"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_index--95a50e"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-eb224d3c.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-eb224d3c.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getResourceIdentifier),
/* harmony export */   b: () => (/* binding */ cloudFileNames),
/* harmony export */   c: () => (/* binding */ cloudFileIcons),
/* harmony export */   d: () => (/* binding */ getCloudOption),
/* harmony export */   e: () => (/* binding */ getProviderOption),
/* harmony export */   f: () => (/* binding */ getDownloadUrl),
/* harmony export */   g: () => (/* binding */ getProvider),
/* harmony export */   h: () => (/* binding */ getOneDriveDownloadUrl),
/* harmony export */   i: () => (/* binding */ getDropBoxDownloadUrl)
/* harmony export */ });
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


function externalRequest(method, contentUrl, body, authorization, contentType) {
  return new Promise((resolve, reject) => {
    const xhttp = new XMLHttpRequest();
    xhttp.open(method, contentUrl, false);
    if (authorization) {
      xhttp.setRequestHeader("Authorization", authorization);
    }
    if (contentType) {
      xhttp.setRequestHeader("Content-type", contentType);
    }
    if (body) {
      xhttp.send(body);
    }
    else {
      xhttp.send();
    }
    const response = JSON.parse(xhttp.responseText);
    //status more than 400 is error
    if (xhttp.status >= 400) {
      reject(JSON.parse(xhttp.responseText));
    }
    resolve(response);
  });
}
function getTokenFromUrl(url, name) {
  return new Promise((resolve, reject) => {
    name = name.replace(/[[]/, "[").replace(/[]]/, "]");
    const regexS = `[?&#]${name}=([^&#]*)`;
    const regex = new RegExp(regexS);
    const results = regex.exec(url);
    if (results == null) {
      reject("InvalidToken");
    }
    else {
      resolve(results[1]);
    }
  });
}
function oauthSignIn(url, portalHostName) {
  return new Promise((resolve, reject) => {
    const currentSourceUrl = `${window.location.protocol}//${window.location.hostname}`;
    const queryString = `?cloudUrl=${url}&currentSourceUrl=${currentSourceUrl}&portalHostName=${portalHostName}`;
    const source = `https://${portalHostName}/home/cloudDriveOauth-callback.html${queryString}`;
    const ifrm = document.createElement("iframe");
    ifrm.src = source;
    ifrm.className = "hide";
    document.body.appendChild(ifrm);
    const eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
    const eventer = window[eventMethod];
    const messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";
    // Listen to message from child window
    eventer(messageEvent, (e) => {
      if (e.origin !== `https://${portalHostName}`) {
        return;
      }
      if (e.data === "popupBlocked" || e.data === "windowClosed") {
        reject(e.data);
      }
      resolve(e.data);
    }, false);
  });
}
const cloudFileIcons = {
  csv: "file-csv",
  excel: "file-excel",
  zip: "file-zip",
  geojson: "file-code",
  sheet: "file-report",
  cad: "file-cad",
  gpx: "file-gpx",
  png: "file-image",
  jpg: "file-image",
  jpeg: "file-image",
  tiff: "file-image",
  gif: "file-image",
  pdf: "file-pdf",
  docx: "file-word"
};
const cloudFileNames = {
  csv: "CSV",
  excel: "Excel",
  zip: "Zip File",
  geojson: "GeoJSON",
  googlesheets: "Google Sheets",
  cad: "CAD",
  gpx: "GPX",
  png: "Image",
  jpg: "Image",
  jpeg: "Image",
  tiff: "Image",
  gif: "Image",
  pdf: "PDF",
  docx: "Microsoft Word",
  pptx: "Microsoft PowerPoint"
};
const cloudFileExtensions = {
  csv: ".csv",
  excel: ".xls",
  zip: ".zip",
  geojson: ".geojson",
  googlesheets: ""
};
function getMimeType(fileName) {
  const parts = fileName.split(".");
  const extension = parts[parts.length - 1].toLowerCase();
  const extensionLookup = {
    xls: "excel",
    xlsx: "excel",
    csv: "csv",
    zip: "zip",
    geojson: "geojson",
    json: "geojson"
  };
  return extensionLookup[extension] || extension;
}

function getDropBoxDownloadUrl(id, token) {
  return `https://content.dropboxapi.com/2/files/download?httpHeaders={"Authorization":"Bearer&#32;${token}","Dropbox-API-Arg":"{\\"path\\":\\"${id}\\"}"}`;
}
class Dropbox {
  constructor() {
    this.nextStart = 0;
  }
  async connect() {
    const { config, portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
    const stateValue = `dropbox${Math.floor(Date.now() / 1000)}`;
    const locale = document.documentElement.lang || "en-US";
    const dropboxOauthUrl = "https://www.dropbox.com/oauth2/authorize";
    const cloudStorageOAuthRedirectUri = `https://${portal.portalHostname}/home/cloudDriveOauth-callback2.html`;
    const url = `${dropboxOauthUrl}?redirect_uri=${cloudStorageOAuthRedirectUri}&response_type=token&client_id=${config.dropboxClientId}&locale=${locale}&state=${stateValue}`;
    return new Promise(async (resolve, reject) => {
      try {
        const signInUrl = await oauthSignIn(url, portal.portalHostname);
        const stateFromUrl = await getTokenFromUrl(signInUrl, "state");
        if (stateValue !== stateFromUrl) {
          reject("invalidState");
        }
        const accessToken = await getTokenFromUrl(signInUrl, "access_token");
        this.token = accessToken;
        resolve(accessToken);
      }
      catch (e) {
        reject(e);
      }
    });
  }
  search(filterValues = {}) {
    const { token } = this;
    return new Promise(async (resolve) => {
      const { searchText, dropdownFilter, next } = filterValues;
      const authorization = `Bearer ${token}`;
      const contentType = "application/json";
      const contentUrl = "https://api.dropboxapi.com/2/files/search";
      const searchInput = searchText ? ` ${searchText}` : "";
      const start = next ? this.nextStart : 0;
      let typeQuery = cloudFileExtensions[dropdownFilter];
      if (dropdownFilter === "excel") {
        typeQuery = "xls";
      }
      const bodyDropboxRequest = `{"path":"","query":"${searchInput} ${typeQuery}","mode": "filename","max_results":10,"start":${start}}`;
      const result = await externalRequest("POST", contentUrl, bodyDropboxRequest, authorization, contentType);
      this.nextStart = result.start;
      const files = result.matches
        .filter((file) => { var _a; return ((_a = file.metadata) === null || _a === void 0 ? void 0 : _a[".tag"]) === "file"; })
        .map(({ metadata: { id, name, size } }) => ({
        id,
        name,
        mimeType: getMimeType(name),
        downloadUrl: `https://content.dropboxapi.com/2/files/download?httpHeaders={"Authorization":"Bearer&#32;${token}","Dropbox-API-Arg":"{\\"path\\":\\"${id}\\"}"}`,
        size
      }));
      resolve({ files, next: !!result.more });
    });
  }
}

/** Google returns an actual mimetype, not just a filename, so we can check and convert to our types */
function lookupMimeType(mimeType) {
  if (mimeType.indexOf("spreadsheetml.sheet") > -1 || mimeType.indexOf("ms-excel") > -1) {
    return "excel";
  }
  if (mimeType.indexOf("application/zip") > -1) {
    return "zip";
  }
  if (mimeType.indexOf("application/octet-stream") > -1 || mimeType.indexOf("application/json") > -1) {
    return "geojson";
  }
  if (mimeType.indexOf("google-apps.spreadsheet") > -1) {
    return "googlesheets";
  }
  if (mimeType.indexOf("text/csv") > -1) {
    return "csv";
  }
  return "zip";
}
const queries = {
  csv: '(mimeType="text/csv")',
  excel: '(mimeType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"ormimeType="application/vnd.ms-excel")',
  zip: '(mimeType="application/x-zip-compressed"ormimeType="application/zip")',
  geojson: '(name contains "json" or name contains "geojson")and(mimeType="application/octet-stream"ormimeType="application/json")',
  googlesheets: `(mimeType="application/vnd.google-apps.spreadsheet")`
};
function getDownloadUrl(id, mimeType, token) {
  const baseUrl = `https://www.googleapis.com/drive/v3/files/${id}`;
  const headers = `&httpHeaders={"Authorization":"Bearer&#32;${token}"}`;
  const sheet = `${baseUrl}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet${headers}`;
  const file = `${baseUrl}?alt=media${headers}`;
  return mimeType.indexOf("google-apps") > -1 || mimeType.indexOf("googlesheets") > -1 ? sheet : file;
}
class GoogleDrive {
  async connect() {
    return new Promise(async (resolve, reject) => {
      const { config, portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
      const portalHostname = portal.portalHostname;
      const locale = document.documentElement.lang || "en-US";
      const stateValue = `google${Math.floor(Date.now() / 1000)}`;
      const googleOauthUrl = "https://accounts.google.com/o/oauth2/v2/auth";
      const googleScope = "https://www.googleapis.com/auth/drive.readonly";
      const cloudStorageOAuthRedirectUri = `https://${portalHostname}/home/cloudDriveOauth-callback2.html`;
      const url = `${googleOauthUrl}?scope=${googleScope}&redirect_uri=${cloudStorageOAuthRedirectUri}&response_type=token&client_id=${config.googleClientId}&hl=${locale}&state=${stateValue}`;
      try {
        const oauthSignInUrl = await oauthSignIn(url, portalHostname);
        const state = await getTokenFromUrl(oauthSignInUrl, "state");
        if (stateValue !== state) {
          reject("invalidState");
        }
        this.token = await getTokenFromUrl(oauthSignInUrl, "access_token");
        resolve(this.token);
      }
      catch (error) {
        reject(error);
      }
    });
  }
  async search(filterValues = {}) {
    return new Promise(async (resolve) => {
      const { searchText, next, dropdownFilter } = filterValues;
      const contentType = "application/json";
      const baseUrl = `https://www.googleapis.com/drive/v3/files?access_token=${this.token}&pageSize=10&fields=incompleteSearch,nextPageToken,files(id,kind,mimeType,name)`;
      const search = searchText ? `name contains '${searchText}' and trashed = false and` : "trashed = false and";
      const filter = queries[dropdownFilter];
      const nextToken = next ? `&pageToken=${this.nextToken}` : "";
      const url = `${baseUrl}&q=${search}${filter}${nextToken}`;
      const result = await externalRequest("GET", url, null, null, contentType);
      this.nextToken = result.nextPageToken;
      const files = result.files.map(({ id, name, mimeType }) => ({
        id,
        name,
        mimeType: lookupMimeType(mimeType),
        downloadUrl: getDownloadUrl(id, mimeType, this.token)
      }));
      resolve({ files, next: !!result.nextPageToken });
    });
  }
}

function getOneDriveDownloadUrl(id, token) {
  const url = `https://graph.microsoft.com/v1.0/me/drive/items/${id}/content?httpHeaders={"Authorization":"Bearer&#32;${token}"}`;
  return url;
}
class OneDrive {
  async connect() {
    return new Promise(async (resolve, reject) => {
      const { config, portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
      const portalHostname = portal.portalHostname;
      const locale = document.documentElement.lang || "en-US";
      const stateValue = `onedrive${Math.floor(Date.now() / 1000)}`;
      const oneDriveOauthUrl = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize";
      const oneDriveScope = "files.read";
      const cloudStorageOAuthRedirectUri = `https://${portalHostname}/home/cloudDriveOauth-callback2.html`;
      const url = `${oneDriveOauthUrl}?scope=${oneDriveScope}&redirect_uri=${cloudStorageOAuthRedirectUri}&response_type=token&client_id=${config.oneDriveClientId}&locale=${locale}&state=${stateValue}`;
      try {
        const oauthSignInUrl = await oauthSignIn(url, portalHostname);
        const state = await getTokenFromUrl(oauthSignInUrl, "state");
        if (stateValue !== state) {
          reject("invalidState");
        }
        this.token = await getTokenFromUrl(oauthSignInUrl, "access_token");
        resolve(this.token);
      }
      catch (error) {
        reject(error);
      }
    });
  }
  search(filterValues = {}) {
    return new Promise(async (resolve) => {
      const { searchText, dropdownFilter, next } = filterValues;
      const authorization = `Bearer ${this.token}`;
      const contentType = "application/json";
      const ext = cloudFileExtensions[dropdownFilter] || "";
      const search = searchText || "";
      const query = `https://graph.microsoft.com/v1.0/me/drive/root/search(q='${search} ${ext}')?select=name,id,file,size&top=10`;
      const url = next ? this.nextLink : query;
      const result = await externalRequest("GET", url, null, authorization, contentType);
      this.nextLink = result["@odata.nextLink"];
      const files = result.value.map(({ size, id, name }) => ({
        size,
        id,
        name,
        mimeType: getMimeType(name),
        downloadUrl: `https://graph.microsoft.com/v1.0/me/drive/items/${id}/content?httpHeaders={"Authorization":"Bearer ${this.token}"}`
      }));
      resolve({ files, next: !!result["@odata.nextLink"] });
    });
  }
}

function getProvider(option) {
  const providers = {
    dropbox: Dropbox,
    "google drive": GoogleDrive,
    onedrive: OneDrive
  };
  return new providers[option]();
}
function getResourceIdentifier(option) {
  const resourceMap = {
    dropbox: "dropBoxConnect",
    "google drive": "googleConnect",
    onedrive: "oneDriveConnect"
  };
  return resourceMap[option];
}
function getProviderOption(option) {
  const providers = {
    dropBoxConnect: Dropbox,
    googleConnect: GoogleDrive,
    oneDriveConnect: OneDrive
  };
  return new providers[option]();
}
function getCloudOption(option) {
  const resourceMap = {
    dropBoxConnect: "dropbox",
    googleConnect: "google drive",
    oneDriveConnect: "onedrive"
  };
  return resourceMap[option];
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21faW5kZXgtLTk1YTUwZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCLElBQUkseUJBQXlCO0FBQ3RGLHFDQUFxQyxJQUFJLG9CQUFvQixpQkFBaUIsa0JBQWtCLGVBQWU7QUFDL0csOEJBQThCLGVBQWUscUNBQXFDLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1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c0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsUUFBUSxFQUFFLElBQUk7QUFDOUY7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxHQUFHLHNCQUFzQiwwQkFBMEIsV0FBVyxFQUFFO0FBQ3hJLE9BQU87QUFDUCxnQkFBZ0IsMENBQTBDO0FBQzFELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtZWIyMjRkM2MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNvbmZpZ1N0YXRlIH0gZnJvbSAnLi9jb25maWctZWI1ZjdkYzIuanMnO1xuXG5mdW5jdGlvbiBleHRlcm5hbFJlcXVlc3QobWV0aG9kLCBjb250ZW50VXJsLCBib2R5LCBhdXRob3JpemF0aW9uLCBjb250ZW50VHlwZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHhodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGh0dHAub3BlbihtZXRob2QsIGNvbnRlbnRVcmwsIGZhbHNlKTtcbiAgICBpZiAoYXV0aG9yaXphdGlvbikge1xuICAgICAgeGh0dHAuc2V0UmVxdWVzdEhlYWRlcihcIkF1dGhvcml6YXRpb25cIiwgYXV0aG9yaXphdGlvbik7XG4gICAgfVxuICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgeGh0dHAuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBjb250ZW50VHlwZSk7XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICB4aHR0cC5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHhodHRwLnNlbmQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhodHRwLnJlc3BvbnNlVGV4dCk7XG4gICAgLy9zdGF0dXMgbW9yZSB0aGFuIDQwMCBpcyBlcnJvclxuICAgIGlmICh4aHR0cC5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICByZWplY3QoSlNPTi5wYXJzZSh4aHR0cC5yZXNwb25zZVRleHQpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VG9rZW5Gcm9tVXJsKHVybCwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tbXS8sIFwiW1wiKS5yZXBsYWNlKC9bXV0vLCBcIl1cIik7XG4gICAgY29uc3QgcmVnZXhTID0gYFs/JiNdJHtuYW1lfT0oW14mI10qKWA7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4Uyk7XG4gICAgY29uc3QgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModXJsKTtcbiAgICBpZiAocmVzdWx0cyA9PSBudWxsKSB7XG4gICAgICByZWplY3QoXCJJbnZhbGlkVG9rZW5cIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXN1bHRzWzFdKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2F1dGhTaWduSW4odXJsLCBwb3J0YWxIb3N0TmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTb3VyY2VVcmwgPSBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX1gO1xuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gYD9jbG91ZFVybD0ke3VybH0mY3VycmVudFNvdXJjZVVybD0ke2N1cnJlbnRTb3VyY2VVcmx9JnBvcnRhbEhvc3ROYW1lPSR7cG9ydGFsSG9zdE5hbWV9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBgaHR0cHM6Ly8ke3BvcnRhbEhvc3ROYW1lfS9ob21lL2Nsb3VkRHJpdmVPYXV0aC1jYWxsYmFjay5odG1sJHtxdWVyeVN0cmluZ31gO1xuICAgIGNvbnN0IGlmcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGlmcm0uc3JjID0gc291cmNlO1xuICAgIGlmcm0uY2xhc3NOYW1lID0gXCJoaWRlXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJtKTtcbiAgICBjb25zdCBldmVudE1ldGhvZCA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gXCJhZGRFdmVudExpc3RlbmVyXCIgOiBcImF0dGFjaEV2ZW50XCI7XG4gICAgY29uc3QgZXZlbnRlciA9IHdpbmRvd1tldmVudE1ldGhvZF07XG4gICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gZXZlbnRNZXRob2QgPT09IFwiYXR0YWNoRXZlbnRcIiA/IFwib25tZXNzYWdlXCIgOiBcIm1lc3NhZ2VcIjtcbiAgICAvLyBMaXN0ZW4gdG8gbWVzc2FnZSBmcm9tIGNoaWxkIHdpbmRvd1xuICAgIGV2ZW50ZXIobWVzc2FnZUV2ZW50LCAoZSkgPT4ge1xuICAgICAgaWYgKGUub3JpZ2luICE9PSBgaHR0cHM6Ly8ke3BvcnRhbEhvc3ROYW1lfWApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGUuZGF0YSA9PT0gXCJwb3B1cEJsb2NrZWRcIiB8fCBlLmRhdGEgPT09IFwid2luZG93Q2xvc2VkXCIpIHtcbiAgICAgICAgcmVqZWN0KGUuZGF0YSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGUuZGF0YSk7XG4gICAgfSwgZmFsc2UpO1xuICB9KTtcbn1cbmNvbnN0IGNsb3VkRmlsZUljb25zID0ge1xuICBjc3Y6IFwiZmlsZS1jc3ZcIixcbiAgZXhjZWw6IFwiZmlsZS1leGNlbFwiLFxuICB6aXA6IFwiZmlsZS16aXBcIixcbiAgZ2VvanNvbjogXCJmaWxlLWNvZGVcIixcbiAgc2hlZXQ6IFwiZmlsZS1yZXBvcnRcIixcbiAgY2FkOiBcImZpbGUtY2FkXCIsXG4gIGdweDogXCJmaWxlLWdweFwiLFxuICBwbmc6IFwiZmlsZS1pbWFnZVwiLFxuICBqcGc6IFwiZmlsZS1pbWFnZVwiLFxuICBqcGVnOiBcImZpbGUtaW1hZ2VcIixcbiAgdGlmZjogXCJmaWxlLWltYWdlXCIsXG4gIGdpZjogXCJmaWxlLWltYWdlXCIsXG4gIHBkZjogXCJmaWxlLXBkZlwiLFxuICBkb2N4OiBcImZpbGUtd29yZFwiXG59O1xuY29uc3QgY2xvdWRGaWxlTmFtZXMgPSB7XG4gIGNzdjogXCJDU1ZcIixcbiAgZXhjZWw6IFwiRXhjZWxcIixcbiAgemlwOiBcIlppcCBGaWxlXCIsXG4gIGdlb2pzb246IFwiR2VvSlNPTlwiLFxuICBnb29nbGVzaGVldHM6IFwiR29vZ2xlIFNoZWV0c1wiLFxuICBjYWQ6IFwiQ0FEXCIsXG4gIGdweDogXCJHUFhcIixcbiAgcG5nOiBcIkltYWdlXCIsXG4gIGpwZzogXCJJbWFnZVwiLFxuICBqcGVnOiBcIkltYWdlXCIsXG4gIHRpZmY6IFwiSW1hZ2VcIixcbiAgZ2lmOiBcIkltYWdlXCIsXG4gIHBkZjogXCJQREZcIixcbiAgZG9jeDogXCJNaWNyb3NvZnQgV29yZFwiLFxuICBwcHR4OiBcIk1pY3Jvc29mdCBQb3dlclBvaW50XCJcbn07XG5jb25zdCBjbG91ZEZpbGVFeHRlbnNpb25zID0ge1xuICBjc3Y6IFwiLmNzdlwiLFxuICBleGNlbDogXCIueGxzXCIsXG4gIHppcDogXCIuemlwXCIsXG4gIGdlb2pzb246IFwiLmdlb2pzb25cIixcbiAgZ29vZ2xlc2hlZXRzOiBcIlwiXG59O1xuZnVuY3Rpb24gZ2V0TWltZVR5cGUoZmlsZU5hbWUpIHtcbiAgY29uc3QgcGFydHMgPSBmaWxlTmFtZS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGV4dGVuc2lvbkxvb2t1cCA9IHtcbiAgICB4bHM6IFwiZXhjZWxcIixcbiAgICB4bHN4OiBcImV4Y2VsXCIsXG4gICAgY3N2OiBcImNzdlwiLFxuICAgIHppcDogXCJ6aXBcIixcbiAgICBnZW9qc29uOiBcImdlb2pzb25cIixcbiAgICBqc29uOiBcImdlb2pzb25cIlxuICB9O1xuICByZXR1cm4gZXh0ZW5zaW9uTG9va3VwW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xufVxuXG5mdW5jdGlvbiBnZXREcm9wQm94RG93bmxvYWRVcmwoaWQsIHRva2VuKSB7XG4gIHJldHVybiBgaHR0cHM6Ly9jb250ZW50LmRyb3Bib3hhcGkuY29tLzIvZmlsZXMvZG93bmxvYWQ/aHR0cEhlYWRlcnM9e1wiQXV0aG9yaXphdGlvblwiOlwiQmVhcmVyJiMzMjske3Rva2VufVwiLFwiRHJvcGJveC1BUEktQXJnXCI6XCJ7XFxcXFwicGF0aFxcXFxcIjpcXFxcXCIke2lkfVxcXFxcIn1cIn1gO1xufVxuY2xhc3MgRHJvcGJveCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmV4dFN0YXJ0ID0gMDtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIGNvbnN0IHN0YXRlVmFsdWUgPSBgZHJvcGJveCR7TWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCl9YDtcbiAgICBjb25zdCBsb2NhbGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyB8fCBcImVuLVVTXCI7XG4gICAgY29uc3QgZHJvcGJveE9hdXRoVXJsID0gXCJodHRwczovL3d3dy5kcm9wYm94LmNvbS9vYXV0aDIvYXV0aG9yaXplXCI7XG4gICAgY29uc3QgY2xvdWRTdG9yYWdlT0F1dGhSZWRpcmVjdFVyaSA9IGBodHRwczovLyR7cG9ydGFsLnBvcnRhbEhvc3RuYW1lfS9ob21lL2Nsb3VkRHJpdmVPYXV0aC1jYWxsYmFjazIuaHRtbGA7XG4gICAgY29uc3QgdXJsID0gYCR7ZHJvcGJveE9hdXRoVXJsfT9yZWRpcmVjdF91cmk9JHtjbG91ZFN0b3JhZ2VPQXV0aFJlZGlyZWN0VXJpfSZyZXNwb25zZV90eXBlPXRva2VuJmNsaWVudF9pZD0ke2NvbmZpZy5kcm9wYm94Q2xpZW50SWR9JmxvY2FsZT0ke2xvY2FsZX0mc3RhdGU9JHtzdGF0ZVZhbHVlfWA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNpZ25JblVybCA9IGF3YWl0IG9hdXRoU2lnbkluKHVybCwgcG9ydGFsLnBvcnRhbEhvc3RuYW1lKTtcbiAgICAgICAgY29uc3Qgc3RhdGVGcm9tVXJsID0gYXdhaXQgZ2V0VG9rZW5Gcm9tVXJsKHNpZ25JblVybCwgXCJzdGF0ZVwiKTtcbiAgICAgICAgaWYgKHN0YXRlVmFsdWUgIT09IHN0YXRlRnJvbVVybCkge1xuICAgICAgICAgIHJlamVjdChcImludmFsaWRTdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IGdldFRva2VuRnJvbVVybChzaWduSW5VcmwsIFwiYWNjZXNzX3Rva2VuXCIpO1xuICAgICAgICB0aGlzLnRva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICAgIHJlc29sdmUoYWNjZXNzVG9rZW4pO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNlYXJjaChmaWx0ZXJWYWx1ZXMgPSB7fSkge1xuICAgIGNvbnN0IHsgdG9rZW4gfSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCB7IHNlYXJjaFRleHQsIGRyb3Bkb3duRmlsdGVyLCBuZXh0IH0gPSBmaWx0ZXJWYWx1ZXM7XG4gICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgY29uc3QgY29udGVudFVybCA9IFwiaHR0cHM6Ly9hcGkuZHJvcGJveGFwaS5jb20vMi9maWxlcy9zZWFyY2hcIjtcbiAgICAgIGNvbnN0IHNlYXJjaElucHV0ID0gc2VhcmNoVGV4dCA/IGAgJHtzZWFyY2hUZXh0fWAgOiBcIlwiO1xuICAgICAgY29uc3Qgc3RhcnQgPSBuZXh0ID8gdGhpcy5uZXh0U3RhcnQgOiAwO1xuICAgICAgbGV0IHR5cGVRdWVyeSA9IGNsb3VkRmlsZUV4dGVuc2lvbnNbZHJvcGRvd25GaWx0ZXJdO1xuICAgICAgaWYgKGRyb3Bkb3duRmlsdGVyID09PSBcImV4Y2VsXCIpIHtcbiAgICAgICAgdHlwZVF1ZXJ5ID0gXCJ4bHNcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHlEcm9wYm94UmVxdWVzdCA9IGB7XCJwYXRoXCI6XCJcIixcInF1ZXJ5XCI6XCIke3NlYXJjaElucHV0fSAke3R5cGVRdWVyeX1cIixcIm1vZGVcIjogXCJmaWxlbmFtZVwiLFwibWF4X3Jlc3VsdHNcIjoxMCxcInN0YXJ0XCI6JHtzdGFydH19YDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4dGVybmFsUmVxdWVzdChcIlBPU1RcIiwgY29udGVudFVybCwgYm9keURyb3Bib3hSZXF1ZXN0LCBhdXRob3JpemF0aW9uLCBjb250ZW50VHlwZSk7XG4gICAgICB0aGlzLm5leHRTdGFydCA9IHJlc3VsdC5zdGFydDtcbiAgICAgIGNvbnN0IGZpbGVzID0gcmVzdWx0Lm1hdGNoZXNcbiAgICAgICAgLmZpbHRlcigoZmlsZSkgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gZmlsZS5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1wiLnRhZ1wiXSkgPT09IFwiZmlsZVwiOyB9KVxuICAgICAgICAubWFwKCh7IG1ldGFkYXRhOiB7IGlkLCBuYW1lLCBzaXplIH0gfSkgPT4gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1pbWVUeXBlOiBnZXRNaW1lVHlwZShuYW1lKSxcbiAgICAgICAgZG93bmxvYWRVcmw6IGBodHRwczovL2NvbnRlbnQuZHJvcGJveGFwaS5jb20vMi9maWxlcy9kb3dubG9hZD9odHRwSGVhZGVycz17XCJBdXRob3JpemF0aW9uXCI6XCJCZWFyZXImIzMyOyR7dG9rZW59XCIsXCJEcm9wYm94LUFQSS1BcmdcIjpcIntcXFxcXCJwYXRoXFxcXFwiOlxcXFxcIiR7aWR9XFxcXFwifVwifWAsXG4gICAgICAgIHNpemVcbiAgICAgIH0pKTtcbiAgICAgIHJlc29sdmUoeyBmaWxlcywgbmV4dDogISFyZXN1bHQubW9yZSB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiogR29vZ2xlIHJldHVybnMgYW4gYWN0dWFsIG1pbWV0eXBlLCBub3QganVzdCBhIGZpbGVuYW1lLCBzbyB3ZSBjYW4gY2hlY2sgYW5kIGNvbnZlcnQgdG8gb3VyIHR5cGVzICovXG5mdW5jdGlvbiBsb29rdXBNaW1lVHlwZShtaW1lVHlwZSkge1xuICBpZiAobWltZVR5cGUuaW5kZXhPZihcInNwcmVhZHNoZWV0bWwuc2hlZXRcIikgPiAtMSB8fCBtaW1lVHlwZS5pbmRleE9mKFwibXMtZXhjZWxcIikgPiAtMSkge1xuICAgIHJldHVybiBcImV4Y2VsXCI7XG4gIH1cbiAgaWYgKG1pbWVUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi96aXBcIikgPiAtMSkge1xuICAgIHJldHVybiBcInppcFwiO1xuICB9XG4gIGlmIChtaW1lVHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpID4gLTEgfHwgbWltZVR5cGUuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgPiAtMSkge1xuICAgIHJldHVybiBcImdlb2pzb25cIjtcbiAgfVxuICBpZiAobWltZVR5cGUuaW5kZXhPZihcImdvb2dsZS1hcHBzLnNwcmVhZHNoZWV0XCIpID4gLTEpIHtcbiAgICByZXR1cm4gXCJnb29nbGVzaGVldHNcIjtcbiAgfVxuICBpZiAobWltZVR5cGUuaW5kZXhPZihcInRleHQvY3N2XCIpID4gLTEpIHtcbiAgICByZXR1cm4gXCJjc3ZcIjtcbiAgfVxuICByZXR1cm4gXCJ6aXBcIjtcbn1cbmNvbnN0IHF1ZXJpZXMgPSB7XG4gIGNzdjogJyhtaW1lVHlwZT1cInRleHQvY3N2XCIpJyxcbiAgZXhjZWw6ICcobWltZVR5cGU9XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwib3JtaW1lVHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbFwiKScsXG4gIHppcDogJyhtaW1lVHlwZT1cImFwcGxpY2F0aW9uL3gtemlwLWNvbXByZXNzZWRcIm9ybWltZVR5cGU9XCJhcHBsaWNhdGlvbi96aXBcIiknLFxuICBnZW9qc29uOiAnKG5hbWUgY29udGFpbnMgXCJqc29uXCIgb3IgbmFtZSBjb250YWlucyBcImdlb2pzb25cIilhbmQobWltZVR5cGU9XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIm9ybWltZVR5cGU9XCJhcHBsaWNhdGlvbi9qc29uXCIpJyxcbiAgZ29vZ2xlc2hlZXRzOiBgKG1pbWVUeXBlPVwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLnNwcmVhZHNoZWV0XCIpYFxufTtcbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKGlkLCBtaW1lVHlwZSwgdG9rZW4pIHtcbiAgY29uc3QgYmFzZVVybCA9IGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlcy8ke2lkfWA7XG4gIGNvbnN0IGhlYWRlcnMgPSBgJmh0dHBIZWFkZXJzPXtcIkF1dGhvcml6YXRpb25cIjpcIkJlYXJlciYjMzI7JHt0b2tlbn1cIn1gO1xuICBjb25zdCBzaGVldCA9IGAke2Jhc2VVcmx9L2V4cG9ydD9taW1lVHlwZT1hcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCR7aGVhZGVyc31gO1xuICBjb25zdCBmaWxlID0gYCR7YmFzZVVybH0/YWx0PW1lZGlhJHtoZWFkZXJzfWA7XG4gIHJldHVybiBtaW1lVHlwZS5pbmRleE9mKFwiZ29vZ2xlLWFwcHNcIikgPiAtMSB8fCBtaW1lVHlwZS5pbmRleE9mKFwiZ29vZ2xlc2hlZXRzXCIpID4gLTEgPyBzaGVldCA6IGZpbGU7XG59XG5jbGFzcyBHb29nbGVEcml2ZSB7XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHsgY29uZmlnLCBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgICAgY29uc3QgcG9ydGFsSG9zdG5hbWUgPSBwb3J0YWwucG9ydGFsSG9zdG5hbWU7XG4gICAgICBjb25zdCBsb2NhbGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyB8fCBcImVuLVVTXCI7XG4gICAgICBjb25zdCBzdGF0ZVZhbHVlID0gYGdvb2dsZSR7TWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCl9YDtcbiAgICAgIGNvbnN0IGdvb2dsZU9hdXRoVXJsID0gXCJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20vby9vYXV0aDIvdjIvYXV0aFwiO1xuICAgICAgY29uc3QgZ29vZ2xlU2NvcGUgPSBcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUucmVhZG9ubHlcIjtcbiAgICAgIGNvbnN0IGNsb3VkU3RvcmFnZU9BdXRoUmVkaXJlY3RVcmkgPSBgaHR0cHM6Ly8ke3BvcnRhbEhvc3RuYW1lfS9ob21lL2Nsb3VkRHJpdmVPYXV0aC1jYWxsYmFjazIuaHRtbGA7XG4gICAgICBjb25zdCB1cmwgPSBgJHtnb29nbGVPYXV0aFVybH0/c2NvcGU9JHtnb29nbGVTY29wZX0mcmVkaXJlY3RfdXJpPSR7Y2xvdWRTdG9yYWdlT0F1dGhSZWRpcmVjdFVyaX0mcmVzcG9uc2VfdHlwZT10b2tlbiZjbGllbnRfaWQ9JHtjb25maWcuZ29vZ2xlQ2xpZW50SWR9JmhsPSR7bG9jYWxlfSZzdGF0ZT0ke3N0YXRlVmFsdWV9YDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9hdXRoU2lnbkluVXJsID0gYXdhaXQgb2F1dGhTaWduSW4odXJsLCBwb3J0YWxIb3N0bmFtZSk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgZ2V0VG9rZW5Gcm9tVXJsKG9hdXRoU2lnbkluVXJsLCBcInN0YXRlXCIpO1xuICAgICAgICBpZiAoc3RhdGVWYWx1ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICByZWplY3QoXCJpbnZhbGlkU3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2tlbiA9IGF3YWl0IGdldFRva2VuRnJvbVVybChvYXV0aFNpZ25JblVybCwgXCJhY2Nlc3NfdG9rZW5cIik7XG4gICAgICAgIHJlc29sdmUodGhpcy50b2tlbik7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBzZWFyY2goZmlsdGVyVmFsdWVzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHsgc2VhcmNoVGV4dCwgbmV4dCwgZHJvcGRvd25GaWx0ZXIgfSA9IGZpbHRlclZhbHVlcztcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICBjb25zdCBiYXNlVXJsID0gYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2RyaXZlL3YzL2ZpbGVzP2FjY2Vzc190b2tlbj0ke3RoaXMudG9rZW59JnBhZ2VTaXplPTEwJmZpZWxkcz1pbmNvbXBsZXRlU2VhcmNoLG5leHRQYWdlVG9rZW4sZmlsZXMoaWQsa2luZCxtaW1lVHlwZSxuYW1lKWA7XG4gICAgICBjb25zdCBzZWFyY2ggPSBzZWFyY2hUZXh0ID8gYG5hbWUgY29udGFpbnMgJyR7c2VhcmNoVGV4dH0nIGFuZCB0cmFzaGVkID0gZmFsc2UgYW5kYCA6IFwidHJhc2hlZCA9IGZhbHNlIGFuZFwiO1xuICAgICAgY29uc3QgZmlsdGVyID0gcXVlcmllc1tkcm9wZG93bkZpbHRlcl07XG4gICAgICBjb25zdCBuZXh0VG9rZW4gPSBuZXh0ID8gYCZwYWdlVG9rZW49JHt0aGlzLm5leHRUb2tlbn1gIDogXCJcIjtcbiAgICAgIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9JnE9JHtzZWFyY2h9JHtmaWx0ZXJ9JHtuZXh0VG9rZW59YDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4dGVybmFsUmVxdWVzdChcIkdFVFwiLCB1cmwsIG51bGwsIG51bGwsIGNvbnRlbnRUeXBlKTtcbiAgICAgIHRoaXMubmV4dFRva2VuID0gcmVzdWx0Lm5leHRQYWdlVG9rZW47XG4gICAgICBjb25zdCBmaWxlcyA9IHJlc3VsdC5maWxlcy5tYXAoKHsgaWQsIG5hbWUsIG1pbWVUeXBlIH0pID0+ICh7XG4gICAgICAgIGlkLFxuICAgICAgICBuYW1lLFxuICAgICAgICBtaW1lVHlwZTogbG9va3VwTWltZVR5cGUobWltZVR5cGUpLFxuICAgICAgICBkb3dubG9hZFVybDogZ2V0RG93bmxvYWRVcmwoaWQsIG1pbWVUeXBlLCB0aGlzLnRva2VuKVxuICAgICAgfSkpO1xuICAgICAgcmVzb2x2ZSh7IGZpbGVzLCBuZXh0OiAhIXJlc3VsdC5uZXh0UGFnZVRva2VuIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE9uZURyaXZlRG93bmxvYWRVcmwoaWQsIHRva2VuKSB7XG4gIGNvbnN0IHVybCA9IGBodHRwczovL2dyYXBoLm1pY3Jvc29mdC5jb20vdjEuMC9tZS9kcml2ZS9pdGVtcy8ke2lkfS9jb250ZW50P2h0dHBIZWFkZXJzPXtcIkF1dGhvcml6YXRpb25cIjpcIkJlYXJlciYjMzI7JHt0b2tlbn1cIn1gO1xuICByZXR1cm4gdXJsO1xufVxuY2xhc3MgT25lRHJpdmUge1xuICBhc3luYyBjb25uZWN0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB7IGNvbmZpZywgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgICAgIGNvbnN0IHBvcnRhbEhvc3RuYW1lID0gcG9ydGFsLnBvcnRhbEhvc3RuYW1lO1xuICAgICAgY29uc3QgbG9jYWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgfHwgXCJlbi1VU1wiO1xuICAgICAgY29uc3Qgc3RhdGVWYWx1ZSA9IGBvbmVkcml2ZSR7TWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCl9YDtcbiAgICAgIGNvbnN0IG9uZURyaXZlT2F1dGhVcmwgPSBcImh0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb21tb24vb2F1dGgyL3YyLjAvYXV0aG9yaXplXCI7XG4gICAgICBjb25zdCBvbmVEcml2ZVNjb3BlID0gXCJmaWxlcy5yZWFkXCI7XG4gICAgICBjb25zdCBjbG91ZFN0b3JhZ2VPQXV0aFJlZGlyZWN0VXJpID0gYGh0dHBzOi8vJHtwb3J0YWxIb3N0bmFtZX0vaG9tZS9jbG91ZERyaXZlT2F1dGgtY2FsbGJhY2syLmh0bWxgO1xuICAgICAgY29uc3QgdXJsID0gYCR7b25lRHJpdmVPYXV0aFVybH0/c2NvcGU9JHtvbmVEcml2ZVNjb3BlfSZyZWRpcmVjdF91cmk9JHtjbG91ZFN0b3JhZ2VPQXV0aFJlZGlyZWN0VXJpfSZyZXNwb25zZV90eXBlPXRva2VuJmNsaWVudF9pZD0ke2NvbmZpZy5vbmVEcml2ZUNsaWVudElkfSZsb2NhbGU9JHtsb2NhbGV9JnN0YXRlPSR7c3RhdGVWYWx1ZX1gO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2F1dGhTaWduSW5VcmwgPSBhd2FpdCBvYXV0aFNpZ25Jbih1cmwsIHBvcnRhbEhvc3RuYW1lKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBnZXRUb2tlbkZyb21Vcmwob2F1dGhTaWduSW5VcmwsIFwic3RhdGVcIik7XG4gICAgICAgIGlmIChzdGF0ZVZhbHVlICE9PSBzdGF0ZSkge1xuICAgICAgICAgIHJlamVjdChcImludmFsaWRTdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2VuID0gYXdhaXQgZ2V0VG9rZW5Gcm9tVXJsKG9hdXRoU2lnbkluVXJsLCBcImFjY2Vzc190b2tlblwiKTtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLnRva2VuKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNlYXJjaChmaWx0ZXJWYWx1ZXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgeyBzZWFyY2hUZXh0LCBkcm9wZG93bkZpbHRlciwgbmV4dCB9ID0gZmlsdGVyVmFsdWVzO1xuICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0aGlzLnRva2VufWA7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgY29uc3QgZXh0ID0gY2xvdWRGaWxlRXh0ZW5zaW9uc1tkcm9wZG93bkZpbHRlcl0gfHwgXCJcIjtcbiAgICAgIGNvbnN0IHNlYXJjaCA9IHNlYXJjaFRleHQgfHwgXCJcIjtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gYGh0dHBzOi8vZ3JhcGgubWljcm9zb2Z0LmNvbS92MS4wL21lL2RyaXZlL3Jvb3Qvc2VhcmNoKHE9JyR7c2VhcmNofSAke2V4dH0nKT9zZWxlY3Q9bmFtZSxpZCxmaWxlLHNpemUmdG9wPTEwYDtcbiAgICAgIGNvbnN0IHVybCA9IG5leHQgPyB0aGlzLm5leHRMaW5rIDogcXVlcnk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleHRlcm5hbFJlcXVlc3QoXCJHRVRcIiwgdXJsLCBudWxsLCBhdXRob3JpemF0aW9uLCBjb250ZW50VHlwZSk7XG4gICAgICB0aGlzLm5leHRMaW5rID0gcmVzdWx0W1wiQG9kYXRhLm5leHRMaW5rXCJdO1xuICAgICAgY29uc3QgZmlsZXMgPSByZXN1bHQudmFsdWUubWFwKCh7IHNpemUsIGlkLCBuYW1lIH0pID0+ICh7XG4gICAgICAgIHNpemUsXG4gICAgICAgIGlkLFxuICAgICAgICBuYW1lLFxuICAgICAgICBtaW1lVHlwZTogZ2V0TWltZVR5cGUobmFtZSksXG4gICAgICAgIGRvd25sb2FkVXJsOiBgaHR0cHM6Ly9ncmFwaC5taWNyb3NvZnQuY29tL3YxLjAvbWUvZHJpdmUvaXRlbXMvJHtpZH0vY29udGVudD9odHRwSGVhZGVycz17XCJBdXRob3JpemF0aW9uXCI6XCJCZWFyZXIgJHt0aGlzLnRva2VufVwifWBcbiAgICAgIH0pKTtcbiAgICAgIHJlc29sdmUoeyBmaWxlcywgbmV4dDogISFyZXN1bHRbXCJAb2RhdGEubmV4dExpbmtcIl0gfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIob3B0aW9uKSB7XG4gIGNvbnN0IHByb3ZpZGVycyA9IHtcbiAgICBkcm9wYm94OiBEcm9wYm94LFxuICAgIFwiZ29vZ2xlIGRyaXZlXCI6IEdvb2dsZURyaXZlLFxuICAgIG9uZWRyaXZlOiBPbmVEcml2ZVxuICB9O1xuICByZXR1cm4gbmV3IHByb3ZpZGVyc1tvcHRpb25dKCk7XG59XG5mdW5jdGlvbiBnZXRSZXNvdXJjZUlkZW50aWZpZXIob3B0aW9uKSB7XG4gIGNvbnN0IHJlc291cmNlTWFwID0ge1xuICAgIGRyb3Bib3g6IFwiZHJvcEJveENvbm5lY3RcIixcbiAgICBcImdvb2dsZSBkcml2ZVwiOiBcImdvb2dsZUNvbm5lY3RcIixcbiAgICBvbmVkcml2ZTogXCJvbmVEcml2ZUNvbm5lY3RcIlxuICB9O1xuICByZXR1cm4gcmVzb3VyY2VNYXBbb3B0aW9uXTtcbn1cbmZ1bmN0aW9uIGdldFByb3ZpZGVyT3B0aW9uKG9wdGlvbikge1xuICBjb25zdCBwcm92aWRlcnMgPSB7XG4gICAgZHJvcEJveENvbm5lY3Q6IERyb3Bib3gsXG4gICAgZ29vZ2xlQ29ubmVjdDogR29vZ2xlRHJpdmUsXG4gICAgb25lRHJpdmVDb25uZWN0OiBPbmVEcml2ZVxuICB9O1xuICByZXR1cm4gbmV3IHByb3ZpZGVyc1tvcHRpb25dKCk7XG59XG5mdW5jdGlvbiBnZXRDbG91ZE9wdGlvbihvcHRpb24pIHtcbiAgY29uc3QgcmVzb3VyY2VNYXAgPSB7XG4gICAgZHJvcEJveENvbm5lY3Q6IFwiZHJvcGJveFwiLFxuICAgIGdvb2dsZUNvbm5lY3Q6IFwiZ29vZ2xlIGRyaXZlXCIsXG4gICAgb25lRHJpdmVDb25uZWN0OiBcIm9uZWRyaXZlXCJcbiAgfTtcbiAgcmV0dXJuIHJlc291cmNlTWFwW29wdGlvbl07XG59XG5cbmV4cG9ydCB7IGdldFJlc291cmNlSWRlbnRpZmllciBhcyBhLCBjbG91ZEZpbGVOYW1lcyBhcyBiLCBjbG91ZEZpbGVJY29ucyBhcyBjLCBnZXRDbG91ZE9wdGlvbiBhcyBkLCBnZXRQcm92aWRlck9wdGlvbiBhcyBlLCBnZXREb3dubG9hZFVybCBhcyBmLCBnZXRQcm92aWRlciBhcyBnLCBnZXRPbmVEcml2ZURvd25sb2FkVXJsIGFzIGgsIGdldERyb3BCb3hEb3dubG9hZFVybCBhcyBpIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=