"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-d8fe77"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-filter_4.entry.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-filter_4.entry.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_filter: () => (/* binding */ ArcgisFilter),
/* harmony export */   arcgis_filter_condition: () => (/* binding */ ArcgisFilterCondition),
/* harmony export */   arcgis_filter_expression: () => (/* binding */ ArcgisFilterExpression),
/* harmony export */   arcgis_filter_unique_list: () => (/* binding */ ArcgisFilterUniqueList)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./commonFunctions-5262b094.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-5262b094.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./commonEnums-f98a323c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-f98a323c.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */









const CSS$3 = {
  panel: "panel",
  hook: "hook",
  removeFilter: "remove-filter",
  matchExpressionMsg: "match-expression-msg",
  matchExpressionDropdown: "match-expression-dropdown",
  logicalOperator: "match-type"
};

var logicalOperators;
(function (logicalOperators) {
  logicalOperators["AND"] = "and";
  logicalOperators["OR"] = "or";
})(logicalOperators || (logicalOperators = {}));
var simpleFieldTypes;
(function (simpleFieldTypes) {
  simpleFieldTypes["NUMBER"] = "number";
  simpleFieldTypes["STRING"] = "string";
  simpleFieldTypes["DATE"] = "date";
  simpleFieldTypes["DATE_ONLY"] = "date-only";
  simpleFieldTypes["OID"] = "oid";
  simpleFieldTypes["GUID"] = "guid";
  simpleFieldTypes["DOMAIN"] = "domain";
})(simpleFieldTypes || (simpleFieldTypes = {}));
var status;
(function (status) {
  status["MISSING"] = "missing";
  status["IN_PROGRESS"] = "inProgress";
  status["SUCCESS"] = "success";
  status["FAILED"] = "failed";
})(status || (status = {}));
var timeUnits;
(function (timeUnits) {
  timeUnits["MINUTE"] = "minute";
  timeUnits["HOUR"] = "hour";
  timeUnits["DAY"] = "day";
  timeUnits["WEEK"] = "week";
  timeUnits["MONTH"] = "month";
  timeUnits["YEAR"] = "year";
})(timeUnits || (timeUnits = {}));
var timeRange;
(function (timeRange) {
  timeRange[timeRange["MINUTE"] = 60000] = "MINUTE";
  timeRange[timeRange["HOUR"] = 3600000] = "HOUR";
  timeRange[timeRange["DAY"] = 86400000] = "DAY";
  timeRange[timeRange["WEEK"] = 604800000] = "WEEK";
  timeRange[timeRange["MONTH"] = 2592000000] = "MONTH";
  timeRange[timeRange["YEAR"] = 31104000000] = "YEAR";
})(timeRange || (timeRange = {}));
var scales;
(function (scales) {
  scales["SMALL"] = "s";
  scales["MEDIUM"] = "m";
  scales["LARGE"] = "l";
})(scales || (scales = {}));
/**
 * Returns true if the value is defined
 * @param value - value to check
 */
function isDefined(value) {
  return value !== undefined && value !== null;
}
function isEffectEmpty(featureEffect) {
  if (!featureEffect || !featureEffect.filter) {
    return true;
  }
  const checkProps = ["geometry", "objectIds", "timeExtent", "where"];
  return !checkProps.some((prop) => featureEffect.filter.hasOwnProperty(prop) && !!featureEffect.filter[prop]);
}
function checkConfig(props) {
  var _a, _b;
  const { layer, mapImageSublayer } = props;
  const url = layer.url;
  props.supportsStandardizedQuery =
    "version" in layer && layer.version >= 10.2 && !!((_b = (_a = layer.capabilities) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.supportsStandardizedQueriesOnly);
  props.supportedSqlParserVersion =
    layer.type === "feature" &&
      props.supportsStandardizedQuery &&
      layer.sourceJSON.sqlParserVersion &&
      layer.sourceJSON.sqlParserVersion !== "ES_10.6.1";
  if (!url || mapImageSublayer) {
    props.isHosted = false;
    return;
  }
  // hosted feature service: http://services.arcgis.com/f7ee40282cbc40998572834591021976/arcgis/rest/services/StateCapitals/FeatureServer
  // new amazon hosted feature service: http://features.arcgis.com/e2ea3c31dd80478689ce70c4fb3380c5/arcgis/rest/services/santaclara_fs/FeatureServer
  // hosted tiled service: https://tilesdevext.arcgis.com/tiles/fa019fbbfbb845d08cc9f0acde6dd8af/arcgis/rest/services/States/MapServer
  // uploaded KML service: http://www.arcgis.com/sharing/content/items/ecddddaf6b174d7ca94816ac397d9b48/data
  // secure service: http://www.arcgis.com/sharing/rest/services/aee2a3d9d15f406cb21576d92ea1316e/MapServer
  const arcgis = ".arcgis.com/", services = "//services", tiles = "//tiles", features = "//features", locationservices = "//locationservices", velocityUs = "//us-iot", velocityEu = "//eu-iot";
  //sharing = (new dojo._Url(esriGeowConfig.restBaseUrl)).authority,
  //isSingleTenant = false; //(false === esriGeowConfig.isMultiTenant);
  // CR #238,732 - only consider locally hosted if the restBaseUrl is on same domain as url
  // and esriGeowConfig.self.supportsHostedServices flag is enabled
  const isAGOL = url.indexOf(arcgis) !== -1, isHostedServer = url.indexOf(services) !== -1 ||
    url.indexOf(tiles) !== -1 ||
    url.indexOf(features) !== -1 ||
    url.indexOf(locationservices) !== -1 ||
    url.indexOf(velocityUs) !== -1 ||
    url.indexOf(velocityEu) !== -1, isLocallyHosted = false; //((isDefined(esriGeowConfig.self) && esriGeowConfig.self.supportsHostedServices) && (url.indexOf(sharing) !== -1 && !isSingleTenant));
  //isProxyService = !isHostedServer && arcgis; // if the service requires non-AGOL credentials
  props.isHosted = (isAGOL && isHostedServer) || (!isAGOL && isLocallyHosted);
}
function fixUIDs(expressions) {
  if (!expressions || !expressions.length) {
    return expressions;
  }
  return expressions.map((expression, idx) => {
    if (expression.uid === `expression-${idx}`) {
      // no change to uid
      return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map((condition, idx2) => {
          const newUid = `condition-${idx}-${idx2}`;
          if (condition.uid === newUid) {
            return condition;
          }
          else {
            return Object.assign(Object.assign({}, condition), { uid: newUid });
          }
        }) });
    }
    else {
      return Object.assign(Object.assign({}, expression), { uid: `expression-${idx}`, expressionIndex: idx, conditions: expression.conditions.map((condition, idx2) => {
          const newUid = `condition-${idx}-${idx2}`;
          if (condition.uid === newUid) {
            return condition;
          }
          else {
            return Object.assign(Object.assign({}, condition), { uid: newUid });
          }
        }) });
    }
  });
}

function utcToDatePicker(value, timeZone) {
  // date is in UTC
  // we need a map timezone
  let str;
  if (!timeZone || timeZone === "system") {
    const diff = new Date().getTimezoneOffset();
    str = new Date(value - diff * 60000).toISOString();
  }
  else if (timeZone === "unknown") {
    str = new Date(value).toISOString();
  }
  else {
    const diff = new Date().getTimezoneOffset();
    const mapDateStr = new Date(value).toLocaleString("en-US", { timeZone });
    str = new Date(new Date(mapDateStr).getTime() - diff * 60000).toISOString();
  }
  //console.log("utcToDatePicker", value, " - ", new Date(value).toISOString(), " -> ", str);
  return str;
}
function datePickerToUTC(date, timeZone) {
  // date is in map timezone
  // we need a UTC UNIX timestamp
  let value;
  if (!timeZone || timeZone === "system") {
    // add difference between local time and UTC
    value = date.getTime() + date.getTimezoneOffset() * 60000;
  }
  else if (timeZone === "unknown") {
    // take what you get
    value = date.getTime();
  }
  else {
    // add difference between map time and UTC
    const diff = new Date(date.toLocaleString("en-US", { timeZone: "utc" })).getTime() -
      new Date(date.toLocaleString("en-US", { timeZone })).getTime();
    value = date.getTime() + diff;
  }
  //console.log("datePickerToUTC", date.toISOString(), " -> ", new Date(value).toISOString());
  return value;
}
function mapTZToUTC(value, timeZone) {
  if (!value) {
    return value;
  }
  // value is in map timezone
  // we need a UTC timestamp
  let newValue;
  if (!timeZone || timeZone === "system") {
    // add difference between local time and UTC
    const date = new Date();
    newValue = value + date.getTimezoneOffset() * 60000;
  }
  else if (timeZone === "unknown") {
    // take what you get
    newValue = value;
  }
  else {
    // add difference between map time and UTC
    const date = new Date();
    const diff = new Date(date.toLocaleString("en-US", { timeZone: "utc" })).getTime() -
      new Date(date.toLocaleString("en-US", { timeZone })).getTime();
    newValue = value + diff;
  }
  //console.log("mapTZToUTC", value, " - ", new Date(value).toISOString(), " - ", new Date(newValue).toISOString());
  return newValue;
}
function getDateDisplayString(value, timeZone, intl, dateFormat) {
  let str;
  if (timeZone === "unknown") {
    str = intl.formatDate(value, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(dateFormat || "short-date-short-time")), { timeZone: "utc", timeZoneName: "shortOffset" }));
  }
  else {
    // known issues with formatting it-CH
    str = intl.formatDate(value, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(dateFormat || "short-date-short-time")), { timeZone }));
  }
  //console.log("getDateDisplayString", value, " - ", new Date(value).toISOString(), " -> ", str);
  return str;
}

//import Domain from "esri/layers/support/Domain";
async function collectFieldDomains(props) {
  // we do not support subTypes ...
  const { layer, fields } = props;
  if (layer.type !== "feature") {
    return;
  }
  const typeIdField = layer.typeIdField;
  const types = layer.types;
  fields.forEach(async (featureField) => {
    const fieldName = featureField.layerField.name;
    const fieldDomain = featureField.layerField.domain;
    const filterField = getFieldInfo(fieldName, props);
    if (!filterField) {
      // maybe geometry field
      return;
    }
    if (typeIdField && types) {
      // layer has types
      if (typeIdField === fieldName) {
        // this is the field with the types
        filterField.fieldDomains = types.map((type) => {
          // fake coded Values
          return {
            code: type.id,
            name: type.name
          };
        });
        getSimpleFieldType(props, filterField);
      }
      else {
        // field does not have types; look farther inside the types
        filterField.fieldDomains = [];
        types.forEach((type) => {
          var _a, _b;
          if (!type.domains || !type.domains[fieldName] || type.domains[fieldName].type === "inherited") {
            const domain /*Domain*/ = fieldDomain;
            if (domain === null || domain === void 0 ? void 0 : domain.codedValues) {
              domain.codedValues.forEach(async (codedValue) => {
                let found = false;
                filterField.fieldDomains.forEach((codedVal) => {
                  if (codedVal.code === codedValue.code) {
                    found = true;
                    if (`, ${codedVal.name},`.indexOf(`, ${codedValue.name},`) === -1) {
                      codedVal.name += `, ${codedValue.name}`;
                    }
                  }
                });
                if (!found) {
                  const [esriLang] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
                  filterField.fieldDomains.push(esriLang.clone(codedValue));
                }
              });
            }
          }
          else if ((_b = (_a = type.domains) === null || _a === void 0 ? void 0 : _a[fieldName]) === null || _b === void 0 ? void 0 : _b.codedValues) {
            type.domains[fieldName].codedValues.forEach(async (codedValue) => {
              let found = false;
              filterField.fieldDomains.forEach((codedVal) => {
                if (codedVal.code === codedValue.code) {
                  found = true;
                  if (`, ${codedVal.name},`.indexOf(`, ${codedValue.name},`) === -1) {
                    codedVal.name += `, ${codedValue.name}`;
                  }
                }
              });
              if (!found) {
                const [esriLang] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
                filterField.fieldDomains.push(esriLang.clone(codedValue));
              }
            });
            //filterField.fieldDomains = filterField.fieldDomains.concat(type.domains[field.name].codedValues);
            //} else {
            /* ... wrong, it's not the typeIdField ...
              // fake coded values
              filterField.fieldDomains.push({
                code: type.id,
                name: type.name
              });
            */
            // field has no domains
            // delete filterField.fieldDomains;
          }
        });
      }
      if (!hasFieldDomains(filterField) && (fieldDomain === null || fieldDomain === void 0 ? void 0 : fieldDomain.codedValues)) {
        const [esriLang] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
        filterField.fieldDomains = esriLang.clone(fieldDomain.codedValues);
      }
    }
    else if (fieldDomain === null || fieldDomain === void 0 ? void 0 : fieldDomain.codedValues) {
      // domains directly on the layer field
      filterField.fieldDomains = fieldDomain.codedValues;
    }
    // update in case it has changed
    getSimpleFieldType(props, filterField);
  });
}
function getDecodedValue(value, filterField) {
  const codedValues = filterField.fieldDomains;
  if (codedValues) {
    let label = "";
    for (let i = 0; i < codedValues.length; i++) {
      const codedValue = codedValues[i];
      if (codedValue.code == value) {
        label += (label.length ? " | " : "") + codedValue.name;
      }
    }
    return label;
  }
  // did not find it
  return value;
}
function hasFieldDomains(filterField) {
  var _a;
  return (_a = filterField.fieldDomains) === null || _a === void 0 ? void 0 : _a.length;
}

async function buildFilterFields(props) {
  const { layer, mapImageSublayer, featureReduction } = props;
  if (!layer) {
    return;
  }
  if (featureReduction) {
    return buildFeatureReductionFields(props);
  }
  let layerFields = layer.fields;
  // https://demographics9dev.arcgis.com/arcgis/rest/services/USA_Demographics_and_Boundaries_2019/MapServer
  if (mapImageSublayer &&
    mapImageSublayer.layer.portalItem &&
    mapImageSublayer.layer.url.indexOf("https://demographics") > -1 &&
    mapImageSublayer.layer.url.indexOf(".arcgis.com") > -1) {
    const portalItem = mapImageSublayer.layer.portalItem;
    try {
      const response = await portalItem.fetchData();
      if (response === null || response === void 0 ? void 0 : response.thematicGroup) {
        const fieldNames = response.thematicGroup.fieldNames;
        if (fieldNames) {
          layerFields = layerFields.filter((layerField) => fieldNames.indexOf(layerField.name) > -1);
        }
      }
      return buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields);
    }
    catch (error) {
      // assume there is none
      return buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields);
    }
  }
  else {
    return buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields);
  }
}
function buildFeatureFilterFieldsAfterThematicGroupCheck(props, layerFields) {
  if (!props.fields || !props.fields.length) {
    props.fields = [];
    props.stringFieldsCount = 0;
    props.dateFieldsCount = 0;
    props.numberFieldsCount = 0;
    if (!props.supportsStandardizedQuery) {
      // NOTE: client side filter effect only supports sql92 and needs the timestamp in the query
      // therfore we disable data fields for services without standardizedQuery support
      layerFields = layerFields.filter((layerField) => ["date", "date-only"].indexOf(layerField.type) === -1);
    }
    let fieldInfos = [];
    if (props.layer.type !== "subtype-group") {
      const { popupTemplate } = props.layer;
      fieldInfos = popupTemplate ? popupTemplate.fieldInfos : [];
    }
    layerFields.forEach((layerField) => {
      const list = fieldInfos
        ? fieldInfos.filter((fieldInfo) => fieldInfo.fieldName === layerField.name)
        : null;
      const label = (list === null || list === void 0 ? void 0 : list.length) ? list[0].label : null;
      const filterField = {
        layerField: layerField,
        statisticsStatus: status.MISSING,
        histogramStatus: status.MISSING,
        uniqueValuesStatus: status.MISSING,
        partialUniqueValues: false,
        label: label || layerField.alias || layerField.name
      };
      getSimpleFieldType(props, filterField);
      if (filterField.simpleFieldType) {
        props.fields.push(filterField);
      } // else can't use field for filter
    });
    collectFieldDomains(props);
  }
}
async function buildFeatureReductionFields(props) {
  var _a;
  const { layer, view } = props;
  if (layer.type === "imagery" || layer.type === "subtype-group") {
    return;
  }
  if (!((_a = props.fields) === null || _a === void 0 ? void 0 : _a.length)) {
    props.fields = [];
    props.stringFieldsCount = 0;
    props.dateFieldsCount = 0;
    props.numberFieldsCount = 1;
    let count = 5000;
    let avg = 10;
    let featureCount = 0;
    try {
      featureCount = await (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_4__.g)(layer, view);
      count = featureCount ? Math.min(Math.max(10, Math.ceil(featureCount / 4)), 5000) : 5000;
      avg = featureCount && featureCount >= 1000 ? 100 : 10;
    }
    catch (_b) { }
    const [Field] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/layers/support/Field"]);
    const featureReduction = layer.featureReduction;
    props.fields = [];
    featureReduction.fields.forEach((aggregateField) => {
      const isCount = aggregateField.statisticType === "count";
      const layerField = aggregateField.onStatisticField &&
        layer.fields.find((field) => field.name === aggregateField.onStatisticField);
      if ((!aggregateField.onStatisticField && isCount) || layerField) {
        const filterField = {
          layerField: new Field({
            name: aggregateField.name,
            alias: aggregateField.alias || aggregateField.name,
            type: (layerField === null || layerField === void 0 ? void 0 : layerField.type) || "integer"
          }),
          statisticsStatus: isCount ? status.SUCCESS : status.MISSING,
          statistics: isCount ? { min: 1, max: count, avg } : undefined,
          histogramStatus: isCount ? status.FAILED : status.MISSING,
          uniqueValuesStatus: status.MISSING,
          partialUniqueValues: false,
          label: aggregateField.alias || aggregateField.name
          //simpleFieldType: ...
        };
        getSimpleFieldType(props, filterField);
        props.fields.push(filterField);
      }
    });
  }
}
function getFieldInfo(fieldName, props) {
  const { fields } = props;
  for (let i = 0; i < fields.length; i++) {
    const filterField = fields[i];
    if (filterField.layerField.name === fieldName) {
      return filterField;
    }
  }
  return undefined;
}
function getDefaultField(props) {
  const { fields, defaultFieldName } = props;
  if (defaultFieldName) {
    const defaultField = fields.find((field) => field.layerField.name === defaultFieldName);
    if (defaultField) {
      return defaultField;
    }
  }
  let firstNumberField;
  for (let i = 0; i < fields.length; i++) {
    const field = fields[i];
    if (field.simpleFieldType &&
      [simpleFieldTypes.OID, simpleFieldTypes.GUID, simpleFieldTypes.DATE].indexOf(field.simpleFieldType) === -1) {
      if (field.simpleFieldType === simpleFieldTypes.NUMBER && !firstNumberField) {
        firstNumberField = field;
      }
      else {
        // string field
        return field;
      }
    }
  }
  // we didn't find a string field
  if (firstNumberField) {
    return firstNumberField;
  }
  return fields[0];
}
function getDefaultValues(props, filterField, operator) {
  var _a;
  const { strings } = props;
  const result = {};
  const statistics = filterField.statistics;
  if (!statistics) {
    if (filterField.simpleFieldType === simpleFieldTypes.STRING &&
      filterField.uniqueValuesStatus === status.SUCCESS &&
      ((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length) &&
      [strings.operators.stringOperatorIs, strings.operators.stringOperatorIsNot].indexOf(operator) > -1) {
      result.value = filterField.uniqueValueInfos[0].value;
    }
    return result;
  }
  if (isInTheLastOperator(props, operator)) {
    const now = new Date().getTime();
    const range = Math.abs(now - statistics.avg);
    if (range > 2 * timeRange.YEAR) {
      result.value = Math.round(range / timeRange.YEAR);
      result.unit = timeUnits.YEAR;
    }
    else {
      if (range > 2 * timeRange.MONTH) {
        result.value = Math.round(range / timeRange.MONTH);
        result.unit = timeUnits.MONTH;
      }
      else {
        if (range > 2 * timeRange.WEEK) {
          result.value = Math.round(range / timeRange.WEEK);
          result.unit = timeUnits.WEEK;
        }
        else {
          if (range > 2 * timeRange.DAY) {
            result.value = Math.round(range / timeRange.DAY);
            result.unit = timeUnits.DAY;
          }
          else {
            if (range > 2 * timeRange.HOUR) {
              result.value = Math.round(range / timeRange.HOUR);
              result.unit = timeUnits.HOUR;
            }
            else {
              result.value = Math.round(range / timeRange.MINUTE);
              result.unit = timeUnits.MINUTE;
            }
          }
        }
      }
    }
  }
  else if (isBetweenOperator(props, operator)) {
    result.value = fieldTypeRound(statistics.avg, props, filterField);
    result.value2 = fieldTypeRound(statistics.max, props, filterField);
  }
  else {
    result.value = fieldTypeRound(statistics.avg, props, filterField);
  }
  return result;
}
function getSignificantDigits(props, filterField) {
  const { layer } = props;
  let significantDigits = 2;
  const popupTemplate = layer.type !== "subtype-group" && layer.popupTemplate;
  if (popupTemplate) {
    const popFieldInfos = popupTemplate.fieldInfos.filter((fieldInfo) => fieldInfo.fieldName === filterField.layerField.name);
    if (popFieldInfos === null || popFieldInfos === void 0 ? void 0 : popFieldInfos.length) {
      const popFieldInfo = popFieldInfos[0];
      if (popFieldInfo.format && isDefined(popFieldInfo.format.places)) {
        significantDigits = popFieldInfo.format.places;
      }
    }
  }
  return significantDigits;
}
function roundToSignificantDigits(value, props, filterField) {
  const significantDigits = getSignificantDigits(props, filterField);
  const factor = Math.pow(10, significantDigits);
  return isDefined(value) && Math.round(value * factor) / factor;
}
function fieldTypeRound(value, props, filterField) {
  return (isDefined(value) &&
    (isIntegerType(filterField) ? Math.round(value) : roundToSignificantDigits(value, props, filterField)));
}
function getSimpleFieldType(props, featureFilterField) {
  switch (featureFilterField.layerField.type) {
    case "string":
      featureFilterField.simpleFieldType = simpleFieldTypes.STRING;
      props.stringFieldsCount++;
      break;
    case "date":
      if (hasFieldDomains(featureFilterField)) {
        featureFilterField.simpleFieldType = simpleFieldTypes.STRING;
        props.stringFieldsCount++;
      }
      else {
        featureFilterField.simpleFieldType = simpleFieldTypes.DATE;
        props.dateFieldsCount++;
      }
      break;
    case "date-only":
      featureFilterField.simpleFieldType = simpleFieldTypes.DATE_ONLY;
      break;
    case "oid":
      featureFilterField.simpleFieldType = simpleFieldTypes.OID;
      break;
    case "guid":
      featureFilterField.simpleFieldType = simpleFieldTypes.GUID;
      break;
    case "small-integer":
    case "big-integer":
    case "integer":
    case "single":
    case "double":
    case "long":
      if (hasFieldDomains(featureFilterField)) {
        featureFilterField.simpleFieldType = simpleFieldTypes.STRING;
        props.stringFieldsCount++;
      }
      else {
        featureFilterField.simpleFieldType = simpleFieldTypes.NUMBER;
        props.numberFieldsCount++;
      }
      break;
  }
}
function isNumberType(featureFilterField) {
  return (["small-integer", "big-integer", "integer", "single", "double", "long"].indexOf(featureFilterField.layerField.type) > -1);
}
function isIntegerType(featureFilterField) {
  return ["small-integer", "big-integer", "integer", "long"].indexOf(featureFilterField.layerField.type) > -1;
}
function isFloatType(featureFilterField) {
  return ["single", "double"].indexOf(featureFilterField.layerField.type) > -1;
}
function isDateType(featureFilterField) {
  return ["date"].indexOf(featureFilterField.layerField.type) > -1;
}
function isDateOnlyType(featureFilterField) {
  return ["date-only"].indexOf(featureFilterField.layerField.type) > -1;
}
function supportsHistogram(fieldName, operator, props) {
  const { strings } = props;
  const filterField = getFieldInfo(fieldName, props);
  // TODO - also check field value type ?
  if (filterField &&
    filterField.simpleFieldType &&
    filterField.statisticsStatus !== "failed" &&
    (([simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) > -1 &&
      [
        strings.operators.numberOperatorIs,
        strings.operators.dateOperatorIsOn,
        // don't remember the reason we hid isNotOn for date fields in the past, so enabling it again
        strings.operators.dateOperatorIsNotOn,
        strings.operators.numberOperatorIsNot,
        strings.operators.numberOperatorIsLessThan,
        strings.operators.dateOperatorIsBefore,
        strings.operators.numberOperatorIsGreaterThan,
        strings.operators.dateOperatorIsAfter,
        strings.operators.numberOperatorIsAtMost,
        strings.operators.numberOperatorIsAtLeast,
        strings.operators.numberOperatorIsBetween,
        strings.operators.dateOperatorIsBetween,
        strings.operators.numberOperatorIsNotBetween,
        strings.operators.dateOperatorIsNotBetween
      ].indexOf(operator) > -1))) {
    return true;
  }
  return false;
}
function createIndexes(props) {
  const { layer, expressions, strings } = props;
  if (layer.type !== "feature") {
    return;
  }
  const { portalItem, sourceJSON } = layer;
  if (!portalItem) {
    return;
  }
  const { typeKeywords, itemControl, portal } = portalItem;
  const isPortal = portal.isPortal;
  const isHosted = (typeKeywords === null || typeKeywords === void 0 ? void 0 : typeKeywords.indexOf("Hosted Service")) > -1;
  const isOnlineLocationTrackingService = !isPortal && (typeKeywords === null || typeKeywords === void 0 ? void 0 : typeKeywords.indexOf("Location Tracking Service")) > -1;
  if (!isHosted || isOnlineLocationTrackingService) {
    return;
  }
  if (portal.user && itemControl && ["admin", "update"].indexOf(itemControl) > -1) {
    const i18nOps = strings.operators;
    const invalidOperators = [
      i18nOps.stringOperatorEndsWith,
      i18nOps.stringOperatorContains,
      i18nOps.stringOperatorDoesNotContain
    ];
    const fieldNames = [];
    const addFieldToList = (condition) => {
      const fieldName = condition.fieldName;
      if (!fieldName) {
        return;
      }
      const filterField = getFieldInfo(fieldName, props);
      const isValidField = !(((filterField === null || filterField === void 0 ? void 0 : filterField.simpleFieldType) === simpleFieldTypes.STRING ||
        (filterField === null || filterField === void 0 ? void 0 : filterField.simpleFieldType) === simpleFieldTypes.GUID) &&
        (filterField.layerField.length > 4000 || invalidOperators.indexOf(condition.operator) > -1));
      if (isValidField && fieldNames.indexOf(fieldName) === -1) {
        fieldNames.push(fieldName);
      }
    };
    expressions === null || expressions === void 0 ? void 0 : expressions.forEach((expression) => expression.conditions.forEach((condition) => addFieldToList(condition)));
    const json = {
      indexes: []
    };
    sourceJSON.indexes = sourceJSON.indexes || [];
    fieldNames.forEach((fieldName) => {
      if (!sourceJSON.indexes.some((index) => index.fields === fieldName)) {
        // index doesn't exist yet
        json.indexes.push({
          name: `${fieldName}_Index`,
          fields: fieldName,
          isUnique: false,
          isAscending: true,
          description: `${fieldName}_Index`
        });
      }
    });
    if (json.indexes.length) {
      executeCreateIndexes(json, props);
    }
  }
}
async function executeCreateIndexes(json, props) {
  var _a, _b;
  const { layer, parentServiceUrl } = props;
  if (layer.type !== "feature") {
    return;
  }
  const { portalItem, sourceJSON } = layer;
  const { typeKeywords, portal } = portalItem;
  const isView = typeKeywords.includes("View Service");
  const [IdentityManager, esriRequest] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/identity/IdentityManager", "esri/request"]);
  if (isView && !parentServiceUrl) {
    // need to use the original service url
    var relatedUrl = `${portal.restUrl}/content/items/${portalItem.id}/relatedItems?relationshipType=Service2Service&direction=reverse`;
    const credential = await IdentityManager.getCredential(portal.restUrl, { prompt: false });
    const result = await esriRequest(relatedUrl, { query: { f: "json", token: credential.token } });
    if ((_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.total) {
      result.data.relatedItems
        .filter((item) => item.typeKeywords.includes("Hosted Service"))
        .forEach((item) => {
        props.parentServiceUrl = item.url;
        executeCreateIndexes(json, props);
      });
    }
    return;
  }
  const adminUrl = (parentServiceUrl || layer.url).replace("/rest/services", "/rest/admin/services");
  const url = `${adminUrl}/${layer.layerId}/addToDefinition`;
  const credential = await IdentityManager.getCredential(layer.url, { prompt: false });
  const content = {
    f: "json",
    addToDefinition: JSON.stringify(json),
    async: !portal.isPortal,
    token: credential.token
  };
  const result = await esriRequest(url, {
    query: content,
    method: "post"
  });
  if (portal.isPortal) {
    sourceJSON.indexes = sourceJSON.indexes || [];
    sourceJSON.indexes = sourceJSON.indexes.concat(json.indexes);
  }
  else {
    try {
      await pollForStatus((_b = result === null || result === void 0 ? void 0 : result.data) === null || _b === void 0 ? void 0 : _b.statusURL, {
        f: "json",
        token: credential.token
      }, esriRequest);
      sourceJSON.indexes = sourceJSON.indexes || [];
      sourceJSON.indexes = sourceJSON.indexes.concat(json.indexes);
    }
    catch (e) {
      // not a big problem if it didn't work
    }
  }
}
const pollForStatus = async (url, params, esriRequest) => {
  var _a;
  if (!url) {
    throw new Error("pollForStatus: no status URL");
  }
  const pendingStatuses = ["processing", "partial", "Pending", "InProgress"];
  const successStatuses = ["completed", "Completed"];
  // Keep polling status until either completed or failed
  try {
    // Do failures report as success (status 200)? May need to manually throw error on status check failure
    const statusResponse = await esriRequest(url, { query: params });
    const status = (_a = statusResponse === null || statusResponse === void 0 ? void 0 : statusResponse.data) === null || _a === void 0 ? void 0 : _a.status;
    if (pendingStatuses.includes(status)) {
      await (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_5__.t)(500);
      return pollForStatus(url, params, esriRequest);
    }
    else if (successStatuses.includes(status)) {
      return statusResponse;
    }
    else {
      throw statusResponse;
    }
  }
  catch (e) {
    console.error(e);
    throw e;
  }
};

function buildOperatorsList(props) {
  const { layer, featureReduction, strings } = props;
  const isStreamLayer = layer.declaredClass === "esri.layers.StreamLayer";
  const isImageryLayer = layer.declaredClass === "esri.layers.ImageryLayer";
  if (!props.operators) {
    props.operators = {};
    props.operators[simpleFieldTypes.STRING] = [];
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorIs
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorIsNot
    });
    if (!isStreamLayer && !isImageryLayer) {
      props.operators[simpleFieldTypes.STRING].push({
        name: strings.operators.stringOperatorIncludes
      });
      props.operators[simpleFieldTypes.STRING].push({
        name: strings.operators.stringOperatorExcludes
      });
    }
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorStartsWith
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorEndsWith
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorContains
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorDoesNotContain
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorIsBlank
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorIsNotBlank
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorIsEmpty
    });
    props.operators[simpleFieldTypes.STRING].push({
      name: strings.operators.stringOperatorIsNotEmpty
    });
    props.operators[simpleFieldTypes.DATE] = [];
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsOn
    });
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsNotOn
    });
    /* if (!isStreamLayer) {
      props.operators[simpleFieldTypes.DATE].push({
        name: strings.operators.numberOperatorIncludes
      });
      props.operators[simpleFieldTypes.DATE].push({
        name: strings.operators.numberOperatorExcludes
      });
    } */
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsBefore
    });
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsAfter
    });
    if (props.isHosted || props.supportedSqlParserVersion) {
      // || layer.version >= 10.21) {
      // We don't know if CURRENT_TIMESTAMP is in UTC for other databases.
      props.operators[simpleFieldTypes.DATE].push({
        name: strings.operators.dateOperatorInTheLast
      });
      props.operators[simpleFieldTypes.DATE].push({
        name: strings.operators.dateOperatorNotInTheLast
      });
    }
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsBetween
    });
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsNotBetween
    });
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsBlank
    });
    props.operators[simpleFieldTypes.DATE].push({
      name: strings.operators.dateOperatorIsNotBlank
    });
    props.operators[simpleFieldTypes.DATE_ONLY] = [];
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsOn
    });
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsNotOn
    });
    /* if (!isStreamLayer) {
      props.operators[simpleFieldTypes.DATE_ONLY].push({
        name: strings.operators.dateOperatorIncludes
      });
      props.operators[simpleFieldTypes.DATE_ONLY].push({
        name: strings.operators.dateOperatorExcludes
      });
    } */
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsBefore
    });
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsAfter
    });
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsBetween
    });
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsNotBetween
    });
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsBlank
    });
    props.operators[simpleFieldTypes.DATE_ONLY].push({
      name: strings.operators.dateOperatorIsNotBlank
    });
    props.operators[simpleFieldTypes.NUMBER] = [];
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIs
    });
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIsNot
    });
    if (!featureReduction && !isStreamLayer && !isImageryLayer) {
      props.operators[simpleFieldTypes.NUMBER].push({
        name: strings.operators.numberOperatorIncludes
      });
      props.operators[simpleFieldTypes.NUMBER].push({
        name: strings.operators.numberOperatorExcludes
      });
    }
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIsAtLeast
    });
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIsLessThan
    });
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIsAtMost
    });
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIsGreaterThan
    });
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIsBetween
    });
    props.operators[simpleFieldTypes.NUMBER].push({
      name: strings.operators.numberOperatorIsNotBetween
    });
    if (!featureReduction) {
      props.operators[simpleFieldTypes.NUMBER].push({
        name: strings.operators.numberOperatorIsBlank
      });
      props.operators[simpleFieldTypes.NUMBER].push({
        name: strings.operators.numberOperatorIsNotBlank
      });
    }
    props.operators[simpleFieldTypes.DOMAIN] = [];
    props.operators[simpleFieldTypes.DOMAIN].push({
      name: strings.operators.stringOperatorIs
    });
    props.operators[simpleFieldTypes.DOMAIN].push({
      name: strings.operators.stringOperatorIsNot
    });
    if (!isStreamLayer && !isImageryLayer && !isImageryLayer) {
      props.operators[simpleFieldTypes.DOMAIN].push({
        name: strings.operators.stringOperatorIncludes
      });
      props.operators[simpleFieldTypes.DOMAIN].push({
        name: strings.operators.stringOperatorExcludes
      });
    }
    props.operators[simpleFieldTypes.DOMAIN].push({
      name: strings.operators.stringOperatorIsBlank
    });
    props.operators[simpleFieldTypes.DOMAIN].push({
      name: strings.operators.stringOperatorIsNotBlank
    });
    props.operators[simpleFieldTypes.DOMAIN].push({
      name: strings.operators.stringOperatorIsEmpty
    });
    props.operators[simpleFieldTypes.DOMAIN].push({
      name: strings.operators.stringOperatorIsNotEmpty
    });
  }
}
function getDefaultOperator(props, featureFilterField) {
  const { strings, defaultOperator } = props;
  if (featureFilterField.layerField.name === "cluster_count") {
    return strings.operators.numberOperatorIsGreaterThan;
  }
  switch (featureFilterField.layerField.type) {
    case "string":
      return strings.operators.stringOperatorIs;
    case "date":
    case "date-only":
      if (hasFieldDomains(featureFilterField)) {
        return strings.operators.stringOperatorIs;
      }
      else if (defaultOperator) {
        switch (defaultOperator) {
          case ">":
          case ">=":
            return strings.operators.dateOperatorIsAfter;
          case "<":
          case "<=":
            return strings.operators.dateOperatorIsBefore;
          default:
            return strings.operators.dateOperatorIsOn;
        }
      }
      else {
        return strings.operators.dateOperatorIsBefore;
      }
    case "oid":
      return strings.operators.numberOperatorIs;
    case "guid":
      return strings.operators.numberOperatorIs;
    case "small-integer":
    case "big-integer":
    case "integer":
    case "single":
      if (hasFieldDomains(featureFilterField)) {
        return strings.operators.stringOperatorIs;
      }
      else if (defaultOperator) {
        switch (defaultOperator) {
          case ">":
            return strings.operators.numberOperatorIsGreaterThan;
          case ">=":
            return strings.operators.numberOperatorIsAtLeast;
          case "<":
            return strings.operators.numberOperatorIsLessThan;
          case "<=":
            return strings.operators.numberOperatorIsAtMost;
          default:
            return strings.operators.numberOperatorIs;
        }
      }
      else {
        return strings.operators.numberOperatorIs;
      }
    case "double":
    case "long":
      if (hasFieldDomains(featureFilterField)) {
        return strings.operators.stringOperatorIs;
      }
      else if (defaultOperator) {
        switch (defaultOperator) {
          case ">":
            return strings.operators.numberOperatorIsGreaterThan;
          case ">=":
            return strings.operators.numberOperatorIsAtLeast;
          case "<":
            return strings.operators.numberOperatorIsLessThan;
          case "<=":
            return strings.operators.numberOperatorIsAtMost;
          default:
            return strings.operators.numberOperatorIs;
        }
      }
      else {
        return strings.operators.numberOperatorIsAtLeast;
      }
    default:
      return strings.operators.stringOperatorIs;
  }
}
function isBetweenOperator(props, operator) {
  const { strings } = props;
  if (operator &&
    [
      strings.operators.numberOperatorIsBetween,
      strings.operators.numberOperatorIsNotBetween,
      strings.operators.dateOperatorIsBetween,
      strings.operators.dateOperatorIsNotBetween
    ].indexOf(operator) > -1) {
    return true;
  }
  return false;
}
function isBlankOperator(props, operator) {
  const { strings } = props;
  if (operator &&
    [
      strings.operators.stringOperatorIsBlank,
      strings.operators.stringOperatorIsNotBlank,
      strings.operators.numberOperatorIsBlank,
      strings.operators.numberOperatorIsNotBlank,
      strings.operators.dateOperatorIsBlank,
      strings.operators.dateOperatorIsNotBlank
    ].indexOf(operator) > -1) {
    return true;
  }
  return false;
}
function isEmptyOperator(props, operator) {
  const { strings } = props;
  if (operator &&
    [strings.operators.stringOperatorIsEmpty, strings.operators.stringOperatorIsNotEmpty].indexOf(operator) > -1) {
    return true;
  }
  return false;
}
function isListOperator(props, operator) {
  const { strings } = props;
  if (operator &&
    [
      strings.operators.stringOperatorIncludes,
      strings.operators.stringOperatorExcludes,
      strings.operators.numberOperatorIncludes,
      strings.operators.numberOperatorExcludes
    ].indexOf(operator) > -1) {
    return true;
  }
  return false;
}
function isIncludesOperator(props, operator) {
  const { strings } = props;
  if (operator &&
    [strings.operators.stringOperatorIncludes, strings.operators.numberOperatorIncludes].indexOf(operator) > -1) {
    return true;
  }
  return false;
}
function isExcludesOperator(props, operator) {
  const { strings } = props;
  if (operator &&
    [strings.operators.stringOperatorExcludes, strings.operators.numberOperatorExcludes].indexOf(operator) > -1) {
    return true;
  }
  return false;
}
function isInTheLastOperator(props, operator) {
  const { strings } = props;
  if (operator &&
    [strings.operators.dateOperatorInTheLast, strings.operators.dateOperatorNotInTheLast].indexOf(operator) > -1) {
    return true;
  }
  return false;
}
function getIncludesOperator(props, filterField) {
  const { strings } = props;
  switch (filterField.simpleFieldType) {
    case "string":
    case "domain":
      return strings.operators.stringOperatorIncludes;
    case "number":
    case "oid":
    case "guid":
      return strings.operators.numberOperatorIncludes;
    default:
      return strings.operators.stringOperatorIncludes;
  }
}
function getExcludesOperator(props, filterField) {
  const { strings } = props;
  switch (filterField.simpleFieldType) {
    case "string":
      return strings.operators.stringOperatorExcludes;
    case "number":
    case "oid":
    case "guid":
      return strings.operators.numberOperatorExcludes;
    //case "date":
    //case "date-only":
    //  return strings.operators.dateOperatorExcludes;
    default:
      return strings.operators.stringOperatorExcludes;
  }
}
function getOperator$1(props, oldFilterField, newFilterField, oldOperator) {
  if (oldFilterField.simpleFieldType !== newFilterField.simpleFieldType) {
    if (isIncludesOperator(props, oldOperator) && newFilterField.simpleFieldType !== simpleFieldTypes.DATE) {
      return getIncludesOperator(props, newFilterField);
    }
    else if (isExcludesOperator(props, oldOperator)) {
      return getExcludesOperator(props, newFilterField);
    }
    else {
      return getDefaultOperator(props, newFilterField);
    }
  }
  return oldOperator;
}

//import * as number from "dojo/number";
//import * as locale from "dojo/date/locale";
const dayInMS = 24 * 60 * 60 * 1000 - 1000;
function createWhereClause(props) {
  let whereClause = "";
  if (!props.expressions || !props.expressions.length) {
    return null;
  }
  let join = "";
  let successfulExpressions = 0;
  for (let i = 0; i < props.expressions.length; i++) {
    const expr = props.expressions[i];
    const str = createExpressionWhereClause(expr, props);
    if (str.length) {
      if (successfulExpressions === 0) {
        whereClause = str;
      }
      else if (successfulExpressions === 1) {
        join = ` ${props.logicalOperatorForExpressions === logicalOperators.OR ? "OR" : "AND"} `;
        whereClause = `(${whereClause})${join}(${str})`;
      }
      else {
        whereClause += `${join}(${str})`;
      }
      successfulExpressions++;
    }
  }
  return whereClause.length ? whereClause : null;
}
function createExpressionWhereClause(expression, props) {
  let exprWhereClause = "";
  if (expression.conditions.length === 1) {
    exprWhereClause = createConditionWhereClause(expression.conditions[0], props);
  }
  else {
    let join = "";
    for (let i = 0; i < expression.conditions.length; i++) {
      const cond = expression.conditions[i];
      const condWhereClause = createConditionWhereClause(cond, props);
      if (condWhereClause.length) {
        exprWhereClause += join + condWhereClause;
        join = ` ${expression.logicalOperatorForConditions === logicalOperators.OR ? "OR" : "AND"} `;
      }
    }
  }
  return exprWhereClause;
}
function createConditionWhereClause(condition, props) {
  const { strings } = props;
  const fieldName = condition.fieldName;
  const operator = condition.operator;
  let value = condition.value;
  let value2 = condition.value2;
  let values = condition.values || [];
  const unit = condition.unit;
  const fieldObject = getFieldInfo(fieldName, props);
  if (!fieldObject) {
    return "";
  }
  if (isBetweenOperator(props, operator) && !isDefined(value2)) {
    return "";
  }
  else if (isListOperator(props, operator) && !values.length) {
    return "";
  }
  else if (isInTheLastOperator(props, operator) && !isDefined(value)) {
    return "";
  }
  else if (!isDefined(value) &&
    !values.length &&
    !isBlankOperator(props, operator) &&
    !isEmptyOperator(props, operator)) {
    return "";
  }
  /* if (isListOperator(operator) && fieldObject.simpleFieldType === simpleFieldTypes.DATE) {
    // max one value; we can't support IN
    value = values?.[0];
  } */
  let whereClause = "";
  if (fieldObject.simpleFieldType === simpleFieldTypes.STRING ||
    fieldObject.simpleFieldType === simpleFieldTypes.GUID) {
    let prefix = "";
    if (isDefined(value) && props.isHosted) {
      if (containsNonLatinCharacter(value)) {
        prefix = "N";
      }
    }
    // e.g. coded value domains
    const isNumber = isNumberType(fieldObject);
    const str = value === null || value === void 0 ? void 0 : value.toString().replace(/\'/g, "''");
    switch (condition.operator) {
      case strings.operators.stringOperatorIs: {
        const pStr = `${prefix}'${str}'`;
        whereClause = `${fieldName} = ${isNumber ? value : pStr}`;
        break;
      }
      case strings.operators.stringOperatorIsNot: {
        const pStr = `${prefix}'${str}'`;
        whereClause = `${fieldName} <> ${isNumber ? value : pStr}`;
        break;
      }
      case strings.operators.stringOperatorStartsWith:
        whereClause = `${fieldName} LIKE ${prefix}'${str}%'`;
        break;
      case strings.operators.stringOperatorEndsWith:
        whereClause = `${fieldName} LIKE ${prefix}'%${str}'`;
        break;
      case strings.operators.stringOperatorContains:
        whereClause = `${fieldName} LIKE ${prefix}'%${str}%'`;
        break;
      case strings.operators.stringOperatorDoesNotContain:
        whereClause = `${fieldName} NOT LIKE ${prefix}'%${str}%'`;
        break;
      case strings.operators.stringOperatorIncludes: {
        whereClause = `${fieldName} IN (${values
          .map((value) => isNumber
          ? value
          : `${containsNonLatinCharacter(value) ? "N" : ""}'${value === null || value === void 0 ? void 0 : value.toString().replace(/\'/g, "''")}'`)
          .toString()})`;
        break;
      }
      case strings.operators.stringOperatorExcludes: {
        whereClause = `${fieldName} NOT IN (${values
          .map((value) => isNumber
          ? value
          : `${containsNonLatinCharacter(value) ? "N" : ""}'${value === null || value === void 0 ? void 0 : value.toString().replace(/\'/g, "''")}'`)
          .toString()})`;
        break;
      }
      case strings.operators.stringOperatorIsBlank:
        whereClause = `${fieldName} IS NULL`;
        break;
      case strings.operators.stringOperatorIsNotBlank:
        whereClause = `${fieldName} IS NOT NULL`;
        break;
      case strings.operators.stringOperatorIsEmpty:
        whereClause = `${fieldName} = ''`;
        break;
      case strings.operators.stringOperatorIsNotEmpty:
        //whereClause = `${fieldName} <> '' OR ${fieldName} IS NULL`;
        whereClause = `${fieldName} <> ''`; // not returning NULL values
        break;
    }
  }
  else if (fieldObject.simpleFieldType === simpleFieldTypes.NUMBER ||
    fieldObject.simpleFieldType === simpleFieldTypes.OID) {
    switch (operator) {
      case strings.operators.numberOperatorIs:
        whereClause = `${fieldName} = ${value}`;
        break;
      case strings.operators.numberOperatorIsNot:
        whereClause = `${fieldName} <> ${value}`;
        break;
      case strings.operators.numberOperatorIsAtLeast:
        whereClause = `${fieldName} >= ${value}`;
        break;
      case strings.operators.numberOperatorIsLessThan:
        whereClause = `${fieldName} < ${value}`;
        break;
      case strings.operators.numberOperatorIsAtMost:
        whereClause = `${fieldName} <= ${value}`;
        break;
      case strings.operators.numberOperatorIsGreaterThan:
        whereClause = `${fieldName} > ${value}`;
        break;
      case strings.operators.numberOperatorIsBetween:
        whereClause = `${fieldName} BETWEEN ${value} AND ${value2}`;
        break;
      case strings.operators.numberOperatorIsNotBetween:
        whereClause = `${fieldName} NOT BETWEEN ${value} AND ${value2}`;
        break;
      case strings.operators.numberOperatorIncludes:
        whereClause = `${fieldName} IN (${values.toString()})`;
        break;
      case strings.operators.numberOperatorExcludes:
        whereClause = `${fieldName} NOT IN (${values.toString()})`;
        break;
      case strings.operators.numberOperatorIsBlank:
        whereClause = `${fieldName} IS NULL`;
        break;
      case strings.operators.numberOperatorIsNotBlank:
        whereClause = `${fieldName} IS NOT NULL`;
        break;
    }
  }
  else if (fieldObject.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
    // date
    // NOTE: client side filter effect only supports sql92 and needs the date in the query
    // therfore we disable data fields for services without standardizedQuery support
    const datestmp = !props.supportsStandardizedQuery ? "" : "DATE ";
    if (typeof value === "number") {
      const date = new Date(value);
      value = `${date.getFullYear()}-${date.getMonth() < 9 ? "0" : ""}${date.getMonth() + 1}-${date.getDate() < 10 ? "0" : ""}${date.getDate()}`;
    }
    if (isDefined(value2) && typeof value2 === "number") {
      const date = new Date(value2);
      value2 = `${date.getFullYear()}-${date.getMonth() < 9 ? "0" : ""}${date.getMonth() + 1}-${date.getDate() < 10 ? "0" : ""}${date.getDate()}`;
    }
    switch (operator) {
      case strings.operators.dateOperatorIsOn:
      case strings.operators.numberOperatorIncludes:
        whereClause = `${fieldName} = ${datestmp}'${value}'`;
        break;
      case strings.operators.dateOperatorIsNotOn:
      case strings.operators.numberOperatorExcludes:
        whereClause = `${fieldName} <> ${datestmp}'${value}'`;
        break;
      case strings.operators.dateOperatorIsBefore:
        whereClause = `${fieldName} < ${datestmp}'${value}'`;
        break;
      case strings.operators.dateOperatorIsAfter:
        whereClause = `${fieldName} > ${datestmp}'${value}'`;
        break;
      case strings.operators.dateOperatorIsBetween:
        whereClause = `${fieldName} BETWEEN ${datestmp}'${value}' AND ${datestmp}'${value2}'`;
        break;
      case strings.operators.dateOperatorIsNotBetween:
        whereClause = `${fieldName} NOT BETWEEN ${datestmp}'${value}' AND ${datestmp}'${value2}'`;
        break;
      /* case strings.operators.numberOperatorIncludes:
      case strings.operators.numberOperatorExcludes:
        let dateValuesString = "";
        let comma = "";
        dateValues.forEach((dateValue: string) => {
          dateValuesString += `${comma}${datestmp}'${dateValue}'`;
          comma = ",";
        });
        if (operator === strings.operators.numberOperatorIncludes) {
          whereClause = `${fieldName} IN (${dateValuesString})`;
        } else {
          whereClause = `${fieldName} NOT IN (${dateValuesString})`;
        }
        break; */
      case strings.operators.dateOperatorIsBlank:
        whereClause = `${fieldName} IS NULL`;
        break;
      case strings.operators.dateOperatorIsNotBlank:
        whereClause = `${fieldName} IS NOT NULL`;
        break;
    }
  }
  else {
    // date
    // NOTE: client side filter effect only supports sql92 and needs the timestamp in the query
    // therfore we disable data fields for services without standardizedQuery support
    let dateValue = getDateObject(value);
    let dateValue2 = getDateObject(value2);
    /* const dateValues =
      values &&
      values.map((value: string | number | Date) => {
        return formatDate(getDateObject(value));
      }); */
    const tmstmp = !props.supportsStandardizedQuery ? "" : "timestamp ";
    const dateStr = formatDate(dateValue);
    const datePlusOneStr = formatDate(addDay(dateValue));
    const date2PlusOneStr = formatDate(addDay(dateValue2));
    switch (operator) {
      case strings.operators.dateOperatorIsOn:
        whereClause = `${fieldName} BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${datePlusOneStr}'`;
        break;
      case strings.operators.dateOperatorIsNotOn:
        whereClause = `${fieldName} NOT BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${datePlusOneStr}'`;
        break;
      case strings.operators.dateOperatorIsBefore:
        whereClause = `${fieldName} < ${tmstmp}'${dateStr}'`;
        break;
      case strings.operators.dateOperatorIsAfter:
        whereClause = `${fieldName} > ${tmstmp}'${datePlusOneStr}'`;
        break;
      case strings.operators.dateOperatorInTheLast:
        whereClause = `${fieldName} BETWEEN ${createInTheLastQueryPart(props, value, unit)}`;
        break;
      case strings.operators.dateOperatorNotInTheLast:
        whereClause = `${fieldName} NOT BETWEEN ${createInTheLastQueryPart(props, value, unit)}`;
        break;
      case strings.operators.dateOperatorIsBetween:
        whereClause = `${fieldName} BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${date2PlusOneStr}'`;
        break;
      case strings.operators.dateOperatorIsNotBetween:
        whereClause = `${fieldName} NOT BETWEEN ${tmstmp}'${dateStr}' AND ${tmstmp}'${date2PlusOneStr}'`;
        break;
      /* case strings.operators.dateOperatorIncludes:
      case strings.operators.dateOperatorExcludes:
        let dateValuesString = "";
        let comma = "";
        dateValues.forEach((dateValue: string) => {
          dateValuesString += `${comma}${tmstmp}'${dateValue}'`;
          comma = ",";
        });
        if (operator === strings.operators.dateOperatorIncludes) {
          whereClause = `${fieldName} IN (${dateValuesString})`;
        } else {
          whereClause = `${fieldName} NOT IN (${dateValuesString})`;
        }
        break; */
      case strings.operators.dateOperatorIsBlank:
        whereClause = `${fieldName} IS NULL`;
        break;
      case strings.operators.dateOperatorIsNotBlank:
        whereClause = `${fieldName} IS NOT NULL`;
        break;
    }
  }
  return whereClause;
}
function getDateObject(value) {
  if (typeof value === "number") {
    // value is a UTC timestamp; returns a date object in local time
    return new Date(value);
  }
  else if (typeof value === "string") {
    // from date picker...
    // e.g. "7/7/2010 12:00:00 AM" returned by generateRenderer
    // in DE value is "02.03.12" for March second; new Date(value) then returns Feb 3rd
    //        value = new Date(value);
    return parseFriendlyDate(value);
  }
  else if (value) {
    // Date object; in local time
    return value;
  }
}
function formatDate(date) {
  // service needs UTC time, but the user looks at local time in the UI
  // date is in local time
  // returns the string in UTC time
  // e.g. 2017-07-07 09:05:19
  if (!date) {
    return "";
  }
  const yearStr = `${date.getUTCFullYear()}`;
  let monthStr = `${date.getUTCMonth() + 1}`;
  if (monthStr.length === 1) {
    monthStr = `0${monthStr}`;
  }
  let dateStr = `${date.getUTCDate()}`;
  if (dateStr.length === 1) {
    dateStr = `0${dateStr}`;
  }
  let hoursStr = `${date.getUTCHours()}`;
  if (hoursStr.length === 1) {
    hoursStr = `0${hoursStr}`;
  }
  let minStr = `${date.getUTCMinutes()}`;
  if (minStr.length === 1) {
    minStr = `0${minStr}`;
  }
  let secStr = `${date.getSeconds()}`;
  if (secStr.length === 1) {
    secStr = `0${secStr}`;
  }
  return `${yearStr}-${monthStr}-${dateStr} ${hoursStr}:${minStr}:${secStr}`;
}
function createInTheLastQueryPart(props, value, unit) {
  if (props.supportedSqlParserVersion) {
    let days = 0;
    if (unit === "year") {
      // not accurate ...
      days = value * 365;
      return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
    }
    else if (unit === "month") {
      // not accurate ...
      days = value * 30;
      return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
    }
    else if (unit === "week") {
      days = value * 7;
      return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
    }
    else if (unit === "day") {
      days = value;
      return `CURRENT_TIMESTAMP - INTERVAL '${days}' DAY AND CURRENT_TIMESTAMP`;
    }
    else if (unit === "hour") {
      return `CURRENT_TIMESTAMP - INTERVAL '${value}' HOUR AND CURRENT_TIMESTAMP`;
    }
    else {
      // minutes
      return `CURRENT_TIMESTAMP - INTERVAL '${value}' MINUTE AND CURRENT_TIMESTAMP`;
    }
  }
  else {
    let days = 0;
    if (unit === "year") {
      // not accurate ...
      days = value * 365;
    }
    else if (unit === "month") {
      // not accurate ...
      days = value * 30;
    }
    else if (unit === "week") {
      days = value * 7;
    }
    else if (unit === "day") {
      days = value;
    }
    else if (unit === "hour") {
      days = value / 24;
    }
    else {
      // minute
      days = value / (24 * 60);
    }
    return `CURRENT_TIMESTAMP - ${days} AND CURRENT_TIMESTAMP`;
  }
}
function parseFriendlyDate(value) {
  // en: 3/2/15 de: 02.03.15 - for march second
  /* return locale.parse(value, {
    formatLength: "short",
    selector: "date"
  }); */
  return new Date(value);
}
function parseDate(strValue) {
  // strValue is in UTC time, but the user looks at local time in the UI
  // we know strValue looks like this 'yyyy-MM-dd HH:mm:ss' (e.g. '2013-03-01 00:00:00')
  /*
  var date = new Date();
  date.setUTCFullYear(Number(strValue.substring(0, 4)));
  date.setUTCMonth(parseInt(strValue.substring(5, 7)) - 1);
  date.setUTCDate(Number(strValue.substring(8, 10)));
  date.setUTCHours(Number(strValue.substring(11, 13)));
  date.setUTCMinutes(Number(strValue.substring(14, 16)));
  date.setSeconds(Number(strValue.substring(17, 19)));
  return date;
  */
  let date = new Date(strValue);
  let utcDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
  //console.log("parseDate", strValue, " - ", utcDate);
  return utcDate;
}
function addDay(date) {
  if (date) {
    return new Date(date.getTime() + dayInMS);
  }
}
function subtractDay(date) {
  return new Date(date.getTime() - dayInMS);
}
function containsNonLatinCharacter(value) {
  if (typeof value === "number") {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    if (value.charCodeAt(i) > 255) {
      return true;
    }
  }
  return false;
}

//import * as WhereClause from "esri/core/sql/WhereClause";
//const dayInMS: number = 24 * 60 * 60 * 1000 - 1000; // 1 sec less than 1 day
async function parseWhereClause(whereClause, props) {
  const { layer } = props;
  // does not call reject()
  if (!whereClause || !whereClause.length) {
    /* const defaultField = getDefaultField(state);
    state.expressions = [
      {
        conditions: [
          {
            fieldName: defaultField.layerField.name,
            operator: getDefaultOperator(defaultField),
            value: null
          }
        ]
      }
    ];
    state.expressions = fixUIDs(state.expressions); */
    return true;
  }
  else {
    const [esriSQL] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/sql"]);
    // ImageryLayer has fieldsIndex too, it's not documented yet. Casting as any for now.
    return esriSQL.parseWhereClause(whereClause, layer.fieldsIndex).then((clause /* WhereClause */) => {
      if (!clause.isStandardized) {
        // uses some non standard functions. invalid
        return false;
      }
      props.expressions = [
        {
          conditions: []
        }
      ];
      const success = parseClause(clause.parseTree, props);
      props.expressions = fixUIDs(props.expressions);
      /*
        console.log(
          "SQLParser:",
          success,
          whereClause,
          clause,
          props.logicalOperatorForExpressions,
          props.expressions
        );
      */
      return success;
    }, (error) => {
      console.error("SQLParser - error:", error);
      return false;
    });
  }
}
function parseClause(parseTree, props) {
  if (!props.expressions) {
    return false;
  }
  if (isCondition(parseTree)) {
    return parseBinaryExpr(parseTree, props.expressions[0].conditions, props);
  }
  else {
    props.logicalOperatorForExpressions = getLogicalOperator(parseTree);
    return parseBinaryExpr(parseTree, props.expressions[0], props);
  }
}
function parseBinaryExpr(obj, stateObj, props) {
  var _a;
  const { strings } = props;
  // left, operator, right, type
  if (isCondition(obj)) {
    // stateObj is list of conditions
    if (obj.left.type === "column-reference") {
      const fieldObject = getFieldInfo(obj.left.column, props);
      const operator = fieldObject ? getOperator(props, obj.operator, fieldObject, obj.right) : undefined;
      if (fieldObject && operator) {
        let condition;
        if (obj.right.type === "null") {
          // IS NULL / IS NOT NULL
          condition = {
            fieldName: fieldObject.layerField.name,
            operator: operator
          };
        }
        else if (obj.right.type === "column-reference") {
          // we no longer support field to field filters
          // -> error
          return false;
        }
        else if (obj.right.type === "expression-list" && isListOperator(props, operator)) {
          // IN, NOT IN
          condition = {
            fieldName: fieldObject.layerField.name,
            operator,
            values: obj.right.value.map((val) => val.value)
          };
        }
        else if (obj.right.type === "expression-list" && isInTheLastOperator(props, operator)) {
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP";
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <days> DAY AND CURRENT_TIMESTAMP";
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <hours> HOUR AND CURRENT_TIMESTAMP";
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <minutes> MINUTE AND CURRENT_TIMESTAMP";
          const result = parseInTheLast(obj);
          if (!result) {
            return false;
          }
          condition = {
            fieldName: fieldObject.layerField.name,
            operator,
            value: result.value,
            unit: result.unit
          };
        }
        else if (obj.right.type === "expression-list" && isBetweenOperator(props, operator)) {
          // BETWEEN, NOT BETWEEN
          if (isDateType(fieldObject)) {
            // value: "2000-09-14 06:26:36"
            const date1 = parseDate(obj.right.value[0].value);
            const date2 = parseDate(obj.right.value[1].value);
            const date2Sub = subtractDay(date2);
            if (Math.abs(date2Sub.getTime() - date1.getTime()) < 1000) {
              // within 1 day
              condition = {
                fieldName: fieldObject.layerField.name,
                operator: operator === strings.operators.dateOperatorIsBetween
                  ? strings.operators.dateOperatorIsOn
                  : strings.operators.dateOperatorIsNotOn,
                value: date1.getTime()
              };
            }
            else {
              condition = {
                fieldName: fieldObject.layerField.name,
                operator,
                value: date1.getTime(),
                value2: date2.getTime()
              };
            }
          }
          else if (isDateOnlyType(fieldObject)) {
            // value: "2000-09-14"
            const date1 = parseDate(obj.right.value[0].value);
            const date2 = parseDate(obj.right.value[1].value);
            const offset = date1.getTimezoneOffset() * 60000;
            condition = {
              fieldName: fieldObject.layerField.name,
              operator,
              // the parser already substracts the offset to local time
              value: date1.getTime() + 2 * offset,
              value2: date2.getTime() + 2 * offset
            };
          }
          else {
            condition = {
              fieldName: fieldObject.layerField.name,
              operator,
              value: obj.right.value[0].value,
              value2: obj.right.value[1].value
            };
          }
        }
        else if (obj.right.type === "timestamp") {
          condition = {
            fieldName: fieldObject.layerField.name,
            operator,
            value: parseDate(obj.right.value).getTime()
          };
        }
        else if (obj.right.type === "date") {
          if (fieldObject.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
            // convert date string to UNIX timestamp (without timestamp offset shift)
            const date = parseDate(obj.right.value);
            const offset = date.getTimezoneOffset() * 60000;
            condition = {
              fieldName: fieldObject.layerField.name,
              operator,
              // the parser already substracts the offset to local time
              value: date.getTime() + 2 * offset
            };
          }
          else {
            condition = {
              fieldName: fieldObject.layerField.name,
              operator,
              value: parseDate(obj.right.value).getTime()
            };
          }
        }
        else {
          // type: "string" | "number" |...
          condition = {
            fieldName: fieldObject.layerField.name,
            operator,
            value: obj.right.value
          };
        }
        stateObj.push(condition);
      }
      else {
        // field or operator not found
        // -> error
        return false;
      }
      return true;
    }
    else {
      return false;
    }
  }
  else {
    // stateObj is expression
    props.expressions = props.expressions || [];
    let success;
    if (isCondition(obj.left) && isCondition(obj.right)) {
      stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
      success = parseBinaryExpr(obj.left, stateObj.conditions, props);
      success = success && parseBinaryExpr(obj.right, stateObj.conditions, props);
    }
    else if (isCondition(obj.left)) {
      if (obj.operator === obj.right.operator && isCondition(obj.right.left) && isCondition(obj.right.right)) {
        // same expression
        stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
        success = parseBinaryExpr(obj.left, stateObj.conditions, props);
        success = success && parseBinaryExpr(obj.right, stateObj, props);
      }
      else {
        // start a new expression
        success = parseBinaryExpr(obj.left, stateObj.conditions, props);
        const expression = {
          conditions: []
        };
        props.expressions.push(expression);
        success = success && parseBinaryExpr(obj.right, expression, props);
      }
    }
    else if (isCondition(obj.right)) {
      if (obj.operator === obj.left.operator &&
        isCondition(obj.left.right) &&
        (isCondition(obj.left.left) || obj.left.operator === ((_a = obj.left.left) === null || _a === void 0 ? void 0 : _a.operator))) {
        // same expression
        stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
        success = parseBinaryExpr(obj.left, stateObj, props);
        success = success && parseBinaryExpr(obj.right, stateObj.conditions, props);
      }
      else {
        // start a new expression
        success = parseBinaryExpr(obj.left, stateObj, props);
        const expression = {
          conditions: []
        };
        props.expressions.push(expression);
        success = success && parseBinaryExpr(obj.right, expression.conditions, props);
      }
    }
    else {
      // no 'leaf'
      if (obj.operator === obj.right.operator && obj.operator === obj.left.operator) {
        // same expression
        stateObj.logicalOperatorForConditions = getLogicalOperator(obj);
        success = parseBinaryExpr(obj.left, stateObj, props);
        success = success && parseBinaryExpr(obj.right, stateObj, props);
      }
      else {
        // start new expressions; first one is still empty...
        success = parseBinaryExpr(obj.left, stateObj, props);
        const expression = {
          conditions: []
        };
        props.expressions.push(expression);
        success = success && parseBinaryExpr(obj.right, expression, props);
      }
    }
    return success;
  }
}
function isCondition(obj) {
  if (obj.type === "binary-expression" && (obj.operator === "OR" || obj.operator === "AND")) {
    return false;
  }
  return true;
}
function getLogicalOperator(obj) {
  return obj.operator.toUpperCase() === "OR" ? logicalOperators.OR : logicalOperators.AND;
}
function getOperator(props, operator, fieldObject, objRight) {
  var _a, _b, _c, _d;
  const { strings } = props;
  if (!fieldObject) {
    return "";
  }
  if (fieldObject.simpleFieldType === simpleFieldTypes.STRING) {
    switch (operator) {
      case "=":
        if (objRight.value === "") {
          return strings.operators.stringOperatorIsEmpty;
        }
        else {
          return strings.operators.stringOperatorIs;
        }
      case "<>": {
        if (objRight.value === "") {
          return strings.operators.stringOperatorIsNotEmpty;
        }
        else {
          return strings.operators.stringOperatorIsNot;
        }
      }
      case "LIKE":
        if (objRight.value.startsWith("%") && objRight.value.endsWith("%")) {
          objRight.value = objRight.value.substring(1, objRight.value.length - 1);
          return strings.operators.stringOperatorContains;
        }
        else if (objRight.value.endsWith("%")) {
          objRight.value = objRight.value.substring(0, objRight.value.length - 1);
          return strings.operators.stringOperatorStartsWith;
        }
        else if (objRight.value.startsWith("%")) {
          objRight.value = objRight.value.substring(1);
          return strings.operators.stringOperatorEndsWith;
        }
        else {
          return strings.operators.stringOperatorIs;
        }
      case "NOT LIKE":
        if (objRight.value.startsWith("%") && objRight.value.endsWith("%")) {
          objRight.value = objRight.value.substring(1, objRight.value.length - 1);
        }
        else if (objRight.value.endsWith("%")) {
          objRight.value = objRight.value.substring(0, objRight.value.length - 1);
        }
        else if (objRight.value.startsWith("%")) {
          objRight.value = objRight.value.substring(1);
        }
        return strings.operators.stringOperatorDoesNotContain;
      case "IS":
        if (objRight.type === "null") {
          return strings.operators.stringOperatorIsBlank;
        }
        return strings.operators.stringOperatorIs;
      case "ISNOT":
      case "IS NOT":
        if (objRight.type === "null") {
          return strings.operators.stringOperatorIsNotBlank;
        }
        return strings.operators.stringOperatorIs;
      case "IN":
        return strings.operators.stringOperatorIncludes;
      case "NOT IN":
      case "NOTIN":
        return strings.operators.stringOperatorExcludes;
    }
  }
  else if (fieldObject.simpleFieldType === "number" || fieldObject.simpleFieldType === "oid") {
    switch (operator) {
      case "=":
        return strings.operators.numberOperatorIs;
      case "<>":
        return strings.operators.numberOperatorIsNot;
      case ">=":
        return strings.operators.numberOperatorIsAtLeast;
      case "<":
        return strings.operators.numberOperatorIsLessThan;
      case "<=":
        return strings.operators.numberOperatorIsAtMost;
      case ">":
        return strings.operators.numberOperatorIsGreaterThan;
      case "BETWEEN":
        return strings.operators.numberOperatorIsBetween;
      case "NOT BETWEEN":
      case "NOTBETWEEN":
        return strings.operators.numberOperatorIsNotBetween;
      case "IS":
        if (objRight.type === "null") {
          return strings.operators.numberOperatorIsBlank;
        }
        return strings.operators.numberOperatorIs;
      case "ISNOT":
      case "IS NOT":
        if (objRight.type === "null") {
          return strings.operators.numberOperatorIsNotBlank;
        }
        return strings.operators.numberOperatorIs;
      case "IN":
        return strings.operators.numberOperatorIncludes;
      case "NOT IN":
      case "NOTIN":
        return strings.operators.numberOperatorExcludes;
    }
  }
  else {
    // date
    switch (operator) {
      case "=":
        // we don't really create this where clause
        return strings.operators.dateOperatorIsOn;
      case "<>":
        return strings.operators.dateOperatorIsNotOn;
      case "<":
        return strings.operators.dateOperatorIsBefore;
      case ">":
        return strings.operators.dateOperatorIsAfter;
      case "BETWEEN":
        if (((_b = (_a = objRight.value[0]) === null || _a === void 0 ? void 0 : _a.left) === null || _b === void 0 ? void 0 : _b.type) === "current-time") {
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP";
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <days> DAY AND CURRENT_TIMESTAMP";
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <hours> HOUR AND CURRENT_TIMESTAMP";
          // whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <minutes> MINUTE AND CURRENT_TIMESTAMP";
          return strings.operators.dateOperatorInTheLast;
        }
        else {
          return strings.operators.dateOperatorIsBetween;
        }
      case "NOT BETWEEN":
      case "NOTBETWEEN":
        if (((_d = (_c = objRight.value[0]) === null || _c === void 0 ? void 0 : _c.left) === null || _d === void 0 ? void 0 : _d.type) === "current-time") {
          // whereClause = "<fieldName> NOT BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP";
          return strings.operators.dateOperatorNotInTheLast;
        }
        else {
          return strings.operators.dateOperatorIsNotBetween;
        }
      case "IS":
        if (objRight.type === "null") {
          return strings.operators.dateOperatorIsBlank;
        } // else not supported
      case "ISNOT":
      case "IS NOT":
        if (objRight.type === "null") {
          return strings.operators.dateOperatorIsNotBlank;
        } // else not supported
    }
  }
  return "";
}
function parseInTheLast(obj) {
  const right = obj.right.value[0].right;
  let count = right.value;
  if (right.type === "interval") {
    //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <days> DAY AND CURRENT_TIMESTAMP";
    //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <hours> HOUR AND CURRENT_TIMESTAMP";
    //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - INTERVAL <minutes> MINUTE AND CURRENT_TIMESTAMP";
    count = right.value.type === "string" ? parseFloat(right.value.value) : right.value.value;
    if (right.qualifier.period === "day") {
      if (count % 365 === 0) {
        return { value: count / 365, unit: "year" };
      }
      else if (count % 30 === 0) {
        return { value: count / 30, unit: "month" };
      }
      else if (count % 7 === 0) {
        return { value: count / 7, unit: "week" };
      }
      else if (count % 1 === 0) {
        return { value: count, unit: "day" };
      }
    }
    else if (right.qualifier.period === "hour") {
      return { value: count, unit: "hour" };
    }
    else if (right.qualifier.period === "minute") {
      return { value: count, unit: "minute" };
    }
  }
  else if (!isNaN(count)) {
    //whereClause = "<fieldName> BETWEEN CURRENT_TIMESTAMP - <days> AND CURRENT_TIMESTAMP"
    if (count % 365 === 0) {
      return { value: count / 365, unit: "year" };
    }
    else if (count % 30 === 0) {
      return { value: count / 30, unit: "month" };
    }
    else if (count % 7 === 0) {
      return { value: count / 7, unit: "week" };
    }
    else if (count % 1 === 0) {
      return { value: count, unit: "day" };
    }
    else {
      const minutes = Math.round(count * 24 * 60);
      if (minutes % 60 === 0) {
        return { value: Math.round(count * 24), unit: "hour" };
      }
      else {
        return { value: minutes, unit: "minute" };
      }
    }
  }
  else {
    return null;
  }
}

const arcgisFilterCss = ".sc-arcgis-filter-h{display:flex;flex:1 1 auto;overflow:hidden}.fab-padding.sc-arcgis-filter{padding-bottom:1rem}.hook.sc-arcgis-filter{width:100%;height:1px}.remove-filter.sc-arcgis-filter{margin-bottom:5px;background-color:white;padding-left:15px}.match-expression-dropdown.sc-arcgis-filter{width:100%}.match-expression-msg.sc-arcgis-filter{padding:12px;background-color:white}.match-type.sc-arcgis-filter{display:flex;justify-content:center;margin:6px 0}.arcgis--rtl.sc-arcgis-filter .remove-filter.sc-arcgis-filter{padding-left:0;padding-right:15px}.no-space.sc-arcgis-filter{--calcite-label-margin-bottom:0}";

const ArcgisFilter = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisFilterWhereChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterWhereChange", 7);
    this.arcgisFilterSave = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterSave", 7);
    this.arcgisFilterCancel = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterCancel", 7);
    this.arcgisFilterDismissedChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterDismissedChange", 7);
    this.arcgisFilterDone = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterDone", 7);
    this.arcgisFilterPanelBackClick = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterPanelBackClick", 7);
    this.closeFilterPopovers = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "closeFilterPopovers", 7);
    this.arcgisFilterExpressionChanged = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterExpressionChanged", 7);
    this.layerViewWaitHandler = null;
    this.layerHasFeatureEffect = false;
    this.properClose = false;
    this.applyFilter = () => {
      const { props, mode } = this;
      const { layerView, layer, labelClassIdx, labelClass, originalLayer } = props;
      this.closeFilterPopovers.emit();
      if (isDefined(labelClassIdx) || isDefined(labelClass)) {
        // we passed the where clause when it changed
        this.arcgisFilterSave.emit();
      }
      else if (mode === "layer-view") {
        const whereClause = createWhereClause(props);
        // keep effect on layerView to avoid flickering
        this.arcgisFilterSave.emit(whereClause);
      }
      else if (mode === "effects") ;
      else if (layer) {
        const whereClause = createWhereClause(props);
        (originalLayer || layer).definitionExpression = whereClause;
        //console.log("definitionExpression:", whereClause);
        if (this.isAllowedFeatureEffect()) {
          layer.featureEffect = null;
        }
        else {
          if (layerView && "filter" in layerView) {
            layerView.filter = null;
          }
        }
        createIndexes(props);
        this.properClose = true;
        this.arcgisFilterSave.emit();
        // switched to definitionExpression from effect/layerView.filter
        this.componentStateInvalid = true;
      }
    };
    this.cancelFilter = () => {
      this.revertFilter();
      this.closeFilterPopovers.emit();
      this.properClose = true;
      this.arcgisFilterCancel.emit();
    };
    this.closeFilter = () => {
      // save on close
      this.applyFilter();
      this.closeFilterPopovers.emit();
      this.properClose = true;
      this.arcgisFilterDismissedChange.emit();
    };
    this.onAddExpression = () => {
      const { props } = this;
      const { expressions } = props;
      const defaultField = getDefaultField(props);
      if (!defaultField) {
        // not ready yet
        return;
      }
      const defaultOperator = getDefaultOperator(props, defaultField);
      const defaultValues = getDefaultValues(props, defaultField, defaultOperator);
      const newExpression = {
        conditions: [
          Object.assign(Object.assign({ fieldName: defaultField.layerField.name, operator: defaultOperator }, defaultValues), { hasFocus: true })
        ]
      };
      props.expressions = expressions
        ? fixUIDs([
          ...expressions.map((expression) => {
            return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map((cond) => {
                return Object.assign(Object.assign({}, cond), { hasFocus: false });
              }) });
          }),
          newExpression
        ])
        : fixUIDs([newExpression]);
      if (isDefined(defaultValues.value)) {
        this.arcgisFilterExpressionChanged.emit({ type: "replace", expression: newExpression });
      }
      this.reRender = !this.reRender;
    };
    this.onMatchSelect = (event) => {
      const { props } = this;
      const select = event.target;
      props.logicalOperatorForExpressions = select.selectedOption.value;
      this.reRender = !this.reRender;
      this.applyFilterToLayer();
    };
    this.onRemoveFilter = () => {
      const { props } = this;
      props.invalidFilter = false;
      props.expressions = undefined;
      this.reRender = !this.reRender;
      this.applyFilterToLayer();
    };
    this.focusByClass = () => {
      // set focus back for keyboard users
      const node = this.hostElement.querySelector("arcgis-filter .autofocus");
      if (node) {
        if (node.nodeName.startsWith("CALCITE-")) {
          node.setFocus();
        }
        else {
          node.focus();
        }
      }
    };
    this.view = undefined;
    this.layer = undefined;
    this.labelClassIdx = undefined;
    this.labelClass = undefined;
    this.mode = undefined;
    this.viewFilter = undefined;
    this.featureReduction = undefined;
    this.hideLayerTitle = false;
    this.panelHeading = undefined;
    this.tipHeading = undefined;
    this.tipMsg = undefined;
    this.invalidHeading = undefined;
    this.invalidMsg = undefined;
    this.newButtonLabel = undefined;
    this.clearText = undefined;
    this.defaultFieldName = undefined;
    this.defaultOperator = undefined;
    this.defaultExpression = false;
    this.hideButtons = false;
    this.panelMaxHeight = undefined;
    this.dismissible = false;
    this.props = undefined;
    this.reRender = false;
    this.componentStateInvalid = false;
  }
  arcgisFilterExpressionChangeHandler(event) {
    var _a;
    const { props } = this;
    const { expressions } = props;
    const { detail } = event;
    if (detail.type === "copy") {
      // replace + copy expression
      const expr = event.detail.expression;
      props.expressions = props.expressions.map((expression) => (expression.uid === expr.uid ? expr : expression) //{ ...expression }
      );
      let copyExpression;
      props.expressions = expressions.map((expression) => {
        return Object.assign(Object.assign({}, expression), { conditions: expression.conditions.map((cond) => {
            return Object.assign(Object.assign({}, cond), { hasFocus: false });
          }) });
      });
      props.expressions.forEach((expr) => {
        if (expr.uid === detail.uid) {
          copyExpression = this.esriLang.clone(Object.assign({}, expr));
          copyExpression.conditions[0].hasFocus = true;
        }
      });
      props.expressions = fixUIDs([...props.expressions, copyExpression]);
      this.reRender = !this.reRender;
    }
    else if (detail.type === "delete") {
      // delete expression
      let removedIdx = 0;
      expressions.forEach((expression, idx) => {
        if (expression.uid === detail.uid) {
          removedIdx = idx;
        }
        else {
          expression.conditions.forEach((cond) => (cond.hasFocus = false));
        }
      });
      props.expressions = expressions.filter((expression) => expression.uid !== detail.uid);
      if ((_a = props.expressions) === null || _a === void 0 ? void 0 : _a.length) {
        props.expressions[Math.max(0, removedIdx - 1)].conditions[0].hasFocus = true;
        props.expressions = fixUIDs([...props.expressions]);
        // wait until rendering is done
        setTimeout(() => this.focusByClass(), 500);
      }
      else {
        // wait until rendering is done
        setTimeout(() => this.fabNode.setFocus(), 500);
      }
      this.reRender = !this.reRender;
    }
    else {
      // type="replace"
      // replace expression
      const replaceExpr = event.detail.expression;
      props.expressions = props.expressions.map((expression) => expression.uid === replaceExpr.uid ? Object.assign({}, replaceExpr) : expression);
    }
    this.applyFilterToLayer();
  }
  disableFilterPanelHandler(event) {
    this.panelNode.disabled = event.detail;
  }
  //--------------------------------------------------------------------------
  //
  //  public calls
  //
  //--------------------------------------------------------------------------
  async setFocus() {
    this.panelNode.setFocus();
  }
  async done() {
    if (!this.componentStateInvalid) {
      // save on done
      this.applyFilter();
      this.closeFilterPopovers.emit();
      this.properClose = true;
      this.arcgisFilterDone.emit();
    }
  }
  async closePopovers() {
    this.closeFilterPopovers.emit();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    const [strings, currentLanguage, currentLanguageIntl] = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement);
    // build FilterProps
    this.props = {
      expressions: undefined,
      logicalOperatorForExpressions: "and",
      fields: [],
      operators: undefined,
      invalidFilter: false,
      stringFieldsCount: 0,
      dateFieldsCount: 0,
      numberFieldsCount: 0,
      isHosted: false,
      supportsStandardizedQuery: false,
      supportedSqlParserVersion: false,
      layer: {},
      view: this.view,
      labelClassIdx: this.labelClassIdx,
      labelClass: this.labelClass,
      featureReduction: this.featureReduction,
      strings,
      locale: currentLanguage,
      localeIntl: currentLanguageIntl,
      inputDefinitionExpression: null,
      backgroundTheme: "light",
      lastWhere: undefined,
      defaultFieldName: this.defaultFieldName,
      defaultOperator: this.defaultOperator
    };
    const [reactiveUtils, colorUtils, ImageryLayer, FeatureLayer, FeatureEffect, esriLang] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)([
      "esri/core/reactiveUtils",
      "esri/views/support/colorUtils",
      "esri/layers/ImageryLayer",
      "esri/layers/FeatureLayer",
      "esri/layers/support/FeatureEffect",
      "esri/core/lang"
    ]);
    this.reactiveUtils = reactiveUtils;
    this.colorUtils = colorUtils;
    this.ImageryLayer = ImageryLayer;
    this.FeatureLayer = FeatureLayer;
    this.FeatureEffect = FeatureEffect;
    this.esriLang = esriLang;
    const { view, layer } = this;
    let { props } = this;
    const propLayer = layer; // issue with type prop
    if (propLayer.declaredClass === "esri.layers.support.Sublayer") {
      // need to create a FeatureLayer
      const mapImageSublayer = propLayer;
      //delete this.layer;
      view && (await this.reactiveUtils.whenOnce(() => !view.updating));
      const sublayerFL = await mapImageSublayer.createFeatureLayer();
      await sublayerFL.load();
      this.props = Object.assign(Object.assign({}, props), { layer: sublayerFL, mapImageSublayer });
    }
    else if (propLayer.type === "imagery" || propLayer.type === "subtype-group") {
      this.props = Object.assign(Object.assign({}, props), { layer: propLayer });
    }
    else if (!view || (propLayer.type === "feature" && propLayer.isTable)) {
      // we need a layer without a filter for statistics, histogram, and uniqueValues
      let nonFilteredLayer;
      nonFilteredLayer = new this.FeatureLayer({
        url: propLayer.url,
        layerId: propLayer.layerId,
        popupTemplate: propLayer.popupTemplate
      });
      await nonFilteredLayer.load();
      this.props = Object.assign(Object.assign({}, props), { layer: nonFilteredLayer, originalLayer: propLayer });
    }
    else {
      this.props = Object.assign(Object.assign({}, props), { layer: propLayer });
    }
    const { labelClassIdx, labelClass, featureReduction } = this.props;
    const labelingInfo = featureReduction
      ? layer.featureReduction.labelingInfo
      : layer.labelingInfo;
    if ((isDefined(labelClassIdx) && (!labelingInfo || !labelingInfo[labelClassIdx])) ||
      (isDefined(labelClass) && (!labelingInfo || !labelingInfo.length))) {
      // error
      console.log("can't find labelClass");
      return;
    }
    this.processLayer();
  }
  componentDidLoad() {
    var _a;
    const { props, defaultExpression } = this;
    if (!((_a = props.expressions) === null || _a === void 0 ? void 0 : _a.length) && defaultExpression) {
      this.onAddExpression();
    }
    requestAnimationFrame(() => this.panelNode.setFocus());
  }
  disconnectedCallback() {
    if (this.properClose) {
      // user left the panel via Save, Cancel, or Close
      // just close popovers
      this.closeFilterPopovers.emit();
    }
    else {
      // user left the panel without clicking on Save, Cancel, or Close
      // e.g. also panel back button
      this.applyFilter();
      if (this.mode === "layer-view") {
        createIndexes(this.props);
      }
    }
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { props, hideLayerTitle, mode, panelHeading, componentStateInvalid, dismissible, hostElement, panelMaxHeight } = this;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(hostElement) === "rtl";
    const { layer, mapImageSublayer, invalidFilter, strings } = props;
    const title = mapImageSublayer ? mapImageSublayer.title : layer.title;
    if (componentStateInvalid) {
      // we removed the effect and created a definitionExpression
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null)));
    }
    if (!layer) {
      return this.renderLoading();
    }
    if (invalidFilter) {
      return this.renderInvalidFilter();
    }
    if (hostElement.parentElement.tagName === "CALCITE-FLOW" ||
      hostElement.parentElement.parentElement.tagName === "CALCITE-FLOW") {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { id: "filter-panel", loading: false, heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, class: {
          [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
        }, style: panelMaxHeight && { maxHeight: panelMaxHeight }, closable: dismissible, ref: (node) => (this.panelNode = node), onCalciteFlowItemBack: () => {
          if (mode === "layer-view") {
            const whereClause = createWhereClause(props);
            this.arcgisFilterPanelBackClick.emit(whereClause);
            // create indexes on disconnect call
          }
          else {
            this.arcgisFilterPanelBackClick.emit();
          }
        }, onCalciteFlowItemClose: () => this.closeFilter() }, this.renderContent())));
    }
    else {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { id: "filter-panel", loading: false, heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, class: {
          [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
        }, style: panelMaxHeight && { maxHeight: panelMaxHeight }, closable: dismissible, ref: (node) => (this.panelNode = node), onCalcitePanelClose: () => this.closeFilter() }, this.renderContent())));
    }
  }
  renderContent() {
    const { props, mode, hideButtons } = this;
    const { labelClassIdx, labelClass } = props;
    const isLabelFilter = isDefined(labelClassIdx) || isDefined(labelClass);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.F, null, !isLabelFilter && mode !== "layer-view" && !hideButtons ? this.renderSaveButton() : null, !isLabelFilter && mode !== "layer-view" && !hideButtons ? this.renderCancelButton() : null, this.renderPopoverHook(), this.renderRemoveFilter(), this.renderMatchExpressionMsg(), this.renderExpressions(), this.renderAddExpression(), this.renderTip()));
  }
  renderSaveButton() {
    const { props } = this;
    const { strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.applyFilter, appearance: "solid", width: "half", label: strings.save }, strings.save));
  }
  renderCancelButton() {
    const { props } = this;
    const { strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.cancelFilter, appearance: "outline-fill", width: "half", label: strings.cancel }, strings.cancel));
  }
  renderPopoverHook() {
    return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { id: "arcgis-filter-hook", class: CSS$3.hook });
  }
  renderRemoveFilter() {
    const { props, clearText } = this;
    const { strings, expressions } = props;
    if (!expressions || !expressions.length) {
      return null;
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.removeFilter }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: "no-space", layout: "inline-space-between", scale: "m" }, clearText || strings.removeFilter, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: clearText || strings.removeFilter, scale: "m", onClick: this.onRemoveFilter }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "trash" })))));
  }
  renderLoading() {
    const { props, hideLayerTitle, panelHeading } = this;
    const { layer, mapImageSublayer, strings } = props;
    const title = mapImageSublayer ? mapImageSublayer.title : layer.title;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement) === "rtl";
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { id: "filter-panel", heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, loading: true, class: {
        panel: true,
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
      } })));
  }
  renderInvalidFilter() {
    const { props, hideLayerTitle, dismissible, mode, hideButtons, panelHeading } = this;
    const { layer, mapImageSublayer, labelClassIdx, labelClass, strings } = props;
    const title = mapImageSublayer ? mapImageSublayer.title : layer.title;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement) === "rtl";
    const isLabelFilter = isDefined(labelClassIdx) || isDefined(labelClass);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { id: "filter-panel", heading: panelHeading || strings.title, description: !hideLayerTitle ? title : undefined, loading: false, closable: dismissible, class: {
        panel: true,
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
      }, ref: this.focusByClass, onCalcitePanelClose: () => this.closeFilter() }, !isLabelFilter && mode !== "layer-view" && !hideButtons ? this.renderSaveButton() : null, !isLabelFilter && mode !== "layer-view" && !hideButtons
      ? this.renderCancelButton()
      : null, this.renderInvalidFilterMsg(), this.renderCreateNewFilter())));
  }
  renderInvalidFilterMsg() {
    // helpId = 120001736 for LearnMore
    const { invalidHeading, invalidMsg, props } = this;
    const { strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tip", { heading: invalidHeading || strings.errors.problemDisplayingFilter, closeDisabled: true }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, invalidMsg || strings.errors.problemDisplayingFilterMsg)));
  }
  renderCreateNewFilter() {
    const { props, newButtonLabel, hideButtons } = this;
    const { strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-fab", { class: {
        autofocus: true,
        "fab-padding": hideButtons
      }, slot: "fab", appearance: "outline-fill", kind: "neutral", scale: "m", textEnabled: true, label: newButtonLabel || strings.createNewFilter, text: newButtonLabel || strings.createNewFilter, onClick: this.onRemoveFilter }));
  }
  renderMatchExpressionMsg() {
    const { props } = this;
    const { expressions, logicalOperatorForExpressions, strings } = props;
    if (!expressions || !expressions.length) {
      return null;
    }
    const isAnd = logicalOperatorForExpressions === logicalOperators.AND;
    return expressions.length === 1 ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.matchExpressionMsg }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "m", class: "no-space" }, strings.oneExpressionMsg))) : ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.matchExpressionMsg }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: "no-space", scale: "m" }, strings.manyExpressionsMsg, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.matchExpressions, class: CSS$3.matchExpressionDropdown, onCalciteSelectChange: this.onMatchSelect }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.AND, label: strings.matchAllExpressions, selected: isAnd }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.OR, label: strings.matchAtLeastOneExpression, selected: !isAnd })))));
  }
  renderExpressions() {
    const { props } = this;
    const { expressions } = props;
    if (!expressions || !expressions.length) {
      return null;
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, expressions.map((expressionProps, idx) => this.renderExpression(expressionProps, idx))));
  }
  renderExpression(expressionProps, expressionIndex) {
    const { props } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, this.renderLogicalOperatorExpression(expressionIndex), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-filter-expression", Object.assign({ props: props, ref: this.focusByClass }, expressionProps))));
  }
  renderLogicalOperatorExpression(expressionIndex) {
    const { props } = this;
    const { logicalOperatorForExpressions, strings } = props;
    if (expressionIndex === 0) {
      return null;
    }
    else {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.logicalOperator }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, logicalOperatorForExpressions === logicalOperators.OR ? strings.or : strings.and)));
    }
  }
  renderAddExpression() {
    const { props, hideButtons } = this;
    const { expressions, strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-fab", { class: {
        autofocus: !expressions || !expressions.length,
        "fab-padding": hideButtons
      }, slot: "fab", appearance: "outline-fill", kind: "neutral", scale: "m", icon: "plus", textEnabled: true, text: strings.addExpression, onClick: this.onAddExpression, ref: (node) => (this.fabNode = node) }));
  }
  renderTip() {
    const { props, mode, tipHeading, tipMsg } = this;
    const { mapImageSublayer, expressions, labelClassIdx, labelClass, strings } = props;
    if (expressions === null || expressions === void 0 ? void 0 : expressions.length) {
      return null;
    }
    const forLabels = isDefined(labelClassIdx) || isDefined(labelClass);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tip", { heading: tipHeading || strings.tips.emptyMsgTitle, closeDisabled: true }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, tipMsg ||
      (forLabels
        ? strings.tips.emptyMsgLabels
        : mapImageSublayer || mode === "layer-view"
          ? strings.tips.emptyMsgMS
          : strings.tips.emptyMsg))));
  }
  // --------------------------------------------------------------------------
  //
  //  Private methods
  //
  // --------------------------------------------------------------------------
  async processLayer() {
    var _a;
    const { props, mode, viewFilter, hideButtons } = this;
    const { layer, mapImageSublayer, originalLayer, view, labelClassIdx, labelClass, featureReduction } = props;
    const labelingInfo = layer.type === "feature" &&
      (featureReduction
        ? layer.featureReduction.labelingInfo
        : layer.labelingInfo);
    if (view &&
      !mapImageSublayer &&
      layer.type !== "imagery" &&
      layer.type !== "subtype-group" &&
      !(layer.type === "feature" && layer.isTable)) {
      props.layerView = (await view.whenLayerView(layer));
    }
    checkConfig(props);
    await buildFilterFields(props);
    buildOperatorsList(props);
    props.backgroundTheme = view && (await this.colorUtils.getBackgroundColorTheme(view));
    this.layerHasFeatureEffect = layer.featureEffect;
    if (isDefined(labelClassIdx) && labelingInfo[labelClassIdx].where) {
      props.inputDefinitionExpression = labelingInfo[labelClassIdx].where;
      const success = await parseWhereClause(props.inputDefinitionExpression, props);
      props.invalidFilter = !success;
      this.reRender = !this.reRender;
    }
    else if (isDefined(labelClass) && labelClass.where) {
      props.inputDefinitionExpression = labelClass.where;
      props.lastWhere = props.inputDefinitionExpression;
      const success = await parseWhereClause(props.inputDefinitionExpression, this.props);
      props.invalidFilter = !success;
      this.reRender = !this.reRender;
    }
    else if (mode === "layer-view") {
      // keep definitionExpression on FL, the new filter is an add-on
      if (viewFilter) {
        const success = await parseWhereClause(viewFilter, props);
        props.invalidFilter = !success;
        if (success) {
          this.applyFilterToLayer(true);
        }
        this.reRender = !this.reRender;
      }
    }
    else if (mode === "effects") {
      props.invalidFilter = false;
      if (layer.featureEffect) {
        props.inputDefinitionExpression = (_a = layer.featureEffect.filter) === null || _a === void 0 ? void 0 : _a.where;
        props.lastWhere = props.inputDefinitionExpression;
        const success = await parseWhereClause(props.inputDefinitionExpression, props);
        props.invalidFilter = !success;
        this.reRender = !this.reRender;
      }
    }
    else if (!isDefined(labelClassIdx) &&
      !isDefined(labelClass) &&
      (isDefined(layer.definitionExpression) || isDefined(originalLayer === null || originalLayer === void 0 ? void 0 : originalLayer.definitionExpression))) {
      props.inputDefinitionExpression = (originalLayer || layer).definitionExpression;
      // apply FeatureFilter to layer
      const success = await parseWhereClause(props.inputDefinitionExpression, props);
      props.invalidFilter = !success;
      if (success) {
        this.applyFilterToLayer(true);
      }
      this.reRender = !this.reRender;
      if (view &&
        layer.type !== "imagery" &&
        layer.type !== "subtype-group" &&
        !(layer.type === "feature" && layer.isTable) &&
        !(mode === "effects" && this.layerHasFeatureEffect)) {
        // remove definitionExpression from layer
        // we use effect instead
        layer.definitionExpression = null;
      }
    }
    else if (hideButtons) {
      props.inputDefinitionExpression = layer.definitionExpression;
      props.lastWhere = props.inputDefinitionExpression;
      const success = await parseWhereClause(props.inputDefinitionExpression, this.props);
      props.invalidFilter = !success;
      this.reRender = !this.reRender;
    }
    else {
      props.invalidFilter = false;
    }
  }
  revertFilter() {
    var _a, _b, _c, _d;
    const { props, mode, viewFilter } = this;
    const { layer, layerView, featureReduction, labelClassIdx, labelClass, inputDefinitionExpression, mapImageSublayer, originalLayer, backgroundTheme } = props;
    const index = this.getLabelClassIndex();
    // apply original expression
    if (layer.type !== "imagery" && layer.type !== "subtype-group" && isDefined(labelClassIdx)) {
      const labelingInfo = featureReduction
        ? layer.featureReduction.labelingInfo
        : layer.labelingInfo;
      labelingInfo[labelClassIdx].where = inputDefinitionExpression;
      // refresh layer
      if (featureReduction) {
        layer.featureReduction = this.esriLang.clone(layer.featureReduction);
        props.labelClass = layer.featureReduction.labelingInfo[index];
      }
      else {
        layer.labelingInfo = layer.labelingInfo;
      }
      if (mapImageSublayer) {
        mapImageSublayer.labelingInfo = layer.labelingInfo;
      }
    }
    else if (layer.type !== "imagery" &&
      layer.type !== "subtype-group" &&
      isDefined(labelClass)) {
      labelClass.where = inputDefinitionExpression;
      // refresh layer
      if (featureReduction) {
        layer.featureReduction = this.esriLang.clone(layer.featureReduction);
        props.labelClass = layer.featureReduction.labelingInfo[index];
      }
      else {
        layer.labelingInfo = layer.labelingInfo;
      }
      if (mapImageSublayer) {
        mapImageSublayer.labelingInfo = layer.labelingInfo;
      }
    }
    else if (mode === "layer-view") {
      // set back to passed in viewFilter
      if (layer.type === "feature") {
        if (viewFilter) {
          if (!isEffectEmpty(layer.featureEffect)) {
            layer.featureEffect.filter.where = viewFilter;
          }
          else {
            const brightness = backgroundTheme === "light" ? 100 : 65;
            layer.featureEffect = new this.FeatureEffect({
              filter: {
                where: viewFilter
              },
              excludedEffect: `grayscale(100%) opacity(30%) brightness(${brightness}%)`
            });
          }
        }
        else {
          if ((_b = (_a = layer.featureEffect) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.where) {
            layer.featureEffect.filter.where = null;
            if (isEffectEmpty(layer.featureEffect)) {
              layer.featureEffect = null;
            }
          }
          else {
            layer.featureEffect = null;
          }
        }
      }
    }
    else if (mode === "effects") ;
    else if (layer) {
      if (mapImageSublayer) {
        mapImageSublayer.definitionExpression = inputDefinitionExpression;
      }
      else {
        (originalLayer || layer).definitionExpression = inputDefinitionExpression;
      }
      if (this.isAllowedFeatureEffect()) {
        const anyLayer = layer;
        if ((_d = (_c = anyLayer.featureEffect) === null || _c === void 0 ? void 0 : _c.filter) === null || _d === void 0 ? void 0 : _d.where) {
          anyLayer.featureEffect.filter.where = null;
          if (isEffectEmpty(anyLayer.featureEffect)) {
            anyLayer.featureEffect = null;
          }
        }
      }
      else {
        if (layerView && "filter" in layerView) {
          layerView.filter = null;
        }
      }
      // switched to definitionExpression from effect/layerView.filter
      this.componentStateInvalid = true;
    }
  }
  applyFilterToLayer(isInit) {
    var _a, _b;
    const { props, layerViewWaitHandler, hideButtons } = this;
    const { backgroundTheme, labelClass, layer, labelClassIdx, view, layerView, mapImageSublayer, originalLayer, featureReduction, lastWhere } = props;
    const where = createWhereClause(props) || undefined;
    if (!isInit && where !== lastWhere) {
      this.arcgisFilterWhereChange.emit(where);
    }
    props.lastWhere = where;
    if (layer.type === "feature" && isDefined(labelClassIdx)) {
      const index = this.getLabelClassIndex();
      const labelingInfo = featureReduction
        ? layer.featureReduction.labelingInfo
        : layer.labelingInfo;
      labelingInfo[labelClassIdx].where = where;
      // refresh layer
      if (featureReduction) {
        layer.featureReduction = this.esriLang.clone(layer.featureReduction);
        props.labelClass = layer.featureReduction.labelingInfo[index];
      }
      else {
        layer.labelingInfo = layer.labelingInfo;
      }
      if (mapImageSublayer) {
        mapImageSublayer.labelingInfo = layer.labelingInfo;
      }
      //console.log("apply", where, layer.labelingInfo);
      return;
    }
    else if (isDefined(labelClass)) {
      // we don't update the layer at all
      return;
    }
    else if (layer.type === "imagery" || layer.type === "subtype-group") {
      layer.definitionExpression = where;
      return;
    }
    else if (hideButtons) {
      // we don't update the layer at all
      return;
    }
    if (mapImageSublayer) {
      mapImageSublayer.definitionExpression = where;
      return;
    }
    else if (!view || (layer.type === "feature" && layer.isTable)) {
      originalLayer.definitionExpression = createWhereClause(props);
      return;
    }
    // use effect
    if (layerViewWaitHandler) {
      clearTimeout(layerViewWaitHandler);
      this.layerViewWaitHandler = undefined;
    }
    if (!layerView) {
      // we need to wait and try later
      this.layerViewWaitHandler = setTimeout(() => {
        this.applyFilterToLayer();
      }, 500);
      return;
    }
    //console.log("FeatureEffect.filter:", whereClause);
    if (where === null || where === void 0 ? void 0 : where.length) {
      if (this.isAllowedFeatureEffect()) {
        if (!isEffectEmpty(layer.featureEffect)) {
          layer.featureEffect.filter = layer.featureEffect.filter || {};
          layer.featureEffect.filter.where = where;
        }
        else {
          const brightness = backgroundTheme === "light" ? 100 : 65;
          layer.featureEffect = new this.FeatureEffect({
            filter: {
              where
            },
            excludedEffect: `grayscale(100%) opacity(30%) brightness(${brightness}%)`
          });
        }
      }
      else if ("filter" in layerView) {
        layerView.filter = {
          where
        };
      }
    }
    else {
      if (this.isAllowedFeatureEffect()) {
        if ((_b = (_a = layer.featureEffect) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.where) {
          layer.featureEffect.filter.where = null;
          if (isEffectEmpty(layer.featureEffect)) {
            layer.featureEffect = null;
          }
        }
      }
      else if ("filter" in layerView) {
        layerView.filter = null;
      }
    }
  }
  isAllowedFeatureEffect() {
    // Ideally we want to filter out features via layer.featureEffect
    // so that filtered out features show dimmed.
    // But if this is not possible use layerView.filter
    // so filtered out features are hidden.
    // Layer.definitionExpression affects the server queries
    // so only apply this when leaving the component
    const { props, layerHasFeatureEffect, mode } = this;
    const { layer } = props;
    return (["feature", "geojson", "ogc-feature", "wfs", "csv", "stream"].indexOf(layer.type) > -1 &&
      !layer.featureReduction &&
      mode !== "effects" &&
      (!layerHasFeatureEffect || mode === "layer-view"));
  }
  getLabelClassIndex() {
    const { props } = this;
    const { layer, labelClass, featureReduction } = props;
    let index = -1;
    const labelingInfo = layer.type === "feature" &&
      (featureReduction
        ? layer.featureReduction.labelingInfo
        : layer.labelingInfo);
    if (labelClass) {
      labelingInfo.forEach((lClass, idx) => {
        if (JSON.stringify(lClass.toJSON()) === JSON.stringify(labelClass.toJSON())) {
          index = idx;
        }
      });
    }
    return index;
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilter.style = arcgisFilterCss;

const CSS$2 = {
  condition: "filter-condition",
  operatorDropdown: "operator-dropdown",
  inputPlusUnique: "input-plus-unique",
  input: "input",
  blankButton: "blank-button",
  selectUniqueButton: "select-unique-button",
  betweenValuesInput: "between-values-input",
  selectValues: "select-values",
  pickList: "pick-list",
  uniqueValuesContentListMsg: "unique-values-content-list-msg",
  inTheLast: "in-the-last",
  inTheLastCount: "in-the-last-count",
  inTheLastUnit: "in-the-last-unit",
  datePicker: "date-picker",
  histogramContent: "histogram-content",
  histogramContentSlim: "histogram-content-slim",
  smallLoader: "small-loader"
};

const arcgisFilterConditionCss = ".filter-condition.sc-arcgis-filter-condition{padding:0 6px}.operator-dropdown.sc-arcgis-filter-condition{width:100%;margin:5px 0}.input-plus-unique.sc-arcgis-filter-condition{display:flex;flex-direction:row;width:100%}.input.sc-arcgis-filter-condition{width:100%}.blank-button.sc-arcgis-filter-condition{height:22px;border:var(--calcite-ui-border-input) 1px solid}.blank-button.active.sc-arcgis-filter-condition{cursor:pointer}.blank-button.inactive.sc-arcgis-filter-condition:focus{outline:none}.select-unique-button.sc-arcgis-filter-condition{height:32px;border-top:var(--calcite-ui-border-input) 1px solid;border-bottom:var(--calcite-ui-border-input) 1px solid;border-right:var(--calcite-ui-border-input) 1px solid}.arcgis--rtl.sc-arcgis-filter-condition .select-unique-button.sc-arcgis-filter-condition{border-right:none;border-left:var(--calcite-ui-border-input) 1px solid}.between-values-input.first.sc-arcgis-filter-condition{margin-bottom:5px}.select-values.sc-arcgis-filter-condition{margin-bottom:4px}.pick-list.sc-arcgis-filter-condition{max-height:200px;overflow-y:auto}.unique-values-content-list-msg.sc-arcgis-filter-condition{font-size:90%;margin-top:5px;margin-bottom:5px}.in-the-last.sc-arcgis-filter-condition{display:flex}.in-the-last-count.sc-arcgis-filter-condition{width:50%}.in-the-last-unit.sc-arcgis-filter-condition{width:50%}.date-picker.sc-arcgis-filter-condition{width:100%}.date-picker.first.sc-arcgis-filter-condition{margin-bottom:5px}.histogram-content.sc-arcgis-filter-condition{height:120px;margin-top:5px}.histogram-content-slim.sc-arcgis-filter-condition{height:40px;margin-top:5px}.small-loader.sc-arcgis-filter-condition{margin-left:calc((100% - 16px) / 2);margin-top:10px}html[dir=rtl].sc-arcgis-filter-condition .small-loader.sc-arcgis-filter-condition{margin-left:auto;margin-right:8px}";

const ArcgisFilterCondition = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisFilterConditionChanged = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterConditionChanged", 7);
    this.disableFilterPanel = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "disableFilterPanel", 7);
    this.arcgisFilterUniqueValuesReturned = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueValuesReturned", 7);
    this.histogramSlider = undefined;
    this.afterCreateSliderDiv = (element) => {
      const { fieldName, props, histogramSlider } = this;
      if (!element) {
        // not sure why that happens
        return;
      }
      setTimeout(() => {
        if (!histogramSlider) {
          // should not happen
          return;
        }
        const divNode = document.createElement("div");
        element.appendChild(divNode);
        if (!histogramSlider.container) {
          histogramSlider.container = divNode;
        }
        else {
          // need to recreate the slider
          const filterField = getFieldInfo(fieldName, props);
          if (!filterField) {
            return;
          }
          const { bins, average, min, max, values, precision, rangeType } = histogramSlider;
          const config = {
            container: divNode,
            bins,
            average,
            //standardDeviation,
            min,
            max,
            values,
            precision,
            rangeType
          };
          if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) >
            -1) {
            config.hasTimeData = true;
            this.addDateFormatFunctions(config);
          }
          //console.log("re-create HistogramRangeSlider", config);
          histogramSlider.destroy();
          this.histogramSlider = new this.HistogramRangeSlider(config);
          this.createSliderChangeEvents(filterField);
        }
      }, 1);
    };
    this.onFieldSelect = () => {
      this.hasFocus = true;
      this.openFieldPickList();
    };
    this.onOperatorSelect = (event) => {
      var _a, _b, _c, _d;
      const { props, fieldName, operator, value, value2 } = this;
      const select = event.target;
      const newOperator = select.selectedOption.value;
      const filterField = getFieldInfo(fieldName, props);
      const oldInTheLast = isInTheLastOperator(props, operator);
      const newInTheLast = isInTheLastOperator(props, newOperator);
      const oneInTheLast = oldInTheLast || newInTheLast;
      const bothInTheLast = oldInTheLast && newInTheLast;
      const oldBetween = isBetweenOperator(props, operator);
      const newBetween = isBetweenOperator(props, newOperator);
      const bothBetween = oldBetween && newBetween;
      //const oldInExclude = isIncludesOperator(props, operator) || isExcludesOperator(props, operator);
      //const newInExclude =
      //  isIncludesOperator(props, newOperator) || isExcludesOperator(props, newOperator);
      //const bothInExclude = oldInExclude && newInExclude;
      const old = {
        value,
        value2,
        operator
      };
      this.value =
        oneInTheLast && !bothInTheLast
          ? null
          : filterField.statistics && !isDefined(value)
            ? filterField.statistics.avg
            : value;
      this.value2 = newBetween
        ? value2 !== null && value2 !== void 0 ? value2 : (isIntegerType(filterField)
          ? Math.round((_a = filterField.statistics) === null || _a === void 0 ? void 0 : _a.max)
          : (_b = filterField.statistics) === null || _b === void 0 ? void 0 : _b.max)
        : oneInTheLast || !bothBetween
          ? null
          : value2;
      this.operator = newOperator;
      const defaultValues = this.checkDefaultValues(filterField);
      const updates = {
        value: (_c = this.value) !== null && _c !== void 0 ? _c : defaultValues.value,
        value2: (_d = this.value2) !== null && _d !== void 0 ? _d : (newBetween ? defaultValues.value2 : null),
        operator: this.operator
      };
      // set it back - TODO, need to find a better way after 9.1
      // if I modify local props the component won't re-render with emitChangeEvent()
      this.value = old.value;
      this.value2 = old.value2;
      this.operator = old.operator;
      this.emitChangeEvent(updates);
    };
    this.onValueChangeMaybe = (event) => {
      const { props, operator, value2 } = this;
      const newValue = this.getNewValue(event);
      if (isDefined(newValue) && isBetweenOperator(props, operator) && newValue >= value2) {
        // we assume the user is in the middle of typing
        return;
      }
      this.onValueChange(event, newValue);
    };
    this.onValueChange = (event, newValue) => {
      const { props, fieldName, operator, value, value2 } = this;
      const { view } = props;
      const { timeZone } = view;
      const filterField = getFieldInfo(fieldName, props);
      const node = event === null || event === void 0 ? void 0 : event.target;
      newValue = event ? this.getNewValue(event) : newValue;
      if (!isDefined(newValue)) {
        // we need to have a value
        // fall back to default values
        const defaultValues = getDefaultValues(props, filterField, operator);
        newValue = defaultValues.value;
        if (node) {
          if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
            node.value = utcToDatePicker(newValue, timeZone);
          }
          else {
            node.value = newValue;
          }
        }
      }
      if (value === newValue) {
        return;
      }
      if (isDefined(newValue) && isBetweenOperator(props, operator) && newValue >= value2) {
        // user finished typing, let's fix the values
        if (node) {
          if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
            newValue = value2 - 1;
            node.value = utcToDatePicker(newValue, timeZone);
          }
          else if (filterField.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
            const prevDay = new Date(new Date(value2).getTime() - 86400000 + new Date().getTimezoneOffset() * 60000);
            newValue = `${prevDay.getFullYear()}-${prevDay.getMonth() < 9 ? "0" : ""}${prevDay.getMonth() + 1}-${prevDay.getDate() < 10 ? "0" : ""}${prevDay.getDate()}`;
            node.value = newValue;
          }
          else {
            newValue = value2 - 1;
            node.value = newValue;
          }
        }
      }
      if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT-DATE-PICKER" ||
        ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT" && (node === null || node === void 0 ? void 0 : node.type) === "number")) {
        this.adjustHistogramMinMax(newValue);
      }
      this.changeValues(newValue, value2);
    };
    this.onValue2ChangeMaybe = (event) => {
      const { props, operator, value } = this;
      const newValue = this.getNewValue(event);
      if (isDefined(newValue) && isBetweenOperator(props, operator) && newValue <= value) {
        // we assume the user is in the middle of typing
        return;
      }
      this.onValue2Change(event, newValue);
    };
    this.onValue2Change = (event, newValue) => {
      const { value, props, fieldName, operator } = this;
      const { view } = props;
      const { timeZone } = view;
      const filterField = getFieldInfo(fieldName, props);
      const node = event.target;
      newValue = newValue !== null && newValue !== void 0 ? newValue : this.getNewValue(event);
      if (!isDefined(newValue)) {
        // we need to have a value
        // fall back to default values
        const defaultValues = getDefaultValues(props, filterField, operator);
        newValue = defaultValues.value2;
        if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
          node.value = utcToDatePicker(newValue, timeZone);
        }
        else {
          node.value = newValue;
        }
      }
      // we're using between operator
      if (newValue <= value) {
        // user finished typing, let's fix the values
        if (filterField.simpleFieldType === simpleFieldTypes.DATE) {
          newValue = value + 1;
          node.value = utcToDatePicker(newValue, timeZone);
        }
        else if (filterField.simpleFieldType === simpleFieldTypes.DATE_ONLY) {
          const nextDay = new Date(new Date(value).getTime() + 86400000 + new Date().getTimezoneOffset() * 60000);
          newValue = `${nextDay.getFullYear()}-${nextDay.getMonth() < 9 ? "0" : ""}${nextDay.getMonth() + 1}-${nextDay.getDate() < 10 ? "0" : ""}${nextDay.getDate()}`;
          node.value = newValue;
        }
        else {
          newValue = value + 1;
          node.value = newValue;
        }
      }
      if (node.tagName === "CALCITE-INPUT-DATE-PICKER" ||
        (node.tagName === "CALCITE-INPUT" && node.type === "number")) {
        this.adjustHistogramMinMax(newValue);
      }
      this.changeValues(value, newValue);
    };
    this.onUnitSelect = (event) => {
      const select = event.target;
      //this.unit = select.selectedOption.value as timeUnits;
      this.emitChangeEvent({ unit: select.selectedOption.value });
    };
    this.onSelectUniqueValue = () => {
      this.onSelectUnique(false);
    };
    this.onSelectUniqueValues = () => {
      const { props, fieldName, operator } = this;
      const filterField = getFieldInfo(fieldName, props);
      const fieldDomains = hasFieldDomains(filterField);
      const listOperator = isListOperator(props, operator);
      const isDomainSingle = fieldDomains && !listOperator;
      this.onSelectUnique(!isDomainSingle);
    };
    this.onDocumentClick = (event) => {
      const target = event.target;
      const isTargetInsidePopover = target.closest(`#arcgis-filter-unique-popover_${this.uid}`);
      if (!isTargetInsidePopover) {
        this.removeUniquePopover();
      }
    };
    this.onRemoveSelectedValue = (value) => {
      const { values, esriLang } = this;
      const idx = values.indexOf(value);
      values.splice(idx, 1);
      //this.values = values.length ? esriLang.clone(values) : undefined;
      this.emitChangeEvent({ values: values.length ? esriLang.clone(values) : null });
    };
    this.afterCreateList = (element) => {
      if (!element) {
        return;
      }
      this.scrollExprIntoView(element);
    };
    this.onHistogramBlockToggle = (event) => {
      if (event.currentTarget.open) {
        this.onHistogramOpen();
      }
      else {
        this.onHistogramClose();
      }
    };
    this.fieldPickListChanges = (event) => {
      var _a, _b;
      event.stopPropagation();
      const selectedField = (_b = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.selectedFields) === null || _b === void 0 ? void 0 : _b[0];
      this.removeFieldsPickList();
      if (selectedField) {
        this.afterFieldSelect(selectedField);
      } // else user hit cancel or close
    };
    this.props = undefined;
    this.uid = undefined;
    this.fieldName = undefined;
    this.operator = undefined;
    this.uniqueValuesSortBy = undefined;
    this.value = undefined;
    this.value2 = undefined;
    this.values = undefined;
    this.unit = undefined;
    this.histogramOpen = undefined;
    this.hasFocus = undefined;
    this.invalidValue = undefined;
    this.reRender = false;
  }
  arcgisFilterUniqueValuesReturnedHandler(event) {
    const fieldName = event.detail;
    if (this.fieldName === fieldName) {
      this.checkDefaultValues(getFieldInfo(fieldName, this.props));
      this.reRender = !this.reRender;
    }
  }
  arcgisFilterUniqueListChangedHandler(event) {
    var _a;
    const { detail } = event;
    const uid = detail.uid;
    if (uid === this.uid) {
      const selectedValues = detail.selectedValues;
      if (!detail.multiple) {
        this.uniqueValuesSortBy = detail.sortBy;
        this.onValueChange(null, (selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.length) ? selectedValues[0] : undefined);
        this.removeUniquePopover();
        (_a = this.uniqueActionNode) === null || _a === void 0 ? void 0 : _a.setFocus();
      }
      else {
        this.emitChangeEvent({ values: selectedValues, uniqueValuesSortBy: detail.sortBy });
      }
    }
  }
  arcgisFilterUniqueListSortByChanged(event) {
    const { detail } = event;
    const uid = detail.uid;
    if (uid === this.uid) {
      this.uniqueValuesSortBy = detail.sortBy;
    }
  }
  arcgisFilterUniqueListDoneHandler(event) {
    var _a;
    const { detail } = event;
    if (detail === this.uid) {
      this.removeUniquePopover();
      (_a = this.uniqueActionNode) === null || _a === void 0 ? void 0 : _a.setFocus();
    }
  }
  calcitePopoverCloseHandler() {
    var _a;
    if (this.uniquePopoverNode) {
      this.removeUniquePopover();
      (_a = this.uniqueActionNode) === null || _a === void 0 ? void 0 : _a.setFocus();
    } // else something else removed the popover
  }
  closeFilterPopoversHandler() {
    this.removeFieldsPickList();
    this.removeUniquePopover();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    const defaultField = getDefaultField({
      fields: this.props.fields
    });
    this.fieldName = this.fieldName || defaultField.layerField.name;
    this.operator = this.operator || getDefaultOperator(this.props, defaultField);
    this.hasFocus = !!this.hasFocus;
    const [esriLang, intl, 
    //smartMappingUtils,
    summaryStatistics, histogram, uniqueValues, HistogramRangeSlider] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)([
      "esri/core/lang",
      "esri/intl",
      //"esri/widgets/smartMapping/support/utils",
      "esri/smartMapping/statistics/summaryStatistics",
      "esri/smartMapping/statistics/histogram",
      "esri/smartMapping/statistics/uniqueValues",
      "esri/widgets/HistogramRangeSlider"
    ]);
    this.esriLang = esriLang;
    this.intl = intl;
    //this.smartMappingUtils = smartMappingUtils;
    this.summaryStatistics = summaryStatistics;
    this.histogram = histogram;
    this.uniqueValues = uniqueValues;
    this.HistogramRangeSlider = HistogramRangeSlider;
    this.onDocumentClickBind = this.onDocumentClick.bind(this);
  }
  componentDidLoad() {
    this.setFocus();
  }
  disconnectedCallback() {
    this.removeFieldsPickList();
    this.removeUniquePopover();
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { fieldName, props } = this;
    const filterField = getFieldInfo(fieldName, props);
    /* console.log(
      "** render condition **",
      "uid",
      this.uid,
      "fieldName",
      this.fieldName,
      "operator",
      this.operator,
      "uniqueValuesSortBy",
      this.uniqueValuesSortBy,
      "value",
      this.value,
      "value2",
      this.value2,
      "values",
      this.values,
      "unit",
      this.unit,
      "histogramOpen",
      this.histogramOpen,
      "hasFocus",
      this.hasFocus,
      "histogramStatus",
      filterField.histogramStatus,
      "uniqueValuesStatus",
      filterField.uniqueValuesStatus,
      "reRender",
      this.reRender
    ); */
    if (!filterField || !filterField.simpleFieldType) {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null)));
    }
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { dir: dir }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
        [CSS$2.condition]: true,
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: dir === "rtl"
      } }, this.renderFieldSelection(), this.renderOperatorSelection(filterField), this.renderValueInput(filterField), this.renderHistogram(filterField))));
  }
  renderFieldSelection() {
    const { hasFocus, fieldName, props } = this;
    const { fields } = props;
    const field = getFieldInfo(fieldName, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", kind: "neutral", width: "full", scale: "m", alignment: "icon-end-space-between", disabled: fields.length <= 1, iconEnd: "chevron-down", class: `${hasFocus ? "autofocus" : ""}`, onClick: fields.length > 1 ? this.onFieldSelect : null, ref: (node) => (this.fieldNode = node) }, (field === null || field === void 0 ? void 0 : field.label) || ""));
  }
  renderOperatorSelection(filterField) {
    const { props } = this;
    const { operators, strings } = props;
    // TODO - also check field value type ?
    let type = filterField.simpleFieldType;
    if (!type) {
      return null;
    }
    if (type === simpleFieldTypes.GUID) {
      type = simpleFieldTypes.STRING;
    }
    if (type === simpleFieldTypes.OID) {
      type = simpleFieldTypes.NUMBER;
    }
    if (hasFieldDomains(filterField)) {
      type = simpleFieldTypes.DOMAIN;
    }
    const optionNodes = operators[type].map((operator) => this.renderOperatorOption(operator.name));
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.operator, class: CSS$2.operatorDropdown, onCalciteSelectChange: this.onOperatorSelect }, optionNodes));
  }
  renderOperatorOption(rendererOperator) {
    const { operator } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: rendererOperator, label: rendererOperator, selected: rendererOperator === operator }));
  }
  renderValueInput(filterField) {
    const { props, operator, invalidValue } = this;
    const status = invalidValue ? "invalid" : undefined;
    let contentNode = null;
    if (isBlankOperator(props, operator) || isEmptyOperator(props, operator)) {
      contentNode = null;
    }
    else if (isListOperator(props, operator)) {
      contentNode = this.renderUniqueValues(filterField);
    }
    else if (isInTheLastOperator(props, operator)) {
      contentNode = this.renderInTheLast();
    }
    else if (filterField.simpleFieldType === simpleFieldTypes.STRING ||
      filterField.simpleFieldType === simpleFieldTypes.GUID ||
      hasFieldDomains(filterField)) {
      contentNode = this.renderValueInputString(filterField, { status });
    }
    else if (filterField.simpleFieldType === simpleFieldTypes.NUMBER) {
      contentNode = this.renderValueInputNumber(filterField, { status });
    }
    else if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) > -1) {
      contentNode = this.renderValueInputDate(filterField);
    }
    else if (filterField.simpleFieldType === simpleFieldTypes.OID) {
      contentNode = this.renderValueInputOid(filterField, { status });
    }
    return invalidValue ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, contentNode, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-message", { icon: true, status: status }, invalidValue))) : (contentNode);
  }
  renderUniqueButton(supportsUnique, disabled, loading) {
    const { props } = this;
    const { layer, strings } = props;
    if (!supportsUnique || layer.type === "imagery" || layer.type === "subtype-group") {
      return null;
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { class: CSS$2.selectUniqueButton, disabled: disabled, loading: !!loading, text: strings.chooseFromUnique, scale: "s", icon: "chevron-down", onClick: !disabled ? this.onSelectUniqueValue : null, ref: (node) => {
        if (node) {
          this.uniqueActionNode = node;
        } // else no idea why this happens - TODO (set of 3 + 1 expr)
      } }));
  }
  renderValueInputString(filterField, inputOptions) {
    const { props, value, operator } = this;
    const { strings } = props;
    const uvStatus = filterField.uniqueValuesStatus;
    const uniqueValues = filterField.uniqueValueInfos;
    const supportsUnique = [strings.operators.stringOperatorIs, strings.operators.stringOperatorIsNot].indexOf(operator) > -1;
    const disabledUnique = supportsUnique &&
      (uvStatus === status.FAILED || (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)));
    const hasDomains = hasFieldDomains(filterField);
    const val = hasDomains ? getDecodedValue(value, filterField) : value;
    const loadingUnique = uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS;
    if (uvStatus === status.MISSING) {
      this.onDisplayUniqueValues(filterField.layerField.name);
    }
    return hasDomains ? (isDefined(val) ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { key: val, appearance: "outline-fill", kind: "neutral", width: "full", scale: "m", alignment: "icon-end-space-between", iconEnd: loadingUnique ? "spinner" : disabledUnique ? undefined : "chevron-down", disabled: disabledUnique, onClick: !disabledUnique ? this.onSelectUniqueValue : undefined, ref: (node) => {
        if (node) {
          this.uniqueActionNode = node;
        } // else no idea why this happens - TODO (set of 3 + 1 expr)
      } }, val ? `${val}` : ``))) : (
    // calcite-button must have text or icon, otherwise width is too small,
    // so use a div instead
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string", class: CSS$2.inputPlusUnique }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string-button", class: `${CSS$2.input} ${CSS$2.blankButton} ${uvStatus === status.SUCCESS ? `active` : `inactive`}`, tabIndex: -1, onClick: uvStatus === status.SUCCESS ? this.onSelectUniqueValue : undefined }), this.renderUniqueButton(supportsUnique, disabledUnique, loadingUnique)))) : ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-string", class: CSS$2.inputPlusUnique }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "text", value: val ? `${val}` : ``, class: CSS$2.input, scale: "m", label: strings.accessibility.value, onCalciteInputInput: this.onValueChange }, inputOptions)), this.renderUniqueButton(supportsUnique, disabledUnique, loadingUnique)));
  }
  renderValueInputNumber(filterField, inputOptions) {
    var _a;
    const { props, value, value2, operator } = this;
    const { strings } = props;
    const isFloat = isFloatType(filterField);
    if ([
      strings.operators.numberOperatorIsBetween,
      strings.operators.numberOperatorIsNotBetween
    ].indexOf(operator) > -1) {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", step: isFloat ? "any" : 1, label: strings.accessibility.fromValue, onCalciteInputInput: (event) => this.waitOnUser(event, this.onValueChangeMaybe) }, inputOptions)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${CSS$2.betweenValuesInput} first` }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value2) ? `${value2}` : ``, scale: "m", step: isFloat ? "any" : 1, class: CSS$2.betweenValuesInput, label: strings.accessibility.toValue, onCalciteInputInput: (event) => this.waitOnUser(event, this.onValue2ChangeMaybe) }, inputOptions))));
    }
    else {
      const uvStatus = filterField.uniqueValuesStatus;
      const uniqueValues = filterField.uniqueValueInfos;
      const supportsUnique = [
        strings.operators.numberOperatorIs,
        strings.operators.numberOperatorIsNot,
        strings.operators.numberOperatorIsAtLeast,
        strings.operators.numberOperatorIsAtMost,
        strings.operators.numberOperatorIsGreaterThan,
        strings.operators.numberOperatorIsLessThan
      ].indexOf(operator) > -1;
      const inputNode = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ class: CSS$2.input, type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", step: isFloat ? "any" : 1, label: strings.accessibility.value, onCalciteInputInput: (event) => this.waitOnUser(event, this.onValueChange) }, inputOptions)));
      if (uvStatus === status.FAILED ||
        (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) ||
        !supportsUnique) {
        return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-number" }, inputNode);
      }
      else if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
        if (uvStatus === status.MISSING) {
          this.onDisplayUniqueValues(filterField.layerField.name);
        }
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-number", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, true, true)));
      }
      else {
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-number", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, !((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length))));
      }
    }
  }
  renderValueInputDate(filterField) {
    var _a;
    const { props, value, value2, operator } = this;
    const { view, strings } = props;
    const { timeZone } = view;
    const dateString = typeof value === "number" ? utcToDatePicker(value, timeZone) : value;
    if ([strings.operators.dateOperatorIsBetween, strings.operators.dateOperatorIsNotBetween].indexOf(operator) > -1) {
      const dateString2 = typeof value2 === "number" ? utcToDatePicker(value2, timeZone) : value2;
      // not using range option, because there is no equivalent for number fields
      // and 'not in between' might be weird if the between area is highlighted in the calendar
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-date-picker", { class: `${CSS$2.datePicker} first`, scale: "m", value: dateString, overlayPositioning: "fixed", onCalciteInputDatePickerChange: this.onValueChange }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-date-picker", { class: CSS$2.datePicker, scale: "m", value: dateString2, overlayPositioning: "fixed", onCalciteInputDatePickerChange: this.onValue2Change })));
    }
    else {
      const uvStatus = filterField.uniqueValuesStatus;
      const uniqueValues = filterField.uniqueValueInfos;
      const supportsUnique = [
        strings.operators.dateOperatorIsOn,
        strings.operators.dateOperatorIsNotOn,
        strings.operators.dateOperatorIsAfter,
        strings.operators.dateOperatorIsBefore
      ].indexOf(operator) > -1;
      const inputNode = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-date-picker", { class: `${CSS$2.datePicker} ${CSS$2.input}`, scale: "m", value: dateString, overlayPositioning: "fixed", onCalciteInputDatePickerChange: this.onValueChange }));
      if (uvStatus === status.FAILED ||
        (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) ||
        !supportsUnique) {
        return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-date" }, inputNode);
      }
      else if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
        if (uvStatus === status.MISSING) {
          this.onDisplayUniqueValues(filterField.layerField.name);
        }
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-date", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, true, true)));
      }
      else {
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-date", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, !((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length))));
      }
    }
  }
  renderValueInputOid(filterField, inputOptions) {
    var _a;
    const { props, value, value2, operator } = this;
    const { strings } = props;
    if (filterField.simpleFieldType === simpleFieldTypes.OID) {
      // we don't allow decimals
      if (isDefined(value) && isDefined(value2)) {
        const roundedVal = Math.round(value);
        const roundedVal2 = Math.round(value2);
        if (roundedVal !== value || roundedVal2 !== value2) {
          this.changeValues(roundedVal, roundedVal2);
        }
      }
      else if (isDefined(value)) {
        const roundedVal = Math.round(value);
        if (roundedVal !== value) {
          this.changeValues(roundedVal, value2);
        }
      }
      else if (isDefined(value2)) {
        const roundedVal = Math.round(value2);
        if (roundedVal !== value2) {
          this.changeValues(value, roundedVal);
        }
      }
    }
    if ([
      strings.operators.numberOperatorIsBetween,
      strings.operators.numberOperatorIsNotBetween
    ].indexOf(operator) > -1) {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", min: 0, step: 1, label: strings.accessibility.fromValue, onCalciteInputInput: this.onValueChangeMaybe }, inputOptions)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${CSS$2.betweenValuesInput} first` }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ type: "number", value: isDefined(value2) ? `${value2}` : ``, scale: "m", min: 0, step: 1, class: CSS$2.betweenValuesInput, label: strings.accessibility.toValue, onCalciteInputInput: this.onValue2ChangeMaybe }, inputOptions))));
    }
    else {
      const uvStatus = filterField.uniqueValuesStatus;
      const uniqueValues = filterField.uniqueValueInfos;
      const supportsUnique = [
        strings.operators.numberOperatorIs,
        strings.operators.numberOperatorIsNot,
        strings.operators.numberOperatorIsAtLeast,
        strings.operators.numberOperatorIsAtMost,
        strings.operators.numberOperatorIsGreaterThan,
        strings.operators.numberOperatorIsLessThan
      ].indexOf(operator) > -1;
      const inputNode = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", Object.assign({ class: CSS$2.input, type: "number", value: isDefined(value) ? `${value}` : ``, scale: "m", min: 0, step: 1, label: strings.accessibility.value, onCalciteInputInput: this.onValueChange }, inputOptions)));
      if (uvStatus === status.FAILED ||
        (uvStatus === status.SUCCESS && !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) ||
        !supportsUnique) {
        return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-oid" }, inputNode);
      }
      else if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
        if (uvStatus === status.MISSING) {
          this.onDisplayUniqueValues(filterField.layerField.name);
        }
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-oid", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, true, true)));
      }
      else {
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: "value-input-oid", class: CSS$2.inputPlusUnique }, inputNode, this.renderUniqueButton(supportsUnique, !((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length))));
      }
    }
  }
  renderUniqueValues(filterField) {
    const { props, values, fieldName } = this;
    const { strings } = props;
    const uvStatus = filterField.uniqueValuesStatus;
    const uniqueValues = filterField.uniqueValueInfos;
    if (uvStatus === status.MISSING || uvStatus === status.IN_PROGRESS) {
      if (uvStatus === status.MISSING) {
        this.onDisplayUniqueValues(filterField.layerField.name);
      }
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-loader", { class: CSS$2.smallLoader, inline: true, label: "" })));
    }
    else if (uvStatus === status.FAILED) {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.uniqueValuesContentListMsg }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", width: "full", scale: "m", alignment: "center", class: CSS$2.selectValues, disabled: true, label: strings.selectValues }, strings.selectValues), strings.errors.errorUniqueValues));
    }
    else {
      const msg1Node = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.uniqueValuesContentListMsg }, !(values === null || values === void 0 ? void 0 : values.length) && (uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length) ? strings.selectOneValue : ""));
      let msg2Node;
      if (!(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length)) {
        msg2Node = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.uniqueValuesContentListMsg }, strings.errors.noUniqueValues));
      }
      const list = values === null || values === void 0 ? void 0 : values.map((value) => this.renderSelectedUniqueValue(value, filterField));
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, msg1Node, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", width: "full", scale: "m", alignment: "center", class: CSS$2.selectValues, disabled: !(uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length), onClick: (uniqueValues === null || uniqueValues === void 0 ? void 0 : uniqueValues.length) > 0 ? this.onSelectUniqueValues : null, ref: (node) => (this.uniqueSelectNode = node), label: strings.selectValues }, strings.selectValues), msg2Node, (values === null || values === void 0 ? void 0 : values.length) ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { key: `unique-values-value-list-${fieldName}`, class: CSS$2.pickList, ref: this.afterCreateList }, list)) : null));
    }
  }
  renderSelectedUniqueValue(value, filterField) {
    const { intl, props } = this;
    const { view, strings } = props;
    const { timeZone } = view;
    const val = hasFieldDomains(filterField)
      ? getDecodedValue(value, filterField)
      : isDateType(filterField)
        ? getDateDisplayString(value, timeZone, intl) //intl.formatDate(new Date(value), intl.convertDateFormatToIntlOptions("short-date"))
        : isDateOnlyType(filterField)
          ? intl.formatDateOnly(value, intl.convertDateFormatToIntlOptions("short-date"))
          : isNumberType(filterField)
            ? intl.formatNumber(value)
            : value;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list-item", { label: `${val}`, value: `${value}` }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { slot: "actions-end", text: strings.remove, icon: "x", onClick: this.onRemoveSelectedValue.bind(this, value) })));
  }
  renderInTheLast() {
    const { props, value, unit } = this;
    const { strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.inTheLast }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { type: "number", min: 1, step: 1, value: isDefined(value) ? `${value}` : ``, scale: "m", class: CSS$2.inTheLastCount, label: strings.accessibility.value, onCalciteInputInput: this.onValueChange }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.units, class: CSS$2.inTheLastUnit, onCalciteSelectChange: this.onUnitSelect }, this.renderInTheLastOption(timeUnits.MINUTE, unit === timeUnits.MINUTE), this.renderInTheLastOption(timeUnits.HOUR, unit === timeUnits.HOUR), this.renderInTheLastOption(timeUnits.DAY, unit === timeUnits.DAY), this.renderInTheLastOption(timeUnits.WEEK, unit === timeUnits.WEEK), this.renderInTheLastOption(timeUnits.MONTH, unit === timeUnits.MONTH), this.renderInTheLastOption(timeUnits.YEAR, unit === timeUnits.YEAR))));
  }
  renderInTheLastOption(unit, isSelected) {
    const { props } = this;
    const { strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: unit, label: strings.units[unit], selected: isSelected }));
  }
  renderHistogram(filterField) {
    const { props, histogramOpen, operator, fieldName } = this;
    const { layer, strings } = props;
    if (layer.type === "imagery" || layer.type === "subtype-group") {
      return null;
    }
    if (!filterField || !filterField.simpleFieldType) {
      return null;
    }
    if (filterField.statisticsStatus === status.FAILED) {
      return null;
    }
    if (!supportsHistogram(fieldName, operator, props)) {
      return null;
    }
    if (histogramOpen === undefined ||
      (histogramOpen && filterField.histogramStatus === status.MISSING)) {
      // open histogram block by default; or get info we need
      this.onHistogramOpen();
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { open: histogramOpen !== false, text: filterField.histogramStatus === status.FAILED ? strings.valueRange : strings.histogram, onCalciteBlockSectionToggle: this.onHistogramBlockToggle }, this.renderHistogramContent(filterField)));
  }
  renderHistogramContent(filterField) {
    const { histogramOpen } = this;
    const fieldName = filterField.layerField.name;
    if (histogramOpen === false) {
      return null;
    }
    if (!filterField.statistics || filterField.histogramStatus === status.IN_PROGRESS) {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `histogram-content-${fieldName}-${filterField.statistics}`, class: filterField.histogram ? CSS$2.histogramContent : CSS$2.histogramContentSlim }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-loader", { class: CSS$2.smallLoader, inline: true, label: "" })));
    }
    else {
      const ok = this.prepareSlider(filterField);
      if (ok) {
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `histogram-content-${fieldName}-${filterField.statistics}`, class: `${filterField.histogram ? CSS$2.histogramContent : CSS$2.histogramContentSlim}`, ref: this.afterCreateSliderDiv }));
      }
      else {
        // don't have a slider yet, need to wait a little longer
        return null;
      }
    }
  }
  // --------------------------------------------------------------------------
  //
  //  Private methods
  //
  // --------------------------------------------------------------------------
  setFocus() {
    setTimeout(() => {
      const node = this.hostElement.querySelector(".autofocus");
      if (node) {
        node.setFocus();
      }
    }, 500);
  }
  onSelectUnique(multiple) {
    var _a;
    const { props, value, values, fieldName, uid, uniqueValuesSortBy, esriLang } = this;
    const { strings, localeIntl } = props;
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
    if (this.uniquePopoverNode) {
      this.closeFilterPopoversHandler();
      // just close the popover
      return;
    }
    this.closeFilterPopoversHandler();
    const filterField = getFieldInfo(fieldName, props);
    if (!filterField) {
      return;
    }
    const nodeWidth = (_a = this.fieldNode) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width;
    const width = nodeWidth ? nodeWidth + 2 : 204;
    // we can't use a panel because we don't want a header
    const panelNode = (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_4__.q)(this.hostElement, "calcite-panel");
    const nodeHeight = panelNode === null || panelNode === void 0 ? void 0 : panelNode.clientHeight;
    const maxHeight = nodeHeight ? Math.max(Math.min(nodeHeight / 3, 400), 240) : 400;
    const popoverUnique = document.createElement("calcite-popover");
    popoverUnique.id = `arcgis-filter-unique-popover_${uid}`;
    popoverUnique.placement = dir === "rtl" ? "bottom-start" : "bottom-end";
    popoverUnique.offsetDistance = 0;
    popoverUnique.offsetSkidding = 0;
    popoverUnique.pointerDisabled = true;
    popoverUnique.style = `width: ${width}px;`;
    popoverUnique.referenceElement = multiple ? this.uniqueSelectNode : this.uniqueActionNode;
    const uniqueList = document.createElement("arcgis-filter-unique-list");
    uniqueList.uid = uid;
    uniqueList.props = props;
    uniqueList.uniqueValues = esriLang.clone(filterField.uniqueValueInfos);
    uniqueList.selectedValues = multiple ? values : value ? [value] : [];
    uniqueList.fieldDomains = filterField.fieldDomains;
    uniqueList.layerFieldType = filterField.layerField.type;
    uniqueList.isDate =
      [simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) > -1;
    uniqueList.multiple = multiple;
    uniqueList.sortBy = uniqueValuesSortBy;
    uniqueList.partialUniqueValues = filterField.partialUniqueValues;
    uniqueList.maxHeight = maxHeight;
    uniqueList.strings = strings;
    uniqueList.locale = localeIntl;
    // otherwise there's an issue with the width of the list...
    uniqueList.style = `min-width: ${width}px`;
    popoverUnique.appendChild(uniqueList);
    document.body.appendChild(popoverUnique);
    popoverUnique.open = true;
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f)(uniqueList);
    uniqueList.setFocus();
    popoverUnique.reposition();
    this.uniquePopoverNode = popoverUnique;
    setTimeout(() => {
      document.addEventListener("click", this.onDocumentClickBind);
    }, 50);
  }
  scrollExprIntoView(node) {
    setTimeout(() => {
      if (node) {
        node = (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_4__.q)(node, ".filter-expression");
        node === null || node === void 0 ? void 0 : node.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "start"
        });
      }
    }, 100);
  }
  removeUniquePopover() {
    var _a;
    document.removeEventListener("click", this.onDocumentClickBind);
    if (this.uniquePopoverNode) {
      /* const popover = this.uniquePopoverNode?.childNodes?.[0] as HTMLCalcitePopoverElement;
      if (popover) {
        popover.open = false;
      } */
      this.uniquePopoverNode.open = false;
      // need the ? here...
      (_a = this.uniquePopoverNode) === null || _a === void 0 ? void 0 : _a.parentElement.removeChild(this.uniquePopoverNode);
      this.uniquePopoverNode = undefined;
    }
  }
  async onDisplayUniqueValues(fieldName) {
    var _a;
    const { props, uniqueValues } = this;
    const { layer, view, featureReduction } = props;
    const filterField = getFieldInfo(fieldName, props);
    if (!filterField || layer.type === "imagery" || layer.type === "subtype-group") {
      return;
    }
    if (filterField.uniqueValuesStatus === status.MISSING && layer) {
      filterField.uniqueValuesStatus = status.IN_PROGRESS;
      try {
        const uniqueValuesResult = await uniqueValues({
          layer,
          view,
          field: fieldName,
          forBinning: featureReduction && ["binning", "cluster"].indexOf((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) > -1
        });
        // uniqueValueInfos: [{value, count},...]
        //console.log("success-uniqueValues", uniqueValuesResult);
        // e.g. coded value domains
        const isNumber = isNumberType(filterField);
        const uniqueValueInfos = uniqueValuesResult.uniqueValueInfos.filter((info) => {
          // value is always a string, because we read it from the renderer
          if (!isDefined(info.value)) {
            return false;
          }
          else if ((filterField.simpleFieldType === "string" && !isNumber) ||
            filterField.simpleFieldType === "guid") {
            return info.value !== "<Null>" && `${info.value}`.trim() !== ""; // we don't allow empty strings
          }
          else if (filterField.simpleFieldType === "number" ||
            filterField.simpleFieldType === "oid" ||
            isNumber) {
            return info.value !== "<Null>" && info.value !== "";
          }
          else {
            // "date"
            return info.value !== "<Null>" && info.value !== "";
          }
        });
        // sort by count
        uniqueValueInfos.sort((a, b) => a.count > b.count ? -1 : a.count < b.count ? 1 : 0);
        if (hasFieldDomains(filterField)) {
          // add domains that are not used in any feature
          filterField.fieldDomains.forEach((fieldDomain) => {
            if (!uniqueValueInfos.find((obj) => obj.value === fieldDomain.code)) {
              uniqueValueInfos.push({
                value: fieldDomain.code,
                count: 0
              });
            }
          });
        }
        // TODO partialData
        const partialUniqueValues = uniqueValuesResult.uniqueValueInfos.length === 2000;
        props.fields = props.fields.map((field) => field.layerField.name === fieldName
          ? Object.assign(Object.assign({}, field), { uniqueValueInfos, uniqueValuesStatus: status.SUCCESS, partialUniqueValues }) : field);
        this.arcgisFilterUniqueValuesReturned.emit(filterField.layerField.name);
      }
      catch (error) {
        console.error("error-uniqueValues", error);
        if (hasFieldDomains(filterField)) {
          // use domains from layer
          const uniqueValueInfos = [];
          filterField.fieldDomains.forEach((fieldDomain) => {
            if (!uniqueValueInfos.find((obj) => obj.value === fieldDomain.code)) {
              uniqueValueInfos.push({
                value: fieldDomain.code,
                count: undefined
              });
            }
          });
          props.fields = props.fields.map((field) => field.layerField.name === fieldName
            ? Object.assign(Object.assign({}, field), { uniqueValueInfos, uniqueValuesStatus: status.SUCCESS, partialUniqueValues: false }) : field);
        }
        else {
          props.fields = props.fields.map((field) => field.layerField.name === fieldName
            ? Object.assign(Object.assign({}, field), { uniqueValuesStatus: status.FAILED }) : field);
        }
        this.reRender = !this.reRender;
      }
    }
  }
  async onHistogramOpen() {
    var _a, _b;
    const { props, fieldName, summaryStatistics, histogram } = this;
    const { layer, view, featureReduction } = props;
    const filterField = getFieldInfo(fieldName, props);
    if (!layer || layer.type === "imagery" || layer.type === "subtype-group" || !filterField) {
      return;
    }
    if (filterField.statistics) {
      this.checkDefaultValues(filterField);
      this.histogramOpen = true;
    }
    else if (!filterField.statistics) {
      props.fields = props.fields.map((field) => field.layerField.name === fieldName
        ? Object.assign(Object.assign({}, field), { statisticsStatus: status.IN_PROGRESS }) : field);
      try {
        const statistics = await summaryStatistics({
          layer,
          view,
          field: fieldName,
          forBinning: featureReduction && ["binning", "cluster"].indexOf((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) > -1
        });
        //console.log("success-statistics", fieldName, statistics);
        if (!isDefined(statistics.avg) ||
          !isDefined(statistics.min) ||
          !isDefined(statistics.max)) {
          // field has maybe no values; statistics is unusable
          props.fields = props.fields.map((field) => field.layerField.name === fieldName
            ? Object.assign(Object.assign({}, field), { statisticsStatus: status.FAILED }) : field);
          this.histogramOpen = false;
          return;
        }
        if (statistics.min === statistics.max) {
          if (statistics.min > 0) {
            statistics.min = statistics.min - 0.1 * statistics.min;
            statistics.max = statistics.max + 0.1 * statistics.max;
          }
          else if (statistics.min < 0) {
            statistics.min = statistics.min + 0.1 * statistics.min;
            statistics.max = statistics.max - 0.1 * statistics.max;
          }
          else {
            statistics.min = -1;
            statistics.max = 1;
          }
        }
        props.fields = props.fields.map((field) => field.layerField.name === fieldName
          ? Object.assign(Object.assign({}, field), { statistics, statisticsStatus: status.SUCCESS }) : field);
        this.checkDefaultValues(filterField);
        try {
          const result = await histogram({
            layer,
            view,
            field: fieldName,
            numBins: 30,
            minValue: statistics.min,
            maxValue: statistics.max,
            forBinning: featureReduction && ["binning", "cluster"].indexOf((_b = layer.featureReduction) === null || _b === void 0 ? void 0 : _b.type) > -1
          });
          //console.log("success-histogram", fieldName, result);
          props.fields = props.fields.map((field) => field.layerField.name === fieldName
            ? Object.assign(Object.assign({}, field), { histogram: result, histogramStatus: status.SUCCESS }) : field);
          this.reRender = !this.reRender;
        }
        catch (error) {
          console.error("error-histogram", error);
          props.fields = props.fields.map((field) => field.layerField.name === fieldName
            ? Object.assign(Object.assign({}, field), { histogramStatus: status.FAILED }) : field);
          this.reRender = !this.reRender;
        }
      }
      catch (error) {
        console.error("error-summaryStatistics", error);
        props.fields = props.fields.map((field) => field.layerField.name === fieldName
          ? Object.assign(Object.assign({}, field), { statisticsStatus: status.FAILED, histogramStatus: status.FAILED }) : field);
        this.histogramOpen = false;
        this.reRender = !this.reRender;
      }
    }
  }
  onHistogramClose() {
    this.histogramOpen = false;
  }
  async onMinMaxChange(min, max, fieldName) {
    var _a;
    const { props, value, value2, histogram } = this;
    const { layer, view, featureReduction } = props;
    const filterField = getFieldInfo(fieldName, props);
    if (!filterField || layer.type === "imagery" || layer.type === "subtype-group") {
      return;
    }
    this.value = Math.min(Math.max(value, min), max);
    if (isDefined(value2)) {
      this.value2 = Math.min(Math.max(value2, min), max);
    }
    this.histogramOpen = true;
    props.fields = props.fields.map((field) => field.layerField.name === fieldName
      ? Object.assign(Object.assign({}, field), { histogramStatus: status.IN_PROGRESS }) : field);
    try {
      const result = await histogram({
        layer,
        view,
        field: filterField.layerField.name,
        numBins: 30,
        minValue: min,
        maxValue: max,
        forBinning: featureReduction && ["binning", "cluster"].indexOf((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) > -1
      });
      //console.log("success-histogram", result);
      props.fields = props.fields.map((field) => field.layerField.name === fieldName
        ? Object.assign(Object.assign({}, field), { histogram: result, histogramStatus: status.SUCCESS }) : field);
      this.reRender = !this.reRender;
    }
    catch (error) {
      console.error("error-histogram", error);
      props.fields = props.fields.map((field) => field.layerField.name === fieldName
        ? Object.assign(Object.assign({}, field), { histogramStatus: status.FAILED }) : field);
    }
  }
  adjustHistogramMinMax(value) {
    const { histogramSlider } = this;
    if (histogramSlider) {
      if (histogramSlider.min > value) {
        histogramSlider.set({ min: value });
      }
      if (histogramSlider.max < value) {
        histogramSlider.set({ max: value });
      }
    }
  }
  prepareSlider(filterField) {
    var _a, _b;
    const { histogramSliderFieldName: sliderFieldName } = this;
    let { value, value2, histogramSlider: slider } = this;
    const statistics = filterField.statistics;
    if (filterField.histogramStatus === status.IN_PROGRESS) {
      // no updates to the slider
      //console.log("no slider updates");
      return false;
    }
    // string values are wrong here
    if (isDefined(value) && typeof value !== "number") {
      value = undefined;
    }
    if (isDefined(value2) && typeof value2 !== "number") {
      value2 = undefined;
    }
    this.checkDefaultValues(filterField);
    // refresh
    value = this.value;
    value2 = this.value2;
    // make sure we have the correct number of values
    const values = [];
    values.push(value);
    if (isDefined(value2)) {
      values.push(value2);
    }
    if (isIntegerType(filterField)) {
      if (isDefined(values[0])) {
        const roundedVal = Math.round(values[0]);
        if (roundedVal !== values[0]) {
          this.changeValues(roundedVal, value2);
        }
        values[0] = roundedVal;
      }
      if (isDefined(values[1])) {
        const roundedVal = Math.round(values[1]);
        if (roundedVal !== values[1]) {
          this.changeValues(value, roundedVal);
        }
        values[1] = roundedVal;
      }
    }
    // adjust the slider if values are outside of range
    let min = filterField.histogram ? filterField.histogram.minValue : statistics.min;
    let max = filterField.histogram ? filterField.histogram.maxValue : statistics.max;
    if (isDefined(values[0]) && isDefined(values[1])) {
      min = Math.min(min, values[0]);
      max = Math.max(max, values[1]);
    }
    else if (isDefined(values[0])) {
      min = Math.min(min, values[0]);
      max = Math.max(max, values[0]);
    }
    if (slider && sliderFieldName !== filterField.layerField.name) {
      // change maybe because of a deleted expression or condition
      slider.destroy();
      slider = undefined;
    }
    if (!slider) {
      // new histogram
      const config = {
        bins: (_a = filterField.histogram) === null || _a === void 0 ? void 0 : _a.bins,
        average: Math.round(statistics.avg * 10) / 10,
        //standardDeviation: filterField.statistics.stddev,
        min: min,
        max: max,
        values: (values === null || values === void 0 ? void 0 : values[0]) === undefined ? undefined : values,
        rangeType: this.getSliderRangeType(),
        precision: isIntegerType(filterField) ? 0 : 4
      };
      if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) >
        -1) {
        config.hasTimeData = true;
        this.addDateFormatFunctions(config);
      }
      this.histogramSliderFieldName = filterField.layerField.name;
      this.histogramSlider = new this.HistogramRangeSlider(config);
      //console.log("new HistogramRangeSlider", config);
      this.createSliderChangeEvents(filterField);
    }
    else {
      // update histogram slider
      const config = {
        bins: (_b = filterField.histogram) === null || _b === void 0 ? void 0 : _b.bins,
        average: Math.round(statistics.avg * 10) / 10,
        min: min,
        max: max,
        values: (values === null || values === void 0 ? void 0 : values[0]) === undefined ? undefined : values,
        rangeType: this.getSliderRangeType()
      };
      //console.log("update HistogramRangeSlider", config, values);
      slider.set(config);
    }
    return true;
  }
  createSliderChangeEvents(filterField) {
    const { histogramSlider } = this;
    if (!histogramSlider) {
      return;
    }
    histogramSlider.on("min-change", (event /*ValueChangeEvent*/) => {
      const slider = histogramSlider;
      this.onMinMaxChange(event.value, slider.max, filterField.layerField.name);
    });
    histogramSlider.on("max-change", (event /*ValueChangeEvent*/) => {
      const slider = histogramSlider;
      this.onMinMaxChange(slider.min, event.value, filterField.layerField.name);
    });
    histogramSlider.watch("values", ( /* values: number[] */) => {
      var _a, _b;
      const slider = histogramSlider;
      let value = (_a = slider.values) === null || _a === void 0 ? void 0 : _a[0];
      let value2 = (_b = slider.values) === null || _b === void 0 ? void 0 : _b[1];
      if ([simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(filterField.simpleFieldType) >
        -1) {
        value = Math.round(value);
      }
      if (isIntegerType(filterField)) {
        if (value2 || value === 0) {
          value = Math.floor(value);
          value2 = Math.ceil(value2);
        }
        else {
          value = Math.round(value);
        }
      }
      this.changeValues(value, value2);
    });
    histogramSlider.on("segment-drag", ( /*event: any SegmentDragEvent*/) => {
      const slider = histogramSlider;
      let value = slider.values[0];
      let value2 = slider.values[1];
      if (isIntegerType(filterField)) {
        if (value2 || value === 0) {
          value = Math.floor(value);
          value2 = Math.ceil(value2);
        }
        else {
          value = Math.round(value);
        }
      }
      this.changeValues(value, value2);
    });
  }
  getSliderRangeType() {
    const { props, operator } = this;
    const { strings } = props;
    switch (operator) {
      case strings.operators.numberOperatorIs:
      case strings.operators.dateOperatorIsOn:
        return "equal";
      case strings.operators.numberOperatorIsNot:
      case strings.operators.dateOperatorIsNotOn:
        return "not-equal";
      case strings.operators.numberOperatorIsLessThan:
      case strings.operators.dateOperatorIsBefore:
        return "less-than";
      case strings.operators.numberOperatorIsGreaterThan:
      case strings.operators.dateOperatorIsAfter:
        return "greater-than";
      case strings.operators.numberOperatorIsAtMost:
        return "at-most";
      case strings.operators.numberOperatorIsAtLeast:
        return "at-least";
      case strings.operators.numberOperatorIsBetween:
      case strings.operators.dateOperatorIsBetween:
        return "between";
      case strings.operators.numberOperatorIsNotBetween:
      case strings.operators.dateOperatorIsNotBetween:
        return "not-between";
      default:
        return "";
    }
  }
  getNewValue(event) {
    const { view } = this.props;
    const { timeZone } = view;
    const node = event === null || event === void 0 ? void 0 : event.target;
    let newValue;
    if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT-DATE-PICKER") {
      newValue = node.value; //valueAsDate; -> valueAsDate seems to have a time offset
      if (!newValue) {
        return;
      }
      newValue = datePickerToUTC(new Date(newValue), timeZone);
    }
    else if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT" && node.type === "number") {
      newValue = node.value;
      if (!newValue) {
        return;
      }
      newValue = parseFloat(newValue);
    }
    else if ((node === null || node === void 0 ? void 0 : node.tagName) === "CALCITE-INPUT") {
      // text
      newValue = node.value;
      if (!(newValue === null || newValue === void 0 ? void 0 : newValue.length)) {
        newValue = undefined;
      }
    }
    return newValue;
  }
  addDateFormatFunctions(config) {
    const { intl, props } = this;
    const { view } = props;
    const { timeZone } = view;
    config.labelFormatFunction = (value) => {
      //return this.smartMappingUtils.formatDateLabel(utcToMapTZ(value, timeZone));
      return getDateDisplayString(value, timeZone, intl, "short-date");
    };
    config.inputFormatFunction = (value) => {
      //return this.smartMappingUtils.formatDateLabel(utcToMapTZ(value, timeZone));
      return getDateDisplayString(value, timeZone, intl, "short-date");
    };
    config.inputParseFunction = (value /* , type: string, index: number */) => {
      return mapTZToUTC(Date.parse(value), timeZone);
    };
  }
  changeValues(value, value2) {
    const { props, fieldName } = this;
    const filterField = getFieldInfo(fieldName, props);
    const newValue = filterField.simpleFieldType &&
      [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.OID].indexOf(filterField.simpleFieldType) > -1
      ? isNaN(value)
        ? null
        : value
      : value;
    const newValue2 = filterField.simpleFieldType &&
      [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.OID].indexOf(filterField.simpleFieldType) > -1
      ? isNaN(value2)
        ? null
        : value2
      : value2;
    if (this.value !== newValue || this.value2 !== newValue2) {
      //this.value = newValue;
      //this.value2 = newValue2;
      this.emitChangeEvent({
        value: newValue !== null && newValue !== void 0 ? newValue : null,
        value2: newValue2 !== null && newValue2 !== void 0 ? newValue2 : null
      });
    }
  }
  checkDefaultValues(filterField) {
    const { props, operator, value, value2, histogramSlider: slider } = this;
    const statistics = filterField.statistics;
    const defaultValues = getDefaultValues(props, filterField, operator);
    if (isInTheLastOperator(props, operator)) {
      if (!isDefined(value)) {
        const now = new Date().getTime();
        const range = Math.abs(now - statistics.avg);
        let value, unit;
        if (range > 2 * timeRange.YEAR) {
          value = Math.round(range / timeRange.YEAR);
          unit = timeUnits.YEAR;
        }
        else {
          if (range > 2 * timeRange.MONTH) {
            value = Math.round(range / timeRange.MONTH);
            unit = timeUnits.MONTH;
          }
          else {
            if (range > 2 * timeRange.WEEK) {
              value = Math.round(range / timeRange.WEEK);
              unit = timeUnits.WEEK;
            }
            else {
              if (range > 2 * timeRange.DAY) {
                value = Math.round(range / timeRange.DAY);
                unit = timeUnits.DAY;
              }
              else {
                if (range > 2 * timeRange.HOUR) {
                  value = Math.round(range / timeRange.HOUR);
                  unit = timeUnits.HOUR;
                }
                else {
                  value = Math.round(range / timeRange.MINUTE);
                  unit = timeUnits.MINUTE;
                }
              }
            }
          }
        }
        //this.value = value;
        //this.unit = unit;
        this.emitChangeEvent({ value, unit });
      }
    }
    else if (isBetweenOperator(props, operator)) {
      if (isDefined(value)) {
        if (isDefined(value2)) {
          if (value2 < value) {
            // let's correct the one that was changed last
            if (slider && slider.values[0] === value) {
              this.changeValues(value, value);
            }
            else {
              this.changeValues(value2, value2);
            }
          }
        }
        else {
          // need a second value
          const val = isIntegerType(filterField) ? Math.round(statistics.max) : statistics.max;
          this.changeValues(value, val);
        }
      }
      else {
        // need values
        if (isDefined(value2)) {
          const val = fieldTypeRound(statistics === null || statistics === void 0 ? void 0 : statistics.avg, props, filterField);
          this.changeValues(val, value2);
        }
        else {
          this.changeValues(defaultValues.value, defaultValues.value2);
        }
      }
    }
    else {
      if (!isDefined(value)) {
        this.changeValues(defaultValues.value, defaultValues.value2);
      }
    }
    // most of the times don't need this return
    return defaultValues;
  }
  openFieldPickList() {
    const { props, fieldName, fieldPickListSortBy } = this;
    const { layer, view, featureReduction } = props;
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
    this.closeFilterPopoversHandler();
    const panelNode = (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_4__.q)(this.hostElement, "#filter-panel");
    const closeNode = panelNode.querySelector("#arcgis-filter-close");
    const nodeWidth = panelNode === null || panelNode === void 0 ? void 0 : panelNode.getBoundingClientRect().width;
    this.arcgisFieldPickList = document.createElement("arcgis-field-pick-list");
    this.arcgisFieldPickList.popoverProps = closeNode
      ? {
        placement: dir === "rtl" ? "bottom-start" : "bottom-end",
        offsetDistance: 20,
        offsetSkidding: 15,
        pointerDisabled: true,
        popoverWidth: nodeWidth ? nodeWidth + 30 : 280,
        refElement: closeNode
      }
      : {
        placement: "auto",
        // we don't have an action bar in layer view where it is used without a close button
        offsetDistance: -1 * (nodeWidth ? nodeWidth - 5 : 215),
        offsetSkidding: 0,
        pointerDisabled: true,
        popoverWidth: nodeWidth ? nodeWidth + 30 : 280,
        refElement: panelNode
      };
    this.arcgisFieldPickList.fields = this.createPickListFields();
    this.arcgisFieldPickList.layer = layer;
    this.arcgisFieldPickList.mapView = view;
    this.arcgisFieldPickList.showFieldInfo = true;
    this.arcgisFieldPickList.showFieldName = false;
    this.arcgisFieldPickList.selectedFields = [fieldName];
    this.arcgisFieldPickList.sortBy = fieldPickListSortBy;
    this.arcgisFieldPickList.showFieldInfo = !featureReduction;
    this.arcgisFieldPickList.addEventListener("arcgisFieldPickListDismissed", this.fieldPickListChanges);
    this.arcgisFieldPickList.addEventListener("arcgisFieldPickListSortByChange", (event) => (this.fieldPickListSortBy = event.detail));
    document.body.appendChild(this.arcgisFieldPickList);
    this.disableFilterPanel.emit(true);
  }
  createPickListFields() {
    const { props } = this;
    const { fields } = props;
    return fields.map((field) => {
      return {
        name: field.layerField.name,
        alias: field.label,
        type: field.simpleFieldType
      };
    });
  }
  removeFieldsPickList() {
    this.disableFilterPanel.emit(false);
    if (this.arcgisFieldPickList) {
      document.body.removeChild(this.arcgisFieldPickList);
      this.arcgisFieldPickList = null;
      setTimeout(() => {
        this.fieldNode.setFocus();
      }, 1);
    }
  }
  afterFieldSelect(newFieldName) {
    var _a;
    const { props, fieldName, operator, histogramOpen } = this;
    const { strings } = props;
    const oldFilterField = getFieldInfo(fieldName, props);
    const newFilterField = getFieldInfo(newFieldName, props);
    /* this.hasFocus = true;
    this.fieldName = newFieldName;
    this.operator = getOperator(props, oldFilterField!, newFilterField!, operator!);
    this.value = undefined;
    this.value2 = undefined;
    this.values = undefined;
    this.uniqueValuesSortBy = undefined;
    this.histogramOpen =
      (newFilterField!.simpleFieldType &&
        [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE].indexOf(
          newFilterField!.simpleFieldType
        ) === -1) ||
      newFilterField!.statisticsStatus === status.FAILED
        ? undefined
        : histogramOpen === false && oldFilterField!.statisticsStatus !== status.FAILED
        ? false
        : undefined; // when undefined then open by default
    */
    let value = null;
    const newOperator = getOperator$1(props, oldFilterField, newFilterField, operator);
    const filterField = getFieldInfo(newFieldName, props);
    if (filterField.simpleFieldType === simpleFieldTypes.STRING &&
      filterField.uniqueValuesStatus === status.SUCCESS &&
      ((_a = filterField.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length) &&
      [strings.operators.stringOperatorIs, strings.operators.stringOperatorIsNot].indexOf(newOperator) > -1) {
      // default value
      value = filterField.uniqueValueInfos[0].value;
    }
    this.emitChangeEvent({
      hasFocus: true,
      fieldName: newFieldName,
      operator: newOperator,
      value,
      value2: null,
      values: null,
      uniqueValuesSortBy: null,
      histogramOpen: (newFilterField.simpleFieldType &&
        [simpleFieldTypes.NUMBER, simpleFieldTypes.DATE, simpleFieldTypes.DATE_ONLY].indexOf(newFilterField.simpleFieldType) === -1) ||
        newFilterField.statisticsStatus === status.FAILED
        ? null
        : histogramOpen === false && oldFilterField.statisticsStatus !== status.FAILED
          ? false
          : null // when undefined then open by default
    });
  }
  emitChangeEvent(overwrites) {
    var _a, _b;
    const { uid, fieldName, operator, uniqueValuesSortBy, value, value2, values, unit, histogramOpen, hasFocus } = this;
    const newCondition = {
      uid,
      fieldName: overwrites.fieldName || fieldName,
      operator: overwrites.operator || operator,
      uniqueValuesSortBy: overwrites.uniqueValuesSortBy === null
        ? undefined
        : overwrites.uniqueValuesSortBy || uniqueValuesSortBy,
      value: overwrites.value === null ? undefined : (_a = overwrites.value) !== null && _a !== void 0 ? _a : value,
      value2: overwrites.value2 === null ? undefined : (_b = overwrites.value2) !== null && _b !== void 0 ? _b : value2,
      values: overwrites.values === null ? undefined : overwrites.values || values,
      unit: overwrites.unit || unit,
      histogramOpen: overwrites.histogramOpen === null ? undefined : overwrites.histogramOpen || histogramOpen,
      hasFocus: overwrites.hasFocus || hasFocus
    };
    this.arcgisFilterConditionChanged.emit(newCondition);
  }
  waitOnUser(event, doChange) {
    // for number fields we don't want to allow an empty value
    // but the user might shortly use an empty input box
    // while typing a new value
    if (this.typingHndl) {
      clearTimeout(this.typingHndl);
      this.typingHndl = undefined;
    }
    const node = event.target;
    const val = node.value;
    const parsedVal = parseFloat(val);
    if (!val) {
      // undefined or empty string
      // user might be in the middle of typing
      // give the user 2 seconds to fill in empty entry
      // otherwise go back to default value
      this.typingHndl = setTimeout(() => {
        this.typingHndl = undefined;
        doChange(event);
      }, 2000);
    }
    else if (val[0] !== "-" || (parsedVal !== 0 && !isNaN(parsedVal))) {
      // not '-', '-0', '-0.', '-0.0', ...
      doChange(event);
    } // else don't update anything; it's still keeping last value
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilterCondition.style = arcgisFilterConditionCss;

const CSS$1 = {
  addConditionButton: "add-condition-button",
  content: "content",
  conditionHeader: "condition-header",
  matchTypeText: "match-type-text",
  matchCondition: "match-condition",
  matchConditionDropdown: "match-condition-dropdown"
};

const arcgisFilterExpressionCss = ".content.sc-arcgis-filter-expression{padding-bottom:6px}.condition-header.sc-arcgis-filter-expression{display:flex;justify-content:flex-end;align-items:center;margin:0 6px}.match-type-text.sc-arcgis-filter-expression{margin:0 auto}.match-condition.sc-arcgis-filter-expression{margin:0 6px}.match-condition-dropdown.sc-arcgis-filter-expression{width:100%}.add-condition-button.sc-arcgis-filter-expression{display:flex}";

const ArcgisFilterExpression = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisFilterExpressionChanged = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterExpressionChanged", 7);
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    this.onAddCondition = () => {
      const { props, conditions } = this;
      const defaultField = getDefaultField(props);
      const defaultOperator = getDefaultOperator(props, defaultField);
      const defaultValues = getDefaultValues(props, defaultField, defaultOperator);
      const newCondition = Object.assign(Object.assign({ fieldName: defaultField.layerField.name, operator: getDefaultOperator(props, defaultField) }, defaultValues), { hasFocus: true });
      conditions.forEach((cond) => (cond.hasFocus = false));
      this.conditions = [...conditions, newCondition];
      props.expressions = props.expressions.map((expression) => expression.uid === this.uid
        ? Object.assign(Object.assign({}, expression), { conditions: this.conditions }) : Object.assign({}, expression));
      this.fixUIDsForExpression();
      this.menuNode.open = false;
      this.emitChangeEvent();
    };
    this.onRemoveCondition = (event) => {
      const { props, conditions } = this;
      const action = event.target;
      const conditionIdx = parseInt(action.getAttribute("data-value"));
      conditions.forEach((cond) => (cond.hasFocus = false));
      let removedIdx = 0;
      this.conditions = conditions.filter((cond, idx2) => {
        if (cond && idx2 === conditionIdx) {
          removedIdx = idx2;
          return false;
        }
        return true;
      });
      this.conditions[Math.max(0, removedIdx - 1)].hasFocus = true;
      props.expressions = props.expressions.map((expression) => expression.uid === this.uid
        ? Object.assign(Object.assign({}, expression), { conditions: this.conditions }) : Object.assign({}, expression));
      this.fixUIDsForExpression();
      this.emitChangeEvent();
    };
    this.onMatchSelect = (event) => {
      const select = event.target;
      const newMatch = select.selectedOption.value;
      this.logicalOperatorForConditions = newMatch;
      this.emitChangeEvent();
    };
    this.onCopyExpression = () => {
      const { uid, conditions, logicalOperatorForConditions } = this;
      const currentExpression = {
        uid,
        conditions,
        logicalOperatorForConditions
      };
      this.menuNode.open = false;
      this.arcgisFilterExpressionChanged.emit({
        type: "copy",
        uid: this.uid,
        expression: currentExpression
      });
    };
    this.onRemoveExpression = () => {
      this.arcgisFilterExpressionChanged.emit({ type: "delete", uid: this.uid });
    };
    this.props = undefined;
    this.uid = undefined;
    this.conditions = undefined;
    this.logicalOperatorForConditions = undefined;
    this.canRemove = true;
    this.canDuplicate = true;
    this.showAddConditionButton = false;
  }
  arcgisFilterConditionChangeHandler(event) {
    const { conditions } = this;
    const { detail: newCondition } = event;
    this.conditions = conditions.map((condition) => condition.uid === newCondition.uid ? newCondition : condition //{ ...condition }
    );
    this.emitChangeEvent();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    this.conditions = this.conditions || [];
    const [esriLang] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/core/lang"]);
    this.esriLang = esriLang;
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { props, conditions } = this;
    const { strings } = props;
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: {
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: dir === "rtl"
      }, dir: dir }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: conditions.length === 1 ? strings.expression : strings.expressionSet, open: true }, this.renderMenu(), this.renderMatchCondition(), this.renderConditions(), this.renderAddConditionButton())));
  }
  renderMenu() {
    const { props, canDuplicate, canRemove, conditions } = this;
    const { strings } = props;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action-menu", { slot: "control", placement: "bottom-end", overlayPositioning: "fixed", label: strings.accessibility.moreOptions, ref: (node) => (this.menuNode = node) }, canRemove && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: conditions.length === 1 ? strings.deleteExpression : strings.deleteSet, textEnabled: true, "data-value": "remove", onClick: this.onRemoveExpression })), canDuplicate && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.duplicate, textEnabled: true, "data-value": "copy", onClick: this.onCopyExpression })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.addCondition, textEnabled: true, "data-value": "add", onClick: this.onAddCondition })));
  }
  renderMatchCondition() {
    const { conditions, logicalOperatorForConditions, props } = this;
    const { strings } = props;
    if (!conditions || !conditions.length || conditions.length === 1) {
      return null;
    }
    const isAnd = logicalOperatorForConditions !== logicalOperators.OR;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.matchCondition }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", scale: "m", label: strings.accessibility.matchConditions, class: CSS$1.matchConditionDropdown, onCalciteSelectChange: this.onMatchSelect }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.AND, label: strings.matchAllConditions, selected: isAnd }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: logicalOperators.OR, label: strings.matchAtLeastOneCondition, selected: !isAnd }))));
  }
  renderConditions() {
    const { conditions } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.content }, conditions.map((conditionProps, idx) => this.renderCondition(conditionProps, idx))));
  }
  renderCondition(conditionProps, conditionIndex) {
    const { props } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, this.renderConditionHeader(conditionIndex), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-filter-condition", Object.assign({ props: props }, conditionProps))));
  }
  renderAddConditionButton() {
    return (this.showAddConditionButton && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { alignment: "center", appearance: "transparent", class: CSS$1.addConditionButton, "icon-start": "plus", scale: "s", onClick: this.onAddCondition }, this.props.strings.addCondition)));
  }
  renderConditionHeader(conditionIndex) {
    const { props, logicalOperatorForConditions, conditions } = this;
    const { strings } = props;
    if (conditions.length < 2) {
      return null;
    }
    const isAnd = logicalOperatorForConditions !== logicalOperators.OR;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.conditionHeader }, conditionIndex > 0 ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: CSS$1.matchTypeText }, isAnd ? strings.and : strings.or)) : null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { label: strings.remove, text: "", icon: "x", compact: true, "data-value": `${conditionIndex}`, onClick: this.onRemoveCondition })));
  }
  fixUIDsForExpression() {
    const { props } = this;
    props.expressions = fixUIDs(props.expressions);
    this.conditions = props.expressions.filter((expression) => expression.uid === this.uid)[0].conditions;
  }
  emitChangeEvent() {
    const { uid, conditions, logicalOperatorForConditions } = this;
    const newExpression = {
      uid,
      conditions,
      logicalOperatorForConditions
    };
    this.arcgisFilterExpressionChanged.emit({ type: "replace", expression: newExpression });
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilterExpression.style = arcgisFilterExpressionCss;

const CSS = {
  container: "container",
  pickList: "popover-unique-pick-list",
  uniqueValuesContentListMsg: "unique-values-content-list-msg",
  count: "count",
  uniqueValuesDone: "unique-values-done"
};

const arcgisFilterUniqueListCss = ".sc-arcgis-filter-unique-list-h{width:100%}.container.sc-arcgis-filter-unique-list{min-height:30px}.popover-unique-pick-list.sc-arcgis-filter-unique-list{width:100%;overflow-y:auto}.unique-values-content-list-msg.sc-arcgis-filter-unique-list{font-size:75%;margin:5px}.count.sc-arcgis-filter-unique-list{padding:12px 6px}.unique-values-done.sc-arcgis-filter-unique-list{padding:0.5rem}";

const ArcgisFilterUniqueList = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisFilterUniqueListDone = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueListDone", 7);
    this.arcgisFilterUniqueListChanged = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueListChanged", 7);
    this.arcgisFilterUniqueListSortByChanged = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisFilterUniqueListSortByChanged", 7);
    this.onSortMenuSelect = (event) => {
      var _a;
      const dropdown = event.currentTarget;
      const type = (_a = dropdown.selectedItems) === null || _a === void 0 ? void 0 : _a[0].getAttribute("data-value");
      this.sortBy = type;
      this.arcgisFilterUniqueListSortByChanged.emit({ uid: this.uid, sortBy: type });
    };
    this.done = () => {
      this.arcgisFilterUniqueListDone.emit(this.uid);
    };
    this.uid = undefined;
    this.props = undefined;
    this.uniqueValues = undefined;
    this.selectedValues = undefined;
    this.fieldDomains = undefined;
    this.layerFieldType = undefined;
    this.isDate = undefined;
    this.sortBy = undefined;
    this.multiple = undefined;
    this.partialUniqueValues = undefined;
    this.maxHeight = undefined;
    this.strings = undefined;
    this.locale = undefined;
  }
  // --------------------------------------------------------------------------
  //
  //  Public Methods
  //
  // --------------------------------------------------------------------------
  async setFocus() {
    var _a;
    (_a = this.pickListNode) === null || _a === void 0 ? void 0 : _a.setFocus();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    const [intl] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)(["esri/intl"]);
    this.intl = intl;
    this.intl.setLocale(this.locale);
  }
  componentDidLoad() {
    //this.setFocus();
  }
  disconnectedCallback() {
    //this.removeFieldsPickList();
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { uid, uniqueValues, selectedValues, layerFieldType, fieldDomains, sortBy, multiple, partialUniqueValues, maxHeight, strings } = this;
    const sortByCount = (list) => {
      list.sort((a, b) => {
        return a.count <= b.count ? 1 : -1;
      });
    };
    const sortAlphabetically = (list) => {
      const hasDomains = fieldDomains === null || fieldDomains === void 0 ? void 0 : fieldDomains.length;
      list.sort((a, b) => {
        const valueA = hasDomains ? this.getDecodedValue(a.value) : a.value;
        const valueB = hasDomains ? this.getDecodedValue(b.value) : b.value;
        return `${valueA}`.charAt(0) === "_"
          ? 1
          : `${valueB}`.charAt(0) === "_"
            ? -1
            : `${valueA}`.localeCompare(`${valueB}`);
      });
    };
    const sortSelected = (list, values) => {
      list.sort((a, b) => {
        var _a, _b;
        const posA = (_a = values === null || values === void 0 ? void 0 : values.indexOf(a.value)) !== null && _a !== void 0 ? _a : -1;
        const posB = (_b = values === null || values === void 0 ? void 0 : values.indexOf(b.value)) !== null && _b !== void 0 ? _b : -1;
        return posA === posB || (posA > -1 && posB > -1) ? 0 : posA > posB ? -1 : 1;
      });
    };
    sortAlphabetically(uniqueValues);
    if (!sortBy || sortBy === "count") {
      sortByCount(uniqueValues);
    }
    else if (sortBy === "selected") {
      sortSelected(uniqueValues, selectedValues);
    }
    const list = uniqueValues.map((info) => this.renderUniqueValue(info));
    let msgNode;
    if (partialUniqueValues) {
      msgNode = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.uniqueValuesContentListMsg }, strings.errors.tooManyUniqueValues));
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.container }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list", { class: CSS.pickList, filterEnabled: uniqueValues.length > 10, multiple: multiple, "filter-placeholder": strings.searchValues, onCalciteListChange: async (event) => {
        const node = event.target;
        let selectedValues = [...(await node.getSelectedItems()).keys()];
        if (layerFieldType === "date-only") {
          selectedValues = selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.map((value) => {
            // convert date string to UNIX timestamp (without timestamp offset shift)
            const date = new Date(value);
            const offset = date.getTimezoneOffset() * 60000;
            return date.getTime() + offset;
          });
        }
        else if (["date", "oid", "guid", "small-integer", "big-integer", "integer", "long"].indexOf(layerFieldType) > -1) {
          selectedValues = selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.map((value) => parseInt(value));
        }
        else if (["single", "double"].indexOf(layerFieldType) > -1) {
          selectedValues = selectedValues === null || selectedValues === void 0 ? void 0 : selectedValues.map((value) => parseFloat(value));
        }
        this.selectedValues = selectedValues;
        this.arcgisFilterUniqueListChanged.emit({
          uid,
          multiple,
          selectedValues,
          sortBy
        });
      }, ref: (node) => {
        this.pickListNode = node;
        if (maxHeight) {
          node.setAttribute("style", `max-height: ${maxHeight || 400}px`);
        }
      } }, uniqueValues.length > 10 ? this.renderSort() : null, list), msgNode, this.renderDone())));
  }
  renderSort() {
    const { sortBy, strings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown", { slot: "menu-actions", placement: "bottom-end", overlayPositioning: "fixed", width: "s", onCalciteDropdownSelect: this.onSortMenuSelect }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { slot: "trigger", label: strings.sortValues, text: "" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "sortDescending" })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-group", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: sortBy === "count" || !isDefined(sortBy), "data-value": "count" }, strings.sortByCount), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: sortBy === "name", "data-value": "name" }, strings.sortAlphabetical), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: sortBy === "selected", "data-value": "selected" }, strings.sortSelected))));
  }
  renderUniqueValue(info) {
    const { selectedValues, fieldDomains, layerFieldType, isDate, intl, props } = this;
    const { view } = props;
    const { timeZone } = view;
    const value = (fieldDomains === null || fieldDomains === void 0 ? void 0 : fieldDomains.length)
      ? this.getDecodedValue(info.value)
      : isDate
        ? layerFieldType === "date-only"
          ? this.getDateOnlyString(info.value)
          : getDateDisplayString(info.value, timeZone, intl)
        : typeof info.value === "number"
          ? intl.formatNumber(info.value)
          : info.value;
    const isSelected = selectedValues ? selectedValues.indexOf(info.value) > -1 : false;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list-item", { key: `pick-list-item_${info.value}`, label: `${value}`, value: `${info.value}`, selected: isSelected }, isDefined(info.count) ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.count, slot: "actions-end" }, `${info.count}`)) : null));
  }
  renderDone() {
    const { multiple, strings } = this;
    if (!multiple) {
      return null;
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.uniqueValuesDone }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", width: "full", onClick: this.done, label: strings.done }, strings.done)));
  }
  getDecodedValue(value) {
    const { fieldDomains } = this;
    const codedValues = fieldDomains;
    if (codedValues) {
      let label = "";
      for (let i = 0; i < codedValues.length; i++) {
        const codedValue = codedValues[i];
        if (codedValue.code == value) {
          label += (label.length ? " | " : "") + codedValue.name;
        }
      }
      return label;
    }
    // did not find it
    return value;
  }
  getDateOnlyString(value) {
    const { intl } = this;
    return value ? intl.formatDateOnly(value) : "";
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisFilterUniqueList.style = arcgisFilterUniqueListCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWQ4ZmU3Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM4STtBQUN4RTtBQUNUO0FBQ3FCO0FBQ1k7QUFDdEM7QUFDckI7QUFDUjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQSwyQ0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0EsK0NBQStDLDJEQUFXO0FBQzFEO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZSxpQkFBaUIsY0FBYztBQUN0RSw2RUFBNkUsZUFBZTtBQUM1RixtREFBbUQsU0FBUyxzQ0FBc0M7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsR0FBRyxjQUFjO0FBQzNDLHNFQUFzRSxlQUFlO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBLFlBQVksMERBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlC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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVpTTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdJak07QUFDQTtBQUNBO0FBQ0E7QUFDMkU7QUFDYjtBQUNOOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbURBQWlDO0FBQ2hFO0FBQ0E7QUFDQSxNQUFNLHdEQUFXO0FBQ2pCLFdBQVcsd0RBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBVztBQUNuQixhQUFhLHdEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFpQztBQUNoRTtBQUNBO0FBQ0EsTUFBTSx3REFBVztBQUNqQixXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHdEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFZLDhCQUE4QixjQUFjLFFBQVEsT0FBTztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWMsRUFBRSxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlLEdBQUcsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUU0RSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1maWx0ZXJfNC5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9mdW5jdGlvbmFsLWM4MmY1YWI5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0xM2UwMGE3NS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBGIGFzIEZyYWdtZW50LCBkIGFzIGdldEVsZW1lbnQsIGYgYXMgZm9yY2VVcGRhdGUgfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyB9IGZyb20gJy4vbG9jYWxlLTEzZTAwYTc1LmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RWxlbWVudERpciwgQyBhcyBDU1NfVVRJTElUWSB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLTIyMjU4YzkwLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0RmVhdHVyZUNvdW50LCBxIGFzIHF1ZXJ5UGFyZW50RWxlbWVudCB9IGZyb20gJy4vY29tbW9uRnVuY3Rpb25zLTUyNjJiMDk0LmpzJztcbmltcG9ydCB7IHQgYXMgdGltZW91dCB9IGZyb20gJy4vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZjk4YTMyM2MuanMnO1xuaW1wb3J0ICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5cbmNvbnN0IENTUyQzID0ge1xuICBwYW5lbDogXCJwYW5lbFwiLFxuICBob29rOiBcImhvb2tcIixcbiAgcmVtb3ZlRmlsdGVyOiBcInJlbW92ZS1maWx0ZXJcIixcbiAgbWF0Y2hFeHByZXNzaW9uTXNnOiBcIm1hdGNoLWV4cHJlc3Npb24tbXNnXCIsXG4gIG1hdGNoRXhwcmVzc2lvbkRyb3Bkb3duOiBcIm1hdGNoLWV4cHJlc3Npb24tZHJvcGRvd25cIixcbiAgbG9naWNhbE9wZXJhdG9yOiBcIm1hdGNoLXR5cGVcIlxufTtcblxudmFyIGxvZ2ljYWxPcGVyYXRvcnM7XG4oZnVuY3Rpb24gKGxvZ2ljYWxPcGVyYXRvcnMpIHtcbiAgbG9naWNhbE9wZXJhdG9yc1tcIkFORFwiXSA9IFwiYW5kXCI7XG4gIGxvZ2ljYWxPcGVyYXRvcnNbXCJPUlwiXSA9IFwib3JcIjtcbn0pKGxvZ2ljYWxPcGVyYXRvcnMgfHwgKGxvZ2ljYWxPcGVyYXRvcnMgPSB7fSkpO1xudmFyIHNpbXBsZUZpZWxkVHlwZXM7XG4oZnVuY3Rpb24gKHNpbXBsZUZpZWxkVHlwZXMpIHtcbiAgc2ltcGxlRmllbGRUeXBlc1tcIk5VTUJFUlwiXSA9IFwibnVtYmVyXCI7XG4gIHNpbXBsZUZpZWxkVHlwZXNbXCJTVFJJTkdcIl0gPSBcInN0cmluZ1wiO1xuICBzaW1wbGVGaWVsZFR5cGVzW1wiREFURVwiXSA9IFwiZGF0ZVwiO1xuICBzaW1wbGVGaWVsZFR5cGVzW1wiREFURV9PTkxZXCJdID0gXCJkYXRlLW9ubHlcIjtcbiAgc2ltcGxlRmllbGRUeXBlc1tcIk9JRFwiXSA9IFwib2lkXCI7XG4gIHNpbXBsZUZpZWxkVHlwZXNbXCJHVUlEXCJdID0gXCJndWlkXCI7XG4gIHNpbXBsZUZpZWxkVHlwZXNbXCJET01BSU5cIl0gPSBcImRvbWFpblwiO1xufSkoc2ltcGxlRmllbGRUeXBlcyB8fCAoc2ltcGxlRmllbGRUeXBlcyA9IHt9KSk7XG52YXIgc3RhdHVzO1xuKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgc3RhdHVzW1wiTUlTU0lOR1wiXSA9IFwibWlzc2luZ1wiO1xuICBzdGF0dXNbXCJJTl9QUk9HUkVTU1wiXSA9IFwiaW5Qcm9ncmVzc1wiO1xuICBzdGF0dXNbXCJTVUNDRVNTXCJdID0gXCJzdWNjZXNzXCI7XG4gIHN0YXR1c1tcIkZBSUxFRFwiXSA9IFwiZmFpbGVkXCI7XG59KShzdGF0dXMgfHwgKHN0YXR1cyA9IHt9KSk7XG52YXIgdGltZVVuaXRzO1xuKGZ1bmN0aW9uICh0aW1lVW5pdHMpIHtcbiAgdGltZVVuaXRzW1wiTUlOVVRFXCJdID0gXCJtaW51dGVcIjtcbiAgdGltZVVuaXRzW1wiSE9VUlwiXSA9IFwiaG91clwiO1xuICB0aW1lVW5pdHNbXCJEQVlcIl0gPSBcImRheVwiO1xuICB0aW1lVW5pdHNbXCJXRUVLXCJdID0gXCJ3ZWVrXCI7XG4gIHRpbWVVbml0c1tcIk1PTlRIXCJdID0gXCJtb250aFwiO1xuICB0aW1lVW5pdHNbXCJZRUFSXCJdID0gXCJ5ZWFyXCI7XG59KSh0aW1lVW5pdHMgfHwgKHRpbWVVbml0cyA9IHt9KSk7XG52YXIgdGltZVJhbmdlO1xuKGZ1bmN0aW9uICh0aW1lUmFuZ2UpIHtcbiAgdGltZVJhbmdlW3RpbWVSYW5nZVtcIk1JTlVURVwiXSA9IDYwMDAwXSA9IFwiTUlOVVRFXCI7XG4gIHRpbWVSYW5nZVt0aW1lUmFuZ2VbXCJIT1VSXCJdID0gMzYwMDAwMF0gPSBcIkhPVVJcIjtcbiAgdGltZVJhbmdlW3RpbWVSYW5nZVtcIkRBWVwiXSA9IDg2NDAwMDAwXSA9IFwiREFZXCI7XG4gIHRpbWVSYW5nZVt0aW1lUmFuZ2VbXCJXRUVLXCJdID0gNjA0ODAwMDAwXSA9IFwiV0VFS1wiO1xuICB0aW1lUmFuZ2VbdGltZVJhbmdlW1wiTU9OVEhcIl0gPSAyNTkyMDAwMDAwXSA9IFwiTU9OVEhcIjtcbiAgdGltZVJhbmdlW3RpbWVSYW5nZVtcIllFQVJcIl0gPSAzMTEwNDAwMDAwMF0gPSBcIllFQVJcIjtcbn0pKHRpbWVSYW5nZSB8fCAodGltZVJhbmdlID0ge30pKTtcbnZhciBzY2FsZXM7XG4oZnVuY3Rpb24gKHNjYWxlcykge1xuICBzY2FsZXNbXCJTTUFMTFwiXSA9IFwic1wiO1xuICBzY2FsZXNbXCJNRURJVU1cIl0gPSBcIm1cIjtcbiAgc2NhbGVzW1wiTEFSR0VcIl0gPSBcImxcIjtcbn0pKHNjYWxlcyB8fCAoc2NhbGVzID0ge30pKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBkZWZpbmVkXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBjaGVja1xuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0VmZmVjdEVtcHR5KGZlYXR1cmVFZmZlY3QpIHtcbiAgaWYgKCFmZWF0dXJlRWZmZWN0IHx8ICFmZWF0dXJlRWZmZWN0LmZpbHRlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoZWNrUHJvcHMgPSBbXCJnZW9tZXRyeVwiLCBcIm9iamVjdElkc1wiLCBcInRpbWVFeHRlbnRcIiwgXCJ3aGVyZVwiXTtcbiAgcmV0dXJuICFjaGVja1Byb3BzLnNvbWUoKHByb3ApID0+IGZlYXR1cmVFZmZlY3QuZmlsdGVyLmhhc093blByb3BlcnR5KHByb3ApICYmICEhZmVhdHVyZUVmZmVjdC5maWx0ZXJbcHJvcF0pO1xufVxuZnVuY3Rpb24gY2hlY2tDb25maWcocHJvcHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciB9ID0gcHJvcHM7XG4gIGNvbnN0IHVybCA9IGxheWVyLnVybDtcbiAgcHJvcHMuc3VwcG9ydHNTdGFuZGFyZGl6ZWRRdWVyeSA9XG4gICAgXCJ2ZXJzaW9uXCIgaW4gbGF5ZXIgJiYgbGF5ZXIudmVyc2lvbiA+PSAxMC4yICYmICEhKChfYiA9IChfYSA9IGxheWVyLmNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3VwcG9ydHNTdGFuZGFyZGl6ZWRRdWVyaWVzT25seSk7XG4gIHByb3BzLnN1cHBvcnRlZFNxbFBhcnNlclZlcnNpb24gPVxuICAgIGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmXG4gICAgICBwcm9wcy5zdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5ICYmXG4gICAgICBsYXllci5zb3VyY2VKU09OLnNxbFBhcnNlclZlcnNpb24gJiZcbiAgICAgIGxheWVyLnNvdXJjZUpTT04uc3FsUGFyc2VyVmVyc2lvbiAhPT0gXCJFU18xMC42LjFcIjtcbiAgaWYgKCF1cmwgfHwgbWFwSW1hZ2VTdWJsYXllcikge1xuICAgIHByb3BzLmlzSG9zdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGhvc3RlZCBmZWF0dXJlIHNlcnZpY2U6IGh0dHA6Ly9zZXJ2aWNlcy5hcmNnaXMuY29tL2Y3ZWU0MDI4MmNiYzQwOTk4NTcyODM0NTkxMDIxOTc2L2FyY2dpcy9yZXN0L3NlcnZpY2VzL1N0YXRlQ2FwaXRhbHMvRmVhdHVyZVNlcnZlclxuICAvLyBuZXcgYW1hem9uIGhvc3RlZCBmZWF0dXJlIHNlcnZpY2U6IGh0dHA6Ly9mZWF0dXJlcy5hcmNnaXMuY29tL2UyZWEzYzMxZGQ4MDQ3ODY4OWNlNzBjNGZiMzM4MGM1L2FyY2dpcy9yZXN0L3NlcnZpY2VzL3NhbnRhY2xhcmFfZnMvRmVhdHVyZVNlcnZlclxuICAvLyBob3N0ZWQgdGlsZWQgc2VydmljZTogaHR0cHM6Ly90aWxlc2RldmV4dC5hcmNnaXMuY29tL3RpbGVzL2ZhMDE5ZmJiZmJiODQ1ZDA4Y2M5ZjBhY2RlNmRkOGFmL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1N0YXRlcy9NYXBTZXJ2ZXJcbiAgLy8gdXBsb2FkZWQgS01MIHNlcnZpY2U6IGh0dHA6Ly93d3cuYXJjZ2lzLmNvbS9zaGFyaW5nL2NvbnRlbnQvaXRlbXMvZWNkZGRkYWY2YjE3NGQ3Y2E5NDgxNmFjMzk3ZDliNDgvZGF0YVxuICAvLyBzZWN1cmUgc2VydmljZTogaHR0cDovL3d3dy5hcmNnaXMuY29tL3NoYXJpbmcvcmVzdC9zZXJ2aWNlcy9hZWUyYTNkOWQxNWY0MDZjYjIxNTc2ZDkyZWExMzE2ZS9NYXBTZXJ2ZXJcbiAgY29uc3QgYXJjZ2lzID0gXCIuYXJjZ2lzLmNvbS9cIiwgc2VydmljZXMgPSBcIi8vc2VydmljZXNcIiwgdGlsZXMgPSBcIi8vdGlsZXNcIiwgZmVhdHVyZXMgPSBcIi8vZmVhdHVyZXNcIiwgbG9jYXRpb25zZXJ2aWNlcyA9IFwiLy9sb2NhdGlvbnNlcnZpY2VzXCIsIHZlbG9jaXR5VXMgPSBcIi8vdXMtaW90XCIsIHZlbG9jaXR5RXUgPSBcIi8vZXUtaW90XCI7XG4gIC8vc2hhcmluZyA9IChuZXcgZG9qby5fVXJsKGVzcmlHZW93Q29uZmlnLnJlc3RCYXNlVXJsKSkuYXV0aG9yaXR5LFxuICAvL2lzU2luZ2xlVGVuYW50ID0gZmFsc2U7IC8vKGZhbHNlID09PSBlc3JpR2Vvd0NvbmZpZy5pc011bHRpVGVuYW50KTtcbiAgLy8gQ1IgIzIzOCw3MzIgLSBvbmx5IGNvbnNpZGVyIGxvY2FsbHkgaG9zdGVkIGlmIHRoZSByZXN0QmFzZVVybCBpcyBvbiBzYW1lIGRvbWFpbiBhcyB1cmxcbiAgLy8gYW5kIGVzcmlHZW93Q29uZmlnLnNlbGYuc3VwcG9ydHNIb3N0ZWRTZXJ2aWNlcyBmbGFnIGlzIGVuYWJsZWRcbiAgY29uc3QgaXNBR09MID0gdXJsLmluZGV4T2YoYXJjZ2lzKSAhPT0gLTEsIGlzSG9zdGVkU2VydmVyID0gdXJsLmluZGV4T2Yoc2VydmljZXMpICE9PSAtMSB8fFxuICAgIHVybC5pbmRleE9mKHRpbGVzKSAhPT0gLTEgfHxcbiAgICB1cmwuaW5kZXhPZihmZWF0dXJlcykgIT09IC0xIHx8XG4gICAgdXJsLmluZGV4T2YobG9jYXRpb25zZXJ2aWNlcykgIT09IC0xIHx8XG4gICAgdXJsLmluZGV4T2YodmVsb2NpdHlVcykgIT09IC0xIHx8XG4gICAgdXJsLmluZGV4T2YodmVsb2NpdHlFdSkgIT09IC0xLCBpc0xvY2FsbHlIb3N0ZWQgPSBmYWxzZTsgLy8oKGlzRGVmaW5lZChlc3JpR2Vvd0NvbmZpZy5zZWxmKSAmJiBlc3JpR2Vvd0NvbmZpZy5zZWxmLnN1cHBvcnRzSG9zdGVkU2VydmljZXMpICYmICh1cmwuaW5kZXhPZihzaGFyaW5nKSAhPT0gLTEgJiYgIWlzU2luZ2xlVGVuYW50KSk7XG4gIC8vaXNQcm94eVNlcnZpY2UgPSAhaXNIb3N0ZWRTZXJ2ZXIgJiYgYXJjZ2lzOyAvLyBpZiB0aGUgc2VydmljZSByZXF1aXJlcyBub24tQUdPTCBjcmVkZW50aWFsc1xuICBwcm9wcy5pc0hvc3RlZCA9IChpc0FHT0wgJiYgaXNIb3N0ZWRTZXJ2ZXIpIHx8ICghaXNBR09MICYmIGlzTG9jYWxseUhvc3RlZCk7XG59XG5mdW5jdGlvbiBmaXhVSURzKGV4cHJlc3Npb25zKSB7XG4gIGlmICghZXhwcmVzc2lvbnMgfHwgIWV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBleHByZXNzaW9ucztcbiAgfVxuICByZXR1cm4gZXhwcmVzc2lvbnMubWFwKChleHByZXNzaW9uLCBpZHgpID0+IHtcbiAgICBpZiAoZXhwcmVzc2lvbi51aWQgPT09IGBleHByZXNzaW9uLSR7aWR4fWApIHtcbiAgICAgIC8vIG5vIGNoYW5nZSB0byB1aWRcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4cHJlc3Npb24pLCB7IGNvbmRpdGlvbnM6IGV4cHJlc3Npb24uY29uZGl0aW9ucy5tYXAoKGNvbmRpdGlvbiwgaWR4MikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1VpZCA9IGBjb25kaXRpb24tJHtpZHh9LSR7aWR4Mn1gO1xuICAgICAgICAgIGlmIChjb25kaXRpb24udWlkID09PSBuZXdVaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZGl0aW9uKSwgeyB1aWQ6IG5ld1VpZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4cHJlc3Npb24pLCB7IHVpZDogYGV4cHJlc3Npb24tJHtpZHh9YCwgZXhwcmVzc2lvbkluZGV4OiBpZHgsIGNvbmRpdGlvbnM6IGV4cHJlc3Npb24uY29uZGl0aW9ucy5tYXAoKGNvbmRpdGlvbiwgaWR4MikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1VpZCA9IGBjb25kaXRpb24tJHtpZHh9LSR7aWR4Mn1gO1xuICAgICAgICAgIGlmIChjb25kaXRpb24udWlkID09PSBuZXdVaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZGl0aW9uKSwgeyB1aWQ6IG5ld1VpZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHV0Y1RvRGF0ZVBpY2tlcih2YWx1ZSwgdGltZVpvbmUpIHtcbiAgLy8gZGF0ZSBpcyBpbiBVVENcbiAgLy8gd2UgbmVlZCBhIG1hcCB0aW1lem9uZVxuICBsZXQgc3RyO1xuICBpZiAoIXRpbWVab25lIHx8IHRpbWVab25lID09PSBcInN5c3RlbVwiKSB7XG4gICAgY29uc3QgZGlmZiA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICBzdHIgPSBuZXcgRGF0ZSh2YWx1ZSAtIGRpZmYgKiA2MDAwMCkudG9JU09TdHJpbmcoKTtcbiAgfVxuICBlbHNlIGlmICh0aW1lWm9uZSA9PT0gXCJ1bmtub3duXCIpIHtcbiAgICBzdHIgPSBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCBkaWZmID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIGNvbnN0IG1hcERhdGVTdHIgPSBuZXcgRGF0ZSh2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lIH0pO1xuICAgIHN0ciA9IG5ldyBEYXRlKG5ldyBEYXRlKG1hcERhdGVTdHIpLmdldFRpbWUoKSAtIGRpZmYgKiA2MDAwMCkudG9JU09TdHJpbmcoKTtcbiAgfVxuICAvL2NvbnNvbGUubG9nKFwidXRjVG9EYXRlUGlja2VyXCIsIHZhbHVlLCBcIiAtIFwiLCBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKSwgXCIgLT4gXCIsIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBkYXRlUGlja2VyVG9VVEMoZGF0ZSwgdGltZVpvbmUpIHtcbiAgLy8gZGF0ZSBpcyBpbiBtYXAgdGltZXpvbmVcbiAgLy8gd2UgbmVlZCBhIFVUQyBVTklYIHRpbWVzdGFtcFxuICBsZXQgdmFsdWU7XG4gIGlmICghdGltZVpvbmUgfHwgdGltZVpvbmUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAvLyBhZGQgZGlmZmVyZW5jZSBiZXR3ZWVuIGxvY2FsIHRpbWUgYW5kIFVUQ1xuICAgIHZhbHVlID0gZGF0ZS5nZXRUaW1lKCkgKyBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgfVxuICBlbHNlIGlmICh0aW1lWm9uZSA9PT0gXCJ1bmtub3duXCIpIHtcbiAgICAvLyB0YWtlIHdoYXQgeW91IGdldFxuICAgIHZhbHVlID0gZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gYWRkIGRpZmZlcmVuY2UgYmV0d2VlbiBtYXAgdGltZSBhbmQgVVRDXG4gICAgY29uc3QgZGlmZiA9IG5ldyBEYXRlKGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lOiBcInV0Y1wiIH0pKS5nZXRUaW1lKCkgLVxuICAgICAgbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHsgdGltZVpvbmUgfSkpLmdldFRpbWUoKTtcbiAgICB2YWx1ZSA9IGRhdGUuZ2V0VGltZSgpICsgZGlmZjtcbiAgfVxuICAvL2NvbnNvbGUubG9nKFwiZGF0ZVBpY2tlclRvVVRDXCIsIGRhdGUudG9JU09TdHJpbmcoKSwgXCIgLT4gXCIsIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVFpUb1VUQyh2YWx1ZSwgdGltZVpvbmUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvLyB2YWx1ZSBpcyBpbiBtYXAgdGltZXpvbmVcbiAgLy8gd2UgbmVlZCBhIFVUQyB0aW1lc3RhbXBcbiAgbGV0IG5ld1ZhbHVlO1xuICBpZiAoIXRpbWVab25lIHx8IHRpbWVab25lID09PSBcInN5c3RlbVwiKSB7XG4gICAgLy8gYWRkIGRpZmZlcmVuY2UgYmV0d2VlbiBsb2NhbCB0aW1lIGFuZCBVVENcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICBuZXdWYWx1ZSA9IHZhbHVlICsgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gIH1cbiAgZWxzZSBpZiAodGltZVpvbmUgPT09IFwidW5rbm93blwiKSB7XG4gICAgLy8gdGFrZSB3aGF0IHlvdSBnZXRcbiAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIGFkZCBkaWZmZXJlbmNlIGJldHdlZW4gbWFwIHRpbWUgYW5kIFVUQ1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGRpZmYgPSBuZXcgRGF0ZShkYXRlLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogXCJ1dGNcIiB9KSkuZ2V0VGltZSgpIC1cbiAgICAgIG5ldyBEYXRlKGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lIH0pKS5nZXRUaW1lKCk7XG4gICAgbmV3VmFsdWUgPSB2YWx1ZSArIGRpZmY7XG4gIH1cbiAgLy9jb25zb2xlLmxvZyhcIm1hcFRaVG9VVENcIiwgdmFsdWUsIFwiIC0gXCIsIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpLCBcIiAtIFwiLCBuZXcgRGF0ZShuZXdWYWx1ZSkudG9JU09TdHJpbmcoKSk7XG4gIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdldERhdGVEaXNwbGF5U3RyaW5nKHZhbHVlLCB0aW1lWm9uZSwgaW50bCwgZGF0ZUZvcm1hdCkge1xuICBsZXQgc3RyO1xuICBpZiAodGltZVpvbmUgPT09IFwidW5rbm93blwiKSB7XG4gICAgc3RyID0gaW50bC5mb3JtYXREYXRlKHZhbHVlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKGRhdGVGb3JtYXQgfHwgXCJzaG9ydC1kYXRlLXNob3J0LXRpbWVcIikpLCB7IHRpbWVab25lOiBcInV0Y1wiLCB0aW1lWm9uZU5hbWU6IFwic2hvcnRPZmZzZXRcIiB9KSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8ga25vd24gaXNzdWVzIHdpdGggZm9ybWF0dGluZyBpdC1DSFxuICAgIHN0ciA9IGludGwuZm9ybWF0RGF0ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRsLmNvbnZlcnREYXRlRm9ybWF0VG9JbnRsT3B0aW9ucyhkYXRlRm9ybWF0IHx8IFwic2hvcnQtZGF0ZS1zaG9ydC10aW1lXCIpKSwgeyB0aW1lWm9uZSB9KSk7XG4gIH1cbiAgLy9jb25zb2xlLmxvZyhcImdldERhdGVEaXNwbGF5U3RyaW5nXCIsIHZhbHVlLCBcIiAtIFwiLCBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKSwgXCIgLT4gXCIsIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbi8vaW1wb3J0IERvbWFpbiBmcm9tIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9Eb21haW5cIjtcbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RGaWVsZERvbWFpbnMocHJvcHMpIHtcbiAgLy8gd2UgZG8gbm90IHN1cHBvcnQgc3ViVHlwZXMgLi4uXG4gIGNvbnN0IHsgbGF5ZXIsIGZpZWxkcyB9ID0gcHJvcHM7XG4gIGlmIChsYXllci50eXBlICE9PSBcImZlYXR1cmVcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0eXBlSWRGaWVsZCA9IGxheWVyLnR5cGVJZEZpZWxkO1xuICBjb25zdCB0eXBlcyA9IGxheWVyLnR5cGVzO1xuICBmaWVsZHMuZm9yRWFjaChhc3luYyAoZmVhdHVyZUZpZWxkKSA9PiB7XG4gICAgY29uc3QgZmllbGROYW1lID0gZmVhdHVyZUZpZWxkLmxheWVyRmllbGQubmFtZTtcbiAgICBjb25zdCBmaWVsZERvbWFpbiA9IGZlYXR1cmVGaWVsZC5sYXllckZpZWxkLmRvbWFpbjtcbiAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICBpZiAoIWZpbHRlckZpZWxkKSB7XG4gICAgICAvLyBtYXliZSBnZW9tZXRyeSBmaWVsZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZUlkRmllbGQgJiYgdHlwZXMpIHtcbiAgICAgIC8vIGxheWVyIGhhcyB0eXBlc1xuICAgICAgaWYgKHR5cGVJZEZpZWxkID09PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmllbGQgd2l0aCB0aGUgdHlwZXNcbiAgICAgICAgZmlsdGVyRmllbGQuZmllbGREb21haW5zID0gdHlwZXMubWFwKCh0eXBlKSA9PiB7XG4gICAgICAgICAgLy8gZmFrZSBjb2RlZCBWYWx1ZXNcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogdHlwZS5pZCxcbiAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBnZXRTaW1wbGVGaWVsZFR5cGUocHJvcHMsIGZpbHRlckZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBmaWVsZCBkb2VzIG5vdCBoYXZlIHR5cGVzOyBsb29rIGZhcnRoZXIgaW5zaWRlIHRoZSB0eXBlc1xuICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMgPSBbXTtcbiAgICAgICAgdHlwZXMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgaWYgKCF0eXBlLmRvbWFpbnMgfHwgIXR5cGUuZG9tYWluc1tmaWVsZE5hbWVdIHx8IHR5cGUuZG9tYWluc1tmaWVsZE5hbWVdLnR5cGUgPT09IFwiaW5oZXJpdGVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbiAvKkRvbWFpbiovID0gZmllbGREb21haW47XG4gICAgICAgICAgICBpZiAoZG9tYWluID09PSBudWxsIHx8IGRvbWFpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9tYWluLmNvZGVkVmFsdWVzKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5jb2RlZFZhbHVlcy5mb3JFYWNoKGFzeW5jIChjb2RlZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlsdGVyRmllbGQuZmllbGREb21haW5zLmZvckVhY2goKGNvZGVkVmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZWRWYWwuY29kZSA9PT0gY29kZWRWYWx1ZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGAsICR7Y29kZWRWYWwubmFtZX0sYC5pbmRleE9mKGAsICR7Y29kZWRWYWx1ZS5uYW1lfSxgKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2RlZFZhbC5uYW1lICs9IGAsICR7Y29kZWRWYWx1ZS5uYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBbZXNyaUxhbmddID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb3JlL2xhbmdcIl0pO1xuICAgICAgICAgICAgICAgICAgZmlsdGVyRmllbGQuZmllbGREb21haW5zLnB1c2goZXNyaUxhbmcuY2xvbmUoY29kZWRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChfYiA9IChfYSA9IHR5cGUuZG9tYWlucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2ZpZWxkTmFtZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlZFZhbHVlcykge1xuICAgICAgICAgICAgdHlwZS5kb21haW5zW2ZpZWxkTmFtZV0uY29kZWRWYWx1ZXMuZm9yRWFjaChhc3luYyAoY29kZWRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZmlsdGVyRmllbGQuZmllbGREb21haW5zLmZvckVhY2goKGNvZGVkVmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVkVmFsLmNvZGUgPT09IGNvZGVkVmFsdWUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaWYgKGAsICR7Y29kZWRWYWwubmFtZX0sYC5pbmRleE9mKGAsICR7Y29kZWRWYWx1ZS5uYW1lfSxgKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZWRWYWwubmFtZSArPSBgLCAke2NvZGVkVmFsdWUubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZXNyaUxhbmddID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb3JlL2xhbmdcIl0pO1xuICAgICAgICAgICAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucy5wdXNoKGVzcmlMYW5nLmNsb25lKGNvZGVkVmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL2ZpbHRlckZpZWxkLmZpZWxkRG9tYWlucyA9IGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucy5jb25jYXQodHlwZS5kb21haW5zW2ZpZWxkLm5hbWVdLmNvZGVkVmFsdWVzKTtcbiAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIC4uLiB3cm9uZywgaXQncyBub3QgdGhlIHR5cGVJZEZpZWxkIC4uLlxuICAgICAgICAgICAgICAvLyBmYWtlIGNvZGVkIHZhbHVlc1xuICAgICAgICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogdHlwZS5pZCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gZmllbGQgaGFzIG5vIGRvbWFpbnNcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzRmllbGREb21haW5zKGZpbHRlckZpZWxkKSAmJiAoZmllbGREb21haW4gPT09IG51bGwgfHwgZmllbGREb21haW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkRG9tYWluLmNvZGVkVmFsdWVzKSkge1xuICAgICAgICBjb25zdCBbZXNyaUxhbmddID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb3JlL2xhbmdcIl0pO1xuICAgICAgICBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMgPSBlc3JpTGFuZy5jbG9uZShmaWVsZERvbWFpbi5jb2RlZFZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpZWxkRG9tYWluID09PSBudWxsIHx8IGZpZWxkRG9tYWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZERvbWFpbi5jb2RlZFZhbHVlcykge1xuICAgICAgLy8gZG9tYWlucyBkaXJlY3RseSBvbiB0aGUgbGF5ZXIgZmllbGRcbiAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucyA9IGZpZWxkRG9tYWluLmNvZGVkVmFsdWVzO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgaW4gY2FzZSBpdCBoYXMgY2hhbmdlZFxuICAgIGdldFNpbXBsZUZpZWxkVHlwZShwcm9wcywgZmlsdGVyRmllbGQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldERlY29kZWRWYWx1ZSh2YWx1ZSwgZmlsdGVyRmllbGQpIHtcbiAgY29uc3QgY29kZWRWYWx1ZXMgPSBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnM7XG4gIGlmIChjb2RlZFZhbHVlcykge1xuICAgIGxldCBsYWJlbCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29kZWRWYWx1ZSA9IGNvZGVkVmFsdWVzW2ldO1xuICAgICAgaWYgKGNvZGVkVmFsdWUuY29kZSA9PSB2YWx1ZSkge1xuICAgICAgICBsYWJlbCArPSAobGFiZWwubGVuZ3RoID8gXCIgfCBcIiA6IFwiXCIpICsgY29kZWRWYWx1ZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH1cbiAgLy8gZGlkIG5vdCBmaW5kIGl0XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGg7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkRmlsdGVyRmllbGRzKHByb3BzKSB7XG4gIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIGZlYXR1cmVSZWR1Y3Rpb24gfSA9IHByb3BzO1xuICBpZiAoIWxheWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmZWF0dXJlUmVkdWN0aW9uKSB7XG4gICAgcmV0dXJuIGJ1aWxkRmVhdHVyZVJlZHVjdGlvbkZpZWxkcyhwcm9wcyk7XG4gIH1cbiAgbGV0IGxheWVyRmllbGRzID0gbGF5ZXIuZmllbGRzO1xuICAvLyBodHRwczovL2RlbW9ncmFwaGljczlkZXYuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9VU0FfRGVtb2dyYXBoaWNzX2FuZF9Cb3VuZGFyaWVzXzIwMTkvTWFwU2VydmVyXG4gIGlmIChtYXBJbWFnZVN1YmxheWVyICYmXG4gICAgbWFwSW1hZ2VTdWJsYXllci5sYXllci5wb3J0YWxJdGVtICYmXG4gICAgbWFwSW1hZ2VTdWJsYXllci5sYXllci51cmwuaW5kZXhPZihcImh0dHBzOi8vZGVtb2dyYXBoaWNzXCIpID4gLTEgJiZcbiAgICBtYXBJbWFnZVN1YmxheWVyLmxheWVyLnVybC5pbmRleE9mKFwiLmFyY2dpcy5jb21cIikgPiAtMSkge1xuICAgIGNvbnN0IHBvcnRhbEl0ZW0gPSBtYXBJbWFnZVN1YmxheWVyLmxheWVyLnBvcnRhbEl0ZW07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9ydGFsSXRlbS5mZXRjaERhdGEoKTtcbiAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UudGhlbWF0aWNHcm91cCkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gcmVzcG9uc2UudGhlbWF0aWNHcm91cC5maWVsZE5hbWVzO1xuICAgICAgICBpZiAoZmllbGROYW1lcykge1xuICAgICAgICAgIGxheWVyRmllbGRzID0gbGF5ZXJGaWVsZHMuZmlsdGVyKChsYXllckZpZWxkKSA9PiBmaWVsZE5hbWVzLmluZGV4T2YobGF5ZXJGaWVsZC5uYW1lKSA+IC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkRmVhdHVyZUZpbHRlckZpZWxkc0FmdGVyVGhlbWF0aWNHcm91cENoZWNrKHByb3BzLCBsYXllckZpZWxkcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gYXNzdW1lIHRoZXJlIGlzIG5vbmVcbiAgICAgIHJldHVybiBidWlsZEZlYXR1cmVGaWx0ZXJGaWVsZHNBZnRlclRoZW1hdGljR3JvdXBDaGVjayhwcm9wcywgbGF5ZXJGaWVsZHMpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gYnVpbGRGZWF0dXJlRmlsdGVyRmllbGRzQWZ0ZXJUaGVtYXRpY0dyb3VwQ2hlY2socHJvcHMsIGxheWVyRmllbGRzKTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRGZWF0dXJlRmlsdGVyRmllbGRzQWZ0ZXJUaGVtYXRpY0dyb3VwQ2hlY2socHJvcHMsIGxheWVyRmllbGRzKSB7XG4gIGlmICghcHJvcHMuZmllbGRzIHx8ICFwcm9wcy5maWVsZHMubGVuZ3RoKSB7XG4gICAgcHJvcHMuZmllbGRzID0gW107XG4gICAgcHJvcHMuc3RyaW5nRmllbGRzQ291bnQgPSAwO1xuICAgIHByb3BzLmRhdGVGaWVsZHNDb3VudCA9IDA7XG4gICAgcHJvcHMubnVtYmVyRmllbGRzQ291bnQgPSAwO1xuICAgIGlmICghcHJvcHMuc3VwcG9ydHNTdGFuZGFyZGl6ZWRRdWVyeSkge1xuICAgICAgLy8gTk9URTogY2xpZW50IHNpZGUgZmlsdGVyIGVmZmVjdCBvbmx5IHN1cHBvcnRzIHNxbDkyIGFuZCBuZWVkcyB0aGUgdGltZXN0YW1wIGluIHRoZSBxdWVyeVxuICAgICAgLy8gdGhlcmZvcmUgd2UgZGlzYWJsZSBkYXRhIGZpZWxkcyBmb3Igc2VydmljZXMgd2l0aG91dCBzdGFuZGFyZGl6ZWRRdWVyeSBzdXBwb3J0XG4gICAgICBsYXllckZpZWxkcyA9IGxheWVyRmllbGRzLmZpbHRlcigobGF5ZXJGaWVsZCkgPT4gW1wiZGF0ZVwiLCBcImRhdGUtb25seVwiXS5pbmRleE9mKGxheWVyRmllbGQudHlwZSkgPT09IC0xKTtcbiAgICB9XG4gICAgbGV0IGZpZWxkSW5mb3MgPSBbXTtcbiAgICBpZiAocHJvcHMubGF5ZXIudHlwZSAhPT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgIGNvbnN0IHsgcG9wdXBUZW1wbGF0ZSB9ID0gcHJvcHMubGF5ZXI7XG4gICAgICBmaWVsZEluZm9zID0gcG9wdXBUZW1wbGF0ZSA/IHBvcHVwVGVtcGxhdGUuZmllbGRJbmZvcyA6IFtdO1xuICAgIH1cbiAgICBsYXllckZpZWxkcy5mb3JFYWNoKChsYXllckZpZWxkKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ID0gZmllbGRJbmZvc1xuICAgICAgICA/IGZpZWxkSW5mb3MuZmlsdGVyKChmaWVsZEluZm8pID0+IGZpZWxkSW5mby5maWVsZE5hbWUgPT09IGxheWVyRmllbGQubmFtZSlcbiAgICAgICAgOiBudWxsO1xuICAgICAgY29uc3QgbGFiZWwgPSAobGlzdCA9PT0gbnVsbCB8fCBsaXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0Lmxlbmd0aCkgPyBsaXN0WzBdLmxhYmVsIDogbnVsbDtcbiAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0ge1xuICAgICAgICBsYXllckZpZWxkOiBsYXllckZpZWxkLFxuICAgICAgICBzdGF0aXN0aWNzU3RhdHVzOiBzdGF0dXMuTUlTU0lORyxcbiAgICAgICAgaGlzdG9ncmFtU3RhdHVzOiBzdGF0dXMuTUlTU0lORyxcbiAgICAgICAgdW5pcXVlVmFsdWVzU3RhdHVzOiBzdGF0dXMuTUlTU0lORyxcbiAgICAgICAgcGFydGlhbFVuaXF1ZVZhbHVlczogZmFsc2UsXG4gICAgICAgIGxhYmVsOiBsYWJlbCB8fCBsYXllckZpZWxkLmFsaWFzIHx8IGxheWVyRmllbGQubmFtZVxuICAgICAgfTtcbiAgICAgIGdldFNpbXBsZUZpZWxkVHlwZShwcm9wcywgZmlsdGVyRmllbGQpO1xuICAgICAgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkge1xuICAgICAgICBwcm9wcy5maWVsZHMucHVzaChmaWx0ZXJGaWVsZCk7XG4gICAgICB9IC8vIGVsc2UgY2FuJ3QgdXNlIGZpZWxkIGZvciBmaWx0ZXJcbiAgICB9KTtcbiAgICBjb2xsZWN0RmllbGREb21haW5zKHByb3BzKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRGZWF0dXJlUmVkdWN0aW9uRmllbGRzKHByb3BzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBsYXllciwgdmlldyB9ID0gcHJvcHM7XG4gIGlmIChsYXllci50eXBlID09PSBcImltYWdlcnlcIiB8fCBsYXllci50eXBlID09PSBcInN1YnR5cGUtZ3JvdXBcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgoX2EgPSBwcm9wcy5maWVsZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XG4gICAgcHJvcHMuZmllbGRzID0gW107XG4gICAgcHJvcHMuc3RyaW5nRmllbGRzQ291bnQgPSAwO1xuICAgIHByb3BzLmRhdGVGaWVsZHNDb3VudCA9IDA7XG4gICAgcHJvcHMubnVtYmVyRmllbGRzQ291bnQgPSAxO1xuICAgIGxldCBjb3VudCA9IDUwMDA7XG4gICAgbGV0IGF2ZyA9IDEwO1xuICAgIGxldCBmZWF0dXJlQ291bnQgPSAwO1xuICAgIHRyeSB7XG4gICAgICBmZWF0dXJlQ291bnQgPSBhd2FpdCBnZXRGZWF0dXJlQ291bnQobGF5ZXIsIHZpZXcpO1xuICAgICAgY291bnQgPSBmZWF0dXJlQ291bnQgPyBNYXRoLm1pbihNYXRoLm1heCgxMCwgTWF0aC5jZWlsKGZlYXR1cmVDb3VudCAvIDQpKSwgNTAwMCkgOiA1MDAwO1xuICAgICAgYXZnID0gZmVhdHVyZUNvdW50ICYmIGZlYXR1cmVDb3VudCA+PSAxMDAwID8gMTAwIDogMTA7XG4gICAgfVxuICAgIGNhdGNoIChfYikgeyB9XG4gICAgY29uc3QgW0ZpZWxkXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvbGF5ZXJzL3N1cHBvcnQvRmllbGRcIl0pO1xuICAgIGNvbnN0IGZlYXR1cmVSZWR1Y3Rpb24gPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uO1xuICAgIHByb3BzLmZpZWxkcyA9IFtdO1xuICAgIGZlYXR1cmVSZWR1Y3Rpb24uZmllbGRzLmZvckVhY2goKGFnZ3JlZ2F0ZUZpZWxkKSA9PiB7XG4gICAgICBjb25zdCBpc0NvdW50ID0gYWdncmVnYXRlRmllbGQuc3RhdGlzdGljVHlwZSA9PT0gXCJjb3VudFwiO1xuICAgICAgY29uc3QgbGF5ZXJGaWVsZCA9IGFnZ3JlZ2F0ZUZpZWxkLm9uU3RhdGlzdGljRmllbGQgJiZcbiAgICAgICAgbGF5ZXIuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBhZ2dyZWdhdGVGaWVsZC5vblN0YXRpc3RpY0ZpZWxkKTtcbiAgICAgIGlmICgoIWFnZ3JlZ2F0ZUZpZWxkLm9uU3RhdGlzdGljRmllbGQgJiYgaXNDb3VudCkgfHwgbGF5ZXJGaWVsZCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IHtcbiAgICAgICAgICBsYXllckZpZWxkOiBuZXcgRmllbGQoe1xuICAgICAgICAgICAgbmFtZTogYWdncmVnYXRlRmllbGQubmFtZSxcbiAgICAgICAgICAgIGFsaWFzOiBhZ2dyZWdhdGVGaWVsZC5hbGlhcyB8fCBhZ2dyZWdhdGVGaWVsZC5uYW1lLFxuICAgICAgICAgICAgdHlwZTogKGxheWVyRmllbGQgPT09IG51bGwgfHwgbGF5ZXJGaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJGaWVsZC50eXBlKSB8fCBcImludGVnZXJcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN0YXRpc3RpY3NTdGF0dXM6IGlzQ291bnQgPyBzdGF0dXMuU1VDQ0VTUyA6IHN0YXR1cy5NSVNTSU5HLFxuICAgICAgICAgIHN0YXRpc3RpY3M6IGlzQ291bnQgPyB7IG1pbjogMSwgbWF4OiBjb3VudCwgYXZnIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgaGlzdG9ncmFtU3RhdHVzOiBpc0NvdW50ID8gc3RhdHVzLkZBSUxFRCA6IHN0YXR1cy5NSVNTSU5HLFxuICAgICAgICAgIHVuaXF1ZVZhbHVlc1N0YXR1czogc3RhdHVzLk1JU1NJTkcsXG4gICAgICAgICAgcGFydGlhbFVuaXF1ZVZhbHVlczogZmFsc2UsXG4gICAgICAgICAgbGFiZWw6IGFnZ3JlZ2F0ZUZpZWxkLmFsaWFzIHx8IGFnZ3JlZ2F0ZUZpZWxkLm5hbWVcbiAgICAgICAgICAvL3NpbXBsZUZpZWxkVHlwZTogLi4uXG4gICAgICAgIH07XG4gICAgICAgIGdldFNpbXBsZUZpZWxkVHlwZShwcm9wcywgZmlsdGVyRmllbGQpO1xuICAgICAgICBwcm9wcy5maWVsZHMucHVzaChmaWx0ZXJGaWVsZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKSB7XG4gIGNvbnN0IHsgZmllbGRzIH0gPSBwcm9wcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGZpZWxkc1tpXTtcbiAgICBpZiAoZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lID09PSBmaWVsZE5hbWUpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJGaWVsZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRGaWVsZChwcm9wcykge1xuICBjb25zdCB7IGZpZWxkcywgZGVmYXVsdEZpZWxkTmFtZSB9ID0gcHJvcHM7XG4gIGlmIChkZWZhdWx0RmllbGROYW1lKSB7XG4gICAgY29uc3QgZGVmYXVsdEZpZWxkID0gZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGRlZmF1bHRGaWVsZE5hbWUpO1xuICAgIGlmIChkZWZhdWx0RmllbGQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0RmllbGQ7XG4gICAgfVxuICB9XG4gIGxldCBmaXJzdE51bWJlckZpZWxkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgIGlmIChmaWVsZC5zaW1wbGVGaWVsZFR5cGUgJiZcbiAgICAgIFtzaW1wbGVGaWVsZFR5cGVzLk9JRCwgc2ltcGxlRmllbGRUeXBlcy5HVUlELCBzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLmluZGV4T2YoZmllbGQuc2ltcGxlRmllbGRUeXBlKSA9PT0gLTEpIHtcbiAgICAgIGlmIChmaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSICYmICFmaXJzdE51bWJlckZpZWxkKSB7XG4gICAgICAgIGZpcnN0TnVtYmVyRmllbGQgPSBmaWVsZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBzdHJpbmcgZmllbGRcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyB3ZSBkaWRuJ3QgZmluZCBhIHN0cmluZyBmaWVsZFxuICBpZiAoZmlyc3ROdW1iZXJGaWVsZCkge1xuICAgIHJldHVybiBmaXJzdE51bWJlckZpZWxkO1xuICB9XG4gIHJldHVybiBmaWVsZHNbMF07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWVzKHByb3BzLCBmaWx0ZXJGaWVsZCwgb3BlcmF0b3IpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qgc3RhdGlzdGljcyA9IGZpbHRlckZpZWxkLnN0YXRpc3RpY3M7XG4gIGlmICghc3RhdGlzdGljcykge1xuICAgIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuU1RSSU5HICYmXG4gICAgICBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZXNTdGF0dXMgPT09IHN0YXR1cy5TVUNDRVNTICYmXG4gICAgICAoKF9hID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgJiZcbiAgICAgIFtzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzLCBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzTm90XS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICByZXN1bHQudmFsdWUgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zWzBdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChpc0luVGhlTGFzdE9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCByYW5nZSA9IE1hdGguYWJzKG5vdyAtIHN0YXRpc3RpY3MuYXZnKTtcbiAgICBpZiAocmFuZ2UgPiAyICogdGltZVJhbmdlLllFQVIpIHtcbiAgICAgIHJlc3VsdC52YWx1ZSA9IE1hdGgucm91bmQocmFuZ2UgLyB0aW1lUmFuZ2UuWUVBUik7XG4gICAgICByZXN1bHQudW5pdCA9IHRpbWVVbml0cy5ZRUFSO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChyYW5nZSA+IDIgKiB0aW1lUmFuZ2UuTU9OVEgpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5NT05USCk7XG4gICAgICAgIHJlc3VsdC51bml0ID0gdGltZVVuaXRzLk1PTlRIO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChyYW5nZSA+IDIgKiB0aW1lUmFuZ2UuV0VFSykge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IE1hdGgucm91bmQocmFuZ2UgLyB0aW1lUmFuZ2UuV0VFSyk7XG4gICAgICAgICAgcmVzdWx0LnVuaXQgPSB0aW1lVW5pdHMuV0VFSztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAocmFuZ2UgPiAyICogdGltZVJhbmdlLkRBWSkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5EQVkpO1xuICAgICAgICAgICAgcmVzdWx0LnVuaXQgPSB0aW1lVW5pdHMuREFZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyYW5nZSA+IDIgKiB0aW1lUmFuZ2UuSE9VUikge1xuICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLkhPVVIpO1xuICAgICAgICAgICAgICByZXN1bHQudW5pdCA9IHRpbWVVbml0cy5IT1VSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IE1hdGgucm91bmQocmFuZ2UgLyB0aW1lUmFuZ2UuTUlOVVRFKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnVuaXQgPSB0aW1lVW5pdHMuTUlOVVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0JldHdlZW5PcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgcmVzdWx0LnZhbHVlID0gZmllbGRUeXBlUm91bmQoc3RhdGlzdGljcy5hdmcsIHByb3BzLCBmaWx0ZXJGaWVsZCk7XG4gICAgcmVzdWx0LnZhbHVlMiA9IGZpZWxkVHlwZVJvdW5kKHN0YXRpc3RpY3MubWF4LCBwcm9wcywgZmlsdGVyRmllbGQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJlc3VsdC52YWx1ZSA9IGZpZWxkVHlwZVJvdW5kKHN0YXRpc3RpY3MuYXZnLCBwcm9wcywgZmlsdGVyRmllbGQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTaWduaWZpY2FudERpZ2l0cyhwcm9wcywgZmlsdGVyRmllbGQpIHtcbiAgY29uc3QgeyBsYXllciB9ID0gcHJvcHM7XG4gIGxldCBzaWduaWZpY2FudERpZ2l0cyA9IDI7XG4gIGNvbnN0IHBvcHVwVGVtcGxhdGUgPSBsYXllci50eXBlICE9PSBcInN1YnR5cGUtZ3JvdXBcIiAmJiBsYXllci5wb3B1cFRlbXBsYXRlO1xuICBpZiAocG9wdXBUZW1wbGF0ZSkge1xuICAgIGNvbnN0IHBvcEZpZWxkSW5mb3MgPSBwb3B1cFRlbXBsYXRlLmZpZWxkSW5mb3MuZmlsdGVyKChmaWVsZEluZm8pID0+IGZpZWxkSW5mby5maWVsZE5hbWUgPT09IGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgaWYgKHBvcEZpZWxkSW5mb3MgPT09IG51bGwgfHwgcG9wRmllbGRJbmZvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wRmllbGRJbmZvcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvcEZpZWxkSW5mbyA9IHBvcEZpZWxkSW5mb3NbMF07XG4gICAgICBpZiAocG9wRmllbGRJbmZvLmZvcm1hdCAmJiBpc0RlZmluZWQocG9wRmllbGRJbmZvLmZvcm1hdC5wbGFjZXMpKSB7XG4gICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gcG9wRmllbGRJbmZvLmZvcm1hdC5wbGFjZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzaWduaWZpY2FudERpZ2l0cztcbn1cbmZ1bmN0aW9uIHJvdW5kVG9TaWduaWZpY2FudERpZ2l0cyh2YWx1ZSwgcHJvcHMsIGZpbHRlckZpZWxkKSB7XG4gIGNvbnN0IHNpZ25pZmljYW50RGlnaXRzID0gZ2V0U2lnbmlmaWNhbnREaWdpdHMocHJvcHMsIGZpbHRlckZpZWxkKTtcbiAgY29uc3QgZmFjdG9yID0gTWF0aC5wb3coMTAsIHNpZ25pZmljYW50RGlnaXRzKTtcbiAgcmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgJiYgTWF0aC5yb3VuZCh2YWx1ZSAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5mdW5jdGlvbiBmaWVsZFR5cGVSb3VuZCh2YWx1ZSwgcHJvcHMsIGZpbHRlckZpZWxkKSB7XG4gIHJldHVybiAoaXNEZWZpbmVkKHZhbHVlKSAmJlxuICAgIChpc0ludGVnZXJUeXBlKGZpbHRlckZpZWxkKSA/IE1hdGgucm91bmQodmFsdWUpIDogcm91bmRUb1NpZ25pZmljYW50RGlnaXRzKHZhbHVlLCBwcm9wcywgZmlsdGVyRmllbGQpKSk7XG59XG5mdW5jdGlvbiBnZXRTaW1wbGVGaWVsZFR5cGUocHJvcHMsIGZlYXR1cmVGaWx0ZXJGaWVsZCkge1xuICBzd2l0Y2ggKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICBwcm9wcy5zdHJpbmdGaWVsZHNDb3VudCsrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRhdGVcIjpcbiAgICAgIGlmIChoYXNGaWVsZERvbWFpbnMoZmVhdHVyZUZpbHRlckZpZWxkKSkge1xuICAgICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgICAgIHByb3BzLnN0cmluZ0ZpZWxkc0NvdW50Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmVhdHVyZUZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuREFURTtcbiAgICAgICAgcHJvcHMuZGF0ZUZpZWxkc0NvdW50Kys7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGF0ZS1vbmx5XCI6XG4gICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2lkXCI6XG4gICAgICBmZWF0dXJlRmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID0gc2ltcGxlRmllbGRUeXBlcy5PSUQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZ3VpZFwiOlxuICAgICAgZmVhdHVyZUZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuR1VJRDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzbWFsbC1pbnRlZ2VyXCI6XG4gICAgY2FzZSBcImJpZy1pbnRlZ2VyXCI6XG4gICAgY2FzZSBcImludGVnZXJcIjpcbiAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgY2FzZSBcImRvdWJsZVwiOlxuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICBpZiAoaGFzRmllbGREb21haW5zKGZlYXR1cmVGaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgZmVhdHVyZUZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuU1RSSU5HO1xuICAgICAgICBwcm9wcy5zdHJpbmdGaWVsZHNDb3VudCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZlYXR1cmVGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPSBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUjtcbiAgICAgICAgcHJvcHMubnVtYmVyRmllbGRzQ291bnQrKztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBpc051bWJlclR5cGUoZmVhdHVyZUZpbHRlckZpZWxkKSB7XG4gIHJldHVybiAoW1wic21hbGwtaW50ZWdlclwiLCBcImJpZy1pbnRlZ2VyXCIsIFwiaW50ZWdlclwiLCBcInNpbmdsZVwiLCBcImRvdWJsZVwiLCBcImxvbmdcIl0uaW5kZXhPZihmZWF0dXJlRmlsdGVyRmllbGQubGF5ZXJGaWVsZC50eXBlKSA+IC0xKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlclR5cGUoZmVhdHVyZUZpbHRlckZpZWxkKSB7XG4gIHJldHVybiBbXCJzbWFsbC1pbnRlZ2VyXCIsIFwiYmlnLWludGVnZXJcIiwgXCJpbnRlZ2VyXCIsIFwibG9uZ1wiXS5pbmRleE9mKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLnR5cGUpID4gLTE7XG59XG5mdW5jdGlvbiBpc0Zsb2F0VHlwZShmZWF0dXJlRmlsdGVyRmllbGQpIHtcbiAgcmV0dXJuIFtcInNpbmdsZVwiLCBcImRvdWJsZVwiXS5pbmRleE9mKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLnR5cGUpID4gLTE7XG59XG5mdW5jdGlvbiBpc0RhdGVUeXBlKGZlYXR1cmVGaWx0ZXJGaWVsZCkge1xuICByZXR1cm4gW1wiZGF0ZVwiXS5pbmRleE9mKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLnR5cGUpID4gLTE7XG59XG5mdW5jdGlvbiBpc0RhdGVPbmx5VHlwZShmZWF0dXJlRmlsdGVyRmllbGQpIHtcbiAgcmV0dXJuIFtcImRhdGUtb25seVwiXS5pbmRleE9mKGZlYXR1cmVGaWx0ZXJGaWVsZC5sYXllckZpZWxkLnR5cGUpID4gLTE7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0hpc3RvZ3JhbShmaWVsZE5hbWUsIG9wZXJhdG9yLCBwcm9wcykge1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgLy8gVE9ETyAtIGFsc28gY2hlY2sgZmllbGQgdmFsdWUgdHlwZSA/XG4gIGlmIChmaWx0ZXJGaWVsZCAmJlxuICAgIGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSAmJlxuICAgIGZpbHRlckZpZWxkLnN0YXRpc3RpY3NTdGF0dXMgIT09IFwiZmFpbGVkXCIgJiZcbiAgICAoKFtzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUiwgc2ltcGxlRmllbGRUeXBlcy5EQVRFLCBzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0uaW5kZXhPZihmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpID4gLTEgJiZcbiAgICAgIFtcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJcyxcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNPbixcbiAgICAgICAgLy8gZG9uJ3QgcmVtZW1iZXIgdGhlIHJlYXNvbiB3ZSBoaWQgaXNOb3RPbiBmb3IgZGF0ZSBmaWVsZHMgaW4gdGhlIHBhc3QsIHNvIGVuYWJsaW5nIGl0IGFnYWluXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T24sXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3QsXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhbixcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZWZvcmUsXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNHcmVhdGVyVGhhbixcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNBZnRlcixcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdCxcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3QsXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNCZXR3ZWVuLFxuICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW4sXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCZXR3ZWVuLFxuICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW5cbiAgICAgIF0uaW5kZXhPZihvcGVyYXRvcikgPiAtMSkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhwcm9wcykge1xuICBjb25zdCB7IGxheWVyLCBleHByZXNzaW9ucywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gIGlmIChsYXllci50eXBlICE9PSBcImZlYXR1cmVcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHBvcnRhbEl0ZW0sIHNvdXJjZUpTT04gfSA9IGxheWVyO1xuICBpZiAoIXBvcnRhbEl0ZW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgeyB0eXBlS2V5d29yZHMsIGl0ZW1Db250cm9sLCBwb3J0YWwgfSA9IHBvcnRhbEl0ZW07XG4gIGNvbnN0IGlzUG9ydGFsID0gcG9ydGFsLmlzUG9ydGFsO1xuICBjb25zdCBpc0hvc3RlZCA9ICh0eXBlS2V5d29yZHMgPT09IG51bGwgfHwgdHlwZUtleXdvcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlS2V5d29yZHMuaW5kZXhPZihcIkhvc3RlZCBTZXJ2aWNlXCIpKSA+IC0xO1xuICBjb25zdCBpc09ubGluZUxvY2F0aW9uVHJhY2tpbmdTZXJ2aWNlID0gIWlzUG9ydGFsICYmICh0eXBlS2V5d29yZHMgPT09IG51bGwgfHwgdHlwZUtleXdvcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlS2V5d29yZHMuaW5kZXhPZihcIkxvY2F0aW9uIFRyYWNraW5nIFNlcnZpY2VcIikpID4gLTE7XG4gIGlmICghaXNIb3N0ZWQgfHwgaXNPbmxpbmVMb2NhdGlvblRyYWNraW5nU2VydmljZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocG9ydGFsLnVzZXIgJiYgaXRlbUNvbnRyb2wgJiYgW1wiYWRtaW5cIiwgXCJ1cGRhdGVcIl0uaW5kZXhPZihpdGVtQ29udHJvbCkgPiAtMSkge1xuICAgIGNvbnN0IGkxOG5PcHMgPSBzdHJpbmdzLm9wZXJhdG9ycztcbiAgICBjb25zdCBpbnZhbGlkT3BlcmF0b3JzID0gW1xuICAgICAgaTE4bk9wcy5zdHJpbmdPcGVyYXRvckVuZHNXaXRoLFxuICAgICAgaTE4bk9wcy5zdHJpbmdPcGVyYXRvckNvbnRhaW5zLFxuICAgICAgaTE4bk9wcy5zdHJpbmdPcGVyYXRvckRvZXNOb3RDb250YWluXG4gICAgXTtcbiAgICBjb25zdCBmaWVsZE5hbWVzID0gW107XG4gICAgY29uc3QgYWRkRmllbGRUb0xpc3QgPSAoY29uZGl0aW9uKSA9PiB7XG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBjb25kaXRpb24uZmllbGROYW1lO1xuICAgICAgaWYgKCFmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICBjb25zdCBpc1ZhbGlkRmllbGQgPSAhKCgoZmlsdGVyRmllbGQgPT09IG51bGwgfHwgZmlsdGVyRmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPT09IHNpbXBsZUZpZWxkVHlwZXMuU1RSSU5HIHx8XG4gICAgICAgIChmaWx0ZXJGaWVsZCA9PT0gbnVsbCB8fCBmaWx0ZXJGaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA9PT0gc2ltcGxlRmllbGRUeXBlcy5HVUlEKSAmJlxuICAgICAgICAoZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5sZW5ndGggPiA0MDAwIHx8IGludmFsaWRPcGVyYXRvcnMuaW5kZXhPZihjb25kaXRpb24ub3BlcmF0b3IpID4gLTEpKTtcbiAgICAgIGlmIChpc1ZhbGlkRmllbGQgJiYgZmllbGROYW1lcy5pbmRleE9mKGZpZWxkTmFtZSkgPT09IC0xKSB7XG4gICAgICAgIGZpZWxkTmFtZXMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwcmVzc2lvbnMgPT09IG51bGwgfHwgZXhwcmVzc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cHJlc3Npb25zLmZvckVhY2goKGV4cHJlc3Npb24pID0+IGV4cHJlc3Npb24uY29uZGl0aW9ucy5mb3JFYWNoKChjb25kaXRpb24pID0+IGFkZEZpZWxkVG9MaXN0KGNvbmRpdGlvbikpKTtcbiAgICBjb25zdCBqc29uID0ge1xuICAgICAgaW5kZXhlczogW11cbiAgICB9O1xuICAgIHNvdXJjZUpTT04uaW5kZXhlcyA9IHNvdXJjZUpTT04uaW5kZXhlcyB8fCBbXTtcbiAgICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgaWYgKCFzb3VyY2VKU09OLmluZGV4ZXMuc29tZSgoaW5kZXgpID0+IGluZGV4LmZpZWxkcyA9PT0gZmllbGROYW1lKSkge1xuICAgICAgICAvLyBpbmRleCBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgICBqc29uLmluZGV4ZXMucHVzaCh7XG4gICAgICAgICAgbmFtZTogYCR7ZmllbGROYW1lfV9JbmRleGAsXG4gICAgICAgICAgZmllbGRzOiBmaWVsZE5hbWUsXG4gICAgICAgICAgaXNVbmlxdWU6IGZhbHNlLFxuICAgICAgICAgIGlzQXNjZW5kaW5nOiB0cnVlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtmaWVsZE5hbWV9X0luZGV4YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoanNvbi5pbmRleGVzLmxlbmd0aCkge1xuICAgICAgZXhlY3V0ZUNyZWF0ZUluZGV4ZXMoanNvbiwgcHJvcHMpO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNyZWF0ZUluZGV4ZXMoanNvbiwgcHJvcHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgeyBsYXllciwgcGFyZW50U2VydmljZVVybCB9ID0gcHJvcHM7XG4gIGlmIChsYXllci50eXBlICE9PSBcImZlYXR1cmVcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHBvcnRhbEl0ZW0sIHNvdXJjZUpTT04gfSA9IGxheWVyO1xuICBjb25zdCB7IHR5cGVLZXl3b3JkcywgcG9ydGFsIH0gPSBwb3J0YWxJdGVtO1xuICBjb25zdCBpc1ZpZXcgPSB0eXBlS2V5d29yZHMuaW5jbHVkZXMoXCJWaWV3IFNlcnZpY2VcIik7XG4gIGNvbnN0IFtJZGVudGl0eU1hbmFnZXIsIGVzcmlSZXF1ZXN0XSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyXCIsIFwiZXNyaS9yZXF1ZXN0XCJdKTtcbiAgaWYgKGlzVmlldyAmJiAhcGFyZW50U2VydmljZVVybCkge1xuICAgIC8vIG5lZWQgdG8gdXNlIHRoZSBvcmlnaW5hbCBzZXJ2aWNlIHVybFxuICAgIHZhciByZWxhdGVkVXJsID0gYCR7cG9ydGFsLnJlc3RVcmx9L2NvbnRlbnQvaXRlbXMvJHtwb3J0YWxJdGVtLmlkfS9yZWxhdGVkSXRlbXM/cmVsYXRpb25zaGlwVHlwZT1TZXJ2aWNlMlNlcnZpY2UmZGlyZWN0aW9uPXJldmVyc2VgO1xuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBJZGVudGl0eU1hbmFnZXIuZ2V0Q3JlZGVudGlhbChwb3J0YWwucmVzdFVybCwgeyBwcm9tcHQ6IGZhbHNlIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVzcmlSZXF1ZXN0KHJlbGF0ZWRVcmwsIHsgcXVlcnk6IHsgZjogXCJqc29uXCIsIHRva2VuOiBjcmVkZW50aWFsLnRva2VuIH0gfSk7XG4gICAgaWYgKChfYSA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG90YWwpIHtcbiAgICAgIHJlc3VsdC5kYXRhLnJlbGF0ZWRJdGVtc1xuICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGVLZXl3b3Jkcy5pbmNsdWRlcyhcIkhvc3RlZCBTZXJ2aWNlXCIpKVxuICAgICAgICAuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBwcm9wcy5wYXJlbnRTZXJ2aWNlVXJsID0gaXRlbS51cmw7XG4gICAgICAgIGV4ZWN1dGVDcmVhdGVJbmRleGVzKGpzb24sIHByb3BzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYWRtaW5VcmwgPSAocGFyZW50U2VydmljZVVybCB8fCBsYXllci51cmwpLnJlcGxhY2UoXCIvcmVzdC9zZXJ2aWNlc1wiLCBcIi9yZXN0L2FkbWluL3NlcnZpY2VzXCIpO1xuICBjb25zdCB1cmwgPSBgJHthZG1pblVybH0vJHtsYXllci5sYXllcklkfS9hZGRUb0RlZmluaXRpb25gO1xuICBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgSWRlbnRpdHlNYW5hZ2VyLmdldENyZWRlbnRpYWwobGF5ZXIudXJsLCB7IHByb21wdDogZmFsc2UgfSk7XG4gIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgZjogXCJqc29uXCIsXG4gICAgYWRkVG9EZWZpbml0aW9uOiBKU09OLnN0cmluZ2lmeShqc29uKSxcbiAgICBhc3luYzogIXBvcnRhbC5pc1BvcnRhbCxcbiAgICB0b2tlbjogY3JlZGVudGlhbC50b2tlblxuICB9O1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBlc3JpUmVxdWVzdCh1cmwsIHtcbiAgICBxdWVyeTogY29udGVudCxcbiAgICBtZXRob2Q6IFwicG9zdFwiXG4gIH0pO1xuICBpZiAocG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgc291cmNlSlNPTi5pbmRleGVzID0gc291cmNlSlNPTi5pbmRleGVzIHx8IFtdO1xuICAgIHNvdXJjZUpTT04uaW5kZXhlcyA9IHNvdXJjZUpTT04uaW5kZXhlcy5jb25jYXQoanNvbi5pbmRleGVzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcG9sbEZvclN0YXR1cygoX2IgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXR1c1VSTCwge1xuICAgICAgICBmOiBcImpzb25cIixcbiAgICAgICAgdG9rZW46IGNyZWRlbnRpYWwudG9rZW5cbiAgICAgIH0sIGVzcmlSZXF1ZXN0KTtcbiAgICAgIHNvdXJjZUpTT04uaW5kZXhlcyA9IHNvdXJjZUpTT04uaW5kZXhlcyB8fCBbXTtcbiAgICAgIHNvdXJjZUpTT04uaW5kZXhlcyA9IHNvdXJjZUpTT04uaW5kZXhlcy5jb25jYXQoanNvbi5pbmRleGVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vdCBhIGJpZyBwcm9ibGVtIGlmIGl0IGRpZG4ndCB3b3JrXG4gICAgfVxuICB9XG59XG5jb25zdCBwb2xsRm9yU3RhdHVzID0gYXN5bmMgKHVybCwgcGFyYW1zLCBlc3JpUmVxdWVzdCkgPT4ge1xuICB2YXIgX2E7XG4gIGlmICghdXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicG9sbEZvclN0YXR1czogbm8gc3RhdHVzIFVSTFwiKTtcbiAgfVxuICBjb25zdCBwZW5kaW5nU3RhdHVzZXMgPSBbXCJwcm9jZXNzaW5nXCIsIFwicGFydGlhbFwiLCBcIlBlbmRpbmdcIiwgXCJJblByb2dyZXNzXCJdO1xuICBjb25zdCBzdWNjZXNzU3RhdHVzZXMgPSBbXCJjb21wbGV0ZWRcIiwgXCJDb21wbGV0ZWRcIl07XG4gIC8vIEtlZXAgcG9sbGluZyBzdGF0dXMgdW50aWwgZWl0aGVyIGNvbXBsZXRlZCBvciBmYWlsZWRcbiAgdHJ5IHtcbiAgICAvLyBEbyBmYWlsdXJlcyByZXBvcnQgYXMgc3VjY2VzcyAoc3RhdHVzIDIwMCk/IE1heSBuZWVkIHRvIG1hbnVhbGx5IHRocm93IGVycm9yIG9uIHN0YXR1cyBjaGVjayBmYWlsdXJlXG4gICAgY29uc3Qgc3RhdHVzUmVzcG9uc2UgPSBhd2FpdCBlc3JpUmVxdWVzdCh1cmwsIHsgcXVlcnk6IHBhcmFtcyB9KTtcbiAgICBjb25zdCBzdGF0dXMgPSAoX2EgPSBzdGF0dXNSZXNwb25zZSA9PT0gbnVsbCB8fCBzdGF0dXNSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHVzUmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cztcbiAgICBpZiAocGVuZGluZ1N0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgIGF3YWl0IHRpbWVvdXQoNTAwKTtcbiAgICAgIHJldHVybiBwb2xsRm9yU3RhdHVzKHVybCwgcGFyYW1zLCBlc3JpUmVxdWVzdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN1Y2Nlc3NTdGF0dXNlcy5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICByZXR1cm4gc3RhdHVzUmVzcG9uc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgc3RhdHVzUmVzcG9uc2U7XG4gICAgfVxuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZE9wZXJhdG9yc0xpc3QocHJvcHMpIHtcbiAgY29uc3QgeyBsYXllciwgZmVhdHVyZVJlZHVjdGlvbiwgc3RyaW5ncyB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzU3RyZWFtTGF5ZXIgPSBsYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLlN0cmVhbUxheWVyXCI7XG4gIGNvbnN0IGlzSW1hZ2VyeUxheWVyID0gbGF5ZXIuZGVjbGFyZWRDbGFzcyA9PT0gXCJlc3JpLmxheWVycy5JbWFnZXJ5TGF5ZXJcIjtcbiAgaWYgKCFwcm9wcy5vcGVyYXRvcnMpIHtcbiAgICBwcm9wcy5vcGVyYXRvcnMgPSB7fTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddID0gW107XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNcbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdFxuICAgIH0pO1xuICAgIGlmICghaXNTdHJlYW1MYXllciAmJiAhaXNJbWFnZXJ5TGF5ZXIpIHtcbiAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLlNUUklOR10ucHVzaCh7XG4gICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySW5jbHVkZXNcbiAgICAgIH0pO1xuICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFeGNsdWRlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLlNUUklOR10ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvclN0YXJ0c1dpdGhcbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFbmRzV2l0aFxuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLlNUUklOR10ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckNvbnRhaW5zXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRG9lc05vdENvbnRhaW5cbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc0JsYW5rXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuU1RSSU5HXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RCbGFua1xuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLlNUUklOR10ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzRW1wdHlcbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5TVFJJTkddLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEVtcHR5XG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0gPSBbXTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT25cbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T25cbiAgICB9KTtcbiAgICAvKiBpZiAoIWlzU3RyZWFtTGF5ZXIpIHtcbiAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckluY2x1ZGVzXG4gICAgICB9KTtcbiAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckV4Y2x1ZGVzXG4gICAgICB9KTtcbiAgICB9ICovXG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JlZm9yZVxuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNBZnRlclxuICAgIH0pO1xuICAgIGlmIChwcm9wcy5pc0hvc3RlZCB8fCBwcm9wcy5zdXBwb3J0ZWRTcWxQYXJzZXJWZXJzaW9uKSB7XG4gICAgICAvLyB8fCBsYXllci52ZXJzaW9uID49IDEwLjIxKSB7XG4gICAgICAvLyBXZSBkb24ndCBrbm93IGlmIENVUlJFTlRfVElNRVNUQU1QIGlzIGluIFVUQyBmb3Igb3RoZXIgZGF0YWJhc2VzLlxuICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0ucHVzaCh7XG4gICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvckluVGhlTGFzdFxuICAgICAgfSk7XG4gICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5wdXNoKHtcbiAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9yTm90SW5UaGVMYXN0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW5cbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90QmV0d2VlblxuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCbGFua1xuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVdLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RCbGFua1xuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0gPSBbXTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNPblxuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdE9uXG4gICAgfSk7XG4gICAgLyogaWYgKCFpc1N0cmVhbUxheWVyKSB7XG4gICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLnB1c2goe1xuICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJbmNsdWRlc1xuICAgICAgfSk7XG4gICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLnB1c2goe1xuICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JFeGNsdWRlc1xuICAgICAgfSk7XG4gICAgfSAqL1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JlZm9yZVxuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0FmdGVyXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2VlblxuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW5cbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCbGFua1xuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJsYW5rXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXSA9IFtdO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUl0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RcbiAgICB9KTtcbiAgICBpZiAoIWZlYXR1cmVSZWR1Y3Rpb24gJiYgIWlzU3RyZWFtTGF5ZXIgJiYgIWlzSW1hZ2VyeUxheWVyKSB7XG4gICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckluY2x1ZGVzXG4gICAgICB9KTtcbiAgICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUl0ucHVzaCh7XG4gICAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9yRXhjbHVkZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3RcbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0xlc3NUaGFuXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdE1vc3RcbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNCZXR3ZWVuXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCZXR3ZWVuXG4gICAgfSk7XG4gICAgaWYgKCFmZWF0dXJlUmVkdWN0aW9uKSB7XG4gICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJdLnB1c2goe1xuICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQmxhbmtcbiAgICAgIH0pO1xuICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSXS5wdXNoKHtcbiAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJsYW5rXG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXSA9IFtdO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRPTUFJTl0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzXG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RcbiAgICB9KTtcbiAgICBpZiAoIWlzU3RyZWFtTGF5ZXIgJiYgIWlzSW1hZ2VyeUxheWVyICYmICFpc0ltYWdlcnlMYXllcikge1xuICAgICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJbmNsdWRlc1xuICAgICAgfSk7XG4gICAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5ET01BSU5dLnB1c2goe1xuICAgICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckV4Y2x1ZGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNCbGFua1xuICAgIH0pO1xuICAgIHByb3BzLm9wZXJhdG9yc1tzaW1wbGVGaWVsZFR5cGVzLkRPTUFJTl0ucHVzaCh7XG4gICAgICBuYW1lOiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzTm90QmxhbmtcbiAgICB9KTtcbiAgICBwcm9wcy5vcGVyYXRvcnNbc2ltcGxlRmllbGRUeXBlcy5ET01BSU5dLnB1c2goe1xuICAgICAgbmFtZTogc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc0VtcHR5XG4gICAgfSk7XG4gICAgcHJvcHMub3BlcmF0b3JzW3NpbXBsZUZpZWxkVHlwZXMuRE9NQUlOXS5wdXNoKHtcbiAgICAgIG5hbWU6IHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RFbXB0eVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0T3BlcmF0b3IocHJvcHMsIGZlYXR1cmVGaWx0ZXJGaWVsZCkge1xuICBjb25zdCB7IHN0cmluZ3MsIGRlZmF1bHRPcGVyYXRvciB9ID0gcHJvcHM7XG4gIGlmIChmZWF0dXJlRmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lID09PSBcImNsdXN0ZXJfY291bnRcIikge1xuICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzR3JlYXRlclRoYW47XG4gIH1cbiAgc3dpdGNoIChmZWF0dXJlRmlsdGVyRmllbGQubGF5ZXJGaWVsZC50eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXM7XG4gICAgY2FzZSBcImRhdGVcIjpcbiAgICBjYXNlIFwiZGF0ZS1vbmx5XCI6XG4gICAgICBpZiAoaGFzRmllbGREb21haW5zKGZlYXR1cmVGaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkZWZhdWx0T3BlcmF0b3IpIHtcbiAgICAgICAgc3dpdGNoIChkZWZhdWx0T3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXI7XG4gICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JlZm9yZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCZWZvcmU7XG4gICAgICB9XG4gICAgY2FzZSBcIm9pZFwiOlxuICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM7XG4gICAgY2FzZSBcImd1aWRcIjpcbiAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzO1xuICAgIGNhc2UgXCJzbWFsbC1pbnRlZ2VyXCI6XG4gICAgY2FzZSBcImJpZy1pbnRlZ2VyXCI6XG4gICAgY2FzZSBcImludGVnZXJcIjpcbiAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICBpZiAoaGFzRmllbGREb21haW5zKGZlYXR1cmVGaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChkZWZhdWx0T3BlcmF0b3IpIHtcbiAgICAgICAgc3dpdGNoIChkZWZhdWx0T3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNHcmVhdGVyVGhhbjtcbiAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRMZWFzdDtcbiAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhbjtcbiAgICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRNb3N0O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzO1xuICAgICAgfVxuICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgaWYgKGhhc0ZpZWxkRG9tYWlucyhmZWF0dXJlRmlsdGVyRmllbGQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGVmYXVsdE9wZXJhdG9yKSB7XG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdE9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzR3JlYXRlclRoYW47XG4gICAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3Q7XG4gICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTGVzc1RoYW47XG4gICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3Q7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICB9XG59XG5mdW5jdGlvbiBpc0JldHdlZW5PcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpIHtcbiAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgaWYgKG9wZXJhdG9yICYmXG4gICAgW1xuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW4sXG4gICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90QmV0d2VlbixcbiAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2VlbixcbiAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90QmV0d2VlblxuICAgIF0uaW5kZXhPZihvcGVyYXRvcikgPiAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQmxhbmtPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpIHtcbiAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgaWYgKG9wZXJhdG9yICYmXG4gICAgW1xuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc0JsYW5rLFxuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEJsYW5rLFxuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JsYW5rLFxuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJsYW5rLFxuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCbGFuayxcbiAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90QmxhbmtcbiAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0VtcHR5T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSB7XG4gIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gIGlmIChvcGVyYXRvciAmJlxuICAgIFtzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzRW1wdHksIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RFbXB0eV0uaW5kZXhPZihvcGVyYXRvcikgPiAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTGlzdE9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikge1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBpZiAob3BlcmF0b3IgJiZcbiAgICBbXG4gICAgICBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzLFxuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JFeGNsdWRlcyxcbiAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySW5jbHVkZXMsXG4gICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckV4Y2x1ZGVzXG4gICAgXS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikge1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBpZiAob3BlcmF0b3IgJiZcbiAgICBbc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJbmNsdWRlcywgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJbmNsdWRlc10uaW5kZXhPZihvcGVyYXRvcikgPiAtMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzRXhjbHVkZXNPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpIHtcbiAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgaWYgKG9wZXJhdG9yICYmXG4gICAgW3N0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRXhjbHVkZXMsIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9yRXhjbHVkZXNdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0luVGhlTGFzdE9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikge1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBpZiAob3BlcmF0b3IgJiZcbiAgICBbc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySW5UaGVMYXN0LCBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JOb3RJblRoZUxhc3RdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBmaWx0ZXJGaWVsZCkge1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBzd2l0Y2ggKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwiZG9tYWluXCI6XG4gICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJbmNsdWRlcztcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcIm9pZFwiOlxuICAgIGNhc2UgXCJndWlkXCI6XG4gICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJbmNsdWRlcztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySW5jbHVkZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV4Y2x1ZGVzT3BlcmF0b3IocHJvcHMsIGZpbHRlckZpZWxkKSB7XG4gIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gIHN3aXRjaCAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRXhjbHVkZXM7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJvaWRcIjpcbiAgICBjYXNlIFwiZ3VpZFwiOlxuICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9yRXhjbHVkZXM7XG4gICAgLy9jYXNlIFwiZGF0ZVwiOlxuICAgIC8vY2FzZSBcImRhdGUtb25seVwiOlxuICAgIC8vICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9yRXhjbHVkZXM7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckV4Y2x1ZGVzO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRvciQxKHByb3BzLCBvbGRGaWx0ZXJGaWVsZCwgbmV3RmlsdGVyRmllbGQsIG9sZE9wZXJhdG9yKSB7XG4gIGlmIChvbGRGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgIT09IG5ld0ZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkge1xuICAgIGlmIChpc0luY2x1ZGVzT3BlcmF0b3IocHJvcHMsIG9sZE9wZXJhdG9yKSAmJiBuZXdGaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgIT09IHNpbXBsZUZpZWxkVHlwZXMuREFURSkge1xuICAgICAgcmV0dXJuIGdldEluY2x1ZGVzT3BlcmF0b3IocHJvcHMsIG5ld0ZpbHRlckZpZWxkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFeGNsdWRlc09wZXJhdG9yKHByb3BzLCBvbGRPcGVyYXRvcikpIHtcbiAgICAgIHJldHVybiBnZXRFeGNsdWRlc09wZXJhdG9yKHByb3BzLCBuZXdGaWx0ZXJGaWVsZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGdldERlZmF1bHRPcGVyYXRvcihwcm9wcywgbmV3RmlsdGVyRmllbGQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2xkT3BlcmF0b3I7XG59XG5cbi8vaW1wb3J0ICogYXMgbnVtYmVyIGZyb20gXCJkb2pvL251bWJlclwiO1xuLy9pbXBvcnQgKiBhcyBsb2NhbGUgZnJvbSBcImRvam8vZGF0ZS9sb2NhbGVcIjtcbmNvbnN0IGRheUluTVMgPSAyNCAqIDYwICogNjAgKiAxMDAwIC0gMTAwMDtcbmZ1bmN0aW9uIGNyZWF0ZVdoZXJlQ2xhdXNlKHByb3BzKSB7XG4gIGxldCB3aGVyZUNsYXVzZSA9IFwiXCI7XG4gIGlmICghcHJvcHMuZXhwcmVzc2lvbnMgfHwgIXByb3BzLmV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBqb2luID0gXCJcIjtcbiAgbGV0IHN1Y2Nlc3NmdWxFeHByZXNzaW9ucyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMuZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBleHByID0gcHJvcHMuZXhwcmVzc2lvbnNbaV07XG4gICAgY29uc3Qgc3RyID0gY3JlYXRlRXhwcmVzc2lvbldoZXJlQ2xhdXNlKGV4cHIsIHByb3BzKTtcbiAgICBpZiAoc3RyLmxlbmd0aCkge1xuICAgICAgaWYgKHN1Y2Nlc3NmdWxFeHByZXNzaW9ucyA9PT0gMCkge1xuICAgICAgICB3aGVyZUNsYXVzZSA9IHN0cjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN1Y2Nlc3NmdWxFeHByZXNzaW9ucyA9PT0gMSkge1xuICAgICAgICBqb2luID0gYCAke3Byb3BzLmxvZ2ljYWxPcGVyYXRvckZvckV4cHJlc3Npb25zID09PSBsb2dpY2FsT3BlcmF0b3JzLk9SID8gXCJPUlwiIDogXCJBTkRcIn0gYDtcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgKCR7d2hlcmVDbGF1c2V9KSR7am9pbn0oJHtzdHJ9KWA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2hlcmVDbGF1c2UgKz0gYCR7am9pbn0oJHtzdHJ9KWA7XG4gICAgICB9XG4gICAgICBzdWNjZXNzZnVsRXhwcmVzc2lvbnMrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdoZXJlQ2xhdXNlLmxlbmd0aCA/IHdoZXJlQ2xhdXNlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb25XaGVyZUNsYXVzZShleHByZXNzaW9uLCBwcm9wcykge1xuICBsZXQgZXhwcldoZXJlQ2xhdXNlID0gXCJcIjtcbiAgaWYgKGV4cHJlc3Npb24uY29uZGl0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICBleHByV2hlcmVDbGF1c2UgPSBjcmVhdGVDb25kaXRpb25XaGVyZUNsYXVzZShleHByZXNzaW9uLmNvbmRpdGlvbnNbMF0sIHByb3BzKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsZXQgam9pbiA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9uLmNvbmRpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbmQgPSBleHByZXNzaW9uLmNvbmRpdGlvbnNbaV07XG4gICAgICBjb25zdCBjb25kV2hlcmVDbGF1c2UgPSBjcmVhdGVDb25kaXRpb25XaGVyZUNsYXVzZShjb25kLCBwcm9wcyk7XG4gICAgICBpZiAoY29uZFdoZXJlQ2xhdXNlLmxlbmd0aCkge1xuICAgICAgICBleHByV2hlcmVDbGF1c2UgKz0gam9pbiArIGNvbmRXaGVyZUNsYXVzZTtcbiAgICAgICAgam9pbiA9IGAgJHtleHByZXNzaW9uLmxvZ2ljYWxPcGVyYXRvckZvckNvbmRpdGlvbnMgPT09IGxvZ2ljYWxPcGVyYXRvcnMuT1IgPyBcIk9SXCIgOiBcIkFORFwifSBgO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwcldoZXJlQ2xhdXNlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29uZGl0aW9uV2hlcmVDbGF1c2UoY29uZGl0aW9uLCBwcm9wcykge1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBjb25zdCBmaWVsZE5hbWUgPSBjb25kaXRpb24uZmllbGROYW1lO1xuICBjb25zdCBvcGVyYXRvciA9IGNvbmRpdGlvbi5vcGVyYXRvcjtcbiAgbGV0IHZhbHVlID0gY29uZGl0aW9uLnZhbHVlO1xuICBsZXQgdmFsdWUyID0gY29uZGl0aW9uLnZhbHVlMjtcbiAgbGV0IHZhbHVlcyA9IGNvbmRpdGlvbi52YWx1ZXMgfHwgW107XG4gIGNvbnN0IHVuaXQgPSBjb25kaXRpb24udW5pdDtcbiAgY29uc3QgZmllbGRPYmplY3QgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gIGlmICghZmllbGRPYmplY3QpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAoaXNCZXR3ZWVuT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSAmJiAhaXNEZWZpbmVkKHZhbHVlMikpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBlbHNlIGlmIChpc0xpc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpICYmICF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZWxzZSBpZiAoaXNJblRoZUxhc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpICYmICFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZWxzZSBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkgJiZcbiAgICAhdmFsdWVzLmxlbmd0aCAmJlxuICAgICFpc0JsYW5rT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSAmJlxuICAgICFpc0VtcHR5T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIC8qIGlmIChpc0xpc3RPcGVyYXRvcihvcGVyYXRvcikgJiYgZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEUpIHtcbiAgICAvLyBtYXggb25lIHZhbHVlOyB3ZSBjYW4ndCBzdXBwb3J0IElOXG4gICAgdmFsdWUgPSB2YWx1ZXM/LlswXTtcbiAgfSAqL1xuICBsZXQgd2hlcmVDbGF1c2UgPSBcIlwiO1xuICBpZiAoZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLlNUUklORyB8fFxuICAgIGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5HVUlEKSB7XG4gICAgbGV0IHByZWZpeCA9IFwiXCI7XG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgcHJvcHMuaXNIb3N0ZWQpIHtcbiAgICAgIGlmIChjb250YWluc05vbkxhdGluQ2hhcmFjdGVyKHZhbHVlKSkge1xuICAgICAgICBwcmVmaXggPSBcIk5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZS5nLiBjb2RlZCB2YWx1ZSBkb21haW5zXG4gICAgY29uc3QgaXNOdW1iZXIgPSBpc051bWJlclR5cGUoZmllbGRPYmplY3QpO1xuICAgIGNvbnN0IHN0ciA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL1xcJy9nLCBcIicnXCIpO1xuICAgIHN3aXRjaCAoY29uZGl0aW9uLm9wZXJhdG9yKSB7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXM6IHtcbiAgICAgICAgY29uc3QgcFN0ciA9IGAke3ByZWZpeH0nJHtzdHJ9J2A7XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA9ICR7aXNOdW1iZXIgPyB2YWx1ZSA6IHBTdHJ9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3Q6IHtcbiAgICAgICAgY29uc3QgcFN0ciA9IGAke3ByZWZpeH0nJHtzdHJ9J2A7XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA8PiAke2lzTnVtYmVyID8gdmFsdWUgOiBwU3RyfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvclN0YXJ0c1dpdGg6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBMSUtFICR7cHJlZml4fScke3N0cn0lJ2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckVuZHNXaXRoOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTElLRSAke3ByZWZpeH0nJSR7c3RyfSdgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JDb250YWluczpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IExJS0UgJHtwcmVmaXh9JyUke3N0cn0lJ2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckRvZXNOb3RDb250YWluOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTk9UIExJS0UgJHtwcmVmaXh9JyUke3N0cn0lJ2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzOiB7XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJTiAoJHt2YWx1ZXNcbiAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gaXNOdW1iZXJcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBgJHtjb250YWluc05vbkxhdGluQ2hhcmFjdGVyKHZhbHVlKSA/IFwiTlwiIDogXCJcIn0nJHt2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cXCcvZywgXCInJ1wiKX0nYClcbiAgICAgICAgICAudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRXhjbHVkZXM6IHtcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IE5PVCBJTiAoJHt2YWx1ZXNcbiAgICAgICAgICAubWFwKCh2YWx1ZSkgPT4gaXNOdW1iZXJcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBgJHtjb250YWluc05vbkxhdGluQ2hhcmFjdGVyKHZhbHVlKSA/IFwiTlwiIDogXCJcIn0nJHt2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cXCcvZywgXCInJ1wiKX0nYClcbiAgICAgICAgICAudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNCbGFuazpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IElTIE5VTExgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEJsYW5rOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSVMgTk9UIE5VTExgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc0VtcHR5OlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPSAnJ2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzTm90RW1wdHk6XG4gICAgICAgIC8vd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDw+ICcnIE9SICR7ZmllbGROYW1lfSBJUyBOVUxMYDtcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDw+ICcnYDsgLy8gbm90IHJldHVybmluZyBOVUxMIHZhbHVlc1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUiB8fFxuICAgIGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5PSUQpIHtcbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA9ICR7dmFsdWV9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3Q6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA8PiAke3ZhbHVlfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRMZWFzdDpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9ID49ICR7dmFsdWV9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhbjpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDwgJHt2YWx1ZX1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdDpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDw9ICR7dmFsdWV9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNHcmVhdGVyVGhhbjpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9ID4gJHt2YWx1ZX1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBCRVRXRUVOICR7dmFsdWV9IEFORCAke3ZhbHVlMn1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJldHdlZW46XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBOT1QgQkVUV0VFTiAke3ZhbHVlfSBBTkQgJHt2YWx1ZTJ9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySW5jbHVkZXM6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJTiAoJHt2YWx1ZXMudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9yRXhjbHVkZXM6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBOT1QgSU4gKCR7dmFsdWVzLnRvU3RyaW5nKCl9KWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQmxhbms6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBJUyBOVUxMYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCbGFuazpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IElTIE5PVCBOVUxMYDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFkpIHtcbiAgICAvLyBkYXRlXG4gICAgLy8gTk9URTogY2xpZW50IHNpZGUgZmlsdGVyIGVmZmVjdCBvbmx5IHN1cHBvcnRzIHNxbDkyIGFuZCBuZWVkcyB0aGUgZGF0ZSBpbiB0aGUgcXVlcnlcbiAgICAvLyB0aGVyZm9yZSB3ZSBkaXNhYmxlIGRhdGEgZmllbGRzIGZvciBzZXJ2aWNlcyB3aXRob3V0IHN0YW5kYXJkaXplZFF1ZXJ5IHN1cHBvcnRcbiAgICBjb25zdCBkYXRlc3RtcCA9ICFwcm9wcy5zdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5ID8gXCJcIiA6IFwiREFURSBcIjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgdmFsdWUgPSBgJHtkYXRlLmdldEZ1bGxZZWFyKCl9LSR7ZGF0ZS5nZXRNb250aCgpIDwgOSA/IFwiMFwiIDogXCJcIn0ke2RhdGUuZ2V0TW9udGgoKSArIDF9LSR7ZGF0ZS5nZXREYXRlKCkgPCAxMCA/IFwiMFwiIDogXCJcIn0ke2RhdGUuZ2V0RGF0ZSgpfWA7XG4gICAgfVxuICAgIGlmIChpc0RlZmluZWQodmFsdWUyKSAmJiB0eXBlb2YgdmFsdWUyID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUyKTtcbiAgICAgIHZhbHVlMiA9IGAke2RhdGUuZ2V0RnVsbFllYXIoKX0tJHtkYXRlLmdldE1vbnRoKCkgPCA5ID8gXCIwXCIgOiBcIlwifSR7ZGF0ZS5nZXRNb250aCgpICsgMX0tJHtkYXRlLmdldERhdGUoKSA8IDEwID8gXCIwXCIgOiBcIlwifSR7ZGF0ZS5nZXREYXRlKCl9YDtcbiAgICB9XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uOlxuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckluY2x1ZGVzOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gPSAke2RhdGVzdG1wfScke3ZhbHVlfSdgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RPbjpcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JFeGNsdWRlczpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDw+ICR7ZGF0ZXN0bXB9JyR7dmFsdWV9J2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JlZm9yZTpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDwgJHtkYXRlc3RtcH0nJHt2YWx1ZX0nYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXI6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA+ICR7ZGF0ZXN0bXB9JyR7dmFsdWV9J2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBCRVRXRUVOICR7ZGF0ZXN0bXB9JyR7dmFsdWV9JyBBTkQgJHtkYXRlc3RtcH0nJHt2YWx1ZTJ9J2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW46XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBOT1QgQkVUV0VFTiAke2RhdGVzdG1wfScke3ZhbHVlfScgQU5EICR7ZGF0ZXN0bXB9JyR7dmFsdWUyfSdgO1xuICAgICAgICBicmVhaztcbiAgICAgIC8qIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJbmNsdWRlczpcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JFeGNsdWRlczpcbiAgICAgICAgbGV0IGRhdGVWYWx1ZXNTdHJpbmcgPSBcIlwiO1xuICAgICAgICBsZXQgY29tbWEgPSBcIlwiO1xuICAgICAgICBkYXRlVmFsdWVzLmZvckVhY2goKGRhdGVWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgZGF0ZVZhbHVlc1N0cmluZyArPSBgJHtjb21tYX0ke2RhdGVzdG1wfScke2RhdGVWYWx1ZX0nYDtcbiAgICAgICAgICBjb21tYSA9IFwiLFwiO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvckluY2x1ZGVzKSB7XG4gICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IElOICgke2RhdGVWYWx1ZXNTdHJpbmd9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IE5PVCBJTiAoJHtkYXRlVmFsdWVzU3RyaW5nfSlgO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAqL1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JsYW5rOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSVMgTlVMTGA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJsYW5rOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSVMgTk9UIE5VTExgO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZGF0ZVxuICAgIC8vIE5PVEU6IGNsaWVudCBzaWRlIGZpbHRlciBlZmZlY3Qgb25seSBzdXBwb3J0cyBzcWw5MiBhbmQgbmVlZHMgdGhlIHRpbWVzdGFtcCBpbiB0aGUgcXVlcnlcbiAgICAvLyB0aGVyZm9yZSB3ZSBkaXNhYmxlIGRhdGEgZmllbGRzIGZvciBzZXJ2aWNlcyB3aXRob3V0IHN0YW5kYXJkaXplZFF1ZXJ5IHN1cHBvcnRcbiAgICBsZXQgZGF0ZVZhbHVlID0gZ2V0RGF0ZU9iamVjdCh2YWx1ZSk7XG4gICAgbGV0IGRhdGVWYWx1ZTIgPSBnZXREYXRlT2JqZWN0KHZhbHVlMik7XG4gICAgLyogY29uc3QgZGF0ZVZhbHVlcyA9XG4gICAgICB2YWx1ZXMgJiZcbiAgICAgIHZhbHVlcy5tYXAoKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBEYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlKGdldERhdGVPYmplY3QodmFsdWUpKTtcbiAgICAgIH0pOyAqL1xuICAgIGNvbnN0IHRtc3RtcCA9ICFwcm9wcy5zdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5ID8gXCJcIiA6IFwidGltZXN0YW1wIFwiO1xuICAgIGNvbnN0IGRhdGVTdHIgPSBmb3JtYXREYXRlKGRhdGVWYWx1ZSk7XG4gICAgY29uc3QgZGF0ZVBsdXNPbmVTdHIgPSBmb3JtYXREYXRlKGFkZERheShkYXRlVmFsdWUpKTtcbiAgICBjb25zdCBkYXRlMlBsdXNPbmVTdHIgPSBmb3JtYXREYXRlKGFkZERheShkYXRlVmFsdWUyKSk7XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gQkVUV0VFTiAke3Rtc3RtcH0nJHtkYXRlU3RyfScgQU5EICR7dG1zdG1wfScke2RhdGVQbHVzT25lU3RyfSdgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RPbjpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IE5PVCBCRVRXRUVOICR7dG1zdG1wfScke2RhdGVTdHJ9JyBBTkQgJHt0bXN0bXB9JyR7ZGF0ZVBsdXNPbmVTdHJ9J2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JlZm9yZTpcbiAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IDwgJHt0bXN0bXB9JyR7ZGF0ZVN0cn0nYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXI6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSA+ICR7dG1zdG1wfScke2RhdGVQbHVzT25lU3RyfSdgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySW5UaGVMYXN0OlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gQkVUV0VFTiAke2NyZWF0ZUluVGhlTGFzdFF1ZXJ5UGFydChwcm9wcywgdmFsdWUsIHVuaXQpfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JOb3RJblRoZUxhc3Q6XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBOT1QgQkVUV0VFTiAke2NyZWF0ZUluVGhlTGFzdFF1ZXJ5UGFydChwcm9wcywgdmFsdWUsIHVuaXQpfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICAgIHdoZXJlQ2xhdXNlID0gYCR7ZmllbGROYW1lfSBCRVRXRUVOICR7dG1zdG1wfScke2RhdGVTdHJ9JyBBTkQgJHt0bXN0bXB9JyR7ZGF0ZTJQbHVzT25lU3RyfSdgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RCZXR3ZWVuOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gTk9UIEJFVFdFRU4gJHt0bXN0bXB9JyR7ZGF0ZVN0cn0nIEFORCAke3Rtc3RtcH0nJHtkYXRlMlBsdXNPbmVTdHJ9J2A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLyogY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJbmNsdWRlczpcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9yRXhjbHVkZXM6XG4gICAgICAgIGxldCBkYXRlVmFsdWVzU3RyaW5nID0gXCJcIjtcbiAgICAgICAgbGV0IGNvbW1hID0gXCJcIjtcbiAgICAgICAgZGF0ZVZhbHVlcy5mb3JFYWNoKChkYXRlVmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGRhdGVWYWx1ZXNTdHJpbmcgKz0gYCR7Y29tbWF9JHt0bXN0bXB9JyR7ZGF0ZVZhbHVlfSdgO1xuICAgICAgICAgIGNvbW1hID0gXCIsXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09IHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvckluY2x1ZGVzKSB7XG4gICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IElOICgke2RhdGVWYWx1ZXNTdHJpbmd9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlcmVDbGF1c2UgPSBgJHtmaWVsZE5hbWV9IE5PVCBJTiAoJHtkYXRlVmFsdWVzU3RyaW5nfSlgO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAqL1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JsYW5rOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSVMgTlVMTGA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJsYW5rOlxuICAgICAgICB3aGVyZUNsYXVzZSA9IGAke2ZpZWxkTmFtZX0gSVMgTk9UIE5VTExgO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdoZXJlQ2xhdXNlO1xufVxuZnVuY3Rpb24gZ2V0RGF0ZU9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgLy8gdmFsdWUgaXMgYSBVVEMgdGltZXN0YW1wOyByZXR1cm5zIGEgZGF0ZSBvYmplY3QgaW4gbG9jYWwgdGltZVxuICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gZnJvbSBkYXRlIHBpY2tlci4uLlxuICAgIC8vIGUuZy4gXCI3LzcvMjAxMCAxMjowMDowMCBBTVwiIHJldHVybmVkIGJ5IGdlbmVyYXRlUmVuZGVyZXJcbiAgICAvLyBpbiBERSB2YWx1ZSBpcyBcIjAyLjAzLjEyXCIgZm9yIE1hcmNoIHNlY29uZDsgbmV3IERhdGUodmFsdWUpIHRoZW4gcmV0dXJucyBGZWIgM3JkXG4gICAgLy8gICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIHJldHVybiBwYXJzZUZyaWVuZGx5RGF0ZSh2YWx1ZSk7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAvLyBEYXRlIG9iamVjdDsgaW4gbG9jYWwgdGltZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIC8vIHNlcnZpY2UgbmVlZHMgVVRDIHRpbWUsIGJ1dCB0aGUgdXNlciBsb29rcyBhdCBsb2NhbCB0aW1lIGluIHRoZSBVSVxuICAvLyBkYXRlIGlzIGluIGxvY2FsIHRpbWVcbiAgLy8gcmV0dXJucyB0aGUgc3RyaW5nIGluIFVUQyB0aW1lXG4gIC8vIGUuZy4gMjAxNy0wNy0wNyAwOTowNToxOVxuICBpZiAoIWRhdGUpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCB5ZWFyU3RyID0gYCR7ZGF0ZS5nZXRVVENGdWxsWWVhcigpfWA7XG4gIGxldCBtb250aFN0ciA9IGAke2RhdGUuZ2V0VVRDTW9udGgoKSArIDF9YDtcbiAgaWYgKG1vbnRoU3RyLmxlbmd0aCA9PT0gMSkge1xuICAgIG1vbnRoU3RyID0gYDAke21vbnRoU3RyfWA7XG4gIH1cbiAgbGV0IGRhdGVTdHIgPSBgJHtkYXRlLmdldFVUQ0RhdGUoKX1gO1xuICBpZiAoZGF0ZVN0ci5sZW5ndGggPT09IDEpIHtcbiAgICBkYXRlU3RyID0gYDAke2RhdGVTdHJ9YDtcbiAgfVxuICBsZXQgaG91cnNTdHIgPSBgJHtkYXRlLmdldFVUQ0hvdXJzKCl9YDtcbiAgaWYgKGhvdXJzU3RyLmxlbmd0aCA9PT0gMSkge1xuICAgIGhvdXJzU3RyID0gYDAke2hvdXJzU3RyfWA7XG4gIH1cbiAgbGV0IG1pblN0ciA9IGAke2RhdGUuZ2V0VVRDTWludXRlcygpfWA7XG4gIGlmIChtaW5TdHIubGVuZ3RoID09PSAxKSB7XG4gICAgbWluU3RyID0gYDAke21pblN0cn1gO1xuICB9XG4gIGxldCBzZWNTdHIgPSBgJHtkYXRlLmdldFNlY29uZHMoKX1gO1xuICBpZiAoc2VjU3RyLmxlbmd0aCA9PT0gMSkge1xuICAgIHNlY1N0ciA9IGAwJHtzZWNTdHJ9YDtcbiAgfVxuICByZXR1cm4gYCR7eWVhclN0cn0tJHttb250aFN0cn0tJHtkYXRlU3RyfSAke2hvdXJzU3RyfToke21pblN0cn06JHtzZWNTdHJ9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluVGhlTGFzdFF1ZXJ5UGFydChwcm9wcywgdmFsdWUsIHVuaXQpIHtcbiAgaWYgKHByb3BzLnN1cHBvcnRlZFNxbFBhcnNlclZlcnNpb24pIHtcbiAgICBsZXQgZGF5cyA9IDA7XG4gICAgaWYgKHVuaXQgPT09IFwieWVhclwiKSB7XG4gICAgICAvLyBub3QgYWNjdXJhdGUgLi4uXG4gICAgICBkYXlzID0gdmFsdWUgKiAzNjU7XG4gICAgICByZXR1cm4gYENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgJyR7ZGF5c30nIERBWSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBgO1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ID09PSBcIm1vbnRoXCIpIHtcbiAgICAgIC8vIG5vdCBhY2N1cmF0ZSAuLi5cbiAgICAgIGRheXMgPSB2YWx1ZSAqIDMwO1xuICAgICAgcmV0dXJuIGBDVVJSRU5UX1RJTUVTVEFNUCAtIElOVEVSVkFMICcke2RheXN9JyBEQVkgQU5EIENVUlJFTlRfVElNRVNUQU1QYDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCA9PT0gXCJ3ZWVrXCIpIHtcbiAgICAgIGRheXMgPSB2YWx1ZSAqIDc7XG4gICAgICByZXR1cm4gYENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgJyR7ZGF5c30nIERBWSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBgO1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ID09PSBcImRheVwiKSB7XG4gICAgICBkYXlzID0gdmFsdWU7XG4gICAgICByZXR1cm4gYENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgJyR7ZGF5c30nIERBWSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBgO1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ID09PSBcImhvdXJcIikge1xuICAgICAgcmV0dXJuIGBDVVJSRU5UX1RJTUVTVEFNUCAtIElOVEVSVkFMICcke3ZhbHVlfScgSE9VUiBBTkQgQ1VSUkVOVF9USU1FU1RBTVBgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIG1pbnV0ZXNcbiAgICAgIHJldHVybiBgQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCAnJHt2YWx1ZX0nIE1JTlVURSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBgO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBsZXQgZGF5cyA9IDA7XG4gICAgaWYgKHVuaXQgPT09IFwieWVhclwiKSB7XG4gICAgICAvLyBub3QgYWNjdXJhdGUgLi4uXG4gICAgICBkYXlzID0gdmFsdWUgKiAzNjU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuaXQgPT09IFwibW9udGhcIikge1xuICAgICAgLy8gbm90IGFjY3VyYXRlIC4uLlxuICAgICAgZGF5cyA9IHZhbHVlICogMzA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuaXQgPT09IFwid2Vla1wiKSB7XG4gICAgICBkYXlzID0gdmFsdWUgKiA3O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ID09PSBcImRheVwiKSB7XG4gICAgICBkYXlzID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuaXQgPT09IFwiaG91clwiKSB7XG4gICAgICBkYXlzID0gdmFsdWUgLyAyNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBtaW51dGVcbiAgICAgIGRheXMgPSB2YWx1ZSAvICgyNCAqIDYwKTtcbiAgICB9XG4gICAgcmV0dXJuIGBDVVJSRU5UX1RJTUVTVEFNUCAtICR7ZGF5c30gQU5EIENVUlJFTlRfVElNRVNUQU1QYDtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VGcmllbmRseURhdGUodmFsdWUpIHtcbiAgLy8gZW46IDMvMi8xNSBkZTogMDIuMDMuMTUgLSBmb3IgbWFyY2ggc2Vjb25kXG4gIC8qIHJldHVybiBsb2NhbGUucGFyc2UodmFsdWUsIHtcbiAgICBmb3JtYXRMZW5ndGg6IFwic2hvcnRcIixcbiAgICBzZWxlY3RvcjogXCJkYXRlXCJcbiAgfSk7ICovXG4gIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYXJzZURhdGUoc3RyVmFsdWUpIHtcbiAgLy8gc3RyVmFsdWUgaXMgaW4gVVRDIHRpbWUsIGJ1dCB0aGUgdXNlciBsb29rcyBhdCBsb2NhbCB0aW1lIGluIHRoZSBVSVxuICAvLyB3ZSBrbm93IHN0clZhbHVlIGxvb2tzIGxpa2UgdGhpcyAneXl5eS1NTS1kZCBISDptbTpzcycgKGUuZy4gJzIwMTMtMDMtMDEgMDA6MDA6MDAnKVxuICAvKlxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoTnVtYmVyKHN0clZhbHVlLnN1YnN0cmluZygwLCA0KSkpO1xuICBkYXRlLnNldFVUQ01vbnRoKHBhcnNlSW50KHN0clZhbHVlLnN1YnN0cmluZyg1LCA3KSkgLSAxKTtcbiAgZGF0ZS5zZXRVVENEYXRlKE51bWJlcihzdHJWYWx1ZS5zdWJzdHJpbmcoOCwgMTApKSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoTnVtYmVyKHN0clZhbHVlLnN1YnN0cmluZygxMSwgMTMpKSk7XG4gIGRhdGUuc2V0VVRDTWludXRlcyhOdW1iZXIoc3RyVmFsdWUuc3Vic3RyaW5nKDE0LCAxNikpKTtcbiAgZGF0ZS5zZXRTZWNvbmRzKE51bWJlcihzdHJWYWx1ZS5zdWJzdHJpbmcoMTcsIDE5KSkpO1xuICByZXR1cm4gZGF0ZTtcbiAgKi9cbiAgbGV0IGRhdGUgPSBuZXcgRGF0ZShzdHJWYWx1ZSk7XG4gIGxldCB1dGNEYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCk7XG4gIC8vY29uc29sZS5sb2coXCJwYXJzZURhdGVcIiwgc3RyVmFsdWUsIFwiIC0gXCIsIHV0Y0RhdGUpO1xuICByZXR1cm4gdXRjRGF0ZTtcbn1cbmZ1bmN0aW9uIGFkZERheShkYXRlKSB7XG4gIGlmIChkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZGF5SW5NUyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RGF5KGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpIC0gZGF5SW5NUyk7XG59XG5mdW5jdGlvbiBjb250YWluc05vbkxhdGluQ2hhcmFjdGVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2YWx1ZS5jaGFyQ29kZUF0KGkpID4gMjU1KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vL2ltcG9ydCAqIGFzIFdoZXJlQ2xhdXNlIGZyb20gXCJlc3JpL2NvcmUvc3FsL1doZXJlQ2xhdXNlXCI7XG4vL2NvbnN0IGRheUluTVM6IG51bWJlciA9IDI0ICogNjAgKiA2MCAqIDEwMDAgLSAxMDAwOyAvLyAxIHNlYyBsZXNzIHRoYW4gMSBkYXlcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlV2hlcmVDbGF1c2Uod2hlcmVDbGF1c2UsIHByb3BzKSB7XG4gIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAvLyBkb2VzIG5vdCBjYWxsIHJlamVjdCgpXG4gIGlmICghd2hlcmVDbGF1c2UgfHwgIXdoZXJlQ2xhdXNlLmxlbmd0aCkge1xuICAgIC8qIGNvbnN0IGRlZmF1bHRGaWVsZCA9IGdldERlZmF1bHRGaWVsZChzdGF0ZSk7XG4gICAgc3RhdGUuZXhwcmVzc2lvbnMgPSBbXG4gICAgICB7XG4gICAgICAgIGNvbmRpdGlvbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmaWVsZE5hbWU6IGRlZmF1bHRGaWVsZC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgICAgICBvcGVyYXRvcjogZ2V0RGVmYXVsdE9wZXJhdG9yKGRlZmF1bHRGaWVsZCksXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gICAgc3RhdGUuZXhwcmVzc2lvbnMgPSBmaXhVSURzKHN0YXRlLmV4cHJlc3Npb25zKTsgKi9cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb25zdCBbZXNyaVNRTF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2NvcmUvc3FsXCJdKTtcbiAgICAvLyBJbWFnZXJ5TGF5ZXIgaGFzIGZpZWxkc0luZGV4IHRvbywgaXQncyBub3QgZG9jdW1lbnRlZCB5ZXQuIENhc3RpbmcgYXMgYW55IGZvciBub3cuXG4gICAgcmV0dXJuIGVzcmlTUUwucGFyc2VXaGVyZUNsYXVzZSh3aGVyZUNsYXVzZSwgbGF5ZXIuZmllbGRzSW5kZXgpLnRoZW4oKGNsYXVzZSAvKiBXaGVyZUNsYXVzZSAqLykgPT4ge1xuICAgICAgaWYgKCFjbGF1c2UuaXNTdGFuZGFyZGl6ZWQpIHtcbiAgICAgICAgLy8gdXNlcyBzb21lIG5vbiBzdGFuZGFyZCBmdW5jdGlvbnMuIGludmFsaWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBjb25kaXRpb25zOiBbXVxuICAgICAgICB9XG4gICAgICBdO1xuICAgICAgY29uc3Qgc3VjY2VzcyA9IHBhcnNlQ2xhdXNlKGNsYXVzZS5wYXJzZVRyZWUsIHByb3BzKTtcbiAgICAgIHByb3BzLmV4cHJlc3Npb25zID0gZml4VUlEcyhwcm9wcy5leHByZXNzaW9ucyk7XG4gICAgICAvKlxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIlNRTFBhcnNlcjpcIixcbiAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgIHdoZXJlQ2xhdXNlLFxuICAgICAgICAgIGNsYXVzZSxcbiAgICAgICAgICBwcm9wcy5sb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucyxcbiAgICAgICAgICBwcm9wcy5leHByZXNzaW9uc1xuICAgICAgICApO1xuICAgICAgKi9cbiAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIlNRTFBhcnNlciAtIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQ2xhdXNlKHBhcnNlVHJlZSwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcy5leHByZXNzaW9ucykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNDb25kaXRpb24ocGFyc2VUcmVlKSkge1xuICAgIHJldHVybiBwYXJzZUJpbmFyeUV4cHIocGFyc2VUcmVlLCBwcm9wcy5leHByZXNzaW9uc1swXS5jb25kaXRpb25zLCBwcm9wcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcHJvcHMubG9naWNhbE9wZXJhdG9yRm9yRXhwcmVzc2lvbnMgPSBnZXRMb2dpY2FsT3BlcmF0b3IocGFyc2VUcmVlKTtcbiAgICByZXR1cm4gcGFyc2VCaW5hcnlFeHByKHBhcnNlVHJlZSwgcHJvcHMuZXhwcmVzc2lvbnNbMF0sIHByb3BzKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VCaW5hcnlFeHByKG9iaiwgc3RhdGVPYmosIHByb3BzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgLy8gbGVmdCwgb3BlcmF0b3IsIHJpZ2h0LCB0eXBlXG4gIGlmIChpc0NvbmRpdGlvbihvYmopKSB7XG4gICAgLy8gc3RhdGVPYmogaXMgbGlzdCBvZiBjb25kaXRpb25zXG4gICAgaWYgKG9iai5sZWZ0LnR5cGUgPT09IFwiY29sdW1uLXJlZmVyZW5jZVwiKSB7XG4gICAgICBjb25zdCBmaWVsZE9iamVjdCA9IGdldEZpZWxkSW5mbyhvYmoubGVmdC5jb2x1bW4sIHByb3BzKTtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gZmllbGRPYmplY3QgPyBnZXRPcGVyYXRvcihwcm9wcywgb2JqLm9wZXJhdG9yLCBmaWVsZE9iamVjdCwgb2JqLnJpZ2h0KSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChmaWVsZE9iamVjdCAmJiBvcGVyYXRvcikge1xuICAgICAgICBsZXQgY29uZGl0aW9uO1xuICAgICAgICBpZiAob2JqLnJpZ2h0LnR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgLy8gSVMgTlVMTCAvIElTIE5PVCBOVUxMXG4gICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE9iamVjdC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5yaWdodC50eXBlID09PSBcImNvbHVtbi1yZWZlcmVuY2VcIikge1xuICAgICAgICAgIC8vIHdlIG5vIGxvbmdlciBzdXBwb3J0IGZpZWxkIHRvIGZpZWxkIGZpbHRlcnNcbiAgICAgICAgICAvLyAtPiBlcnJvclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoucmlnaHQudHlwZSA9PT0gXCJleHByZXNzaW9uLWxpc3RcIiAmJiBpc0xpc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgLy8gSU4sIE5PVCBJTlxuICAgICAgICAgIGNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICB2YWx1ZXM6IG9iai5yaWdodC52YWx1ZS5tYXAoKHZhbCkgPT4gdmFsLnZhbHVlKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLnJpZ2h0LnR5cGUgPT09IFwiZXhwcmVzc2lvbi1saXN0XCIgJiYgaXNJblRoZUxhc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgLy8gd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSA8ZGF5cz4gQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgICAgLy8gd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCA8ZGF5cz4gREFZIEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiO1xuICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPGhvdXJzPiBIT1VSIEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiO1xuICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPG1pbnV0ZXM+IE1JTlVURSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZUluVGhlTGFzdChvYmopO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgdW5pdDogcmVzdWx0LnVuaXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5yaWdodC50eXBlID09PSBcImV4cHJlc3Npb24tbGlzdFwiICYmIGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAvLyBCRVRXRUVOLCBOT1QgQkVUV0VFTlxuICAgICAgICAgIGlmIChpc0RhdGVUeXBlKGZpZWxkT2JqZWN0KSkge1xuICAgICAgICAgICAgLy8gdmFsdWU6IFwiMjAwMC0wOS0xNCAwNjoyNjozNlwiXG4gICAgICAgICAgICBjb25zdCBkYXRlMSA9IHBhcnNlRGF0ZShvYmoucmlnaHQudmFsdWVbMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgZGF0ZTIgPSBwYXJzZURhdGUob2JqLnJpZ2h0LnZhbHVlWzFdLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUyU3ViID0gc3VidHJhY3REYXkoZGF0ZTIpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRhdGUyU3ViLmdldFRpbWUoKSAtIGRhdGUxLmdldFRpbWUoKSkgPCAxMDAwKSB7XG4gICAgICAgICAgICAgIC8vIHdpdGhpbiAxIGRheVxuICAgICAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE9iamVjdC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW5cbiAgICAgICAgICAgICAgICAgID8gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNPblxuICAgICAgICAgICAgICAgICAgOiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdE9uLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRlMS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE9iamVjdC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRhdGUxLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTI6IGRhdGUyLmdldFRpbWUoKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0RhdGVPbmx5VHlwZShmaWVsZE9iamVjdCkpIHtcbiAgICAgICAgICAgIC8vIHZhbHVlOiBcIjIwMDAtMDktMTRcIlxuICAgICAgICAgICAgY29uc3QgZGF0ZTEgPSBwYXJzZURhdGUob2JqLnJpZ2h0LnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUyID0gcGFyc2VEYXRlKG9iai5yaWdodC52YWx1ZVsxXS52YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRlMS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgLy8gdGhlIHBhcnNlciBhbHJlYWR5IHN1YnN0cmFjdHMgdGhlIG9mZnNldCB0byBsb2NhbCB0aW1lXG4gICAgICAgICAgICAgIHZhbHVlOiBkYXRlMS5nZXRUaW1lKCkgKyAyICogb2Zmc2V0LFxuICAgICAgICAgICAgICB2YWx1ZTI6IGRhdGUyLmdldFRpbWUoKSArIDIgKiBvZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkT2JqZWN0LmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBvYmoucmlnaHQudmFsdWVbMF0udmFsdWUsXG4gICAgICAgICAgICAgIHZhbHVlMjogb2JqLnJpZ2h0LnZhbHVlWzFdLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoucmlnaHQudHlwZSA9PT0gXCJ0aW1lc3RhbXBcIikge1xuICAgICAgICAgIGNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VEYXRlKG9iai5yaWdodC52YWx1ZSkuZ2V0VGltZSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoucmlnaHQudHlwZSA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICBpZiAoZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWSkge1xuICAgICAgICAgICAgLy8gY29udmVydCBkYXRlIHN0cmluZyB0byBVTklYIHRpbWVzdGFtcCAod2l0aG91dCB0aW1lc3RhbXAgb2Zmc2V0IHNoaWZ0KVxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHBhcnNlRGF0ZShvYmoucmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGRPYmplY3QubGF5ZXJGaWVsZC5uYW1lLFxuICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgLy8gdGhlIHBhcnNlciBhbHJlYWR5IHN1YnN0cmFjdHMgdGhlIG9mZnNldCB0byBsb2NhbCB0aW1lXG4gICAgICAgICAgICAgIHZhbHVlOiBkYXRlLmdldFRpbWUoKSArIDIgKiBvZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uZGl0aW9uID0ge1xuICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkT2JqZWN0LmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBwYXJzZURhdGUob2JqLnJpZ2h0LnZhbHVlKS5nZXRUaW1lKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHR5cGU6IFwic3RyaW5nXCIgfCBcIm51bWJlclwiIHwuLi5cbiAgICAgICAgICBjb25kaXRpb24gPSB7XG4gICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkT2JqZWN0LmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgdmFsdWU6IG9iai5yaWdodC52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVPYmoucHVzaChjb25kaXRpb24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGZpZWxkIG9yIG9wZXJhdG9yIG5vdCBmb3VuZFxuICAgICAgICAvLyAtPiBlcnJvclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIHN0YXRlT2JqIGlzIGV4cHJlc3Npb25cbiAgICBwcm9wcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zIHx8IFtdO1xuICAgIGxldCBzdWNjZXNzO1xuICAgIGlmIChpc0NvbmRpdGlvbihvYmoubGVmdCkgJiYgaXNDb25kaXRpb24ob2JqLnJpZ2h0KSkge1xuICAgICAgc3RhdGVPYmoubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IGdldExvZ2ljYWxPcGVyYXRvcihvYmopO1xuICAgICAgc3VjY2VzcyA9IHBhcnNlQmluYXJ5RXhwcihvYmoubGVmdCwgc3RhdGVPYmouY29uZGl0aW9ucywgcHJvcHMpO1xuICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgJiYgcGFyc2VCaW5hcnlFeHByKG9iai5yaWdodCwgc3RhdGVPYmouY29uZGl0aW9ucywgcHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0NvbmRpdGlvbihvYmoubGVmdCkpIHtcbiAgICAgIGlmIChvYmoub3BlcmF0b3IgPT09IG9iai5yaWdodC5vcGVyYXRvciAmJiBpc0NvbmRpdGlvbihvYmoucmlnaHQubGVmdCkgJiYgaXNDb25kaXRpb24ob2JqLnJpZ2h0LnJpZ2h0KSkge1xuICAgICAgICAvLyBzYW1lIGV4cHJlc3Npb25cbiAgICAgICAgc3RhdGVPYmoubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IGdldExvZ2ljYWxPcGVyYXRvcihvYmopO1xuICAgICAgICBzdWNjZXNzID0gcGFyc2VCaW5hcnlFeHByKG9iai5sZWZ0LCBzdGF0ZU9iai5jb25kaXRpb25zLCBwcm9wcyk7XG4gICAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIHBhcnNlQmluYXJ5RXhwcihvYmoucmlnaHQsIHN0YXRlT2JqLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gc3RhcnQgYSBuZXcgZXhwcmVzc2lvblxuICAgICAgICBzdWNjZXNzID0gcGFyc2VCaW5hcnlFeHByKG9iai5sZWZ0LCBzdGF0ZU9iai5jb25kaXRpb25zLCBwcm9wcyk7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB7XG4gICAgICAgICAgY29uZGl0aW9uczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgJiYgcGFyc2VCaW5hcnlFeHByKG9iai5yaWdodCwgZXhwcmVzc2lvbiwgcHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0NvbmRpdGlvbihvYmoucmlnaHQpKSB7XG4gICAgICBpZiAob2JqLm9wZXJhdG9yID09PSBvYmoubGVmdC5vcGVyYXRvciAmJlxuICAgICAgICBpc0NvbmRpdGlvbihvYmoubGVmdC5yaWdodCkgJiZcbiAgICAgICAgKGlzQ29uZGl0aW9uKG9iai5sZWZ0LmxlZnQpIHx8IG9iai5sZWZ0Lm9wZXJhdG9yID09PSAoKF9hID0gb2JqLmxlZnQubGVmdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZXJhdG9yKSkpIHtcbiAgICAgICAgLy8gc2FtZSBleHByZXNzaW9uXG4gICAgICAgIHN0YXRlT2JqLmxvZ2ljYWxPcGVyYXRvckZvckNvbmRpdGlvbnMgPSBnZXRMb2dpY2FsT3BlcmF0b3Iob2JqKTtcbiAgICAgICAgc3VjY2VzcyA9IHBhcnNlQmluYXJ5RXhwcihvYmoubGVmdCwgc3RhdGVPYmosIHByb3BzKTtcbiAgICAgICAgc3VjY2VzcyA9IHN1Y2Nlc3MgJiYgcGFyc2VCaW5hcnlFeHByKG9iai5yaWdodCwgc3RhdGVPYmouY29uZGl0aW9ucywgcHJvcHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHN0YXJ0IGEgbmV3IGV4cHJlc3Npb25cbiAgICAgICAgc3VjY2VzcyA9IHBhcnNlQmluYXJ5RXhwcihvYmoubGVmdCwgc3RhdGVPYmosIHByb3BzKTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHtcbiAgICAgICAgICBjb25kaXRpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwcm9wcy5leHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICBzdWNjZXNzID0gc3VjY2VzcyAmJiBwYXJzZUJpbmFyeUV4cHIob2JqLnJpZ2h0LCBleHByZXNzaW9uLmNvbmRpdGlvbnMsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBubyAnbGVhZidcbiAgICAgIGlmIChvYmoub3BlcmF0b3IgPT09IG9iai5yaWdodC5vcGVyYXRvciAmJiBvYmoub3BlcmF0b3IgPT09IG9iai5sZWZ0Lm9wZXJhdG9yKSB7XG4gICAgICAgIC8vIHNhbWUgZXhwcmVzc2lvblxuICAgICAgICBzdGF0ZU9iai5sb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zID0gZ2V0TG9naWNhbE9wZXJhdG9yKG9iaik7XG4gICAgICAgIHN1Y2Nlc3MgPSBwYXJzZUJpbmFyeUV4cHIob2JqLmxlZnQsIHN0YXRlT2JqLCBwcm9wcyk7XG4gICAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIHBhcnNlQmluYXJ5RXhwcihvYmoucmlnaHQsIHN0YXRlT2JqLCBwcm9wcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gc3RhcnQgbmV3IGV4cHJlc3Npb25zOyBmaXJzdCBvbmUgaXMgc3RpbGwgZW1wdHkuLi5cbiAgICAgICAgc3VjY2VzcyA9IHBhcnNlQmluYXJ5RXhwcihvYmoubGVmdCwgc3RhdGVPYmosIHByb3BzKTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHtcbiAgICAgICAgICBjb25kaXRpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwcm9wcy5leHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICBzdWNjZXNzID0gc3VjY2VzcyAmJiBwYXJzZUJpbmFyeUV4cHIob2JqLnJpZ2h0LCBleHByZXNzaW9uLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbmRpdGlvbihvYmopIHtcbiAgaWYgKG9iai50eXBlID09PSBcImJpbmFyeS1leHByZXNzaW9uXCIgJiYgKG9iai5vcGVyYXRvciA9PT0gXCJPUlwiIHx8IG9iai5vcGVyYXRvciA9PT0gXCJBTkRcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRMb2dpY2FsT3BlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmoub3BlcmF0b3IudG9VcHBlckNhc2UoKSA9PT0gXCJPUlwiID8gbG9naWNhbE9wZXJhdG9ycy5PUiA6IGxvZ2ljYWxPcGVyYXRvcnMuQU5EO1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yLCBmaWVsZE9iamVjdCwgb2JqUmlnaHQpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICBpZiAoIWZpZWxkT2JqZWN0KSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKGZpZWxkT2JqZWN0LnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkcpIHtcbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiPVwiOlxuICAgICAgICBpZiAob2JqUmlnaHQudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc0VtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiPD5cIjoge1xuICAgICAgICBpZiAob2JqUmlnaHQudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzTm90O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlIFwiTElLRVwiOlxuICAgICAgICBpZiAob2JqUmlnaHQudmFsdWUuc3RhcnRzV2l0aChcIiVcIikgJiYgb2JqUmlnaHQudmFsdWUuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgb2JqUmlnaHQudmFsdWUgPSBvYmpSaWdodC52YWx1ZS5zdWJzdHJpbmcoMSwgb2JqUmlnaHQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yQ29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqUmlnaHQudmFsdWUuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgb2JqUmlnaHQudmFsdWUgPSBvYmpSaWdodC52YWx1ZS5zdWJzdHJpbmcoMCwgb2JqUmlnaHQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yU3RhcnRzV2l0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmpSaWdodC52YWx1ZS5zdGFydHNXaXRoKFwiJVwiKSkge1xuICAgICAgICAgIG9ialJpZ2h0LnZhbHVlID0gb2JqUmlnaHQudmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckVuZHNXaXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiTk9UIExJS0VcIjpcbiAgICAgICAgaWYgKG9ialJpZ2h0LnZhbHVlLnN0YXJ0c1dpdGgoXCIlXCIpICYmIG9ialJpZ2h0LnZhbHVlLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgICAgIG9ialJpZ2h0LnZhbHVlID0gb2JqUmlnaHQudmFsdWUuc3Vic3RyaW5nKDEsIG9ialJpZ2h0LnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ialJpZ2h0LnZhbHVlLmVuZHNXaXRoKFwiJVwiKSkge1xuICAgICAgICAgIG9ialJpZ2h0LnZhbHVlID0gb2JqUmlnaHQudmFsdWUuc3Vic3RyaW5nKDAsIG9ialJpZ2h0LnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ialJpZ2h0LnZhbHVlLnN0YXJ0c1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgb2JqUmlnaHQudmFsdWUgPSBvYmpSaWdodC52YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9yRG9lc05vdENvbnRhaW47XG4gICAgICBjYXNlIFwiSVNcIjpcbiAgICAgICAgaWYgKG9ialJpZ2h0LnR5cGUgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNCbGFuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJcztcbiAgICAgIGNhc2UgXCJJU05PVFwiOlxuICAgICAgY2FzZSBcIklTIE5PVFwiOlxuICAgICAgICBpZiAob2JqUmlnaHQudHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdEJsYW5rO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvcklzO1xuICAgICAgY2FzZSBcIklOXCI6XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckluY2x1ZGVzO1xuICAgICAgY2FzZSBcIk5PVCBJTlwiOlxuICAgICAgY2FzZSBcIk5PVElOXCI6XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5zdHJpbmdPcGVyYXRvckV4Y2x1ZGVzO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChmaWVsZE9iamVjdC5zaW1wbGVGaWVsZFR5cGUgPT09IFwibnVtYmVyXCIgfHwgZmllbGRPYmplY3Quc2ltcGxlRmllbGRUeXBlID09PSBcIm9pZFwiKSB7XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM7XG4gICAgICBjYXNlIFwiPD5cIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3Q7XG4gICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdExlYXN0O1xuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNMZXNzVGhhbjtcbiAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdDtcbiAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzR3JlYXRlclRoYW47XG4gICAgICBjYXNlIFwiQkVUV0VFTlwiOlxuICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW47XG4gICAgICBjYXNlIFwiTk9UIEJFVFdFRU5cIjpcbiAgICAgIGNhc2UgXCJOT1RCRVRXRUVOXCI6XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90QmV0d2VlbjtcbiAgICAgIGNhc2UgXCJJU1wiOlxuICAgICAgICBpZiAob2JqUmlnaHQudHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JsYW5rO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzO1xuICAgICAgY2FzZSBcIklTTk9UXCI6XG4gICAgICBjYXNlIFwiSVMgTk9UXCI6XG4gICAgICAgIGlmIChvYmpSaWdodC50eXBlID09PSBcIm51bGxcIikge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90Qmxhbms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM7XG4gICAgICBjYXNlIFwiSU5cIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySW5jbHVkZXM7XG4gICAgICBjYXNlIFwiTk9UIElOXCI6XG4gICAgICBjYXNlIFwiTk9USU5cIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9yRXhjbHVkZXM7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGRhdGVcbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY3JlYXRlIHRoaXMgd2hlcmUgY2xhdXNlXG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc09uO1xuICAgICAgY2FzZSBcIjw+XCI6XG4gICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdE9uO1xuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlO1xuICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXI7XG4gICAgICBjYXNlIFwiQkVUV0VFTlwiOlxuICAgICAgICBpZiAoKChfYiA9IChfYSA9IG9ialJpZ2h0LnZhbHVlWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVmdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSBcImN1cnJlbnQtdGltZVwiKSB7XG4gICAgICAgICAgLy8gd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSA8ZGF5cz4gQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgICAgICAgLy8gd2hlcmVDbGF1c2UgPSBcIjxmaWVsZE5hbWU+IEJFVFdFRU4gQ1VSUkVOVF9USU1FU1RBTVAgLSBJTlRFUlZBTCA8ZGF5cz4gREFZIEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiO1xuICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPGhvdXJzPiBIT1VSIEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiO1xuICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPG1pbnV0ZXM+IE1JTlVURSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySW5UaGVMYXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0JldHdlZW47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJOT1QgQkVUV0VFTlwiOlxuICAgICAgY2FzZSBcIk5PVEJFVFdFRU5cIjpcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSBvYmpSaWdodC52YWx1ZVswXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlZnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50eXBlKSA9PT0gXCJjdXJyZW50LXRpbWVcIikge1xuICAgICAgICAgIC8vIHdoZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBOT1QgQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIDxkYXlzPiBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9yTm90SW5UaGVMYXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc05vdEJldHdlZW47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJJU1wiOlxuICAgICAgICBpZiAob2JqUmlnaHQudHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNCbGFuaztcbiAgICAgICAgfSAvLyBlbHNlIG5vdCBzdXBwb3J0ZWRcbiAgICAgIGNhc2UgXCJJU05PVFwiOlxuICAgICAgY2FzZSBcIklTIE5PVFwiOlxuICAgICAgICBpZiAob2JqUmlnaHQudHlwZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RCbGFuaztcbiAgICAgICAgfSAvLyBlbHNlIG5vdCBzdXBwb3J0ZWRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBwYXJzZUluVGhlTGFzdChvYmopIHtcbiAgY29uc3QgcmlnaHQgPSBvYmoucmlnaHQudmFsdWVbMF0ucmlnaHQ7XG4gIGxldCBjb3VudCA9IHJpZ2h0LnZhbHVlO1xuICBpZiAocmlnaHQudHlwZSA9PT0gXCJpbnRlcnZhbFwiKSB7XG4gICAgLy93aGVyZUNsYXVzZSA9IFwiPGZpZWxkTmFtZT4gQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIElOVEVSVkFMIDxkYXlzPiBEQVkgQU5EIENVUlJFTlRfVElNRVNUQU1QXCI7XG4gICAgLy93aGVyZUNsYXVzZSA9IFwiPGZpZWxkTmFtZT4gQkVUV0VFTiBDVVJSRU5UX1RJTUVTVEFNUCAtIElOVEVSVkFMIDxob3Vycz4gSE9VUiBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICAvL3doZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gSU5URVJWQUwgPG1pbnV0ZXM+IE1JTlVURSBBTkQgQ1VSUkVOVF9USU1FU1RBTVBcIjtcbiAgICBjb3VudCA9IHJpZ2h0LnZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgPyBwYXJzZUZsb2F0KHJpZ2h0LnZhbHVlLnZhbHVlKSA6IHJpZ2h0LnZhbHVlLnZhbHVlO1xuICAgIGlmIChyaWdodC5xdWFsaWZpZXIucGVyaW9kID09PSBcImRheVwiKSB7XG4gICAgICBpZiAoY291bnQgJSAzNjUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvdW50IC8gMzY1LCB1bml0OiBcInllYXJcIiB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY291bnQgJSAzMCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY291bnQgLyAzMCwgdW5pdDogXCJtb250aFwiIH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3VudCAlIDcgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvdW50IC8gNywgdW5pdDogXCJ3ZWVrXCIgfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvdW50ICUgMSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY291bnQsIHVuaXQ6IFwiZGF5XCIgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmlnaHQucXVhbGlmaWVyLnBlcmlvZCA9PT0gXCJob3VyXCIpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBjb3VudCwgdW5pdDogXCJob3VyXCIgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmlnaHQucXVhbGlmaWVyLnBlcmlvZCA9PT0gXCJtaW51dGVcIikge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvdW50LCB1bml0OiBcIm1pbnV0ZVwiIH07XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKCFpc05hTihjb3VudCkpIHtcbiAgICAvL3doZXJlQ2xhdXNlID0gXCI8ZmllbGROYW1lPiBCRVRXRUVOIENVUlJFTlRfVElNRVNUQU1QIC0gPGRheXM+IEFORCBDVVJSRU5UX1RJTUVTVEFNUFwiXG4gICAgaWYgKGNvdW50ICUgMzY1ID09PSAwKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogY291bnQgLyAzNjUsIHVuaXQ6IFwieWVhclwiIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvdW50ICUgMzAgPT09IDApIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBjb3VudCAvIDMwLCB1bml0OiBcIm1vbnRoXCIgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY291bnQgJSA3ID09PSAwKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogY291bnQgLyA3LCB1bml0OiBcIndlZWtcIiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjb3VudCAlIDEgPT09IDApIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBjb3VudCwgdW5pdDogXCJkYXlcIiB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKGNvdW50ICogMjQgKiA2MCk7XG4gICAgICBpZiAobWludXRlcyAlIDYwID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBNYXRoLnJvdW5kKGNvdW50ICogMjQpLCB1bml0OiBcImhvdXJcIiB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBtaW51dGVzLCB1bml0OiBcIm1pbnV0ZVwiIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmNvbnN0IGFyY2dpc0ZpbHRlckNzcyA9IFwiLnNjLWFyY2dpcy1maWx0ZXItaHtkaXNwbGF5OmZsZXg7ZmxleDoxIDEgYXV0bztvdmVyZmxvdzpoaWRkZW59LmZhYi1wYWRkaW5nLnNjLWFyY2dpcy1maWx0ZXJ7cGFkZGluZy1ib3R0b206MXJlbX0uaG9vay5zYy1hcmNnaXMtZmlsdGVye3dpZHRoOjEwMCU7aGVpZ2h0OjFweH0ucmVtb3ZlLWZpbHRlci5zYy1hcmNnaXMtZmlsdGVye21hcmdpbi1ib3R0b206NXB4O2JhY2tncm91bmQtY29sb3I6d2hpdGU7cGFkZGluZy1sZWZ0OjE1cHh9Lm1hdGNoLWV4cHJlc3Npb24tZHJvcGRvd24uc2MtYXJjZ2lzLWZpbHRlcnt3aWR0aDoxMDAlfS5tYXRjaC1leHByZXNzaW9uLW1zZy5zYy1hcmNnaXMtZmlsdGVye3BhZGRpbmc6MTJweDtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlfS5tYXRjaC10eXBlLnNjLWFyY2dpcy1maWx0ZXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjZweCAwfS5hcmNnaXMtLXJ0bC5zYy1hcmNnaXMtZmlsdGVyIC5yZW1vdmUtZmlsdGVyLnNjLWFyY2dpcy1maWx0ZXJ7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDoxNXB4fS5uby1zcGFjZS5zYy1hcmNnaXMtZmlsdGVyey0tY2FsY2l0ZS1sYWJlbC1tYXJnaW4tYm90dG9tOjB9XCI7XG5cbmNvbnN0IEFyY2dpc0ZpbHRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJXaGVyZUNoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyV2hlcmVDaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJTYXZlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNGaWx0ZXJTYXZlXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzRmlsdGVyQ2FuY2VsID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNGaWx0ZXJDYW5jZWxcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJEaXNtaXNzZWRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlckRpc21pc3NlZENoYW5nZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc0ZpbHRlckRvbmUgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlckRvbmVcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJQYW5lbEJhY2tDbGljayA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyUGFuZWxCYWNrQ2xpY2tcIiwgNyk7XG4gICAgdGhpcy5jbG9zZUZpbHRlclBvcG92ZXJzID0gY3JlYXRlRXZlbnQodGhpcywgXCJjbG9zZUZpbHRlclBvcG92ZXJzXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNoYW5nZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlckV4cHJlc3Npb25DaGFuZ2VkXCIsIDcpO1xuICAgIHRoaXMubGF5ZXJWaWV3V2FpdEhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMubGF5ZXJIYXNGZWF0dXJlRWZmZWN0ID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wZXJDbG9zZSA9IGZhbHNlO1xuICAgIHRoaXMuYXBwbHlGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BzLCBtb2RlIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeyBsYXllclZpZXcsIGxheWVyLCBsYWJlbENsYXNzSWR4LCBsYWJlbENsYXNzLCBvcmlnaW5hbExheWVyIH0gPSBwcm9wcztcbiAgICAgIHRoaXMuY2xvc2VGaWx0ZXJQb3BvdmVycy5lbWl0KCk7XG4gICAgICBpZiAoaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpIHx8IGlzRGVmaW5lZChsYWJlbENsYXNzKSkge1xuICAgICAgICAvLyB3ZSBwYXNzZWQgdGhlIHdoZXJlIGNsYXVzZSB3aGVuIGl0IGNoYW5nZWRcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJTYXZlLmVtaXQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1vZGUgPT09IFwibGF5ZXItdmlld1wiKSB7XG4gICAgICAgIGNvbnN0IHdoZXJlQ2xhdXNlID0gY3JlYXRlV2hlcmVDbGF1c2UocHJvcHMpO1xuICAgICAgICAvLyBrZWVwIGVmZmVjdCBvbiBsYXllclZpZXcgdG8gYXZvaWQgZmxpY2tlcmluZ1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlclNhdmUuZW1pdCh3aGVyZUNsYXVzZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtb2RlID09PSBcImVmZmVjdHNcIikgO1xuICAgICAgZWxzZSBpZiAobGF5ZXIpIHtcbiAgICAgICAgY29uc3Qgd2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZShwcm9wcyk7XG4gICAgICAgIChvcmlnaW5hbExheWVyIHx8IGxheWVyKS5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IHdoZXJlQ2xhdXNlO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZGVmaW5pdGlvbkV4cHJlc3Npb246XCIsIHdoZXJlQ2xhdXNlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNBbGxvd2VkRmVhdHVyZUVmZmVjdCgpKSB7XG4gICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGxheWVyVmlldyAmJiBcImZpbHRlclwiIGluIGxheWVyVmlldykge1xuICAgICAgICAgICAgbGF5ZXJWaWV3LmZpbHRlciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZUluZGV4ZXMocHJvcHMpO1xuICAgICAgICB0aGlzLnByb3BlckNsb3NlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJTYXZlLmVtaXQoKTtcbiAgICAgICAgLy8gc3dpdGNoZWQgdG8gZGVmaW5pdGlvbkV4cHJlc3Npb24gZnJvbSBlZmZlY3QvbGF5ZXJWaWV3LmZpbHRlclxuICAgICAgICB0aGlzLmNvbXBvbmVudFN0YXRlSW52YWxpZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNhbmNlbEZpbHRlciA9ICgpID0+IHtcbiAgICAgIHRoaXMucmV2ZXJ0RmlsdGVyKCk7XG4gICAgICB0aGlzLmNsb3NlRmlsdGVyUG9wb3ZlcnMuZW1pdCgpO1xuICAgICAgdGhpcy5wcm9wZXJDbG9zZSA9IHRydWU7XG4gICAgICB0aGlzLmFyY2dpc0ZpbHRlckNhbmNlbC5lbWl0KCk7XG4gICAgfTtcbiAgICB0aGlzLmNsb3NlRmlsdGVyID0gKCkgPT4ge1xuICAgICAgLy8gc2F2ZSBvbiBjbG9zZVxuICAgICAgdGhpcy5hcHBseUZpbHRlcigpO1xuICAgICAgdGhpcy5jbG9zZUZpbHRlclBvcG92ZXJzLmVtaXQoKTtcbiAgICAgIHRoaXMucHJvcGVyQ2xvc2UgPSB0cnVlO1xuICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJEaXNtaXNzZWRDaGFuZ2UuZW1pdCgpO1xuICAgIH07XG4gICAgdGhpcy5vbkFkZEV4cHJlc3Npb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeyBleHByZXNzaW9ucyB9ID0gcHJvcHM7XG4gICAgICBjb25zdCBkZWZhdWx0RmllbGQgPSBnZXREZWZhdWx0RmllbGQocHJvcHMpO1xuICAgICAgaWYgKCFkZWZhdWx0RmllbGQpIHtcbiAgICAgICAgLy8gbm90IHJlYWR5IHlldFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkZWZhdWx0T3BlcmF0b3IgPSBnZXREZWZhdWx0T3BlcmF0b3IocHJvcHMsIGRlZmF1bHRGaWVsZCk7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gZ2V0RGVmYXVsdFZhbHVlcyhwcm9wcywgZGVmYXVsdEZpZWxkLCBkZWZhdWx0T3BlcmF0b3IpO1xuICAgICAgY29uc3QgbmV3RXhwcmVzc2lvbiA9IHtcbiAgICAgICAgY29uZGl0aW9uczogW1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGZpZWxkTmFtZTogZGVmYXVsdEZpZWxkLmxheWVyRmllbGQubmFtZSwgb3BlcmF0b3I6IGRlZmF1bHRPcGVyYXRvciB9LCBkZWZhdWx0VmFsdWVzKSwgeyBoYXNGb2N1czogdHJ1ZSB9KVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9uc1xuICAgICAgICA/IGZpeFVJRHMoW1xuICAgICAgICAgIC4uLmV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwcmVzc2lvbiksIHsgY29uZGl0aW9uczogZXhwcmVzc2lvbi5jb25kaXRpb25zLm1hcCgoY29uZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmQpLCB7IGhhc0ZvY3VzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbmV3RXhwcmVzc2lvblxuICAgICAgICBdKVxuICAgICAgICA6IGZpeFVJRHMoW25ld0V4cHJlc3Npb25dKTtcbiAgICAgIGlmIChpc0RlZmluZWQoZGVmYXVsdFZhbHVlcy52YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ2hhbmdlZC5lbWl0KHsgdHlwZTogXCJyZXBsYWNlXCIsIGV4cHJlc3Npb246IG5ld0V4cHJlc3Npb24gfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfTtcbiAgICB0aGlzLm9uTWF0Y2hTZWxlY3QgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzZWxlY3QgPSBldmVudC50YXJnZXQ7XG4gICAgICBwcm9wcy5sb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucyA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi52YWx1ZTtcbiAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXJUb0xheWVyKCk7XG4gICAgfTtcbiAgICB0aGlzLm9uUmVtb3ZlRmlsdGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgIHByb3BzLmludmFsaWRGaWx0ZXIgPSBmYWxzZTtcbiAgICAgIHByb3BzLmV4cHJlc3Npb25zID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgdGhpcy5hcHBseUZpbHRlclRvTGF5ZXIoKTtcbiAgICB9O1xuICAgIHRoaXMuZm9jdXNCeUNsYXNzID0gKCkgPT4ge1xuICAgICAgLy8gc2V0IGZvY3VzIGJhY2sgZm9yIGtleWJvYXJkIHVzZXJzXG4gICAgICBjb25zdCBub2RlID0gdGhpcy5ob3N0RWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiYXJjZ2lzLWZpbHRlciAuYXV0b2ZvY3VzXCIpO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUuc3RhcnRzV2l0aChcIkNBTENJVEUtXCIpKSB7XG4gICAgICAgICAgbm9kZS5zZXRGb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5vZGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy52aWV3ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbENsYXNzSWR4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxDbGFzcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52aWV3RmlsdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZmVhdHVyZVJlZHVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpZGVMYXllclRpdGxlID0gZmFsc2U7XG4gICAgdGhpcy5wYW5lbEhlYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXBIZWFkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGlwTXNnID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW52YWxpZEhlYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZhbGlkTXNnID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubmV3QnV0dG9uTGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbGVhclRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kZWZhdWx0RmllbGROYW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGVmYXVsdE9wZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGVmYXVsdEV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICB0aGlzLmhpZGVCdXR0b25zID0gZmFsc2U7XG4gICAgdGhpcy5wYW5lbE1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRpc21pc3NpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlUmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5jb21wb25lbnRTdGF0ZUludmFsaWQgPSBmYWxzZTtcbiAgfVxuICBhcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ2hhbmdlSGFuZGxlcihldmVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZXhwcmVzc2lvbnMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICBpZiAoZGV0YWlsLnR5cGUgPT09IFwiY29weVwiKSB7XG4gICAgICAvLyByZXBsYWNlICsgY29weSBleHByZXNzaW9uXG4gICAgICBjb25zdCBleHByID0gZXZlbnQuZGV0YWlsLmV4cHJlc3Npb247XG4gICAgICBwcm9wcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvbikgPT4gKGV4cHJlc3Npb24udWlkID09PSBleHByLnVpZCA/IGV4cHIgOiBleHByZXNzaW9uKSAvL3sgLi4uZXhwcmVzc2lvbiB9XG4gICAgICApO1xuICAgICAgbGV0IGNvcHlFeHByZXNzaW9uO1xuICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucy5tYXAoKGV4cHJlc3Npb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwcmVzc2lvbiksIHsgY29uZGl0aW9uczogZXhwcmVzc2lvbi5jb25kaXRpb25zLm1hcCgoY29uZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZCksIHsgaGFzRm9jdXM6IGZhbHNlIH0pO1xuICAgICAgICAgIH0pIH0pO1xuICAgICAgfSk7XG4gICAgICBwcm9wcy5leHByZXNzaW9ucy5mb3JFYWNoKChleHByKSA9PiB7XG4gICAgICAgIGlmIChleHByLnVpZCA9PT0gZGV0YWlsLnVpZCkge1xuICAgICAgICAgIGNvcHlFeHByZXNzaW9uID0gdGhpcy5lc3JpTGFuZy5jbG9uZShPYmplY3QuYXNzaWduKHt9LCBleHByKSk7XG4gICAgICAgICAgY29weUV4cHJlc3Npb24uY29uZGl0aW9uc1swXS5oYXNGb2N1cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBmaXhVSURzKFsuLi5wcm9wcy5leHByZXNzaW9ucywgY29weUV4cHJlc3Npb25dKTtcbiAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGV0YWlsLnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgIC8vIGRlbGV0ZSBleHByZXNzaW9uXG4gICAgICBsZXQgcmVtb3ZlZElkeCA9IDA7XG4gICAgICBleHByZXNzaW9ucy5mb3JFYWNoKChleHByZXNzaW9uLCBpZHgpID0+IHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udWlkID09PSBkZXRhaWwudWlkKSB7XG4gICAgICAgICAgcmVtb3ZlZElkeCA9IGlkeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uLmNvbmRpdGlvbnMuZm9yRWFjaCgoY29uZCkgPT4gKGNvbmQuaGFzRm9jdXMgPSBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHByb3BzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMuZmlsdGVyKChleHByZXNzaW9uKSA9PiBleHByZXNzaW9uLnVpZCAhPT0gZGV0YWlsLnVpZCk7XG4gICAgICBpZiAoKF9hID0gcHJvcHMuZXhwcmVzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnNbTWF0aC5tYXgoMCwgcmVtb3ZlZElkeCAtIDEpXS5jb25kaXRpb25zWzBdLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBmaXhVSURzKFsuLi5wcm9wcy5leHByZXNzaW9uc10pO1xuICAgICAgICAvLyB3YWl0IHVudGlsIHJlbmRlcmluZyBpcyBkb25lXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mb2N1c0J5Q2xhc3MoKSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB3YWl0IHVudGlsIHJlbmRlcmluZyBpcyBkb25lXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mYWJOb2RlLnNldEZvY3VzKCksIDUwMCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdHlwZT1cInJlcGxhY2VcIlxuICAgICAgLy8gcmVwbGFjZSBleHByZXNzaW9uXG4gICAgICBjb25zdCByZXBsYWNlRXhwciA9IGV2ZW50LmRldGFpbC5leHByZXNzaW9uO1xuICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBwcm9wcy5leHByZXNzaW9ucy5tYXAoKGV4cHJlc3Npb24pID0+IGV4cHJlc3Npb24udWlkID09PSByZXBsYWNlRXhwci51aWQgPyBPYmplY3QuYXNzaWduKHt9LCByZXBsYWNlRXhwcikgOiBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgdGhpcy5hcHBseUZpbHRlclRvTGF5ZXIoKTtcbiAgfVxuICBkaXNhYmxlRmlsdGVyUGFuZWxIYW5kbGVyKGV2ZW50KSB7XG4gICAgdGhpcy5wYW5lbE5vZGUuZGlzYWJsZWQgPSBldmVudC5kZXRhaWw7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgcHVibGljIGNhbGxzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgdGhpcy5wYW5lbE5vZGUuc2V0Rm9jdXMoKTtcbiAgfVxuICBhc3luYyBkb25lKCkge1xuICAgIGlmICghdGhpcy5jb21wb25lbnRTdGF0ZUludmFsaWQpIHtcbiAgICAgIC8vIHNhdmUgb24gZG9uZVxuICAgICAgdGhpcy5hcHBseUZpbHRlcigpO1xuICAgICAgdGhpcy5jbG9zZUZpbHRlclBvcG92ZXJzLmVtaXQoKTtcbiAgICAgIHRoaXMucHJvcGVyQ2xvc2UgPSB0cnVlO1xuICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJEb25lLmVtaXQoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY2xvc2VQb3BvdmVycygpIHtcbiAgICB0aGlzLmNsb3NlRmlsdGVyUG9wb3ZlcnMuZW1pdCgpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIGNvbnN0IFtzdHJpbmdzLCBjdXJyZW50TGFuZ3VhZ2UsIGN1cnJlbnRMYW5ndWFnZUludGxdID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAvLyBidWlsZCBGaWx0ZXJQcm9wc1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICBleHByZXNzaW9uczogdW5kZWZpbmVkLFxuICAgICAgbG9naWNhbE9wZXJhdG9yRm9yRXhwcmVzc2lvbnM6IFwiYW5kXCIsXG4gICAgICBmaWVsZHM6IFtdLFxuICAgICAgb3BlcmF0b3JzOiB1bmRlZmluZWQsXG4gICAgICBpbnZhbGlkRmlsdGVyOiBmYWxzZSxcbiAgICAgIHN0cmluZ0ZpZWxkc0NvdW50OiAwLFxuICAgICAgZGF0ZUZpZWxkc0NvdW50OiAwLFxuICAgICAgbnVtYmVyRmllbGRzQ291bnQ6IDAsXG4gICAgICBpc0hvc3RlZDogZmFsc2UsXG4gICAgICBzdXBwb3J0c1N0YW5kYXJkaXplZFF1ZXJ5OiBmYWxzZSxcbiAgICAgIHN1cHBvcnRlZFNxbFBhcnNlclZlcnNpb246IGZhbHNlLFxuICAgICAgbGF5ZXI6IHt9LFxuICAgICAgdmlldzogdGhpcy52aWV3LFxuICAgICAgbGFiZWxDbGFzc0lkeDogdGhpcy5sYWJlbENsYXNzSWR4LFxuICAgICAgbGFiZWxDbGFzczogdGhpcy5sYWJlbENsYXNzLFxuICAgICAgZmVhdHVyZVJlZHVjdGlvbjogdGhpcy5mZWF0dXJlUmVkdWN0aW9uLFxuICAgICAgc3RyaW5ncyxcbiAgICAgIGxvY2FsZTogY3VycmVudExhbmd1YWdlLFxuICAgICAgbG9jYWxlSW50bDogY3VycmVudExhbmd1YWdlSW50bCxcbiAgICAgIGlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb246IG51bGwsXG4gICAgICBiYWNrZ3JvdW5kVGhlbWU6IFwibGlnaHRcIixcbiAgICAgIGxhc3RXaGVyZTogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdEZpZWxkTmFtZTogdGhpcy5kZWZhdWx0RmllbGROYW1lLFxuICAgICAgZGVmYXVsdE9wZXJhdG9yOiB0aGlzLmRlZmF1bHRPcGVyYXRvclxuICAgIH07XG4gICAgY29uc3QgW3JlYWN0aXZlVXRpbHMsIGNvbG9yVXRpbHMsIEltYWdlcnlMYXllciwgRmVhdHVyZUxheWVyLCBGZWF0dXJlRWZmZWN0LCBlc3JpTGFuZ10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICBcImVzcmkvY29yZS9yZWFjdGl2ZVV0aWxzXCIsXG4gICAgICBcImVzcmkvdmlld3Mvc3VwcG9ydC9jb2xvclV0aWxzXCIsXG4gICAgICBcImVzcmkvbGF5ZXJzL0ltYWdlcnlMYXllclwiLFxuICAgICAgXCJlc3JpL2xheWVycy9GZWF0dXJlTGF5ZXJcIixcbiAgICAgIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9GZWF0dXJlRWZmZWN0XCIsXG4gICAgICBcImVzcmkvY29yZS9sYW5nXCJcbiAgICBdKTtcbiAgICB0aGlzLnJlYWN0aXZlVXRpbHMgPSByZWFjdGl2ZVV0aWxzO1xuICAgIHRoaXMuY29sb3JVdGlscyA9IGNvbG9yVXRpbHM7XG4gICAgdGhpcy5JbWFnZXJ5TGF5ZXIgPSBJbWFnZXJ5TGF5ZXI7XG4gICAgdGhpcy5GZWF0dXJlTGF5ZXIgPSBGZWF0dXJlTGF5ZXI7XG4gICAgdGhpcy5GZWF0dXJlRWZmZWN0ID0gRmVhdHVyZUVmZmVjdDtcbiAgICB0aGlzLmVzcmlMYW5nID0gZXNyaUxhbmc7XG4gICAgY29uc3QgeyB2aWV3LCBsYXllciB9ID0gdGhpcztcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCBwcm9wTGF5ZXIgPSBsYXllcjsgLy8gaXNzdWUgd2l0aCB0eXBlIHByb3BcbiAgICBpZiAocHJvcExheWVyLmRlY2xhcmVkQ2xhc3MgPT09IFwiZXNyaS5sYXllcnMuc3VwcG9ydC5TdWJsYXllclwiKSB7XG4gICAgICAvLyBuZWVkIHRvIGNyZWF0ZSBhIEZlYXR1cmVMYXllclxuICAgICAgY29uc3QgbWFwSW1hZ2VTdWJsYXllciA9IHByb3BMYXllcjtcbiAgICAgIC8vZGVsZXRlIHRoaXMubGF5ZXI7XG4gICAgICB2aWV3ICYmIChhd2FpdCB0aGlzLnJlYWN0aXZlVXRpbHMud2hlbk9uY2UoKCkgPT4gIXZpZXcudXBkYXRpbmcpKTtcbiAgICAgIGNvbnN0IHN1YmxheWVyRkwgPSBhd2FpdCBtYXBJbWFnZVN1YmxheWVyLmNyZWF0ZUZlYXR1cmVMYXllcigpO1xuICAgICAgYXdhaXQgc3VibGF5ZXJGTC5sb2FkKCk7XG4gICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgbGF5ZXI6IHN1YmxheWVyRkwsIG1hcEltYWdlU3VibGF5ZXIgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BMYXllci50eXBlID09PSBcImltYWdlcnlcIiB8fCBwcm9wTGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBsYXllcjogcHJvcExheWVyIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghdmlldyB8fCAocHJvcExheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmIHByb3BMYXllci5pc1RhYmxlKSkge1xuICAgICAgLy8gd2UgbmVlZCBhIGxheWVyIHdpdGhvdXQgYSBmaWx0ZXIgZm9yIHN0YXRpc3RpY3MsIGhpc3RvZ3JhbSwgYW5kIHVuaXF1ZVZhbHVlc1xuICAgICAgbGV0IG5vbkZpbHRlcmVkTGF5ZXI7XG4gICAgICBub25GaWx0ZXJlZExheWVyID0gbmV3IHRoaXMuRmVhdHVyZUxheWVyKHtcbiAgICAgICAgdXJsOiBwcm9wTGF5ZXIudXJsLFxuICAgICAgICBsYXllcklkOiBwcm9wTGF5ZXIubGF5ZXJJZCxcbiAgICAgICAgcG9wdXBUZW1wbGF0ZTogcHJvcExheWVyLnBvcHVwVGVtcGxhdGVcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbm9uRmlsdGVyZWRMYXllci5sb2FkKCk7XG4gICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgbGF5ZXI6IG5vbkZpbHRlcmVkTGF5ZXIsIG9yaWdpbmFsTGF5ZXI6IHByb3BMYXllciB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgbGF5ZXI6IHByb3BMYXllciB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBsYWJlbENsYXNzSWR4LCBsYWJlbENsYXNzLCBmZWF0dXJlUmVkdWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGxhYmVsaW5nSW5mbyA9IGZlYXR1cmVSZWR1Y3Rpb25cbiAgICAgID8gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbi5sYWJlbGluZ0luZm9cbiAgICAgIDogbGF5ZXIubGFiZWxpbmdJbmZvO1xuICAgIGlmICgoaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpICYmICghbGFiZWxpbmdJbmZvIHx8ICFsYWJlbGluZ0luZm9bbGFiZWxDbGFzc0lkeF0pKSB8fFxuICAgICAgKGlzRGVmaW5lZChsYWJlbENsYXNzKSAmJiAoIWxhYmVsaW5nSW5mbyB8fCAhbGFiZWxpbmdJbmZvLmxlbmd0aCkpKSB7XG4gICAgICAvLyBlcnJvclxuICAgICAgY29uc29sZS5sb2coXCJjYW4ndCBmaW5kIGxhYmVsQ2xhc3NcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc0xheWVyKCk7XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwcm9wcywgZGVmYXVsdEV4cHJlc3Npb24gfSA9IHRoaXM7XG4gICAgaWYgKCEoKF9hID0gcHJvcHMuZXhwcmVzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICYmIGRlZmF1bHRFeHByZXNzaW9uKSB7XG4gICAgICB0aGlzLm9uQWRkRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5wYW5lbE5vZGUuc2V0Rm9jdXMoKSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMucHJvcGVyQ2xvc2UpIHtcbiAgICAgIC8vIHVzZXIgbGVmdCB0aGUgcGFuZWwgdmlhIFNhdmUsIENhbmNlbCwgb3IgQ2xvc2VcbiAgICAgIC8vIGp1c3QgY2xvc2UgcG9wb3ZlcnNcbiAgICAgIHRoaXMuY2xvc2VGaWx0ZXJQb3BvdmVycy5lbWl0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdXNlciBsZWZ0IHRoZSBwYW5lbCB3aXRob3V0IGNsaWNraW5nIG9uIFNhdmUsIENhbmNlbCwgb3IgQ2xvc2VcbiAgICAgIC8vIGUuZy4gYWxzbyBwYW5lbCBiYWNrIGJ1dHRvblxuICAgICAgdGhpcy5hcHBseUZpbHRlcigpO1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJsYXllci12aWV3XCIpIHtcbiAgICAgICAgY3JlYXRlSW5kZXhlcyh0aGlzLnByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlciBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIGhpZGVMYXllclRpdGxlLCBtb2RlLCBwYW5lbEhlYWRpbmcsIGNvbXBvbmVudFN0YXRlSW52YWxpZCwgZGlzbWlzc2libGUsIGhvc3RFbGVtZW50LCBwYW5lbE1heEhlaWdodCB9ID0gdGhpcztcbiAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKGhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBpbnZhbGlkRmlsdGVyLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCB0aXRsZSA9IG1hcEltYWdlU3VibGF5ZXIgPyBtYXBJbWFnZVN1YmxheWVyLnRpdGxlIDogbGF5ZXIudGl0bGU7XG4gICAgaWYgKGNvbXBvbmVudFN0YXRlSW52YWxpZCkge1xuICAgICAgLy8gd2UgcmVtb3ZlZCB0aGUgZWZmZWN0IGFuZCBjcmVhdGVkIGEgZGVmaW5pdGlvbkV4cHJlc3Npb25cbiAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiZGl2XCIsIG51bGwpKSk7XG4gICAgfVxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckxvYWRpbmcoKTtcbiAgICB9XG4gICAgaWYgKGludmFsaWRGaWx0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckludmFsaWRGaWx0ZXIoKTtcbiAgICB9XG4gICAgaWYgKGhvc3RFbGVtZW50LnBhcmVudEVsZW1lbnQudGFnTmFtZSA9PT0gXCJDQUxDSVRFLUZMT1dcIiB8fFxuICAgICAgaG9zdEVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1GTE9XXCIpIHtcbiAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBpZDogXCJmaWx0ZXItcGFuZWxcIiwgbG9hZGluZzogZmFsc2UsIGhlYWRpbmc6IHBhbmVsSGVhZGluZyB8fCBzdHJpbmdzLnRpdGxlLCBkZXNjcmlwdGlvbjogIWhpZGVMYXllclRpdGxlID8gdGl0bGUgOiB1bmRlZmluZWQsIGNsYXNzOiB7XG4gICAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgICB9LCBzdHlsZTogcGFuZWxNYXhIZWlnaHQgJiYgeyBtYXhIZWlnaHQ6IHBhbmVsTWF4SGVpZ2h0IH0sIGNsb3NhYmxlOiBkaXNtaXNzaWJsZSwgcmVmOiAobm9kZSkgPT4gKHRoaXMucGFuZWxOb2RlID0gbm9kZSksIG9uQ2FsY2l0ZUZsb3dJdGVtQmFjazogKCkgPT4ge1xuICAgICAgICAgIGlmIChtb2RlID09PSBcImxheWVyLXZpZXdcIikge1xuICAgICAgICAgICAgY29uc3Qgd2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZShwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlclBhbmVsQmFja0NsaWNrLmVtaXQod2hlcmVDbGF1c2UpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIGluZGV4ZXMgb24gZGlzY29ubmVjdCBjYWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJQYW5lbEJhY2tDbGljay5lbWl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvbkNhbGNpdGVGbG93SXRlbUNsb3NlOiAoKSA9PiB0aGlzLmNsb3NlRmlsdGVyKCkgfSwgdGhpcy5yZW5kZXJDb250ZW50KCkpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJjYWxjaXRlLXBhbmVsXCIsIHsgaWQ6IFwiZmlsdGVyLXBhbmVsXCIsIGxvYWRpbmc6IGZhbHNlLCBoZWFkaW5nOiBwYW5lbEhlYWRpbmcgfHwgc3RyaW5ncy50aXRsZSwgZGVzY3JpcHRpb246ICFoaWRlTGF5ZXJUaXRsZSA/IHRpdGxlIDogdW5kZWZpbmVkLCBjbGFzczoge1xuICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgICAgfSwgc3R5bGU6IHBhbmVsTWF4SGVpZ2h0ICYmIHsgbWF4SGVpZ2h0OiBwYW5lbE1heEhlaWdodCB9LCBjbG9zYWJsZTogZGlzbWlzc2libGUsIHJlZjogKG5vZGUpID0+ICh0aGlzLnBhbmVsTm9kZSA9IG5vZGUpLCBvbkNhbGNpdGVQYW5lbENsb3NlOiAoKSA9PiB0aGlzLmNsb3NlRmlsdGVyKCkgfSwgdGhpcy5yZW5kZXJDb250ZW50KCkpKSk7XG4gICAgfVxuICB9XG4gIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgY29uc3QgeyBwcm9wcywgbW9kZSwgaGlkZUJ1dHRvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYWJlbENsYXNzSWR4LCBsYWJlbENsYXNzIH0gPSBwcm9wcztcbiAgICBjb25zdCBpc0xhYmVsRmlsdGVyID0gaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpIHx8IGlzRGVmaW5lZChsYWJlbENsYXNzKTtcbiAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsICFpc0xhYmVsRmlsdGVyICYmIG1vZGUgIT09IFwibGF5ZXItdmlld1wiICYmICFoaWRlQnV0dG9ucyA/IHRoaXMucmVuZGVyU2F2ZUJ1dHRvbigpIDogbnVsbCwgIWlzTGFiZWxGaWx0ZXIgJiYgbW9kZSAhPT0gXCJsYXllci12aWV3XCIgJiYgIWhpZGVCdXR0b25zID8gdGhpcy5yZW5kZXJDYW5jZWxCdXR0b24oKSA6IG51bGwsIHRoaXMucmVuZGVyUG9wb3Zlckhvb2soKSwgdGhpcy5yZW5kZXJSZW1vdmVGaWx0ZXIoKSwgdGhpcy5yZW5kZXJNYXRjaEV4cHJlc3Npb25Nc2coKSwgdGhpcy5yZW5kZXJFeHByZXNzaW9ucygpLCB0aGlzLnJlbmRlckFkZEV4cHJlc3Npb24oKSwgdGhpcy5yZW5kZXJUaXAoKSkpO1xuICB9XG4gIHJlbmRlclNhdmVCdXR0b24oKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgc2xvdDogXCJmb290ZXJcIiwgb25DbGljazogdGhpcy5hcHBseUZpbHRlciwgYXBwZWFyYW5jZTogXCJzb2xpZFwiLCB3aWR0aDogXCJoYWxmXCIsIGxhYmVsOiBzdHJpbmdzLnNhdmUgfSwgc3RyaW5ncy5zYXZlKSk7XG4gIH1cbiAgcmVuZGVyQ2FuY2VsQnV0dG9uKCkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIG9uQ2xpY2s6IHRoaXMuY2FuY2VsRmlsdGVyLCBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCB3aWR0aDogXCJoYWxmXCIsIGxhYmVsOiBzdHJpbmdzLmNhbmNlbCB9LCBzdHJpbmdzLmNhbmNlbCkpO1xuICB9XG4gIHJlbmRlclBvcG92ZXJIb29rKCkge1xuICAgIHJldHVybiBoKFwiZGl2XCIsIHsgaWQ6IFwiYXJjZ2lzLWZpbHRlci1ob29rXCIsIGNsYXNzOiBDU1MkMy5ob29rIH0pO1xuICB9XG4gIHJlbmRlclJlbW92ZUZpbHRlcigpIHtcbiAgICBjb25zdCB7IHByb3BzLCBjbGVhclRleHQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzLCBleHByZXNzaW9ucyB9ID0gcHJvcHM7XG4gICAgaWYgKCFleHByZXNzaW9ucyB8fCAhZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQzLnJlbW92ZUZpbHRlciB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGNsYXNzOiBcIm5vLXNwYWNlXCIsIGxheW91dDogXCJpbmxpbmUtc3BhY2UtYmV0d2VlblwiLCBzY2FsZTogXCJtXCIgfSwgY2xlYXJUZXh0IHx8IHN0cmluZ3MucmVtb3ZlRmlsdGVyLCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyB0ZXh0OiBjbGVhclRleHQgfHwgc3RyaW5ncy5yZW1vdmVGaWx0ZXIsIHNjYWxlOiBcIm1cIiwgb25DbGljazogdGhpcy5vblJlbW92ZUZpbHRlciB9LCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgc2NhbGU6IFwic1wiLCBpY29uOiBcInRyYXNoXCIgfSkpKSkpO1xuICB9XG4gIHJlbmRlckxvYWRpbmcoKSB7XG4gICAgY29uc3QgeyBwcm9wcywgaGlkZUxheWVyVGl0bGUsIHBhbmVsSGVhZGluZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCB0aXRsZSA9IG1hcEltYWdlU3VibGF5ZXIgPyBtYXBJbWFnZVN1YmxheWVyLnRpdGxlIDogbGF5ZXIudGl0bGU7XG4gICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtcGFuZWxcIiwgeyBpZDogXCJmaWx0ZXItcGFuZWxcIiwgaGVhZGluZzogcGFuZWxIZWFkaW5nIHx8IHN0cmluZ3MudGl0bGUsIGRlc2NyaXB0aW9uOiAhaGlkZUxheWVyVGl0bGUgPyB0aXRsZSA6IHVuZGVmaW5lZCwgbG9hZGluZzogdHJ1ZSwgY2xhc3M6IHtcbiAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgIH0gfSkpKTtcbiAgfVxuICByZW5kZXJJbnZhbGlkRmlsdGVyKCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIGhpZGVMYXllclRpdGxlLCBkaXNtaXNzaWJsZSwgbW9kZSwgaGlkZUJ1dHRvbnMsIHBhbmVsSGVhZGluZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBsYWJlbENsYXNzSWR4LCBsYWJlbENsYXNzLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCB0aXRsZSA9IG1hcEltYWdlU3VibGF5ZXIgPyBtYXBJbWFnZVN1YmxheWVyLnRpdGxlIDogbGF5ZXIudGl0bGU7XG4gICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICBjb25zdCBpc0xhYmVsRmlsdGVyID0gaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpIHx8IGlzRGVmaW5lZChsYWJlbENsYXNzKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtcGFuZWxcIiwgeyBpZDogXCJmaWx0ZXItcGFuZWxcIiwgaGVhZGluZzogcGFuZWxIZWFkaW5nIHx8IHN0cmluZ3MudGl0bGUsIGRlc2NyaXB0aW9uOiAhaGlkZUxheWVyVGl0bGUgPyB0aXRsZSA6IHVuZGVmaW5lZCwgbG9hZGluZzogZmFsc2UsIGNsb3NhYmxlOiBkaXNtaXNzaWJsZSwgY2xhc3M6IHtcbiAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgIH0sIHJlZjogdGhpcy5mb2N1c0J5Q2xhc3MsIG9uQ2FsY2l0ZVBhbmVsQ2xvc2U6ICgpID0+IHRoaXMuY2xvc2VGaWx0ZXIoKSB9LCAhaXNMYWJlbEZpbHRlciAmJiBtb2RlICE9PSBcImxheWVyLXZpZXdcIiAmJiAhaGlkZUJ1dHRvbnMgPyB0aGlzLnJlbmRlclNhdmVCdXR0b24oKSA6IG51bGwsICFpc0xhYmVsRmlsdGVyICYmIG1vZGUgIT09IFwibGF5ZXItdmlld1wiICYmICFoaWRlQnV0dG9uc1xuICAgICAgPyB0aGlzLnJlbmRlckNhbmNlbEJ1dHRvbigpXG4gICAgICA6IG51bGwsIHRoaXMucmVuZGVySW52YWxpZEZpbHRlck1zZygpLCB0aGlzLnJlbmRlckNyZWF0ZU5ld0ZpbHRlcigpKSkpO1xuICB9XG4gIHJlbmRlckludmFsaWRGaWx0ZXJNc2coKSB7XG4gICAgLy8gaGVscElkID0gMTIwMDAxNzM2IGZvciBMZWFybk1vcmVcbiAgICBjb25zdCB7IGludmFsaWRIZWFkaW5nLCBpbnZhbGlkTXNnLCBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtdGlwXCIsIHsgaGVhZGluZzogaW52YWxpZEhlYWRpbmcgfHwgc3RyaW5ncy5lcnJvcnMucHJvYmxlbURpc3BsYXlpbmdGaWx0ZXIsIGNsb3NlRGlzYWJsZWQ6IHRydWUgfSwgaChcImRpdlwiLCBudWxsLCBpbnZhbGlkTXNnIHx8IHN0cmluZ3MuZXJyb3JzLnByb2JsZW1EaXNwbGF5aW5nRmlsdGVyTXNnKSkpO1xuICB9XG4gIHJlbmRlckNyZWF0ZU5ld0ZpbHRlcigpIHtcbiAgICBjb25zdCB7IHByb3BzLCBuZXdCdXR0b25MYWJlbCwgaGlkZUJ1dHRvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWZhYlwiLCB7IGNsYXNzOiB7XG4gICAgICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICAgICAgXCJmYWItcGFkZGluZ1wiOiBoaWRlQnV0dG9uc1xuICAgICAgfSwgc2xvdDogXCJmYWJcIiwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJuZXV0cmFsXCIsIHNjYWxlOiBcIm1cIiwgdGV4dEVuYWJsZWQ6IHRydWUsIGxhYmVsOiBuZXdCdXR0b25MYWJlbCB8fCBzdHJpbmdzLmNyZWF0ZU5ld0ZpbHRlciwgdGV4dDogbmV3QnV0dG9uTGFiZWwgfHwgc3RyaW5ncy5jcmVhdGVOZXdGaWx0ZXIsIG9uQ2xpY2s6IHRoaXMub25SZW1vdmVGaWx0ZXIgfSkpO1xuICB9XG4gIHJlbmRlck1hdGNoRXhwcmVzc2lvbk1zZygpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZXhwcmVzc2lvbnMsIGxvZ2ljYWxPcGVyYXRvckZvckV4cHJlc3Npb25zLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBpZiAoIWV4cHJlc3Npb25zIHx8ICFleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpc0FuZCA9IGxvZ2ljYWxPcGVyYXRvckZvckV4cHJlc3Npb25zID09PSBsb2dpY2FsT3BlcmF0b3JzLkFORDtcbiAgICByZXR1cm4gZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxID8gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDMubWF0Y2hFeHByZXNzaW9uTXNnIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwibVwiLCBjbGFzczogXCJuby1zcGFjZVwiIH0sIHN0cmluZ3Mub25lRXhwcmVzc2lvbk1zZykpKSA6IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQzLm1hdGNoRXhwcmVzc2lvbk1zZyB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGNsYXNzOiBcIm5vLXNwYWNlXCIsIHNjYWxlOiBcIm1cIiB9LCBzdHJpbmdzLm1hbnlFeHByZXNzaW9uc01zZywgaChcImNhbGNpdGUtc2VsZWN0XCIsIHsgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGxhYmVsOiBzdHJpbmdzLmFjY2Vzc2liaWxpdHkubWF0Y2hFeHByZXNzaW9ucywgY2xhc3M6IENTUyQzLm1hdGNoRXhwcmVzc2lvbkRyb3Bkb3duLCBvbkNhbGNpdGVTZWxlY3RDaGFuZ2U6IHRoaXMub25NYXRjaFNlbGVjdCB9LCBoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyB2YWx1ZTogbG9naWNhbE9wZXJhdG9ycy5BTkQsIGxhYmVsOiBzdHJpbmdzLm1hdGNoQWxsRXhwcmVzc2lvbnMsIHNlbGVjdGVkOiBpc0FuZCB9KSwgaChcImNhbGNpdGUtb3B0aW9uXCIsIHsgdmFsdWU6IGxvZ2ljYWxPcGVyYXRvcnMuT1IsIGxhYmVsOiBzdHJpbmdzLm1hdGNoQXRMZWFzdE9uZUV4cHJlc3Npb24sIHNlbGVjdGVkOiAhaXNBbmQgfSkpKSkpO1xuICB9XG4gIHJlbmRlckV4cHJlc3Npb25zKCkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBleHByZXNzaW9ucyB9ID0gcHJvcHM7XG4gICAgaWYgKCFleHByZXNzaW9ucyB8fCAhZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvblByb3BzLCBpZHgpID0+IHRoaXMucmVuZGVyRXhwcmVzc2lvbihleHByZXNzaW9uUHJvcHMsIGlkeCkpKSk7XG4gIH1cbiAgcmVuZGVyRXhwcmVzc2lvbihleHByZXNzaW9uUHJvcHMsIGV4cHJlc3Npb25JbmRleCkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIHRoaXMucmVuZGVyTG9naWNhbE9wZXJhdG9yRXhwcmVzc2lvbihleHByZXNzaW9uSW5kZXgpLCBoKFwiYXJjZ2lzLWZpbHRlci1leHByZXNzaW9uXCIsIE9iamVjdC5hc3NpZ24oeyBwcm9wczogcHJvcHMsIHJlZjogdGhpcy5mb2N1c0J5Q2xhc3MgfSwgZXhwcmVzc2lvblByb3BzKSkpKTtcbiAgfVxuICByZW5kZXJMb2dpY2FsT3BlcmF0b3JFeHByZXNzaW9uKGV4cHJlc3Npb25JbmRleCkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgaWYgKGV4cHJlc3Npb25JbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQzLmxvZ2ljYWxPcGVyYXRvciB9LCBoKFwic3BhblwiLCBudWxsLCBsb2dpY2FsT3BlcmF0b3JGb3JFeHByZXNzaW9ucyA9PT0gbG9naWNhbE9wZXJhdG9ycy5PUiA/IHN0cmluZ3Mub3IgOiBzdHJpbmdzLmFuZCkpKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyQWRkRXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCB7IHByb3BzLCBoaWRlQnV0dG9ucyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGV4cHJlc3Npb25zLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWZhYlwiLCB7IGNsYXNzOiB7XG4gICAgICAgIGF1dG9mb2N1czogIWV4cHJlc3Npb25zIHx8ICFleHByZXNzaW9ucy5sZW5ndGgsXG4gICAgICAgIFwiZmFiLXBhZGRpbmdcIjogaGlkZUJ1dHRvbnNcbiAgICAgIH0sIHNsb3Q6IFwiZmFiXCIsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBzY2FsZTogXCJtXCIsIGljb246IFwicGx1c1wiLCB0ZXh0RW5hYmxlZDogdHJ1ZSwgdGV4dDogc3RyaW5ncy5hZGRFeHByZXNzaW9uLCBvbkNsaWNrOiB0aGlzLm9uQWRkRXhwcmVzc2lvbiwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZmFiTm9kZSA9IG5vZGUpIH0pKTtcbiAgfVxuICByZW5kZXJUaXAoKSB7XG4gICAgY29uc3QgeyBwcm9wcywgbW9kZSwgdGlwSGVhZGluZywgdGlwTXNnIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbWFwSW1hZ2VTdWJsYXllciwgZXhwcmVzc2lvbnMsIGxhYmVsQ2xhc3NJZHgsIGxhYmVsQ2xhc3MsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGlmIChleHByZXNzaW9ucyA9PT0gbnVsbCB8fCBleHByZXNzaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZm9yTGFiZWxzID0gaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpIHx8IGlzRGVmaW5lZChsYWJlbENsYXNzKTtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXRpcFwiLCB7IGhlYWRpbmc6IHRpcEhlYWRpbmcgfHwgc3RyaW5ncy50aXBzLmVtcHR5TXNnVGl0bGUsIGNsb3NlRGlzYWJsZWQ6IHRydWUgfSwgaChcImRpdlwiLCBudWxsLCB0aXBNc2cgfHxcbiAgICAgIChmb3JMYWJlbHNcbiAgICAgICAgPyBzdHJpbmdzLnRpcHMuZW1wdHlNc2dMYWJlbHNcbiAgICAgICAgOiBtYXBJbWFnZVN1YmxheWVyIHx8IG1vZGUgPT09IFwibGF5ZXItdmlld1wiXG4gICAgICAgICAgPyBzdHJpbmdzLnRpcHMuZW1wdHlNc2dNU1xuICAgICAgICAgIDogc3RyaW5ncy50aXBzLmVtcHR5TXNnKSkpKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIHByb2Nlc3NMYXllcigpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwcm9wcywgbW9kZSwgdmlld0ZpbHRlciwgaGlkZUJ1dHRvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciwgb3JpZ2luYWxMYXllciwgdmlldywgbGFiZWxDbGFzc0lkeCwgbGFiZWxDbGFzcywgZmVhdHVyZVJlZHVjdGlvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgbGFiZWxpbmdJbmZvID0gbGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCIgJiZcbiAgICAgIChmZWF0dXJlUmVkdWN0aW9uXG4gICAgICAgID8gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbi5sYWJlbGluZ0luZm9cbiAgICAgICAgOiBsYXllci5sYWJlbGluZ0luZm8pO1xuICAgIGlmICh2aWV3ICYmXG4gICAgICAhbWFwSW1hZ2VTdWJsYXllciAmJlxuICAgICAgbGF5ZXIudHlwZSAhPT0gXCJpbWFnZXJ5XCIgJiZcbiAgICAgIGxheWVyLnR5cGUgIT09IFwic3VidHlwZS1ncm91cFwiICYmXG4gICAgICAhKGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmIGxheWVyLmlzVGFibGUpKSB7XG4gICAgICBwcm9wcy5sYXllclZpZXcgPSAoYXdhaXQgdmlldy53aGVuTGF5ZXJWaWV3KGxheWVyKSk7XG4gICAgfVxuICAgIGNoZWNrQ29uZmlnKHByb3BzKTtcbiAgICBhd2FpdCBidWlsZEZpbHRlckZpZWxkcyhwcm9wcyk7XG4gICAgYnVpbGRPcGVyYXRvcnNMaXN0KHByb3BzKTtcbiAgICBwcm9wcy5iYWNrZ3JvdW5kVGhlbWUgPSB2aWV3ICYmIChhd2FpdCB0aGlzLmNvbG9yVXRpbHMuZ2V0QmFja2dyb3VuZENvbG9yVGhlbWUodmlldykpO1xuICAgIHRoaXMubGF5ZXJIYXNGZWF0dXJlRWZmZWN0ID0gbGF5ZXIuZmVhdHVyZUVmZmVjdDtcbiAgICBpZiAoaXNEZWZpbmVkKGxhYmVsQ2xhc3NJZHgpICYmIGxhYmVsaW5nSW5mb1tsYWJlbENsYXNzSWR4XS53aGVyZSkge1xuICAgICAgcHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiA9IGxhYmVsaW5nSW5mb1tsYWJlbENsYXNzSWR4XS53aGVyZTtcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBwYXJzZVdoZXJlQ2xhdXNlKHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb24sIHByb3BzKTtcbiAgICAgIHByb3BzLmludmFsaWRGaWx0ZXIgPSAhc3VjY2VzcztcbiAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWZpbmVkKGxhYmVsQ2xhc3MpICYmIGxhYmVsQ2xhc3Mud2hlcmUpIHtcbiAgICAgIHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb24gPSBsYWJlbENsYXNzLndoZXJlO1xuICAgICAgcHJvcHMubGFzdFdoZXJlID0gcHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbjtcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBwYXJzZVdoZXJlQ2xhdXNlKHByb3BzLmlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb24sIHRoaXMucHJvcHMpO1xuICAgICAgcHJvcHMuaW52YWxpZEZpbHRlciA9ICFzdWNjZXNzO1xuICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2RlID09PSBcImxheWVyLXZpZXdcIikge1xuICAgICAgLy8ga2VlcCBkZWZpbml0aW9uRXhwcmVzc2lvbiBvbiBGTCwgdGhlIG5ldyBmaWx0ZXIgaXMgYW4gYWRkLW9uXG4gICAgICBpZiAodmlld0ZpbHRlcikge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgcGFyc2VXaGVyZUNsYXVzZSh2aWV3RmlsdGVyLCBwcm9wcyk7XG4gICAgICAgIHByb3BzLmludmFsaWRGaWx0ZXIgPSAhc3VjY2VzcztcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyVG9MYXllcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZGUgPT09IFwiZWZmZWN0c1wiKSB7XG4gICAgICBwcm9wcy5pbnZhbGlkRmlsdGVyID0gZmFsc2U7XG4gICAgICBpZiAobGF5ZXIuZmVhdHVyZUVmZmVjdCkge1xuICAgICAgICBwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uID0gKF9hID0gbGF5ZXIuZmVhdHVyZUVmZmVjdC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aGVyZTtcbiAgICAgICAgcHJvcHMubGFzdFdoZXJlID0gcHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHBhcnNlV2hlcmVDbGF1c2UocHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiwgcHJvcHMpO1xuICAgICAgICBwcm9wcy5pbnZhbGlkRmlsdGVyID0gIXN1Y2Nlc3M7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzRGVmaW5lZChsYWJlbENsYXNzSWR4KSAmJlxuICAgICAgIWlzRGVmaW5lZChsYWJlbENsYXNzKSAmJlxuICAgICAgKGlzRGVmaW5lZChsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbikgfHwgaXNEZWZpbmVkKG9yaWdpbmFsTGF5ZXIgPT09IG51bGwgfHwgb3JpZ2luYWxMYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWxMYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbikpKSB7XG4gICAgICBwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uID0gKG9yaWdpbmFsTGF5ZXIgfHwgbGF5ZXIpLmRlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgLy8gYXBwbHkgRmVhdHVyZUZpbHRlciB0byBsYXllclxuICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHBhcnNlV2hlcmVDbGF1c2UocHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiwgcHJvcHMpO1xuICAgICAgcHJvcHMuaW52YWxpZEZpbHRlciA9ICFzdWNjZXNzO1xuICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlclRvTGF5ZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICBpZiAodmlldyAmJlxuICAgICAgICBsYXllci50eXBlICE9PSBcImltYWdlcnlcIiAmJlxuICAgICAgICBsYXllci50eXBlICE9PSBcInN1YnR5cGUtZ3JvdXBcIiAmJlxuICAgICAgICAhKGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmIGxheWVyLmlzVGFibGUpICYmXG4gICAgICAgICEobW9kZSA9PT0gXCJlZmZlY3RzXCIgJiYgdGhpcy5sYXllckhhc0ZlYXR1cmVFZmZlY3QpKSB7XG4gICAgICAgIC8vIHJlbW92ZSBkZWZpbml0aW9uRXhwcmVzc2lvbiBmcm9tIGxheWVyXG4gICAgICAgIC8vIHdlIHVzZSBlZmZlY3QgaW5zdGVhZFxuICAgICAgICBsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGhpZGVCdXR0b25zKSB7XG4gICAgICBwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uID0gbGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb247XG4gICAgICBwcm9wcy5sYXN0V2hlcmUgPSBwcm9wcy5pbnB1dERlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHBhcnNlV2hlcmVDbGF1c2UocHJvcHMuaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbiwgdGhpcy5wcm9wcyk7XG4gICAgICBwcm9wcy5pbnZhbGlkRmlsdGVyID0gIXN1Y2Nlc3M7XG4gICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcHJvcHMuaW52YWxpZEZpbHRlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXZlcnRGaWx0ZXIoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgcHJvcHMsIG1vZGUsIHZpZXdGaWx0ZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXllciwgbGF5ZXJWaWV3LCBmZWF0dXJlUmVkdWN0aW9uLCBsYWJlbENsYXNzSWR4LCBsYWJlbENsYXNzLCBpbnB1dERlZmluaXRpb25FeHByZXNzaW9uLCBtYXBJbWFnZVN1YmxheWVyLCBvcmlnaW5hbExheWVyLCBiYWNrZ3JvdW5kVGhlbWUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRMYWJlbENsYXNzSW5kZXgoKTtcbiAgICAvLyBhcHBseSBvcmlnaW5hbCBleHByZXNzaW9uXG4gICAgaWYgKGxheWVyLnR5cGUgIT09IFwiaW1hZ2VyeVwiICYmIGxheWVyLnR5cGUgIT09IFwic3VidHlwZS1ncm91cFwiICYmIGlzRGVmaW5lZChsYWJlbENsYXNzSWR4KSkge1xuICAgICAgY29uc3QgbGFiZWxpbmdJbmZvID0gZmVhdHVyZVJlZHVjdGlvblxuICAgICAgICA/IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24ubGFiZWxpbmdJbmZvXG4gICAgICAgIDogbGF5ZXIubGFiZWxpbmdJbmZvO1xuICAgICAgbGFiZWxpbmdJbmZvW2xhYmVsQ2xhc3NJZHhdLndoZXJlID0gaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbjtcbiAgICAgIC8vIHJlZnJlc2ggbGF5ZXJcbiAgICAgIGlmIChmZWF0dXJlUmVkdWN0aW9uKSB7XG4gICAgICAgIGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24gPSB0aGlzLmVzcmlMYW5nLmNsb25lKGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pO1xuICAgICAgICBwcm9wcy5sYWJlbENsYXNzID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbi5sYWJlbGluZ0luZm9baW5kZXhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxheWVyLmxhYmVsaW5nSW5mbyA9IGxheWVyLmxhYmVsaW5nSW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChtYXBJbWFnZVN1YmxheWVyKSB7XG4gICAgICAgIG1hcEltYWdlU3VibGF5ZXIubGFiZWxpbmdJbmZvID0gbGF5ZXIubGFiZWxpbmdJbmZvO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChsYXllci50eXBlICE9PSBcImltYWdlcnlcIiAmJlxuICAgICAgbGF5ZXIudHlwZSAhPT0gXCJzdWJ0eXBlLWdyb3VwXCIgJiZcbiAgICAgIGlzRGVmaW5lZChsYWJlbENsYXNzKSkge1xuICAgICAgbGFiZWxDbGFzcy53aGVyZSA9IGlucHV0RGVmaW5pdGlvbkV4cHJlc3Npb247XG4gICAgICAvLyByZWZyZXNoIGxheWVyXG4gICAgICBpZiAoZmVhdHVyZVJlZHVjdGlvbikge1xuICAgICAgICBsYXllci5mZWF0dXJlUmVkdWN0aW9uID0gdGhpcy5lc3JpTGFuZy5jbG9uZShsYXllci5mZWF0dXJlUmVkdWN0aW9uKTtcbiAgICAgICAgcHJvcHMubGFiZWxDbGFzcyA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24ubGFiZWxpbmdJbmZvW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsYXllci5sYWJlbGluZ0luZm8gPSBsYXllci5sYWJlbGluZ0luZm87XG4gICAgICB9XG4gICAgICBpZiAobWFwSW1hZ2VTdWJsYXllcikge1xuICAgICAgICBtYXBJbWFnZVN1YmxheWVyLmxhYmVsaW5nSW5mbyA9IGxheWVyLmxhYmVsaW5nSW5mbztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobW9kZSA9PT0gXCJsYXllci12aWV3XCIpIHtcbiAgICAgIC8vIHNldCBiYWNrIHRvIHBhc3NlZCBpbiB2aWV3RmlsdGVyXG4gICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCIpIHtcbiAgICAgICAgaWYgKHZpZXdGaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoIWlzRWZmZWN0RW1wdHkobGF5ZXIuZmVhdHVyZUVmZmVjdCkpIHtcbiAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QuZmlsdGVyLndoZXJlID0gdmlld0ZpbHRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzID0gYmFja2dyb3VuZFRoZW1lID09PSBcImxpZ2h0XCIgPyAxMDAgOiA2NTtcbiAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBuZXcgdGhpcy5GZWF0dXJlRWZmZWN0KHtcbiAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgd2hlcmU6IHZpZXdGaWx0ZXJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXhjbHVkZWRFZmZlY3Q6IGBncmF5c2NhbGUoMTAwJSkgb3BhY2l0eSgzMCUpIGJyaWdodG5lc3MoJHticmlnaHRuZXNzfSUpYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSBsYXllci5mZWF0dXJlRWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2hlcmUpIHtcbiAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QuZmlsdGVyLndoZXJlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0VmZmVjdEVtcHR5KGxheWVyLmZlYXR1cmVFZmZlY3QpKSB7XG4gICAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChtb2RlID09PSBcImVmZmVjdHNcIikgO1xuICAgIGVsc2UgaWYgKGxheWVyKSB7XG4gICAgICBpZiAobWFwSW1hZ2VTdWJsYXllcikge1xuICAgICAgICBtYXBJbWFnZVN1YmxheWVyLmRlZmluaXRpb25FeHByZXNzaW9uID0gaW5wdXREZWZpbml0aW9uRXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAob3JpZ2luYWxMYXllciB8fCBsYXllcikuZGVmaW5pdGlvbkV4cHJlc3Npb24gPSBpbnB1dERlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNBbGxvd2VkRmVhdHVyZUVmZmVjdCgpKSB7XG4gICAgICAgIGNvbnN0IGFueUxheWVyID0gbGF5ZXI7XG4gICAgICAgIGlmICgoX2QgPSAoX2MgPSBhbnlMYXllci5mZWF0dXJlRWZmZWN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmlsdGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qud2hlcmUpIHtcbiAgICAgICAgICBhbnlMYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlci53aGVyZSA9IG51bGw7XG4gICAgICAgICAgaWYgKGlzRWZmZWN0RW1wdHkoYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkpIHtcbiAgICAgICAgICAgIGFueUxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChsYXllclZpZXcgJiYgXCJmaWx0ZXJcIiBpbiBsYXllclZpZXcpIHtcbiAgICAgICAgICBsYXllclZpZXcuZmlsdGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc3dpdGNoZWQgdG8gZGVmaW5pdGlvbkV4cHJlc3Npb24gZnJvbSBlZmZlY3QvbGF5ZXJWaWV3LmZpbHRlclxuICAgICAgdGhpcy5jb21wb25lbnRTdGF0ZUludmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhcHBseUZpbHRlclRvTGF5ZXIoaXNJbml0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IHByb3BzLCBsYXllclZpZXdXYWl0SGFuZGxlciwgaGlkZUJ1dHRvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kVGhlbWUsIGxhYmVsQ2xhc3MsIGxheWVyLCBsYWJlbENsYXNzSWR4LCB2aWV3LCBsYXllclZpZXcsIG1hcEltYWdlU3VibGF5ZXIsIG9yaWdpbmFsTGF5ZXIsIGZlYXR1cmVSZWR1Y3Rpb24sIGxhc3RXaGVyZSB9ID0gcHJvcHM7XG4gICAgY29uc3Qgd2hlcmUgPSBjcmVhdGVXaGVyZUNsYXVzZShwcm9wcykgfHwgdW5kZWZpbmVkO1xuICAgIGlmICghaXNJbml0ICYmIHdoZXJlICE9PSBsYXN0V2hlcmUpIHtcbiAgICAgIHRoaXMuYXJjZ2lzRmlsdGVyV2hlcmVDaGFuZ2UuZW1pdCh3aGVyZSk7XG4gICAgfVxuICAgIHByb3BzLmxhc3RXaGVyZSA9IHdoZXJlO1xuICAgIGlmIChsYXllci50eXBlID09PSBcImZlYXR1cmVcIiAmJiBpc0RlZmluZWQobGFiZWxDbGFzc0lkeCkpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRMYWJlbENsYXNzSW5kZXgoKTtcbiAgICAgIGNvbnN0IGxhYmVsaW5nSW5mbyA9IGZlYXR1cmVSZWR1Y3Rpb25cbiAgICAgICAgPyBsYXllci5mZWF0dXJlUmVkdWN0aW9uLmxhYmVsaW5nSW5mb1xuICAgICAgICA6IGxheWVyLmxhYmVsaW5nSW5mbztcbiAgICAgIGxhYmVsaW5nSW5mb1tsYWJlbENsYXNzSWR4XS53aGVyZSA9IHdoZXJlO1xuICAgICAgLy8gcmVmcmVzaCBsYXllclxuICAgICAgaWYgKGZlYXR1cmVSZWR1Y3Rpb24pIHtcbiAgICAgICAgbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUobGF5ZXIuZmVhdHVyZVJlZHVjdGlvbik7XG4gICAgICAgIHByb3BzLmxhYmVsQ2xhc3MgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uLmxhYmVsaW5nSW5mb1tpbmRleF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGF5ZXIubGFiZWxpbmdJbmZvID0gbGF5ZXIubGFiZWxpbmdJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKG1hcEltYWdlU3VibGF5ZXIpIHtcbiAgICAgICAgbWFwSW1hZ2VTdWJsYXllci5sYWJlbGluZ0luZm8gPSBsYXllci5sYWJlbGluZ0luZm87XG4gICAgICB9XG4gICAgICAvL2NvbnNvbGUubG9nKFwiYXBwbHlcIiwgd2hlcmUsIGxheWVyLmxhYmVsaW5nSW5mbyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmaW5lZChsYWJlbENsYXNzKSkge1xuICAgICAgLy8gd2UgZG9uJ3QgdXBkYXRlIHRoZSBsYXllciBhdCBhbGxcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAobGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgIGxheWVyLmRlZmluaXRpb25FeHByZXNzaW9uID0gd2hlcmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGhpZGVCdXR0b25zKSB7XG4gICAgICAvLyB3ZSBkb24ndCB1cGRhdGUgdGhlIGxheWVyIGF0IGFsbFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWFwSW1hZ2VTdWJsYXllcikge1xuICAgICAgbWFwSW1hZ2VTdWJsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbiA9IHdoZXJlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmICghdmlldyB8fCAobGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCIgJiYgbGF5ZXIuaXNUYWJsZSkpIHtcbiAgICAgIG9yaWdpbmFsTGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24gPSBjcmVhdGVXaGVyZUNsYXVzZShwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVzZSBlZmZlY3RcbiAgICBpZiAobGF5ZXJWaWV3V2FpdEhhbmRsZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChsYXllclZpZXdXYWl0SGFuZGxlcik7XG4gICAgICB0aGlzLmxheWVyVmlld1dhaXRIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWxheWVyVmlldykge1xuICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGFuZCB0cnkgbGF0ZXJcbiAgICAgIHRoaXMubGF5ZXJWaWV3V2FpdEhhbmRsZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlclRvTGF5ZXIoKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJGZWF0dXJlRWZmZWN0LmZpbHRlcjpcIiwgd2hlcmVDbGF1c2UpO1xuICAgIGlmICh3aGVyZSA9PT0gbnVsbCB8fCB3aGVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2hlcmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5pc0FsbG93ZWRGZWF0dXJlRWZmZWN0KCkpIHtcbiAgICAgICAgaWYgKCFpc0VmZmVjdEVtcHR5KGxheWVyLmZlYXR1cmVFZmZlY3QpKSB7XG4gICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdC5maWx0ZXIgPSBsYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlciB8fCB7fTtcbiAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0LmZpbHRlci53aGVyZSA9IHdoZXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSBiYWNrZ3JvdW5kVGhlbWUgPT09IFwibGlnaHRcIiA/IDEwMCA6IDY1O1xuICAgICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBuZXcgdGhpcy5GZWF0dXJlRWZmZWN0KHtcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICB3aGVyZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4Y2x1ZGVkRWZmZWN0OiBgZ3JheXNjYWxlKDEwMCUpIG9wYWNpdHkoMzAlKSBicmlnaHRuZXNzKCR7YnJpZ2h0bmVzc30lKWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXCJmaWx0ZXJcIiBpbiBsYXllclZpZXcpIHtcbiAgICAgICAgbGF5ZXJWaWV3LmZpbHRlciA9IHtcbiAgICAgICAgICB3aGVyZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlzQWxsb3dlZEZlYXR1cmVFZmZlY3QoKSkge1xuICAgICAgICBpZiAoKF9iID0gKF9hID0gbGF5ZXIuZmVhdHVyZUVmZmVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndoZXJlKSB7XG4gICAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdC5maWx0ZXIud2hlcmUgPSBudWxsO1xuICAgICAgICAgIGlmIChpc0VmZmVjdEVtcHR5KGxheWVyLmZlYXR1cmVFZmZlY3QpKSB7XG4gICAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFwiZmlsdGVyXCIgaW4gbGF5ZXJWaWV3KSB7XG4gICAgICAgIGxheWVyVmlldy5maWx0ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0FsbG93ZWRGZWF0dXJlRWZmZWN0KCkge1xuICAgIC8vIElkZWFsbHkgd2Ugd2FudCB0byBmaWx0ZXIgb3V0IGZlYXR1cmVzIHZpYSBsYXllci5mZWF0dXJlRWZmZWN0XG4gICAgLy8gc28gdGhhdCBmaWx0ZXJlZCBvdXQgZmVhdHVyZXMgc2hvdyBkaW1tZWQuXG4gICAgLy8gQnV0IGlmIHRoaXMgaXMgbm90IHBvc3NpYmxlIHVzZSBsYXllclZpZXcuZmlsdGVyXG4gICAgLy8gc28gZmlsdGVyZWQgb3V0IGZlYXR1cmVzIGFyZSBoaWRkZW4uXG4gICAgLy8gTGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24gYWZmZWN0cyB0aGUgc2VydmVyIHF1ZXJpZXNcbiAgICAvLyBzbyBvbmx5IGFwcGx5IHRoaXMgd2hlbiBsZWF2aW5nIHRoZSBjb21wb25lbnRcbiAgICBjb25zdCB7IHByb3BzLCBsYXllckhhc0ZlYXR1cmVFZmZlY3QsIG1vZGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXllciB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChbXCJmZWF0dXJlXCIsIFwiZ2VvanNvblwiLCBcIm9nYy1mZWF0dXJlXCIsIFwid2ZzXCIsIFwiY3N2XCIsIFwic3RyZWFtXCJdLmluZGV4T2YobGF5ZXIudHlwZSkgPiAtMSAmJlxuICAgICAgIWxheWVyLmZlYXR1cmVSZWR1Y3Rpb24gJiZcbiAgICAgIG1vZGUgIT09IFwiZWZmZWN0c1wiICYmXG4gICAgICAoIWxheWVySGFzRmVhdHVyZUVmZmVjdCB8fCBtb2RlID09PSBcImxheWVyLXZpZXdcIikpO1xuICB9XG4gIGdldExhYmVsQ2xhc3NJbmRleCgpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5ZXIsIGxhYmVsQ2xhc3MsIGZlYXR1cmVSZWR1Y3Rpb24gfSA9IHByb3BzO1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxhYmVsaW5nSW5mbyA9IGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiICYmXG4gICAgICAoZmVhdHVyZVJlZHVjdGlvblxuICAgICAgICA/IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24ubGFiZWxpbmdJbmZvXG4gICAgICAgIDogbGF5ZXIubGFiZWxpbmdJbmZvKTtcbiAgICBpZiAobGFiZWxDbGFzcykge1xuICAgICAgbGFiZWxpbmdJbmZvLmZvckVhY2goKGxDbGFzcywgaWR4KSA9PiB7XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShsQ2xhc3MudG9KU09OKCkpID09PSBKU09OLnN0cmluZ2lmeShsYWJlbENsYXNzLnRvSlNPTigpKSkge1xuICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIGdldCBob3N0RWxlbWVudCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNGaWx0ZXIuc3R5bGUgPSBhcmNnaXNGaWx0ZXJDc3M7XG5cbmNvbnN0IENTUyQyID0ge1xuICBjb25kaXRpb246IFwiZmlsdGVyLWNvbmRpdGlvblwiLFxuICBvcGVyYXRvckRyb3Bkb3duOiBcIm9wZXJhdG9yLWRyb3Bkb3duXCIsXG4gIGlucHV0UGx1c1VuaXF1ZTogXCJpbnB1dC1wbHVzLXVuaXF1ZVwiLFxuICBpbnB1dDogXCJpbnB1dFwiLFxuICBibGFua0J1dHRvbjogXCJibGFuay1idXR0b25cIixcbiAgc2VsZWN0VW5pcXVlQnV0dG9uOiBcInNlbGVjdC11bmlxdWUtYnV0dG9uXCIsXG4gIGJldHdlZW5WYWx1ZXNJbnB1dDogXCJiZXR3ZWVuLXZhbHVlcy1pbnB1dFwiLFxuICBzZWxlY3RWYWx1ZXM6IFwic2VsZWN0LXZhbHVlc1wiLFxuICBwaWNrTGlzdDogXCJwaWNrLWxpc3RcIixcbiAgdW5pcXVlVmFsdWVzQ29udGVudExpc3RNc2c6IFwidW5pcXVlLXZhbHVlcy1jb250ZW50LWxpc3QtbXNnXCIsXG4gIGluVGhlTGFzdDogXCJpbi10aGUtbGFzdFwiLFxuICBpblRoZUxhc3RDb3VudDogXCJpbi10aGUtbGFzdC1jb3VudFwiLFxuICBpblRoZUxhc3RVbml0OiBcImluLXRoZS1sYXN0LXVuaXRcIixcbiAgZGF0ZVBpY2tlcjogXCJkYXRlLXBpY2tlclwiLFxuICBoaXN0b2dyYW1Db250ZW50OiBcImhpc3RvZ3JhbS1jb250ZW50XCIsXG4gIGhpc3RvZ3JhbUNvbnRlbnRTbGltOiBcImhpc3RvZ3JhbS1jb250ZW50LXNsaW1cIixcbiAgc21hbGxMb2FkZXI6IFwic21hbGwtbG9hZGVyXCJcbn07XG5cbmNvbnN0IGFyY2dpc0ZpbHRlckNvbmRpdGlvbkNzcyA9IFwiLmZpbHRlci1jb25kaXRpb24uc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257cGFkZGluZzowIDZweH0ub3BlcmF0b3ItZHJvcGRvd24uc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6MTAwJTttYXJnaW46NXB4IDB9LmlucHV0LXBsdXMtdW5pcXVlLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7d2lkdGg6MTAwJX0uaW5wdXQuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6MTAwJX0uYmxhbmstYnV0dG9uLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2hlaWdodDoyMnB4O2JvcmRlcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci1pbnB1dCkgMXB4IHNvbGlkfS5ibGFuay1idXR0b24uYWN0aXZlLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2N1cnNvcjpwb2ludGVyfS5ibGFuay1idXR0b24uaW5hY3RpdmUuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb246Zm9jdXN7b3V0bGluZTpub25lfS5zZWxlY3QtdW5pcXVlLWJ1dHRvbi5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbntoZWlnaHQ6MzJweDtib3JkZXItdG9wOnZhcigtLWNhbGNpdGUtdWktYm9yZGVyLWlucHV0KSAxcHggc29saWQ7Ym9yZGVyLWJvdHRvbTp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci1pbnB1dCkgMXB4IHNvbGlkO2JvcmRlci1yaWdodDp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci1pbnB1dCkgMXB4IHNvbGlkfS5hcmNnaXMtLXJ0bC5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbiAuc2VsZWN0LXVuaXF1ZS1idXR0b24uc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257Ym9yZGVyLXJpZ2h0Om5vbmU7Ym9yZGVyLWxlZnQ6dmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItaW5wdXQpIDFweCBzb2xpZH0uYmV0d2Vlbi12YWx1ZXMtaW5wdXQuZmlyc3Quc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWJvdHRvbTo1cHh9LnNlbGVjdC12YWx1ZXMuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWJvdHRvbTo0cHh9LnBpY2stbGlzdC5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbnttYXgtaGVpZ2h0OjIwMHB4O292ZXJmbG93LXk6YXV0b30udW5pcXVlLXZhbHVlcy1jb250ZW50LWxpc3QtbXNnLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2ZvbnQtc2l6ZTo5MCU7bWFyZ2luLXRvcDo1cHg7bWFyZ2luLWJvdHRvbTo1cHh9LmluLXRoZS1sYXN0LnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2Rpc3BsYXk6ZmxleH0uaW4tdGhlLWxhc3QtY291bnQuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6NTAlfS5pbi10aGUtbGFzdC11bml0LnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue3dpZHRoOjUwJX0uZGF0ZS1waWNrZXIuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257d2lkdGg6MTAwJX0uZGF0ZS1waWNrZXIuZmlyc3Quc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWJvdHRvbTo1cHh9Lmhpc3RvZ3JhbS1jb250ZW50LnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue2hlaWdodDoxMjBweDttYXJnaW4tdG9wOjVweH0uaGlzdG9ncmFtLWNvbnRlbnQtc2xpbS5zYy1hcmNnaXMtZmlsdGVyLWNvbmRpdGlvbntoZWlnaHQ6NDBweDttYXJnaW4tdG9wOjVweH0uc21hbGwtbG9hZGVyLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9ue21hcmdpbi1sZWZ0OmNhbGMoKDEwMCUgLSAxNnB4KSAvIDIpO21hcmdpbi10b3A6MTBweH1odG1sW2Rpcj1ydGxdLnNjLWFyY2dpcy1maWx0ZXItY29uZGl0aW9uIC5zbWFsbC1sb2FkZXIuc2MtYXJjZ2lzLWZpbHRlci1jb25kaXRpb257bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6OHB4fVwiO1xuXG5jb25zdCBBcmNnaXNGaWx0ZXJDb25kaXRpb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzRmlsdGVyQ29uZGl0aW9uQ2hhbmdlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyQ29uZGl0aW9uQ2hhbmdlZFwiLCA3KTtcbiAgICB0aGlzLmRpc2FibGVGaWx0ZXJQYW5lbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiZGlzYWJsZUZpbHRlclBhbmVsXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzRmlsdGVyVW5pcXVlVmFsdWVzUmV0dXJuZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlclVuaXF1ZVZhbHVlc1JldHVybmVkXCIsIDcpO1xuICAgIHRoaXMuaGlzdG9ncmFtU2xpZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJDcmVhdGVTbGlkZXJEaXYgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIHByb3BzLCBoaXN0b2dyYW1TbGlkZXIgfSA9IHRoaXM7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgLy8gbm90IHN1cmUgd2h5IHRoYXQgaGFwcGVuc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFoaXN0b2dyYW1TbGlkZXIpIHtcbiAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXZOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkaXZOb2RlKTtcbiAgICAgICAgaWYgKCFoaXN0b2dyYW1TbGlkZXIuY29udGFpbmVyKSB7XG4gICAgICAgICAgaGlzdG9ncmFtU2xpZGVyLmNvbnRhaW5lciA9IGRpdk5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gbmVlZCB0byByZWNyZWF0ZSB0aGUgc2xpZGVyXG4gICAgICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICAgICAgaWYgKCFmaWx0ZXJGaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGJpbnMsIGF2ZXJhZ2UsIG1pbiwgbWF4LCB2YWx1ZXMsIHByZWNpc2lvbiwgcmFuZ2VUeXBlIH0gPSBoaXN0b2dyYW1TbGlkZXI7XG4gICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgY29udGFpbmVyOiBkaXZOb2RlLFxuICAgICAgICAgICAgYmlucyxcbiAgICAgICAgICAgIGF2ZXJhZ2UsXG4gICAgICAgICAgICAvL3N0YW5kYXJkRGV2aWF0aW9uLFxuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgcHJlY2lzaW9uLFxuICAgICAgICAgICAgcmFuZ2VUeXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoW3NpbXBsZUZpZWxkVHlwZXMuREFURSwgc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLmluZGV4T2YoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA+XG4gICAgICAgICAgICAtMSkge1xuICAgICAgICAgICAgY29uZmlnLmhhc1RpbWVEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0ZUZvcm1hdEZ1bmN0aW9ucyhjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicmUtY3JlYXRlIEhpc3RvZ3JhbVJhbmdlU2xpZGVyXCIsIGNvbmZpZyk7XG4gICAgICAgICAgaGlzdG9ncmFtU2xpZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmhpc3RvZ3JhbVNsaWRlciA9IG5ldyB0aGlzLkhpc3RvZ3JhbVJhbmdlU2xpZGVyKGNvbmZpZyk7XG4gICAgICAgICAgdGhpcy5jcmVhdGVTbGlkZXJDaGFuZ2VFdmVudHMoZmlsdGVyRmllbGQpO1xuICAgICAgICB9XG4gICAgICB9LCAxKTtcbiAgICB9O1xuICAgIHRoaXMub25GaWVsZFNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgdGhpcy5vcGVuRmllbGRQaWNrTGlzdCgpO1xuICAgIH07XG4gICAgdGhpcy5vbk9wZXJhdG9yU2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICBjb25zdCB7IHByb3BzLCBmaWVsZE5hbWUsIG9wZXJhdG9yLCB2YWx1ZSwgdmFsdWUyIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2VsZWN0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgbmV3T3BlcmF0b3IgPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWU7XG4gICAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICAgIGNvbnN0IG9sZEluVGhlTGFzdCA9IGlzSW5UaGVMYXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKTtcbiAgICAgIGNvbnN0IG5ld0luVGhlTGFzdCA9IGlzSW5UaGVMYXN0T3BlcmF0b3IocHJvcHMsIG5ld09wZXJhdG9yKTtcbiAgICAgIGNvbnN0IG9uZUluVGhlTGFzdCA9IG9sZEluVGhlTGFzdCB8fCBuZXdJblRoZUxhc3Q7XG4gICAgICBjb25zdCBib3RoSW5UaGVMYXN0ID0gb2xkSW5UaGVMYXN0ICYmIG5ld0luVGhlTGFzdDtcbiAgICAgIGNvbnN0IG9sZEJldHdlZW4gPSBpc0JldHdlZW5PcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpO1xuICAgICAgY29uc3QgbmV3QmV0d2VlbiA9IGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBuZXdPcGVyYXRvcik7XG4gICAgICBjb25zdCBib3RoQmV0d2VlbiA9IG9sZEJldHdlZW4gJiYgbmV3QmV0d2VlbjtcbiAgICAgIC8vY29uc3Qgb2xkSW5FeGNsdWRlID0gaXNJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikgfHwgaXNFeGNsdWRlc09wZXJhdG9yKHByb3BzLCBvcGVyYXRvcik7XG4gICAgICAvL2NvbnN0IG5ld0luRXhjbHVkZSA9XG4gICAgICAvLyAgaXNJbmNsdWRlc09wZXJhdG9yKHByb3BzLCBuZXdPcGVyYXRvcikgfHwgaXNFeGNsdWRlc09wZXJhdG9yKHByb3BzLCBuZXdPcGVyYXRvcik7XG4gICAgICAvL2NvbnN0IGJvdGhJbkV4Y2x1ZGUgPSBvbGRJbkV4Y2x1ZGUgJiYgbmV3SW5FeGNsdWRlO1xuICAgICAgY29uc3Qgb2xkID0ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWUyLFxuICAgICAgICBvcGVyYXRvclxuICAgICAgfTtcbiAgICAgIHRoaXMudmFsdWUgPVxuICAgICAgICBvbmVJblRoZUxhc3QgJiYgIWJvdGhJblRoZUxhc3RcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IGZpbHRlckZpZWxkLnN0YXRpc3RpY3MgJiYgIWlzRGVmaW5lZCh2YWx1ZSlcbiAgICAgICAgICAgID8gZmlsdGVyRmllbGQuc3RhdGlzdGljcy5hdmdcbiAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICB0aGlzLnZhbHVlMiA9IG5ld0JldHdlZW5cbiAgICAgICAgPyB2YWx1ZTIgIT09IG51bGwgJiYgdmFsdWUyICE9PSB2b2lkIDAgPyB2YWx1ZTIgOiAoaXNJbnRlZ2VyVHlwZShmaWx0ZXJGaWVsZClcbiAgICAgICAgICA/IE1hdGgucm91bmQoKF9hID0gZmlsdGVyRmllbGQuc3RhdGlzdGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1heClcbiAgICAgICAgICA6IChfYiA9IGZpbHRlckZpZWxkLnN0YXRpc3RpY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXgpXG4gICAgICAgIDogb25lSW5UaGVMYXN0IHx8ICFib3RoQmV0d2VlblxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdmFsdWUyO1xuICAgICAgdGhpcy5vcGVyYXRvciA9IG5ld09wZXJhdG9yO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IHRoaXMuY2hlY2tEZWZhdWx0VmFsdWVzKGZpbHRlckZpZWxkKTtcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICAgIHZhbHVlOiAoX2MgPSB0aGlzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0VmFsdWVzLnZhbHVlLFxuICAgICAgICB2YWx1ZTI6IChfZCA9IHRoaXMudmFsdWUyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAobmV3QmV0d2VlbiA/IGRlZmF1bHRWYWx1ZXMudmFsdWUyIDogbnVsbCksXG4gICAgICAgIG9wZXJhdG9yOiB0aGlzLm9wZXJhdG9yXG4gICAgICB9O1xuICAgICAgLy8gc2V0IGl0IGJhY2sgLSBUT0RPLCBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IGFmdGVyIDkuMVxuICAgICAgLy8gaWYgSSBtb2RpZnkgbG9jYWwgcHJvcHMgdGhlIGNvbXBvbmVudCB3b24ndCByZS1yZW5kZXIgd2l0aCBlbWl0Q2hhbmdlRXZlbnQoKVxuICAgICAgdGhpcy52YWx1ZSA9IG9sZC52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUyID0gb2xkLnZhbHVlMjtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSBvbGQub3BlcmF0b3I7XG4gICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCh1cGRhdGVzKTtcbiAgICB9O1xuICAgIHRoaXMub25WYWx1ZUNoYW5nZU1heWJlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BzLCBvcGVyYXRvciwgdmFsdWUyIH0gPSB0aGlzO1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmdldE5ld1ZhbHVlKGV2ZW50KTtcbiAgICAgIGlmIChpc0RlZmluZWQobmV3VmFsdWUpICYmIGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikgJiYgbmV3VmFsdWUgPj0gdmFsdWUyKSB7XG4gICAgICAgIC8vIHdlIGFzc3VtZSB0aGUgdXNlciBpcyBpbiB0aGUgbWlkZGxlIG9mIHR5cGluZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UoZXZlbnQsIG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMub25WYWx1ZUNoYW5nZSA9IChldmVudCwgbmV3VmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHMsIGZpZWxkTmFtZSwgb3BlcmF0b3IsIHZhbHVlLCB2YWx1ZTIgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IHZpZXcgfSA9IHByb3BzO1xuICAgICAgY29uc3QgeyB0aW1lWm9uZSB9ID0gdmlldztcbiAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC50YXJnZXQ7XG4gICAgICBuZXdWYWx1ZSA9IGV2ZW50ID8gdGhpcy5nZXROZXdWYWx1ZShldmVudCkgOiBuZXdWYWx1ZTtcbiAgICAgIGlmICghaXNEZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGhhdmUgYSB2YWx1ZVxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IGdldERlZmF1bHRWYWx1ZXMocHJvcHMsIGZpbHRlckZpZWxkLCBvcGVyYXRvcik7XG4gICAgICAgIG5ld1ZhbHVlID0gZGVmYXVsdFZhbHVlcy52YWx1ZTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEUpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB1dGNUb0RhdGVQaWNrZXIobmV3VmFsdWUsIHRpbWVab25lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZmluZWQobmV3VmFsdWUpICYmIGlzQmV0d2Vlbk9wZXJhdG9yKHByb3BzLCBvcGVyYXRvcikgJiYgbmV3VmFsdWUgPj0gdmFsdWUyKSB7XG4gICAgICAgIC8vIHVzZXIgZmluaXNoZWQgdHlwaW5nLCBsZXQncyBmaXggdGhlIHZhbHVlc1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTIgLSAxO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHV0Y1RvRGF0ZVBpY2tlcihuZXdWYWx1ZSwgdGltZVpvbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2RGF5ID0gbmV3IERhdGUobmV3IERhdGUodmFsdWUyKS5nZXRUaW1lKCkgLSA4NjQwMDAwMCArIG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gYCR7cHJldkRheS5nZXRGdWxsWWVhcigpfS0ke3ByZXZEYXkuZ2V0TW9udGgoKSA8IDkgPyBcIjBcIiA6IFwiXCJ9JHtwcmV2RGF5LmdldE1vbnRoKCkgKyAxfS0ke3ByZXZEYXkuZ2V0RGF0ZSgpIDwgMTAgPyBcIjBcIiA6IFwiXCJ9JHtwcmV2RGF5LmdldERhdGUoKX1gO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWUyIC0gMTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRhZ05hbWUpID09PSBcIkNBTENJVEUtSU5QVVQtREFURS1QSUNLRVJcIiB8fFxuICAgICAgICAoKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50YWdOYW1lKSA9PT0gXCJDQUxDSVRFLUlOUFVUXCIgJiYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgdGhpcy5hZGp1c3RIaXN0b2dyYW1NaW5NYXgobmV3VmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXMobmV3VmFsdWUsIHZhbHVlMik7XG4gICAgfTtcbiAgICB0aGlzLm9uVmFsdWUyQ2hhbmdlTWF5YmUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHMsIG9wZXJhdG9yLCB2YWx1ZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5nZXROZXdWYWx1ZShldmVudCk7XG4gICAgICBpZiAoaXNEZWZpbmVkKG5ld1ZhbHVlKSAmJiBpc0JldHdlZW5PcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpICYmIG5ld1ZhbHVlIDw9IHZhbHVlKSB7XG4gICAgICAgIC8vIHdlIGFzc3VtZSB0aGUgdXNlciBpcyBpbiB0aGUgbWlkZGxlIG9mIHR5cGluZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9uVmFsdWUyQ2hhbmdlKGV2ZW50LCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uVmFsdWUyQ2hhbmdlID0gKGV2ZW50LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgcHJvcHMsIGZpZWxkTmFtZSwgb3BlcmF0b3IgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IHZpZXcgfSA9IHByb3BzO1xuICAgICAgY29uc3QgeyB0aW1lWm9uZSB9ID0gdmlldztcbiAgICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHZvaWQgMCA/IG5ld1ZhbHVlIDogdGhpcy5nZXROZXdWYWx1ZShldmVudCk7XG4gICAgICBpZiAoIWlzRGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBoYXZlIGEgdmFsdWVcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBnZXREZWZhdWx0VmFsdWVzKHByb3BzLCBmaWx0ZXJGaWVsZCwgb3BlcmF0b3IpO1xuICAgICAgICBuZXdWYWx1ZSA9IGRlZmF1bHRWYWx1ZXMudmFsdWUyO1xuICAgICAgICBpZiAoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gdXRjVG9EYXRlUGlja2VyKG5ld1ZhbHVlLCB0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB3ZSdyZSB1c2luZyBiZXR3ZWVuIG9wZXJhdG9yXG4gICAgICBpZiAobmV3VmFsdWUgPD0gdmFsdWUpIHtcbiAgICAgICAgLy8gdXNlciBmaW5pc2hlZCB0eXBpbmcsIGxldCdzIGZpeCB0aGUgdmFsdWVzXG4gICAgICAgIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWUgKyAxO1xuICAgICAgICAgIG5vZGUudmFsdWUgPSB1dGNUb0RhdGVQaWNrZXIobmV3VmFsdWUsIHRpbWVab25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZKSB7XG4gICAgICAgICAgY29uc3QgbmV4dERheSA9IG5ldyBEYXRlKG5ldyBEYXRlKHZhbHVlKS5nZXRUaW1lKCkgKyA4NjQwMDAwMCArIG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGAke25leHREYXkuZ2V0RnVsbFllYXIoKX0tJHtuZXh0RGF5LmdldE1vbnRoKCkgPCA5ID8gXCIwXCIgOiBcIlwifSR7bmV4dERheS5nZXRNb250aCgpICsgMX0tJHtuZXh0RGF5LmdldERhdGUoKSA8IDEwID8gXCIwXCIgOiBcIlwifSR7bmV4dERheS5nZXREYXRlKCl9YDtcbiAgICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZSArIDE7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIkNBTENJVEUtSU5QVVQtREFURS1QSUNLRVJcIiB8fFxuICAgICAgICAobm9kZS50YWdOYW1lID09PSBcIkNBTENJVEUtSU5QVVRcIiAmJiBub2RlLnR5cGUgPT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgIHRoaXMuYWRqdXN0SGlzdG9ncmFtTWluTWF4KG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uVW5pdFNlbGVjdCA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgLy90aGlzLnVuaXQgPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWUgYXMgdGltZVVuaXRzO1xuICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoeyB1bml0OiBzZWxlY3Quc2VsZWN0ZWRPcHRpb24udmFsdWUgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uU2VsZWN0VW5pcXVlVmFsdWUgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uU2VsZWN0VW5pcXVlKGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMub25TZWxlY3RVbmlxdWVWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BzLCBmaWVsZE5hbWUsIG9wZXJhdG9yIH0gPSB0aGlzO1xuICAgICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgICBjb25zdCBmaWVsZERvbWFpbnMgPSBoYXNGaWVsZERvbWFpbnMoZmlsdGVyRmllbGQpO1xuICAgICAgY29uc3QgbGlzdE9wZXJhdG9yID0gaXNMaXN0T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKTtcbiAgICAgIGNvbnN0IGlzRG9tYWluU2luZ2xlID0gZmllbGREb21haW5zICYmICFsaXN0T3BlcmF0b3I7XG4gICAgICB0aGlzLm9uU2VsZWN0VW5pcXVlKCFpc0RvbWFpblNpbmdsZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uRG9jdW1lbnRDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgaXNUYXJnZXRJbnNpZGVQb3BvdmVyID0gdGFyZ2V0LmNsb3Nlc3QoYCNhcmNnaXMtZmlsdGVyLXVuaXF1ZS1wb3BvdmVyXyR7dGhpcy51aWR9YCk7XG4gICAgICBpZiAoIWlzVGFyZ2V0SW5zaWRlUG9wb3Zlcikge1xuICAgICAgICB0aGlzLnJlbW92ZVVuaXF1ZVBvcG92ZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub25SZW1vdmVTZWxlY3RlZFZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7IHZhbHVlcywgZXNyaUxhbmcgfSA9IHRoaXM7XG4gICAgICBjb25zdCBpZHggPSB2YWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICB2YWx1ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAvL3RoaXMudmFsdWVzID0gdmFsdWVzLmxlbmd0aCA/IGVzcmlMYW5nLmNsb25lKHZhbHVlcykgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCh7IHZhbHVlczogdmFsdWVzLmxlbmd0aCA/IGVzcmlMYW5nLmNsb25lKHZhbHVlcykgOiBudWxsIH0pO1xuICAgIH07XG4gICAgdGhpcy5hZnRlckNyZWF0ZUxpc3QgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsRXhwckludG9WaWV3KGVsZW1lbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkhpc3RvZ3JhbUJsb2NrVG9nZ2xlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldC5vcGVuKSB7XG4gICAgICAgIHRoaXMub25IaXN0b2dyYW1PcGVuKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkhpc3RvZ3JhbUNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmZpZWxkUGlja0xpc3RDaGFuZ2VzID0gKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjb25zdCBzZWxlY3RlZEZpZWxkID0gKF9iID0gKF9hID0gZXZlbnQuZGV0YWlsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VsZWN0ZWRGaWVsZHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXTtcbiAgICAgIHRoaXMucmVtb3ZlRmllbGRzUGlja0xpc3QoKTtcbiAgICAgIGlmIChzZWxlY3RlZEZpZWxkKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJGaWVsZFNlbGVjdChzZWxlY3RlZEZpZWxkKTtcbiAgICAgIH0gLy8gZWxzZSB1c2VyIGhpdCBjYW5jZWwgb3IgY2xvc2VcbiAgICB9O1xuICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy51aWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maWVsZE5hbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaXF1ZVZhbHVlc1NvcnRCeSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsdWUyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudW5pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpc3RvZ3JhbU9wZW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oYXNGb2N1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmludmFsaWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlUmVuZGVyID0gZmFsc2U7XG4gIH1cbiAgYXJjZ2lzRmlsdGVyVW5pcXVlVmFsdWVzUmV0dXJuZWRIYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gZXZlbnQuZGV0YWlsO1xuICAgIGlmICh0aGlzLmZpZWxkTmFtZSA9PT0gZmllbGROYW1lKSB7XG4gICAgICB0aGlzLmNoZWNrRGVmYXVsdFZhbHVlcyhnZXRGaWVsZEluZm8oZmllbGROYW1lLCB0aGlzLnByb3BzKSk7XG4gICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICB9XG4gIGFyY2dpc0ZpbHRlclVuaXF1ZUxpc3RDaGFuZ2VkSGFuZGxlcihldmVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgY29uc3QgdWlkID0gZGV0YWlsLnVpZDtcbiAgICBpZiAodWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZXMgPSBkZXRhaWwuc2VsZWN0ZWRWYWx1ZXM7XG4gICAgICBpZiAoIWRldGFpbC5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLnVuaXF1ZVZhbHVlc1NvcnRCeSA9IGRldGFpbC5zb3J0Qnk7XG4gICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZShudWxsLCAoc2VsZWN0ZWRWYWx1ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWRWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkVmFsdWVzLmxlbmd0aCkgPyBzZWxlY3RlZFZhbHVlc1swXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlVW5pcXVlUG9wb3ZlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLnVuaXF1ZUFjdGlvbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KHsgdmFsdWVzOiBzZWxlY3RlZFZhbHVlcywgdW5pcXVlVmFsdWVzU29ydEJ5OiBkZXRhaWwuc29ydEJ5IH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhcmNnaXNGaWx0ZXJVbmlxdWVMaXN0U29ydEJ5Q2hhbmdlZChldmVudCkge1xuICAgIGNvbnN0IHsgZGV0YWlsIH0gPSBldmVudDtcbiAgICBjb25zdCB1aWQgPSBkZXRhaWwudWlkO1xuICAgIGlmICh1aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLnVuaXF1ZVZhbHVlc1NvcnRCeSA9IGRldGFpbC5zb3J0Qnk7XG4gICAgfVxuICB9XG4gIGFyY2dpc0ZpbHRlclVuaXF1ZUxpc3REb25lSGFuZGxlcihldmVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGRldGFpbCB9ID0gZXZlbnQ7XG4gICAgaWYgKGRldGFpbCA9PT0gdGhpcy51aWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlVW5pcXVlUG9wb3ZlcigpO1xuICAgICAgKF9hID0gdGhpcy51bmlxdWVBY3Rpb25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgY2FsY2l0ZVBvcG92ZXJDbG9zZUhhbmRsZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLnVuaXF1ZVBvcG92ZXJOb2RlKSB7XG4gICAgICB0aGlzLnJlbW92ZVVuaXF1ZVBvcG92ZXIoKTtcbiAgICAgIChfYSA9IHRoaXMudW5pcXVlQWN0aW9uTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgfSAvLyBlbHNlIHNvbWV0aGluZyBlbHNlIHJlbW92ZWQgdGhlIHBvcG92ZXJcbiAgfVxuICBjbG9zZUZpbHRlclBvcG92ZXJzSGFuZGxlcigpIHtcbiAgICB0aGlzLnJlbW92ZUZpZWxkc1BpY2tMaXN0KCk7XG4gICAgdGhpcy5yZW1vdmVVbmlxdWVQb3BvdmVyKCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgY29uc3QgZGVmYXVsdEZpZWxkID0gZ2V0RGVmYXVsdEZpZWxkKHtcbiAgICAgIGZpZWxkczogdGhpcy5wcm9wcy5maWVsZHNcbiAgICB9KTtcbiAgICB0aGlzLmZpZWxkTmFtZSA9IHRoaXMuZmllbGROYW1lIHx8IGRlZmF1bHRGaWVsZC5sYXllckZpZWxkLm5hbWU7XG4gICAgdGhpcy5vcGVyYXRvciA9IHRoaXMub3BlcmF0b3IgfHwgZ2V0RGVmYXVsdE9wZXJhdG9yKHRoaXMucHJvcHMsIGRlZmF1bHRGaWVsZCk7XG4gICAgdGhpcy5oYXNGb2N1cyA9ICEhdGhpcy5oYXNGb2N1cztcbiAgICBjb25zdCBbZXNyaUxhbmcsIGludGwsIFxuICAgIC8vc21hcnRNYXBwaW5nVXRpbHMsXG4gICAgc3VtbWFyeVN0YXRpc3RpY3MsIGhpc3RvZ3JhbSwgdW5pcXVlVmFsdWVzLCBIaXN0b2dyYW1SYW5nZVNsaWRlcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICBcImVzcmkvY29yZS9sYW5nXCIsXG4gICAgICBcImVzcmkvaW50bFwiLFxuICAgICAgLy9cImVzcmkvd2lkZ2V0cy9zbWFydE1hcHBpbmcvc3VwcG9ydC91dGlsc1wiLFxuICAgICAgXCJlc3JpL3NtYXJ0TWFwcGluZy9zdGF0aXN0aWNzL3N1bW1hcnlTdGF0aXN0aWNzXCIsXG4gICAgICBcImVzcmkvc21hcnRNYXBwaW5nL3N0YXRpc3RpY3MvaGlzdG9ncmFtXCIsXG4gICAgICBcImVzcmkvc21hcnRNYXBwaW5nL3N0YXRpc3RpY3MvdW5pcXVlVmFsdWVzXCIsXG4gICAgICBcImVzcmkvd2lkZ2V0cy9IaXN0b2dyYW1SYW5nZVNsaWRlclwiXG4gICAgXSk7XG4gICAgdGhpcy5lc3JpTGFuZyA9IGVzcmlMYW5nO1xuICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgLy90aGlzLnNtYXJ0TWFwcGluZ1V0aWxzID0gc21hcnRNYXBwaW5nVXRpbHM7XG4gICAgdGhpcy5zdW1tYXJ5U3RhdGlzdGljcyA9IHN1bW1hcnlTdGF0aXN0aWNzO1xuICAgIHRoaXMuaGlzdG9ncmFtID0gaGlzdG9ncmFtO1xuICAgIHRoaXMudW5pcXVlVmFsdWVzID0gdW5pcXVlVmFsdWVzO1xuICAgIHRoaXMuSGlzdG9ncmFtUmFuZ2VTbGlkZXIgPSBIaXN0b2dyYW1SYW5nZVNsaWRlcjtcbiAgICB0aGlzLm9uRG9jdW1lbnRDbGlja0JpbmQgPSB0aGlzLm9uRG9jdW1lbnRDbGljay5iaW5kKHRoaXMpO1xuICB9XG4gIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgdGhpcy5zZXRGb2N1cygpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRmllbGRzUGlja0xpc3QoKTtcbiAgICB0aGlzLnJlbW92ZVVuaXF1ZVBvcG92ZXIoKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBmaWVsZE5hbWUsIHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgIC8qIGNvbnNvbGUubG9nKFxuICAgICAgXCIqKiByZW5kZXIgY29uZGl0aW9uICoqXCIsXG4gICAgICBcInVpZFwiLFxuICAgICAgdGhpcy51aWQsXG4gICAgICBcImZpZWxkTmFtZVwiLFxuICAgICAgdGhpcy5maWVsZE5hbWUsXG4gICAgICBcIm9wZXJhdG9yXCIsXG4gICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgXCJ1bmlxdWVWYWx1ZXNTb3J0QnlcIixcbiAgICAgIHRoaXMudW5pcXVlVmFsdWVzU29ydEJ5LFxuICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgdGhpcy52YWx1ZSxcbiAgICAgIFwidmFsdWUyXCIsXG4gICAgICB0aGlzLnZhbHVlMixcbiAgICAgIFwidmFsdWVzXCIsXG4gICAgICB0aGlzLnZhbHVlcyxcbiAgICAgIFwidW5pdFwiLFxuICAgICAgdGhpcy51bml0LFxuICAgICAgXCJoaXN0b2dyYW1PcGVuXCIsXG4gICAgICB0aGlzLmhpc3RvZ3JhbU9wZW4sXG4gICAgICBcImhhc0ZvY3VzXCIsXG4gICAgICB0aGlzLmhhc0ZvY3VzLFxuICAgICAgXCJoaXN0b2dyYW1TdGF0dXNcIixcbiAgICAgIGZpbHRlckZpZWxkLmhpc3RvZ3JhbVN0YXR1cyxcbiAgICAgIFwidW5pcXVlVmFsdWVzU3RhdHVzXCIsXG4gICAgICBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZXNTdGF0dXMsXG4gICAgICBcInJlUmVuZGVyXCIsXG4gICAgICB0aGlzLnJlUmVuZGVyXG4gICAgKTsgKi9cbiAgICBpZiAoIWZpbHRlckZpZWxkIHx8ICFmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpIHtcbiAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiZGl2XCIsIG51bGwpKSk7XG4gICAgfVxuICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgZGlyOiBkaXIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiB7XG4gICAgICAgIFtDU1MkMi5jb25kaXRpb25dOiB0cnVlLFxuICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogZGlyID09PSBcInJ0bFwiXG4gICAgICB9IH0sIHRoaXMucmVuZGVyRmllbGRTZWxlY3Rpb24oKSwgdGhpcy5yZW5kZXJPcGVyYXRvclNlbGVjdGlvbihmaWx0ZXJGaWVsZCksIHRoaXMucmVuZGVyVmFsdWVJbnB1dChmaWx0ZXJGaWVsZCksIHRoaXMucmVuZGVySGlzdG9ncmFtKGZpbHRlckZpZWxkKSkpKTtcbiAgfVxuICByZW5kZXJGaWVsZFNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7IGhhc0ZvY3VzLCBmaWVsZE5hbWUsIHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZmllbGRzIH0gPSBwcm9wcztcbiAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCB3aWR0aDogXCJmdWxsXCIsIHNjYWxlOiBcIm1cIiwgYWxpZ25tZW50OiBcImljb24tZW5kLXNwYWNlLWJldHdlZW5cIiwgZGlzYWJsZWQ6IGZpZWxkcy5sZW5ndGggPD0gMSwgaWNvbkVuZDogXCJjaGV2cm9uLWRvd25cIiwgY2xhc3M6IGAke2hhc0ZvY3VzID8gXCJhdXRvZm9jdXNcIiA6IFwiXCJ9YCwgb25DbGljazogZmllbGRzLmxlbmd0aCA+IDEgPyB0aGlzLm9uRmllbGRTZWxlY3QgOiBudWxsLCByZWY6IChub2RlKSA9PiAodGhpcy5maWVsZE5vZGUgPSBub2RlKSB9LCAoZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLmxhYmVsKSB8fCBcIlwiKSk7XG4gIH1cbiAgcmVuZGVyT3BlcmF0b3JTZWxlY3Rpb24oZmlsdGVyRmllbGQpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgb3BlcmF0b3JzLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICAvLyBUT0RPIC0gYWxzbyBjaGVjayBmaWVsZCB2YWx1ZSB0eXBlID9cbiAgICBsZXQgdHlwZSA9IGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5HVUlEKSB7XG4gICAgICB0eXBlID0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkc7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLk9JRCkge1xuICAgICAgdHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuTlVNQkVSO1xuICAgIH1cbiAgICBpZiAoaGFzRmllbGREb21haW5zKGZpbHRlckZpZWxkKSkge1xuICAgICAgdHlwZSA9IHNpbXBsZUZpZWxkVHlwZXMuRE9NQUlOO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25Ob2RlcyA9IG9wZXJhdG9yc1t0eXBlXS5tYXAoKG9wZXJhdG9yKSA9PiB0aGlzLnJlbmRlck9wZXJhdG9yT3B0aW9uKG9wZXJhdG9yLm5hbWUpKTtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXNlbGVjdFwiLCB7IHdpZHRoOiBcImZ1bGxcIiwgc2NhbGU6IFwibVwiLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5Lm9wZXJhdG9yLCBjbGFzczogQ1NTJDIub3BlcmF0b3JEcm9wZG93biwgb25DYWxjaXRlU2VsZWN0Q2hhbmdlOiB0aGlzLm9uT3BlcmF0b3JTZWxlY3QgfSwgb3B0aW9uTm9kZXMpKTtcbiAgfVxuICByZW5kZXJPcGVyYXRvck9wdGlvbihyZW5kZXJlck9wZXJhdG9yKSB7XG4gICAgY29uc3QgeyBvcGVyYXRvciB9ID0gdGhpcztcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLW9wdGlvblwiLCB7IHZhbHVlOiByZW5kZXJlck9wZXJhdG9yLCBsYWJlbDogcmVuZGVyZXJPcGVyYXRvciwgc2VsZWN0ZWQ6IHJlbmRlcmVyT3BlcmF0b3IgPT09IG9wZXJhdG9yIH0pKTtcbiAgfVxuICByZW5kZXJWYWx1ZUlucHV0KGZpbHRlckZpZWxkKSB7XG4gICAgY29uc3QgeyBwcm9wcywgb3BlcmF0b3IsIGludmFsaWRWYWx1ZSB9ID0gdGhpcztcbiAgICBjb25zdCBzdGF0dXMgPSBpbnZhbGlkVmFsdWUgPyBcImludmFsaWRcIiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY29udGVudE5vZGUgPSBudWxsO1xuICAgIGlmIChpc0JsYW5rT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSB8fCBpc0VtcHR5T3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSkge1xuICAgICAgY29udGVudE5vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0xpc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgICBjb250ZW50Tm9kZSA9IHRoaXMucmVuZGVyVW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJblRoZUxhc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgICBjb250ZW50Tm9kZSA9IHRoaXMucmVuZGVySW5UaGVMYXN0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkcgfHxcbiAgICAgIGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5HVUlEIHx8XG4gICAgICBoYXNGaWVsZERvbWFpbnMoZmlsdGVyRmllbGQpKSB7XG4gICAgICBjb250ZW50Tm9kZSA9IHRoaXMucmVuZGVyVmFsdWVJbnB1dFN0cmluZyhmaWx0ZXJGaWVsZCwgeyBzdGF0dXMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5OVU1CRVIpIHtcbiAgICAgIGNvbnRlbnROb2RlID0gdGhpcy5yZW5kZXJWYWx1ZUlucHV0TnVtYmVyKGZpbHRlckZpZWxkLCB7IHN0YXR1cyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoW3NpbXBsZUZpZWxkVHlwZXMuREFURSwgc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLmluZGV4T2YoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA+IC0xKSB7XG4gICAgICBjb250ZW50Tm9kZSA9IHRoaXMucmVuZGVyVmFsdWVJbnB1dERhdGUoZmlsdGVyRmllbGQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IHNpbXBsZUZpZWxkVHlwZXMuT0lEKSB7XG4gICAgICBjb250ZW50Tm9kZSA9IHRoaXMucmVuZGVyVmFsdWVJbnB1dE9pZChmaWx0ZXJGaWVsZCwgeyBzdGF0dXMgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnZhbGlkVmFsdWUgPyAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgY29udGVudE5vZGUsIGgoXCJjYWxjaXRlLWlucHV0LW1lc3NhZ2VcIiwgeyBpY29uOiB0cnVlLCBzdGF0dXM6IHN0YXR1cyB9LCBpbnZhbGlkVmFsdWUpKSkgOiAoY29udGVudE5vZGUpO1xuICB9XG4gIHJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgZGlzYWJsZWQsIGxvYWRpbmcpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGlmICghc3VwcG9ydHNVbmlxdWUgfHwgbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IGNsYXNzOiBDU1MkMi5zZWxlY3RVbmlxdWVCdXR0b24sIGRpc2FibGVkOiBkaXNhYmxlZCwgbG9hZGluZzogISFsb2FkaW5nLCB0ZXh0OiBzdHJpbmdzLmNob29zZUZyb21VbmlxdWUsIHNjYWxlOiBcInNcIiwgaWNvbjogXCJjaGV2cm9uLWRvd25cIiwgb25DbGljazogIWRpc2FibGVkID8gdGhpcy5vblNlbGVjdFVuaXF1ZVZhbHVlIDogbnVsbCwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHRoaXMudW5pcXVlQWN0aW9uTm9kZSA9IG5vZGU7XG4gICAgICAgIH0gLy8gZWxzZSBubyBpZGVhIHdoeSB0aGlzIGhhcHBlbnMgLSBUT0RPIChzZXQgb2YgMyArIDEgZXhwcilcbiAgICAgIH0gfSkpO1xuICB9XG4gIHJlbmRlclZhbHVlSW5wdXRTdHJpbmcoZmlsdGVyRmllbGQsIGlucHV0T3B0aW9ucykge1xuICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlLCBvcGVyYXRvciB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGNvbnN0IHV2U3RhdHVzID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVzU3RhdHVzO1xuICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3M7XG4gICAgY29uc3Qgc3VwcG9ydHNVbmlxdWUgPSBbc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJcywgc3RyaW5ncy5vcGVyYXRvcnMuc3RyaW5nT3BlcmF0b3JJc05vdF0uaW5kZXhPZihvcGVyYXRvcikgPiAtMTtcbiAgICBjb25zdCBkaXNhYmxlZFVuaXF1ZSA9IHN1cHBvcnRzVW5pcXVlICYmXG4gICAgICAodXZTdGF0dXMgPT09IHN0YXR1cy5GQUlMRUQgfHwgKHV2U3RhdHVzID09PSBzdGF0dXMuU1VDQ0VTUyAmJiAhKHVuaXF1ZVZhbHVlcyA9PT0gbnVsbCB8fCB1bmlxdWVWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuaXF1ZVZhbHVlcy5sZW5ndGgpKSk7XG4gICAgY29uc3QgaGFzRG9tYWlucyA9IGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZCk7XG4gICAgY29uc3QgdmFsID0gaGFzRG9tYWlucyA/IGdldERlY29kZWRWYWx1ZSh2YWx1ZSwgZmlsdGVyRmllbGQpIDogdmFsdWU7XG4gICAgY29uc3QgbG9hZGluZ1VuaXF1ZSA9IHV2U3RhdHVzID09PSBzdGF0dXMuTUlTU0lORyB8fCB1dlN0YXR1cyA9PT0gc3RhdHVzLklOX1BST0dSRVNTO1xuICAgIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLk1JU1NJTkcpIHtcbiAgICAgIHRoaXMub25EaXNwbGF5VW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNEb21haW5zID8gKGlzRGVmaW5lZCh2YWwpID8gKGgoXCJkaXZcIiwgeyBrZXk6IFwidmFsdWUtaW5wdXQtc3RyaW5nXCIgfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsga2V5OiB2YWwsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCB3aWR0aDogXCJmdWxsXCIsIHNjYWxlOiBcIm1cIiwgYWxpZ25tZW50OiBcImljb24tZW5kLXNwYWNlLWJldHdlZW5cIiwgaWNvbkVuZDogbG9hZGluZ1VuaXF1ZSA/IFwic3Bpbm5lclwiIDogZGlzYWJsZWRVbmlxdWUgPyB1bmRlZmluZWQgOiBcImNoZXZyb24tZG93blwiLCBkaXNhYmxlZDogZGlzYWJsZWRVbmlxdWUsIG9uQ2xpY2s6ICFkaXNhYmxlZFVuaXF1ZSA/IHRoaXMub25TZWxlY3RVbmlxdWVWYWx1ZSA6IHVuZGVmaW5lZCwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHRoaXMudW5pcXVlQWN0aW9uTm9kZSA9IG5vZGU7XG4gICAgICAgIH0gLy8gZWxzZSBubyBpZGVhIHdoeSB0aGlzIGhhcHBlbnMgLSBUT0RPIChzZXQgb2YgMyArIDEgZXhwcilcbiAgICAgIH0gfSwgdmFsID8gYCR7dmFsfWAgOiBgYCkpKSA6IChcbiAgICAvLyBjYWxjaXRlLWJ1dHRvbiBtdXN0IGhhdmUgdGV4dCBvciBpY29uLCBvdGhlcndpc2Ugd2lkdGggaXMgdG9vIHNtYWxsLFxuICAgIC8vIHNvIHVzZSBhIGRpdiBpbnN0ZWFkXG4gICAgaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1zdHJpbmdcIiwgY2xhc3M6IENTUyQyLmlucHV0UGx1c1VuaXF1ZSB9LCBoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LXN0cmluZy1idXR0b25cIiwgY2xhc3M6IGAke0NTUyQyLmlucHV0fSAke0NTUyQyLmJsYW5rQnV0dG9ufSAke3V2U3RhdHVzID09PSBzdGF0dXMuU1VDQ0VTUyA/IGBhY3RpdmVgIDogYGluYWN0aXZlYH1gLCB0YWJJbmRleDogLTEsIG9uQ2xpY2s6IHV2U3RhdHVzID09PSBzdGF0dXMuU1VDQ0VTUyA/IHRoaXMub25TZWxlY3RVbmlxdWVWYWx1ZSA6IHVuZGVmaW5lZCB9KSwgdGhpcy5yZW5kZXJVbmlxdWVCdXR0b24oc3VwcG9ydHNVbmlxdWUsIGRpc2FibGVkVW5pcXVlLCBsb2FkaW5nVW5pcXVlKSkpKSA6IChoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LXN0cmluZ1wiLCBjbGFzczogQ1NTJDIuaW5wdXRQbHVzVW5pcXVlIH0sIGgoXCJjYWxjaXRlLWlucHV0XCIsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHZhbCA/IGAke3ZhbH1gIDogYGAsIGNsYXNzOiBDU1MkMi5pbnB1dCwgc2NhbGU6IFwibVwiLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LnZhbHVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiB0aGlzLm9uVmFsdWVDaGFuZ2UgfSwgaW5wdXRPcHRpb25zKSksIHRoaXMucmVuZGVyVW5pcXVlQnV0dG9uKHN1cHBvcnRzVW5pcXVlLCBkaXNhYmxlZFVuaXF1ZSwgbG9hZGluZ1VuaXF1ZSkpKTtcbiAgfVxuICByZW5kZXJWYWx1ZUlucHV0TnVtYmVyKGZpbHRlckZpZWxkLCBpbnB1dE9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwcm9wcywgdmFsdWUsIHZhbHVlMiwgb3BlcmF0b3IgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCBpc0Zsb2F0ID0gaXNGbG9hdFR5cGUoZmlsdGVyRmllbGQpO1xuICAgIGlmIChbXG4gICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQmV0d2VlbixcbiAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3RCZXR3ZWVuXG4gICAgXS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtaW5wdXRcIiwgT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiBpc0RlZmluZWQodmFsdWUpID8gYCR7dmFsdWV9YCA6IGBgLCBzY2FsZTogXCJtXCIsIHN0ZXA6IGlzRmxvYXQgPyBcImFueVwiIDogMSwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS5mcm9tVmFsdWUsIG9uQ2FsY2l0ZUlucHV0SW5wdXQ6IChldmVudCkgPT4gdGhpcy53YWl0T25Vc2VyKGV2ZW50LCB0aGlzLm9uVmFsdWVDaGFuZ2VNYXliZSkgfSwgaW5wdXRPcHRpb25zKSksIGgoXCJkaXZcIiwgeyBjbGFzczogYCR7Q1NTJDIuYmV0d2VlblZhbHVlc0lucHV0fSBmaXJzdGAgfSksIGgoXCJjYWxjaXRlLWlucHV0XCIsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogaXNEZWZpbmVkKHZhbHVlMikgPyBgJHt2YWx1ZTJ9YCA6IGBgLCBzY2FsZTogXCJtXCIsIHN0ZXA6IGlzRmxvYXQgPyBcImFueVwiIDogMSwgY2xhc3M6IENTUyQyLmJldHdlZW5WYWx1ZXNJbnB1dCwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS50b1ZhbHVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZXZlbnQpID0+IHRoaXMud2FpdE9uVXNlcihldmVudCwgdGhpcy5vblZhbHVlMkNoYW5nZU1heWJlKSB9LCBpbnB1dE9wdGlvbnMpKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHV2U3RhdHVzID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVzU3RhdHVzO1xuICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvcztcbiAgICAgIGNvbnN0IHN1cHBvcnRzVW5pcXVlID0gW1xuICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzLFxuICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90LFxuICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRMZWFzdCxcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdCxcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuLFxuICAgICAgICBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTGVzc1RoYW5cbiAgICAgIF0uaW5kZXhPZihvcGVyYXRvcikgPiAtMTtcbiAgICAgIGNvbnN0IGlucHV0Tm9kZSA9IChoKFwiY2FsY2l0ZS1pbnB1dFwiLCBPYmplY3QuYXNzaWduKHsgY2xhc3M6IENTUyQyLmlucHV0LCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogaXNEZWZpbmVkKHZhbHVlKSA/IGAke3ZhbHVlfWAgOiBgYCwgc2NhbGU6IFwibVwiLCBzdGVwOiBpc0Zsb2F0ID8gXCJhbnlcIiA6IDEsIGxhYmVsOiBzdHJpbmdzLmFjY2Vzc2liaWxpdHkudmFsdWUsIG9uQ2FsY2l0ZUlucHV0SW5wdXQ6IChldmVudCkgPT4gdGhpcy53YWl0T25Vc2VyKGV2ZW50LCB0aGlzLm9uVmFsdWVDaGFuZ2UpIH0sIGlucHV0T3B0aW9ucykpKTtcbiAgICAgIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRCB8fFxuICAgICAgICAodXZTdGF0dXMgPT09IHN0YXR1cy5TVUNDRVNTICYmICEodW5pcXVlVmFsdWVzID09PSBudWxsIHx8IHVuaXF1ZVZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5pcXVlVmFsdWVzLmxlbmd0aCkpIHx8XG4gICAgICAgICFzdXBwb3J0c1VuaXF1ZSkge1xuICAgICAgICByZXR1cm4gaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1udW1iZXJcIiB9LCBpbnB1dE5vZGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HIHx8IHV2U3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuTUlTU0lORykge1xuICAgICAgICAgIHRoaXMub25EaXNwbGF5VW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LW51bWJlclwiLCBjbGFzczogQ1NTJDIuaW5wdXRQbHVzVW5pcXVlIH0sIGlucHV0Tm9kZSwgdGhpcy5yZW5kZXJVbmlxdWVCdXR0b24oc3VwcG9ydHNVbmlxdWUsIHRydWUsIHRydWUpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LW51bWJlclwiLCBjbGFzczogQ1NTJDIuaW5wdXRQbHVzVW5pcXVlIH0sIGlucHV0Tm9kZSwgdGhpcy5yZW5kZXJVbmlxdWVCdXR0b24oc3VwcG9ydHNVbmlxdWUsICEoKF9hID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlbmRlclZhbHVlSW5wdXREYXRlKGZpbHRlckZpZWxkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlLCB2YWx1ZTIsIG9wZXJhdG9yIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlldywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0aW1lWm9uZSB9ID0gdmlldztcbiAgICBjb25zdCBkYXRlU3RyaW5nID0gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdXRjVG9EYXRlUGlja2VyKHZhbHVlLCB0aW1lWm9uZSkgOiB2YWx1ZTtcbiAgICBpZiAoW3N0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2Vlbiwgc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RCZXR3ZWVuXS5pbmRleE9mKG9wZXJhdG9yKSA+IC0xKSB7XG4gICAgICBjb25zdCBkYXRlU3RyaW5nMiA9IHR5cGVvZiB2YWx1ZTIgPT09IFwibnVtYmVyXCIgPyB1dGNUb0RhdGVQaWNrZXIodmFsdWUyLCB0aW1lWm9uZSkgOiB2YWx1ZTI7XG4gICAgICAvLyBub3QgdXNpbmcgcmFuZ2Ugb3B0aW9uLCBiZWNhdXNlIHRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgZm9yIG51bWJlciBmaWVsZHNcbiAgICAgIC8vIGFuZCAnbm90IGluIGJldHdlZW4nIG1pZ2h0IGJlIHdlaXJkIGlmIHRoZSBiZXR3ZWVuIGFyZWEgaXMgaGlnaGxpZ2h0ZWQgaW4gdGhlIGNhbGVuZGFyXG4gICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtaW5wdXQtZGF0ZS1waWNrZXJcIiwgeyBjbGFzczogYCR7Q1NTJDIuZGF0ZVBpY2tlcn0gZmlyc3RgLCBzY2FsZTogXCJtXCIsIHZhbHVlOiBkYXRlU3RyaW5nLCBvdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiwgb25DYWxjaXRlSW5wdXREYXRlUGlja2VyQ2hhbmdlOiB0aGlzLm9uVmFsdWVDaGFuZ2UgfSksIGgoXCJjYWxjaXRlLWlucHV0LWRhdGUtcGlja2VyXCIsIHsgY2xhc3M6IENTUyQyLmRhdGVQaWNrZXIsIHNjYWxlOiBcIm1cIiwgdmFsdWU6IGRhdGVTdHJpbmcyLCBvdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiwgb25DYWxjaXRlSW5wdXREYXRlUGlja2VyQ2hhbmdlOiB0aGlzLm9uVmFsdWUyQ2hhbmdlIH0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdXZTdGF0dXMgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZXNTdGF0dXM7XG4gICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zO1xuICAgICAgY29uc3Qgc3VwcG9ydHNVbmlxdWUgPSBbXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT24sXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T24sXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQWZ0ZXIsXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlXG4gICAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTE7XG4gICAgICBjb25zdCBpbnB1dE5vZGUgPSAoaChcImNhbGNpdGUtaW5wdXQtZGF0ZS1waWNrZXJcIiwgeyBjbGFzczogYCR7Q1NTJDIuZGF0ZVBpY2tlcn0gJHtDU1MkMi5pbnB1dH1gLCBzY2FsZTogXCJtXCIsIHZhbHVlOiBkYXRlU3RyaW5nLCBvdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiwgb25DYWxjaXRlSW5wdXREYXRlUGlja2VyQ2hhbmdlOiB0aGlzLm9uVmFsdWVDaGFuZ2UgfSkpO1xuICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuRkFJTEVEIHx8XG4gICAgICAgICh1dlN0YXR1cyA9PT0gc3RhdHVzLlNVQ0NFU1MgJiYgISh1bmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmlxdWVWYWx1ZXMubGVuZ3RoKSkgfHxcbiAgICAgICAgIXN1cHBvcnRzVW5pcXVlKSB7XG4gICAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LWRhdGVcIiB9LCBpbnB1dE5vZGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HIHx8IHV2U3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuTUlTU0lORykge1xuICAgICAgICAgIHRoaXMub25EaXNwbGF5VW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LWRhdGVcIiwgY2xhc3M6IENTUyQyLmlucHV0UGx1c1VuaXF1ZSB9LCBpbnB1dE5vZGUsIHRoaXMucmVuZGVyVW5pcXVlQnV0dG9uKHN1cHBvcnRzVW5pcXVlLCB0cnVlLCB0cnVlKSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogXCJ2YWx1ZS1pbnB1dC1kYXRlXCIsIGNsYXNzOiBDU1MkMi5pbnB1dFBsdXNVbmlxdWUgfSwgaW5wdXROb2RlLCB0aGlzLnJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgISgoX2EgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyVmFsdWVJbnB1dE9pZChmaWx0ZXJGaWVsZCwgaW5wdXRPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlLCB2YWx1ZTIsIG9wZXJhdG9yIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5PSUQpIHtcbiAgICAgIC8vIHdlIGRvbid0IGFsbG93IGRlY2ltYWxzXG4gICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSAmJiBpc0RlZmluZWQodmFsdWUyKSkge1xuICAgICAgICBjb25zdCByb3VuZGVkVmFsID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJvdW5kZWRWYWwyID0gTWF0aC5yb3VuZCh2YWx1ZTIpO1xuICAgICAgICBpZiAocm91bmRlZFZhbCAhPT0gdmFsdWUgfHwgcm91bmRlZFZhbDIgIT09IHZhbHVlMikge1xuICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHJvdW5kZWRWYWwsIHJvdW5kZWRWYWwyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICBjb25zdCByb3VuZGVkVmFsID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICAgIGlmIChyb3VuZGVkVmFsICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHJvdW5kZWRWYWwsIHZhbHVlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzRGVmaW5lZCh2YWx1ZTIpKSB7XG4gICAgICAgIGNvbnN0IHJvdW5kZWRWYWwgPSBNYXRoLnJvdW5kKHZhbHVlMik7XG4gICAgICAgIGlmIChyb3VuZGVkVmFsICE9PSB2YWx1ZTIpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWx1ZSwgcm91bmRlZFZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFtcbiAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNCZXR3ZWVuLFxuICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdEJldHdlZW5cbiAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTEpIHtcbiAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1pbnB1dFwiLCBPYmplY3QuYXNzaWduKHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IGlzRGVmaW5lZCh2YWx1ZSkgPyBgJHt2YWx1ZX1gIDogYGAsIHNjYWxlOiBcIm1cIiwgbWluOiAwLCBzdGVwOiAxLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LmZyb21WYWx1ZSwgb25DYWxjaXRlSW5wdXRJbnB1dDogdGhpcy5vblZhbHVlQ2hhbmdlTWF5YmUgfSwgaW5wdXRPcHRpb25zKSksIGgoXCJkaXZcIiwgeyBjbGFzczogYCR7Q1NTJDIuYmV0d2VlblZhbHVlc0lucHV0fSBmaXJzdGAgfSksIGgoXCJjYWxjaXRlLWlucHV0XCIsIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogaXNEZWZpbmVkKHZhbHVlMikgPyBgJHt2YWx1ZTJ9YCA6IGBgLCBzY2FsZTogXCJtXCIsIG1pbjogMCwgc3RlcDogMSwgY2xhc3M6IENTUyQyLmJldHdlZW5WYWx1ZXNJbnB1dCwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS50b1ZhbHVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiB0aGlzLm9uVmFsdWUyQ2hhbmdlTWF5YmUgfSwgaW5wdXRPcHRpb25zKSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCB1dlN0YXR1cyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cztcbiAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlSW5mb3M7XG4gICAgICBjb25zdCBzdXBwb3J0c1VuaXF1ZSA9IFtcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJcyxcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc05vdCxcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TGVhc3QsXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNBdE1vc3QsXG4gICAgICAgIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNHcmVhdGVyVGhhbixcbiAgICAgICAgc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0xlc3NUaGFuXG4gICAgICBdLmluZGV4T2Yob3BlcmF0b3IpID4gLTE7XG4gICAgICBjb25zdCBpbnB1dE5vZGUgPSAoaChcImNhbGNpdGUtaW5wdXRcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzOiBDU1MkMi5pbnB1dCwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IGlzRGVmaW5lZCh2YWx1ZSkgPyBgJHt2YWx1ZX1gIDogYGAsIHNjYWxlOiBcIm1cIiwgbWluOiAwLCBzdGVwOiAxLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5LnZhbHVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiB0aGlzLm9uVmFsdWVDaGFuZ2UgfSwgaW5wdXRPcHRpb25zKSkpO1xuICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuRkFJTEVEIHx8XG4gICAgICAgICh1dlN0YXR1cyA9PT0gc3RhdHVzLlNVQ0NFU1MgJiYgISh1bmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmlxdWVWYWx1ZXMubGVuZ3RoKSkgfHxcbiAgICAgICAgIXN1cHBvcnRzVW5pcXVlKSB7XG4gICAgICAgIHJldHVybiBoKFwiZGl2XCIsIHsga2V5OiBcInZhbHVlLWlucHV0LW9pZFwiIH0sIGlucHV0Tm9kZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLk1JU1NJTkcgfHwgdXZTdGF0dXMgPT09IHN0YXR1cy5JTl9QUk9HUkVTUykge1xuICAgICAgICBpZiAodXZTdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HKSB7XG4gICAgICAgICAgdGhpcy5vbkRpc3BsYXlVbmlxdWVWYWx1ZXMoZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBrZXk6IFwidmFsdWUtaW5wdXQtb2lkXCIsIGNsYXNzOiBDU1MkMi5pbnB1dFBsdXNVbmlxdWUgfSwgaW5wdXROb2RlLCB0aGlzLnJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgdHJ1ZSwgdHJ1ZSkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBrZXk6IFwidmFsdWUtaW5wdXQtb2lkXCIsIGNsYXNzOiBDU1MkMi5pbnB1dFBsdXNVbmlxdWUgfSwgaW5wdXROb2RlLCB0aGlzLnJlbmRlclVuaXF1ZUJ1dHRvbihzdXBwb3J0c1VuaXF1ZSwgISgoX2EgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyVW5pcXVlVmFsdWVzKGZpbHRlckZpZWxkKSB7XG4gICAgY29uc3QgeyBwcm9wcywgdmFsdWVzLCBmaWVsZE5hbWUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCB1dlN0YXR1cyA9IGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cztcbiAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zO1xuICAgIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLk1JU1NJTkcgfHwgdXZTdGF0dXMgPT09IHN0YXR1cy5JTl9QUk9HUkVTUykge1xuICAgICAgaWYgKHV2U3RhdHVzID09PSBzdGF0dXMuTUlTU0lORykge1xuICAgICAgICB0aGlzLm9uRGlzcGxheVVuaXF1ZVZhbHVlcyhmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWxvYWRlclwiLCB7IGNsYXNzOiBDU1MkMi5zbWFsbExvYWRlciwgaW5saW5lOiB0cnVlLCBsYWJlbDogXCJcIiB9KSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dlN0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRCkge1xuICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLnVuaXF1ZVZhbHVlc0NvbnRlbnRMaXN0TXNnIH0sIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGFsaWdubWVudDogXCJjZW50ZXJcIiwgY2xhc3M6IENTUyQyLnNlbGVjdFZhbHVlcywgZGlzYWJsZWQ6IHRydWUsIGxhYmVsOiBzdHJpbmdzLnNlbGVjdFZhbHVlcyB9LCBzdHJpbmdzLnNlbGVjdFZhbHVlcyksIHN0cmluZ3MuZXJyb3JzLmVycm9yVW5pcXVlVmFsdWVzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbXNnMU5vZGUgPSAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi51bmlxdWVWYWx1ZXNDb250ZW50TGlzdE1zZyB9LCAhKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlcy5sZW5ndGgpICYmICh1bmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmlxdWVWYWx1ZXMubGVuZ3RoKSA/IHN0cmluZ3Muc2VsZWN0T25lVmFsdWUgOiBcIlwiKSk7XG4gICAgICBsZXQgbXNnMk5vZGU7XG4gICAgICBpZiAoISh1bmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmlxdWVWYWx1ZXMubGVuZ3RoKSkge1xuICAgICAgICBtc2cyTm9kZSA9IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQyLnVuaXF1ZVZhbHVlc0NvbnRlbnRMaXN0TXNnIH0sIHN0cmluZ3MuZXJyb3JzLm5vVW5pcXVlVmFsdWVzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLm1hcCgodmFsdWUpID0+IHRoaXMucmVuZGVyU2VsZWN0ZWRVbmlxdWVWYWx1ZSh2YWx1ZSwgZmlsdGVyRmllbGQpKTtcbiAgICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBtc2cxTm9kZSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCB3aWR0aDogXCJmdWxsXCIsIHNjYWxlOiBcIm1cIiwgYWxpZ25tZW50OiBcImNlbnRlclwiLCBjbGFzczogQ1NTJDIuc2VsZWN0VmFsdWVzLCBkaXNhYmxlZDogISh1bmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmlxdWVWYWx1ZXMubGVuZ3RoKSwgb25DbGljazogKHVuaXF1ZVZhbHVlcyA9PT0gbnVsbCB8fCB1bmlxdWVWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuaXF1ZVZhbHVlcy5sZW5ndGgpID4gMCA/IHRoaXMub25TZWxlY3RVbmlxdWVWYWx1ZXMgOiBudWxsLCByZWY6IChub2RlKSA9PiAodGhpcy51bmlxdWVTZWxlY3ROb2RlID0gbm9kZSksIGxhYmVsOiBzdHJpbmdzLnNlbGVjdFZhbHVlcyB9LCBzdHJpbmdzLnNlbGVjdFZhbHVlcyksIG1zZzJOb2RlLCAodmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmxlbmd0aCkgPyAoaChcImNhbGNpdGUtdmFsdWUtbGlzdFwiLCB7IGtleTogYHVuaXF1ZS12YWx1ZXMtdmFsdWUtbGlzdC0ke2ZpZWxkTmFtZX1gLCBjbGFzczogQ1NTJDIucGlja0xpc3QsIHJlZjogdGhpcy5hZnRlckNyZWF0ZUxpc3QgfSwgbGlzdCkpIDogbnVsbCkpO1xuICAgIH1cbiAgfVxuICByZW5kZXJTZWxlY3RlZFVuaXF1ZVZhbHVlKHZhbHVlLCBmaWx0ZXJGaWVsZCkge1xuICAgIGNvbnN0IHsgaW50bCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aWV3LCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHRpbWVab25lIH0gPSB2aWV3O1xuICAgIGNvbnN0IHZhbCA9IGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZClcbiAgICAgID8gZ2V0RGVjb2RlZFZhbHVlKHZhbHVlLCBmaWx0ZXJGaWVsZClcbiAgICAgIDogaXNEYXRlVHlwZShmaWx0ZXJGaWVsZClcbiAgICAgICAgPyBnZXREYXRlRGlzcGxheVN0cmluZyh2YWx1ZSwgdGltZVpvbmUsIGludGwpIC8vaW50bC5mb3JtYXREYXRlKG5ldyBEYXRlKHZhbHVlKSwgaW50bC5jb252ZXJ0RGF0ZUZvcm1hdFRvSW50bE9wdGlvbnMoXCJzaG9ydC1kYXRlXCIpKVxuICAgICAgICA6IGlzRGF0ZU9ubHlUeXBlKGZpbHRlckZpZWxkKVxuICAgICAgICAgID8gaW50bC5mb3JtYXREYXRlT25seSh2YWx1ZSwgaW50bC5jb252ZXJ0RGF0ZUZvcm1hdFRvSW50bE9wdGlvbnMoXCJzaG9ydC1kYXRlXCIpKVxuICAgICAgICAgIDogaXNOdW1iZXJUeXBlKGZpbHRlckZpZWxkKVxuICAgICAgICAgICAgPyBpbnRsLmZvcm1hdE51bWJlcih2YWx1ZSlcbiAgICAgICAgICAgIDogdmFsdWU7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIiwgeyBsYWJlbDogYCR7dmFsfWAsIHZhbHVlOiBgJHt2YWx1ZX1gIH0sIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IHNsb3Q6IFwiYWN0aW9ucy1lbmRcIiwgdGV4dDogc3RyaW5ncy5yZW1vdmUsIGljb246IFwieFwiLCBvbkNsaWNrOiB0aGlzLm9uUmVtb3ZlU2VsZWN0ZWRWYWx1ZS5iaW5kKHRoaXMsIHZhbHVlKSB9KSkpO1xuICB9XG4gIHJlbmRlckluVGhlTGFzdCgpIHtcbiAgICBjb25zdCB7IHByb3BzLCB2YWx1ZSwgdW5pdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi5pblRoZUxhc3QgfSwgaChcImNhbGNpdGUtaW5wdXRcIiwgeyB0eXBlOiBcIm51bWJlclwiLCBtaW46IDEsIHN0ZXA6IDEsIHZhbHVlOiBpc0RlZmluZWQodmFsdWUpID8gYCR7dmFsdWV9YCA6IGBgLCBzY2FsZTogXCJtXCIsIGNsYXNzOiBDU1MkMi5pblRoZUxhc3RDb3VudCwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS52YWx1ZSwgb25DYWxjaXRlSW5wdXRJbnB1dDogdGhpcy5vblZhbHVlQ2hhbmdlIH0pLCBoKFwiY2FsY2l0ZS1zZWxlY3RcIiwgeyB3aWR0aDogXCJmdWxsXCIsIHNjYWxlOiBcIm1cIiwgbGFiZWw6IHN0cmluZ3MuYWNjZXNzaWJpbGl0eS51bml0cywgY2xhc3M6IENTUyQyLmluVGhlTGFzdFVuaXQsIG9uQ2FsY2l0ZVNlbGVjdENoYW5nZTogdGhpcy5vblVuaXRTZWxlY3QgfSwgdGhpcy5yZW5kZXJJblRoZUxhc3RPcHRpb24odGltZVVuaXRzLk1JTlVURSwgdW5pdCA9PT0gdGltZVVuaXRzLk1JTlVURSksIHRoaXMucmVuZGVySW5UaGVMYXN0T3B0aW9uKHRpbWVVbml0cy5IT1VSLCB1bml0ID09PSB0aW1lVW5pdHMuSE9VUiksIHRoaXMucmVuZGVySW5UaGVMYXN0T3B0aW9uKHRpbWVVbml0cy5EQVksIHVuaXQgPT09IHRpbWVVbml0cy5EQVkpLCB0aGlzLnJlbmRlckluVGhlTGFzdE9wdGlvbih0aW1lVW5pdHMuV0VFSywgdW5pdCA9PT0gdGltZVVuaXRzLldFRUspLCB0aGlzLnJlbmRlckluVGhlTGFzdE9wdGlvbih0aW1lVW5pdHMuTU9OVEgsIHVuaXQgPT09IHRpbWVVbml0cy5NT05USCksIHRoaXMucmVuZGVySW5UaGVMYXN0T3B0aW9uKHRpbWVVbml0cy5ZRUFSLCB1bml0ID09PSB0aW1lVW5pdHMuWUVBUikpKSk7XG4gIH1cbiAgcmVuZGVySW5UaGVMYXN0T3B0aW9uKHVuaXQsIGlzU2VsZWN0ZWQpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyB2YWx1ZTogdW5pdCwgbGFiZWw6IHN0cmluZ3MudW5pdHNbdW5pdF0sIHNlbGVjdGVkOiBpc1NlbGVjdGVkIH0pKTtcbiAgfVxuICByZW5kZXJIaXN0b2dyYW0oZmlsdGVyRmllbGQpIHtcbiAgICBjb25zdCB7IHByb3BzLCBoaXN0b2dyYW1PcGVuLCBvcGVyYXRvciwgZmllbGROYW1lIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGlmIChsYXllci50eXBlID09PSBcImltYWdlcnlcIiB8fCBsYXllci50eXBlID09PSBcInN1YnR5cGUtZ3JvdXBcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghZmlsdGVyRmllbGQgfHwgIWZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJGaWVsZC5zdGF0aXN0aWNzU3RhdHVzID09PSBzdGF0dXMuRkFJTEVEKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFzdXBwb3J0c0hpc3RvZ3JhbShmaWVsZE5hbWUsIG9wZXJhdG9yLCBwcm9wcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaGlzdG9ncmFtT3BlbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoaGlzdG9ncmFtT3BlbiAmJiBmaWx0ZXJGaWVsZC5oaXN0b2dyYW1TdGF0dXMgPT09IHN0YXR1cy5NSVNTSU5HKSkge1xuICAgICAgLy8gb3BlbiBoaXN0b2dyYW0gYmxvY2sgYnkgZGVmYXVsdDsgb3IgZ2V0IGluZm8gd2UgbmVlZFxuICAgICAgdGhpcy5vbkhpc3RvZ3JhbU9wZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9jay1zZWN0aW9uXCIsIHsgb3BlbjogaGlzdG9ncmFtT3BlbiAhPT0gZmFsc2UsIHRleHQ6IGZpbHRlckZpZWxkLmhpc3RvZ3JhbVN0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRCA/IHN0cmluZ3MudmFsdWVSYW5nZSA6IHN0cmluZ3MuaGlzdG9ncmFtLCBvbkNhbGNpdGVCbG9ja1NlY3Rpb25Ub2dnbGU6IHRoaXMub25IaXN0b2dyYW1CbG9ja1RvZ2dsZSB9LCB0aGlzLnJlbmRlckhpc3RvZ3JhbUNvbnRlbnQoZmlsdGVyRmllbGQpKSk7XG4gIH1cbiAgcmVuZGVySGlzdG9ncmFtQ29udGVudChmaWx0ZXJGaWVsZCkge1xuICAgIGNvbnN0IHsgaGlzdG9ncmFtT3BlbiB9ID0gdGhpcztcbiAgICBjb25zdCBmaWVsZE5hbWUgPSBmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWU7XG4gICAgaWYgKGhpc3RvZ3JhbU9wZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFmaWx0ZXJGaWVsZC5zdGF0aXN0aWNzIHx8IGZpbHRlckZpZWxkLmhpc3RvZ3JhbVN0YXR1cyA9PT0gc3RhdHVzLklOX1BST0dSRVNTKSB7XG4gICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBrZXk6IGBoaXN0b2dyYW0tY29udGVudC0ke2ZpZWxkTmFtZX0tJHtmaWx0ZXJGaWVsZC5zdGF0aXN0aWNzfWAsIGNsYXNzOiBmaWx0ZXJGaWVsZC5oaXN0b2dyYW0gPyBDU1MkMi5oaXN0b2dyYW1Db250ZW50IDogQ1NTJDIuaGlzdG9ncmFtQ29udGVudFNsaW0gfSwgaChcImNhbGNpdGUtbG9hZGVyXCIsIHsgY2xhc3M6IENTUyQyLnNtYWxsTG9hZGVyLCBpbmxpbmU6IHRydWUsIGxhYmVsOiBcIlwiIH0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3Qgb2sgPSB0aGlzLnByZXBhcmVTbGlkZXIoZmlsdGVyRmllbGQpO1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGtleTogYGhpc3RvZ3JhbS1jb250ZW50LSR7ZmllbGROYW1lfS0ke2ZpbHRlckZpZWxkLnN0YXRpc3RpY3N9YCwgY2xhc3M6IGAke2ZpbHRlckZpZWxkLmhpc3RvZ3JhbSA/IENTUyQyLmhpc3RvZ3JhbUNvbnRlbnQgOiBDU1MkMi5oaXN0b2dyYW1Db250ZW50U2xpbX1gLCByZWY6IHRoaXMuYWZ0ZXJDcmVhdGVTbGlkZXJEaXYgfSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGRvbid0IGhhdmUgYSBzbGlkZXIgeWV0LCBuZWVkIHRvIHdhaXQgYSBsaXR0bGUgbG9uZ2VyXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHNldEZvY3VzKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuaG9zdEVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5hdXRvZm9jdXNcIik7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlLnNldEZvY3VzKCk7XG4gICAgICB9XG4gICAgfSwgNTAwKTtcbiAgfVxuICBvblNlbGVjdFVuaXF1ZShtdWx0aXBsZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHByb3BzLCB2YWx1ZSwgdmFsdWVzLCBmaWVsZE5hbWUsIHVpZCwgdW5pcXVlVmFsdWVzU29ydEJ5LCBlc3JpTGFuZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MsIGxvY2FsZUludGwgfSA9IHByb3BzO1xuICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgaWYgKHRoaXMudW5pcXVlUG9wb3Zlck5vZGUpIHtcbiAgICAgIHRoaXMuY2xvc2VGaWx0ZXJQb3BvdmVyc0hhbmRsZXIoKTtcbiAgICAgIC8vIGp1c3QgY2xvc2UgdGhlIHBvcG92ZXJcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jbG9zZUZpbHRlclBvcG92ZXJzSGFuZGxlcigpO1xuICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgIGlmICghZmlsdGVyRmllbGQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVdpZHRoID0gKF9hID0gdGhpcy5maWVsZE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICBjb25zdCB3aWR0aCA9IG5vZGVXaWR0aCA/IG5vZGVXaWR0aCArIDIgOiAyMDQ7XG4gICAgLy8gd2UgY2FuJ3QgdXNlIGEgcGFuZWwgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGEgaGVhZGVyXG4gICAgY29uc3QgcGFuZWxOb2RlID0gcXVlcnlQYXJlbnRFbGVtZW50KHRoaXMuaG9zdEVsZW1lbnQsIFwiY2FsY2l0ZS1wYW5lbFwiKTtcbiAgICBjb25zdCBub2RlSGVpZ2h0ID0gcGFuZWxOb2RlID09PSBudWxsIHx8IHBhbmVsTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZWxOb2RlLmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSBub2RlSGVpZ2h0ID8gTWF0aC5tYXgoTWF0aC5taW4obm9kZUhlaWdodCAvIDMsIDQwMCksIDI0MCkgOiA0MDA7XG4gICAgY29uc3QgcG9wb3ZlclVuaXF1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYWxjaXRlLXBvcG92ZXJcIik7XG4gICAgcG9wb3ZlclVuaXF1ZS5pZCA9IGBhcmNnaXMtZmlsdGVyLXVuaXF1ZS1wb3BvdmVyXyR7dWlkfWA7XG4gICAgcG9wb3ZlclVuaXF1ZS5wbGFjZW1lbnQgPSBkaXIgPT09IFwicnRsXCIgPyBcImJvdHRvbS1zdGFydFwiIDogXCJib3R0b20tZW5kXCI7XG4gICAgcG9wb3ZlclVuaXF1ZS5vZmZzZXREaXN0YW5jZSA9IDA7XG4gICAgcG9wb3ZlclVuaXF1ZS5vZmZzZXRTa2lkZGluZyA9IDA7XG4gICAgcG9wb3ZlclVuaXF1ZS5wb2ludGVyRGlzYWJsZWQgPSB0cnVlO1xuICAgIHBvcG92ZXJVbmlxdWUuc3R5bGUgPSBgd2lkdGg6ICR7d2lkdGh9cHg7YDtcbiAgICBwb3BvdmVyVW5pcXVlLnJlZmVyZW5jZUVsZW1lbnQgPSBtdWx0aXBsZSA/IHRoaXMudW5pcXVlU2VsZWN0Tm9kZSA6IHRoaXMudW5pcXVlQWN0aW9uTm9kZTtcbiAgICBjb25zdCB1bmlxdWVMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1maWx0ZXItdW5pcXVlLWxpc3RcIik7XG4gICAgdW5pcXVlTGlzdC51aWQgPSB1aWQ7XG4gICAgdW5pcXVlTGlzdC5wcm9wcyA9IHByb3BzO1xuICAgIHVuaXF1ZUxpc3QudW5pcXVlVmFsdWVzID0gZXNyaUxhbmcuY2xvbmUoZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvcyk7XG4gICAgdW5pcXVlTGlzdC5zZWxlY3RlZFZhbHVlcyA9IG11bHRpcGxlID8gdmFsdWVzIDogdmFsdWUgPyBbdmFsdWVdIDogW107XG4gICAgdW5pcXVlTGlzdC5maWVsZERvbWFpbnMgPSBmaWx0ZXJGaWVsZC5maWVsZERvbWFpbnM7XG4gICAgdW5pcXVlTGlzdC5sYXllckZpZWxkVHlwZSA9IGZpbHRlckZpZWxkLmxheWVyRmllbGQudHlwZTtcbiAgICB1bmlxdWVMaXN0LmlzRGF0ZSA9XG4gICAgICBbc2ltcGxlRmllbGRUeXBlcy5EQVRFLCBzaW1wbGVGaWVsZFR5cGVzLkRBVEVfT05MWV0uaW5kZXhPZihmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpID4gLTE7XG4gICAgdW5pcXVlTGlzdC5tdWx0aXBsZSA9IG11bHRpcGxlO1xuICAgIHVuaXF1ZUxpc3Quc29ydEJ5ID0gdW5pcXVlVmFsdWVzU29ydEJ5O1xuICAgIHVuaXF1ZUxpc3QucGFydGlhbFVuaXF1ZVZhbHVlcyA9IGZpbHRlckZpZWxkLnBhcnRpYWxVbmlxdWVWYWx1ZXM7XG4gICAgdW5pcXVlTGlzdC5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdW5pcXVlTGlzdC5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB1bmlxdWVMaXN0LmxvY2FsZSA9IGxvY2FsZUludGw7XG4gICAgLy8gb3RoZXJ3aXNlIHRoZXJlJ3MgYW4gaXNzdWUgd2l0aCB0aGUgd2lkdGggb2YgdGhlIGxpc3QuLi5cbiAgICB1bmlxdWVMaXN0LnN0eWxlID0gYG1pbi13aWR0aDogJHt3aWR0aH1weGA7XG4gICAgcG9wb3ZlclVuaXF1ZS5hcHBlbmRDaGlsZCh1bmlxdWVMaXN0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXJVbmlxdWUpO1xuICAgIHBvcG92ZXJVbmlxdWUub3BlbiA9IHRydWU7XG4gICAgZm9yY2VVcGRhdGUodW5pcXVlTGlzdCk7XG4gICAgdW5pcXVlTGlzdC5zZXRGb2N1cygpO1xuICAgIHBvcG92ZXJVbmlxdWUucmVwb3NpdGlvbigpO1xuICAgIHRoaXMudW5pcXVlUG9wb3Zlck5vZGUgPSBwb3BvdmVyVW5pcXVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25Eb2N1bWVudENsaWNrQmluZCk7XG4gICAgfSwgNTApO1xuICB9XG4gIHNjcm9sbEV4cHJJbnRvVmlldyhub2RlKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlID0gcXVlcnlQYXJlbnRFbGVtZW50KG5vZGUsIFwiLmZpbHRlci1leHByZXNzaW9uXCIpO1xuICAgICAgICBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIixcbiAgICAgICAgICBpbmxpbmU6IFwic3RhcnRcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9XG4gIHJlbW92ZVVuaXF1ZVBvcG92ZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uRG9jdW1lbnRDbGlja0JpbmQpO1xuICAgIGlmICh0aGlzLnVuaXF1ZVBvcG92ZXJOb2RlKSB7XG4gICAgICAvKiBjb25zdCBwb3BvdmVyID0gdGhpcy51bmlxdWVQb3BvdmVyTm9kZT8uY2hpbGROb2Rlcz8uWzBdIGFzIEhUTUxDYWxjaXRlUG9wb3ZlckVsZW1lbnQ7XG4gICAgICBpZiAocG9wb3Zlcikge1xuICAgICAgICBwb3BvdmVyLm9wZW4gPSBmYWxzZTtcbiAgICAgIH0gKi9cbiAgICAgIHRoaXMudW5pcXVlUG9wb3Zlck5vZGUub3BlbiA9IGZhbHNlO1xuICAgICAgLy8gbmVlZCB0aGUgPyBoZXJlLi4uXG4gICAgICAoX2EgPSB0aGlzLnVuaXF1ZVBvcG92ZXJOb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnVuaXF1ZVBvcG92ZXJOb2RlKTtcbiAgICAgIHRoaXMudW5pcXVlUG9wb3Zlck5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGFzeW5jIG9uRGlzcGxheVVuaXF1ZVZhbHVlcyhmaWVsZE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwcm9wcywgdW5pcXVlVmFsdWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5ZXIsIHZpZXcsIGZlYXR1cmVSZWR1Y3Rpb24gfSA9IHByb3BzO1xuICAgIGNvbnN0IGZpbHRlckZpZWxkID0gZ2V0RmllbGRJbmZvKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgIGlmICghZmlsdGVyRmllbGQgfHwgbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgbGF5ZXIudHlwZSA9PT0gXCJzdWJ0eXBlLWdyb3VwXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cyA9PT0gc3RhdHVzLk1JU1NJTkcgJiYgbGF5ZXIpIHtcbiAgICAgIGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cyA9IHN0YXR1cy5JTl9QUk9HUkVTUztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlc1Jlc3VsdCA9IGF3YWl0IHVuaXF1ZVZhbHVlcyh7XG4gICAgICAgICAgbGF5ZXIsXG4gICAgICAgICAgdmlldyxcbiAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxuICAgICAgICAgIGZvckJpbm5pbmc6IGZlYXR1cmVSZWR1Y3Rpb24gJiYgW1wiYmlubmluZ1wiLCBcImNsdXN0ZXJcIl0uaW5kZXhPZigoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPiAtMVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdW5pcXVlVmFsdWVJbmZvczogW3t2YWx1ZSwgY291bnR9LC4uLl1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInN1Y2Nlc3MtdW5pcXVlVmFsdWVzXCIsIHVuaXF1ZVZhbHVlc1Jlc3VsdCk7XG4gICAgICAgIC8vIGUuZy4gY29kZWQgdmFsdWUgZG9tYWluc1xuICAgICAgICBjb25zdCBpc051bWJlciA9IGlzTnVtYmVyVHlwZShmaWx0ZXJGaWVsZCk7XG4gICAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlSW5mb3MgPSB1bmlxdWVWYWx1ZXNSZXN1bHQudW5pcXVlVmFsdWVJbmZvcy5maWx0ZXIoKGluZm8pID0+IHtcbiAgICAgICAgICAvLyB2YWx1ZSBpcyBhbHdheXMgYSBzdHJpbmcsIGJlY2F1c2Ugd2UgcmVhZCBpdCBmcm9tIHRoZSByZW5kZXJlclxuICAgICAgICAgIGlmICghaXNEZWZpbmVkKGluZm8udmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IFwic3RyaW5nXCIgJiYgIWlzTnVtYmVyKSB8fFxuICAgICAgICAgICAgZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlID09PSBcImd1aWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluZm8udmFsdWUgIT09IFwiPE51bGw+XCIgJiYgYCR7aW5mby52YWx1ZX1gLnRyaW0oKSAhPT0gXCJcIjsgLy8gd2UgZG9uJ3QgYWxsb3cgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gXCJvaWRcIiB8fFxuICAgICAgICAgICAgaXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvLnZhbHVlICE9PSBcIjxOdWxsPlwiICYmIGluZm8udmFsdWUgIT09IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gXCJkYXRlXCJcbiAgICAgICAgICAgIHJldHVybiBpbmZvLnZhbHVlICE9PSBcIjxOdWxsPlwiICYmIGluZm8udmFsdWUgIT09IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc29ydCBieSBjb3VudFxuICAgICAgICB1bmlxdWVWYWx1ZUluZm9zLnNvcnQoKGEsIGIpID0+IGEuY291bnQgPiBiLmNvdW50ID8gLTEgOiBhLmNvdW50IDwgYi5jb3VudCA/IDEgOiAwKTtcbiAgICAgICAgaWYgKGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgICAvLyBhZGQgZG9tYWlucyB0aGF0IGFyZSBub3QgdXNlZCBpbiBhbnkgZmVhdHVyZVxuICAgICAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucy5mb3JFYWNoKChmaWVsZERvbWFpbikgPT4ge1xuICAgICAgICAgICAgaWYgKCF1bmlxdWVWYWx1ZUluZm9zLmZpbmQoKG9iaikgPT4gb2JqLnZhbHVlID09PSBmaWVsZERvbWFpbi5jb2RlKSkge1xuICAgICAgICAgICAgICB1bmlxdWVWYWx1ZUluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmaWVsZERvbWFpbi5jb2RlLFxuICAgICAgICAgICAgICAgIGNvdW50OiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gcGFydGlhbERhdGFcbiAgICAgICAgY29uc3QgcGFydGlhbFVuaXF1ZVZhbHVlcyA9IHVuaXF1ZVZhbHVlc1Jlc3VsdC51bmlxdWVWYWx1ZUluZm9zLmxlbmd0aCA9PT0gMjAwMDtcbiAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyB1bmlxdWVWYWx1ZUluZm9zLCB1bmlxdWVWYWx1ZXNTdGF0dXM6IHN0YXR1cy5TVUNDRVNTLCBwYXJ0aWFsVW5pcXVlVmFsdWVzIH0pIDogZmllbGQpO1xuICAgICAgICB0aGlzLmFyY2dpc0ZpbHRlclVuaXF1ZVZhbHVlc1JldHVybmVkLmVtaXQoZmlsdGVyRmllbGQubGF5ZXJGaWVsZC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZXJyb3ItdW5pcXVlVmFsdWVzXCIsIGVycm9yKTtcbiAgICAgICAgaWYgKGhhc0ZpZWxkRG9tYWlucyhmaWx0ZXJGaWVsZCkpIHtcbiAgICAgICAgICAvLyB1c2UgZG9tYWlucyBmcm9tIGxheWVyXG4gICAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVJbmZvcyA9IFtdO1xuICAgICAgICAgIGZpbHRlckZpZWxkLmZpZWxkRG9tYWlucy5mb3JFYWNoKChmaWVsZERvbWFpbikgPT4ge1xuICAgICAgICAgICAgaWYgKCF1bmlxdWVWYWx1ZUluZm9zLmZpbmQoKG9iaikgPT4gb2JqLnZhbHVlID09PSBmaWVsZERvbWFpbi5jb2RlKSkge1xuICAgICAgICAgICAgICB1bmlxdWVWYWx1ZUluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmaWVsZERvbWFpbi5jb2RlLFxuICAgICAgICAgICAgICAgIGNvdW50OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB7IHVuaXF1ZVZhbHVlSW5mb3MsIHVuaXF1ZVZhbHVlc1N0YXR1czogc3RhdHVzLlNVQ0NFU1MsIHBhcnRpYWxVbmlxdWVWYWx1ZXM6IGZhbHNlIH0pIDogZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyB1bmlxdWVWYWx1ZXNTdGF0dXM6IHN0YXR1cy5GQUlMRUQgfSkgOiBmaWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBvbkhpc3RvZ3JhbU9wZW4oKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IHByb3BzLCBmaWVsZE5hbWUsIHN1bW1hcnlTdGF0aXN0aWNzLCBoaXN0b2dyYW0gfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXllciwgdmlldywgZmVhdHVyZVJlZHVjdGlvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgaWYgKCFsYXllciB8fCBsYXllci50eXBlID09PSBcImltYWdlcnlcIiB8fCBsYXllci50eXBlID09PSBcInN1YnR5cGUtZ3JvdXBcIiB8fCAhZmlsdGVyRmllbGQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZpbHRlckZpZWxkLnN0YXRpc3RpY3MpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWZhdWx0VmFsdWVzKGZpbHRlckZpZWxkKTtcbiAgICAgIHRoaXMuaGlzdG9ncmFtT3BlbiA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFmaWx0ZXJGaWVsZC5zdGF0aXN0aWNzKSB7XG4gICAgICBwcm9wcy5maWVsZHMgPSBwcm9wcy5maWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubGF5ZXJGaWVsZC5uYW1lID09PSBmaWVsZE5hbWVcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBzdGF0aXN0aWNzU3RhdHVzOiBzdGF0dXMuSU5fUFJPR1JFU1MgfSkgOiBmaWVsZCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGF0aXN0aWNzID0gYXdhaXQgc3VtbWFyeVN0YXRpc3RpY3Moe1xuICAgICAgICAgIGxheWVyLFxuICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgZmllbGQ6IGZpZWxkTmFtZSxcbiAgICAgICAgICBmb3JCaW5uaW5nOiBmZWF0dXJlUmVkdWN0aW9uICYmIFtcImJpbm5pbmdcIiwgXCJjbHVzdGVyXCJdLmluZGV4T2YoKF9hID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID4gLTFcbiAgICAgICAgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJzdWNjZXNzLXN0YXRpc3RpY3NcIiwgZmllbGROYW1lLCBzdGF0aXN0aWNzKTtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQoc3RhdGlzdGljcy5hdmcpIHx8XG4gICAgICAgICAgIWlzRGVmaW5lZChzdGF0aXN0aWNzLm1pbikgfHxcbiAgICAgICAgICAhaXNEZWZpbmVkKHN0YXRpc3RpY3MubWF4KSkge1xuICAgICAgICAgIC8vIGZpZWxkIGhhcyBtYXliZSBubyB2YWx1ZXM7IHN0YXRpc3RpY3MgaXMgdW51c2FibGVcbiAgICAgICAgICBwcm9wcy5maWVsZHMgPSBwcm9wcy5maWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubGF5ZXJGaWVsZC5uYW1lID09PSBmaWVsZE5hbWVcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIHsgc3RhdGlzdGljc1N0YXR1czogc3RhdHVzLkZBSUxFRCB9KSA6IGZpZWxkKTtcbiAgICAgICAgICB0aGlzLmhpc3RvZ3JhbU9wZW4gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRpc3RpY3MubWluID09PSBzdGF0aXN0aWNzLm1heCkge1xuICAgICAgICAgIGlmIChzdGF0aXN0aWNzLm1pbiA+IDApIHtcbiAgICAgICAgICAgIHN0YXRpc3RpY3MubWluID0gc3RhdGlzdGljcy5taW4gLSAwLjEgKiBzdGF0aXN0aWNzLm1pbjtcbiAgICAgICAgICAgIHN0YXRpc3RpY3MubWF4ID0gc3RhdGlzdGljcy5tYXggKyAwLjEgKiBzdGF0aXN0aWNzLm1heDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc3RhdGlzdGljcy5taW4gPCAwKSB7XG4gICAgICAgICAgICBzdGF0aXN0aWNzLm1pbiA9IHN0YXRpc3RpY3MubWluICsgMC4xICogc3RhdGlzdGljcy5taW47XG4gICAgICAgICAgICBzdGF0aXN0aWNzLm1heCA9IHN0YXRpc3RpY3MubWF4IC0gMC4xICogc3RhdGlzdGljcy5tYXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGlzdGljcy5taW4gPSAtMTtcbiAgICAgICAgICAgIHN0YXRpc3RpY3MubWF4ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBzdGF0aXN0aWNzLCBzdGF0aXN0aWNzU3RhdHVzOiBzdGF0dXMuU1VDQ0VTUyB9KSA6IGZpZWxkKTtcbiAgICAgICAgdGhpcy5jaGVja0RlZmF1bHRWYWx1ZXMoZmlsdGVyRmllbGQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhpc3RvZ3JhbSh7XG4gICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxuICAgICAgICAgICAgbnVtQmluczogMzAsXG4gICAgICAgICAgICBtaW5WYWx1ZTogc3RhdGlzdGljcy5taW4sXG4gICAgICAgICAgICBtYXhWYWx1ZTogc3RhdGlzdGljcy5tYXgsXG4gICAgICAgICAgICBmb3JCaW5uaW5nOiBmZWF0dXJlUmVkdWN0aW9uICYmIFtcImJpbm5pbmdcIiwgXCJjbHVzdGVyXCJdLmluZGV4T2YoKF9iID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID4gLTFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3VjY2Vzcy1oaXN0b2dyYW1cIiwgZmllbGROYW1lLCByZXN1bHQpO1xuICAgICAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBoaXN0b2dyYW06IHJlc3VsdCwgaGlzdG9ncmFtU3RhdHVzOiBzdGF0dXMuU1VDQ0VTUyB9KSA6IGZpZWxkKTtcbiAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImVycm9yLWhpc3RvZ3JhbVwiLCBlcnJvcik7XG4gICAgICAgICAgcHJvcHMuZmllbGRzID0gcHJvcHMuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLmxheWVyRmllbGQubmFtZSA9PT0gZmllbGROYW1lXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB7IGhpc3RvZ3JhbVN0YXR1czogc3RhdHVzLkZBSUxFRCB9KSA6IGZpZWxkKTtcbiAgICAgICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZXJyb3Itc3VtbWFyeVN0YXRpc3RpY3NcIiwgZXJyb3IpO1xuICAgICAgICBwcm9wcy5maWVsZHMgPSBwcm9wcy5maWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubGF5ZXJGaWVsZC5uYW1lID09PSBmaWVsZE5hbWVcbiAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB7IHN0YXRpc3RpY3NTdGF0dXM6IHN0YXR1cy5GQUlMRUQsIGhpc3RvZ3JhbVN0YXR1czogc3RhdHVzLkZBSUxFRCB9KSA6IGZpZWxkKTtcbiAgICAgICAgdGhpcy5oaXN0b2dyYW1PcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25IaXN0b2dyYW1DbG9zZSgpIHtcbiAgICB0aGlzLmhpc3RvZ3JhbU9wZW4gPSBmYWxzZTtcbiAgfVxuICBhc3luYyBvbk1pbk1heENoYW5nZShtaW4sIG1heCwgZmllbGROYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgcHJvcHMsIHZhbHVlLCB2YWx1ZTIsIGhpc3RvZ3JhbSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyLCB2aWV3LCBmZWF0dXJlUmVkdWN0aW9uIH0gPSBwcm9wcztcbiAgICBjb25zdCBmaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICBpZiAoIWZpbHRlckZpZWxkIHx8IGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiIHx8IGxheWVyLnR5cGUgPT09IFwic3VidHlwZS1ncm91cFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlMikpIHtcbiAgICAgIHRoaXMudmFsdWUyID0gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUyLCBtaW4pLCBtYXgpO1xuICAgIH1cbiAgICB0aGlzLmhpc3RvZ3JhbU9wZW4gPSB0cnVlO1xuICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBoaXN0b2dyYW1TdGF0dXM6IHN0YXR1cy5JTl9QUk9HUkVTUyB9KSA6IGZpZWxkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGlzdG9ncmFtKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXcsXG4gICAgICAgIGZpZWxkOiBmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUsXG4gICAgICAgIG51bUJpbnM6IDMwLFxuICAgICAgICBtaW5WYWx1ZTogbWluLFxuICAgICAgICBtYXhWYWx1ZTogbWF4LFxuICAgICAgICBmb3JCaW5uaW5nOiBmZWF0dXJlUmVkdWN0aW9uICYmIFtcImJpbm5pbmdcIiwgXCJjbHVzdGVyXCJdLmluZGV4T2YoKF9hID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID4gLTFcbiAgICAgIH0pO1xuICAgICAgLy9jb25zb2xlLmxvZyhcInN1Y2Nlc3MtaGlzdG9ncmFtXCIsIHJlc3VsdCk7XG4gICAgICBwcm9wcy5maWVsZHMgPSBwcm9wcy5maWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubGF5ZXJGaWVsZC5uYW1lID09PSBmaWVsZE5hbWVcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkKSwgeyBoaXN0b2dyYW06IHJlc3VsdCwgaGlzdG9ncmFtU3RhdHVzOiBzdGF0dXMuU1VDQ0VTUyB9KSA6IGZpZWxkKTtcbiAgICAgIHRoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiZXJyb3ItaGlzdG9ncmFtXCIsIGVycm9yKTtcbiAgICAgIHByb3BzLmZpZWxkcyA9IHByb3BzLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5sYXllckZpZWxkLm5hbWUgPT09IGZpZWxkTmFtZVxuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGQpLCB7IGhpc3RvZ3JhbVN0YXR1czogc3RhdHVzLkZBSUxFRCB9KSA6IGZpZWxkKTtcbiAgICB9XG4gIH1cbiAgYWRqdXN0SGlzdG9ncmFtTWluTWF4KHZhbHVlKSB7XG4gICAgY29uc3QgeyBoaXN0b2dyYW1TbGlkZXIgfSA9IHRoaXM7XG4gICAgaWYgKGhpc3RvZ3JhbVNsaWRlcikge1xuICAgICAgaWYgKGhpc3RvZ3JhbVNsaWRlci5taW4gPiB2YWx1ZSkge1xuICAgICAgICBoaXN0b2dyYW1TbGlkZXIuc2V0KHsgbWluOiB2YWx1ZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChoaXN0b2dyYW1TbGlkZXIubWF4IDwgdmFsdWUpIHtcbiAgICAgICAgaGlzdG9ncmFtU2xpZGVyLnNldCh7IG1heDogdmFsdWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByZXBhcmVTbGlkZXIoZmlsdGVyRmllbGQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgaGlzdG9ncmFtU2xpZGVyRmllbGROYW1lOiBzbGlkZXJGaWVsZE5hbWUgfSA9IHRoaXM7XG4gICAgbGV0IHsgdmFsdWUsIHZhbHVlMiwgaGlzdG9ncmFtU2xpZGVyOiBzbGlkZXIgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhdGlzdGljcyA9IGZpbHRlckZpZWxkLnN0YXRpc3RpY3M7XG4gICAgaWYgKGZpbHRlckZpZWxkLmhpc3RvZ3JhbVN0YXR1cyA9PT0gc3RhdHVzLklOX1BST0dSRVNTKSB7XG4gICAgICAvLyBubyB1cGRhdGVzIHRvIHRoZSBzbGlkZXJcbiAgICAgIC8vY29uc29sZS5sb2coXCJubyBzbGlkZXIgdXBkYXRlc1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gc3RyaW5nIHZhbHVlcyBhcmUgd3JvbmcgaGVyZVxuICAgIGlmIChpc0RlZmluZWQodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0RlZmluZWQodmFsdWUyKSAmJiB0eXBlb2YgdmFsdWUyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZTIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tEZWZhdWx0VmFsdWVzKGZpbHRlckZpZWxkKTtcbiAgICAvLyByZWZyZXNoXG4gICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHZhbHVlMiA9IHRoaXMudmFsdWUyO1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiB2YWx1ZXNcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZTIpKSB7XG4gICAgICB2YWx1ZXMucHVzaCh2YWx1ZTIpO1xuICAgIH1cbiAgICBpZiAoaXNJbnRlZ2VyVHlwZShmaWx0ZXJGaWVsZCkpIHtcbiAgICAgIGlmIChpc0RlZmluZWQodmFsdWVzWzBdKSkge1xuICAgICAgICBjb25zdCByb3VuZGVkVmFsID0gTWF0aC5yb3VuZCh2YWx1ZXNbMF0pO1xuICAgICAgICBpZiAocm91bmRlZFZhbCAhPT0gdmFsdWVzWzBdKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXMocm91bmRlZFZhbCwgdmFsdWUyKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbMF0gPSByb3VuZGVkVmFsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZXNbMV0pKSB7XG4gICAgICAgIGNvbnN0IHJvdW5kZWRWYWwgPSBNYXRoLnJvdW5kKHZhbHVlc1sxXSk7XG4gICAgICAgIGlmIChyb3VuZGVkVmFsICE9PSB2YWx1ZXNbMV0pIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWx1ZSwgcm91bmRlZFZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzWzFdID0gcm91bmRlZFZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRqdXN0IHRoZSBzbGlkZXIgaWYgdmFsdWVzIGFyZSBvdXRzaWRlIG9mIHJhbmdlXG4gICAgbGV0IG1pbiA9IGZpbHRlckZpZWxkLmhpc3RvZ3JhbSA/IGZpbHRlckZpZWxkLmhpc3RvZ3JhbS5taW5WYWx1ZSA6IHN0YXRpc3RpY3MubWluO1xuICAgIGxldCBtYXggPSBmaWx0ZXJGaWVsZC5oaXN0b2dyYW0gPyBmaWx0ZXJGaWVsZC5oaXN0b2dyYW0ubWF4VmFsdWUgOiBzdGF0aXN0aWNzLm1heDtcbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlc1swXSkgJiYgaXNEZWZpbmVkKHZhbHVlc1sxXSkpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmFsdWVzWzBdKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWVzWzFdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWZpbmVkKHZhbHVlc1swXSkpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmFsdWVzWzBdKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWVzWzBdKTtcbiAgICB9XG4gICAgaWYgKHNsaWRlciAmJiBzbGlkZXJGaWVsZE5hbWUgIT09IGZpbHRlckZpZWxkLmxheWVyRmllbGQubmFtZSkge1xuICAgICAgLy8gY2hhbmdlIG1heWJlIGJlY2F1c2Ugb2YgYSBkZWxldGVkIGV4cHJlc3Npb24gb3IgY29uZGl0aW9uXG4gICAgICBzbGlkZXIuZGVzdHJveSgpO1xuICAgICAgc2xpZGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIXNsaWRlcikge1xuICAgICAgLy8gbmV3IGhpc3RvZ3JhbVxuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBiaW5zOiAoX2EgPSBmaWx0ZXJGaWVsZC5oaXN0b2dyYW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5zLFxuICAgICAgICBhdmVyYWdlOiBNYXRoLnJvdW5kKHN0YXRpc3RpY3MuYXZnICogMTApIC8gMTAsXG4gICAgICAgIC8vc3RhbmRhcmREZXZpYXRpb246IGZpbHRlckZpZWxkLnN0YXRpc3RpY3Muc3RkZGV2LFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgIHZhbHVlczogKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlc1swXSkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHZhbHVlcyxcbiAgICAgICAgcmFuZ2VUeXBlOiB0aGlzLmdldFNsaWRlclJhbmdlVHlwZSgpLFxuICAgICAgICBwcmVjaXNpb246IGlzSW50ZWdlclR5cGUoZmlsdGVyRmllbGQpID8gMCA6IDRcbiAgICAgIH07XG4gICAgICBpZiAoW3NpbXBsZUZpZWxkVHlwZXMuREFURSwgc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLmluZGV4T2YoZmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA+XG4gICAgICAgIC0xKSB7XG4gICAgICAgIGNvbmZpZy5oYXNUaW1lRGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkRGF0ZUZvcm1hdEZ1bmN0aW9ucyhjb25maWcpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaXN0b2dyYW1TbGlkZXJGaWVsZE5hbWUgPSBmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWU7XG4gICAgICB0aGlzLmhpc3RvZ3JhbVNsaWRlciA9IG5ldyB0aGlzLkhpc3RvZ3JhbVJhbmdlU2xpZGVyKGNvbmZpZyk7XG4gICAgICAvL2NvbnNvbGUubG9nKFwibmV3IEhpc3RvZ3JhbVJhbmdlU2xpZGVyXCIsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNyZWF0ZVNsaWRlckNoYW5nZUV2ZW50cyhmaWx0ZXJGaWVsZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIGhpc3RvZ3JhbSBzbGlkZXJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgYmluczogKF9iID0gZmlsdGVyRmllbGQuaGlzdG9ncmFtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmlucyxcbiAgICAgICAgYXZlcmFnZTogTWF0aC5yb3VuZChzdGF0aXN0aWNzLmF2ZyAqIDEwKSAvIDEwLFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgIHZhbHVlczogKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlc1swXSkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHZhbHVlcyxcbiAgICAgICAgcmFuZ2VUeXBlOiB0aGlzLmdldFNsaWRlclJhbmdlVHlwZSgpXG4gICAgICB9O1xuICAgICAgLy9jb25zb2xlLmxvZyhcInVwZGF0ZSBIaXN0b2dyYW1SYW5nZVNsaWRlclwiLCBjb25maWcsIHZhbHVlcyk7XG4gICAgICBzbGlkZXIuc2V0KGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVNsaWRlckNoYW5nZUV2ZW50cyhmaWx0ZXJGaWVsZCkge1xuICAgIGNvbnN0IHsgaGlzdG9ncmFtU2xpZGVyIH0gPSB0aGlzO1xuICAgIGlmICghaGlzdG9ncmFtU2xpZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhpc3RvZ3JhbVNsaWRlci5vbihcIm1pbi1jaGFuZ2VcIiwgKGV2ZW50IC8qVmFsdWVDaGFuZ2VFdmVudCovKSA9PiB7XG4gICAgICBjb25zdCBzbGlkZXIgPSBoaXN0b2dyYW1TbGlkZXI7XG4gICAgICB0aGlzLm9uTWluTWF4Q2hhbmdlKGV2ZW50LnZhbHVlLCBzbGlkZXIubWF4LCBmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUpO1xuICAgIH0pO1xuICAgIGhpc3RvZ3JhbVNsaWRlci5vbihcIm1heC1jaGFuZ2VcIiwgKGV2ZW50IC8qVmFsdWVDaGFuZ2VFdmVudCovKSA9PiB7XG4gICAgICBjb25zdCBzbGlkZXIgPSBoaXN0b2dyYW1TbGlkZXI7XG4gICAgICB0aGlzLm9uTWluTWF4Q2hhbmdlKHNsaWRlci5taW4sIGV2ZW50LnZhbHVlLCBmaWx0ZXJGaWVsZC5sYXllckZpZWxkLm5hbWUpO1xuICAgIH0pO1xuICAgIGhpc3RvZ3JhbVNsaWRlci53YXRjaChcInZhbHVlc1wiLCAoIC8qIHZhbHVlczogbnVtYmVyW10gKi8pID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBzbGlkZXIgPSBoaXN0b2dyYW1TbGlkZXI7XG4gICAgICBsZXQgdmFsdWUgPSAoX2EgPSBzbGlkZXIudmFsdWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICBsZXQgdmFsdWUyID0gKF9iID0gc2xpZGVyLnZhbHVlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzFdO1xuICAgICAgaWYgKFtzaW1wbGVGaWVsZFR5cGVzLkRBVEUsIHNpbXBsZUZpZWxkVHlwZXMuREFURV9PTkxZXS5pbmRleE9mKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPlxuICAgICAgICAtMSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzSW50ZWdlclR5cGUoZmlsdGVyRmllbGQpKSB7XG4gICAgICAgIGlmICh2YWx1ZTIgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICAgIHZhbHVlMiA9IE1hdGguY2VpbCh2YWx1ZTIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHZhbHVlLCB2YWx1ZTIpO1xuICAgIH0pO1xuICAgIGhpc3RvZ3JhbVNsaWRlci5vbihcInNlZ21lbnQtZHJhZ1wiLCAoIC8qZXZlbnQ6IGFueSBTZWdtZW50RHJhZ0V2ZW50Ki8pID0+IHtcbiAgICAgIGNvbnN0IHNsaWRlciA9IGhpc3RvZ3JhbVNsaWRlcjtcbiAgICAgIGxldCB2YWx1ZSA9IHNsaWRlci52YWx1ZXNbMF07XG4gICAgICBsZXQgdmFsdWUyID0gc2xpZGVyLnZhbHVlc1sxXTtcbiAgICAgIGlmIChpc0ludGVnZXJUeXBlKGZpbHRlckZpZWxkKSkge1xuICAgICAgICBpZiAodmFsdWUyIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgICB2YWx1ZTIgPSBNYXRoLmNlaWwodmFsdWUyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWx1ZSwgdmFsdWUyKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTbGlkZXJSYW5nZVR5cGUoKSB7XG4gICAgY29uc3QgeyBwcm9wcywgb3BlcmF0b3IgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXM6XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzT246XG4gICAgICAgIHJldHVybiBcImVxdWFsXCI7XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLm51bWJlck9wZXJhdG9ySXNOb3Q6XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzTm90T246XG4gICAgICAgIHJldHVybiBcIm5vdC1lcXVhbFwiO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTGVzc1RoYW46XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmVmb3JlOlxuICAgICAgICByZXR1cm4gXCJsZXNzLXRoYW5cIjtcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0dyZWF0ZXJUaGFuOlxuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5kYXRlT3BlcmF0b3JJc0FmdGVyOlxuICAgICAgICByZXR1cm4gXCJncmVhdGVyLXRoYW5cIjtcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0F0TW9zdDpcbiAgICAgICAgcmV0dXJuIFwiYXQtbW9zdFwiO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzQXRMZWFzdDpcbiAgICAgICAgcmV0dXJuIFwiYXQtbGVhc3RcIjtcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMubnVtYmVyT3BlcmF0b3JJc0JldHdlZW46XG4gICAgICBjYXNlIHN0cmluZ3Mub3BlcmF0b3JzLmRhdGVPcGVyYXRvcklzQmV0d2VlbjpcbiAgICAgICAgcmV0dXJuIFwiYmV0d2VlblwiO1xuICAgICAgY2FzZSBzdHJpbmdzLm9wZXJhdG9ycy5udW1iZXJPcGVyYXRvcklzTm90QmV0d2VlbjpcbiAgICAgIGNhc2Ugc3RyaW5ncy5vcGVyYXRvcnMuZGF0ZU9wZXJhdG9ySXNOb3RCZXR3ZWVuOlxuICAgICAgICByZXR1cm4gXCJub3QtYmV0d2VlblwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XG4gIGdldE5ld1ZhbHVlKGV2ZW50KSB7XG4gICAgY29uc3QgeyB2aWV3IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgdGltZVpvbmUgfSA9IHZpZXc7XG4gICAgY29uc3Qgbm9kZSA9IGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC50YXJnZXQ7XG4gICAgbGV0IG5ld1ZhbHVlO1xuICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRhZ05hbWUpID09PSBcIkNBTENJVEUtSU5QVVQtREFURS1QSUNLRVJcIikge1xuICAgICAgbmV3VmFsdWUgPSBub2RlLnZhbHVlOyAvL3ZhbHVlQXNEYXRlOyAtPiB2YWx1ZUFzRGF0ZSBzZWVtcyB0byBoYXZlIGEgdGltZSBvZmZzZXRcbiAgICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV3VmFsdWUgPSBkYXRlUGlja2VyVG9VVEMobmV3IERhdGUobmV3VmFsdWUpLCB0aW1lWm9uZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUudGFnTmFtZSkgPT09IFwiQ0FMQ0lURS1JTlBVVFwiICYmIG5vZGUudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbmV3VmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgaWYgKCFuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXdWYWx1ZSA9IHBhcnNlRmxvYXQobmV3VmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRhZ05hbWUpID09PSBcIkNBTENJVEUtSU5QVVRcIikge1xuICAgICAgLy8gdGV4dFxuICAgICAgbmV3VmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgaWYgKCEobmV3VmFsdWUgPT09IG51bGwgfHwgbmV3VmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld1ZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfVxuICBhZGREYXRlRm9ybWF0RnVuY3Rpb25zKGNvbmZpZykge1xuICAgIGNvbnN0IHsgaW50bCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aWV3IH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHRpbWVab25lIH0gPSB2aWV3O1xuICAgIGNvbmZpZy5sYWJlbEZvcm1hdEZ1bmN0aW9uID0gKHZhbHVlKSA9PiB7XG4gICAgICAvL3JldHVybiB0aGlzLnNtYXJ0TWFwcGluZ1V0aWxzLmZvcm1hdERhdGVMYWJlbCh1dGNUb01hcFRaKHZhbHVlLCB0aW1lWm9uZSkpO1xuICAgICAgcmV0dXJuIGdldERhdGVEaXNwbGF5U3RyaW5nKHZhbHVlLCB0aW1lWm9uZSwgaW50bCwgXCJzaG9ydC1kYXRlXCIpO1xuICAgIH07XG4gICAgY29uZmlnLmlucHV0Rm9ybWF0RnVuY3Rpb24gPSAodmFsdWUpID0+IHtcbiAgICAgIC8vcmV0dXJuIHRoaXMuc21hcnRNYXBwaW5nVXRpbHMuZm9ybWF0RGF0ZUxhYmVsKHV0Y1RvTWFwVFoodmFsdWUsIHRpbWVab25lKSk7XG4gICAgICByZXR1cm4gZ2V0RGF0ZURpc3BsYXlTdHJpbmcodmFsdWUsIHRpbWVab25lLCBpbnRsLCBcInNob3J0LWRhdGVcIik7XG4gICAgfTtcbiAgICBjb25maWcuaW5wdXRQYXJzZUZ1bmN0aW9uID0gKHZhbHVlIC8qICwgdHlwZTogc3RyaW5nLCBpbmRleDogbnVtYmVyICovKSA9PiB7XG4gICAgICByZXR1cm4gbWFwVFpUb1VUQyhEYXRlLnBhcnNlKHZhbHVlKSwgdGltZVpvbmUpO1xuICAgIH07XG4gIH1cbiAgY2hhbmdlVmFsdWVzKHZhbHVlLCB2YWx1ZTIpIHtcbiAgICBjb25zdCB7IHByb3BzLCBmaWVsZE5hbWUgfSA9IHRoaXM7XG4gICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8oZmllbGROYW1lLCBwcm9wcyk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUgJiZcbiAgICAgIFtzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUiwgc2ltcGxlRmllbGRUeXBlcy5EQVRFLCBzaW1wbGVGaWVsZFR5cGVzLk9JRF0uaW5kZXhPZihmaWx0ZXJGaWVsZC5zaW1wbGVGaWVsZFR5cGUpID4gLTFcbiAgICAgID8gaXNOYU4odmFsdWUpXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHZhbHVlXG4gICAgICA6IHZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlMiA9IGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSAmJlxuICAgICAgW3NpbXBsZUZpZWxkVHlwZXMuTlVNQkVSLCBzaW1wbGVGaWVsZFR5cGVzLkRBVEUsIHNpbXBsZUZpZWxkVHlwZXMuT0lEXS5pbmRleE9mKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPiAtMVxuICAgICAgPyBpc05hTih2YWx1ZTIpXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHZhbHVlMlxuICAgICAgOiB2YWx1ZTI7XG4gICAgaWYgKHRoaXMudmFsdWUgIT09IG5ld1ZhbHVlIHx8IHRoaXMudmFsdWUyICE9PSBuZXdWYWx1ZTIpIHtcbiAgICAgIC8vdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgLy90aGlzLnZhbHVlMiA9IG5ld1ZhbHVlMjtcbiAgICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KHtcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlICE9PSBudWxsICYmIG5ld1ZhbHVlICE9PSB2b2lkIDAgPyBuZXdWYWx1ZSA6IG51bGwsXG4gICAgICAgIHZhbHVlMjogbmV3VmFsdWUyICE9PSBudWxsICYmIG5ld1ZhbHVlMiAhPT0gdm9pZCAwID8gbmV3VmFsdWUyIDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNoZWNrRGVmYXVsdFZhbHVlcyhmaWx0ZXJGaWVsZCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIG9wZXJhdG9yLCB2YWx1ZSwgdmFsdWUyLCBoaXN0b2dyYW1TbGlkZXI6IHNsaWRlciB9ID0gdGhpcztcbiAgICBjb25zdCBzdGF0aXN0aWNzID0gZmlsdGVyRmllbGQuc3RhdGlzdGljcztcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gZ2V0RGVmYXVsdFZhbHVlcyhwcm9wcywgZmlsdGVyRmllbGQsIG9wZXJhdG9yKTtcbiAgICBpZiAoaXNJblRoZUxhc3RPcGVyYXRvcihwcm9wcywgb3BlcmF0b3IpKSB7XG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gTWF0aC5hYnMobm93IC0gc3RhdGlzdGljcy5hdmcpO1xuICAgICAgICBsZXQgdmFsdWUsIHVuaXQ7XG4gICAgICAgIGlmIChyYW5nZSA+IDIgKiB0aW1lUmFuZ2UuWUVBUikge1xuICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5ZRUFSKTtcbiAgICAgICAgICB1bml0ID0gdGltZVVuaXRzLllFQVI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHJhbmdlID4gMiAqIHRpbWVSYW5nZS5NT05USCkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLk1PTlRIKTtcbiAgICAgICAgICAgIHVuaXQgPSB0aW1lVW5pdHMuTU9OVEg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJhbmdlID4gMiAqIHRpbWVSYW5nZS5XRUVLKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZChyYW5nZSAvIHRpbWVSYW5nZS5XRUVLKTtcbiAgICAgICAgICAgICAgdW5pdCA9IHRpbWVVbml0cy5XRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZSA+IDIgKiB0aW1lUmFuZ2UuREFZKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLkRBWSk7XG4gICAgICAgICAgICAgICAgdW5pdCA9IHRpbWVVbml0cy5EQVk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID4gMiAqIHRpbWVSYW5nZS5IT1VSKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQocmFuZ2UgLyB0aW1lUmFuZ2UuSE9VUik7XG4gICAgICAgICAgICAgICAgICB1bml0ID0gdGltZVVuaXRzLkhPVVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHJhbmdlIC8gdGltZVJhbmdlLk1JTlVURSk7XG4gICAgICAgICAgICAgICAgICB1bml0ID0gdGltZVVuaXRzLk1JTlVURTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIC8vdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoeyB2YWx1ZSwgdW5pdCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCZXR3ZWVuT3BlcmF0b3IocHJvcHMsIG9wZXJhdG9yKSkge1xuICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZTIpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlMiA8IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBsZXQncyBjb3JyZWN0IHRoZSBvbmUgdGhhdCB3YXMgY2hhbmdlZCBsYXN0XG4gICAgICAgICAgICBpZiAoc2xpZGVyICYmIHNsaWRlci52YWx1ZXNbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXModmFsdWUyLCB2YWx1ZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBuZWVkIGEgc2Vjb25kIHZhbHVlXG4gICAgICAgICAgY29uc3QgdmFsID0gaXNJbnRlZ2VyVHlwZShmaWx0ZXJGaWVsZCkgPyBNYXRoLnJvdW5kKHN0YXRpc3RpY3MubWF4KSA6IHN0YXRpc3RpY3MubWF4O1xuICAgICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKHZhbHVlLCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmVlZCB2YWx1ZXNcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZTIpKSB7XG4gICAgICAgICAgY29uc3QgdmFsID0gZmllbGRUeXBlUm91bmQoc3RhdGlzdGljcyA9PT0gbnVsbCB8fCBzdGF0aXN0aWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0aXN0aWNzLmF2ZywgcHJvcHMsIGZpbHRlckZpZWxkKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZVZhbHVlcyh2YWwsIHZhbHVlMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZXMoZGVmYXVsdFZhbHVlcy52YWx1ZSwgZGVmYXVsdFZhbHVlcy52YWx1ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlVmFsdWVzKGRlZmF1bHRWYWx1ZXMudmFsdWUsIGRlZmF1bHRWYWx1ZXMudmFsdWUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbW9zdCBvZiB0aGUgdGltZXMgZG9uJ3QgbmVlZCB0aGlzIHJldHVyblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWVzO1xuICB9XG4gIG9wZW5GaWVsZFBpY2tMaXN0KCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIGZpZWxkTmFtZSwgZmllbGRQaWNrTGlzdFNvcnRCeSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyLCB2aWV3LCBmZWF0dXJlUmVkdWN0aW9uIH0gPSBwcm9wcztcbiAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgIHRoaXMuY2xvc2VGaWx0ZXJQb3BvdmVyc0hhbmRsZXIoKTtcbiAgICBjb25zdCBwYW5lbE5vZGUgPSBxdWVyeVBhcmVudEVsZW1lbnQodGhpcy5ob3N0RWxlbWVudCwgXCIjZmlsdGVyLXBhbmVsXCIpO1xuICAgIGNvbnN0IGNsb3NlTm9kZSA9IHBhbmVsTm9kZS5xdWVyeVNlbGVjdG9yKFwiI2FyY2dpcy1maWx0ZXItY2xvc2VcIik7XG4gICAgY29uc3Qgbm9kZVdpZHRoID0gcGFuZWxOb2RlID09PSBudWxsIHx8IHBhbmVsTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFuZWxOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtZmllbGQtcGljay1saXN0XCIpO1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5wb3BvdmVyUHJvcHMgPSBjbG9zZU5vZGVcbiAgICAgID8ge1xuICAgICAgICBwbGFjZW1lbnQ6IGRpciA9PT0gXCJydGxcIiA/IFwiYm90dG9tLXN0YXJ0XCIgOiBcImJvdHRvbS1lbmRcIixcbiAgICAgICAgb2Zmc2V0RGlzdGFuY2U6IDIwLFxuICAgICAgICBvZmZzZXRTa2lkZGluZzogMTUsXG4gICAgICAgIHBvaW50ZXJEaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgcG9wb3ZlcldpZHRoOiBub2RlV2lkdGggPyBub2RlV2lkdGggKyAzMCA6IDI4MCxcbiAgICAgICAgcmVmRWxlbWVudDogY2xvc2VOb2RlXG4gICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgcGxhY2VtZW50OiBcImF1dG9cIixcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhbiBhY3Rpb24gYmFyIGluIGxheWVyIHZpZXcgd2hlcmUgaXQgaXMgdXNlZCB3aXRob3V0IGEgY2xvc2UgYnV0dG9uXG4gICAgICAgIG9mZnNldERpc3RhbmNlOiAtMSAqIChub2RlV2lkdGggPyBub2RlV2lkdGggLSA1IDogMjE1KSxcbiAgICAgICAgb2Zmc2V0U2tpZGRpbmc6IDAsXG4gICAgICAgIHBvaW50ZXJEaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgcG9wb3ZlcldpZHRoOiBub2RlV2lkdGggPyBub2RlV2lkdGggKyAzMCA6IDI4MCxcbiAgICAgICAgcmVmRWxlbWVudDogcGFuZWxOb2RlXG4gICAgICB9O1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5maWVsZHMgPSB0aGlzLmNyZWF0ZVBpY2tMaXN0RmllbGRzKCk7XG4gICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LmxheWVyID0gbGF5ZXI7XG4gICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0Lm1hcFZpZXcgPSB2aWV3O1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zaG93RmllbGRJbmZvID0gdHJ1ZTtcbiAgICB0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3Quc2hvd0ZpZWxkTmFtZSA9IGZhbHNlO1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zZWxlY3RlZEZpZWxkcyA9IFtmaWVsZE5hbWVdO1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zb3J0QnkgPSBmaWVsZFBpY2tMaXN0U29ydEJ5O1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5zaG93RmllbGRJbmZvID0gIWZlYXR1cmVSZWR1Y3Rpb247XG4gICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNGaWVsZFBpY2tMaXN0RGlzbWlzc2VkXCIsIHRoaXMuZmllbGRQaWNrTGlzdENoYW5nZXMpO1xuICAgIHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdC5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzRmllbGRQaWNrTGlzdFNvcnRCeUNoYW5nZVwiLCAoZXZlbnQpID0+ICh0aGlzLmZpZWxkUGlja0xpc3RTb3J0QnkgPSBldmVudC5kZXRhaWwpKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdCk7XG4gICAgdGhpcy5kaXNhYmxlRmlsdGVyUGFuZWwuZW1pdCh0cnVlKTtcbiAgfVxuICBjcmVhdGVQaWNrTGlzdEZpZWxkcygpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZmllbGRzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gZmllbGRzLm1hcCgoZmllbGQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGZpZWxkLmxheWVyRmllbGQubmFtZSxcbiAgICAgICAgYWxpYXM6IGZpZWxkLmxhYmVsLFxuICAgICAgICB0eXBlOiBmaWVsZC5zaW1wbGVGaWVsZFR5cGVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlRmllbGRzUGlja0xpc3QoKSB7XG4gICAgdGhpcy5kaXNhYmxlRmlsdGVyUGFuZWwuZW1pdChmYWxzZSk7XG4gICAgaWYgKHRoaXMuYXJjZ2lzRmllbGRQaWNrTGlzdCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmFyY2dpc0ZpZWxkUGlja0xpc3QpO1xuICAgICAgdGhpcy5hcmNnaXNGaWVsZFBpY2tMaXN0ID0gbnVsbDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmZpZWxkTm9kZS5zZXRGb2N1cygpO1xuICAgICAgfSwgMSk7XG4gICAgfVxuICB9XG4gIGFmdGVyRmllbGRTZWxlY3QobmV3RmllbGROYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgcHJvcHMsIGZpZWxkTmFtZSwgb3BlcmF0b3IsIGhpc3RvZ3JhbU9wZW4gfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCBvbGRGaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhmaWVsZE5hbWUsIHByb3BzKTtcbiAgICBjb25zdCBuZXdGaWx0ZXJGaWVsZCA9IGdldEZpZWxkSW5mbyhuZXdGaWVsZE5hbWUsIHByb3BzKTtcbiAgICAvKiB0aGlzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICB0aGlzLmZpZWxkTmFtZSA9IG5ld0ZpZWxkTmFtZTtcbiAgICB0aGlzLm9wZXJhdG9yID0gZ2V0T3BlcmF0b3IocHJvcHMsIG9sZEZpbHRlckZpZWxkISwgbmV3RmlsdGVyRmllbGQhLCBvcGVyYXRvciEpO1xuICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWx1ZTIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy51bmlxdWVWYWx1ZXNTb3J0QnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oaXN0b2dyYW1PcGVuID1cbiAgICAgIChuZXdGaWx0ZXJGaWVsZCEuc2ltcGxlRmllbGRUeXBlICYmXG4gICAgICAgIFtzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUiwgc2ltcGxlRmllbGRUeXBlcy5EQVRFXS5pbmRleE9mKFxuICAgICAgICAgIG5ld0ZpbHRlckZpZWxkIS5zaW1wbGVGaWVsZFR5cGVcbiAgICAgICAgKSA9PT0gLTEpIHx8XG4gICAgICBuZXdGaWx0ZXJGaWVsZCEuc3RhdGlzdGljc1N0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IGhpc3RvZ3JhbU9wZW4gPT09IGZhbHNlICYmIG9sZEZpbHRlckZpZWxkIS5zdGF0aXN0aWNzU3RhdHVzICE9PSBzdGF0dXMuRkFJTEVEXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiB1bmRlZmluZWQ7IC8vIHdoZW4gdW5kZWZpbmVkIHRoZW4gb3BlbiBieSBkZWZhdWx0XG4gICAgKi9cbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGNvbnN0IG5ld09wZXJhdG9yID0gZ2V0T3BlcmF0b3IkMShwcm9wcywgb2xkRmlsdGVyRmllbGQsIG5ld0ZpbHRlckZpZWxkLCBvcGVyYXRvcik7XG4gICAgY29uc3QgZmlsdGVyRmllbGQgPSBnZXRGaWVsZEluZm8obmV3RmllbGROYW1lLCBwcm9wcyk7XG4gICAgaWYgKGZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSA9PT0gc2ltcGxlRmllbGRUeXBlcy5TVFJJTkcgJiZcbiAgICAgIGZpbHRlckZpZWxkLnVuaXF1ZVZhbHVlc1N0YXR1cyA9PT0gc3RhdHVzLlNVQ0NFU1MgJiZcbiAgICAgICgoX2EgPSBmaWx0ZXJGaWVsZC51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJlxuICAgICAgW3N0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXMsIHN0cmluZ3Mub3BlcmF0b3JzLnN0cmluZ09wZXJhdG9ySXNOb3RdLmluZGV4T2YobmV3T3BlcmF0b3IpID4gLTEpIHtcbiAgICAgIC8vIGRlZmF1bHQgdmFsdWVcbiAgICAgIHZhbHVlID0gZmlsdGVyRmllbGQudW5pcXVlVmFsdWVJbmZvc1swXS52YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoe1xuICAgICAgaGFzRm9jdXM6IHRydWUsXG4gICAgICBmaWVsZE5hbWU6IG5ld0ZpZWxkTmFtZSxcbiAgICAgIG9wZXJhdG9yOiBuZXdPcGVyYXRvcixcbiAgICAgIHZhbHVlLFxuICAgICAgdmFsdWUyOiBudWxsLFxuICAgICAgdmFsdWVzOiBudWxsLFxuICAgICAgdW5pcXVlVmFsdWVzU29ydEJ5OiBudWxsLFxuICAgICAgaGlzdG9ncmFtT3BlbjogKG5ld0ZpbHRlckZpZWxkLnNpbXBsZUZpZWxkVHlwZSAmJlxuICAgICAgICBbc2ltcGxlRmllbGRUeXBlcy5OVU1CRVIsIHNpbXBsZUZpZWxkVHlwZXMuREFURSwgc2ltcGxlRmllbGRUeXBlcy5EQVRFX09OTFldLmluZGV4T2YobmV3RmlsdGVyRmllbGQuc2ltcGxlRmllbGRUeXBlKSA9PT0gLTEpIHx8XG4gICAgICAgIG5ld0ZpbHRlckZpZWxkLnN0YXRpc3RpY3NTdGF0dXMgPT09IHN0YXR1cy5GQUlMRURcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogaGlzdG9ncmFtT3BlbiA9PT0gZmFsc2UgJiYgb2xkRmlsdGVyRmllbGQuc3RhdGlzdGljc1N0YXR1cyAhPT0gc3RhdHVzLkZBSUxFRFxuICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICA6IG51bGwgLy8gd2hlbiB1bmRlZmluZWQgdGhlbiBvcGVuIGJ5IGRlZmF1bHRcbiAgICB9KTtcbiAgfVxuICBlbWl0Q2hhbmdlRXZlbnQob3ZlcndyaXRlcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyB1aWQsIGZpZWxkTmFtZSwgb3BlcmF0b3IsIHVuaXF1ZVZhbHVlc1NvcnRCeSwgdmFsdWUsIHZhbHVlMiwgdmFsdWVzLCB1bml0LCBoaXN0b2dyYW1PcGVuLCBoYXNGb2N1cyB9ID0gdGhpcztcbiAgICBjb25zdCBuZXdDb25kaXRpb24gPSB7XG4gICAgICB1aWQsXG4gICAgICBmaWVsZE5hbWU6IG92ZXJ3cml0ZXMuZmllbGROYW1lIHx8IGZpZWxkTmFtZSxcbiAgICAgIG9wZXJhdG9yOiBvdmVyd3JpdGVzLm9wZXJhdG9yIHx8IG9wZXJhdG9yLFxuICAgICAgdW5pcXVlVmFsdWVzU29ydEJ5OiBvdmVyd3JpdGVzLnVuaXF1ZVZhbHVlc1NvcnRCeSA9PT0gbnVsbFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IG92ZXJ3cml0ZXMudW5pcXVlVmFsdWVzU29ydEJ5IHx8IHVuaXF1ZVZhbHVlc1NvcnRCeSxcbiAgICAgIHZhbHVlOiBvdmVyd3JpdGVzLnZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogKF9hID0gb3ZlcndyaXRlcy52YWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWUsXG4gICAgICB2YWx1ZTI6IG92ZXJ3cml0ZXMudmFsdWUyID09PSBudWxsID8gdW5kZWZpbmVkIDogKF9iID0gb3ZlcndyaXRlcy52YWx1ZTIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHZhbHVlMixcbiAgICAgIHZhbHVlczogb3ZlcndyaXRlcy52YWx1ZXMgPT09IG51bGwgPyB1bmRlZmluZWQgOiBvdmVyd3JpdGVzLnZhbHVlcyB8fCB2YWx1ZXMsXG4gICAgICB1bml0OiBvdmVyd3JpdGVzLnVuaXQgfHwgdW5pdCxcbiAgICAgIGhpc3RvZ3JhbU9wZW46IG92ZXJ3cml0ZXMuaGlzdG9ncmFtT3BlbiA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IG92ZXJ3cml0ZXMuaGlzdG9ncmFtT3BlbiB8fCBoaXN0b2dyYW1PcGVuLFxuICAgICAgaGFzRm9jdXM6IG92ZXJ3cml0ZXMuaGFzRm9jdXMgfHwgaGFzRm9jdXNcbiAgICB9O1xuICAgIHRoaXMuYXJjZ2lzRmlsdGVyQ29uZGl0aW9uQ2hhbmdlZC5lbWl0KG5ld0NvbmRpdGlvbik7XG4gIH1cbiAgd2FpdE9uVXNlcihldmVudCwgZG9DaGFuZ2UpIHtcbiAgICAvLyBmb3IgbnVtYmVyIGZpZWxkcyB3ZSBkb24ndCB3YW50IHRvIGFsbG93IGFuIGVtcHR5IHZhbHVlXG4gICAgLy8gYnV0IHRoZSB1c2VyIG1pZ2h0IHNob3J0bHkgdXNlIGFuIGVtcHR5IGlucHV0IGJveFxuICAgIC8vIHdoaWxlIHR5cGluZyBhIG5ldyB2YWx1ZVxuICAgIGlmICh0aGlzLnR5cGluZ0huZGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnR5cGluZ0huZGwpO1xuICAgICAgdGhpcy50eXBpbmdIbmRsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IHZhbCA9IG5vZGUudmFsdWU7XG4gICAgY29uc3QgcGFyc2VkVmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIGlmICghdmFsKSB7XG4gICAgICAvLyB1bmRlZmluZWQgb3IgZW1wdHkgc3RyaW5nXG4gICAgICAvLyB1c2VyIG1pZ2h0IGJlIGluIHRoZSBtaWRkbGUgb2YgdHlwaW5nXG4gICAgICAvLyBnaXZlIHRoZSB1c2VyIDIgc2Vjb25kcyB0byBmaWxsIGluIGVtcHR5IGVudHJ5XG4gICAgICAvLyBvdGhlcndpc2UgZ28gYmFjayB0byBkZWZhdWx0IHZhbHVlXG4gICAgICB0aGlzLnR5cGluZ0huZGwgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50eXBpbmdIbmRsID0gdW5kZWZpbmVkO1xuICAgICAgICBkb0NoYW5nZShldmVudCk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsWzBdICE9PSBcIi1cIiB8fCAocGFyc2VkVmFsICE9PSAwICYmICFpc05hTihwYXJzZWRWYWwpKSkge1xuICAgICAgLy8gbm90ICctJywgJy0wJywgJy0wLicsICctMC4wJywgLi4uXG4gICAgICBkb0NoYW5nZShldmVudCk7XG4gICAgfSAvLyBlbHNlIGRvbid0IHVwZGF0ZSBhbnl0aGluZzsgaXQncyBzdGlsbCBrZWVwaW5nIGxhc3QgdmFsdWVcbiAgfVxuICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzRmlsdGVyQ29uZGl0aW9uLnN0eWxlID0gYXJjZ2lzRmlsdGVyQ29uZGl0aW9uQ3NzO1xuXG5jb25zdCBDU1MkMSA9IHtcbiAgYWRkQ29uZGl0aW9uQnV0dG9uOiBcImFkZC1jb25kaXRpb24tYnV0dG9uXCIsXG4gIGNvbnRlbnQ6IFwiY29udGVudFwiLFxuICBjb25kaXRpb25IZWFkZXI6IFwiY29uZGl0aW9uLWhlYWRlclwiLFxuICBtYXRjaFR5cGVUZXh0OiBcIm1hdGNoLXR5cGUtdGV4dFwiLFxuICBtYXRjaENvbmRpdGlvbjogXCJtYXRjaC1jb25kaXRpb25cIixcbiAgbWF0Y2hDb25kaXRpb25Ecm9wZG93bjogXCJtYXRjaC1jb25kaXRpb24tZHJvcGRvd25cIlxufTtcblxuY29uc3QgYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNzcyA9IFwiLmNvbnRlbnQuc2MtYXJjZ2lzLWZpbHRlci1leHByZXNzaW9ue3BhZGRpbmctYm90dG9tOjZweH0uY29uZGl0aW9uLWhlYWRlci5zYy1hcmNnaXMtZmlsdGVyLWV4cHJlc3Npb257ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZDthbGlnbi1pdGVtczpjZW50ZXI7bWFyZ2luOjAgNnB4fS5tYXRjaC10eXBlLXRleHQuc2MtYXJjZ2lzLWZpbHRlci1leHByZXNzaW9ue21hcmdpbjowIGF1dG99Lm1hdGNoLWNvbmRpdGlvbi5zYy1hcmNnaXMtZmlsdGVyLWV4cHJlc3Npb257bWFyZ2luOjAgNnB4fS5tYXRjaC1jb25kaXRpb24tZHJvcGRvd24uc2MtYXJjZ2lzLWZpbHRlci1leHByZXNzaW9ue3dpZHRoOjEwMCV9LmFkZC1jb25kaXRpb24tYnV0dG9uLnNjLWFyY2dpcy1maWx0ZXItZXhwcmVzc2lvbntkaXNwbGF5OmZsZXh9XCI7XG5cbmNvbnN0IEFyY2dpc0ZpbHRlckV4cHJlc3Npb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzRmlsdGVyRXhwcmVzc2lvbkNoYW5nZWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0ZpbHRlckV4cHJlc3Npb25DaGFuZ2VkXCIsIDcpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMub25BZGRDb25kaXRpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHByb3BzLCBjb25kaXRpb25zIH0gPSB0aGlzO1xuICAgICAgY29uc3QgZGVmYXVsdEZpZWxkID0gZ2V0RGVmYXVsdEZpZWxkKHByb3BzKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcGVyYXRvciA9IGdldERlZmF1bHRPcGVyYXRvcihwcm9wcywgZGVmYXVsdEZpZWxkKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBnZXREZWZhdWx0VmFsdWVzKHByb3BzLCBkZWZhdWx0RmllbGQsIGRlZmF1bHRPcGVyYXRvcik7XG4gICAgICBjb25zdCBuZXdDb25kaXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBmaWVsZE5hbWU6IGRlZmF1bHRGaWVsZC5sYXllckZpZWxkLm5hbWUsIG9wZXJhdG9yOiBnZXREZWZhdWx0T3BlcmF0b3IocHJvcHMsIGRlZmF1bHRGaWVsZCkgfSwgZGVmYXVsdFZhbHVlcyksIHsgaGFzRm9jdXM6IHRydWUgfSk7XG4gICAgICBjb25kaXRpb25zLmZvckVhY2goKGNvbmQpID0+IChjb25kLmhhc0ZvY3VzID0gZmFsc2UpKTtcbiAgICAgIHRoaXMuY29uZGl0aW9ucyA9IFsuLi5jb25kaXRpb25zLCBuZXdDb25kaXRpb25dO1xuICAgICAgcHJvcHMuZXhwcmVzc2lvbnMgPSBwcm9wcy5leHByZXNzaW9ucy5tYXAoKGV4cHJlc3Npb24pID0+IGV4cHJlc3Npb24udWlkID09PSB0aGlzLnVpZFxuICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhwcmVzc2lvbiksIHsgY29uZGl0aW9uczogdGhpcy5jb25kaXRpb25zIH0pIDogT2JqZWN0LmFzc2lnbih7fSwgZXhwcmVzc2lvbikpO1xuICAgICAgdGhpcy5maXhVSURzRm9yRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5tZW51Tm9kZS5vcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCgpO1xuICAgIH07XG4gICAgdGhpcy5vblJlbW92ZUNvbmRpdGlvbiA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBwcm9wcywgY29uZGl0aW9ucyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbklkeCA9IHBhcnNlSW50KGFjdGlvbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpKTtcbiAgICAgIGNvbmRpdGlvbnMuZm9yRWFjaCgoY29uZCkgPT4gKGNvbmQuaGFzRm9jdXMgPSBmYWxzZSkpO1xuICAgICAgbGV0IHJlbW92ZWRJZHggPSAwO1xuICAgICAgdGhpcy5jb25kaXRpb25zID0gY29uZGl0aW9ucy5maWx0ZXIoKGNvbmQsIGlkeDIpID0+IHtcbiAgICAgICAgaWYgKGNvbmQgJiYgaWR4MiA9PT0gY29uZGl0aW9uSWR4KSB7XG4gICAgICAgICAgcmVtb3ZlZElkeCA9IGlkeDI7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbmRpdGlvbnNbTWF0aC5tYXgoMCwgcmVtb3ZlZElkeCAtIDEpXS5oYXNGb2N1cyA9IHRydWU7XG4gICAgICBwcm9wcy5leHByZXNzaW9ucyA9IHByb3BzLmV4cHJlc3Npb25zLm1hcCgoZXhwcmVzc2lvbikgPT4gZXhwcmVzc2lvbi51aWQgPT09IHRoaXMudWlkXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHByZXNzaW9uKSwgeyBjb25kaXRpb25zOiB0aGlzLmNvbmRpdGlvbnMgfSkgOiBPYmplY3QuYXNzaWduKHt9LCBleHByZXNzaW9uKSk7XG4gICAgICB0aGlzLmZpeFVJRHNGb3JFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCgpO1xuICAgIH07XG4gICAgdGhpcy5vbk1hdGNoU2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3QgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCBuZXdNYXRjaCA9IHNlbGVjdC5zZWxlY3RlZE9wdGlvbi52YWx1ZTtcbiAgICAgIHRoaXMubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IG5ld01hdGNoO1xuICAgICAgdGhpcy5lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIHRoaXMub25Db3B5RXhwcmVzc2lvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdWlkLCBjb25kaXRpb25zLCBsb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VycmVudEV4cHJlc3Npb24gPSB7XG4gICAgICAgIHVpZCxcbiAgICAgICAgY29uZGl0aW9ucyxcbiAgICAgICAgbG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMubWVudU5vZGUub3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgdHlwZTogXCJjb3B5XCIsXG4gICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgIGV4cHJlc3Npb246IGN1cnJlbnRFeHByZXNzaW9uXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMub25SZW1vdmVFeHByZXNzaW9uID0gKCkgPT4ge1xuICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ2hhbmdlZC5lbWl0KHsgdHlwZTogXCJkZWxldGVcIiwgdWlkOiB0aGlzLnVpZCB9KTtcbiAgICB9O1xuICAgIHRoaXMucHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy51aWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25kaXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhblJlbW92ZSA9IHRydWU7XG4gICAgdGhpcy5jYW5EdXBsaWNhdGUgPSB0cnVlO1xuICAgIHRoaXMuc2hvd0FkZENvbmRpdGlvbkJ1dHRvbiA9IGZhbHNlO1xuICB9XG4gIGFyY2dpc0ZpbHRlckNvbmRpdGlvbkNoYW5nZUhhbmRsZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7IGNvbmRpdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkZXRhaWw6IG5ld0NvbmRpdGlvbiB9ID0gZXZlbnQ7XG4gICAgdGhpcy5jb25kaXRpb25zID0gY29uZGl0aW9ucy5tYXAoKGNvbmRpdGlvbikgPT4gY29uZGl0aW9uLnVpZCA9PT0gbmV3Q29uZGl0aW9uLnVpZCA/IG5ld0NvbmRpdGlvbiA6IGNvbmRpdGlvbiAvL3sgLi4uY29uZGl0aW9uIH1cbiAgICApO1xuICAgIHRoaXMuZW1pdENoYW5nZUV2ZW50KCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdGhpcy5jb25kaXRpb25zID0gdGhpcy5jb25kaXRpb25zIHx8IFtdO1xuICAgIGNvbnN0IFtlc3JpTGFuZ10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2NvcmUvbGFuZ1wiXSk7XG4gICAgdGhpcy5lc3JpTGFuZyA9IGVzcmlMYW5nO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHByb3BzLCBjb25kaXRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgY29uc3QgZGlyID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczoge1xuICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogZGlyID09PSBcInJ0bFwiXG4gICAgICB9LCBkaXI6IGRpciB9LCBoKFwiY2FsY2l0ZS1ibG9ja1wiLCB7IGhlYWRpbmc6IGNvbmRpdGlvbnMubGVuZ3RoID09PSAxID8gc3RyaW5ncy5leHByZXNzaW9uIDogc3RyaW5ncy5leHByZXNzaW9uU2V0LCBvcGVuOiB0cnVlIH0sIHRoaXMucmVuZGVyTWVudSgpLCB0aGlzLnJlbmRlck1hdGNoQ29uZGl0aW9uKCksIHRoaXMucmVuZGVyQ29uZGl0aW9ucygpLCB0aGlzLnJlbmRlckFkZENvbmRpdGlvbkJ1dHRvbigpKSkpO1xuICB9XG4gIHJlbmRlck1lbnUoKSB7XG4gICAgY29uc3QgeyBwcm9wcywgY2FuRHVwbGljYXRlLCBjYW5SZW1vdmUsIGNvbmRpdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWFjdGlvbi1tZW51XCIsIHsgc2xvdDogXCJjb250cm9sXCIsIHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsIG92ZXJsYXlQb3NpdGlvbmluZzogXCJmaXhlZFwiLCBsYWJlbDogc3RyaW5ncy5hY2Nlc3NpYmlsaXR5Lm1vcmVPcHRpb25zLCByZWY6IChub2RlKSA9PiAodGhpcy5tZW51Tm9kZSA9IG5vZGUpIH0sIGNhblJlbW92ZSAmJiAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogY29uZGl0aW9ucy5sZW5ndGggPT09IDEgPyBzdHJpbmdzLmRlbGV0ZUV4cHJlc3Npb24gOiBzdHJpbmdzLmRlbGV0ZVNldCwgdGV4dEVuYWJsZWQ6IHRydWUsIFwiZGF0YS12YWx1ZVwiOiBcInJlbW92ZVwiLCBvbkNsaWNrOiB0aGlzLm9uUmVtb3ZlRXhwcmVzc2lvbiB9KSksIGNhbkR1cGxpY2F0ZSAmJiAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5kdXBsaWNhdGUsIHRleHRFbmFibGVkOiB0cnVlLCBcImRhdGEtdmFsdWVcIjogXCJjb3B5XCIsIG9uQ2xpY2s6IHRoaXMub25Db3B5RXhwcmVzc2lvbiB9KSksIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IHRleHQ6IHN0cmluZ3MuYWRkQ29uZGl0aW9uLCB0ZXh0RW5hYmxlZDogdHJ1ZSwgXCJkYXRhLXZhbHVlXCI6IFwiYWRkXCIsIG9uQ2xpY2s6IHRoaXMub25BZGRDb25kaXRpb24gfSkpKTtcbiAgfVxuICByZW5kZXJNYXRjaENvbmRpdGlvbigpIHtcbiAgICBjb25zdCB7IGNvbmRpdGlvbnMsIGxvZ2ljYWxPcGVyYXRvckZvckNvbmRpdGlvbnMsIHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgaWYgKCFjb25kaXRpb25zIHx8ICFjb25kaXRpb25zLmxlbmd0aCB8fCBjb25kaXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGlzQW5kID0gbG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucyAhPT0gbG9naWNhbE9wZXJhdG9ycy5PUjtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEubWF0Y2hDb25kaXRpb24gfSwgaChcImNhbGNpdGUtc2VsZWN0XCIsIHsgd2lkdGg6IFwiZnVsbFwiLCBzY2FsZTogXCJtXCIsIGxhYmVsOiBzdHJpbmdzLmFjY2Vzc2liaWxpdHkubWF0Y2hDb25kaXRpb25zLCBjbGFzczogQ1NTJDEubWF0Y2hDb25kaXRpb25Ecm9wZG93biwgb25DYWxjaXRlU2VsZWN0Q2hhbmdlOiB0aGlzLm9uTWF0Y2hTZWxlY3QgfSwgaChcImNhbGNpdGUtb3B0aW9uXCIsIHsgdmFsdWU6IGxvZ2ljYWxPcGVyYXRvcnMuQU5ELCBsYWJlbDogc3RyaW5ncy5tYXRjaEFsbENvbmRpdGlvbnMsIHNlbGVjdGVkOiBpc0FuZCB9KSwgaChcImNhbGNpdGUtb3B0aW9uXCIsIHsgdmFsdWU6IGxvZ2ljYWxPcGVyYXRvcnMuT1IsIGxhYmVsOiBzdHJpbmdzLm1hdGNoQXRMZWFzdE9uZUNvbmRpdGlvbiwgc2VsZWN0ZWQ6ICFpc0FuZCB9KSkpKTtcbiAgfVxuICByZW5kZXJDb25kaXRpb25zKCkge1xuICAgIGNvbnN0IHsgY29uZGl0aW9ucyB9ID0gdGhpcztcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuY29udGVudCB9LCBjb25kaXRpb25zLm1hcCgoY29uZGl0aW9uUHJvcHMsIGlkeCkgPT4gdGhpcy5yZW5kZXJDb25kaXRpb24oY29uZGl0aW9uUHJvcHMsIGlkeCkpKSk7XG4gIH1cbiAgcmVuZGVyQ29uZGl0aW9uKGNvbmRpdGlvblByb3BzLCBjb25kaXRpb25JbmRleCkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIHRoaXMucmVuZGVyQ29uZGl0aW9uSGVhZGVyKGNvbmRpdGlvbkluZGV4KSwgaChcImFyY2dpcy1maWx0ZXItY29uZGl0aW9uXCIsIE9iamVjdC5hc3NpZ24oeyBwcm9wczogcHJvcHMgfSwgY29uZGl0aW9uUHJvcHMpKSkpO1xuICB9XG4gIHJlbmRlckFkZENvbmRpdGlvbkJ1dHRvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuc2hvd0FkZENvbmRpdGlvbkJ1dHRvbiAmJiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgYWxpZ25tZW50OiBcImNlbnRlclwiLCBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGNsYXNzOiBDU1MkMS5hZGRDb25kaXRpb25CdXR0b24sIFwiaWNvbi1zdGFydFwiOiBcInBsdXNcIiwgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiB0aGlzLm9uQWRkQ29uZGl0aW9uIH0sIHRoaXMucHJvcHMuc3RyaW5ncy5hZGRDb25kaXRpb24pKSk7XG4gIH1cbiAgcmVuZGVyQ29uZGl0aW9uSGVhZGVyKGNvbmRpdGlvbkluZGV4KSB7XG4gICAgY29uc3QgeyBwcm9wcywgbG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9ucywgY29uZGl0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGlmIChjb25kaXRpb25zLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpc0FuZCA9IGxvZ2ljYWxPcGVyYXRvckZvckNvbmRpdGlvbnMgIT09IGxvZ2ljYWxPcGVyYXRvcnMuT1I7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQxLmNvbmRpdGlvbkhlYWRlciB9LCBjb25kaXRpb25JbmRleCA+IDAgPyAoaChcInNwYW5cIiwgeyBjbGFzczogQ1NTJDEubWF0Y2hUeXBlVGV4dCB9LCBpc0FuZCA/IHN0cmluZ3MuYW5kIDogc3RyaW5ncy5vcikpIDogbnVsbCwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgbGFiZWw6IHN0cmluZ3MucmVtb3ZlLCB0ZXh0OiBcIlwiLCBpY29uOiBcInhcIiwgY29tcGFjdDogdHJ1ZSwgXCJkYXRhLXZhbHVlXCI6IGAke2NvbmRpdGlvbkluZGV4fWAsIG9uQ2xpY2s6IHRoaXMub25SZW1vdmVDb25kaXRpb24gfSkpKTtcbiAgfVxuICBmaXhVSURzRm9yRXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIHByb3BzLmV4cHJlc3Npb25zID0gZml4VUlEcyhwcm9wcy5leHByZXNzaW9ucyk7XG4gICAgdGhpcy5jb25kaXRpb25zID0gcHJvcHMuZXhwcmVzc2lvbnMuZmlsdGVyKChleHByZXNzaW9uKSA9PiBleHByZXNzaW9uLnVpZCA9PT0gdGhpcy51aWQpWzBdLmNvbmRpdGlvbnM7XG4gIH1cbiAgZW1pdENoYW5nZUV2ZW50KCkge1xuICAgIGNvbnN0IHsgdWlkLCBjb25kaXRpb25zLCBsb2dpY2FsT3BlcmF0b3JGb3JDb25kaXRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0V4cHJlc3Npb24gPSB7XG4gICAgICB1aWQsXG4gICAgICBjb25kaXRpb25zLFxuICAgICAgbG9naWNhbE9wZXJhdG9yRm9yQ29uZGl0aW9uc1xuICAgIH07XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ2hhbmdlZC5lbWl0KHsgdHlwZTogXCJyZXBsYWNlXCIsIGV4cHJlc3Npb246IG5ld0V4cHJlc3Npb24gfSk7XG4gIH1cbiAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0ZpbHRlckV4cHJlc3Npb24uc3R5bGUgPSBhcmNnaXNGaWx0ZXJFeHByZXNzaW9uQ3NzO1xuXG5jb25zdCBDU1MgPSB7XG4gIGNvbnRhaW5lcjogXCJjb250YWluZXJcIixcbiAgcGlja0xpc3Q6IFwicG9wb3Zlci11bmlxdWUtcGljay1saXN0XCIsXG4gIHVuaXF1ZVZhbHVlc0NvbnRlbnRMaXN0TXNnOiBcInVuaXF1ZS12YWx1ZXMtY29udGVudC1saXN0LW1zZ1wiLFxuICBjb3VudDogXCJjb3VudFwiLFxuICB1bmlxdWVWYWx1ZXNEb25lOiBcInVuaXF1ZS12YWx1ZXMtZG9uZVwiXG59O1xuXG5jb25zdCBhcmNnaXNGaWx0ZXJVbmlxdWVMaXN0Q3NzID0gXCIuc2MtYXJjZ2lzLWZpbHRlci11bmlxdWUtbGlzdC1oe3dpZHRoOjEwMCV9LmNvbnRhaW5lci5zYy1hcmNnaXMtZmlsdGVyLXVuaXF1ZS1saXN0e21pbi1oZWlnaHQ6MzBweH0ucG9wb3Zlci11bmlxdWUtcGljay1saXN0LnNjLWFyY2dpcy1maWx0ZXItdW5pcXVlLWxpc3R7d2lkdGg6MTAwJTtvdmVyZmxvdy15OmF1dG99LnVuaXF1ZS12YWx1ZXMtY29udGVudC1saXN0LW1zZy5zYy1hcmNnaXMtZmlsdGVyLXVuaXF1ZS1saXN0e2ZvbnQtc2l6ZTo3NSU7bWFyZ2luOjVweH0uY291bnQuc2MtYXJjZ2lzLWZpbHRlci11bmlxdWUtbGlzdHtwYWRkaW5nOjEycHggNnB4fS51bmlxdWUtdmFsdWVzLWRvbmUuc2MtYXJjZ2lzLWZpbHRlci11bmlxdWUtbGlzdHtwYWRkaW5nOjAuNXJlbX1cIjtcblxuY29uc3QgQXJjZ2lzRmlsdGVyVW5pcXVlTGlzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJVbmlxdWVMaXN0RG9uZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyVW5pcXVlTGlzdERvbmVcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJVbmlxdWVMaXN0Q2hhbmdlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyVW5pcXVlTGlzdENoYW5nZWRcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNGaWx0ZXJVbmlxdWVMaXN0U29ydEJ5Q2hhbmdlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzRmlsdGVyVW5pcXVlTGlzdFNvcnRCeUNoYW5nZWRcIiwgNyk7XG4gICAgdGhpcy5vblNvcnRNZW51U2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkcm9wZG93biA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCB0eXBlID0gKF9hID0gZHJvcGRvd24uc2VsZWN0ZWRJdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIik7XG4gICAgICB0aGlzLnNvcnRCeSA9IHR5cGU7XG4gICAgICB0aGlzLmFyY2dpc0ZpbHRlclVuaXF1ZUxpc3RTb3J0QnlDaGFuZ2VkLmVtaXQoeyB1aWQ6IHRoaXMudWlkLCBzb3J0Qnk6IHR5cGUgfSk7XG4gICAgfTtcbiAgICB0aGlzLmRvbmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmFyY2dpc0ZpbHRlclVuaXF1ZUxpc3REb25lLmVtaXQodGhpcy51aWQpO1xuICAgIH07XG4gICAgdGhpcy51aWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaXF1ZVZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZmllbGREb21haW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGF5ZXJGaWVsZFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3J0QnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tdWx0aXBsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnRpYWxVbmlxdWVWYWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdHJpbmdzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9jYWxlID0gdW5kZWZpbmVkO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQdWJsaWMgTWV0aG9kc1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBzZXRGb2N1cygpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5waWNrTGlzdE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIGNvbnN0IFtpbnRsXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaW50bFwiXSk7XG4gICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICB0aGlzLmludGwuc2V0TG9jYWxlKHRoaXMubG9jYWxlKTtcbiAgfVxuICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIC8vdGhpcy5zZXRGb2N1cygpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vdGhpcy5yZW1vdmVGaWVsZHNQaWNrTGlzdCgpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHVpZCwgdW5pcXVlVmFsdWVzLCBzZWxlY3RlZFZhbHVlcywgbGF5ZXJGaWVsZFR5cGUsIGZpZWxkRG9tYWlucywgc29ydEJ5LCBtdWx0aXBsZSwgcGFydGlhbFVuaXF1ZVZhbHVlcywgbWF4SGVpZ2h0LCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNvcnRCeUNvdW50ID0gKGxpc3QpID0+IHtcbiAgICAgIGxpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYS5jb3VudCA8PSBiLmNvdW50ID8gMSA6IC0xO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzb3J0QWxwaGFiZXRpY2FsbHkgPSAobGlzdCkgPT4ge1xuICAgICAgY29uc3QgaGFzRG9tYWlucyA9IGZpZWxkRG9tYWlucyA9PT0gbnVsbCB8fCBmaWVsZERvbWFpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkRG9tYWlucy5sZW5ndGg7XG4gICAgICBsaXN0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVBID0gaGFzRG9tYWlucyA/IHRoaXMuZ2V0RGVjb2RlZFZhbHVlKGEudmFsdWUpIDogYS52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFsdWVCID0gaGFzRG9tYWlucyA/IHRoaXMuZ2V0RGVjb2RlZFZhbHVlKGIudmFsdWUpIDogYi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlQX1gLmNoYXJBdCgwKSA9PT0gXCJfXCJcbiAgICAgICAgICA/IDFcbiAgICAgICAgICA6IGAke3ZhbHVlQn1gLmNoYXJBdCgwKSA9PT0gXCJfXCJcbiAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgIDogYCR7dmFsdWVBfWAubG9jYWxlQ29tcGFyZShgJHt2YWx1ZUJ9YCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNvcnRTZWxlY3RlZCA9IChsaXN0LCB2YWx1ZXMpID0+IHtcbiAgICAgIGxpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBwb3NBID0gKF9hID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmluZGV4T2YoYS52YWx1ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xO1xuICAgICAgICBjb25zdCBwb3NCID0gKF9iID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmluZGV4T2YoYi52YWx1ZSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC0xO1xuICAgICAgICByZXR1cm4gcG9zQSA9PT0gcG9zQiB8fCAocG9zQSA+IC0xICYmIHBvc0IgPiAtMSkgPyAwIDogcG9zQSA+IHBvc0IgPyAtMSA6IDE7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHNvcnRBbHBoYWJldGljYWxseSh1bmlxdWVWYWx1ZXMpO1xuICAgIGlmICghc29ydEJ5IHx8IHNvcnRCeSA9PT0gXCJjb3VudFwiKSB7XG4gICAgICBzb3J0QnlDb3VudCh1bmlxdWVWYWx1ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3J0QnkgPT09IFwic2VsZWN0ZWRcIikge1xuICAgICAgc29ydFNlbGVjdGVkKHVuaXF1ZVZhbHVlcywgc2VsZWN0ZWRWYWx1ZXMpO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ID0gdW5pcXVlVmFsdWVzLm1hcCgoaW5mbykgPT4gdGhpcy5yZW5kZXJVbmlxdWVWYWx1ZShpbmZvKSk7XG4gICAgbGV0IG1zZ05vZGU7XG4gICAgaWYgKHBhcnRpYWxVbmlxdWVWYWx1ZXMpIHtcbiAgICAgIG1zZ05vZGUgPSAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MudW5pcXVlVmFsdWVzQ29udGVudExpc3RNc2cgfSwgc3RyaW5ncy5lcnJvcnMudG9vTWFueVVuaXF1ZVZhbHVlcykpO1xuICAgIH1cbiAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGFpbmVyIH0sIGgoXCJjYWxjaXRlLXBpY2stbGlzdFwiLCB7IGNsYXNzOiBDU1MucGlja0xpc3QsIGZpbHRlckVuYWJsZWQ6IHVuaXF1ZVZhbHVlcy5sZW5ndGggPiAxMCwgbXVsdGlwbGU6IG11bHRpcGxlLCBcImZpbHRlci1wbGFjZWhvbGRlclwiOiBzdHJpbmdzLnNlYXJjaFZhbHVlcywgb25DYWxjaXRlTGlzdENoYW5nZTogYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGxldCBzZWxlY3RlZFZhbHVlcyA9IFsuLi4oYXdhaXQgbm9kZS5nZXRTZWxlY3RlZEl0ZW1zKCkpLmtleXMoKV07XG4gICAgICAgIGlmIChsYXllckZpZWxkVHlwZSA9PT0gXCJkYXRlLW9ubHlcIikge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gc2VsZWN0ZWRWYWx1ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWRWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkVmFsdWVzLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZGF0ZSBzdHJpbmcgdG8gVU5JWCB0aW1lc3RhbXAgKHdpdGhvdXQgdGltZXN0YW1wIG9mZnNldCBzaGlmdClcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSArIG9mZnNldDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChbXCJkYXRlXCIsIFwib2lkXCIsIFwiZ3VpZFwiLCBcInNtYWxsLWludGVnZXJcIiwgXCJiaWctaW50ZWdlclwiLCBcImludGVnZXJcIiwgXCJsb25nXCJdLmluZGV4T2YobGF5ZXJGaWVsZFR5cGUpID4gLTEpIHtcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IHNlbGVjdGVkVmFsdWVzID09PSBudWxsIHx8IHNlbGVjdGVkVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZFZhbHVlcy5tYXAoKHZhbHVlKSA9PiBwYXJzZUludCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFtcInNpbmdsZVwiLCBcImRvdWJsZVwiXS5pbmRleE9mKGxheWVyRmllbGRUeXBlKSA+IC0xKSB7XG4gICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBzZWxlY3RlZFZhbHVlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZFZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRWYWx1ZXMubWFwKCh2YWx1ZSkgPT4gcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZXMgPSBzZWxlY3RlZFZhbHVlcztcbiAgICAgICAgdGhpcy5hcmNnaXNGaWx0ZXJVbmlxdWVMaXN0Q2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICB1aWQsXG4gICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgc29ydEJ5XG4gICAgICAgIH0pO1xuICAgICAgfSwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICB0aGlzLnBpY2tMaXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIGlmIChtYXhIZWlnaHQpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBtYXgtaGVpZ2h0OiAke21heEhlaWdodCB8fCA0MDB9cHhgKTtcbiAgICAgICAgfVxuICAgICAgfSB9LCB1bmlxdWVWYWx1ZXMubGVuZ3RoID4gMTAgPyB0aGlzLnJlbmRlclNvcnQoKSA6IG51bGwsIGxpc3QpLCBtc2dOb2RlLCB0aGlzLnJlbmRlckRvbmUoKSkpKTtcbiAgfVxuICByZW5kZXJTb3J0KCkge1xuICAgIGNvbnN0IHsgc29ydEJ5LCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtZHJvcGRvd25cIiwgeyBzbG90OiBcIm1lbnUtYWN0aW9uc1wiLCBwbGFjZW1lbnQ6IFwiYm90dG9tLWVuZFwiLCBvdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiwgd2lkdGg6IFwic1wiLCBvbkNhbGNpdGVEcm9wZG93blNlbGVjdDogdGhpcy5vblNvcnRNZW51U2VsZWN0IH0sIGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IHNsb3Q6IFwidHJpZ2dlclwiLCBsYWJlbDogc3RyaW5ncy5zb3J0VmFsdWVzLCB0ZXh0OiBcIlwiIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBzY2FsZTogXCJzXCIsIGljb246IFwic29ydERlc2NlbmRpbmdcIiB9KSksIGgoXCJjYWxjaXRlLWRyb3Bkb3duLWdyb3VwXCIsIG51bGwsIGgoXCJjYWxjaXRlLWRyb3Bkb3duLWl0ZW1cIiwgeyBzZWxlY3RlZDogc29ydEJ5ID09PSBcImNvdW50XCIgfHwgIWlzRGVmaW5lZChzb3J0QnkpLCBcImRhdGEtdmFsdWVcIjogXCJjb3VudFwiIH0sIHN0cmluZ3Muc29ydEJ5Q291bnQpLCBoKFwiY2FsY2l0ZS1kcm9wZG93bi1pdGVtXCIsIHsgc2VsZWN0ZWQ6IHNvcnRCeSA9PT0gXCJuYW1lXCIsIFwiZGF0YS12YWx1ZVwiOiBcIm5hbWVcIiB9LCBzdHJpbmdzLnNvcnRBbHBoYWJldGljYWwpLCBoKFwiY2FsY2l0ZS1kcm9wZG93bi1pdGVtXCIsIHsgc2VsZWN0ZWQ6IHNvcnRCeSA9PT0gXCJzZWxlY3RlZFwiLCBcImRhdGEtdmFsdWVcIjogXCJzZWxlY3RlZFwiIH0sIHN0cmluZ3Muc29ydFNlbGVjdGVkKSkpKTtcbiAgfVxuICByZW5kZXJVbmlxdWVWYWx1ZShpbmZvKSB7XG4gICAgY29uc3QgeyBzZWxlY3RlZFZhbHVlcywgZmllbGREb21haW5zLCBsYXllckZpZWxkVHlwZSwgaXNEYXRlLCBpbnRsLCBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHZpZXcgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdGltZVpvbmUgfSA9IHZpZXc7XG4gICAgY29uc3QgdmFsdWUgPSAoZmllbGREb21haW5zID09PSBudWxsIHx8IGZpZWxkRG9tYWlucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGREb21haW5zLmxlbmd0aClcbiAgICAgID8gdGhpcy5nZXREZWNvZGVkVmFsdWUoaW5mby52YWx1ZSlcbiAgICAgIDogaXNEYXRlXG4gICAgICAgID8gbGF5ZXJGaWVsZFR5cGUgPT09IFwiZGF0ZS1vbmx5XCJcbiAgICAgICAgICA/IHRoaXMuZ2V0RGF0ZU9ubHlTdHJpbmcoaW5mby52YWx1ZSlcbiAgICAgICAgICA6IGdldERhdGVEaXNwbGF5U3RyaW5nKGluZm8udmFsdWUsIHRpbWVab25lLCBpbnRsKVxuICAgICAgICA6IHR5cGVvZiBpbmZvLnZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgPyBpbnRsLmZvcm1hdE51bWJlcihpbmZvLnZhbHVlKVxuICAgICAgICAgIDogaW5mby52YWx1ZTtcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZXMgPyBzZWxlY3RlZFZhbHVlcy5pbmRleE9mKGluZm8udmFsdWUpID4gLTEgOiBmYWxzZTtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXBpY2stbGlzdC1pdGVtXCIsIHsga2V5OiBgcGljay1saXN0LWl0ZW1fJHtpbmZvLnZhbHVlfWAsIGxhYmVsOiBgJHt2YWx1ZX1gLCB2YWx1ZTogYCR7aW5mby52YWx1ZX1gLCBzZWxlY3RlZDogaXNTZWxlY3RlZCB9LCBpc0RlZmluZWQoaW5mby5jb3VudCkgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY291bnQsIHNsb3Q6IFwiYWN0aW9ucy1lbmRcIiB9LCBgJHtpbmZvLmNvdW50fWApKSA6IG51bGwpKTtcbiAgfVxuICByZW5kZXJEb25lKCkge1xuICAgIGNvbnN0IHsgbXVsdGlwbGUsIHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MudW5pcXVlVmFsdWVzRG9uZSB9LCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCB3aWR0aDogXCJmdWxsXCIsIG9uQ2xpY2s6IHRoaXMuZG9uZSwgbGFiZWw6IHN0cmluZ3MuZG9uZSB9LCBzdHJpbmdzLmRvbmUpKSk7XG4gIH1cbiAgZ2V0RGVjb2RlZFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgeyBmaWVsZERvbWFpbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgY29kZWRWYWx1ZXMgPSBmaWVsZERvbWFpbnM7XG4gICAgaWYgKGNvZGVkVmFsdWVzKSB7XG4gICAgICBsZXQgbGFiZWwgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlZFZhbHVlID0gY29kZWRWYWx1ZXNbaV07XG4gICAgICAgIGlmIChjb2RlZFZhbHVlLmNvZGUgPT0gdmFsdWUpIHtcbiAgICAgICAgICBsYWJlbCArPSAobGFiZWwubGVuZ3RoID8gXCIgfCBcIiA6IFwiXCIpICsgY29kZWRWYWx1ZS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxuICAgIC8vIGRpZCBub3QgZmluZCBpdFxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXREYXRlT25seVN0cmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IHsgaW50bCB9ID0gdGhpcztcbiAgICByZXR1cm4gdmFsdWUgPyBpbnRsLmZvcm1hdERhdGVPbmx5KHZhbHVlKSA6IFwiXCI7XG4gIH1cbiAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0ZpbHRlclVuaXF1ZUxpc3Quc3R5bGUgPSBhcmNnaXNGaWx0ZXJVbmlxdWVMaXN0Q3NzO1xuXG5leHBvcnQgeyBBcmNnaXNGaWx0ZXIgYXMgYXJjZ2lzX2ZpbHRlciwgQXJjZ2lzRmlsdGVyQ29uZGl0aW9uIGFzIGFyY2dpc19maWx0ZXJfY29uZGl0aW9uLCBBcmNnaXNGaWx0ZXJFeHByZXNzaW9uIGFzIGFyY2dpc19maWx0ZXJfZXhwcmVzc2lvbiwgQXJjZ2lzRmlsdGVyVW5pcXVlTGlzdCBhcyBhcmNnaXNfZmlsdGVyX3VuaXF1ZV9saXN0IH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICByZXR1cm4gc3RhdHVzO1xuICB9XG4gIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICB9LCBkZWxheSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgY29uc3QgbG9va3VwTWFwID0ge307XG4gIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgY29uc3Qgb2JqcyA9IFtdO1xuICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTEzZjViMDBjLmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICB9XG4gIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICBsZXQgc3RyaW5ncztcbiAgdHJ5IHtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gIH1cbiAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9