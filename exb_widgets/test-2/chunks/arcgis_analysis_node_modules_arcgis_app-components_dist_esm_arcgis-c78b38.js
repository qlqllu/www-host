"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-c78b38"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-workflow.entry.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-workflow.entry.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_workflow: () => (/* binding */ ArcgisWorkflow)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _store_3210b604_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./store-3210b604.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-3210b604.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */









const arcgisWorkflowCss = "calcite-modal{--calcite-modal-content-padding:0;--calcite-modal-content-background:var(--calcite-ui-background);--calcite-modal-width:1080px;--calcite-modal-height:min(922px, 75vh)}:host{border:10px solid black;overflow-x:hidden}.content{overflow-y:auto;height:100%;overflow-x:hidden}.padded{padding:1rem}.stage{box-sizing:border-box;opacity:1;display:block;transition:all 200ms ease-in-out}.stage--fullscreen{overflow:auto;padding-bottom:0}.stage-anim{position:absolute;transform:translate3d(0, 0, 0)}.stage-anim--left{opacity:0;transform:translate3d(-24px, 0, 0)}.stage-anim--right{opacity:0;transform:translate3d(24px, 0, 0)}.header{display:flex;align-items:center;position:relative}.header>.icon{border-style:none;margin-left:0.5rem;margin-right:0.5rem;padding:0;display:flex;background-color:transparent}@media screen and (max-width: 480px){.stage{padding-bottom:6rem}}.header__title{font-size:1.125rem;margin:0;padding:0;font-weight:500}@media screen and (max-width: 1080px){.content{height:100%}}.onboarding{--arcgis-information-min-width:0}.onboarding__scroll{overflow:auto;max-height:min(700px, 60vh)}.onboarding__section{padding-bottom:1rem;padding-top:0.5rem;width:255px}.onboarding__title{color:var(--calcite-ui-text-1);font-size:0.875rem;padding-top:0;margin:0;font-weight:600}.onboarding__description{margin-top:0.5rem;margin-bottom:0.75rem;font-size:0.75rem;color:var(--calcite-ui-text-1)}.modal--grey{--calcite-modal-content-padding:0;--calcite-modal-content-background:var(--calcite-ui-background)}";

const ANIMATION_DURATION = 200;
const ArcgisWorkflow = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisWorkflowUpdatePage = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisWorkflowUpdatePage", 7);
    this.workflowCancel = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "workflowCancel", 7);
    this.workflowComplete = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "workflowComplete", 7);
    this.showBackButton = false;
    this.workflowCompleted = false;
    this.toggleFooterVisibility = (visible) => {
      var _a;
      const shadowRoot = (_a = this.modalRef) === null || _a === void 0 ? void 0 : _a.shadowRoot;
      if (shadowRoot) {
        const modalFooter = shadowRoot.querySelector(".footer");
        const modalContent = shadowRoot.querySelector(".content");
        if (modalFooter && modalContent) {
          modalFooter.style.display = visible ? "flex" : "none";
        }
      }
    };
    this.closeDialog = () => {
      !this.workflowCompleted && this.handleCancel();
      this.workflowCompleted = false;
      this.pageHistory = [this.firstPage];
    };
    this.handleCancel = async () => {
      this.workflowCancel.emit();
    };
    this.firstPage = undefined;
    this.isActive = true;
    this.headerText = "";
    this.primaryButtonText = undefined;
    this.loadingText = undefined;
    this.pageHistory = [];
    this.navEnabled = true;
    this.transition = undefined;
    this.isLoading = false;
    this.padded = true;
    this.error = null;
  }
  handleRedirect() {
    this.isActive = false;
  }
  // TODO: Might not need this? Should be the concern of the specific workflow
  handleWorkflowComplete() {
    this.workflowCompleted = true;
  }
  toggleNavigationEnabled(event) {
    this.navEnabled = event.detail;
  }
  /**
   * Configure modal event
   * Would handle setting properties on the main modal from each page
   * TODO: Strong types - need to keep this tidy, minimal config options
   * Before page change, spread incoming page config with a default set
   *
   * Configuration options:
   * Show/hide footer
   * Show/hide back button
   * Padded/fullscreen
   * Enable/disable buttons
   *  */
  configureModal(event) {
    const { padded, footerVisible } = event.detail;
    this.padded = padded;
    this.toggleFooterVisibility(footerVisible);
  }
  // TODO: combine update, previous?
  async goToNextPage(event) {
    this.pageHistory = [...this.pageHistory, event.detail];
    await this.transitionPage("forward");
  }
  async goToPreviousPage() {
    await this.transitionPage("back");
  }
  reportError({ detail: errorMessage }) {
    this.error = errorMessage;
  }
  triggerPageTransition(eventType) {
    var _a;
    const event = new CustomEvent(eventType, { cancelable: true });
    const eventNotCancelled = (_a = this.currentPageEl) === null || _a === void 0 ? void 0 : _a.dispatchEvent(event);
    if (eventNotCancelled && eventType === "arcgisWorkflowPagePrevious") {
      this.goToPreviousPage();
    }
  }
  async transitionPage(direction) {
    var _a, _b;
    (_a = this.primaryButtonText) !== null && _a !== void 0 ? _a : (this.primaryButtonText = this.i18n.next);
    this.transition = direction;
    await (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.t)(ANIMATION_DURATION);
    this.transition = null;
    if (direction === "back") {
      this.pageHistory = this.pageHistory.slice(0, -1);
    }
    const transitionCompleteEvent = new CustomEvent("arcgisTransitionComplete");
    (_b = this.currentPageEl) === null || _b === void 0 ? void 0 : _b.dispatchEvent(transitionCompleteEvent);
    await (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.t)(ANIMATION_DURATION);
    this.focusFirstElement();
  }
  updateActive(active) {
    if (active && this.firstPage) {
      this.pageHistory = [this.firstPage];
    }
  }
  updateFirstPage(page) {
    this.pageHistory = [page];
  }
  focusFirstElement() {
    var _a, _b;
    const curPage = this.currentPageEl;
    if (curPage && !curPage.managedFocus) {
      (_b = (_a = this.modalRef) === null || _a === void 0 ? void 0 : _a.setFocus) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  }
  /** Update the component in the modal's slot when a state change is detected */
  displayPage() {
    const { transition, pageHistory, padded } = this;
    const forward = transition === "forward";
    const back = transition === "back";
    const next = back ? pageHistory[pageHistory.length - 2] : pageHistory[pageHistory.length - 1];
    // Don't render a page if modal isn't active or pageHistory is empty
    if (!this.isActive || !next) {
      return;
    }
    // TODO: strictly type this
    const NextScreen = `${next.element}`;
    const CurrentScreen = this.currentScreen;
    if (CurrentScreen && pageHistory.length > 1 && transition) {
      return [
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(CurrentScreen, { class: {
            stage: true,
            "stage-anim": true,
            "stage-anim--left": forward,
            "stage-anim--right": back,
            padded
          } }),
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(NextScreen, { class: {
            stage: true,
            "stage-anim": true,
            "stage-anim--left": back,
            "stage-anim--right": forward,
            padded
          }, ref: (el) => {
            this.currentPageEl = el;
          } })
      ];
    }
    else {
      this.currentScreen = NextScreen;
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(NextScreen, Object.assign({}, next.props, { class: {
        stage: true,
        padded
      }, ref: (el) => {
        this.currentPageEl = el;
      } })));
  }
  disconnectedCallback() {
    this.closeDialog();
  }
  /** Initialize the config store with data from props on load */
  async componentWillLoad() {
    var _a;
    const { firstPage } = this;
    const locale = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el);
    _store_3210b604_js__WEBPACK_IMPORTED_MODULE_3__.w.i18n = locale[0];
    _store_3210b604_js__WEBPACK_IMPORTED_MODULE_3__.w.lang = locale[1];
    this.i18n = locale[0];
    (_a = this.primaryButtonText) !== null && _a !== void 0 ? _a : (this.primaryButtonText = this.i18n.next);
    this.loadingText = this.i18n.loading;
    if (firstPage) {
      this.pageHistory = [this.firstPage];
    }
  }
  componentWillRender() {
    this.showBackButton = this.pageHistory.length > 1;
  }
  componentDidRender() {
    var _a;
    const shadowRoot = (_a = this.modalRef) === null || _a === void 0 ? void 0 : _a.shadowRoot;
    if (shadowRoot) {
      // Help the tooltip to be on top of the footer
      const modalHeader = shadowRoot.querySelector(".header");
      if (modalHeader) {
        modalHeader.style.zIndex = "3";
      }
    }
  }
  componentDidLoad() {
    var _a, _b, _c;
    (_b = (_a = this.modalRef) === null || _a === void 0 ? void 0 : _a.setFocus) === null || _b === void 0 ? void 0 : _b.call(_a);
    const contentContainer = (_c = this.modalRef) === null || _c === void 0 ? void 0 : _c.shadowRoot.querySelector(".content");
    if (contentContainer) {
      contentContainer.style.overflowX = "hidden";
    }
  }
  render() {
    const { i18n, isLoading, loadingText, isActive, error } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-modal", { ref: (ele) => (this.modalRef = ele), open: isActive, onCalciteModalClose: this.closeDialog, outsideCloseDisabled: true, escapeDisabled: true }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "header", class: "header" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("h3", { id: "modal-title", class: "header__title" }, this.headerText)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "content", class: "content" }, isLoading ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "stage" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-workflow-loader", { active: isLoading, text: loadingText }))) : (this.displayPage())), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "back" }, this.showBackButton && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", kind: "neutral", "data-id": "backButton", onClick: () => {
        this.triggerPageTransition("arcgisWorkflowPagePrevious");
      }, width: "full", disabled: !this.navEnabled }, i18n.back))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "secondary", appearance: "outline-fill", "data-id": "cancelButton", onClick: () => {
        this.isActive = false;
      }, width: "full" }, i18n.cancel), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { id: "primary-button", slot: "primary", appearance: "solid", "data-id": "nextButton", onClick: () => {
        this.triggerPageTransition("arcgisWorkflowPageNext");
      }, width: "full", disabled: !this.navEnabled }, this.primaryButtonText)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-alert", { heading: error === null || error === void 0 ? void 0 : error.title, description: error === null || error === void 0 ? void 0 : error.description, active: !!error, link: error === null || error === void 0 ? void 0 : error.link, onAlertDismiss: () => (this.error = null) })));
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "isActive": ["updateActive"],
    "firstPage": ["updateFirstPage"]
  }; }
};
ArcgisWorkflow.style = arcgisWorkflowCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



const languageMap = new Map([
  ["ar", "ar"],
  ["bg", "bg"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["cs", "cs"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["es", "es"],
  ["et", "et"],
  ["fi", "fi"],
  ["fr", "fr"],
  ["he", "he"],
  ["hr", "hr"],
  ["hu", "hu"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "ja"],
  ["ko", "ko"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["nb", "nb"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["pt-br", "pt-BR"],
  ["pt-pt", "pt-PT"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sr", "sr"],
  ["sv", "sv"],
  ["th", "th"],
  ["tr", "tr"],
  ["uk", "uk"],
  ["vi", "vi"],
  ["zh-cn", "zh-CN"],
  ["zh-hk", "zh-HK"],
  ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
  return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
  const closestWithProp = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
  return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
  rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
  const { api, type, places } = options || {};
  if (api === 4) {
    const [intl] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
    const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
      places,
      style: type,
      digitSeparator: true
    });
    return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
  }
  const [dojoNumber] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
  return dojoNumber.format(number, {
    type,
    places,
    pattern: options === null || options === void 0 ? void 0 : options.pattern
  });
}
const cache = {};
function formatDate(date) {
  const lang = document.documentElement.lang;
  const dayShortMonthYear = {
    year: "numeric",
    month: "short",
    day: "numeric"
  };
  if (!cache[lang]) {
    cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
  }
  return cache[lang].format(date);
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-3210b604.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-3210b604.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ workflowState)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const workflowStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  portal: null,
  user: null,
  i18n: null,
  scale: "m",
  api: 4,
  nextText: null,
  uploadProgress: 0
});
const workflowState = workflowStore.state;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWM3OGIzOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RztBQUNyRDtBQUNjO0FBQ2I7QUFDOUI7QUFDUztBQUNEO0FBQ047O0FBRTdCLHlDQUF5QyxrQ0FBa0MsZ0VBQWdFLDZCQUE2Qix3Q0FBd0MsTUFBTSx3QkFBd0Isa0JBQWtCLFNBQVMsZ0JBQWdCLFlBQVksa0JBQWtCLFFBQVEsYUFBYSxPQUFPLHNCQUFzQixVQUFVLGNBQWMsaUNBQWlDLG1CQUFtQixjQUFjLGlCQUFpQixZQUFZLGtCQUFrQiwrQkFBK0Isa0JBQWtCLFVBQVUsbUNBQW1DLG1CQUFtQixVQUFVLGtDQUFrQyxRQUFRLGFBQWEsbUJBQW1CLGtCQUFrQixjQUFjLGtCQUFrQixtQkFBbUIsb0JBQW9CLFVBQVUsYUFBYSw2QkFBNkIscUNBQXFDLE9BQU8scUJBQXFCLGVBQWUsbUJBQW1CLFNBQVMsVUFBVSxnQkFBZ0Isc0NBQXNDLFNBQVMsYUFBYSxZQUFZLGlDQUFpQyxvQkFBb0IsY0FBYyw0QkFBNEIscUJBQXFCLG9CQUFvQixtQkFBbUIsWUFBWSxtQkFBbUIsK0JBQStCLG1CQUFtQixjQUFjLFNBQVMsZ0JBQWdCLHlCQUF5QixrQkFBa0Isc0JBQXNCLGtCQUFrQiwrQkFBK0IsYUFBYSxrQ0FBa0MsZ0VBQWdFOztBQUV0Z0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBZ0I7QUFDcEIsb0NBQW9DLHFEQUFXO0FBQy9DLDBCQUEwQixxREFBVztBQUNyQyw0QkFBNEIscURBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYyxFQUFFLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWUsR0FBRyxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRTRFOzs7Ozs7Ozs7Ozs7Ozs7O0FDOUY1RTtBQUNBO0FBQ0E7QUFDQTtBQUN1RDs7QUFFdkQsc0JBQXNCLHFEQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUU4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy13b3JrZmxvdy5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9mdW5jdGlvbmFsLWM4MmY1YWI5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2luZGV4LTgxZDU0OGI3LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMTNlMDBhNzUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc3RvcmUtMzIxMGI2MDQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIEggYXMgSG9zdCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5pbXBvcnQgeyB0IGFzIHRpbWVvdXQgfSBmcm9tICcuL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMTNlMDBhNzUuanMnO1xuaW1wb3J0IHsgdyBhcyB3b3JrZmxvd1N0YXRlIH0gZnJvbSAnLi9zdG9yZS0zMjEwYjYwNC5qcyc7XG5pbXBvcnQgJy4vZG9tLTEzZjViMDBjLmpzJztcbmltcG9ydCAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCAnLi9pbmRleC04MWQ1NDhiNy5qcyc7XG5cbmNvbnN0IGFyY2dpc1dvcmtmbG93Q3NzID0gXCJjYWxjaXRlLW1vZGFsey0tY2FsY2l0ZS1tb2RhbC1jb250ZW50LXBhZGRpbmc6MDstLWNhbGNpdGUtbW9kYWwtY29udGVudC1iYWNrZ3JvdW5kOnZhcigtLWNhbGNpdGUtdWktYmFja2dyb3VuZCk7LS1jYWxjaXRlLW1vZGFsLXdpZHRoOjEwODBweDstLWNhbGNpdGUtbW9kYWwtaGVpZ2h0Om1pbig5MjJweCwgNzV2aCl9Omhvc3R7Ym9yZGVyOjEwcHggc29saWQgYmxhY2s7b3ZlcmZsb3cteDpoaWRkZW59LmNvbnRlbnR7b3ZlcmZsb3cteTphdXRvO2hlaWdodDoxMDAlO292ZXJmbG93LXg6aGlkZGVufS5wYWRkZWR7cGFkZGluZzoxcmVtfS5zdGFnZXtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3BhY2l0eToxO2Rpc3BsYXk6YmxvY2s7dHJhbnNpdGlvbjphbGwgMjAwbXMgZWFzZS1pbi1vdXR9LnN0YWdlLS1mdWxsc2NyZWVue292ZXJmbG93OmF1dG87cGFkZGluZy1ib3R0b206MH0uc3RhZ2UtYW5pbXtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCl9LnN0YWdlLWFuaW0tLWxlZnR7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMjRweCwgMCwgMCl9LnN0YWdlLWFuaW0tLXJpZ2h0e29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMjRweCwgMCwgMCl9LmhlYWRlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlfS5oZWFkZXI+Lmljb257Ym9yZGVyLXN0eWxlOm5vbmU7bWFyZ2luLWxlZnQ6MC41cmVtO21hcmdpbi1yaWdodDowLjVyZW07cGFkZGluZzowO2Rpc3BsYXk6ZmxleDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ4MHB4KXsuc3RhZ2V7cGFkZGluZy1ib3R0b206NnJlbX19LmhlYWRlcl9fdGl0bGV7Zm9udC1zaXplOjEuMTI1cmVtO21hcmdpbjowO3BhZGRpbmc6MDtmb250LXdlaWdodDo1MDB9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMTA4MHB4KXsuY29udGVudHtoZWlnaHQ6MTAwJX19Lm9uYm9hcmRpbmd7LS1hcmNnaXMtaW5mb3JtYXRpb24tbWluLXdpZHRoOjB9Lm9uYm9hcmRpbmdfX3Njcm9sbHtvdmVyZmxvdzphdXRvO21heC1oZWlnaHQ6bWluKDcwMHB4LCA2MHZoKX0ub25ib2FyZGluZ19fc2VjdGlvbntwYWRkaW5nLWJvdHRvbToxcmVtO3BhZGRpbmctdG9wOjAuNXJlbTt3aWR0aDoyNTVweH0ub25ib2FyZGluZ19fdGl0bGV7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO2ZvbnQtc2l6ZTowLjg3NXJlbTtwYWRkaW5nLXRvcDowO21hcmdpbjowO2ZvbnQtd2VpZ2h0OjYwMH0ub25ib2FyZGluZ19fZGVzY3JpcHRpb257bWFyZ2luLXRvcDowLjVyZW07bWFyZ2luLWJvdHRvbTowLjc1cmVtO2ZvbnQtc2l6ZTowLjc1cmVtO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKX0ubW9kYWwtLWdyZXl7LS1jYWxjaXRlLW1vZGFsLWNvbnRlbnQtcGFkZGluZzowOy0tY2FsY2l0ZS1tb2RhbC1jb250ZW50LWJhY2tncm91bmQ6dmFyKC0tY2FsY2l0ZS11aS1iYWNrZ3JvdW5kKX1cIjtcblxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gMjAwO1xuY29uc3QgQXJjZ2lzV29ya2Zsb3cgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzV29ya2Zsb3dVcGRhdGVQYWdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNXb3JrZmxvd1VwZGF0ZVBhZ2VcIiwgNyk7XG4gICAgdGhpcy53b3JrZmxvd0NhbmNlbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwid29ya2Zsb3dDYW5jZWxcIiwgNyk7XG4gICAgdGhpcy53b3JrZmxvd0NvbXBsZXRlID0gY3JlYXRlRXZlbnQodGhpcywgXCJ3b3JrZmxvd0NvbXBsZXRlXCIsIDcpO1xuICAgIHRoaXMuc2hvd0JhY2tCdXR0b24gPSBmYWxzZTtcbiAgICB0aGlzLndvcmtmbG93Q29tcGxldGVkID0gZmFsc2U7XG4gICAgdGhpcy50b2dnbGVGb290ZXJWaXNpYmlsaXR5ID0gKHZpc2libGUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSAoX2EgPSB0aGlzLm1vZGFsUmVmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hhZG93Um9vdDtcbiAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgIGNvbnN0IG1vZGFsRm9vdGVyID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLmZvb3RlclwiKTtcbiAgICAgICAgY29uc3QgbW9kYWxDb250ZW50ID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRlbnRcIik7XG4gICAgICAgIGlmIChtb2RhbEZvb3RlciAmJiBtb2RhbENvbnRlbnQpIHtcbiAgICAgICAgICBtb2RhbEZvb3Rlci5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/IFwiZmxleFwiIDogXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xvc2VEaWFsb2cgPSAoKSA9PiB7XG4gICAgICAhdGhpcy53b3JrZmxvd0NvbXBsZXRlZCAmJiB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgICAgdGhpcy53b3JrZmxvd0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5wYWdlSGlzdG9yeSA9IFt0aGlzLmZpcnN0UGFnZV07XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNhbmNlbCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMud29ya2Zsb3dDYW5jZWwuZW1pdCgpO1xuICAgIH07XG4gICAgdGhpcy5maXJzdFBhZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5oZWFkZXJUZXh0ID0gXCJcIjtcbiAgICB0aGlzLnByaW1hcnlCdXR0b25UZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9hZGluZ1RleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWdlSGlzdG9yeSA9IFtdO1xuICAgIHRoaXMubmF2RW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYWRkZWQgPSB0cnVlO1xuICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICB9XG4gIGhhbmRsZVJlZGlyZWN0KCkge1xuICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgfVxuICAvLyBUT0RPOiBNaWdodCBub3QgbmVlZCB0aGlzPyBTaG91bGQgYmUgdGhlIGNvbmNlcm4gb2YgdGhlIHNwZWNpZmljIHdvcmtmbG93XG4gIGhhbmRsZVdvcmtmbG93Q29tcGxldGUoKSB7XG4gICAgdGhpcy53b3JrZmxvd0NvbXBsZXRlZCA9IHRydWU7XG4gIH1cbiAgdG9nZ2xlTmF2aWdhdGlvbkVuYWJsZWQoZXZlbnQpIHtcbiAgICB0aGlzLm5hdkVuYWJsZWQgPSBldmVudC5kZXRhaWw7XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSBtb2RhbCBldmVudFxuICAgKiBXb3VsZCBoYW5kbGUgc2V0dGluZyBwcm9wZXJ0aWVzIG9uIHRoZSBtYWluIG1vZGFsIGZyb20gZWFjaCBwYWdlXG4gICAqIFRPRE86IFN0cm9uZyB0eXBlcyAtIG5lZWQgdG8ga2VlcCB0aGlzIHRpZHksIG1pbmltYWwgY29uZmlnIG9wdGlvbnNcbiAgICogQmVmb3JlIHBhZ2UgY2hhbmdlLCBzcHJlYWQgaW5jb21pbmcgcGFnZSBjb25maWcgd2l0aCBhIGRlZmF1bHQgc2V0XG4gICAqXG4gICAqIENvbmZpZ3VyYXRpb24gb3B0aW9uczpcbiAgICogU2hvdy9oaWRlIGZvb3RlclxuICAgKiBTaG93L2hpZGUgYmFjayBidXR0b25cbiAgICogUGFkZGVkL2Z1bGxzY3JlZW5cbiAgICogRW5hYmxlL2Rpc2FibGUgYnV0dG9uc1xuICAgKiAgKi9cbiAgY29uZmlndXJlTW9kYWwoZXZlbnQpIHtcbiAgICBjb25zdCB7IHBhZGRlZCwgZm9vdGVyVmlzaWJsZSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgIHRoaXMucGFkZGVkID0gcGFkZGVkO1xuICAgIHRoaXMudG9nZ2xlRm9vdGVyVmlzaWJpbGl0eShmb290ZXJWaXNpYmxlKTtcbiAgfVxuICAvLyBUT0RPOiBjb21iaW5lIHVwZGF0ZSwgcHJldmlvdXM/XG4gIGFzeW5jIGdvVG9OZXh0UGFnZShldmVudCkge1xuICAgIHRoaXMucGFnZUhpc3RvcnkgPSBbLi4udGhpcy5wYWdlSGlzdG9yeSwgZXZlbnQuZGV0YWlsXTtcbiAgICBhd2FpdCB0aGlzLnRyYW5zaXRpb25QYWdlKFwiZm9yd2FyZFwiKTtcbiAgfVxuICBhc3luYyBnb1RvUHJldmlvdXNQYWdlKCkge1xuICAgIGF3YWl0IHRoaXMudHJhbnNpdGlvblBhZ2UoXCJiYWNrXCIpO1xuICB9XG4gIHJlcG9ydEVycm9yKHsgZGV0YWlsOiBlcnJvck1lc3NhZ2UgfSkge1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gIH1cbiAgdHJpZ2dlclBhZ2VUcmFuc2l0aW9uKGV2ZW50VHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudFR5cGUsIHsgY2FuY2VsYWJsZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBldmVudE5vdENhbmNlbGxlZCA9IChfYSA9IHRoaXMuY3VycmVudFBhZ2VFbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIGlmIChldmVudE5vdENhbmNlbGxlZCAmJiBldmVudFR5cGUgPT09IFwiYXJjZ2lzV29ya2Zsb3dQYWdlUHJldmlvdXNcIikge1xuICAgICAgdGhpcy5nb1RvUHJldmlvdXNQYWdlKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHRyYW5zaXRpb25QYWdlKGRpcmVjdGlvbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gdGhpcy5wcmltYXJ5QnV0dG9uVGV4dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMucHJpbWFyeUJ1dHRvblRleHQgPSB0aGlzLmkxOG4ubmV4dCk7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gZGlyZWN0aW9uO1xuICAgIGF3YWl0IHRpbWVvdXQoQU5JTUFUSU9OX0RVUkFUSU9OKTtcbiAgICB0aGlzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiYmFja1wiKSB7XG4gICAgICB0aGlzLnBhZ2VIaXN0b3J5ID0gdGhpcy5wYWdlSGlzdG9yeS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwiYXJjZ2lzVHJhbnNpdGlvbkNvbXBsZXRlXCIpO1xuICAgIChfYiA9IHRoaXMuY3VycmVudFBhZ2VFbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc3BhdGNoRXZlbnQodHJhbnNpdGlvbkNvbXBsZXRlRXZlbnQpO1xuICAgIGF3YWl0IHRpbWVvdXQoQU5JTUFUSU9OX0RVUkFUSU9OKTtcbiAgICB0aGlzLmZvY3VzRmlyc3RFbGVtZW50KCk7XG4gIH1cbiAgdXBkYXRlQWN0aXZlKGFjdGl2ZSkge1xuICAgIGlmIChhY3RpdmUgJiYgdGhpcy5maXJzdFBhZ2UpIHtcbiAgICAgIHRoaXMucGFnZUhpc3RvcnkgPSBbdGhpcy5maXJzdFBhZ2VdO1xuICAgIH1cbiAgfVxuICB1cGRhdGVGaXJzdFBhZ2UocGFnZSkge1xuICAgIHRoaXMucGFnZUhpc3RvcnkgPSBbcGFnZV07XG4gIH1cbiAgZm9jdXNGaXJzdEVsZW1lbnQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBjdXJQYWdlID0gdGhpcy5jdXJyZW50UGFnZUVsO1xuICAgIGlmIChjdXJQYWdlICYmICFjdXJQYWdlLm1hbmFnZWRGb2N1cykge1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5tb2RhbFJlZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICB9XG4gIC8qKiBVcGRhdGUgdGhlIGNvbXBvbmVudCBpbiB0aGUgbW9kYWwncyBzbG90IHdoZW4gYSBzdGF0ZSBjaGFuZ2UgaXMgZGV0ZWN0ZWQgKi9cbiAgZGlzcGxheVBhZ2UoKSB7XG4gICAgY29uc3QgeyB0cmFuc2l0aW9uLCBwYWdlSGlzdG9yeSwgcGFkZGVkIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZvcndhcmQgPSB0cmFuc2l0aW9uID09PSBcImZvcndhcmRcIjtcbiAgICBjb25zdCBiYWNrID0gdHJhbnNpdGlvbiA9PT0gXCJiYWNrXCI7XG4gICAgY29uc3QgbmV4dCA9IGJhY2sgPyBwYWdlSGlzdG9yeVtwYWdlSGlzdG9yeS5sZW5ndGggLSAyXSA6IHBhZ2VIaXN0b3J5W3BhZ2VIaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgIC8vIERvbid0IHJlbmRlciBhIHBhZ2UgaWYgbW9kYWwgaXNuJ3QgYWN0aXZlIG9yIHBhZ2VIaXN0b3J5IGlzIGVtcHR5XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8ICFuZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRPRE86IHN0cmljdGx5IHR5cGUgdGhpc1xuICAgIGNvbnN0IE5leHRTY3JlZW4gPSBgJHtuZXh0LmVsZW1lbnR9YDtcbiAgICBjb25zdCBDdXJyZW50U2NyZWVuID0gdGhpcy5jdXJyZW50U2NyZWVuO1xuICAgIGlmIChDdXJyZW50U2NyZWVuICYmIHBhZ2VIaXN0b3J5Lmxlbmd0aCA+IDEgJiYgdHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgaChDdXJyZW50U2NyZWVuLCB7IGNsYXNzOiB7XG4gICAgICAgICAgICBzdGFnZTogdHJ1ZSxcbiAgICAgICAgICAgIFwic3RhZ2UtYW5pbVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzdGFnZS1hbmltLS1sZWZ0XCI6IGZvcndhcmQsXG4gICAgICAgICAgICBcInN0YWdlLWFuaW0tLXJpZ2h0XCI6IGJhY2ssXG4gICAgICAgICAgICBwYWRkZWRcbiAgICAgICAgICB9IH0pLFxuICAgICAgICBoKE5leHRTY3JlZW4sIHsgY2xhc3M6IHtcbiAgICAgICAgICAgIHN0YWdlOiB0cnVlLFxuICAgICAgICAgICAgXCJzdGFnZS1hbmltXCI6IHRydWUsXG4gICAgICAgICAgICBcInN0YWdlLWFuaW0tLWxlZnRcIjogYmFjayxcbiAgICAgICAgICAgIFwic3RhZ2UtYW5pbS0tcmlnaHRcIjogZm9yd2FyZCxcbiAgICAgICAgICAgIHBhZGRlZFxuICAgICAgICAgIH0sIHJlZjogKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlRWwgPSBlbDtcbiAgICAgICAgICB9IH0pXG4gICAgICBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFNjcmVlbiA9IE5leHRTY3JlZW47XG4gICAgfVxuICAgIHJldHVybiAoaChOZXh0U2NyZWVuLCBPYmplY3QuYXNzaWduKHt9LCBuZXh0LnByb3BzLCB7IGNsYXNzOiB7XG4gICAgICAgIHN0YWdlOiB0cnVlLFxuICAgICAgICBwYWRkZWRcbiAgICAgIH0sIHJlZjogKGVsKSA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2VFbCA9IGVsO1xuICAgICAgfSB9KSkpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuY2xvc2VEaWFsb2coKTtcbiAgfVxuICAvKiogSW5pdGlhbGl6ZSB0aGUgY29uZmlnIHN0b3JlIHdpdGggZGF0YSBmcm9tIHByb3BzIG9uIGxvYWQgKi9cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZmlyc3RQYWdlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxvY2FsZSA9IGF3YWl0IGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3ModGhpcy5lbCk7XG4gICAgd29ya2Zsb3dTdGF0ZS5pMThuID0gbG9jYWxlWzBdO1xuICAgIHdvcmtmbG93U3RhdGUubGFuZyA9IGxvY2FsZVsxXTtcbiAgICB0aGlzLmkxOG4gPSBsb2NhbGVbMF07XG4gICAgKF9hID0gdGhpcy5wcmltYXJ5QnV0dG9uVGV4dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMucHJpbWFyeUJ1dHRvblRleHQgPSB0aGlzLmkxOG4ubmV4dCk7XG4gICAgdGhpcy5sb2FkaW5nVGV4dCA9IHRoaXMuaTE4bi5sb2FkaW5nO1xuICAgIGlmIChmaXJzdFBhZ2UpIHtcbiAgICAgIHRoaXMucGFnZUhpc3RvcnkgPSBbdGhpcy5maXJzdFBhZ2VdO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsUmVuZGVyKCkge1xuICAgIHRoaXMuc2hvd0JhY2tCdXR0b24gPSB0aGlzLnBhZ2VIaXN0b3J5Lmxlbmd0aCA+IDE7XG4gIH1cbiAgY29tcG9uZW50RGlkUmVuZGVyKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaGFkb3dSb290ID0gKF9hID0gdGhpcy5tb2RhbFJlZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNoYWRvd1Jvb3Q7XG4gICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgIC8vIEhlbHAgdGhlIHRvb2x0aXAgdG8gYmUgb24gdG9wIG9mIHRoZSBmb290ZXJcbiAgICAgIGNvbnN0IG1vZGFsSGVhZGVyID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLmhlYWRlclwiKTtcbiAgICAgIGlmIChtb2RhbEhlYWRlcikge1xuICAgICAgICBtb2RhbEhlYWRlci5zdHlsZS56SW5kZXggPSBcIjNcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAoX2IgPSAoX2EgPSB0aGlzLm1vZGFsUmVmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICBjb25zdCBjb250ZW50Q29udGFpbmVyID0gKF9jID0gdGhpcy5tb2RhbFJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5jb250ZW50XCIpO1xuICAgIGlmIChjb250ZW50Q29udGFpbmVyKSB7XG4gICAgICBjb250ZW50Q29udGFpbmVyLnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGkxOG4sIGlzTG9hZGluZywgbG9hZGluZ1RleHQsIGlzQWN0aXZlLCBlcnJvciB9ID0gdGhpcztcbiAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtbW9kYWxcIiwgeyByZWY6IChlbGUpID0+ICh0aGlzLm1vZGFsUmVmID0gZWxlKSwgb3BlbjogaXNBY3RpdmUsIG9uQ2FsY2l0ZU1vZGFsQ2xvc2U6IHRoaXMuY2xvc2VEaWFsb2csIG91dHNpZGVDbG9zZURpc2FibGVkOiB0cnVlLCBlc2NhcGVEaXNhYmxlZDogdHJ1ZSB9LCBoKFwiZGl2XCIsIHsgc2xvdDogXCJoZWFkZXJcIiwgY2xhc3M6IFwiaGVhZGVyXCIgfSwgaChcImgzXCIsIHsgaWQ6IFwibW9kYWwtdGl0bGVcIiwgY2xhc3M6IFwiaGVhZGVyX190aXRsZVwiIH0sIHRoaXMuaGVhZGVyVGV4dCkpLCBoKFwiZGl2XCIsIHsgc2xvdDogXCJjb250ZW50XCIsIGNsYXNzOiBcImNvbnRlbnRcIiB9LCBpc0xvYWRpbmcgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBcInN0YWdlXCIgfSwgaChcImFyY2dpcy13b3JrZmxvdy1sb2FkZXJcIiwgeyBhY3RpdmU6IGlzTG9hZGluZywgdGV4dDogbG9hZGluZ1RleHQgfSkpKSA6ICh0aGlzLmRpc3BsYXlQYWdlKCkpKSwgaChcImRpdlwiLCB7IHNsb3Q6IFwiYmFja1wiIH0sIHRoaXMuc2hvd0JhY2tCdXR0b24gJiYgKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBcImRhdGEtaWRcIjogXCJiYWNrQnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyUGFnZVRyYW5zaXRpb24oXCJhcmNnaXNXb3JrZmxvd1BhZ2VQcmV2aW91c1wiKTtcbiAgICAgIH0sIHdpZHRoOiBcImZ1bGxcIiwgZGlzYWJsZWQ6ICF0aGlzLm5hdkVuYWJsZWQgfSwgaTE4bi5iYWNrKSkpLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBzbG90OiBcInNlY29uZGFyeVwiLCBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCBcImRhdGEtaWRcIjogXCJjYW5jZWxCdXR0b25cIiwgb25DbGljazogKCkgPT4ge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICB9LCB3aWR0aDogXCJmdWxsXCIgfSwgaTE4bi5jYW5jZWwpLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBpZDogXCJwcmltYXJ5LWJ1dHRvblwiLCBzbG90OiBcInByaW1hcnlcIiwgYXBwZWFyYW5jZTogXCJzb2xpZFwiLCBcImRhdGEtaWRcIjogXCJuZXh0QnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyUGFnZVRyYW5zaXRpb24oXCJhcmNnaXNXb3JrZmxvd1BhZ2VOZXh0XCIpO1xuICAgICAgfSwgd2lkdGg6IFwiZnVsbFwiLCBkaXNhYmxlZDogIXRoaXMubmF2RW5hYmxlZCB9LCB0aGlzLnByaW1hcnlCdXR0b25UZXh0KSksIGgoXCJhcmNnaXMtbmV3LWl0ZW0tYWxlcnRcIiwgeyBoZWFkaW5nOiBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IudGl0bGUsIGRlc2NyaXB0aW9uOiBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuZGVzY3JpcHRpb24sIGFjdGl2ZTogISFlcnJvciwgbGluazogZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmxpbmssIG9uQWxlcnREaXNtaXNzOiAoKSA9PiAodGhpcy5lcnJvciA9IG51bGwpIH0pKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwiaXNBY3RpdmVcIjogW1widXBkYXRlQWN0aXZlXCJdLFxuICAgIFwiZmlyc3RQYWdlXCI6IFtcInVwZGF0ZUZpcnN0UGFnZVwiXVxuICB9OyB9XG59O1xuQXJjZ2lzV29ya2Zsb3cuc3R5bGUgPSBhcmNnaXNXb3JrZmxvd0NzcztcblxuZXhwb3J0IHsgQXJjZ2lzV29ya2Zsb3cgYXMgYXJjZ2lzX3dvcmtmbG93IH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICByZXR1cm4gc3RhdHVzO1xuICB9XG4gIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICB9LCBkZWxheSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgY29uc3QgbG9va3VwTWFwID0ge307XG4gIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgY29uc3Qgb2JqcyA9IFtdO1xuICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBnIGFzIGdldFJlbmRlcmluZ1JlZiwgZiBhcyBmb3JjZVVwZGF0ZSB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuXG5jb25zdCBhcHBlbmRUb01hcCA9IChtYXAsIHByb3BOYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gbWFwLmdldChwcm9wTmFtZSk7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgICBtYXAuc2V0KHByb3BOYW1lLCBbdmFsdWVdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWl0ZW1zLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIG1zKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSAwO1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvc3NpYmxlIGVsZW1lbnQgaXNDb25uZWN0ZWQuXG4gKiBUaGUgcHJvcGVydHkgbWlnaHQgbm90IGJlIHRoZXJlLCBzbyB3ZSBjaGVjayBmb3IgaXQuXG4gKlxuICogV2Ugd2FudCBpdCB0byByZXR1cm4gdHJ1ZSBpZiBpc0Nvbm5lY3RlZCBpcyBub3QgYSBwcm9wZXJ0eSxcbiAqIG90aGVyd2lzZSB3ZSB3b3VsZCByZW1vdmUgdGhlc2UgZWxlbWVudHMgYW5kIHdvdWxkIG5vdCB1cGRhdGUuXG4gKlxuICogQmV0dGVyIGxlYWsgaW4gRWRnZSB0aGFuIHRvIGJlIHVzZWxlc3MuXG4gKi9cbmNvbnN0IGlzQ29ubmVjdGVkID0gKG1heWJlRWxlbWVudCkgPT4gISgnaXNDb25uZWN0ZWQnIGluIG1heWJlRWxlbWVudCkgfHwgbWF5YmVFbGVtZW50LmlzQ29ubmVjdGVkO1xuY29uc3QgY2xlYW51cEVsZW1lbnRzID0gZGVib3VuY2UoKG1hcCkgPT4ge1xuICAgIGZvciAobGV0IGtleSBvZiBtYXAua2V5cygpKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBtYXAuZ2V0KGtleSkuZmlsdGVyKGlzQ29ubmVjdGVkKSk7XG4gICAgfVxufSwgMjAwMCk7XG5jb25zdCBzdGVuY2lsU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2V0UmVuZGVyaW5nUmVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBub3QgaW4gYSBzdGVuY2lsIHByb2plY3QsIHdlIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlYWxseSBleHBvcnRlZCBieSBAc3RlbmNpbC9jb3JlLlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGVsbXNUb1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwb3NlOiAoKSA9PiBlbG1zVG9VcGRhdGUuY2xlYXIoKSxcbiAgICAgICAgZ2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IGdldFJlbmRlcmluZ1JlZigpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZFRvTWFwKGVsbXNUb1VwZGF0ZSwgcHJvcE5hbWUsIGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKHByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGVsbXNUb1VwZGF0ZS5nZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZWxtc1RvVXBkYXRlLnNldChwcm9wTmFtZSwgZWxlbWVudHMuZmlsdGVyKGZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwRWxlbWVudHMoZWxtc1RvVXBkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGVsbXNUb1VwZGF0ZS5mb3JFYWNoKChlbG1zKSA9PiBlbG1zLmZvckVhY2goZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCB1bndyYXAgPSAodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHZhbCgpIDogdmFsKTtcbmNvbnN0IGNyZWF0ZU9ic2VydmFibGVNYXAgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUgPSAoYSwgYikgPT4gYSAhPT0gYikgPT4ge1xuICAgIGNvbnN0IHVud3JhcHBlZFN0YXRlID0gdW53cmFwKGRlZmF1bHRTdGF0ZSk7XG4gICAgbGV0IHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXModW53cmFwcGVkU3RhdGUgIT09IG51bGwgJiYgdW53cmFwcGVkU3RhdGUgIT09IHZvaWQgMCA/IHVud3JhcHBlZFN0YXRlIDoge30pKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgZGlzcG9zZTogW10sXG4gICAgICAgIGdldDogW10sXG4gICAgICAgIHNldDogW10sXG4gICAgICAgIHJlc2V0OiBbXSxcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFdoZW4gcmVzZXR0aW5nIHRoZSBzdGF0ZSwgdGhlIGRlZmF1bHQgc3RhdGUgbWF5IGJlIGEgZnVuY3Rpb24gLSB1bndyYXAgaXQgdG8gaW52b2tlIGl0LlxuICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBzdGF0ZSB3b24ndCBiZSBwcm9wZXJseSByZXNldFxuICAgICAgICBzdGF0ZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKChfYSA9IHVud3JhcChkZWZhdWx0U3RhdGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSkpO1xuICAgICAgICBoYW5kbGVycy5yZXNldC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgfTtcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAvLyBDYWxsIGZpcnN0IGRpc3Bvc2UgYXMgcmVzZXR0aW5nIHRoZSBzdGF0ZSB3b3VsZFxuICAgICAgICAvLyBjYXVzZSBsZXNzIHVwZGF0ZXMgOylcbiAgICAgICAgaGFuZGxlcnMuZGlzcG9zZS5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQgPSAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgaGFuZGxlcnMuZ2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSkpO1xuICAgICAgICByZXR1cm4gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXQgPSAocHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUodmFsdWUsIG9sZFZhbHVlLCBwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIHN0YXRlcy5zZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2IocHJvcE5hbWUsIHZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9ICh0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8ge31cbiAgICAgICAgOiBuZXcgUHJveHkodW53cmFwcGVkU3RhdGUsIHtcbiAgICAgICAgICAgIGdldChfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXMoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXRlcy5rZXlzKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXMoXywgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzLmhhcyhwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KF8sIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIGNvbnN0IG9uID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheShoYW5kbGVyc1tldmVudE5hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IChwcm9wTmFtZSwgY2IpID0+IHtcbiAgICAgICAgY29uc3QgdW5TZXQgPSBvbignc2V0JywgKGtleSwgbmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2IobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1bndyYXAgdGhlIGRlZmF1bHRTdGF0ZSBiZWNhdXNlIGl0IG1pZ2h0IGJlIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBtaWdodCBub3QgYmUgc2VuZGluZyB0aGUgcmlnaHQgcmVzZXQgdmFsdWUuXG4gICAgICAgIGNvbnN0IHVuUmVzZXQgPSBvbigncmVzZXQnLCAoKSA9PiBjYih1bndyYXAoZGVmYXVsdFN0YXRlKVtwcm9wTmFtZV0pKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVuU2V0KCk7XG4gICAgICAgICAgICB1blJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB1c2UgPSAoLi4uc3Vic2NyaXB0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnMgPSBzdWJzY3JpcHRpb25zLnJlZHVjZSgodW5zdWJzLCBzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uc2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ3NldCcsIHN1YnNjcmlwdGlvbi5zZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZ2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2dldCcsIHN1YnNjcmlwdGlvbi5nZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ucmVzZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbigncmVzZXQnLCBzdWJzY3JpcHRpb24ucmVzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdkaXNwb3NlJywgc3Vic2NyaXB0aW9uLmRpc3Bvc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bnN1YnM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHVuc3Vicy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2Ioa2V5LCBvbGRWYWx1ZSwgb2xkVmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHNldCxcbiAgICAgICAgb24sXG4gICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICB1c2UsXG4gICAgICAgIGRpc3Bvc2UsXG4gICAgICAgIHJlc2V0LFxuICAgICAgICBmb3JjZVVwZGF0ZSxcbiAgICB9O1xufTtcbmNvbnN0IHJlbW92ZUZyb21BcnJheSA9IChhcnJheSwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgYXJyYXkubGVuZ3RoLS07XG4gICAgfVxufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpID0+IHtcbiAgICBjb25zdCBtYXAgPSBjcmVhdGVPYnNlcnZhYmxlTWFwKGRlZmF1bHRTdGF0ZSwgc2hvdWxkVXBkYXRlKTtcbiAgICBtYXAudXNlKHN0ZW5jaWxTdWJzY3JpcHRpb24oKSk7XG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlIGFzIGMgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYWFmMzBiZDYuanMnO1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5cbmNvbnN0IGxhbmd1YWdlTWFwID0gbmV3IE1hcChbXG4gIFtcImFyXCIsIFwiYXJcIl0sXG4gIFtcImJnXCIsIFwiYmdcIl0sXG4gIFtcImJzXCIsIFwiYnNcIl0sXG4gIFtcImNhXCIsIFwiY2FcIl0sXG4gIFtcImNzXCIsIFwiY3NcIl0sXG4gIFtcImRhXCIsIFwiZGFcIl0sXG4gIFtcImRlXCIsIFwiZGVcIl0sXG4gIFtcImVsXCIsIFwiZWxcIl0sXG4gIFtcImVuXCIsIFwiZW5cIl0sXG4gIFtcImVzXCIsIFwiZXNcIl0sXG4gIFtcImV0XCIsIFwiZXRcIl0sXG4gIFtcImZpXCIsIFwiZmlcIl0sXG4gIFtcImZyXCIsIFwiZnJcIl0sXG4gIFtcImhlXCIsIFwiaGVcIl0sXG4gIFtcImhyXCIsIFwiaHJcIl0sXG4gIFtcImh1XCIsIFwiaHVcIl0sXG4gIFtcImlkXCIsIFwiaWRcIl0sXG4gIFtcIml0XCIsIFwiaXRcIl0sXG4gIFtcImphXCIsIFwiamFcIl0sXG4gIFtcImtvXCIsIFwia29cIl0sXG4gIFtcImx0XCIsIFwibHRcIl0sXG4gIFtcImx2XCIsIFwibHZcIl0sXG4gIFtcIm5iXCIsIFwibmJcIl0sXG4gIFtcIm5sXCIsIFwibmxcIl0sXG4gIFtcInBsXCIsIFwicGxcIl0sXG4gIFtcInB0LWJyXCIsIFwicHQtQlJcIl0sXG4gIFtcInB0LXB0XCIsIFwicHQtUFRcIl0sXG4gIFtcInJvXCIsIFwicm9cIl0sXG4gIFtcInJ1XCIsIFwicnVcIl0sXG4gIFtcInNrXCIsIFwic2tcIl0sXG4gIFtcInNsXCIsIFwic2xcIl0sXG4gIFtcInNyXCIsIFwic3JcIl0sXG4gIFtcInN2XCIsIFwic3ZcIl0sXG4gIFtcInRoXCIsIFwidGhcIl0sXG4gIFtcInRyXCIsIFwidHJcIl0sXG4gIFtcInVrXCIsIFwidWtcIl0sXG4gIFtcInZpXCIsIFwidmlcIl0sXG4gIFtcInpoLWNuXCIsIFwiemgtQ05cIl0sXG4gIFtcInpoLWhrXCIsIFwiemgtSEtcIl0sXG4gIFtcInpoLXR3XCIsIFwiemgtVFdcIl1cbl0pO1xuLy8gcnRsXG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gIHJldHVybiBnZXRFbGVtZW50UHJvcChlbCwgXCJkaXJcIiwgXCJsdHJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgY2xvc2VzdFdpdGhQcm9wID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBgWyR7cHJvcH1dYCk7XG4gIHJldHVybiBjbG9zZXN0V2l0aFByb3AgPyBjbG9zZXN0V2l0aFByb3AuZ2V0QXR0cmlidXRlKHByb3ApIDogdmFsdWU7XG59XG4vLyBjc3NcbmNvbnN0IENTU19VVElMSVRZID0ge1xuICBydGw6IFwiYXJjZ2lzLS1ydGxcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhcGksIHR5cGUsIHBsYWNlcyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKGFwaSA9PT0gNCkge1xuICAgIGNvbnN0IFtpbnRsXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaW50bFwiXSk7XG4gICAgY29uc3QgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMgPSBpbnRsLmNvbnZlcnROdW1iZXJGb3JtYXRUb0ludGxPcHRpb25zKHtcbiAgICAgIHBsYWNlcyxcbiAgICAgIHN0eWxlOiB0eXBlLFxuICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gaW50bC5mb3JtYXROdW1iZXIobnVtYmVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlckZvcm1hdEludGxPcHRpb25zKSwgeyBzdHlsZTogdHlwZSB9KSk7XG4gIH1cbiAgY29uc3QgW2Rvam9OdW1iZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZG9qby9udW1iZXJcIl0pO1xuICByZXR1cm4gZG9qb051bWJlci5mb3JtYXQobnVtYmVyLCB7XG4gICAgdHlwZSxcbiAgICBwbGFjZXMsXG4gICAgcGF0dGVybjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhdHRlcm5cbiAgfSk7XG59XG5jb25zdCBjYWNoZSA9IHt9O1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIGNvbnN0IGxhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZztcbiAgY29uc3QgZGF5U2hvcnRNb250aFllYXIgPSB7XG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwic2hvcnRcIixcbiAgICBkYXk6IFwibnVtZXJpY1wiXG4gIH07XG4gIGlmICghY2FjaGVbbGFuZ10pIHtcbiAgICBjYWNoZVtsYW5nXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nLCBkYXlTaG9ydE1vbnRoWWVhcik7XG4gIH1cbiAgcmV0dXJuIGNhY2hlW2xhbmddLmZvcm1hdChkYXRlKTtcbn1cblxuZXhwb3J0IHsgQ1NTX1VUSUxJVFkgYXMgQywgZm9ybWF0RGF0ZSBhcyBhLCBmb3JtYXROdW1iZXIgYXMgZiwgZ2V0RWxlbWVudERpciBhcyBnLCBsYW5ndWFnZU1hcCBhcyBsIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tMTNmNWIwMGMuanMnO1xuaW1wb3J0IHsgbCBhcyBsYW5ndWFnZU1hcCB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLTIyMjU4YzkwLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9zdGVuY2lsLXRyaWNrcy9pbXBsZW1lbnRpbmctaW50ZXJuYXRpb25hbGlzYXRpb24taTE4bi13aXRoLXN0ZW5jaWwtNWU2NTU5NTU0MTE3XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcuc2xpY2UoMCwgMikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBcImVuXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIC8vIGl0J3MgT0sgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgNCBsZXR0ZXIgbGFuZ3VhZ2UgZmlsZSBmb3IgaXRcbiAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgIC8vIHdlIHN1cHBvcnQgdGhlIDIgbGV0dGVyIGNvZGVkIGxhbmd1YWdlXG4gICAgICAvLyBlLmcuIGl0LUNIIHZzIGl0XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoKGdldEFzc2V0UGF0aChgLi4vYXJjZ2lzLWFwcC1hc3NldHMvaTE4bi8ke2NvbXBvbmVudE5hbWV9LmkxOG4uJHtsb2NhbGV9Lmpzb25gKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0Lm9rKVxuICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgZWxzZVxuICAgICAgICByZWplY3QoKTtcbiAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gIH0pO1xufVxuY29uc3Qgc3RyaW5nQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgY29uc3QgaWQgPSBgJHtjb21wb25lbnROYW1lfSR7bG9jYWxlfWA7XG4gIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgc3RyaW5nQ2FjaGVbaWRdID0gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ0NhY2hlW2lkXTtcbn1cbi8qKlxuICogR2V0IHN0cmluZ3MgYW5kIGxhbmd1YWdlIGNvZGVzLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyAyIGxhbmd1YWdlIGNvZGVzLlxuICogVGhlIGZpcnN0IG9uZSByZXR1cm5zIGEgY29kZSB0aGF0J3MgYWxzbyBzdXBwb3J0ZWQgYXMgYSBsYW5ndWFnZSBmaWxlLlxuICogVGhlIHNlY29uZCBvbmUgcmV0dXJucyBhIGNvZGUgd2hlcmUgdGhlcmUgaXMgc3VwcG9ydCBmb3IgdGhlIGZpcnN0IDIgbGV0dGVycyBvZiB0aGUgY29kZSBhcyBwYXJ0IG9mIGEgbGFuZ3VhZ2UgZmlsZSxcbiAqIGJ1dCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgNCBsZXR0ZXIgY29kZSBmcm9tIHRoZSBwYWdlLlxuICogRS5nLiBGb3IgXCJpdC1jaFwiIGl0IHdpbGwgcmV0dXJuIFwiaXRcIiBhcyB0aGUgZmlyc3QgbGFuZ3VhZ2UgY29kZSBhbmQgXCJpdC1jaFwiIGFzIHRoZSBzZWNvbmQuXG4gKiBUaGUgc2Vjb25kIG9uZSBpcyByZXF1aXJlZCBmb3IgZXNyaS5pbnRsLnNldExvY2FsZSgpIHRvIGdldCB0aGUgY29ycmVjdCBmb3JtYXR0aW5nLlxuICpcbiAqIElmIGEgdGFnTmFtZSBpcyBwcm92aWRlZCBpdCB3aWxsIG92ZXJ3aXRlIHRoZSBlbGVtZW50J3MgdGFnTmFtZVxuICpcbiAqICBAcmV0dXJuIFsgc3RyaW5ncywgZmlyc3QgbGFuZ3VhZ2UgY29kZSwgc2Vjb25kIGxhbmd1YWdlIGNvZGVdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MoZWxlbWVudCwgdGFnTmFtZSkge1xuICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlSW50bCA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCk7XG4gIGxldCBzdHJpbmdzO1xuICB0cnkge1xuICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50TGFuZ3VhZ2UpO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgXCJlblwiKTtcbiAgfVxuICByZXR1cm4gW3N0cmluZ3MsIGNvbXBvbmVudExhbmd1YWdlLCBjb21wb25lbnRMYW5ndWFnZUludGxdO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgYXMgYSwgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyBhcyBnIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlU3RvcmUgfSBmcm9tICcuL2luZGV4LTgxZDU0OGI3LmpzJztcblxuY29uc3Qgd29ya2Zsb3dTdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgcG9ydGFsOiBudWxsLFxuICB1c2VyOiBudWxsLFxuICBpMThuOiBudWxsLFxuICBzY2FsZTogXCJtXCIsXG4gIGFwaTogNCxcbiAgbmV4dFRleHQ6IG51bGwsXG4gIHVwbG9hZFByb2dyZXNzOiAwXG59KTtcbmNvbnN0IHdvcmtmbG93U3RhdGUgPSB3b3JrZmxvd1N0b3JlLnN0YXRlO1xuXG5leHBvcnQgeyB3b3JrZmxvd1N0YXRlIGFzIHcgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==