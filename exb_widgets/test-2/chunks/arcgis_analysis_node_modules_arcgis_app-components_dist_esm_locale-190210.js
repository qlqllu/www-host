"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_locale-190210"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-d9d70416.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-d9d70416.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getHydratedItem),
/* harmony export */   b: () => (/* binding */ getItemDataUrl),
/* harmony export */   c: () => (/* binding */ getItemGroups),
/* harmony export */   d: () => (/* binding */ getItem),
/* harmony export */   e: () => (/* binding */ isEditableItem),
/* harmony export */   g: () => (/* binding */ getItemData),
/* harmony export */   i: () => (/* binding */ isHostedService),
/* harmony export */   r: () => (/* binding */ requestFetch)
/* harmony export */ });
/* harmony import */ var _portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./portal-79caaeff.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js");
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/* harmony import */ var _privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./privileges-ccd5f37d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




/** Work-around since using `request` directly will trigger unwanted toast on the Home App if the layer is unavailable */
const requestFetch = async (url, portal, options = {}) => {
  const { body, usePost, addTokenManually, api = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === null || _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === void 0 ? void 0 : _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c.api } = options;
  const data = new URLSearchParams();
  if (body) {
    Object.entries(body).forEach(([key, value]) => {
      if (value !== undefined) {
        data.append(key, value);
      }
    });
  }
  const urlToSend = new URL(url);
  urlToSend.searchParams.append("f", "json");
  const token = addTokenManually === false ? null : await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.d)(portal, api);
  if (token) {
    urlToSend.searchParams.append("token", token);
  }
  const response = await fetch(urlToSend.toString(), {
    body: usePost ? data : undefined,
    method: usePost ? "POST" : "GET"
  });
  const result = await response.json();
  const error = result.error;
  if (error) {
    throw typeof error === "string" ? new Error(error) : error;
  }
  return result;
};

const isHostedService = (typeKeywords, type) => type === "Feature Service" && typeKeywords.includes("Hosted Service");

const getHydratedItem = async (itemId, portal) => {
  try {
    const item = await requestFetch(getItemUrl(itemId, portal), portal);
    // TODO: check if we still need to do this
    // if (isHostedService(item.typeKeywords, item.type)) {
    //   const itemData = getItemData(item.id, portal);
    //   return { result: { ...item, ...itemInfo, ...itemData } };
    // }
    return { result: item };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
const getItemDataUrl = (itemId, portal) => `${getItemUrl(itemId, portal)}/data`;
const getItemData = async (itemId, portal) => {
  return requestFetch(getItemDataUrl(itemId, portal), portal);
};
// TODO: remove these once we figure out how to efficiently disable the toast on the Home App
const getItemUrl = (itemId, portal) => `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)(portal)}content/items/${itemId}`;
const getItem = async (itemId, portal, requestOptions) => {
  try {
    const url = getItemUrl(itemId, portal);
    return await requestFetch(url, portal, requestOptions);
  }
  catch (error) {
    console.warn(error);
  }
};
const getItemGroups = async (itemId, portal) => {
  try {
    const url = `${getItemUrl(itemId, portal)}/groups`;
    return { result: await requestFetch(url, portal) };
  }
  catch (error) {
    // TODO: handle error
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
const isEditableItem = async (item, portal) => {
  let isEditable = false;
  if (isHostedService(item.typeKeywords, item.type)) {
    isEditable = await hasEditingCapability(item.url, portal);
  }
  return isEditable;
};
const hasEditingCapability = async (layerUrl, portal, requiredNoToken = false) => {
  var _a, _b, _c;
  if (layerUrl) {
    try {
      const result = await requestFetch(`${(_a = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.p)(layerUrl)) === null || _a === void 0 ? void 0 : _a.baseServerUrl}/layers`, portal, { addTokenManually: !requiredNoToken });
      return (_b = result === null || result === void 0 ? void 0 : result.layers) === null || _b === void 0 ? void 0 : _b.reduce((memo, layer) => memo || (layer === null || layer === void 0 ? void 0 : layer.capabilities.includes("Editing")), false);
    }
    catch (error) {
      if ((_c = error === null || error === void 0 ? void 0 : error.message) === null || _c === void 0 ? void 0 : _c.toLowerCase().includes("token required")) {
        return hasEditingCapability(layerUrl, portal, true);
      }
    }
  }
  return false;
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



const languageMap = new Map([
  ["ar", "ar"],
  ["bg", "bg"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["cs", "cs"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["es", "es"],
  ["et", "et"],
  ["fi", "fi"],
  ["fr", "fr"],
  ["he", "he"],
  ["hr", "hr"],
  ["hu", "hu"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "ja"],
  ["ko", "ko"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["nb", "nb"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["pt-br", "pt-BR"],
  ["pt-pt", "pt-PT"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sr", "sr"],
  ["sv", "sv"],
  ["th", "th"],
  ["tr", "tr"],
  ["uk", "uk"],
  ["vi", "vi"],
  ["zh-cn", "zh-CN"],
  ["zh-hk", "zh-HK"],
  ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
  return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
  const closestWithProp = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
  return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
  rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
  const { api, type, places } = options || {};
  if (api === 4) {
    const [intl] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
    const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
      places,
      style: type,
      digitSeparator: true
    });
    return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
  }
  const [dojoNumber] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
  return dojoNumber.format(number, {
    type,
    places,
    pattern: options === null || options === void 0 ? void 0 : options.pattern
  });
}
const cache = {};
function formatDate(date) {
  const lang = document.documentElement.lang;
  const dayShortMonthYear = {
    year: "numeric",
    month: "short",
    day: "numeric"
  };
  if (!cache[lang]) {
    cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
  }
  return cache[lang].format(date);
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/services-adddeef9.js":
/*!**************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/services-adddeef9.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ analyzeSharingDetail),
/* harmony export */   b: () => (/* binding */ shareItems),
/* harmony export */   c: () => (/* binding */ isBlockedFromSharingToPublic),
/* harmony export */   d: () => (/* binding */ isBlockedFromDeveloperSharingToPublic),
/* harmony export */   e: () => (/* binding */ dependencyCheckCacheTypes),
/* harmony export */   i: () => (/* binding */ isAccessLevelGreater),
/* harmony export */   s: () => (/* binding */ shareItemsToSharedGroups),
/* harmony export */   u: () => (/* binding */ unshareItems)
/* harmony export */ });
/* harmony import */ var _server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server-item-f12153e6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/server-item-f12153e6.js");
/* harmony import */ var _portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./portal-79caaeff.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js");
/* harmony import */ var _privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./privileges-ccd5f37d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js");
/* harmony import */ var _item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./item-d9d70416.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-d9d70416.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */






/**
 * Share items to the specified groups with the specified access level
 *
 * Note: `request` will toast an error on the Home app `useFetchRequest` is a workaround. TODO: remove this once we have a better way
 *
 * */
const shareItems = async (items, shareLevel, groupIds, config, useFetchRequest = false) => {
  const { portal, user } = config;
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.g)(portal)}content/users/${user.username}/shareItems`;
  let result = [];
  const shareLevelOptions = shareLevel ? toShareLevelOptions(shareLevel) : {};
  if (items.every((item) => (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.i)(item, user))) {
    try {
      result = (await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, {
        body: Object.assign({ items: items.map((item) => item.id).join(","), groups: (groupIds === null || groupIds === void 0 ? void 0 : groupIds.length) ? groupIds.join(",") : undefined, confirmItemControl: true }, shareLevelOptions),
        usePost: true
      })).results;
    }
    catch (error) {
      console.error(error);
      return { error: { code: "unhandledError" } };
    }
  }
  else {
    // TODO: hair splitting error here
    result = (await Promise.all(items.map(({ id }) => shareItem(id, shareLevelOptions, groupIds, portal, useFetchRequest)))).map((response) => response.result);
  }
  return { result };
};
const unshareItems = async (itemIds, groupIds, config) => {
  const { portal, user } = config;
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.g)(portal)}content/users/${user.username}/unshareItems`;
  try {
    const result = (await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, {
      body: { items: itemIds.join(","), groups: (groupIds === null || groupIds === void 0 ? void 0 : groupIds.length) ? groupIds.join(",") : null },
      usePost: true
    })).results;
    return { result };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
/**
 * Share single item to the specified groups with the specified access level
 *
 * Note: `request` will toast an error on the Home app `useFetchRequest` is a workaround. TODO: remove this once we have a better way
 *
 * */
async function shareItem(itemId, shareLevelOptions, groups, portal, useFetchRequest = false) {
  try {
    const url = `${(0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_0__.g)(itemId, portal)}/share`;
    const params = Object.assign({ groups: (groups === null || groups === void 0 ? void 0 : groups.length) ? groups.join(",") : null, confirmItemControl: true }, shareLevelOptions);
    let result;
    if (useFetchRequest) {
      result = await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, { body: params, usePost: true });
    }
    else {
      result = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.r)(url, params, {}, "post");
    }
    return { result };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
}
function toShareLevelOptions(shareLevel) {
  switch (shareLevel) {
    case "public":
      return { org: false, everyone: true };
    case "org":
      return { org: true, everyone: false };
    case "private":
      return { org: false, everyone: false };
    case "shared":
      return { org: false, everyone: false };
    default:
      return {};
  }
}

// disable public sharing of certain items
// WebGIS/arcgis-portal-app#26591, WebGIS/arcgis-portal-app#26987, WebGIS/arcgis-portal-app#30517
// WebGIS/arcgis-portal-app#35924, WebGIS/arcgis-portal-app#36835
function isBlockedFromSharingToPublic(item) {
  const { typeKeywords, type, url } = item;
  const hasNonShareableKeyword = typeKeywords && nonPubliclyShareableKeywords.some((keyword) => typeKeywords.includes(keyword));
  // ! No need to check for portal.isPortal here as that url type is only in ArcGIS Online
  const isOnlineDynamicImageryService = type === "Image Service" && (url === null || url === void 0 ? void 0 : url.includes("://iservices")) && url.includes("arcgis.com");
  const isNonShareableType = nonPubliclyShareableTypes.includes(type);
  return hasNonShareableKeyword || isOnlineDynamicImageryService || isNonShareableType;
}
function isBlockedFromDeveloperSharingToPublic(item) {
  var _a;
  const isHosted = (_a = item.typeKeywords) === null || _a === void 0 ? void 0 : _a.includes("Hosted Service");
  const blackListTypes = [
    "Vector Tile Service",
    "Map Service",
    "Scene Service",
    "Feature Service"
  ];
  return blackListTypes.includes(item.type) && isHosted;
}
const nonPubliclyShareableKeywords = [
  "Location Tracking Service",
  "Location Tracking View",
  "IoTFeed",
  "IoTFeatureLayer",
  "IoTMapImageLayer",
  "IoTStreamLayer",
  "Administrative Report",
  "EditExtensionIndoorsSpaces",
  "ArcgisWorkflowJobLocation"
];
const nonPubliclyShareableTypes = ["Knowledge Graph", "Pro Project"];

// * --- Dependent item layers
const getDependentItemLayers = async (mainItem, portal) => {
  const id = mainItem.id;
  let getDataError;
  let itemsAndLayers = { items: [], layers: [] };
  switch (mainItem.type) {
    case "Group Layer":
      ({ result: itemsAndLayers, error: getDataError } = await getGroupLayerDependentItemLayers(id, portal));
      break;
    case "Web Map":
    case "Web Scene":
      ({ result: itemsAndLayers, error: getDataError } = await getWebMapDependentItemLayers(id, portal));
      break;
    case "Web Mapping Application":
      ({ result: itemsAndLayers, error: getDataError } = await getWebAppDependentItemLayers(id, portal));
      break;
    case "Web Experience":
    case "Web Experience Template":
      ({ result: itemsAndLayers, error: getDataError } = await getWebExperienceDependentItemLayers(id, mainItem.typeKeywords, portal));
      break;
    case "Big Data File Share":
    case "Data Store":
      throw new Error("Not implemented");
  }
  return { result: itemsAndLayers, error: getDataError };
};
// * --- Group layer
const getGroupLayerDependentItemLayers = async (itemId, portal) => {
  try {
    const itemData = await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.g)(itemId, portal);
    return {
      result: {
        items: [],
        layers: [Object.assign({}, itemData)]
      }
    };
  }
  catch (error) {
    // TODO: handle more error
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
// * --- Web map
const getWebMapDependentItemLayers = async (itemId, portal) => {
  var _a, _b;
  try {
    const itemData = await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.g)(itemId, portal);
    const { operationalLayers, baseMap, tables, ground } = itemData;
    return {
      result: {
        items: [],
        layers: [
          ...(operationalLayers !== null && operationalLayers !== void 0 ? operationalLayers : []),
          ...((_a = baseMap === null || baseMap === void 0 ? void 0 : baseMap.baseMapLayers) !== null && _a !== void 0 ? _a : []),
          ...((_b = ground === null || ground === void 0 ? void 0 : ground.layers) !== null && _b !== void 0 ? _b : []),
          ...(tables !== null && tables !== void 0 ? tables : [])
        ]
      }
    };
  }
  catch (error) {
    // TODO: handle more error
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
// * --- Web app
const getWebAppDependentItemLayers = async (itemId, portal) => {
  try {
    const itemData = await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.g)(itemId, portal);
    if (!itemData) {
      return { result: { items: [], layers: [] } };
    }
    const webAppMapList = getWebAppMapList(itemData);
    const dependentItems = (await Promise.all(webAppMapList.map((itemId) => (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.a)(itemId, portal))))
      // TODO: handle errors
      .map(({ result }) => result)
      .filter((item) => item);
    const dependentItemLayers = await Promise.all(dependentItems.map((item) => getDependentItemLayers(item, portal)));
    const { items, layers } = flattenDependentItemsAndLayerResponse(dependentItemLayers
      .map(({ result }) => result)
      .flat()
      .filter((result) => result));
    return {
      // Web map application doesn't have any layers so we only return the layers from dep items
      result: { items: [...dependentItems, ...items], layers }
    };
  }
  catch (error) {
    // TODO: handle more error
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
const getWebAppMapList = (appData) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  const items = ((_a = appData === null || appData === void 0 ? void 0 : appData.map) === null || _a === void 0 ? void 0 : _a.itemId) ? [appData.map.itemId] : [];
  const portfolioCollection = (_d = (_c = (_b = appData.values) === null || _b === void 0 ? void 0 : _b.itemCollection) === null || _c === void 0 ? void 0 : _c.map((el) => el.id)) !== null && _d !== void 0 ? _d : [];
  const maps = (_g = (_f = (_e = appData.values) === null || _e === void 0 ? void 0 : _e.webmap) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
  const scenes = (_k = (_j = (_h = appData.values) === null || _h === void 0 ? void 0 : _h.webscene) === null || _j === void 0 ? void 0 : _j.split(",")) !== null && _k !== void 0 ? _k : [];
  return [...items, ...portfolioCollection, ...maps, ...scenes];
};
// * --- Web experience
const getWebExperienceDependentItemLayers = async (itemId, typeKeywords, portal) => {
  const draftUrl = `${(0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_0__.g)(itemId, portal)}/resources/config/config.json`;
  const itemDataUrl = (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.b)(itemId, portal);
  const dataUrls = [];
  if (typeKeywords.includes("status: Draft")) {
    dataUrls.push(draftUrl);
  }
  else if (typeKeywords.includes("status: Changed")) {
    dataUrls.push(draftUrl, itemDataUrl);
  }
  else {
    dataUrls.push(itemDataUrl);
  }
  try {
    const allItems = [];
    const allDependentItems = [];
    const allLayers = [];
    await Promise.all(dataUrls.map(async (dataUrl) => {
      const itemData = await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.r)(dataUrl, portal);
      if (!(itemData === null || itemData === void 0 ? void 0 : itemData.dataSources) && !(itemData === null || itemData === void 0 ? void 0 : itemData.utilities)) {
        return;
      }
      const dependentItems = (await Promise.all(getWebExperienceDependencyIdList(itemData).map((itemId) => (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.a)(itemId, portal)))) // TODO: handle errors
        .map(({ result }) => result)
        .filter((item) => item);
      const dependentItemLayers = await Promise.all(dependentItems.map((item) => getDependentItemLayers(item, portal)));
      const { items, layers } = flattenDependentItemsAndLayerResponse(dependentItemLayers.flatMap(({ result }) => result).filter((layer) => layer));
      allLayers.push(...layers);
      allItems.push(...items);
      allDependentItems.push(...dependentItems);
    }));
    return {
      // Web experience doesn't have any layers so we only return the layers from dep items
      result: { items: [...allDependentItems, ...allItems], layers: allLayers }
    };
  }
  catch (error) {
    // TODO: handle more error
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
function getWebExperienceDependencyIdList(data) {
  const dataSources = data.dataSources || {};
  const utilities = data.utilities || {};
  const allDeps = [...Object.values(dataSources), ...Object.values(utilities)];
  return allDeps.map((dep) => dep.itemId).filter((id) => id);
}
const flattenDependentItemsAndLayerResponse = (responses) => {
  return {
    items: responses.flatMap((response) => response.items),
    layers: responses.flatMap((response) => response.layers)
  };
};

/**
 * Get the groups that a layer is shared with
 */
async function getLayerSharedGroups(layerId, portal, includeFavoriteGroups = false) {
  try {
    const { result } = await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.c)(layerId, portal);
    return {
      result: [...result.admin, ...result.member, ...result.other]
        .filter((group) => includeFavoriteGroups || !group.isFav)
        .map((group) => group.id)
    };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
}

const isWebMapTable = (layer) => 
// ! This is just a workaround for now but it's not completely safe since there is no discriminator
!("layerType" in layer) && layer.url && layer.popupInfo;
const isSupportedLayerTypeForUrlCheck = (layer) => {
  const validTypes = [
    "table",
    "ArcGISFeatureLayer",
    "ArcGISTiledMapServiceLayer",
    "VectorTileLayer",
    "GroupLayer",
    "ArcGISImageServiceLayer",
    "ArcGISTiledImageServiceLayer",
    "SubtypeGroupLayer",
    "ArcGISStreamLayer",
    "MediaLayer"
  ];
  return validTypes.includes(layer.layerType);
};
const isTileLayer = (layer) => layer.layerType === "ArcGISTiledMapServiceLayer";
const isTileOperationLayerWithPopup = (layer) => layer.layerType === "ArcGISTiledMapServiceLayer" && "layers" in layer && layer.layers[0].disablePopup === false;
const isVectorTileLayer = (layer) => layer.layerType === "VectorTileLayer" && "styleUrl" in layer;
const DEFAULT_SHARING_DETAILS = {
  needsGroupUpdate: false,
  needsShareLevelUpdate: false,
  canEditShareLevel: true,
  premium: false
};

/**
 * Send a request to get data for `url`. This request will not include a token to avoid token leak
 */
const getServiceUrlResponse = async (url, portal) => {
  var _a;
  try {
    return { result: await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, { addTokenManually: false }) };
  }
  catch (error) {
    const tokenRequiredMessage = "token required";
    if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(tokenRequiredMessage)) {
      return { error: { code: "tokenRequired" } };
    }
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};

const accessLevel = {
  private: 0,
  shared: 1,
  org: 2,
  public: 3
};
const isAccessLevelGreater = (mainAccess, otherAccess) => accessLevel[mainAccess] > accessLevel[otherAccess];
/**
 * Given a URL and a relative path, return the full URL
 * e.g: https://www.arcgis.com/sharing/rest/content/items/1234567890abcdefg and "../../", return https://www.arcgis.com/sharing/rest/
 *
 */
const traverseUrls = ({ path, url }) => {
  const urlParts = url.split("/");
  const pathParts = path.split("/");
  const urlPartsToKeep = urlParts.slice(0, urlParts.length - pathParts.length);
  return urlPartsToKeep.join("/");
};

const filterUrlsFromSameOrigin = async (portal, urlsToCheck) => {
  const { owningSystemUrl: mainItemOwningSystemUrl } = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.f)(async () => (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.a)(portal), "portalInfo", portal.id);
  const urlOwningSystemInfo = await Promise.all(urlsToCheck.map(async (url) => {
    try {
      const { owningSystemUrl } = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.b)(url);
      return { owningSystemUrl, url };
    }
    catch (error) {
      console.error(error);
      return { owningSystemUrl: null, url };
    }
  }));
  return (urlOwningSystemInfo
    // TODO: handle Enterprise case
    .filter(({ owningSystemUrl }) => owningSystemUrl === mainItemOwningSystemUrl)
    .map(({ url }) => url));
};

/** Get the source item for tile layer
 * @param layer - The layer to get the source item for with layer type of ArcGISTiledMapServiceLayer
 */
const getTileLayerSourceItem = async (layer, portal) => {
  try {
    const itemId = layer.itemId;
    const itemData = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.f)(() => (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.g)(itemId, portal), "itemData", itemId);
    // Currently a tile layer can only be created from a single layer so we can just take the first layer
    const { layerItemId: sourceItemId } = itemData === null || itemData === void 0 ? void 0 : itemData.layers[0];
    if (!sourceItemId) {
      return { error: { code: "unhandledError" } };
    }
    return { result: await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.d)(sourceItemId, portal) };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
/** Get source items for items duplicated from another item
 *
 * This will ignore items that is not on the same environment as the main item
 * or if not using the same federated server if we're in Enterprise
 *
 * https://devtopia.esri.com/WebGIS/arcgis-app-components/issues/3809
 */
const getSourceItemsFromUrls = async (itemUrls, portal) => {
  const validUrlInfos = itemUrls.filter((urlInfo) => urlInfo && isSupportedLayerTypeForUrlCheck({ layerType: urlInfo.layerType }));
  const validItemUrls = await filterOutDiffOriginAGSUrls(validUrlInfos.map((urlInfo) => urlInfo.url), portal);
  // Some url is a root.json url so we need to go through another layer of getSourceItemsFromUrls to get the actual item
  const rootJSONServiceURL = [];
  // * First send request without token
  const requiredTokenUrls = [];
  const noTokenMetaData = [];
  await Promise.all(validItemUrls.map(async (url) => {
    const { result, error } = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.f)(() => getServiceUrlResponse(url, portal), "itemMetadata", `${url}--no-token`);
    if ((error === null || error === void 0 ? void 0 : error.code) === "tokenRequired") {
      requiredTokenUrls.push(url);
      return;
    }
    if (isRootJSONResponse(result)) {
      rootJSONServiceURL.push(getRootJSONResponseUrl(result, url));
    }
    else {
      noTokenMetaData.push(result);
    }
  }));
  const noTokenServiceIds = noTokenMetaData.map((metaData) => metaData === null || metaData === void 0 ? void 0 : metaData.serviceItemId);
  // * For urls that require token, check if they are in the same origin
  const sameHostRestUrls = await filterUrlsFromSameOrigin(portal, requiredTokenUrls);
  // If yes, then we can just get the item detail
  const requiredTokenMetaData = await Promise.all(sameHostRestUrls.map(async (url) => ({
    response: await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, { addTokenManually: true }),
    url // We need this for root json url
  })));
  const requiredTokenServiceIds = requiredTokenMetaData.reduce((idList, { response, url }) => {
    if (isRootJSONResponse(response)) {
      rootJSONServiceURL.push(getRootJSONResponseUrl(response, url));
      return idList;
    }
    return [...idList, response === null || response === void 0 ? void 0 : response.serviceItemId];
  }, []);
  // * Then just get the item detail
  const returnItems = await Promise.all([...noTokenServiceIds, ...requiredTokenServiceIds].map(async (serviceItemId) => serviceItemId ? (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.d)(serviceItemId, portal) : null));
  // We repeat the same process to get the actual `serviceItemId` then the item via the root json URL
  const rootJSONItems = rootJSONServiceURL.length <= 0
    ? []
    : await getSourceItemsFromUrls(rootJSONServiceURL.map((url) => ({ url, layerType: "VectorTileLayer" })), portal);
  return [...returnItems.filter((item) => !!item), ...rootJSONItems];
};
const isRootJSONResponse = (response) => {
  return !!(response === null || response === void 0 ? void 0 : response.sources);
};
const getRootJSONResponseUrl = (response, url) => {
  var _a;
  const responseUrl = (_a = Object.values(response.sources)[0]) === null || _a === void 0 ? void 0 : _a.url;
  if (!responseUrl) {
    return null;
  }
  return responseUrl.includes("..") ? traverseUrls({ url, path: responseUrl }) : responseUrl;
};
const filterOutDiffOriginAGSUrls = async (urls, portal) => {
  const validAgsURL = urls.filter((url) => !!url && !!(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.p)(url));
  // TODO R3: we'll fine-grain checking this later and once items have better spec
  const nonAGSUrls = urls.filter((url) => !url || !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.p)(url));
  const sameOriginUrls = await filterUrlsFromSameOrigin(portal, validAgsURL);
  return [...sameOriginUrls, ...nonAGSUrls];
};

const getSourceItemsFromDependentLayers = async (dependentLayers, portal) => {
  // * Recursively flatten layers, focusing on GroupLayer
  const flattenedLayers = [];
  const analyzeLayer = (layer) => {
    if (isWebMapTable(layer)) {
      flattenedLayers.push({
        id: layer.id,
        url: layer.url,
        layerType: "table",
        getType: "normal"
      });
      return;
    }
    if (layer.layerType === "GroupLayer") {
      if (layer.itemId) {
        // A GroupLayer item
        flattenedLayers.push({
          id: layer.id,
          itemId: layer.itemId,
          layerType: "GroupLayer",
          getType: "normal"
        });
      }
      layer.layers.forEach((subLayer) => {
        if (isWebMapTable(subLayer) || subLayer.layerType === "GroupLayer") {
          analyzeLayer(subLayer);
          return;
        }
        const subLayerUrl = subLayer.url;
        if (!subLayerUrl) {
          analyzeLayer(subLayer);
          return;
        }
        const parseUrlInfo = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.p)(subLayerUrl);
        analyzeLayer(Object.assign(Object.assign({}, subLayer), { 
          // If a layer in GroupLayer has index in their URL, we'll want to strip them out first
          // This might create some duplicated URLs but we already filter them out below via the `layerItemIdLookupMap`
          url: (parseUrlInfo === null || parseUrlInfo === void 0 ? void 0 : parseUrlInfo.index) != null ? parseUrlInfo.baseServerUrl : subLayer.url }));
      });
      return;
    }
    if (isVectorTileLayer(layer)) {
      flattenedLayers.push({
        id: layer.id,
        url: layer.styleUrl,
        itemId: layer.itemId,
        layerType: layer.layerType,
        getType: "normal"
      });
      return;
    }
    // We need to also fetch the original item this tile layer is created from
    if (isTileLayer(layer)) {
      // If the tile layer has popup enabled, we can just take the layer directly
      //  which is simply via layers[0]'s `layerItemId`
      //  if not, we'll have to go into /data and get the `layerItemId` first from there
      const isTileLayerWithPopup = isTileOperationLayerWithPopup(layer);
      if (isTileLayerWithPopup) {
        const firstSubLayer = layer.layers[0];
        flattenedLayers.push({
          id: firstSubLayer.id,
          url: firstSubLayer.layerUrl,
          getType: "normal",
          layerType: layer.layerType,
          itemId: firstSubLayer.layerItemId
        });
        // ! We also want to check for the tile layer sharing mismatch so there is no return here
      }
      flattenedLayers.push({
        id: layer.id,
        getType: isTileLayerWithPopup ? "normal" : "tile-layer-with-no-popup",
        itemId: layer.itemId,
        layerType: layer.layerType,
        url: layer.url
      });
      return;
    }
    if (layer.itemId || layer.url) {
      flattenedLayers.push({
        id: layer.id,
        url: layer.url,
        itemId: layer.itemId,
        layerType: layer.layerType,
        getType: "normal"
      });
    }
  };
  dependentLayers.forEach(analyzeLayer);
  const layerItemIdLookupMap = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_4__.a)(flattenedLayers, (layer) => {
    if (layer.itemId) {
      return { key: layer.itemId, data: { searchType: "item-id", layerType: layer.layerType } };
    }
    // Layer from shallow copied or duplicated items
    // However, if layer doesn't have both `itemId` and `url`, we'll just have the key as `null` and ignore them since there is no way to get the source item
    return { key: layer.url, data: { searchType: "url", layerType: layer.layerType } };
  });
  const uniqueIds = Object.keys(layerItemIdLookupMap).filter((id) => layerItemIdLookupMap[id].searchType === "item-id");
  try {
    // * --- Handle getting source item
    const itemsFromIds = (await Promise.all(uniqueIds.map((id) => (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.d)(id, portal)))).filter((itemInfo) => !!itemInfo);
    // Handle tile layer source item if the tile layer doesn't have popup enabled
    const dependentTileLayers = flattenedLayers.filter(({ getType: type, itemId }) => type === "tile-layer-with-no-popup" && !!itemId);
    const tileLayerSourceItems = (await Promise.all(dependentTileLayers.map((layer) => getTileLayerSourceItem(layer, portal)))).map(({ result }) => result);
    // Handle item duplicated from another item --- currently also handle vector tile layer
    //  because isHostedService doesn't count vector tile layer as hosted service
    const nonHostedItems = itemsFromIds.filter((item) => !(0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.i)(item.typeKeywords, item.type));
    const nonHostedItemInfos = await getSourceItemsFromUrls(nonHostedItems.map((item) => {
      const { url, id } = item;
      const layerInfo = layerItemIdLookupMap[id];
      return layerInfo ? { layerType: layerInfo.layerType, url } : null;
    }), portal);
    const nonHostedItemsLookupByUrl = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_4__.a)(nonHostedItemInfos, (item) => ({
      key: item.url,
      data: item
    }));
    // Handle shallow copied layers
    const shallowedCopiedLayerUrls = Object.keys(layerItemIdLookupMap)
      .map((url) => {
      const layerInfo = layerItemIdLookupMap[url];
      return layerInfo && layerInfo.searchType === "url" ? { layerType: layerInfo.layerType, url } : null;
    })
      .filter((layerInfo) => layerInfo);
    const shallowCopiedItems = await getSourceItemsFromUrls(shallowedCopiedLayerUrls, portal);
    // * Aggregate the result
    const sourceItems = [];
    itemsFromIds
      .filter((itemInfo) => itemInfo)
      .forEach((item) => {
      const itemUrl = item.url;
      sourceItems.push({ sourceItem: item });
      const nonHostedSourceItem = nonHostedItemsLookupByUrl[itemUrl];
      if (nonHostedSourceItem && item.id !== nonHostedSourceItem.id) {
        sourceItems.push({ sourceItem: nonHostedSourceItem });
      }
    });
    [...tileLayerSourceItems, ...shallowCopiedItems].forEach((item) => {
      if (!item) {
        return;
      }
      sourceItems.push({ layer: null, sourceItem: item });
    });
    return { result: sourceItems };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};

/**
 * Analyze sharing detail of the item and return any mismatch or sharing issues
 *
 * @param overrideLayers
 * Normally, the util will fetch the layers from the /data endpoint
 * However, if the user has overrideLayers layers, we can pass them in here
 *
 * **Note!!!**: Make sure the layers passed in is in the form of what we would receive from the /data endpoint of the item, not JS API's `Layer`
 *
 * This is useful in the case of Map Viewer where the /data endpoint is not updated with the latest layers after save
 *
 * @param options - options - see {@link Options}
 */
const analyzeSharingDetail = async (item, portal, overrideLayers, options = { clearDataCacheOnDone: true }) => {
  if (item.access === "private") {
    return {
      result: {
        needEditableLayers: [],
        needPubliclyEditableLayers: [],
        needDataCollectionLayers: [],
        needsShareLevelUpdateLayers: [],
        premiumLayers: [],
        notEditableLayers: []
      }
    };
  }
  const { result, error } = await getLayerAndSharingDetail(item, portal, overrideLayers);
  if (error) {
    return { error };
  }
  const sharingDetailBuckets = {
    needEditableLayers: [],
    needPubliclyEditableLayers: [],
    needDataCollectionLayers: [],
    needsShareLevelUpdateLayers: [],
    premiumLayers: [],
    notEditableLayers: []
  };
  await Promise.all(result === null || result === void 0 ? void 0 : result.map(async (info) => {
    const bucket = await getSharingDetailBucket({
      mainItem: item,
      sharingDetailResult: info,
      portal
    });
    bucket && sharingDetailBuckets[bucket].push(info);
  }));
  if (options.clearDataCacheOnDone) {
    // TODO: find a way to scope this to the function only (possibly through store of cache)
    //  but right now we don't have a use case for that so it should be fine...
    dependencyCheckCacheTypes.forEach((type) => (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_1__.c)(type));
  }
  return { result: sharingDetailBuckets };
};
/**
 * Get item and layers from /data in case user doesn't pass layers

  * Ultimately, the goal is to get the source item and their sharing detail from all the dependent layers
 */
const getLayerAndSharingDetail = async (mainItem, portal, overrideLayers) => {
  let itemsToCheck = [];
  let dependentLayers = [...(overrideLayers || [])];
  let getDataError;
  if (!(dependentLayers === null || dependentLayers === void 0 ? void 0 : dependentLayers.length)) {
    const { error, result } = await getDependentItemLayers(mainItem, portal);
    getDataError = error;
    dependentLayers = result.layers;
    itemsToCheck = result.items;
  }
  if (getDataError) {
    return { error: getDataError };
  }
  if (dependentLayers.length <= 0 && itemsToCheck.length <= 0) {
    return { error: { code: "dataNotAvailable" } };
  }
  try {
    const { result: dependentLayerSourceItems, error } = await getSourceItemsFromDependentLayers(dependentLayers, portal);
    if (error) {
      return { error };
    }
    // * Group sharing stuff
    const { result: mainItemSharingGroups, error: getSharedGroupsError } = await getLayerSharedGroups(mainItem.id, portal);
    if (getSharedGroupsError) {
      return { error: getSharedGroupsError };
    }
    // Sometimes layers can be created from he same source layers so we need to make sure we don't check the same source item multiple times
    const allSourceItems = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_4__.u)([...dependentLayerSourceItems.map(({ sourceItem }) => sourceItem), ...itemsToCheck], (item) => item.id);
    const result = await Promise.all(allSourceItems.map(async (item) => {
      const sharingDetail = await getItemSharingDetail({
        sourceItem: item,
        mainItemAccess: mainItem.access,
        mainItemSharingGroups,
        portal
      });
      return { layer: null, sourceItem: item, detail: sharingDetail };
    }));
    return { result };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};
async function getItemSharingDetail({ mainItemAccess, mainItemSharingGroups, portal, sourceItem }) {
  const { access: sourceItemAccess, itemControl } = sourceItem;
  const sharingDetail = Object.assign({}, DEFAULT_SHARING_DETAILS);
  const isMainItemSharingToPublic = mainItemAccess === "public";
  if (isBlockedFromSharingToPublic(sourceItem) && isMainItemSharingToPublic) {
    return Object.assign(Object.assign({}, sharingDetail), { needsShareLevelUpdate: true, canEditShareLevel: false });
  }
  // Can current user update the sharing on this item, and do they need to, if the layer is public
  // it doesn't really matter if they can or cannot
  if (sourceItemAccess !== "public") {
    sharingDetail.canEditShareLevel = checkCanUpdateShareLevel(itemControl);
    sharingDetail.needsGroupUpdate = await checkNeedGroupUpdate({
      sourceItem,
      isMainItemSharingToPublic,
      mainItemSharingGroups,
      portal
    });
    sharingDetail.needsShareLevelUpdate = checkNeedShareUpdate({
      mainItemAccess,
      sourceItemAccess
    });
  }
  else {
    // Is this item considered a premium item
    sharingDetail.premium = isPremiumContent(sourceItem);
  }
  return sharingDetail;
}
const checkCanUpdateShareLevel = (itemControl) => itemControl === "admin";
const checkNeedGroupUpdate = async ({ sourceItem, isMainItemSharingToPublic, portal, mainItemSharingGroups }) => {
  // TODO: remove this once we have fine-grain check for
  //  https://devtopia.esri.com/WebGIS/arcgis-app-components/pull/4068
  if (isMainItemSharingToPublic) {
    return false;
  }
  const { result: layerSharedGroups } = await getLayerSharedGroups(sourceItem.id, portal);
  return !sharedWithSameGroups(mainItemSharingGroups, layerSharedGroups);
};
const checkNeedShareUpdate = ({ mainItemAccess, sourceItemAccess }) => 
// "shared" is the same as "private" with groups so it needs group update, not share update
!(sourceItemAccess === "private" && mainItemAccess === "shared") &&
  isAccessLevelGreater(mainItemAccess, sourceItemAccess);
function isPremiumContent(item) {
  return (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.a)(item) || (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.b)(item);
  // return selectedShareLevel !== "public" ? false : isSubscriber(item) || isPremium(item);
}
function sharedWithSameGroups(sharedGroups, layerSharedGroups) {
  if (sharedGroups === null || sharedGroups === void 0 ? void 0 : sharedGroups.length) {
    // We use `sharedGroups` to check the order since we only need to check if layerSharedGroups
    // contains the same groups in the same order as sharedGroups, not the other way around
    const groupsNotSharedWithLayer = sharedGroups.filter((value) => !(layerSharedGroups || []).includes(value));
    return groupsNotSharedWithLayer.length <= 0;
  }
  return true;
}
/**
 * Share `items` with groups fetch from `sourceItemsForGroups`
 */
async function shareItemsToSharedGroups(items, sourceItemsForGroups, shareLevel, portal, shouldUpdateGroup = true) {
  const { user } = portal;
  const sharedGroupsList = !shouldUpdateGroup
    ? []
    : await Promise.all(sourceItemsForGroups.map(async (mainItem) => {
      const { result: groupIds } = await getLayerSharedGroups(mainItem.id, portal);
      return groupIds;
    }));
  const groupIds = sharedGroupsList.flat(1);
  return shareItems(items, shareLevel, groupIds, { portal, user }, true);
}
// https://www.figma.com/file/BBmw0ioRw0ZQmCqFHJeH2N/Share-Flowchart-5?type=whiteboard&node-id=401-149&t=E77ZkPzT8cboGdt7-0
const getSharingDetailBucket = async ({ mainItem, sharingDetailResult, portal }) => {
  var _a;
  const { sourceItem, detail } = sharingDetailResult;
  const { canEditShareLevel, needsGroupUpdate, needsShareLevelUpdate, premium } = detail;
  if (!needsGroupUpdate && !needsShareLevelUpdate && !premium) {
    return null;
  }
  if (!canEditShareLevel && !premium) {
    return "notEditableLayers";
  }
  switch (mainItem.access) {
    case "public":
      if (premium) {
        return "premiumLayers";
      }
      if (sourceItem.access !== "public") {
        const developer = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.c)(portal.subscriptionInfo || ((_a = portal.sourceJSON) === null || _a === void 0 ? void 0 : _a.subscriptionInfo));
        if (developer && isBlockedFromDeveloperSharingToPublic(sourceItem)) {
          return "notEditableLayers";
        }
        if (await (0,_item_d9d70416_js__WEBPACK_IMPORTED_MODULE_3__.e)(sourceItem, portal)) {
          const isDataCollectionLayer = sourceItem.typeKeywords.includes("Public Data Collection");
          return isDataCollectionLayer ? "needEditableLayers" : "needDataCollectionLayers";
        }
      }
      return "needsShareLevelUpdateLayers";
    case "org":
    case "shared":
    case "private":
      if (premium) {
        return null;
      }
      return "needsShareLevelUpdateLayers";
    default:
      assertNever(mainItem.access);
  }
};
// We don't blow up the cache for portal info since that information will not likely be changed
const dependencyCheckCacheTypes = ["itemData", "itemMetadata"];
const assertNever = (access) => {
  throw new Error(`Unexpected share level ${access}`);
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/utils-fba8960d.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/utils-fba8960d.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DEFAULT_SHARING_DETAIL),
/* harmony export */   a: () => (/* binding */ getUsernameQuery),
/* harmony export */   b: () => (/* binding */ showRevertGroupWarning),
/* harmony export */   c: () => (/* binding */ showRevertShareLevelWarning),
/* harmony export */   d: () => (/* binding */ DEFAULT_SHARE_LEVELS),
/* harmony export */   e: () => (/* binding */ showShareLevelChangeWarning),
/* harmony export */   f: () => (/* binding */ isShareLevelDirty),
/* harmony export */   g: () => (/* binding */ getItemsAndGroupsToUpdateShare),
/* harmony export */   h: () => (/* binding */ getPossibleShareLevel),
/* harmony export */   i: () => (/* binding */ isSelectedGroupDataDirty),
/* harmony export */   j: () => (/* binding */ getShareMode),
/* harmony export */   k: () => (/* binding */ canShareItemToGroup),
/* harmony export */   l: () => (/* binding */ checkIfSharingMixed),
/* harmony export */   s: () => (/* binding */ showEditGroupWarning)
/* harmony export */ });
/* harmony import */ var _privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./privileges-ccd5f37d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _services_adddeef9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./services-adddeef9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/services-adddeef9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




const groupsAreOwnedByOrg = (user, groupData) => {
  const { username, orgId } = user;
  return groupData.every(({ group }) => {
    const isOwner = username === (group === null || group === void 0 ? void 0 : group.owner);
    const isOwnedByMyOrg = orgId === group.orgId;
    return isOwner || isOwnedByMyOrg;
  });
};
const canShareItemToGroup = (selectedGroupData, user) => userCanShare(user) || ((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.A)(user) && groupsAreOwnedByOrg(user, selectedGroupData));
const userCanShare = (user) => !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.x)(user) || userCanShareItemToGroup(user);
/**
 * Checks if the groups are in a mixed state where at least one group is shared with different items than the rest
 */
const checkIfSharingMixed = (items, selectedGroups) => selectedGroups.some(({ selectedByItemIds }) => selectedByItemIds.length !== items.length);
/**
 * Checks whether the user is allowed to share their item to groups
 */
function userCanShareItemToGroup(user) {
  return (user.privileges || []).includes("portal:user:shareToGroup");
}
const privateItemsHaveBeenSharedToGroups = ({ items, groupData }) => items
  .filter((item) => {
  const access = item.access;
  return access === "private" || access === "shared";
})
  .reduce((memo, item) => memo || itemHasBeenSharedToGroups({ item, groupData }), false);
const itemHasBeenSharedToGroups = ({ item, groupData }) => groupData.reduce((memo, groupData) => memo || (!!groupData.selectedByItemIds && groupData.selectedByItemIds.includes(item.id)), false);
const showEditGroupWarning = (user, selectedShareLevels) => !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.x)(user) &&
  !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.y)(user) &&
  // They can't share to org anyway so no need to check that
  selectedShareLevels.some((shareLevel) => shareLevel === "private");
const showRevertGroupWarning = (user, selectedShareLevels, initialSelectedGroupData) => (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.n)(user) &&
  selectedShareLevels.some((shareLevel) => shareLevel === "private") &&
  initialSelectedGroupData.length > 0;
const showRevertShareLevelWarning = (user, items, selectedGroupData) => !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.x)(user) &&
  !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.z)(user) &&
  privateItemsHaveBeenSharedToGroups({ items, groupData: selectedGroupData });
const showShareLevelChangeWarning = (user, newShareLevel, selectedGroupData) => !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.x)(user) &&
  !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.z)(user) &&
  newShareLevel === "private" &&
  Object.keys(selectedGroupData).length > 0;

const getUsernameQuery = ({ shareMode, currentUsername, user, userGroupLookup, isPrivate }) => {
  var _a;
  let groupIds = [];
  let groupIdsQuery;
  if (userGroupLookup) {
    let currentUserGroups = [];
    if (shareMode === "admin" && ((_a = userGroupLookup[currentUsername]) === null || _a === void 0 ? void 0 : _a.length) && currentUsername !== user.username) {
      // In admin case, we want to also includes groups that the item owner has access to
      currentUserGroups = [...userGroupLookup[currentUsername]];
    }
    if (shareMode !== "admin" || !isPrivate) {
      // For admin, we only want to include the admin's groups if the item is not private
      // For private item owner, includes groups that they can share to
      userGroupLookup[user.username].forEach((group) => {
        if (!currentUserGroups.some((g) => g.id === group.id)) {
          currentUserGroups.push(group);
        }
      });
    }
    currentUserGroups === null || currentUserGroups === void 0 ? void 0 : currentUserGroups.forEach((group) => {
      var _a;
      // include group ids that the current user is owner or admin or if viewOnly is false
      const memberType = (_a = group.userMembership) === null || _a === void 0 ? void 0 : _a.memberType;
      if (group.isViewOnly && (memberType === "owner" || memberType === "admin")) {
        groupIds.push(group.id);
      }
    });
  }
  if (groupIds.length) {
    groupIdsQuery = `(isviewonly:false OR id:(${groupIds.join(" OR ")}))`;
  }
  const adminGroupQuery = groupIds.length ? ` OR id:(${groupIds.join(" OR ")})` : "";
  switch (shareMode) {
    // In the default (item owner) case, we want to show all the groups
    // that the user either owns or has write access to.
    // Write access is indicated by the isviewonly flag.
    //
    // Ideally, we'd also be able to show groups the current user is admin of
    // maybe with a syntax like admin:${currentUsername}
    // but the search endpoint does not support that.
    case "default":
      return groupIdsQuery || `(owner:${currentUsername} OR isviewonly:false)`;
    // group owner mode should only see groups owned by the current user
    // excluding shared-update groups
    case "group":
      return `owner:${currentUsername} -capabilities:updateitemcontrol`;
    // In admin cases, we want all the groups the current user is a member of.
    // this is handled by the searchUserAccess and searchUserName params
    // outside of the query string.
    case "admin":
      if (user.username === currentUsername) {
        return `(isviewonly:false${adminGroupQuery} OR owner:${user.username}) -capabilities:updateitemcontrol`;
      }
      // When looking at the content user's groups, show that user's groups
      // or groups they have access to.
      // WebGIS/arcgis-portal-app#28041
      return `(owner:${currentUsername} OR isviewonly:false${adminGroupQuery})`;
    default:
      return "";
  }
};

const DEFAULT_SHARING_DETAIL = {
  needEditableLayers: [],
  needPubliclyEditableLayers: [],
  needDataCollectionLayers: [],
  needsShareLevelUpdateLayers: [],
  premiumLayers: [],
  notEditableLayers: []
};
const DEFAULT_SHARE_LEVELS = ["private", "org", "public"];

// TODO: add unit test
/**
 * Compose the list of items/groups to share and unshare
 *
 * ! This assume when we share/unshare, we share/unshare to all items
 *
 * Useful for /shareItems or /unshareItems endpoints
 *  */
const getItemsAndGroupsToUpdateShare = (initialSelectedGroupData, curSelectedGroupData) => {
  // 3 states to handle:
  // 1: groups that are completely unshared from the all items -> unshareData
  // 2: groups that are completely shared to all items -> shareData
  // 3: mixed sharing -> we don't care // ! it will affect the activity log but we don't care for now
  const completelyUnsharedGroupData = initialSelectedGroupData.filter((groupData) => !curSelectedGroupData.some((curGroupData) => curGroupData.group.id === groupData.group.id));
  const completelySharedGroupData = curSelectedGroupData.filter((groupData) => {
    const initialGroupData = initialSelectedGroupData.find((initialGroupData) => initialGroupData.group.id === groupData.group.id);
    // This assume that when we share/unshare, we share/unshare to all items,
    //  so this means groupData.selectedByItemIds.length is already the max
    // This would make the util independent of the length of the items array
    return !initialGroupData || initialGroupData.selectedByItemIds.length < groupData.selectedByItemIds.length;
  });
  return {
    unshareGroupIds: completelyUnsharedGroupData.map((groupData) => groupData.group.id),
    shareGroupIds: completelySharedGroupData.map((groupData) => groupData.group.id)
  };
};
const getPossibleShareLevel = (user, items, portal) => {
  const isPublicUser$1 = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.n)(user);
  let possibleShareLevelOptions = DEFAULT_SHARE_LEVELS;
  if (isPublicUser$1) {
    possibleShareLevelOptions = ["private", "public"];
  }
  else if (!portal.canSharePublic && !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.e)(user)) {
    possibleShareLevelOptions = ["private", "org"];
  }
  possibleShareLevelOptions = possibleShareLevelOptions.filter((shareLevel) => canShareLevel(shareLevel, items, user, portal));
  return possibleShareLevelOptions;
};
const canShareLevel = (shareLevel, items, user, portal) => {
  var _a;
  if (shareLevel === "private") {
    return true;
  }
  const isOwnerOfAllItems = itemsOwnedByUser(user, items);
  const itemsBelongToOrg = itemsOwnedByOrg(user, items);
  const isItemAdmin = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.e)(user) && !(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.t)(user) && itemsBelongToOrg;
  const isCustomItemAdmin = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.e)(user) && (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.t)(user) && itemsBelongToOrg;
  const isPublicUser$1 = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.n)(user);
  if (shareLevel === "org") {
    if (isPublicUser$1) {
      return false;
    }
    return (((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.z)(user) && (isOwnerOfAllItems || isItemAdmin)) ||
      ((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.B)(user) && (isItemAdmin || isCustomItemAdmin)));
  }
  if (shareLevel === "public") {
    const developer = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.c)((portal === null || portal === void 0 ? void 0 : portal.subscriptionInfo) || ((_a = portal === null || portal === void 0 ? void 0 : portal.sourceJSON) === null || _a === void 0 ? void 0 : _a.subscriptionInfo));
    if (items.length === 1 &&
      ((0,_services_adddeef9_js__WEBPACK_IMPORTED_MODULE_2__.c)(items[0]) || (developer && (0,_services_adddeef9_js__WEBPACK_IMPORTED_MODULE_2__.d)(items[0])))) {
      return false;
    }
    const canSharePublic = portal.canSharePublic;
    return (isPublicUser$1 ||
      ((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.C)(user) && ((isOwnerOfAllItems && canSharePublic) || isItemAdmin)) ||
      ((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.D)(user) && (isItemAdmin || isCustomItemAdmin)));
  }
};
/**
 * Determine the share mode of the user based on the item.
 *
 * ! We only consider the first item on the list
 */
const getShareMode = (items, user, portal) => {
  const item = items[0];
  if ((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.i)(item, user)) {
    return "default";
  }
  /**
   * if there is no org id on the item, deduce that the user can do admin things
   *
   * if item.orgId is present, check equality against portal user's org
   */
  const itemOwnerAndUserSameOrg = !item.orgId || item.orgId === user.orgId;
  if ((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.E)({ items, user, portal }) && itemOwnerAndUserSameOrg) {
    return "admin";
  }
  // if the user is not item owner or org admin, they enter group sharing mode
  // which is very restricted
  return "group";
};
const itemsOwnedByUser = (user, items) => {
  return items.every((item) => (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.i)(item, user));
};
const itemsOwnedByOrg = (user, items) => {
  const userOrgId = user === null || user === void 0 ? void 0 : user.orgId;
  return items.every((item) => {
    var _a;
    return ((0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_0__.i)(item, user) ||
      // 3.x specific item.portal
      ((_a = item.portal) === null || _a === void 0 ? void 0 : _a.id) === userOrgId ||
      // 4.x specific item.orgId
      item.orgId === userOrgId ||
      // Seems to be available on both 3.x and 4.x but can't verify via the official doc, only the Home App :(
      // This property is calculated based on the user's credential (token) that's used to access the item
      //  so it might not be available if the item is accessed without a token (just a theory)
      //  that's why it's the last resort
      // https://developers.arcgis.com/javascript/latest/api-reference/esri-portal-PortalItem.html#isOrgItem
      item.isOrgItem);
  });
};
const isShareLevelDirty = (selectedShareLevels, initialShareLevels, items, selectedGroupData) => selectedShareLevels.some((curShareLevel, index) => {
  const initialShareLevel = initialShareLevels[index];
  // "shared" level = shared to group + "private"
  if (initialShareLevel === "shared" && curShareLevel === "private") {
    const item = items[index];
    return !selectedGroupData.some((groupData) => groupData.selectedByItemIds.includes(item.id));
  }
  return initialShareLevel !== curShareLevel;
});
// TODO: optimize this O(n^3)...
const isSelectedGroupDataDirty = (initialSelectedGroupData, curSelectedGroupData) => {
  if (initialSelectedGroupData.length !== curSelectedGroupData.length) {
    return true;
  }
  return curSelectedGroupData.some((curGroupData) => {
    const initialGroupData = initialSelectedGroupData.find((initialGroupData) => initialGroupData.group.id === curGroupData.group.id);
    if (!initialGroupData) {
      return true;
    }
    return !(0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.f)(initialGroupData.selectedByItemIds, curGroupData.selectedByItemIds);
  });
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fbG9jYWxlLTE5MDIxMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dGO0FBQ3hCO0FBQ1c7O0FBRW5FO0FBQ0EscURBQXFEO0FBQ3JELFVBQVUsdUNBQXVDLGtEQUFXLGFBQWEsa0RBQVcsdUJBQXVCLGtEQUFXLE9BQU87QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzREFBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNEQUFjLFNBQVMsZ0JBQWdCLE9BQU87QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sMERBQWtCLGtFQUFrRSxvQkFBb0Isb0NBQW9DO0FBQzdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1Szs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUNBLE1BQU0sMERBQXNCLEdBQUcscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBEQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQW1CO0FBQy9CLEdBQUc7QUFDSDs7QUFFb1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9pdGVtLWQ5ZDcwNDE2LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMTNlMDBhNzUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc2VydmljZXMtYWRkZGVlZjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vdXRpbHMtZmJhODk2MGQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBkIGFzIGdldFBvcnRhbFRva2VuLCBnIGFzIGdldFJlc3RCYXNlVXJsIH0gZnJvbSAnLi9wb3J0YWwtNzljYWFlZmYuanMnO1xuaW1wb3J0IHsgYyBhcyBjb25maWdTdGF0ZSB9IGZyb20gJy4vY29uZmlnLWViNWY3ZGMyLmpzJztcbmltcG9ydCB7IHAgYXMgcGFyc2VBR1NTZXJ2ZXJJbmZvIH0gZnJvbSAnLi9wcml2aWxlZ2VzLWNjZDVmMzdkLmpzJztcblxuLyoqIFdvcmstYXJvdW5kIHNpbmNlIHVzaW5nIGByZXF1ZXN0YCBkaXJlY3RseSB3aWxsIHRyaWdnZXIgdW53YW50ZWQgdG9hc3Qgb24gdGhlIEhvbWUgQXBwIGlmIHRoZSBsYXllciBpcyB1bmF2YWlsYWJsZSAqL1xuY29uc3QgcmVxdWVzdEZldGNoID0gYXN5bmMgKHVybCwgcG9ydGFsLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBib2R5LCB1c2VQb3N0LCBhZGRUb2tlbk1hbnVhbGx5LCBhcGkgPSBjb25maWdTdGF0ZSA9PT0gbnVsbCB8fCBjb25maWdTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnU3RhdGUuYXBpIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBpZiAoYm9keSkge1xuICAgIE9iamVjdC5lbnRyaWVzKGJvZHkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdXJsVG9TZW5kID0gbmV3IFVSTCh1cmwpO1xuICB1cmxUb1NlbmQuc2VhcmNoUGFyYW1zLmFwcGVuZChcImZcIiwgXCJqc29uXCIpO1xuICBjb25zdCB0b2tlbiA9IGFkZFRva2VuTWFudWFsbHkgPT09IGZhbHNlID8gbnVsbCA6IGF3YWl0IGdldFBvcnRhbFRva2VuKHBvcnRhbCwgYXBpKTtcbiAgaWYgKHRva2VuKSB7XG4gICAgdXJsVG9TZW5kLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJ0b2tlblwiLCB0b2tlbik7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmxUb1NlbmQudG9TdHJpbmcoKSwge1xuICAgIGJvZHk6IHVzZVBvc3QgPyBkYXRhIDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogdXNlUG9zdCA/IFwiUE9TVFwiIDogXCJHRVRcIlxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICBjb25zdCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgdHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiID8gbmV3IEVycm9yKGVycm9yKSA6IGVycm9yO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBpc0hvc3RlZFNlcnZpY2UgPSAodHlwZUtleXdvcmRzLCB0eXBlKSA9PiB0eXBlID09PSBcIkZlYXR1cmUgU2VydmljZVwiICYmIHR5cGVLZXl3b3Jkcy5pbmNsdWRlcyhcIkhvc3RlZCBTZXJ2aWNlXCIpO1xuXG5jb25zdCBnZXRIeWRyYXRlZEl0ZW0gPSBhc3luYyAoaXRlbUlkLCBwb3J0YWwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpdGVtID0gYXdhaXQgcmVxdWVzdEZldGNoKGdldEl0ZW1VcmwoaXRlbUlkLCBwb3J0YWwpLCBwb3J0YWwpO1xuICAgIC8vIFRPRE86IGNoZWNrIGlmIHdlIHN0aWxsIG5lZWQgdG8gZG8gdGhpc1xuICAgIC8vIGlmIChpc0hvc3RlZFNlcnZpY2UoaXRlbS50eXBlS2V5d29yZHMsIGl0ZW0udHlwZSkpIHtcbiAgICAvLyAgIGNvbnN0IGl0ZW1EYXRhID0gZ2V0SXRlbURhdGEoaXRlbS5pZCwgcG9ydGFsKTtcbiAgICAvLyAgIHJldHVybiB7IHJlc3VsdDogeyAuLi5pdGVtLCAuLi5pdGVtSW5mbywgLi4uaXRlbURhdGEgfSB9O1xuICAgIC8vIH1cbiAgICByZXR1cm4geyByZXN1bHQ6IGl0ZW0gfTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICB9XG59O1xuY29uc3QgZ2V0SXRlbURhdGFVcmwgPSAoaXRlbUlkLCBwb3J0YWwpID0+IGAke2dldEl0ZW1VcmwoaXRlbUlkLCBwb3J0YWwpfS9kYXRhYDtcbmNvbnN0IGdldEl0ZW1EYXRhID0gYXN5bmMgKGl0ZW1JZCwgcG9ydGFsKSA9PiB7XG4gIHJldHVybiByZXF1ZXN0RmV0Y2goZ2V0SXRlbURhdGFVcmwoaXRlbUlkLCBwb3J0YWwpLCBwb3J0YWwpO1xufTtcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBvbmNlIHdlIGZpZ3VyZSBvdXQgaG93IHRvIGVmZmljaWVudGx5IGRpc2FibGUgdGhlIHRvYXN0IG9uIHRoZSBIb21lIEFwcFxuY29uc3QgZ2V0SXRlbVVybCA9IChpdGVtSWQsIHBvcnRhbCkgPT4gYCR7Z2V0UmVzdEJhc2VVcmwocG9ydGFsKX1jb250ZW50L2l0ZW1zLyR7aXRlbUlkfWA7XG5jb25zdCBnZXRJdGVtID0gYXN5bmMgKGl0ZW1JZCwgcG9ydGFsLCByZXF1ZXN0T3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGdldEl0ZW1VcmwoaXRlbUlkLCBwb3J0YWwpO1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0RmV0Y2godXJsLCBwb3J0YWwsIHJlcXVlc3RPcHRpb25zKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICB9XG59O1xuY29uc3QgZ2V0SXRlbUdyb3VwcyA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGAke2dldEl0ZW1VcmwoaXRlbUlkLCBwb3J0YWwpfS9ncm91cHNgO1xuICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgcmVxdWVzdEZldGNoKHVybCwgcG9ydGFsKSB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIC8vIFRPRE86IGhhbmRsZSBlcnJvclxuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gIH1cbn07XG5jb25zdCBpc0VkaXRhYmxlSXRlbSA9IGFzeW5jIChpdGVtLCBwb3J0YWwpID0+IHtcbiAgbGV0IGlzRWRpdGFibGUgPSBmYWxzZTtcbiAgaWYgKGlzSG9zdGVkU2VydmljZShpdGVtLnR5cGVLZXl3b3JkcywgaXRlbS50eXBlKSkge1xuICAgIGlzRWRpdGFibGUgPSBhd2FpdCBoYXNFZGl0aW5nQ2FwYWJpbGl0eShpdGVtLnVybCwgcG9ydGFsKTtcbiAgfVxuICByZXR1cm4gaXNFZGl0YWJsZTtcbn07XG5jb25zdCBoYXNFZGl0aW5nQ2FwYWJpbGl0eSA9IGFzeW5jIChsYXllclVybCwgcG9ydGFsLCByZXF1aXJlZE5vVG9rZW4gPSBmYWxzZSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgaWYgKGxheWVyVXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3RGZXRjaChgJHsoX2EgPSBwYXJzZUFHU1NlcnZlckluZm8obGF5ZXJVcmwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmFzZVNlcnZlclVybH0vbGF5ZXJzYCwgcG9ydGFsLCB7IGFkZFRva2VuTWFudWFsbHk6ICFyZXF1aXJlZE5vVG9rZW4gfSk7XG4gICAgICByZXR1cm4gKF9iID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmxheWVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZHVjZSgobWVtbywgbGF5ZXIpID0+IG1lbW8gfHwgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci5jYXBhYmlsaXRpZXMuaW5jbHVkZXMoXCJFZGl0aW5nXCIpKSwgZmFsc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICgoX2MgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlbiByZXF1aXJlZFwiKSkge1xuICAgICAgICByZXR1cm4gaGFzRWRpdGluZ0NhcGFiaWxpdHkobGF5ZXJVcmwsIHBvcnRhbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGdldEh5ZHJhdGVkSXRlbSBhcyBhLCBnZXRJdGVtRGF0YVVybCBhcyBiLCBnZXRJdGVtR3JvdXBzIGFzIGMsIGdldEl0ZW0gYXMgZCwgaXNFZGl0YWJsZUl0ZW0gYXMgZSwgZ2V0SXRlbURhdGEgYXMgZywgaXNIb3N0ZWRTZXJ2aWNlIGFzIGksIHJlcXVlc3RGZXRjaCBhcyByIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tMTNmNWIwMGMuanMnO1xuXG5jb25zdCBsYW5ndWFnZU1hcCA9IG5ldyBNYXAoW1xuICBbXCJhclwiLCBcImFyXCJdLFxuICBbXCJiZ1wiLCBcImJnXCJdLFxuICBbXCJic1wiLCBcImJzXCJdLFxuICBbXCJjYVwiLCBcImNhXCJdLFxuICBbXCJjc1wiLCBcImNzXCJdLFxuICBbXCJkYVwiLCBcImRhXCJdLFxuICBbXCJkZVwiLCBcImRlXCJdLFxuICBbXCJlbFwiLCBcImVsXCJdLFxuICBbXCJlblwiLCBcImVuXCJdLFxuICBbXCJlc1wiLCBcImVzXCJdLFxuICBbXCJldFwiLCBcImV0XCJdLFxuICBbXCJmaVwiLCBcImZpXCJdLFxuICBbXCJmclwiLCBcImZyXCJdLFxuICBbXCJoZVwiLCBcImhlXCJdLFxuICBbXCJoclwiLCBcImhyXCJdLFxuICBbXCJodVwiLCBcImh1XCJdLFxuICBbXCJpZFwiLCBcImlkXCJdLFxuICBbXCJpdFwiLCBcIml0XCJdLFxuICBbXCJqYVwiLCBcImphXCJdLFxuICBbXCJrb1wiLCBcImtvXCJdLFxuICBbXCJsdFwiLCBcImx0XCJdLFxuICBbXCJsdlwiLCBcImx2XCJdLFxuICBbXCJuYlwiLCBcIm5iXCJdLFxuICBbXCJubFwiLCBcIm5sXCJdLFxuICBbXCJwbFwiLCBcInBsXCJdLFxuICBbXCJwdC1iclwiLCBcInB0LUJSXCJdLFxuICBbXCJwdC1wdFwiLCBcInB0LVBUXCJdLFxuICBbXCJyb1wiLCBcInJvXCJdLFxuICBbXCJydVwiLCBcInJ1XCJdLFxuICBbXCJza1wiLCBcInNrXCJdLFxuICBbXCJzbFwiLCBcInNsXCJdLFxuICBbXCJzclwiLCBcInNyXCJdLFxuICBbXCJzdlwiLCBcInN2XCJdLFxuICBbXCJ0aFwiLCBcInRoXCJdLFxuICBbXCJ0clwiLCBcInRyXCJdLFxuICBbXCJ1a1wiLCBcInVrXCJdLFxuICBbXCJ2aVwiLCBcInZpXCJdLFxuICBbXCJ6aC1jblwiLCBcInpoLUNOXCJdLFxuICBbXCJ6aC1oa1wiLCBcInpoLUhLXCJdLFxuICBbXCJ6aC10d1wiLCBcInpoLVRXXCJdXG5dKTtcbi8vIHJ0bFxuZnVuY3Rpb24gZ2V0RWxlbWVudERpcihlbCkge1xuICByZXR1cm4gZ2V0RWxlbWVudFByb3AoZWwsIFwiZGlyXCIsIFwibHRyXCIpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFByb3AoZWwsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IGNsb3Nlc3RXaXRoUHJvcCA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgYFske3Byb3B9XWApO1xuICByZXR1cm4gY2xvc2VzdFdpdGhQcm9wID8gY2xvc2VzdFdpdGhQcm9wLmdldEF0dHJpYnV0ZShwcm9wKSA6IHZhbHVlO1xufVxuLy8gY3NzXG5jb25zdCBDU1NfVVRJTElUWSA9IHtcbiAgcnRsOiBcImFyY2dpcy0tcnRsXCJcbn07XG5hc3luYyBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYXBpLCB0eXBlLCBwbGFjZXMgfSA9IG9wdGlvbnMgfHwge307XG4gIGlmIChhcGkgPT09IDQpIHtcbiAgICBjb25zdCBbaW50bF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2ludGxcIl0pO1xuICAgIGNvbnN0IG51bWJlckZvcm1hdEludGxPcHRpb25zID0gaW50bC5jb252ZXJ0TnVtYmVyRm9ybWF0VG9JbnRsT3B0aW9ucyh7XG4gICAgICBwbGFjZXMsXG4gICAgICBzdHlsZTogdHlwZSxcbiAgICAgIGRpZ2l0U2VwYXJhdG9yOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGludGwuZm9ybWF0TnVtYmVyKG51bWJlciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyksIHsgc3R5bGU6IHR5cGUgfSkpO1xuICB9XG4gIGNvbnN0IFtkb2pvTnVtYmVyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImRvam8vbnVtYmVyXCJdKTtcbiAgcmV0dXJuIGRvam9OdW1iZXIuZm9ybWF0KG51bWJlciwge1xuICAgIHR5cGUsXG4gICAgcGxhY2VzLFxuICAgIHBhdHRlcm46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXR0ZXJuXG4gIH0pO1xufVxuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICBjb25zdCBsYW5nID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lmxhbmc7XG4gIGNvbnN0IGRheVNob3J0TW9udGhZZWFyID0ge1xuICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIlxuICB9O1xuICBpZiAoIWNhY2hlW2xhbmddKSB7XG4gICAgY2FjaGVbbGFuZ10gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZywgZGF5U2hvcnRNb250aFllYXIpO1xuICB9XG4gIHJldHVybiBjYWNoZVtsYW5nXS5mb3JtYXQoZGF0ZSk7XG59XG5cbmV4cG9ydCB7IENTU19VVElMSVRZIGFzIEMsIGZvcm1hdERhdGUgYXMgYSwgZm9ybWF0TnVtYmVyIGFzIGYsIGdldEVsZW1lbnREaXIgYXMgZywgbGFuZ3VhZ2VNYXAgYXMgbCB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTEzZjViMDBjLmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICB9XG4gIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICBsZXQgc3RyaW5ncztcbiAgdHJ5IHtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gIH1cbiAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBnIGFzIGdldEl0ZW1VcmwgfSBmcm9tICcuL3NlcnZlci1pdGVtLWYxMjE1M2U2LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0UmVzdEJhc2VVcmwsIHIgYXMgcmVxdWVzdCwgZiBhcyBmcm9tQ2FjaGUsIGEgYXMgZ2V0UG9ydGFsUmVzdEluZm8sIGIgYXMgZ2V0UG9ydGFsUmVzdEluZm9Gcm9tVXJsLCBjIGFzIGNsZWFyQ2FjaGUgfSBmcm9tICcuL3BvcnRhbC03OWNhYWVmZi5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzT3duZXIsIHAgYXMgcGFyc2VBR1NTZXJ2ZXJJbmZvLCBhIGFzIGlzU3Vic2NyaWJlciwgYiBhcyBpc1ByZW1pdW0sIGMgYXMgaXNEZXZlbG9wZXIgfSBmcm9tICcuL3ByaXZpbGVnZXMtY2NkNWYzN2QuanMnO1xuaW1wb3J0IHsgciBhcyByZXF1ZXN0RmV0Y2gsIGcgYXMgZ2V0SXRlbURhdGEsIGEgYXMgZ2V0SHlkcmF0ZWRJdGVtLCBiIGFzIGdldEl0ZW1EYXRhVXJsLCBjIGFzIGdldEl0ZW1Hcm91cHMsIGQgYXMgZ2V0SXRlbSwgaSBhcyBpc0hvc3RlZFNlcnZpY2UsIGUgYXMgaXNFZGl0YWJsZUl0ZW0gfSBmcm9tICcuL2l0ZW0tZDlkNzA0MTYuanMnO1xuaW1wb3J0IHsgYSBhcyBhcnJheVRvTG9va3VwTWFwLCB1IGFzIHVuaXF1ZUJ5IH0gZnJvbSAnLi9mdW5jdGlvbmFsLWM4MmY1YWI5LmpzJztcblxuLyoqXG4gKiBTaGFyZSBpdGVtcyB0byB0aGUgc3BlY2lmaWVkIGdyb3VwcyB3aXRoIHRoZSBzcGVjaWZpZWQgYWNjZXNzIGxldmVsXG4gKlxuICogTm90ZTogYHJlcXVlc3RgIHdpbGwgdG9hc3QgYW4gZXJyb3Igb24gdGhlIEhvbWUgYXBwIGB1c2VGZXRjaFJlcXVlc3RgIGlzIGEgd29ya2Fyb3VuZC4gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSB3ZSBoYXZlIGEgYmV0dGVyIHdheVxuICpcbiAqICovXG5jb25zdCBzaGFyZUl0ZW1zID0gYXN5bmMgKGl0ZW1zLCBzaGFyZUxldmVsLCBncm91cElkcywgY29uZmlnLCB1c2VGZXRjaFJlcXVlc3QgPSBmYWxzZSkgPT4ge1xuICBjb25zdCB7IHBvcnRhbCwgdXNlciB9ID0gY29uZmlnO1xuICBjb25zdCB1cmwgPSBgJHtnZXRSZXN0QmFzZVVybChwb3J0YWwpfWNvbnRlbnQvdXNlcnMvJHt1c2VyLnVzZXJuYW1lfS9zaGFyZUl0ZW1zYDtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzaGFyZUxldmVsT3B0aW9ucyA9IHNoYXJlTGV2ZWwgPyB0b1NoYXJlTGV2ZWxPcHRpb25zKHNoYXJlTGV2ZWwpIDoge307XG4gIGlmIChpdGVtcy5ldmVyeSgoaXRlbSkgPT4gaXNPd25lcihpdGVtLCB1c2VyKSkpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gKGF3YWl0IHJlcXVlc3RGZXRjaCh1cmwsIHBvcnRhbCwge1xuICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKHsgaXRlbXM6IGl0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5pZCkuam9pbihcIixcIiksIGdyb3VwczogKGdyb3VwSWRzID09PSBudWxsIHx8IGdyb3VwSWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cElkcy5sZW5ndGgpID8gZ3JvdXBJZHMuam9pbihcIixcIikgOiB1bmRlZmluZWQsIGNvbmZpcm1JdGVtQ29udHJvbDogdHJ1ZSB9LCBzaGFyZUxldmVsT3B0aW9ucyksXG4gICAgICAgIHVzZVBvc3Q6IHRydWVcbiAgICAgIH0pKS5yZXN1bHRzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gVE9ETzogaGFpciBzcGxpdHRpbmcgZXJyb3IgaGVyZVxuICAgIHJlc3VsdCA9IChhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoKHsgaWQgfSkgPT4gc2hhcmVJdGVtKGlkLCBzaGFyZUxldmVsT3B0aW9ucywgZ3JvdXBJZHMsIHBvcnRhbCwgdXNlRmV0Y2hSZXF1ZXN0KSkpKS5tYXAoKHJlc3BvbnNlKSA9PiByZXNwb25zZS5yZXN1bHQpO1xuICB9XG4gIHJldHVybiB7IHJlc3VsdCB9O1xufTtcbmNvbnN0IHVuc2hhcmVJdGVtcyA9IGFzeW5jIChpdGVtSWRzLCBncm91cElkcywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHsgcG9ydGFsLCB1c2VyIH0gPSBjb25maWc7XG4gIGNvbnN0IHVybCA9IGAke2dldFJlc3RCYXNlVXJsKHBvcnRhbCl9Y29udGVudC91c2Vycy8ke3VzZXIudXNlcm5hbWV9L3Vuc2hhcmVJdGVtc2A7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gKGF3YWl0IHJlcXVlc3RGZXRjaCh1cmwsIHBvcnRhbCwge1xuICAgICAgYm9keTogeyBpdGVtczogaXRlbUlkcy5qb2luKFwiLFwiKSwgZ3JvdXBzOiAoZ3JvdXBJZHMgPT09IG51bGwgfHwgZ3JvdXBJZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwSWRzLmxlbmd0aCkgPyBncm91cElkcy5qb2luKFwiLFwiKSA6IG51bGwgfSxcbiAgICAgIHVzZVBvc3Q6IHRydWVcbiAgICB9KSkucmVzdWx0cztcbiAgICByZXR1cm4geyByZXN1bHQgfTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICB9XG59O1xuLyoqXG4gKiBTaGFyZSBzaW5nbGUgaXRlbSB0byB0aGUgc3BlY2lmaWVkIGdyb3VwcyB3aXRoIHRoZSBzcGVjaWZpZWQgYWNjZXNzIGxldmVsXG4gKlxuICogTm90ZTogYHJlcXVlc3RgIHdpbGwgdG9hc3QgYW4gZXJyb3Igb24gdGhlIEhvbWUgYXBwIGB1c2VGZXRjaFJlcXVlc3RgIGlzIGEgd29ya2Fyb3VuZC4gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSB3ZSBoYXZlIGEgYmV0dGVyIHdheVxuICpcbiAqICovXG5hc3luYyBmdW5jdGlvbiBzaGFyZUl0ZW0oaXRlbUlkLCBzaGFyZUxldmVsT3B0aW9ucywgZ3JvdXBzLCBwb3J0YWwsIHVzZUZldGNoUmVxdWVzdCA9IGZhbHNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYCR7Z2V0SXRlbVVybChpdGVtSWQsIHBvcnRhbCl9L3NoYXJlYDtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHsgZ3JvdXBzOiAoZ3JvdXBzID09PSBudWxsIHx8IGdyb3VwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBzLmxlbmd0aCkgPyBncm91cHMuam9pbihcIixcIikgOiBudWxsLCBjb25maXJtSXRlbUNvbnRyb2w6IHRydWUgfSwgc2hhcmVMZXZlbE9wdGlvbnMpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHVzZUZldGNoUmVxdWVzdCkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdEZldGNoKHVybCwgcG9ydGFsLCB7IGJvZHk6IHBhcmFtcywgdXNlUG9zdDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCByZXF1ZXN0KHVybCwgcGFyYW1zLCB7fSwgXCJwb3N0XCIpO1xuICAgIH1cbiAgICByZXR1cm4geyByZXN1bHQgfTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICB9XG59XG5mdW5jdGlvbiB0b1NoYXJlTGV2ZWxPcHRpb25zKHNoYXJlTGV2ZWwpIHtcbiAgc3dpdGNoIChzaGFyZUxldmVsKSB7XG4gICAgY2FzZSBcInB1YmxpY1wiOlxuICAgICAgcmV0dXJuIHsgb3JnOiBmYWxzZSwgZXZlcnlvbmU6IHRydWUgfTtcbiAgICBjYXNlIFwib3JnXCI6XG4gICAgICByZXR1cm4geyBvcmc6IHRydWUsIGV2ZXJ5b25lOiBmYWxzZSB9O1xuICAgIGNhc2UgXCJwcml2YXRlXCI6XG4gICAgICByZXR1cm4geyBvcmc6IGZhbHNlLCBldmVyeW9uZTogZmFsc2UgfTtcbiAgICBjYXNlIFwic2hhcmVkXCI6XG4gICAgICByZXR1cm4geyBvcmc6IGZhbHNlLCBldmVyeW9uZTogZmFsc2UgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8vIGRpc2FibGUgcHVibGljIHNoYXJpbmcgb2YgY2VydGFpbiBpdGVtc1xuLy8gV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzI2NTkxLCBXZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAjMjY5ODcsIFdlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcCMzMDUxN1xuLy8gV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzM1OTI0LCBXZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAjMzY4MzVcbmZ1bmN0aW9uIGlzQmxvY2tlZEZyb21TaGFyaW5nVG9QdWJsaWMoaXRlbSkge1xuICBjb25zdCB7IHR5cGVLZXl3b3JkcywgdHlwZSwgdXJsIH0gPSBpdGVtO1xuICBjb25zdCBoYXNOb25TaGFyZWFibGVLZXl3b3JkID0gdHlwZUtleXdvcmRzICYmIG5vblB1YmxpY2x5U2hhcmVhYmxlS2V5d29yZHMuc29tZSgoa2V5d29yZCkgPT4gdHlwZUtleXdvcmRzLmluY2x1ZGVzKGtleXdvcmQpKTtcbiAgLy8gISBObyBuZWVkIHRvIGNoZWNrIGZvciBwb3J0YWwuaXNQb3J0YWwgaGVyZSBhcyB0aGF0IHVybCB0eXBlIGlzIG9ubHkgaW4gQXJjR0lTIE9ubGluZVxuICBjb25zdCBpc09ubGluZUR5bmFtaWNJbWFnZXJ5U2VydmljZSA9IHR5cGUgPT09IFwiSW1hZ2UgU2VydmljZVwiICYmICh1cmwgPT09IG51bGwgfHwgdXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1cmwuaW5jbHVkZXMoXCI6Ly9pc2VydmljZXNcIikpICYmIHVybC5pbmNsdWRlcyhcImFyY2dpcy5jb21cIik7XG4gIGNvbnN0IGlzTm9uU2hhcmVhYmxlVHlwZSA9IG5vblB1YmxpY2x5U2hhcmVhYmxlVHlwZXMuaW5jbHVkZXModHlwZSk7XG4gIHJldHVybiBoYXNOb25TaGFyZWFibGVLZXl3b3JkIHx8IGlzT25saW5lRHluYW1pY0ltYWdlcnlTZXJ2aWNlIHx8IGlzTm9uU2hhcmVhYmxlVHlwZTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tlZEZyb21EZXZlbG9wZXJTaGFyaW5nVG9QdWJsaWMoaXRlbSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGlzSG9zdGVkID0gKF9hID0gaXRlbS50eXBlS2V5d29yZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcIkhvc3RlZCBTZXJ2aWNlXCIpO1xuICBjb25zdCBibGFja0xpc3RUeXBlcyA9IFtcbiAgICBcIlZlY3RvciBUaWxlIFNlcnZpY2VcIixcbiAgICBcIk1hcCBTZXJ2aWNlXCIsXG4gICAgXCJTY2VuZSBTZXJ2aWNlXCIsXG4gICAgXCJGZWF0dXJlIFNlcnZpY2VcIlxuICBdO1xuICByZXR1cm4gYmxhY2tMaXN0VHlwZXMuaW5jbHVkZXMoaXRlbS50eXBlKSAmJiBpc0hvc3RlZDtcbn1cbmNvbnN0IG5vblB1YmxpY2x5U2hhcmVhYmxlS2V5d29yZHMgPSBbXG4gIFwiTG9jYXRpb24gVHJhY2tpbmcgU2VydmljZVwiLFxuICBcIkxvY2F0aW9uIFRyYWNraW5nIFZpZXdcIixcbiAgXCJJb1RGZWVkXCIsXG4gIFwiSW9URmVhdHVyZUxheWVyXCIsXG4gIFwiSW9UTWFwSW1hZ2VMYXllclwiLFxuICBcIklvVFN0cmVhbUxheWVyXCIsXG4gIFwiQWRtaW5pc3RyYXRpdmUgUmVwb3J0XCIsXG4gIFwiRWRpdEV4dGVuc2lvbkluZG9vcnNTcGFjZXNcIixcbiAgXCJBcmNnaXNXb3JrZmxvd0pvYkxvY2F0aW9uXCJcbl07XG5jb25zdCBub25QdWJsaWNseVNoYXJlYWJsZVR5cGVzID0gW1wiS25vd2xlZGdlIEdyYXBoXCIsIFwiUHJvIFByb2plY3RcIl07XG5cbi8vICogLS0tIERlcGVuZGVudCBpdGVtIGxheWVyc1xuY29uc3QgZ2V0RGVwZW5kZW50SXRlbUxheWVycyA9IGFzeW5jIChtYWluSXRlbSwgcG9ydGFsKSA9PiB7XG4gIGNvbnN0IGlkID0gbWFpbkl0ZW0uaWQ7XG4gIGxldCBnZXREYXRhRXJyb3I7XG4gIGxldCBpdGVtc0FuZExheWVycyA9IHsgaXRlbXM6IFtdLCBsYXllcnM6IFtdIH07XG4gIHN3aXRjaCAobWFpbkl0ZW0udHlwZSkge1xuICAgIGNhc2UgXCJHcm91cCBMYXllclwiOlxuICAgICAgKHsgcmVzdWx0OiBpdGVtc0FuZExheWVycywgZXJyb3I6IGdldERhdGFFcnJvciB9ID0gYXdhaXQgZ2V0R3JvdXBMYXllckRlcGVuZGVudEl0ZW1MYXllcnMoaWQsIHBvcnRhbCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIldlYiBNYXBcIjpcbiAgICBjYXNlIFwiV2ViIFNjZW5lXCI6XG4gICAgICAoeyByZXN1bHQ6IGl0ZW1zQW5kTGF5ZXJzLCBlcnJvcjogZ2V0RGF0YUVycm9yIH0gPSBhd2FpdCBnZXRXZWJNYXBEZXBlbmRlbnRJdGVtTGF5ZXJzKGlkLCBwb3J0YWwpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJXZWIgTWFwcGluZyBBcHBsaWNhdGlvblwiOlxuICAgICAgKHsgcmVzdWx0OiBpdGVtc0FuZExheWVycywgZXJyb3I6IGdldERhdGFFcnJvciB9ID0gYXdhaXQgZ2V0V2ViQXBwRGVwZW5kZW50SXRlbUxheWVycyhpZCwgcG9ydGFsKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiV2ViIEV4cGVyaWVuY2VcIjpcbiAgICBjYXNlIFwiV2ViIEV4cGVyaWVuY2UgVGVtcGxhdGVcIjpcbiAgICAgICh7IHJlc3VsdDogaXRlbXNBbmRMYXllcnMsIGVycm9yOiBnZXREYXRhRXJyb3IgfSA9IGF3YWl0IGdldFdlYkV4cGVyaWVuY2VEZXBlbmRlbnRJdGVtTGF5ZXJzKGlkLCBtYWluSXRlbS50eXBlS2V5d29yZHMsIHBvcnRhbCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkJpZyBEYXRhIEZpbGUgU2hhcmVcIjpcbiAgICBjYXNlIFwiRGF0YSBTdG9yZVwiOlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiB7IHJlc3VsdDogaXRlbXNBbmRMYXllcnMsIGVycm9yOiBnZXREYXRhRXJyb3IgfTtcbn07XG4vLyAqIC0tLSBHcm91cCBsYXllclxuY29uc3QgZ2V0R3JvdXBMYXllckRlcGVuZGVudEl0ZW1MYXllcnMgPSBhc3luYyAoaXRlbUlkLCBwb3J0YWwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpdGVtRGF0YSA9IGF3YWl0IGdldEl0ZW1EYXRhKGl0ZW1JZCwgcG9ydGFsKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGF5ZXJzOiBbT2JqZWN0LmFzc2lnbih7fSwgaXRlbURhdGEpXVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVE9ETzogaGFuZGxlIG1vcmUgZXJyb3JcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICB9XG59O1xuLy8gKiAtLS0gV2ViIG1hcFxuY29uc3QgZ2V0V2ViTWFwRGVwZW5kZW50SXRlbUxheWVycyA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICB0cnkge1xuICAgIGNvbnN0IGl0ZW1EYXRhID0gYXdhaXQgZ2V0SXRlbURhdGEoaXRlbUlkLCBwb3J0YWwpO1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uYWxMYXllcnMsIGJhc2VNYXAsIHRhYmxlcywgZ3JvdW5kIH0gPSBpdGVtRGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGF5ZXJzOiBbXG4gICAgICAgICAgLi4uKG9wZXJhdGlvbmFsTGF5ZXJzICE9PSBudWxsICYmIG9wZXJhdGlvbmFsTGF5ZXJzICE9PSB2b2lkIDAgPyBvcGVyYXRpb25hbExheWVycyA6IFtdKSxcbiAgICAgICAgICAuLi4oKF9hID0gYmFzZU1hcCA9PT0gbnVsbCB8fCBiYXNlTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiYXNlTWFwLmJhc2VNYXBMYXllcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSxcbiAgICAgICAgICAuLi4oKF9iID0gZ3JvdW5kID09PSBudWxsIHx8IGdyb3VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdW5kLmxheWVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pLFxuICAgICAgICAgIC4uLih0YWJsZXMgIT09IG51bGwgJiYgdGFibGVzICE9PSB2b2lkIDAgPyB0YWJsZXMgOiBbXSlcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVE9ETzogaGFuZGxlIG1vcmUgZXJyb3JcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICB9XG59O1xuLy8gKiAtLS0gV2ViIGFwcFxuY29uc3QgZ2V0V2ViQXBwRGVwZW5kZW50SXRlbUxheWVycyA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGl0ZW1EYXRhID0gYXdhaXQgZ2V0SXRlbURhdGEoaXRlbUlkLCBwb3J0YWwpO1xuICAgIGlmICghaXRlbURhdGEpIHtcbiAgICAgIHJldHVybiB7IHJlc3VsdDogeyBpdGVtczogW10sIGxheWVyczogW10gfSB9O1xuICAgIH1cbiAgICBjb25zdCB3ZWJBcHBNYXBMaXN0ID0gZ2V0V2ViQXBwTWFwTGlzdChpdGVtRGF0YSk7XG4gICAgY29uc3QgZGVwZW5kZW50SXRlbXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwod2ViQXBwTWFwTGlzdC5tYXAoKGl0ZW1JZCkgPT4gZ2V0SHlkcmF0ZWRJdGVtKGl0ZW1JZCwgcG9ydGFsKSkpKVxuICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yc1xuICAgICAgLm1hcCgoeyByZXN1bHQgfSkgPT4gcmVzdWx0KVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSk7XG4gICAgY29uc3QgZGVwZW5kZW50SXRlbUxheWVycyA9IGF3YWl0IFByb21pc2UuYWxsKGRlcGVuZGVudEl0ZW1zLm1hcCgoaXRlbSkgPT4gZ2V0RGVwZW5kZW50SXRlbUxheWVycyhpdGVtLCBwb3J0YWwpKSk7XG4gICAgY29uc3QgeyBpdGVtcywgbGF5ZXJzIH0gPSBmbGF0dGVuRGVwZW5kZW50SXRlbXNBbmRMYXllclJlc3BvbnNlKGRlcGVuZGVudEl0ZW1MYXllcnNcbiAgICAgIC5tYXAoKHsgcmVzdWx0IH0pID0+IHJlc3VsdClcbiAgICAgIC5mbGF0KClcbiAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFdlYiBtYXAgYXBwbGljYXRpb24gZG9lc24ndCBoYXZlIGFueSBsYXllcnMgc28gd2Ugb25seSByZXR1cm4gdGhlIGxheWVycyBmcm9tIGRlcCBpdGVtc1xuICAgICAgcmVzdWx0OiB7IGl0ZW1zOiBbLi4uZGVwZW5kZW50SXRlbXMsIC4uLml0ZW1zXSwgbGF5ZXJzIH1cbiAgICB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIC8vIFRPRE86IGhhbmRsZSBtb3JlIGVycm9yXG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgfVxufTtcbmNvbnN0IGdldFdlYkFwcE1hcExpc3QgPSAoYXBwRGF0YSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gIGNvbnN0IGl0ZW1zID0gKChfYSA9IGFwcERhdGEgPT09IG51bGwgfHwgYXBwRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwRGF0YS5tYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pdGVtSWQpID8gW2FwcERhdGEubWFwLml0ZW1JZF0gOiBbXTtcbiAgY29uc3QgcG9ydGZvbGlvQ29sbGVjdGlvbiA9IChfZCA9IChfYyA9IChfYiA9IGFwcERhdGEudmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXRlbUNvbGxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAoKGVsKSA9PiBlbC5pZCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdO1xuICBjb25zdCBtYXBzID0gKF9nID0gKF9mID0gKF9lID0gYXBwRGF0YS52YWx1ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS53ZWJtYXApID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zcGxpdChcIixcIikpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdO1xuICBjb25zdCBzY2VuZXMgPSAoX2sgPSAoX2ogPSAoX2ggPSBhcHBEYXRhLnZhbHVlcykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLndlYnNjZW5lKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouc3BsaXQoXCIsXCIpKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBbXTtcbiAgcmV0dXJuIFsuLi5pdGVtcywgLi4ucG9ydGZvbGlvQ29sbGVjdGlvbiwgLi4ubWFwcywgLi4uc2NlbmVzXTtcbn07XG4vLyAqIC0tLSBXZWIgZXhwZXJpZW5jZVxuY29uc3QgZ2V0V2ViRXhwZXJpZW5jZURlcGVuZGVudEl0ZW1MYXllcnMgPSBhc3luYyAoaXRlbUlkLCB0eXBlS2V5d29yZHMsIHBvcnRhbCkgPT4ge1xuICBjb25zdCBkcmFmdFVybCA9IGAke2dldEl0ZW1VcmwoaXRlbUlkLCBwb3J0YWwpfS9yZXNvdXJjZXMvY29uZmlnL2NvbmZpZy5qc29uYDtcbiAgY29uc3QgaXRlbURhdGFVcmwgPSBnZXRJdGVtRGF0YVVybChpdGVtSWQsIHBvcnRhbCk7XG4gIGNvbnN0IGRhdGFVcmxzID0gW107XG4gIGlmICh0eXBlS2V5d29yZHMuaW5jbHVkZXMoXCJzdGF0dXM6IERyYWZ0XCIpKSB7XG4gICAgZGF0YVVybHMucHVzaChkcmFmdFVybCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZUtleXdvcmRzLmluY2x1ZGVzKFwic3RhdHVzOiBDaGFuZ2VkXCIpKSB7XG4gICAgZGF0YVVybHMucHVzaChkcmFmdFVybCwgaXRlbURhdGFVcmwpO1xuICB9XG4gIGVsc2Uge1xuICAgIGRhdGFVcmxzLnB1c2goaXRlbURhdGFVcmwpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYWxsSXRlbXMgPSBbXTtcbiAgICBjb25zdCBhbGxEZXBlbmRlbnRJdGVtcyA9IFtdO1xuICAgIGNvbnN0IGFsbExheWVycyA9IFtdO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGRhdGFVcmxzLm1hcChhc3luYyAoZGF0YVVybCkgPT4ge1xuICAgICAgY29uc3QgaXRlbURhdGEgPSBhd2FpdCByZXF1ZXN0RmV0Y2goZGF0YVVybCwgcG9ydGFsKTtcbiAgICAgIGlmICghKGl0ZW1EYXRhID09PSBudWxsIHx8IGl0ZW1EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtRGF0YS5kYXRhU291cmNlcykgJiYgIShpdGVtRGF0YSA9PT0gbnVsbCB8fCBpdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbURhdGEudXRpbGl0aWVzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkZXBlbmRlbnRJdGVtcyA9IChhd2FpdCBQcm9taXNlLmFsbChnZXRXZWJFeHBlcmllbmNlRGVwZW5kZW5jeUlkTGlzdChpdGVtRGF0YSkubWFwKChpdGVtSWQpID0+IGdldEh5ZHJhdGVkSXRlbShpdGVtSWQsIHBvcnRhbCkpKSkgLy8gVE9ETzogaGFuZGxlIGVycm9yc1xuICAgICAgICAubWFwKCh7IHJlc3VsdCB9KSA9PiByZXN1bHQpXG4gICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0pO1xuICAgICAgY29uc3QgZGVwZW5kZW50SXRlbUxheWVycyA9IGF3YWl0IFByb21pc2UuYWxsKGRlcGVuZGVudEl0ZW1zLm1hcCgoaXRlbSkgPT4gZ2V0RGVwZW5kZW50SXRlbUxheWVycyhpdGVtLCBwb3J0YWwpKSk7XG4gICAgICBjb25zdCB7IGl0ZW1zLCBsYXllcnMgfSA9IGZsYXR0ZW5EZXBlbmRlbnRJdGVtc0FuZExheWVyUmVzcG9uc2UoZGVwZW5kZW50SXRlbUxheWVycy5mbGF0TWFwKCh7IHJlc3VsdCB9KSA9PiByZXN1bHQpLmZpbHRlcigobGF5ZXIpID0+IGxheWVyKSk7XG4gICAgICBhbGxMYXllcnMucHVzaCguLi5sYXllcnMpO1xuICAgICAgYWxsSXRlbXMucHVzaCguLi5pdGVtcyk7XG4gICAgICBhbGxEZXBlbmRlbnRJdGVtcy5wdXNoKC4uLmRlcGVuZGVudEl0ZW1zKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFdlYiBleHBlcmllbmNlIGRvZXNuJ3QgaGF2ZSBhbnkgbGF5ZXJzIHNvIHdlIG9ubHkgcmV0dXJuIHRoZSBsYXllcnMgZnJvbSBkZXAgaXRlbXNcbiAgICAgIHJlc3VsdDogeyBpdGVtczogWy4uLmFsbERlcGVuZGVudEl0ZW1zLCAuLi5hbGxJdGVtc10sIGxheWVyczogYWxsTGF5ZXJzIH1cbiAgICB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIC8vIFRPRE86IGhhbmRsZSBtb3JlIGVycm9yXG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFdlYkV4cGVyaWVuY2VEZXBlbmRlbmN5SWRMaXN0KGRhdGEpIHtcbiAgY29uc3QgZGF0YVNvdXJjZXMgPSBkYXRhLmRhdGFTb3VyY2VzIHx8IHt9O1xuICBjb25zdCB1dGlsaXRpZXMgPSBkYXRhLnV0aWxpdGllcyB8fCB7fTtcbiAgY29uc3QgYWxsRGVwcyA9IFsuLi5PYmplY3QudmFsdWVzKGRhdGFTb3VyY2VzKSwgLi4uT2JqZWN0LnZhbHVlcyh1dGlsaXRpZXMpXTtcbiAgcmV0dXJuIGFsbERlcHMubWFwKChkZXApID0+IGRlcC5pdGVtSWQpLmZpbHRlcigoaWQpID0+IGlkKTtcbn1cbmNvbnN0IGZsYXR0ZW5EZXBlbmRlbnRJdGVtc0FuZExheWVyUmVzcG9uc2UgPSAocmVzcG9uc2VzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaXRlbXM6IHJlc3BvbnNlcy5mbGF0TWFwKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuaXRlbXMpLFxuICAgIGxheWVyczogcmVzcG9uc2VzLmZsYXRNYXAoKHJlc3BvbnNlKSA9PiByZXNwb25zZS5sYXllcnMpXG4gIH07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZ3JvdXBzIHRoYXQgYSBsYXllciBpcyBzaGFyZWQgd2l0aFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMYXllclNoYXJlZEdyb3VwcyhsYXllcklkLCBwb3J0YWwsIGluY2x1ZGVGYXZvcml0ZUdyb3VwcyA9IGZhbHNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGdldEl0ZW1Hcm91cHMobGF5ZXJJZCwgcG9ydGFsKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBbLi4ucmVzdWx0LmFkbWluLCAuLi5yZXN1bHQubWVtYmVyLCAuLi5yZXN1bHQub3RoZXJdXG4gICAgICAgIC5maWx0ZXIoKGdyb3VwKSA9PiBpbmNsdWRlRmF2b3JpdGVHcm91cHMgfHwgIWdyb3VwLmlzRmF2KVxuICAgICAgICAubWFwKChncm91cCkgPT4gZ3JvdXAuaWQpXG4gICAgfTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICB9XG59XG5cbmNvbnN0IGlzV2ViTWFwVGFibGUgPSAobGF5ZXIpID0+IFxuLy8gISBUaGlzIGlzIGp1c3QgYSB3b3JrYXJvdW5kIGZvciBub3cgYnV0IGl0J3Mgbm90IGNvbXBsZXRlbHkgc2FmZSBzaW5jZSB0aGVyZSBpcyBubyBkaXNjcmltaW5hdG9yXG4hKFwibGF5ZXJUeXBlXCIgaW4gbGF5ZXIpICYmIGxheWVyLnVybCAmJiBsYXllci5wb3B1cEluZm87XG5jb25zdCBpc1N1cHBvcnRlZExheWVyVHlwZUZvclVybENoZWNrID0gKGxheWVyKSA9PiB7XG4gIGNvbnN0IHZhbGlkVHlwZXMgPSBbXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwiQXJjR0lTRmVhdHVyZUxheWVyXCIsXG4gICAgXCJBcmNHSVNUaWxlZE1hcFNlcnZpY2VMYXllclwiLFxuICAgIFwiVmVjdG9yVGlsZUxheWVyXCIsXG4gICAgXCJHcm91cExheWVyXCIsXG4gICAgXCJBcmNHSVNJbWFnZVNlcnZpY2VMYXllclwiLFxuICAgIFwiQXJjR0lTVGlsZWRJbWFnZVNlcnZpY2VMYXllclwiLFxuICAgIFwiU3VidHlwZUdyb3VwTGF5ZXJcIixcbiAgICBcIkFyY0dJU1N0cmVhbUxheWVyXCIsXG4gICAgXCJNZWRpYUxheWVyXCJcbiAgXTtcbiAgcmV0dXJuIHZhbGlkVHlwZXMuaW5jbHVkZXMobGF5ZXIubGF5ZXJUeXBlKTtcbn07XG5jb25zdCBpc1RpbGVMYXllciA9IChsYXllcikgPT4gbGF5ZXIubGF5ZXJUeXBlID09PSBcIkFyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyXCI7XG5jb25zdCBpc1RpbGVPcGVyYXRpb25MYXllcldpdGhQb3B1cCA9IChsYXllcikgPT4gbGF5ZXIubGF5ZXJUeXBlID09PSBcIkFyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyXCIgJiYgXCJsYXllcnNcIiBpbiBsYXllciAmJiBsYXllci5sYXllcnNbMF0uZGlzYWJsZVBvcHVwID09PSBmYWxzZTtcbmNvbnN0IGlzVmVjdG9yVGlsZUxheWVyID0gKGxheWVyKSA9PiBsYXllci5sYXllclR5cGUgPT09IFwiVmVjdG9yVGlsZUxheWVyXCIgJiYgXCJzdHlsZVVybFwiIGluIGxheWVyO1xuY29uc3QgREVGQVVMVF9TSEFSSU5HX0RFVEFJTFMgPSB7XG4gIG5lZWRzR3JvdXBVcGRhdGU6IGZhbHNlLFxuICBuZWVkc1NoYXJlTGV2ZWxVcGRhdGU6IGZhbHNlLFxuICBjYW5FZGl0U2hhcmVMZXZlbDogdHJ1ZSxcbiAgcHJlbWl1bTogZmFsc2Vcbn07XG5cbi8qKlxuICogU2VuZCBhIHJlcXVlc3QgdG8gZ2V0IGRhdGEgZm9yIGB1cmxgLiBUaGlzIHJlcXVlc3Qgd2lsbCBub3QgaW5jbHVkZSBhIHRva2VuIHRvIGF2b2lkIHRva2VuIGxlYWtcbiAqL1xuY29uc3QgZ2V0U2VydmljZVVybFJlc3BvbnNlID0gYXN5bmMgKHVybCwgcG9ydGFsKSA9PiB7XG4gIHZhciBfYTtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IHJlcXVlc3RGZXRjaCh1cmwsIHBvcnRhbCwgeyBhZGRUb2tlbk1hbnVhbGx5OiBmYWxzZSB9KSB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IHRva2VuUmVxdWlyZWRNZXNzYWdlID0gXCJ0b2tlbiByZXF1aXJlZFwiO1xuICAgIGlmICgoX2EgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModG9rZW5SZXF1aXJlZE1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInRva2VuUmVxdWlyZWRcIiB9IH07XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gIH1cbn07XG5cbmNvbnN0IGFjY2Vzc0xldmVsID0ge1xuICBwcml2YXRlOiAwLFxuICBzaGFyZWQ6IDEsXG4gIG9yZzogMixcbiAgcHVibGljOiAzXG59O1xuY29uc3QgaXNBY2Nlc3NMZXZlbEdyZWF0ZXIgPSAobWFpbkFjY2Vzcywgb3RoZXJBY2Nlc3MpID0+IGFjY2Vzc0xldmVsW21haW5BY2Nlc3NdID4gYWNjZXNzTGV2ZWxbb3RoZXJBY2Nlc3NdO1xuLyoqXG4gKiBHaXZlbiBhIFVSTCBhbmQgYSByZWxhdGl2ZSBwYXRoLCByZXR1cm4gdGhlIGZ1bGwgVVJMXG4gKiBlLmc6IGh0dHBzOi8vd3d3LmFyY2dpcy5jb20vc2hhcmluZy9yZXN0L2NvbnRlbnQvaXRlbXMvMTIzNDU2Nzg5MGFiY2RlZmcgYW5kIFwiLi4vLi4vXCIsIHJldHVybiBodHRwczovL3d3dy5hcmNnaXMuY29tL3NoYXJpbmcvcmVzdC9cbiAqXG4gKi9cbmNvbnN0IHRyYXZlcnNlVXJscyA9ICh7IHBhdGgsIHVybCB9KSA9PiB7XG4gIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiL1wiKTtcbiAgY29uc3QgcGF0aFBhcnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGNvbnN0IHVybFBhcnRzVG9LZWVwID0gdXJsUGFydHMuc2xpY2UoMCwgdXJsUGFydHMubGVuZ3RoIC0gcGF0aFBhcnRzLmxlbmd0aCk7XG4gIHJldHVybiB1cmxQYXJ0c1RvS2VlcC5qb2luKFwiL1wiKTtcbn07XG5cbmNvbnN0IGZpbHRlclVybHNGcm9tU2FtZU9yaWdpbiA9IGFzeW5jIChwb3J0YWwsIHVybHNUb0NoZWNrKSA9PiB7XG4gIGNvbnN0IHsgb3duaW5nU3lzdGVtVXJsOiBtYWluSXRlbU93bmluZ1N5c3RlbVVybCB9ID0gYXdhaXQgZnJvbUNhY2hlKGFzeW5jICgpID0+IGdldFBvcnRhbFJlc3RJbmZvKHBvcnRhbCksIFwicG9ydGFsSW5mb1wiLCBwb3J0YWwuaWQpO1xuICBjb25zdCB1cmxPd25pbmdTeXN0ZW1JbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwodXJsc1RvQ2hlY2subWFwKGFzeW5jICh1cmwpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBvd25pbmdTeXN0ZW1VcmwgfSA9IGF3YWl0IGdldFBvcnRhbFJlc3RJbmZvRnJvbVVybCh1cmwpO1xuICAgICAgcmV0dXJuIHsgb3duaW5nU3lzdGVtVXJsLCB1cmwgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IG93bmluZ1N5c3RlbVVybDogbnVsbCwgdXJsIH07XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiAodXJsT3duaW5nU3lzdGVtSW5mb1xuICAgIC8vIFRPRE86IGhhbmRsZSBFbnRlcnByaXNlIGNhc2VcbiAgICAuZmlsdGVyKCh7IG93bmluZ1N5c3RlbVVybCB9KSA9PiBvd25pbmdTeXN0ZW1VcmwgPT09IG1haW5JdGVtT3duaW5nU3lzdGVtVXJsKVxuICAgIC5tYXAoKHsgdXJsIH0pID0+IHVybCkpO1xufTtcblxuLyoqIEdldCB0aGUgc291cmNlIGl0ZW0gZm9yIHRpbGUgbGF5ZXJcbiAqIEBwYXJhbSBsYXllciAtIFRoZSBsYXllciB0byBnZXQgdGhlIHNvdXJjZSBpdGVtIGZvciB3aXRoIGxheWVyIHR5cGUgb2YgQXJjR0lTVGlsZWRNYXBTZXJ2aWNlTGF5ZXJcbiAqL1xuY29uc3QgZ2V0VGlsZUxheWVyU291cmNlSXRlbSA9IGFzeW5jIChsYXllciwgcG9ydGFsKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgaXRlbUlkID0gbGF5ZXIuaXRlbUlkO1xuICAgIGNvbnN0IGl0ZW1EYXRhID0gYXdhaXQgZnJvbUNhY2hlKCgpID0+IGdldEl0ZW1EYXRhKGl0ZW1JZCwgcG9ydGFsKSwgXCJpdGVtRGF0YVwiLCBpdGVtSWQpO1xuICAgIC8vIEN1cnJlbnRseSBhIHRpbGUgbGF5ZXIgY2FuIG9ubHkgYmUgY3JlYXRlZCBmcm9tIGEgc2luZ2xlIGxheWVyIHNvIHdlIGNhbiBqdXN0IHRha2UgdGhlIGZpcnN0IGxheWVyXG4gICAgY29uc3QgeyBsYXllckl0ZW1JZDogc291cmNlSXRlbUlkIH0gPSBpdGVtRGF0YSA9PT0gbnVsbCB8fCBpdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbURhdGEubGF5ZXJzWzBdO1xuICAgIGlmICghc291cmNlSXRlbUlkKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICAgIH1cbiAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEl0ZW0oc291cmNlSXRlbUlkLCBwb3J0YWwpIH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgfVxufTtcbi8qKiBHZXQgc291cmNlIGl0ZW1zIGZvciBpdGVtcyBkdXBsaWNhdGVkIGZyb20gYW5vdGhlciBpdGVtXG4gKlxuICogVGhpcyB3aWxsIGlnbm9yZSBpdGVtcyB0aGF0IGlzIG5vdCBvbiB0aGUgc2FtZSBlbnZpcm9ubWVudCBhcyB0aGUgbWFpbiBpdGVtXG4gKiBvciBpZiBub3QgdXNpbmcgdGhlIHNhbWUgZmVkZXJhdGVkIHNlcnZlciBpZiB3ZSdyZSBpbiBFbnRlcnByaXNlXG4gKlxuICogaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWFwcC1jb21wb25lbnRzL2lzc3Vlcy8zODA5XG4gKi9cbmNvbnN0IGdldFNvdXJjZUl0ZW1zRnJvbVVybHMgPSBhc3luYyAoaXRlbVVybHMsIHBvcnRhbCkgPT4ge1xuICBjb25zdCB2YWxpZFVybEluZm9zID0gaXRlbVVybHMuZmlsdGVyKCh1cmxJbmZvKSA9PiB1cmxJbmZvICYmIGlzU3VwcG9ydGVkTGF5ZXJUeXBlRm9yVXJsQ2hlY2soeyBsYXllclR5cGU6IHVybEluZm8ubGF5ZXJUeXBlIH0pKTtcbiAgY29uc3QgdmFsaWRJdGVtVXJscyA9IGF3YWl0IGZpbHRlck91dERpZmZPcmlnaW5BR1NVcmxzKHZhbGlkVXJsSW5mb3MubWFwKCh1cmxJbmZvKSA9PiB1cmxJbmZvLnVybCksIHBvcnRhbCk7XG4gIC8vIFNvbWUgdXJsIGlzIGEgcm9vdC5qc29uIHVybCBzbyB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggYW5vdGhlciBsYXllciBvZiBnZXRTb3VyY2VJdGVtc0Zyb21VcmxzIHRvIGdldCB0aGUgYWN0dWFsIGl0ZW1cbiAgY29uc3Qgcm9vdEpTT05TZXJ2aWNlVVJMID0gW107XG4gIC8vICogRmlyc3Qgc2VuZCByZXF1ZXN0IHdpdGhvdXQgdG9rZW5cbiAgY29uc3QgcmVxdWlyZWRUb2tlblVybHMgPSBbXTtcbiAgY29uc3Qgbm9Ub2tlbk1ldGFEYXRhID0gW107XG4gIGF3YWl0IFByb21pc2UuYWxsKHZhbGlkSXRlbVVybHMubWFwKGFzeW5jICh1cmwpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IGZyb21DYWNoZSgoKSA9PiBnZXRTZXJ2aWNlVXJsUmVzcG9uc2UodXJsLCBwb3J0YWwpLCBcIml0ZW1NZXRhZGF0YVwiLCBgJHt1cmx9LS1uby10b2tlbmApO1xuICAgIGlmICgoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpID09PSBcInRva2VuUmVxdWlyZWRcIikge1xuICAgICAgcmVxdWlyZWRUb2tlblVybHMucHVzaCh1cmwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNSb290SlNPTlJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJvb3RKU09OU2VydmljZVVSTC5wdXNoKGdldFJvb3RKU09OUmVzcG9uc2VVcmwocmVzdWx0LCB1cmwpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBub1Rva2VuTWV0YURhdGEucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgfSkpO1xuICBjb25zdCBub1Rva2VuU2VydmljZUlkcyA9IG5vVG9rZW5NZXRhRGF0YS5tYXAoKG1ldGFEYXRhKSA9PiBtZXRhRGF0YSA9PT0gbnVsbCB8fCBtZXRhRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YURhdGEuc2VydmljZUl0ZW1JZCk7XG4gIC8vICogRm9yIHVybHMgdGhhdCByZXF1aXJlIHRva2VuLCBjaGVjayBpZiB0aGV5IGFyZSBpbiB0aGUgc2FtZSBvcmlnaW5cbiAgY29uc3Qgc2FtZUhvc3RSZXN0VXJscyA9IGF3YWl0IGZpbHRlclVybHNGcm9tU2FtZU9yaWdpbihwb3J0YWwsIHJlcXVpcmVkVG9rZW5VcmxzKTtcbiAgLy8gSWYgeWVzLCB0aGVuIHdlIGNhbiBqdXN0IGdldCB0aGUgaXRlbSBkZXRhaWxcbiAgY29uc3QgcmVxdWlyZWRUb2tlbk1ldGFEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoc2FtZUhvc3RSZXN0VXJscy5tYXAoYXN5bmMgKHVybCkgPT4gKHtcbiAgICByZXNwb25zZTogYXdhaXQgcmVxdWVzdEZldGNoKHVybCwgcG9ydGFsLCB7IGFkZFRva2VuTWFudWFsbHk6IHRydWUgfSksXG4gICAgdXJsIC8vIFdlIG5lZWQgdGhpcyBmb3Igcm9vdCBqc29uIHVybFxuICB9KSkpO1xuICBjb25zdCByZXF1aXJlZFRva2VuU2VydmljZUlkcyA9IHJlcXVpcmVkVG9rZW5NZXRhRGF0YS5yZWR1Y2UoKGlkTGlzdCwgeyByZXNwb25zZSwgdXJsIH0pID0+IHtcbiAgICBpZiAoaXNSb290SlNPTlJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgcm9vdEpTT05TZXJ2aWNlVVJMLnB1c2goZ2V0Um9vdEpTT05SZXNwb25zZVVybChyZXNwb25zZSwgdXJsKSk7XG4gICAgICByZXR1cm4gaWRMaXN0O1xuICAgIH1cbiAgICByZXR1cm4gWy4uLmlkTGlzdCwgcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnNlcnZpY2VJdGVtSWRdO1xuICB9LCBbXSk7XG4gIC8vICogVGhlbiBqdXN0IGdldCB0aGUgaXRlbSBkZXRhaWxcbiAgY29uc3QgcmV0dXJuSXRlbXMgPSBhd2FpdCBQcm9taXNlLmFsbChbLi4ubm9Ub2tlblNlcnZpY2VJZHMsIC4uLnJlcXVpcmVkVG9rZW5TZXJ2aWNlSWRzXS5tYXAoYXN5bmMgKHNlcnZpY2VJdGVtSWQpID0+IHNlcnZpY2VJdGVtSWQgPyBnZXRJdGVtKHNlcnZpY2VJdGVtSWQsIHBvcnRhbCkgOiBudWxsKSk7XG4gIC8vIFdlIHJlcGVhdCB0aGUgc2FtZSBwcm9jZXNzIHRvIGdldCB0aGUgYWN0dWFsIGBzZXJ2aWNlSXRlbUlkYCB0aGVuIHRoZSBpdGVtIHZpYSB0aGUgcm9vdCBqc29uIFVSTFxuICBjb25zdCByb290SlNPTkl0ZW1zID0gcm9vdEpTT05TZXJ2aWNlVVJMLmxlbmd0aCA8PSAwXG4gICAgPyBbXVxuICAgIDogYXdhaXQgZ2V0U291cmNlSXRlbXNGcm9tVXJscyhyb290SlNPTlNlcnZpY2VVUkwubWFwKCh1cmwpID0+ICh7IHVybCwgbGF5ZXJUeXBlOiBcIlZlY3RvclRpbGVMYXllclwiIH0pKSwgcG9ydGFsKTtcbiAgcmV0dXJuIFsuLi5yZXR1cm5JdGVtcy5maWx0ZXIoKGl0ZW0pID0+ICEhaXRlbSksIC4uLnJvb3RKU09OSXRlbXNdO1xufTtcbmNvbnN0IGlzUm9vdEpTT05SZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICByZXR1cm4gISEocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnNvdXJjZXMpO1xufTtcbmNvbnN0IGdldFJvb3RKU09OUmVzcG9uc2VVcmwgPSAocmVzcG9uc2UsIHVybCkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc3BvbnNlVXJsID0gKF9hID0gT2JqZWN0LnZhbHVlcyhyZXNwb25zZS5zb3VyY2VzKVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVybDtcbiAgaWYgKCFyZXNwb25zZVVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiByZXNwb25zZVVybC5pbmNsdWRlcyhcIi4uXCIpID8gdHJhdmVyc2VVcmxzKHsgdXJsLCBwYXRoOiByZXNwb25zZVVybCB9KSA6IHJlc3BvbnNlVXJsO1xufTtcbmNvbnN0IGZpbHRlck91dERpZmZPcmlnaW5BR1NVcmxzID0gYXN5bmMgKHVybHMsIHBvcnRhbCkgPT4ge1xuICBjb25zdCB2YWxpZEFnc1VSTCA9IHVybHMuZmlsdGVyKCh1cmwpID0+ICEhdXJsICYmICEhcGFyc2VBR1NTZXJ2ZXJJbmZvKHVybCkpO1xuICAvLyBUT0RPIFIzOiB3ZSdsbCBmaW5lLWdyYWluIGNoZWNraW5nIHRoaXMgbGF0ZXIgYW5kIG9uY2UgaXRlbXMgaGF2ZSBiZXR0ZXIgc3BlY1xuICBjb25zdCBub25BR1NVcmxzID0gdXJscy5maWx0ZXIoKHVybCkgPT4gIXVybCB8fCAhcGFyc2VBR1NTZXJ2ZXJJbmZvKHVybCkpO1xuICBjb25zdCBzYW1lT3JpZ2luVXJscyA9IGF3YWl0IGZpbHRlclVybHNGcm9tU2FtZU9yaWdpbihwb3J0YWwsIHZhbGlkQWdzVVJMKTtcbiAgcmV0dXJuIFsuLi5zYW1lT3JpZ2luVXJscywgLi4ubm9uQUdTVXJsc107XG59O1xuXG5jb25zdCBnZXRTb3VyY2VJdGVtc0Zyb21EZXBlbmRlbnRMYXllcnMgPSBhc3luYyAoZGVwZW5kZW50TGF5ZXJzLCBwb3J0YWwpID0+IHtcbiAgLy8gKiBSZWN1cnNpdmVseSBmbGF0dGVuIGxheWVycywgZm9jdXNpbmcgb24gR3JvdXBMYXllclxuICBjb25zdCBmbGF0dGVuZWRMYXllcnMgPSBbXTtcbiAgY29uc3QgYW5hbHl6ZUxheWVyID0gKGxheWVyKSA9PiB7XG4gICAgaWYgKGlzV2ViTWFwVGFibGUobGF5ZXIpKSB7XG4gICAgICBmbGF0dGVuZWRMYXllcnMucHVzaCh7XG4gICAgICAgIGlkOiBsYXllci5pZCxcbiAgICAgICAgdXJsOiBsYXllci51cmwsXG4gICAgICAgIGxheWVyVHlwZTogXCJ0YWJsZVwiLFxuICAgICAgICBnZXRUeXBlOiBcIm5vcm1hbFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxheWVyLmxheWVyVHlwZSA9PT0gXCJHcm91cExheWVyXCIpIHtcbiAgICAgIGlmIChsYXllci5pdGVtSWQpIHtcbiAgICAgICAgLy8gQSBHcm91cExheWVyIGl0ZW1cbiAgICAgICAgZmxhdHRlbmVkTGF5ZXJzLnB1c2goe1xuICAgICAgICAgIGlkOiBsYXllci5pZCxcbiAgICAgICAgICBpdGVtSWQ6IGxheWVyLml0ZW1JZCxcbiAgICAgICAgICBsYXllclR5cGU6IFwiR3JvdXBMYXllclwiLFxuICAgICAgICAgIGdldFR5cGU6IFwibm9ybWFsXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXllci5sYXllcnMuZm9yRWFjaCgoc3ViTGF5ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzV2ViTWFwVGFibGUoc3ViTGF5ZXIpIHx8IHN1YkxheWVyLmxheWVyVHlwZSA9PT0gXCJHcm91cExheWVyXCIpIHtcbiAgICAgICAgICBhbmFseXplTGF5ZXIoc3ViTGF5ZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJMYXllclVybCA9IHN1YkxheWVyLnVybDtcbiAgICAgICAgaWYgKCFzdWJMYXllclVybCkge1xuICAgICAgICAgIGFuYWx5emVMYXllcihzdWJMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlVXJsSW5mbyA9IHBhcnNlQUdTU2VydmVySW5mbyhzdWJMYXllclVybCk7XG4gICAgICAgIGFuYWx5emVMYXllcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN1YkxheWVyKSwgeyBcbiAgICAgICAgICAvLyBJZiBhIGxheWVyIGluIEdyb3VwTGF5ZXIgaGFzIGluZGV4IGluIHRoZWlyIFVSTCwgd2UnbGwgd2FudCB0byBzdHJpcCB0aGVtIG91dCBmaXJzdFxuICAgICAgICAgIC8vIFRoaXMgbWlnaHQgY3JlYXRlIHNvbWUgZHVwbGljYXRlZCBVUkxzIGJ1dCB3ZSBhbHJlYWR5IGZpbHRlciB0aGVtIG91dCBiZWxvdyB2aWEgdGhlIGBsYXllckl0ZW1JZExvb2t1cE1hcGBcbiAgICAgICAgICB1cmw6IChwYXJzZVVybEluZm8gPT09IG51bGwgfHwgcGFyc2VVcmxJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZVVybEluZm8uaW5kZXgpICE9IG51bGwgPyBwYXJzZVVybEluZm8uYmFzZVNlcnZlclVybCA6IHN1YkxheWVyLnVybCB9KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzVmVjdG9yVGlsZUxheWVyKGxheWVyKSkge1xuICAgICAgZmxhdHRlbmVkTGF5ZXJzLnB1c2goe1xuICAgICAgICBpZDogbGF5ZXIuaWQsXG4gICAgICAgIHVybDogbGF5ZXIuc3R5bGVVcmwsXG4gICAgICAgIGl0ZW1JZDogbGF5ZXIuaXRlbUlkLFxuICAgICAgICBsYXllclR5cGU6IGxheWVyLmxheWVyVHlwZSxcbiAgICAgICAgZ2V0VHlwZTogXCJub3JtYWxcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIG5lZWQgdG8gYWxzbyBmZXRjaCB0aGUgb3JpZ2luYWwgaXRlbSB0aGlzIHRpbGUgbGF5ZXIgaXMgY3JlYXRlZCBmcm9tXG4gICAgaWYgKGlzVGlsZUxheWVyKGxheWVyKSkge1xuICAgICAgLy8gSWYgdGhlIHRpbGUgbGF5ZXIgaGFzIHBvcHVwIGVuYWJsZWQsIHdlIGNhbiBqdXN0IHRha2UgdGhlIGxheWVyIGRpcmVjdGx5XG4gICAgICAvLyAgd2hpY2ggaXMgc2ltcGx5IHZpYSBsYXllcnNbMF0ncyBgbGF5ZXJJdGVtSWRgXG4gICAgICAvLyAgaWYgbm90LCB3ZSdsbCBoYXZlIHRvIGdvIGludG8gL2RhdGEgYW5kIGdldCB0aGUgYGxheWVySXRlbUlkYCBmaXJzdCBmcm9tIHRoZXJlXG4gICAgICBjb25zdCBpc1RpbGVMYXllcldpdGhQb3B1cCA9IGlzVGlsZU9wZXJhdGlvbkxheWVyV2l0aFBvcHVwKGxheWVyKTtcbiAgICAgIGlmIChpc1RpbGVMYXllcldpdGhQb3B1cCkge1xuICAgICAgICBjb25zdCBmaXJzdFN1YkxheWVyID0gbGF5ZXIubGF5ZXJzWzBdO1xuICAgICAgICBmbGF0dGVuZWRMYXllcnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGZpcnN0U3ViTGF5ZXIuaWQsXG4gICAgICAgICAgdXJsOiBmaXJzdFN1YkxheWVyLmxheWVyVXJsLFxuICAgICAgICAgIGdldFR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgbGF5ZXJUeXBlOiBsYXllci5sYXllclR5cGUsXG4gICAgICAgICAgaXRlbUlkOiBmaXJzdFN1YkxheWVyLmxheWVySXRlbUlkXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAhIFdlIGFsc28gd2FudCB0byBjaGVjayBmb3IgdGhlIHRpbGUgbGF5ZXIgc2hhcmluZyBtaXNtYXRjaCBzbyB0aGVyZSBpcyBubyByZXR1cm4gaGVyZVxuICAgICAgfVxuICAgICAgZmxhdHRlbmVkTGF5ZXJzLnB1c2goe1xuICAgICAgICBpZDogbGF5ZXIuaWQsXG4gICAgICAgIGdldFR5cGU6IGlzVGlsZUxheWVyV2l0aFBvcHVwID8gXCJub3JtYWxcIiA6IFwidGlsZS1sYXllci13aXRoLW5vLXBvcHVwXCIsXG4gICAgICAgIGl0ZW1JZDogbGF5ZXIuaXRlbUlkLFxuICAgICAgICBsYXllclR5cGU6IGxheWVyLmxheWVyVHlwZSxcbiAgICAgICAgdXJsOiBsYXllci51cmxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGF5ZXIuaXRlbUlkIHx8IGxheWVyLnVybCkge1xuICAgICAgZmxhdHRlbmVkTGF5ZXJzLnB1c2goe1xuICAgICAgICBpZDogbGF5ZXIuaWQsXG4gICAgICAgIHVybDogbGF5ZXIudXJsLFxuICAgICAgICBpdGVtSWQ6IGxheWVyLml0ZW1JZCxcbiAgICAgICAgbGF5ZXJUeXBlOiBsYXllci5sYXllclR5cGUsXG4gICAgICAgIGdldFR5cGU6IFwibm9ybWFsXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZGVwZW5kZW50TGF5ZXJzLmZvckVhY2goYW5hbHl6ZUxheWVyKTtcbiAgY29uc3QgbGF5ZXJJdGVtSWRMb29rdXBNYXAgPSBhcnJheVRvTG9va3VwTWFwKGZsYXR0ZW5lZExheWVycywgKGxheWVyKSA9PiB7XG4gICAgaWYgKGxheWVyLml0ZW1JZCkge1xuICAgICAgcmV0dXJuIHsga2V5OiBsYXllci5pdGVtSWQsIGRhdGE6IHsgc2VhcmNoVHlwZTogXCJpdGVtLWlkXCIsIGxheWVyVHlwZTogbGF5ZXIubGF5ZXJUeXBlIH0gfTtcbiAgICB9XG4gICAgLy8gTGF5ZXIgZnJvbSBzaGFsbG93IGNvcGllZCBvciBkdXBsaWNhdGVkIGl0ZW1zXG4gICAgLy8gSG93ZXZlciwgaWYgbGF5ZXIgZG9lc24ndCBoYXZlIGJvdGggYGl0ZW1JZGAgYW5kIGB1cmxgLCB3ZSdsbCBqdXN0IGhhdmUgdGhlIGtleSBhcyBgbnVsbGAgYW5kIGlnbm9yZSB0aGVtIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBnZXQgdGhlIHNvdXJjZSBpdGVtXG4gICAgcmV0dXJuIHsga2V5OiBsYXllci51cmwsIGRhdGE6IHsgc2VhcmNoVHlwZTogXCJ1cmxcIiwgbGF5ZXJUeXBlOiBsYXllci5sYXllclR5cGUgfSB9O1xuICB9KTtcbiAgY29uc3QgdW5pcXVlSWRzID0gT2JqZWN0LmtleXMobGF5ZXJJdGVtSWRMb29rdXBNYXApLmZpbHRlcigoaWQpID0+IGxheWVySXRlbUlkTG9va3VwTWFwW2lkXS5zZWFyY2hUeXBlID09PSBcIml0ZW0taWRcIik7XG4gIHRyeSB7XG4gICAgLy8gKiAtLS0gSGFuZGxlIGdldHRpbmcgc291cmNlIGl0ZW1cbiAgICBjb25zdCBpdGVtc0Zyb21JZHMgPSAoYXdhaXQgUHJvbWlzZS5hbGwodW5pcXVlSWRzLm1hcCgoaWQpID0+IGdldEl0ZW0oaWQsIHBvcnRhbCkpKSkuZmlsdGVyKChpdGVtSW5mbykgPT4gISFpdGVtSW5mbyk7XG4gICAgLy8gSGFuZGxlIHRpbGUgbGF5ZXIgc291cmNlIGl0ZW0gaWYgdGhlIHRpbGUgbGF5ZXIgZG9lc24ndCBoYXZlIHBvcHVwIGVuYWJsZWRcbiAgICBjb25zdCBkZXBlbmRlbnRUaWxlTGF5ZXJzID0gZmxhdHRlbmVkTGF5ZXJzLmZpbHRlcigoeyBnZXRUeXBlOiB0eXBlLCBpdGVtSWQgfSkgPT4gdHlwZSA9PT0gXCJ0aWxlLWxheWVyLXdpdGgtbm8tcG9wdXBcIiAmJiAhIWl0ZW1JZCk7XG4gICAgY29uc3QgdGlsZUxheWVyU291cmNlSXRlbXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoZGVwZW5kZW50VGlsZUxheWVycy5tYXAoKGxheWVyKSA9PiBnZXRUaWxlTGF5ZXJTb3VyY2VJdGVtKGxheWVyLCBwb3J0YWwpKSkpLm1hcCgoeyByZXN1bHQgfSkgPT4gcmVzdWx0KTtcbiAgICAvLyBIYW5kbGUgaXRlbSBkdXBsaWNhdGVkIGZyb20gYW5vdGhlciBpdGVtIC0tLSBjdXJyZW50bHkgYWxzbyBoYW5kbGUgdmVjdG9yIHRpbGUgbGF5ZXJcbiAgICAvLyAgYmVjYXVzZSBpc0hvc3RlZFNlcnZpY2UgZG9lc24ndCBjb3VudCB2ZWN0b3IgdGlsZSBsYXllciBhcyBob3N0ZWQgc2VydmljZVxuICAgIGNvbnN0IG5vbkhvc3RlZEl0ZW1zID0gaXRlbXNGcm9tSWRzLmZpbHRlcigoaXRlbSkgPT4gIWlzSG9zdGVkU2VydmljZShpdGVtLnR5cGVLZXl3b3JkcywgaXRlbS50eXBlKSk7XG4gICAgY29uc3Qgbm9uSG9zdGVkSXRlbUluZm9zID0gYXdhaXQgZ2V0U291cmNlSXRlbXNGcm9tVXJscyhub25Ib3N0ZWRJdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHsgdXJsLCBpZCB9ID0gaXRlbTtcbiAgICAgIGNvbnN0IGxheWVySW5mbyA9IGxheWVySXRlbUlkTG9va3VwTWFwW2lkXTtcbiAgICAgIHJldHVybiBsYXllckluZm8gPyB7IGxheWVyVHlwZTogbGF5ZXJJbmZvLmxheWVyVHlwZSwgdXJsIH0gOiBudWxsO1xuICAgIH0pLCBwb3J0YWwpO1xuICAgIGNvbnN0IG5vbkhvc3RlZEl0ZW1zTG9va3VwQnlVcmwgPSBhcnJheVRvTG9va3VwTWFwKG5vbkhvc3RlZEl0ZW1JbmZvcywgKGl0ZW0pID0+ICh7XG4gICAgICBrZXk6IGl0ZW0udXJsLFxuICAgICAgZGF0YTogaXRlbVxuICAgIH0pKTtcbiAgICAvLyBIYW5kbGUgc2hhbGxvdyBjb3BpZWQgbGF5ZXJzXG4gICAgY29uc3Qgc2hhbGxvd2VkQ29waWVkTGF5ZXJVcmxzID0gT2JqZWN0LmtleXMobGF5ZXJJdGVtSWRMb29rdXBNYXApXG4gICAgICAubWFwKCh1cmwpID0+IHtcbiAgICAgIGNvbnN0IGxheWVySW5mbyA9IGxheWVySXRlbUlkTG9va3VwTWFwW3VybF07XG4gICAgICByZXR1cm4gbGF5ZXJJbmZvICYmIGxheWVySW5mby5zZWFyY2hUeXBlID09PSBcInVybFwiID8geyBsYXllclR5cGU6IGxheWVySW5mby5sYXllclR5cGUsIHVybCB9IDogbnVsbDtcbiAgICB9KVxuICAgICAgLmZpbHRlcigobGF5ZXJJbmZvKSA9PiBsYXllckluZm8pO1xuICAgIGNvbnN0IHNoYWxsb3dDb3BpZWRJdGVtcyA9IGF3YWl0IGdldFNvdXJjZUl0ZW1zRnJvbVVybHMoc2hhbGxvd2VkQ29waWVkTGF5ZXJVcmxzLCBwb3J0YWwpO1xuICAgIC8vICogQWdncmVnYXRlIHRoZSByZXN1bHRcbiAgICBjb25zdCBzb3VyY2VJdGVtcyA9IFtdO1xuICAgIGl0ZW1zRnJvbUlkc1xuICAgICAgLmZpbHRlcigoaXRlbUluZm8pID0+IGl0ZW1JbmZvKVxuICAgICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1VcmwgPSBpdGVtLnVybDtcbiAgICAgIHNvdXJjZUl0ZW1zLnB1c2goeyBzb3VyY2VJdGVtOiBpdGVtIH0pO1xuICAgICAgY29uc3Qgbm9uSG9zdGVkU291cmNlSXRlbSA9IG5vbkhvc3RlZEl0ZW1zTG9va3VwQnlVcmxbaXRlbVVybF07XG4gICAgICBpZiAobm9uSG9zdGVkU291cmNlSXRlbSAmJiBpdGVtLmlkICE9PSBub25Ib3N0ZWRTb3VyY2VJdGVtLmlkKSB7XG4gICAgICAgIHNvdXJjZUl0ZW1zLnB1c2goeyBzb3VyY2VJdGVtOiBub25Ib3N0ZWRTb3VyY2VJdGVtIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFsuLi50aWxlTGF5ZXJTb3VyY2VJdGVtcywgLi4uc2hhbGxvd0NvcGllZEl0ZW1zXS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc291cmNlSXRlbXMucHVzaCh7IGxheWVyOiBudWxsLCBzb3VyY2VJdGVtOiBpdGVtIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlc3VsdDogc291cmNlSXRlbXMgfTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICB9XG59O1xuXG4vKipcbiAqIEFuYWx5emUgc2hhcmluZyBkZXRhaWwgb2YgdGhlIGl0ZW0gYW5kIHJldHVybiBhbnkgbWlzbWF0Y2ggb3Igc2hhcmluZyBpc3N1ZXNcbiAqXG4gKiBAcGFyYW0gb3ZlcnJpZGVMYXllcnNcbiAqIE5vcm1hbGx5LCB0aGUgdXRpbCB3aWxsIGZldGNoIHRoZSBsYXllcnMgZnJvbSB0aGUgL2RhdGEgZW5kcG9pbnRcbiAqIEhvd2V2ZXIsIGlmIHRoZSB1c2VyIGhhcyBvdmVycmlkZUxheWVycyBsYXllcnMsIHdlIGNhbiBwYXNzIHRoZW0gaW4gaGVyZVxuICpcbiAqICoqTm90ZSEhISoqOiBNYWtlIHN1cmUgdGhlIGxheWVycyBwYXNzZWQgaW4gaXMgaW4gdGhlIGZvcm0gb2Ygd2hhdCB3ZSB3b3VsZCByZWNlaXZlIGZyb20gdGhlIC9kYXRhIGVuZHBvaW50IG9mIHRoZSBpdGVtLCBub3QgSlMgQVBJJ3MgYExheWVyYFxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGluIHRoZSBjYXNlIG9mIE1hcCBWaWV3ZXIgd2hlcmUgdGhlIC9kYXRhIGVuZHBvaW50IGlzIG5vdCB1cGRhdGVkIHdpdGggdGhlIGxhdGVzdCBsYXllcnMgYWZ0ZXIgc2F2ZVxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyAtIHNlZSB7QGxpbmsgT3B0aW9uc31cbiAqL1xuY29uc3QgYW5hbHl6ZVNoYXJpbmdEZXRhaWwgPSBhc3luYyAoaXRlbSwgcG9ydGFsLCBvdmVycmlkZUxheWVycywgb3B0aW9ucyA9IHsgY2xlYXJEYXRhQ2FjaGVPbkRvbmU6IHRydWUgfSkgPT4ge1xuICBpZiAoaXRlbS5hY2Nlc3MgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICBuZWVkRWRpdGFibGVMYXllcnM6IFtdLFxuICAgICAgICBuZWVkUHVibGljbHlFZGl0YWJsZUxheWVyczogW10sXG4gICAgICAgIG5lZWREYXRhQ29sbGVjdGlvbkxheWVyczogW10sXG4gICAgICAgIG5lZWRzU2hhcmVMZXZlbFVwZGF0ZUxheWVyczogW10sXG4gICAgICAgIHByZW1pdW1MYXllcnM6IFtdLFxuICAgICAgICBub3RFZGl0YWJsZUxheWVyczogW11cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gYXdhaXQgZ2V0TGF5ZXJBbmRTaGFyaW5nRGV0YWlsKGl0ZW0sIHBvcnRhbCwgb3ZlcnJpZGVMYXllcnMpO1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG4gIGNvbnN0IHNoYXJpbmdEZXRhaWxCdWNrZXRzID0ge1xuICAgIG5lZWRFZGl0YWJsZUxheWVyczogW10sXG4gICAgbmVlZFB1YmxpY2x5RWRpdGFibGVMYXllcnM6IFtdLFxuICAgIG5lZWREYXRhQ29sbGVjdGlvbkxheWVyczogW10sXG4gICAgbmVlZHNTaGFyZUxldmVsVXBkYXRlTGF5ZXJzOiBbXSxcbiAgICBwcmVtaXVtTGF5ZXJzOiBbXSxcbiAgICBub3RFZGl0YWJsZUxheWVyczogW11cbiAgfTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0Lm1hcChhc3luYyAoaW5mbykgPT4ge1xuICAgIGNvbnN0IGJ1Y2tldCA9IGF3YWl0IGdldFNoYXJpbmdEZXRhaWxCdWNrZXQoe1xuICAgICAgbWFpbkl0ZW06IGl0ZW0sXG4gICAgICBzaGFyaW5nRGV0YWlsUmVzdWx0OiBpbmZvLFxuICAgICAgcG9ydGFsXG4gICAgfSk7XG4gICAgYnVja2V0ICYmIHNoYXJpbmdEZXRhaWxCdWNrZXRzW2J1Y2tldF0ucHVzaChpbmZvKTtcbiAgfSkpO1xuICBpZiAob3B0aW9ucy5jbGVhckRhdGFDYWNoZU9uRG9uZSkge1xuICAgIC8vIFRPRE86IGZpbmQgYSB3YXkgdG8gc2NvcGUgdGhpcyB0byB0aGUgZnVuY3Rpb24gb25seSAocG9zc2libHkgdGhyb3VnaCBzdG9yZSBvZiBjYWNoZSlcbiAgICAvLyAgYnV0IHJpZ2h0IG5vdyB3ZSBkb24ndCBoYXZlIGEgdXNlIGNhc2UgZm9yIHRoYXQgc28gaXQgc2hvdWxkIGJlIGZpbmUuLi5cbiAgICBkZXBlbmRlbmN5Q2hlY2tDYWNoZVR5cGVzLmZvckVhY2goKHR5cGUpID0+IGNsZWFyQ2FjaGUodHlwZSkpO1xuICB9XG4gIHJldHVybiB7IHJlc3VsdDogc2hhcmluZ0RldGFpbEJ1Y2tldHMgfTtcbn07XG4vKipcbiAqIEdldCBpdGVtIGFuZCBsYXllcnMgZnJvbSAvZGF0YSBpbiBjYXNlIHVzZXIgZG9lc24ndCBwYXNzIGxheWVyc1xuXG4gICogVWx0aW1hdGVseSwgdGhlIGdvYWwgaXMgdG8gZ2V0IHRoZSBzb3VyY2UgaXRlbSBhbmQgdGhlaXIgc2hhcmluZyBkZXRhaWwgZnJvbSBhbGwgdGhlIGRlcGVuZGVudCBsYXllcnNcbiAqL1xuY29uc3QgZ2V0TGF5ZXJBbmRTaGFyaW5nRGV0YWlsID0gYXN5bmMgKG1haW5JdGVtLCBwb3J0YWwsIG92ZXJyaWRlTGF5ZXJzKSA9PiB7XG4gIGxldCBpdGVtc1RvQ2hlY2sgPSBbXTtcbiAgbGV0IGRlcGVuZGVudExheWVycyA9IFsuLi4ob3ZlcnJpZGVMYXllcnMgfHwgW10pXTtcbiAgbGV0IGdldERhdGFFcnJvcjtcbiAgaWYgKCEoZGVwZW5kZW50TGF5ZXJzID09PSBudWxsIHx8IGRlcGVuZGVudExheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwZW5kZW50TGF5ZXJzLmxlbmd0aCkpIHtcbiAgICBjb25zdCB7IGVycm9yLCByZXN1bHQgfSA9IGF3YWl0IGdldERlcGVuZGVudEl0ZW1MYXllcnMobWFpbkl0ZW0sIHBvcnRhbCk7XG4gICAgZ2V0RGF0YUVycm9yID0gZXJyb3I7XG4gICAgZGVwZW5kZW50TGF5ZXJzID0gcmVzdWx0LmxheWVycztcbiAgICBpdGVtc1RvQ2hlY2sgPSByZXN1bHQuaXRlbXM7XG4gIH1cbiAgaWYgKGdldERhdGFFcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiBnZXREYXRhRXJyb3IgfTtcbiAgfVxuICBpZiAoZGVwZW5kZW50TGF5ZXJzLmxlbmd0aCA8PSAwICYmIGl0ZW1zVG9DaGVjay5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwiZGF0YU5vdEF2YWlsYWJsZVwiIH0gfTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgcmVzdWx0OiBkZXBlbmRlbnRMYXllclNvdXJjZUl0ZW1zLCBlcnJvciB9ID0gYXdhaXQgZ2V0U291cmNlSXRlbXNGcm9tRGVwZW5kZW50TGF5ZXJzKGRlcGVuZGVudExheWVycywgcG9ydGFsKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgfVxuICAgIC8vICogR3JvdXAgc2hhcmluZyBzdHVmZlxuICAgIGNvbnN0IHsgcmVzdWx0OiBtYWluSXRlbVNoYXJpbmdHcm91cHMsIGVycm9yOiBnZXRTaGFyZWRHcm91cHNFcnJvciB9ID0gYXdhaXQgZ2V0TGF5ZXJTaGFyZWRHcm91cHMobWFpbkl0ZW0uaWQsIHBvcnRhbCk7XG4gICAgaWYgKGdldFNoYXJlZEdyb3Vwc0Vycm9yKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogZ2V0U2hhcmVkR3JvdXBzRXJyb3IgfTtcbiAgICB9XG4gICAgLy8gU29tZXRpbWVzIGxheWVycyBjYW4gYmUgY3JlYXRlZCBmcm9tIGhlIHNhbWUgc291cmNlIGxheWVycyBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBjaGVjayB0aGUgc2FtZSBzb3VyY2UgaXRlbSBtdWx0aXBsZSB0aW1lc1xuICAgIGNvbnN0IGFsbFNvdXJjZUl0ZW1zID0gdW5pcXVlQnkoWy4uLmRlcGVuZGVudExheWVyU291cmNlSXRlbXMubWFwKCh7IHNvdXJjZUl0ZW0gfSkgPT4gc291cmNlSXRlbSksIC4uLml0ZW1zVG9DaGVja10sIChpdGVtKSA9PiBpdGVtLmlkKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChhbGxTb3VyY2VJdGVtcy5tYXAoYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNoYXJpbmdEZXRhaWwgPSBhd2FpdCBnZXRJdGVtU2hhcmluZ0RldGFpbCh7XG4gICAgICAgIHNvdXJjZUl0ZW06IGl0ZW0sXG4gICAgICAgIG1haW5JdGVtQWNjZXNzOiBtYWluSXRlbS5hY2Nlc3MsXG4gICAgICAgIG1haW5JdGVtU2hhcmluZ0dyb3VwcyxcbiAgICAgICAgcG9ydGFsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IGxheWVyOiBudWxsLCBzb3VyY2VJdGVtOiBpdGVtLCBkZXRhaWw6IHNoYXJpbmdEZXRhaWwgfTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHsgcmVzdWx0IH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGdldEl0ZW1TaGFyaW5nRGV0YWlsKHsgbWFpbkl0ZW1BY2Nlc3MsIG1haW5JdGVtU2hhcmluZ0dyb3VwcywgcG9ydGFsLCBzb3VyY2VJdGVtIH0pIHtcbiAgY29uc3QgeyBhY2Nlc3M6IHNvdXJjZUl0ZW1BY2Nlc3MsIGl0ZW1Db250cm9sIH0gPSBzb3VyY2VJdGVtO1xuICBjb25zdCBzaGFyaW5nRGV0YWlsID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TSEFSSU5HX0RFVEFJTFMpO1xuICBjb25zdCBpc01haW5JdGVtU2hhcmluZ1RvUHVibGljID0gbWFpbkl0ZW1BY2Nlc3MgPT09IFwicHVibGljXCI7XG4gIGlmIChpc0Jsb2NrZWRGcm9tU2hhcmluZ1RvUHVibGljKHNvdXJjZUl0ZW0pICYmIGlzTWFpbkl0ZW1TaGFyaW5nVG9QdWJsaWMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzaGFyaW5nRGV0YWlsKSwgeyBuZWVkc1NoYXJlTGV2ZWxVcGRhdGU6IHRydWUsIGNhbkVkaXRTaGFyZUxldmVsOiBmYWxzZSB9KTtcbiAgfVxuICAvLyBDYW4gY3VycmVudCB1c2VyIHVwZGF0ZSB0aGUgc2hhcmluZyBvbiB0aGlzIGl0ZW0sIGFuZCBkbyB0aGV5IG5lZWQgdG8sIGlmIHRoZSBsYXllciBpcyBwdWJsaWNcbiAgLy8gaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyIGlmIHRoZXkgY2FuIG9yIGNhbm5vdFxuICBpZiAoc291cmNlSXRlbUFjY2VzcyAhPT0gXCJwdWJsaWNcIikge1xuICAgIHNoYXJpbmdEZXRhaWwuY2FuRWRpdFNoYXJlTGV2ZWwgPSBjaGVja0NhblVwZGF0ZVNoYXJlTGV2ZWwoaXRlbUNvbnRyb2wpO1xuICAgIHNoYXJpbmdEZXRhaWwubmVlZHNHcm91cFVwZGF0ZSA9IGF3YWl0IGNoZWNrTmVlZEdyb3VwVXBkYXRlKHtcbiAgICAgIHNvdXJjZUl0ZW0sXG4gICAgICBpc01haW5JdGVtU2hhcmluZ1RvUHVibGljLFxuICAgICAgbWFpbkl0ZW1TaGFyaW5nR3JvdXBzLFxuICAgICAgcG9ydGFsXG4gICAgfSk7XG4gICAgc2hhcmluZ0RldGFpbC5uZWVkc1NoYXJlTGV2ZWxVcGRhdGUgPSBjaGVja05lZWRTaGFyZVVwZGF0ZSh7XG4gICAgICBtYWluSXRlbUFjY2VzcyxcbiAgICAgIHNvdXJjZUl0ZW1BY2Nlc3NcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBJcyB0aGlzIGl0ZW0gY29uc2lkZXJlZCBhIHByZW1pdW0gaXRlbVxuICAgIHNoYXJpbmdEZXRhaWwucHJlbWl1bSA9IGlzUHJlbWl1bUNvbnRlbnQoc291cmNlSXRlbSk7XG4gIH1cbiAgcmV0dXJuIHNoYXJpbmdEZXRhaWw7XG59XG5jb25zdCBjaGVja0NhblVwZGF0ZVNoYXJlTGV2ZWwgPSAoaXRlbUNvbnRyb2wpID0+IGl0ZW1Db250cm9sID09PSBcImFkbWluXCI7XG5jb25zdCBjaGVja05lZWRHcm91cFVwZGF0ZSA9IGFzeW5jICh7IHNvdXJjZUl0ZW0sIGlzTWFpbkl0ZW1TaGFyaW5nVG9QdWJsaWMsIHBvcnRhbCwgbWFpbkl0ZW1TaGFyaW5nR3JvdXBzIH0pID0+IHtcbiAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSB3ZSBoYXZlIGZpbmUtZ3JhaW4gY2hlY2sgZm9yXG4gIC8vICBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtYXBwLWNvbXBvbmVudHMvcHVsbC80MDY4XG4gIGlmIChpc01haW5JdGVtU2hhcmluZ1RvUHVibGljKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHsgcmVzdWx0OiBsYXllclNoYXJlZEdyb3VwcyB9ID0gYXdhaXQgZ2V0TGF5ZXJTaGFyZWRHcm91cHMoc291cmNlSXRlbS5pZCwgcG9ydGFsKTtcbiAgcmV0dXJuICFzaGFyZWRXaXRoU2FtZUdyb3VwcyhtYWluSXRlbVNoYXJpbmdHcm91cHMsIGxheWVyU2hhcmVkR3JvdXBzKTtcbn07XG5jb25zdCBjaGVja05lZWRTaGFyZVVwZGF0ZSA9ICh7IG1haW5JdGVtQWNjZXNzLCBzb3VyY2VJdGVtQWNjZXNzIH0pID0+IFxuLy8gXCJzaGFyZWRcIiBpcyB0aGUgc2FtZSBhcyBcInByaXZhdGVcIiB3aXRoIGdyb3VwcyBzbyBpdCBuZWVkcyBncm91cCB1cGRhdGUsIG5vdCBzaGFyZSB1cGRhdGVcbiEoc291cmNlSXRlbUFjY2VzcyA9PT0gXCJwcml2YXRlXCIgJiYgbWFpbkl0ZW1BY2Nlc3MgPT09IFwic2hhcmVkXCIpICYmXG4gIGlzQWNjZXNzTGV2ZWxHcmVhdGVyKG1haW5JdGVtQWNjZXNzLCBzb3VyY2VJdGVtQWNjZXNzKTtcbmZ1bmN0aW9uIGlzUHJlbWl1bUNvbnRlbnQoaXRlbSkge1xuICByZXR1cm4gaXNTdWJzY3JpYmVyKGl0ZW0pIHx8IGlzUHJlbWl1bShpdGVtKTtcbiAgLy8gcmV0dXJuIHNlbGVjdGVkU2hhcmVMZXZlbCAhPT0gXCJwdWJsaWNcIiA/IGZhbHNlIDogaXNTdWJzY3JpYmVyKGl0ZW0pIHx8IGlzUHJlbWl1bShpdGVtKTtcbn1cbmZ1bmN0aW9uIHNoYXJlZFdpdGhTYW1lR3JvdXBzKHNoYXJlZEdyb3VwcywgbGF5ZXJTaGFyZWRHcm91cHMpIHtcbiAgaWYgKHNoYXJlZEdyb3VwcyA9PT0gbnVsbCB8fCBzaGFyZWRHcm91cHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNoYXJlZEdyb3Vwcy5sZW5ndGgpIHtcbiAgICAvLyBXZSB1c2UgYHNoYXJlZEdyb3Vwc2AgdG8gY2hlY2sgdGhlIG9yZGVyIHNpbmNlIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBsYXllclNoYXJlZEdyb3Vwc1xuICAgIC8vIGNvbnRhaW5zIHRoZSBzYW1lIGdyb3VwcyBpbiB0aGUgc2FtZSBvcmRlciBhcyBzaGFyZWRHcm91cHMsIG5vdCB0aGUgb3RoZXIgd2F5IGFyb3VuZFxuICAgIGNvbnN0IGdyb3Vwc05vdFNoYXJlZFdpdGhMYXllciA9IHNoYXJlZEdyb3Vwcy5maWx0ZXIoKHZhbHVlKSA9PiAhKGxheWVyU2hhcmVkR3JvdXBzIHx8IFtdKS5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgIHJldHVybiBncm91cHNOb3RTaGFyZWRXaXRoTGF5ZXIubGVuZ3RoIDw9IDA7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFNoYXJlIGBpdGVtc2Agd2l0aCBncm91cHMgZmV0Y2ggZnJvbSBgc291cmNlSXRlbXNGb3JHcm91cHNgXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNoYXJlSXRlbXNUb1NoYXJlZEdyb3VwcyhpdGVtcywgc291cmNlSXRlbXNGb3JHcm91cHMsIHNoYXJlTGV2ZWwsIHBvcnRhbCwgc2hvdWxkVXBkYXRlR3JvdXAgPSB0cnVlKSB7XG4gIGNvbnN0IHsgdXNlciB9ID0gcG9ydGFsO1xuICBjb25zdCBzaGFyZWRHcm91cHNMaXN0ID0gIXNob3VsZFVwZGF0ZUdyb3VwXG4gICAgPyBbXVxuICAgIDogYXdhaXQgUHJvbWlzZS5hbGwoc291cmNlSXRlbXNGb3JHcm91cHMubWFwKGFzeW5jIChtYWluSXRlbSkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQ6IGdyb3VwSWRzIH0gPSBhd2FpdCBnZXRMYXllclNoYXJlZEdyb3VwcyhtYWluSXRlbS5pZCwgcG9ydGFsKTtcbiAgICAgIHJldHVybiBncm91cElkcztcbiAgICB9KSk7XG4gIGNvbnN0IGdyb3VwSWRzID0gc2hhcmVkR3JvdXBzTGlzdC5mbGF0KDEpO1xuICByZXR1cm4gc2hhcmVJdGVtcyhpdGVtcywgc2hhcmVMZXZlbCwgZ3JvdXBJZHMsIHsgcG9ydGFsLCB1c2VyIH0sIHRydWUpO1xufVxuLy8gaHR0cHM6Ly93d3cuZmlnbWEuY29tL2ZpbGUvQkJtdzBpb1J3MFpRbUNxRkhKZUgyTi9TaGFyZS1GbG93Y2hhcnQtNT90eXBlPXdoaXRlYm9hcmQmbm9kZS1pZD00MDEtMTQ5JnQ9RTc3WmtQelQ4Y2JvR2R0Ny0wXG5jb25zdCBnZXRTaGFyaW5nRGV0YWlsQnVja2V0ID0gYXN5bmMgKHsgbWFpbkl0ZW0sIHNoYXJpbmdEZXRhaWxSZXN1bHQsIHBvcnRhbCB9KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBzb3VyY2VJdGVtLCBkZXRhaWwgfSA9IHNoYXJpbmdEZXRhaWxSZXN1bHQ7XG4gIGNvbnN0IHsgY2FuRWRpdFNoYXJlTGV2ZWwsIG5lZWRzR3JvdXBVcGRhdGUsIG5lZWRzU2hhcmVMZXZlbFVwZGF0ZSwgcHJlbWl1bSB9ID0gZGV0YWlsO1xuICBpZiAoIW5lZWRzR3JvdXBVcGRhdGUgJiYgIW5lZWRzU2hhcmVMZXZlbFVwZGF0ZSAmJiAhcHJlbWl1bSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY2FuRWRpdFNoYXJlTGV2ZWwgJiYgIXByZW1pdW0pIHtcbiAgICByZXR1cm4gXCJub3RFZGl0YWJsZUxheWVyc1wiO1xuICB9XG4gIHN3aXRjaCAobWFpbkl0ZW0uYWNjZXNzKSB7XG4gICAgY2FzZSBcInB1YmxpY1wiOlxuICAgICAgaWYgKHByZW1pdW0pIHtcbiAgICAgICAgcmV0dXJuIFwicHJlbWl1bUxheWVyc1wiO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZUl0ZW0uYWNjZXNzICE9PSBcInB1YmxpY1wiKSB7XG4gICAgICAgIGNvbnN0IGRldmVsb3BlciA9IGlzRGV2ZWxvcGVyKHBvcnRhbC5zdWJzY3JpcHRpb25JbmZvIHx8ICgoX2EgPSBwb3J0YWwuc291cmNlSlNPTikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnNjcmlwdGlvbkluZm8pKTtcbiAgICAgICAgaWYgKGRldmVsb3BlciAmJiBpc0Jsb2NrZWRGcm9tRGV2ZWxvcGVyU2hhcmluZ1RvUHVibGljKHNvdXJjZUl0ZW0pKSB7XG4gICAgICAgICAgcmV0dXJuIFwibm90RWRpdGFibGVMYXllcnNcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXdhaXQgaXNFZGl0YWJsZUl0ZW0oc291cmNlSXRlbSwgcG9ydGFsKSkge1xuICAgICAgICAgIGNvbnN0IGlzRGF0YUNvbGxlY3Rpb25MYXllciA9IHNvdXJjZUl0ZW0udHlwZUtleXdvcmRzLmluY2x1ZGVzKFwiUHVibGljIERhdGEgQ29sbGVjdGlvblwiKTtcbiAgICAgICAgICByZXR1cm4gaXNEYXRhQ29sbGVjdGlvbkxheWVyID8gXCJuZWVkRWRpdGFibGVMYXllcnNcIiA6IFwibmVlZERhdGFDb2xsZWN0aW9uTGF5ZXJzXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm5lZWRzU2hhcmVMZXZlbFVwZGF0ZUxheWVyc1wiO1xuICAgIGNhc2UgXCJvcmdcIjpcbiAgICBjYXNlIFwic2hhcmVkXCI6XG4gICAgY2FzZSBcInByaXZhdGVcIjpcbiAgICAgIGlmIChwcmVtaXVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwibmVlZHNTaGFyZUxldmVsVXBkYXRlTGF5ZXJzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydE5ldmVyKG1haW5JdGVtLmFjY2Vzcyk7XG4gIH1cbn07XG4vLyBXZSBkb24ndCBibG93IHVwIHRoZSBjYWNoZSBmb3IgcG9ydGFsIGluZm8gc2luY2UgdGhhdCBpbmZvcm1hdGlvbiB3aWxsIG5vdCBsaWtlbHkgYmUgY2hhbmdlZFxuY29uc3QgZGVwZW5kZW5jeUNoZWNrQ2FjaGVUeXBlcyA9IFtcIml0ZW1EYXRhXCIsIFwiaXRlbU1ldGFkYXRhXCJdO1xuY29uc3QgYXNzZXJ0TmV2ZXIgPSAoYWNjZXNzKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBzaGFyZSBsZXZlbCAke2FjY2Vzc31gKTtcbn07XG5cbmV4cG9ydCB7IGFuYWx5emVTaGFyaW5nRGV0YWlsIGFzIGEsIHNoYXJlSXRlbXMgYXMgYiwgaXNCbG9ja2VkRnJvbVNoYXJpbmdUb1B1YmxpYyBhcyBjLCBpc0Jsb2NrZWRGcm9tRGV2ZWxvcGVyU2hhcmluZ1RvUHVibGljIGFzIGQsIGRlcGVuZGVuY3lDaGVja0NhY2hlVHlwZXMgYXMgZSwgaXNBY2Nlc3NMZXZlbEdyZWF0ZXIgYXMgaSwgc2hhcmVJdGVtc1RvU2hhcmVkR3JvdXBzIGFzIHMsIHVuc2hhcmVJdGVtcyBhcyB1IH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IHggYXMgaXNPcmdVc2VyLCB5IGFzIGNhblNoYXJlSXRlbVRvR3JvdXAkMSwgbiBhcyBpc1B1YmxpY1VzZXIsIHogYXMgY2FuU2hhcmVJdGVtVG9PcmcsIEEgYXMgYWRtaW5DYW5TaGFyZU90aGVyc0l0ZW1Ub0dyb3VwLCBlIGFzIGlzT3JnQWRtaW4sIGkgYXMgaXNPd25lciwgdCBhcyBpc0N1c3RvbVJvbGUsIEIgYXMgY2FuU2hhcmVPdGhlcnNJdGVtc1RvT3JnLCBDIGFzIGNhblNoYXJlSXRlbVRvUHVibGljLCBEIGFzIGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYywgRSBhcyBoYXNBZG1pblNoYXJlUHJpdmlsZWdlLCBjIGFzIGlzRGV2ZWxvcGVyIH0gZnJvbSAnLi9wcml2aWxlZ2VzLWNjZDVmMzdkLmpzJztcbmltcG9ydCB7IGYgYXMgYXJyYXlzQXJlRXF1aXZhbGVudCB9IGZyb20gJy4vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyc7XG5pbXBvcnQgeyBjIGFzIGlzQmxvY2tlZEZyb21TaGFyaW5nVG9QdWJsaWMsIGQgYXMgaXNCbG9ja2VkRnJvbURldmVsb3BlclNoYXJpbmdUb1B1YmxpYyB9IGZyb20gJy4vc2VydmljZXMtYWRkZGVlZjkuanMnO1xuXG5jb25zdCBncm91cHNBcmVPd25lZEJ5T3JnID0gKHVzZXIsIGdyb3VwRGF0YSkgPT4ge1xuICBjb25zdCB7IHVzZXJuYW1lLCBvcmdJZCB9ID0gdXNlcjtcbiAgcmV0dXJuIGdyb3VwRGF0YS5ldmVyeSgoeyBncm91cCB9KSA9PiB7XG4gICAgY29uc3QgaXNPd25lciA9IHVzZXJuYW1lID09PSAoZ3JvdXAgPT09IG51bGwgfHwgZ3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwLm93bmVyKTtcbiAgICBjb25zdCBpc093bmVkQnlNeU9yZyA9IG9yZ0lkID09PSBncm91cC5vcmdJZDtcbiAgICByZXR1cm4gaXNPd25lciB8fCBpc093bmVkQnlNeU9yZztcbiAgfSk7XG59O1xuY29uc3QgY2FuU2hhcmVJdGVtVG9Hcm91cCA9IChzZWxlY3RlZEdyb3VwRGF0YSwgdXNlcikgPT4gdXNlckNhblNoYXJlKHVzZXIpIHx8IChhZG1pbkNhblNoYXJlT3RoZXJzSXRlbVRvR3JvdXAodXNlcikgJiYgZ3JvdXBzQXJlT3duZWRCeU9yZyh1c2VyLCBzZWxlY3RlZEdyb3VwRGF0YSkpO1xuY29uc3QgdXNlckNhblNoYXJlID0gKHVzZXIpID0+ICFpc09yZ1VzZXIodXNlcikgfHwgdXNlckNhblNoYXJlSXRlbVRvR3JvdXAodXNlcik7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ3JvdXBzIGFyZSBpbiBhIG1peGVkIHN0YXRlIHdoZXJlIGF0IGxlYXN0IG9uZSBncm91cCBpcyBzaGFyZWQgd2l0aCBkaWZmZXJlbnQgaXRlbXMgdGhhbiB0aGUgcmVzdFxuICovXG5jb25zdCBjaGVja0lmU2hhcmluZ01peGVkID0gKGl0ZW1zLCBzZWxlY3RlZEdyb3VwcykgPT4gc2VsZWN0ZWRHcm91cHMuc29tZSgoeyBzZWxlY3RlZEJ5SXRlbUlkcyB9KSA9PiBzZWxlY3RlZEJ5SXRlbUlkcy5sZW5ndGggIT09IGl0ZW1zLmxlbmd0aCk7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gc2hhcmUgdGhlaXIgaXRlbSB0byBncm91cHNcbiAqL1xuZnVuY3Rpb24gdXNlckNhblNoYXJlSXRlbVRvR3JvdXAodXNlcikge1xuICByZXR1cm4gKHVzZXIucHJpdmlsZWdlcyB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6dXNlcjpzaGFyZVRvR3JvdXBcIik7XG59XG5jb25zdCBwcml2YXRlSXRlbXNIYXZlQmVlblNoYXJlZFRvR3JvdXBzID0gKHsgaXRlbXMsIGdyb3VwRGF0YSB9KSA9PiBpdGVtc1xuICAuZmlsdGVyKChpdGVtKSA9PiB7XG4gIGNvbnN0IGFjY2VzcyA9IGl0ZW0uYWNjZXNzO1xuICByZXR1cm4gYWNjZXNzID09PSBcInByaXZhdGVcIiB8fCBhY2Nlc3MgPT09IFwic2hhcmVkXCI7XG59KVxuICAucmVkdWNlKChtZW1vLCBpdGVtKSA9PiBtZW1vIHx8IGl0ZW1IYXNCZWVuU2hhcmVkVG9Hcm91cHMoeyBpdGVtLCBncm91cERhdGEgfSksIGZhbHNlKTtcbmNvbnN0IGl0ZW1IYXNCZWVuU2hhcmVkVG9Hcm91cHMgPSAoeyBpdGVtLCBncm91cERhdGEgfSkgPT4gZ3JvdXBEYXRhLnJlZHVjZSgobWVtbywgZ3JvdXBEYXRhKSA9PiBtZW1vIHx8ICghIWdyb3VwRGF0YS5zZWxlY3RlZEJ5SXRlbUlkcyAmJiBncm91cERhdGEuc2VsZWN0ZWRCeUl0ZW1JZHMuaW5jbHVkZXMoaXRlbS5pZCkpLCBmYWxzZSk7XG5jb25zdCBzaG93RWRpdEdyb3VwV2FybmluZyA9ICh1c2VyLCBzZWxlY3RlZFNoYXJlTGV2ZWxzKSA9PiAhaXNPcmdVc2VyKHVzZXIpICYmXG4gICFjYW5TaGFyZUl0ZW1Ub0dyb3VwJDEodXNlcikgJiZcbiAgLy8gVGhleSBjYW4ndCBzaGFyZSB0byBvcmcgYW55d2F5IHNvIG5vIG5lZWQgdG8gY2hlY2sgdGhhdFxuICBzZWxlY3RlZFNoYXJlTGV2ZWxzLnNvbWUoKHNoYXJlTGV2ZWwpID0+IHNoYXJlTGV2ZWwgPT09IFwicHJpdmF0ZVwiKTtcbmNvbnN0IHNob3dSZXZlcnRHcm91cFdhcm5pbmcgPSAodXNlciwgc2VsZWN0ZWRTaGFyZUxldmVscywgaW5pdGlhbFNlbGVjdGVkR3JvdXBEYXRhKSA9PiBpc1B1YmxpY1VzZXIodXNlcikgJiZcbiAgc2VsZWN0ZWRTaGFyZUxldmVscy5zb21lKChzaGFyZUxldmVsKSA9PiBzaGFyZUxldmVsID09PSBcInByaXZhdGVcIikgJiZcbiAgaW5pdGlhbFNlbGVjdGVkR3JvdXBEYXRhLmxlbmd0aCA+IDA7XG5jb25zdCBzaG93UmV2ZXJ0U2hhcmVMZXZlbFdhcm5pbmcgPSAodXNlciwgaXRlbXMsIHNlbGVjdGVkR3JvdXBEYXRhKSA9PiAhaXNPcmdVc2VyKHVzZXIpICYmXG4gICFjYW5TaGFyZUl0ZW1Ub09yZyh1c2VyKSAmJlxuICBwcml2YXRlSXRlbXNIYXZlQmVlblNoYXJlZFRvR3JvdXBzKHsgaXRlbXMsIGdyb3VwRGF0YTogc2VsZWN0ZWRHcm91cERhdGEgfSk7XG5jb25zdCBzaG93U2hhcmVMZXZlbENoYW5nZVdhcm5pbmcgPSAodXNlciwgbmV3U2hhcmVMZXZlbCwgc2VsZWN0ZWRHcm91cERhdGEpID0+ICFpc09yZ1VzZXIodXNlcikgJiZcbiAgIWNhblNoYXJlSXRlbVRvT3JnKHVzZXIpICYmXG4gIG5ld1NoYXJlTGV2ZWwgPT09IFwicHJpdmF0ZVwiICYmXG4gIE9iamVjdC5rZXlzKHNlbGVjdGVkR3JvdXBEYXRhKS5sZW5ndGggPiAwO1xuXG5jb25zdCBnZXRVc2VybmFtZVF1ZXJ5ID0gKHsgc2hhcmVNb2RlLCBjdXJyZW50VXNlcm5hbWUsIHVzZXIsIHVzZXJHcm91cExvb2t1cCwgaXNQcml2YXRlIH0pID0+IHtcbiAgdmFyIF9hO1xuICBsZXQgZ3JvdXBJZHMgPSBbXTtcbiAgbGV0IGdyb3VwSWRzUXVlcnk7XG4gIGlmICh1c2VyR3JvdXBMb29rdXApIHtcbiAgICBsZXQgY3VycmVudFVzZXJHcm91cHMgPSBbXTtcbiAgICBpZiAoc2hhcmVNb2RlID09PSBcImFkbWluXCIgJiYgKChfYSA9IHVzZXJHcm91cExvb2t1cFtjdXJyZW50VXNlcm5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJiBjdXJyZW50VXNlcm5hbWUgIT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgIC8vIEluIGFkbWluIGNhc2UsIHdlIHdhbnQgdG8gYWxzbyBpbmNsdWRlcyBncm91cHMgdGhhdCB0aGUgaXRlbSBvd25lciBoYXMgYWNjZXNzIHRvXG4gICAgICBjdXJyZW50VXNlckdyb3VwcyA9IFsuLi51c2VyR3JvdXBMb29rdXBbY3VycmVudFVzZXJuYW1lXV07XG4gICAgfVxuICAgIGlmIChzaGFyZU1vZGUgIT09IFwiYWRtaW5cIiB8fCAhaXNQcml2YXRlKSB7XG4gICAgICAvLyBGb3IgYWRtaW4sIHdlIG9ubHkgd2FudCB0byBpbmNsdWRlIHRoZSBhZG1pbidzIGdyb3VwcyBpZiB0aGUgaXRlbSBpcyBub3QgcHJpdmF0ZVxuICAgICAgLy8gRm9yIHByaXZhdGUgaXRlbSBvd25lciwgaW5jbHVkZXMgZ3JvdXBzIHRoYXQgdGhleSBjYW4gc2hhcmUgdG9cbiAgICAgIHVzZXJHcm91cExvb2t1cFt1c2VyLnVzZXJuYW1lXS5mb3JFYWNoKChncm91cCkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyR3JvdXBzLnNvbWUoKGcpID0+IGcuaWQgPT09IGdyb3VwLmlkKSkge1xuICAgICAgICAgIGN1cnJlbnRVc2VyR3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY3VycmVudFVzZXJHcm91cHMgPT09IG51bGwgfHwgY3VycmVudFVzZXJHcm91cHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRVc2VyR3JvdXBzLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAvLyBpbmNsdWRlIGdyb3VwIGlkcyB0aGF0IHRoZSBjdXJyZW50IHVzZXIgaXMgb3duZXIgb3IgYWRtaW4gb3IgaWYgdmlld09ubHkgaXMgZmFsc2VcbiAgICAgIGNvbnN0IG1lbWJlclR5cGUgPSAoX2EgPSBncm91cC51c2VyTWVtYmVyc2hpcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lbWJlclR5cGU7XG4gICAgICBpZiAoZ3JvdXAuaXNWaWV3T25seSAmJiAobWVtYmVyVHlwZSA9PT0gXCJvd25lclwiIHx8IG1lbWJlclR5cGUgPT09IFwiYWRtaW5cIikpIHtcbiAgICAgICAgZ3JvdXBJZHMucHVzaChncm91cC5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKGdyb3VwSWRzLmxlbmd0aCkge1xuICAgIGdyb3VwSWRzUXVlcnkgPSBgKGlzdmlld29ubHk6ZmFsc2UgT1IgaWQ6KCR7Z3JvdXBJZHMuam9pbihcIiBPUiBcIil9KSlgO1xuICB9XG4gIGNvbnN0IGFkbWluR3JvdXBRdWVyeSA9IGdyb3VwSWRzLmxlbmd0aCA/IGAgT1IgaWQ6KCR7Z3JvdXBJZHMuam9pbihcIiBPUiBcIil9KWAgOiBcIlwiO1xuICBzd2l0Y2ggKHNoYXJlTW9kZSkge1xuICAgIC8vIEluIHRoZSBkZWZhdWx0IChpdGVtIG93bmVyKSBjYXNlLCB3ZSB3YW50IHRvIHNob3cgYWxsIHRoZSBncm91cHNcbiAgICAvLyB0aGF0IHRoZSB1c2VyIGVpdGhlciBvd25zIG9yIGhhcyB3cml0ZSBhY2Nlc3MgdG8uXG4gICAgLy8gV3JpdGUgYWNjZXNzIGlzIGluZGljYXRlZCBieSB0aGUgaXN2aWV3b25seSBmbGFnLlxuICAgIC8vXG4gICAgLy8gSWRlYWxseSwgd2UnZCBhbHNvIGJlIGFibGUgdG8gc2hvdyBncm91cHMgdGhlIGN1cnJlbnQgdXNlciBpcyBhZG1pbiBvZlxuICAgIC8vIG1heWJlIHdpdGggYSBzeW50YXggbGlrZSBhZG1pbjoke2N1cnJlbnRVc2VybmFtZX1cbiAgICAvLyBidXQgdGhlIHNlYXJjaCBlbmRwb2ludCBkb2VzIG5vdCBzdXBwb3J0IHRoYXQuXG4gICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgIHJldHVybiBncm91cElkc1F1ZXJ5IHx8IGAob3duZXI6JHtjdXJyZW50VXNlcm5hbWV9IE9SIGlzdmlld29ubHk6ZmFsc2UpYDtcbiAgICAvLyBncm91cCBvd25lciBtb2RlIHNob3VsZCBvbmx5IHNlZSBncm91cHMgb3duZWQgYnkgdGhlIGN1cnJlbnQgdXNlclxuICAgIC8vIGV4Y2x1ZGluZyBzaGFyZWQtdXBkYXRlIGdyb3Vwc1xuICAgIGNhc2UgXCJncm91cFwiOlxuICAgICAgcmV0dXJuIGBvd25lcjoke2N1cnJlbnRVc2VybmFtZX0gLWNhcGFiaWxpdGllczp1cGRhdGVpdGVtY29udHJvbGA7XG4gICAgLy8gSW4gYWRtaW4gY2FzZXMsIHdlIHdhbnQgYWxsIHRoZSBncm91cHMgdGhlIGN1cnJlbnQgdXNlciBpcyBhIG1lbWJlciBvZi5cbiAgICAvLyB0aGlzIGlzIGhhbmRsZWQgYnkgdGhlIHNlYXJjaFVzZXJBY2Nlc3MgYW5kIHNlYXJjaFVzZXJOYW1lIHBhcmFtc1xuICAgIC8vIG91dHNpZGUgb2YgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICBjYXNlIFwiYWRtaW5cIjpcbiAgICAgIGlmICh1c2VyLnVzZXJuYW1lID09PSBjdXJyZW50VXNlcm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAoaXN2aWV3b25seTpmYWxzZSR7YWRtaW5Hcm91cFF1ZXJ5fSBPUiBvd25lcjoke3VzZXIudXNlcm5hbWV9KSAtY2FwYWJpbGl0aWVzOnVwZGF0ZWl0ZW1jb250cm9sYDtcbiAgICAgIH1cbiAgICAgIC8vIFdoZW4gbG9va2luZyBhdCB0aGUgY29udGVudCB1c2VyJ3MgZ3JvdXBzLCBzaG93IHRoYXQgdXNlcidzIGdyb3Vwc1xuICAgICAgLy8gb3IgZ3JvdXBzIHRoZXkgaGF2ZSBhY2Nlc3MgdG8uXG4gICAgICAvLyBXZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAjMjgwNDFcbiAgICAgIHJldHVybiBgKG93bmVyOiR7Y3VycmVudFVzZXJuYW1lfSBPUiBpc3ZpZXdvbmx5OmZhbHNlJHthZG1pbkdyb3VwUXVlcnl9KWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuXG5jb25zdCBERUZBVUxUX1NIQVJJTkdfREVUQUlMID0ge1xuICBuZWVkRWRpdGFibGVMYXllcnM6IFtdLFxuICBuZWVkUHVibGljbHlFZGl0YWJsZUxheWVyczogW10sXG4gIG5lZWREYXRhQ29sbGVjdGlvbkxheWVyczogW10sXG4gIG5lZWRzU2hhcmVMZXZlbFVwZGF0ZUxheWVyczogW10sXG4gIHByZW1pdW1MYXllcnM6IFtdLFxuICBub3RFZGl0YWJsZUxheWVyczogW11cbn07XG5jb25zdCBERUZBVUxUX1NIQVJFX0xFVkVMUyA9IFtcInByaXZhdGVcIiwgXCJvcmdcIiwgXCJwdWJsaWNcIl07XG5cbi8vIFRPRE86IGFkZCB1bml0IHRlc3Rcbi8qKlxuICogQ29tcG9zZSB0aGUgbGlzdCBvZiBpdGVtcy9ncm91cHMgdG8gc2hhcmUgYW5kIHVuc2hhcmVcbiAqXG4gKiAhIFRoaXMgYXNzdW1lIHdoZW4gd2Ugc2hhcmUvdW5zaGFyZSwgd2Ugc2hhcmUvdW5zaGFyZSB0byBhbGwgaXRlbXNcbiAqXG4gKiBVc2VmdWwgZm9yIC9zaGFyZUl0ZW1zIG9yIC91bnNoYXJlSXRlbXMgZW5kcG9pbnRzXG4gKiAgKi9cbmNvbnN0IGdldEl0ZW1zQW5kR3JvdXBzVG9VcGRhdGVTaGFyZSA9IChpbml0aWFsU2VsZWN0ZWRHcm91cERhdGEsIGN1clNlbGVjdGVkR3JvdXBEYXRhKSA9PiB7XG4gIC8vIDMgc3RhdGVzIHRvIGhhbmRsZTpcbiAgLy8gMTogZ3JvdXBzIHRoYXQgYXJlIGNvbXBsZXRlbHkgdW5zaGFyZWQgZnJvbSB0aGUgYWxsIGl0ZW1zIC0+IHVuc2hhcmVEYXRhXG4gIC8vIDI6IGdyb3VwcyB0aGF0IGFyZSBjb21wbGV0ZWx5IHNoYXJlZCB0byBhbGwgaXRlbXMgLT4gc2hhcmVEYXRhXG4gIC8vIDM6IG1peGVkIHNoYXJpbmcgLT4gd2UgZG9uJ3QgY2FyZSAvLyAhIGl0IHdpbGwgYWZmZWN0IHRoZSBhY3Rpdml0eSBsb2cgYnV0IHdlIGRvbid0IGNhcmUgZm9yIG5vd1xuICBjb25zdCBjb21wbGV0ZWx5VW5zaGFyZWRHcm91cERhdGEgPSBpbml0aWFsU2VsZWN0ZWRHcm91cERhdGEuZmlsdGVyKChncm91cERhdGEpID0+ICFjdXJTZWxlY3RlZEdyb3VwRGF0YS5zb21lKChjdXJHcm91cERhdGEpID0+IGN1ckdyb3VwRGF0YS5ncm91cC5pZCA9PT0gZ3JvdXBEYXRhLmdyb3VwLmlkKSk7XG4gIGNvbnN0IGNvbXBsZXRlbHlTaGFyZWRHcm91cERhdGEgPSBjdXJTZWxlY3RlZEdyb3VwRGF0YS5maWx0ZXIoKGdyb3VwRGF0YSkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxHcm91cERhdGEgPSBpbml0aWFsU2VsZWN0ZWRHcm91cERhdGEuZmluZCgoaW5pdGlhbEdyb3VwRGF0YSkgPT4gaW5pdGlhbEdyb3VwRGF0YS5ncm91cC5pZCA9PT0gZ3JvdXBEYXRhLmdyb3VwLmlkKTtcbiAgICAvLyBUaGlzIGFzc3VtZSB0aGF0IHdoZW4gd2Ugc2hhcmUvdW5zaGFyZSwgd2Ugc2hhcmUvdW5zaGFyZSB0byBhbGwgaXRlbXMsXG4gICAgLy8gIHNvIHRoaXMgbWVhbnMgZ3JvdXBEYXRhLnNlbGVjdGVkQnlJdGVtSWRzLmxlbmd0aCBpcyBhbHJlYWR5IHRoZSBtYXhcbiAgICAvLyBUaGlzIHdvdWxkIG1ha2UgdGhlIHV0aWwgaW5kZXBlbmRlbnQgb2YgdGhlIGxlbmd0aCBvZiB0aGUgaXRlbXMgYXJyYXlcbiAgICByZXR1cm4gIWluaXRpYWxHcm91cERhdGEgfHwgaW5pdGlhbEdyb3VwRGF0YS5zZWxlY3RlZEJ5SXRlbUlkcy5sZW5ndGggPCBncm91cERhdGEuc2VsZWN0ZWRCeUl0ZW1JZHMubGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB1bnNoYXJlR3JvdXBJZHM6IGNvbXBsZXRlbHlVbnNoYXJlZEdyb3VwRGF0YS5tYXAoKGdyb3VwRGF0YSkgPT4gZ3JvdXBEYXRhLmdyb3VwLmlkKSxcbiAgICBzaGFyZUdyb3VwSWRzOiBjb21wbGV0ZWx5U2hhcmVkR3JvdXBEYXRhLm1hcCgoZ3JvdXBEYXRhKSA9PiBncm91cERhdGEuZ3JvdXAuaWQpXG4gIH07XG59O1xuY29uc3QgZ2V0UG9zc2libGVTaGFyZUxldmVsID0gKHVzZXIsIGl0ZW1zLCBwb3J0YWwpID0+IHtcbiAgY29uc3QgaXNQdWJsaWNVc2VyJDEgPSBpc1B1YmxpY1VzZXIodXNlcik7XG4gIGxldCBwb3NzaWJsZVNoYXJlTGV2ZWxPcHRpb25zID0gREVGQVVMVF9TSEFSRV9MRVZFTFM7XG4gIGlmIChpc1B1YmxpY1VzZXIkMSkge1xuICAgIHBvc3NpYmxlU2hhcmVMZXZlbE9wdGlvbnMgPSBbXCJwcml2YXRlXCIsIFwicHVibGljXCJdO1xuICB9XG4gIGVsc2UgaWYgKCFwb3J0YWwuY2FuU2hhcmVQdWJsaWMgJiYgIWlzT3JnQWRtaW4odXNlcikpIHtcbiAgICBwb3NzaWJsZVNoYXJlTGV2ZWxPcHRpb25zID0gW1wicHJpdmF0ZVwiLCBcIm9yZ1wiXTtcbiAgfVxuICBwb3NzaWJsZVNoYXJlTGV2ZWxPcHRpb25zID0gcG9zc2libGVTaGFyZUxldmVsT3B0aW9ucy5maWx0ZXIoKHNoYXJlTGV2ZWwpID0+IGNhblNoYXJlTGV2ZWwoc2hhcmVMZXZlbCwgaXRlbXMsIHVzZXIsIHBvcnRhbCkpO1xuICByZXR1cm4gcG9zc2libGVTaGFyZUxldmVsT3B0aW9ucztcbn07XG5jb25zdCBjYW5TaGFyZUxldmVsID0gKHNoYXJlTGV2ZWwsIGl0ZW1zLCB1c2VyLCBwb3J0YWwpID0+IHtcbiAgdmFyIF9hO1xuICBpZiAoc2hhcmVMZXZlbCA9PT0gXCJwcml2YXRlXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc093bmVyT2ZBbGxJdGVtcyA9IGl0ZW1zT3duZWRCeVVzZXIodXNlciwgaXRlbXMpO1xuICBjb25zdCBpdGVtc0JlbG9uZ1RvT3JnID0gaXRlbXNPd25lZEJ5T3JnKHVzZXIsIGl0ZW1zKTtcbiAgY29uc3QgaXNJdGVtQWRtaW4gPSBpc09yZ0FkbWluKHVzZXIpICYmICFpc0N1c3RvbVJvbGUodXNlcikgJiYgaXRlbXNCZWxvbmdUb09yZztcbiAgY29uc3QgaXNDdXN0b21JdGVtQWRtaW4gPSBpc09yZ0FkbWluKHVzZXIpICYmIGlzQ3VzdG9tUm9sZSh1c2VyKSAmJiBpdGVtc0JlbG9uZ1RvT3JnO1xuICBjb25zdCBpc1B1YmxpY1VzZXIkMSA9IGlzUHVibGljVXNlcih1c2VyKTtcbiAgaWYgKHNoYXJlTGV2ZWwgPT09IFwib3JnXCIpIHtcbiAgICBpZiAoaXNQdWJsaWNVc2VyJDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgoY2FuU2hhcmVJdGVtVG9PcmcodXNlcikgJiYgKGlzT3duZXJPZkFsbEl0ZW1zIHx8IGlzSXRlbUFkbWluKSkgfHxcbiAgICAgIChjYW5TaGFyZU90aGVyc0l0ZW1zVG9PcmcodXNlcikgJiYgKGlzSXRlbUFkbWluIHx8IGlzQ3VzdG9tSXRlbUFkbWluKSkpO1xuICB9XG4gIGlmIChzaGFyZUxldmVsID09PSBcInB1YmxpY1wiKSB7XG4gICAgY29uc3QgZGV2ZWxvcGVyID0gaXNEZXZlbG9wZXIoKHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5zdWJzY3JpcHRpb25JbmZvKSB8fCAoKF9hID0gcG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpcHRpb25JbmZvKSk7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgKGlzQmxvY2tlZEZyb21TaGFyaW5nVG9QdWJsaWMoaXRlbXNbMF0pIHx8IChkZXZlbG9wZXIgJiYgaXNCbG9ja2VkRnJvbURldmVsb3BlclNoYXJpbmdUb1B1YmxpYyhpdGVtc1swXSkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjYW5TaGFyZVB1YmxpYyA9IHBvcnRhbC5jYW5TaGFyZVB1YmxpYztcbiAgICByZXR1cm4gKGlzUHVibGljVXNlciQxIHx8XG4gICAgICAoY2FuU2hhcmVJdGVtVG9QdWJsaWModXNlcikgJiYgKChpc093bmVyT2ZBbGxJdGVtcyAmJiBjYW5TaGFyZVB1YmxpYykgfHwgaXNJdGVtQWRtaW4pKSB8fFxuICAgICAgKGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyh1c2VyKSAmJiAoaXNJdGVtQWRtaW4gfHwgaXNDdXN0b21JdGVtQWRtaW4pKSk7XG4gIH1cbn07XG4vKipcbiAqIERldGVybWluZSB0aGUgc2hhcmUgbW9kZSBvZiB0aGUgdXNlciBiYXNlZCBvbiB0aGUgaXRlbS5cbiAqXG4gKiAhIFdlIG9ubHkgY29uc2lkZXIgdGhlIGZpcnN0IGl0ZW0gb24gdGhlIGxpc3RcbiAqL1xuY29uc3QgZ2V0U2hhcmVNb2RlID0gKGl0ZW1zLCB1c2VyLCBwb3J0YWwpID0+IHtcbiAgY29uc3QgaXRlbSA9IGl0ZW1zWzBdO1xuICBpZiAoaXNPd25lcihpdGVtLCB1c2VyKSkge1xuICAgIHJldHVybiBcImRlZmF1bHRcIjtcbiAgfVxuICAvKipcbiAgICogaWYgdGhlcmUgaXMgbm8gb3JnIGlkIG9uIHRoZSBpdGVtLCBkZWR1Y2UgdGhhdCB0aGUgdXNlciBjYW4gZG8gYWRtaW4gdGhpbmdzXG4gICAqXG4gICAqIGlmIGl0ZW0ub3JnSWQgaXMgcHJlc2VudCwgY2hlY2sgZXF1YWxpdHkgYWdhaW5zdCBwb3J0YWwgdXNlcidzIG9yZ1xuICAgKi9cbiAgY29uc3QgaXRlbU93bmVyQW5kVXNlclNhbWVPcmcgPSAhaXRlbS5vcmdJZCB8fCBpdGVtLm9yZ0lkID09PSB1c2VyLm9yZ0lkO1xuICBpZiAoaGFzQWRtaW5TaGFyZVByaXZpbGVnZSh7IGl0ZW1zLCB1c2VyLCBwb3J0YWwgfSkgJiYgaXRlbU93bmVyQW5kVXNlclNhbWVPcmcpIHtcbiAgICByZXR1cm4gXCJhZG1pblwiO1xuICB9XG4gIC8vIGlmIHRoZSB1c2VyIGlzIG5vdCBpdGVtIG93bmVyIG9yIG9yZyBhZG1pbiwgdGhleSBlbnRlciBncm91cCBzaGFyaW5nIG1vZGVcbiAgLy8gd2hpY2ggaXMgdmVyeSByZXN0cmljdGVkXG4gIHJldHVybiBcImdyb3VwXCI7XG59O1xuY29uc3QgaXRlbXNPd25lZEJ5VXNlciA9ICh1c2VyLCBpdGVtcykgPT4ge1xuICByZXR1cm4gaXRlbXMuZXZlcnkoKGl0ZW0pID0+IGlzT3duZXIoaXRlbSwgdXNlcikpO1xufTtcbmNvbnN0IGl0ZW1zT3duZWRCeU9yZyA9ICh1c2VyLCBpdGVtcykgPT4ge1xuICBjb25zdCB1c2VyT3JnSWQgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIub3JnSWQ7XG4gIHJldHVybiBpdGVtcy5ldmVyeSgoaXRlbSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKGlzT3duZXIoaXRlbSwgdXNlcikgfHxcbiAgICAgIC8vIDMueCBzcGVjaWZpYyBpdGVtLnBvcnRhbFxuICAgICAgKChfYSA9IGl0ZW0ucG9ydGFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpID09PSB1c2VyT3JnSWQgfHxcbiAgICAgIC8vIDQueCBzcGVjaWZpYyBpdGVtLm9yZ0lkXG4gICAgICBpdGVtLm9yZ0lkID09PSB1c2VyT3JnSWQgfHxcbiAgICAgIC8vIFNlZW1zIHRvIGJlIGF2YWlsYWJsZSBvbiBib3RoIDMueCBhbmQgNC54IGJ1dCBjYW4ndCB2ZXJpZnkgdmlhIHRoZSBvZmZpY2lhbCBkb2MsIG9ubHkgdGhlIEhvbWUgQXBwIDooXG4gICAgICAvLyBUaGlzIHByb3BlcnR5IGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHVzZXIncyBjcmVkZW50aWFsICh0b2tlbikgdGhhdCdzIHVzZWQgdG8gYWNjZXNzIHRoZSBpdGVtXG4gICAgICAvLyAgc28gaXQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpZiB0aGUgaXRlbSBpcyBhY2Nlc3NlZCB3aXRob3V0IGEgdG9rZW4gKGp1c3QgYSB0aGVvcnkpXG4gICAgICAvLyAgdGhhdCdzIHdoeSBpdCdzIHRoZSBsYXN0IHJlc29ydFxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vamF2YXNjcmlwdC9sYXRlc3QvYXBpLXJlZmVyZW5jZS9lc3JpLXBvcnRhbC1Qb3J0YWxJdGVtLmh0bWwjaXNPcmdJdGVtXG4gICAgICBpdGVtLmlzT3JnSXRlbSk7XG4gIH0pO1xufTtcbmNvbnN0IGlzU2hhcmVMZXZlbERpcnR5ID0gKHNlbGVjdGVkU2hhcmVMZXZlbHMsIGluaXRpYWxTaGFyZUxldmVscywgaXRlbXMsIHNlbGVjdGVkR3JvdXBEYXRhKSA9PiBzZWxlY3RlZFNoYXJlTGV2ZWxzLnNvbWUoKGN1clNoYXJlTGV2ZWwsIGluZGV4KSA9PiB7XG4gIGNvbnN0IGluaXRpYWxTaGFyZUxldmVsID0gaW5pdGlhbFNoYXJlTGV2ZWxzW2luZGV4XTtcbiAgLy8gXCJzaGFyZWRcIiBsZXZlbCA9IHNoYXJlZCB0byBncm91cCArIFwicHJpdmF0ZVwiXG4gIGlmIChpbml0aWFsU2hhcmVMZXZlbCA9PT0gXCJzaGFyZWRcIiAmJiBjdXJTaGFyZUxldmVsID09PSBcInByaXZhdGVcIikge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF07XG4gICAgcmV0dXJuICFzZWxlY3RlZEdyb3VwRGF0YS5zb21lKChncm91cERhdGEpID0+IGdyb3VwRGF0YS5zZWxlY3RlZEJ5SXRlbUlkcy5pbmNsdWRlcyhpdGVtLmlkKSk7XG4gIH1cbiAgcmV0dXJuIGluaXRpYWxTaGFyZUxldmVsICE9PSBjdXJTaGFyZUxldmVsO1xufSk7XG4vLyBUT0RPOiBvcHRpbWl6ZSB0aGlzIE8obl4zKS4uLlxuY29uc3QgaXNTZWxlY3RlZEdyb3VwRGF0YURpcnR5ID0gKGluaXRpYWxTZWxlY3RlZEdyb3VwRGF0YSwgY3VyU2VsZWN0ZWRHcm91cERhdGEpID0+IHtcbiAgaWYgKGluaXRpYWxTZWxlY3RlZEdyb3VwRGF0YS5sZW5ndGggIT09IGN1clNlbGVjdGVkR3JvdXBEYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjdXJTZWxlY3RlZEdyb3VwRGF0YS5zb21lKChjdXJHcm91cERhdGEpID0+IHtcbiAgICBjb25zdCBpbml0aWFsR3JvdXBEYXRhID0gaW5pdGlhbFNlbGVjdGVkR3JvdXBEYXRhLmZpbmQoKGluaXRpYWxHcm91cERhdGEpID0+IGluaXRpYWxHcm91cERhdGEuZ3JvdXAuaWQgPT09IGN1ckdyb3VwRGF0YS5ncm91cC5pZCk7XG4gICAgaWYgKCFpbml0aWFsR3JvdXBEYXRhKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICFhcnJheXNBcmVFcXVpdmFsZW50KGluaXRpYWxHcm91cERhdGEuc2VsZWN0ZWRCeUl0ZW1JZHMsIGN1ckdyb3VwRGF0YS5zZWxlY3RlZEJ5SXRlbUlkcyk7XG4gIH0pO1xufTtcblxuZXhwb3J0IHsgREVGQVVMVF9TSEFSSU5HX0RFVEFJTCBhcyBELCBnZXRVc2VybmFtZVF1ZXJ5IGFzIGEsIHNob3dSZXZlcnRHcm91cFdhcm5pbmcgYXMgYiwgc2hvd1JldmVydFNoYXJlTGV2ZWxXYXJuaW5nIGFzIGMsIERFRkFVTFRfU0hBUkVfTEVWRUxTIGFzIGQsIHNob3dTaGFyZUxldmVsQ2hhbmdlV2FybmluZyBhcyBlLCBpc1NoYXJlTGV2ZWxEaXJ0eSBhcyBmLCBnZXRJdGVtc0FuZEdyb3Vwc1RvVXBkYXRlU2hhcmUgYXMgZywgZ2V0UG9zc2libGVTaGFyZUxldmVsIGFzIGgsIGlzU2VsZWN0ZWRHcm91cERhdGFEaXJ0eSBhcyBpLCBnZXRTaGFyZU1vZGUgYXMgaiwgY2FuU2hhcmVJdGVtVG9Hcm91cCBhcyBrLCBjaGVja0lmU2hhcmluZ01peGVkIGFzIGwsIHNob3dFZGl0R3JvdXBXYXJuaW5nIGFzIHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==