"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_layer--66fd57"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/layer-ee0d645e.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/layer-ee0d645e.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AOI),
/* harmony export */   N: () => (/* binding */ NavigationTab),
/* harmony export */   a: () => (/* binding */ getImageItemCount),
/* harmony export */   b: () => (/* binding */ buildLayerQuery),
/* harmony export */   c: () => (/* binding */ getFilteredImageItems),
/* harmony export */   d: () => (/* binding */ getDefaultImageItemCardDisplayedFields),
/* harmony export */   e: () => (/* binding */ getMinAndMaxValuesForLayerField),
/* harmony export */   f: () => (/* binding */ getUniqueValuesForLayerField),
/* harmony export */   g: () => (/* binding */ getFilteredVisibleImageItems),
/* harmony export */   h: () => (/* binding */ getSupportedLayerFields),
/* harmony export */   i: () => (/* binding */ isAbortedError),
/* harmony export */   j: () => (/* binding */ getDefaultSelectedLayerField),
/* harmony export */   k: () => (/* binding */ isNumericFieldType),
/* harmony export */   l: () => (/* binding */ getFormattedDateString),
/* harmony export */   m: () => (/* binding */ getImageItemGeometry)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



var NavigationTab;
(function (NavigationTab) {
  NavigationTab["Inspect"] = "inspect";
  NavigationTab["Select"] = "select";
})(NavigationTab || (NavigationTab = {}));
var AOI;
(function (AOI) {
  AOI["Visible"] = "visible";
  AOI["DisplayExtent"] = "displayExtent";
  AOI["All"] = "all";
})(AOI || (AOI = {}));
/**
 * check if the error is abort error.
 *
 * @param error
 */
function isAbortedError(error) {
  return (error === null || error === void 0 ? void 0 : error.name) === "AbortError";
}
/**
 * check if field type is numeric type.
 *
 * @param fieldType
 */
function isNumericFieldType(fieldType) {
  const numericFieldTypes = ["small-integer", "big-integer", "integer", "single", "double", "oid"];
  return numericFieldTypes.includes(fieldType);
}
/**
 * get formatted date string from a timestamp.
 *
 * @param unixTimestamp timestamp
 * @returns date string in the format of "yyyy-mm-dd hh:mm:ss"
 */
function getFormattedDateString(unixTimestamp) {
  const dateObj = new Date(unixTimestamp);
  return `${dateObj.getFullYear()}-${padString((dateObj.getMonth() + 1).toString(), 2, "0")}-${padString(dateObj.getDate().toString(), 2, "0")} ${padString(dateObj.getHours().toString(), 2, "0")}:${padString(dateObj.getMinutes().toString(), 2, "0")}:${padString(dateObj.getSeconds().toString(), 2, "0")}`;
}
function padString(str, targetLength, padString) {
  padString = padString || " ";
  while (str.length < targetLength) {
    str = padString + str;
  }
  return str;
}

/**
 * get the default selected layer field for a given layer
 *
 * @param layerFields - layer's fields
 * @returns __esri.Field - default selected layer field
 *
 */
function getDefaultSelectedLayerField(layerFields) {
  const bestField = layerFields.find((field) => field.name.toLowerCase() === "best");
  if (bestField) {
    return bestField;
  }
  const acquisitionDateField = layerFields.find((field) => field.name.toLowerCase() === "acquisitiondate");
  if (acquisitionDateField) {
    return acquisitionDateField;
  }
  const dateTypeField = layerFields.find((field) => field.name.toLowerCase() === "date");
  if (dateTypeField) {
    return dateTypeField;
  }
  const intOrDoubleTypeField = layerFields.find((field) => field.type === "double" || field.type === "integer");
  return intOrDoubleTypeField;
}
/**
 * get the image item count that match the query condition
 *
 * @param layer - imagery layer
 * @param query - layer query
 * @returns number - raster item count
 *
 */
async function getImageItemCount(layer, query) {
  let count;
  try {
    count = await layer.queryRasterCount(query);
  }
  catch (err) {
    console.log(err);
    //
  }
  return Number.isInteger(count) ? count : null;
}
/**
 * get image items that match the query condition
 *
 * @param layer - imagery layer
 * @param query - query
 * @returns __esri.FeatureSet - raster items
 *
 */
async function getFilteredImageItems(layer, query) {
  query.outFields = ["*"];
  query.returnGeometry = true;
  const res = await layer.queryRasters(query);
  return Array.isArray(res === null || res === void 0 ? void 0 : res.features) ? res : null;
}
/**
 * get the geometry of image item
 *
 * @param layer - imagery layer
 * @param imageItemObjectID - image item object id
 * @returns __esri.Geometry - image item geometry
 *
 */
async function getImageItemGeometry(layer, imageItemObjectID) {
  var _a;
  const query = layer.createQuery();
  query.where = `${layer.objectIdField} = ${imageItemObjectID}`;
  query.returnGeometry = true;
  let res;
  try {
    res = await layer.queryRasters(query);
  }
  catch (err) {
    console.log(err);
    //
  }
  return ((_a = res === null || res === void 0 ? void 0 : res.features) === null || _a === void 0 ? void 0 : _a[0].geometry) || null;
}
/**
 * get default displayed fields for image item cards
 *
 * @param layer - imagery layer
 * @param selectedQueryField - current selected query field
 * @returns __esri.Field[] - default displayed fields
 *
 */
function getDefaultImageItemCardDisplayedFields(layer, selectedQueryField) {
  const layerFields = layer.fields;
  const layerObjectIdFieldName = layer.objectIdField;
  let defaultField = layerFields.find((field) => field.name.toLowerCase() === "name");
  if (!defaultField) {
    defaultField = layerFields.find((field) => field.name === layerObjectIdFieldName);
  }
  if (defaultField && defaultField.name !== selectedQueryField.name) {
    return [defaultField, selectedQueryField];
  }
  return [selectedQueryField];
}
/**
 * get supported layer fields based on field type for display and selection
 *
 * @param layerFields - imagery layer
 * @returns __esri.Field[] - supported fields
 *
 */
function getSupportedLayerFields(layerFields) {
  const supportedFieldTypes = ["small-integer", "big-integer", "integer", "single", "double", "date", "oid", "string"];
  return Array.isArray(layerFields) ? layerFields.filter((field) => supportedFieldTypes.includes(field.type)) : [];
}
/**
 * build layer query
 *
 * @param layerFields - imagery layer
 * @param queryField  - query field
 * @param queryValue - query value
 * @param selectedAOI - selected area of interest
 * @param isOverviewsIncluded - is Overviews included
 * @param mapExtent - map extent
 * @returns __esri.Query - layer query
 *
 */
function buildLayerQuery(layer, queryField, queryValues, selectedAOI, isOverviewsIncluded, mapExtent) {
  const query = layer.createQuery();
  if ((queryValues === null || queryValues === void 0 ? void 0 : queryValues.length) > 0) {
    let queryValueWhereClause = "";
    if (queryField.type === "date") {
      if (queryValues.length === 1) {
        const startDate = new Date(queryValues[0]);
        const endDateTimestamp = startDate.setSeconds(startDate.getSeconds() + 1);
        queryValueWhereClause = queryValueWhereClause = `${queryField.name} BETWEEN timestamp '${getFormattedDateString(queryValues[0])}' AND timestamp '${getFormattedDateString(endDateTimestamp)}'`;
      }
      if (queryValues.length === 2) {
        queryValueWhereClause = `${queryField.name} BETWEEN timestamp '${getFormattedDateString(queryValues[0])}' AND timestamp '${getFormattedDateString(queryValues[1])}'`;
      }
    }
    else {
      if (queryValues.length === 1) {
        queryValueWhereClause =
          typeof queryValues[0] === "string"
            ? `${queryField.name}='${queryValues[0]}'`
            : `${queryField.name}=${queryValues[0]}`;
      }
      if (queryValues.length === 2) {
        queryValueWhereClause =
          typeof queryValues[0] === "string"
            ? `${queryField.name} BETWEEN '${queryValues[0]}' AND '${queryValues[1]}'`
            : `${queryField.name} BETWEEN ${queryValues[0]} AND ${queryValues[1]}`;
      }
    }
    query.where = queryValueWhereClause;
  }
  const queryOverviewWhereClause = "(Category <> 2)";
  if (!isOverviewsIncluded) {
    const newWhereClause = queryOverviewWhereClause + (query.where ? " AND " + query.where : "");
    query.where = newWhereClause;
  }
  else {
    query.where = query.where.replace(queryOverviewWhereClause, "");
  }
  query.geometry = selectedAOI === AOI.DisplayExtent ? mapExtent : null;
  query.spatialRelationship = selectedAOI === AOI.DisplayExtent ? "intersects" : null;
  return query;
}
/**
 * get unique value for an attribute field in the imagery layer
 *
 * @param layer - imagery layer
 * @param queryFieldName - query field name
 * @param selectedAOI - selected AOI
 * @param mapExtent - map extent
 * @param abortSignal - abort signal
 * @param isFetchingAll - whether is fetching all results
 * @returns Array<string | number> - unique value array
 */
async function getUniqueValuesForLayerField(layer, queryField, selectedAOI, mapExtent, abortSignal, isFetchingAll = false) {
  var _a, _b;
  if (!queryField)
    return [];
  const query = layer.createQuery();
  query.where = "1=1";
  const isConstrainedByMapExtent = selectedAOI === AOI.DisplayExtent || selectedAOI === AOI.Visible;
  query.geometry = isConstrainedByMapExtent ? mapExtent : null;
  query.spatialRelationship = isConstrainedByMapExtent ? "intersects" : null;
  query.outFields = [queryField];
  query.orderByFields = [`${queryField} ASC`];
  query.returnExceededLimitFeatures = true;
  query.returnGeometry = false;
  const resultValues = [];
  if (isFetchingAll) {
    let hasMore = true;
    while (hasMore) {
      const res = await layer.queryRasters(query, { signal: abortSignal });
      hasMore = res === null || res === void 0 ? void 0 : res.exceededTransferLimit;
      if (((_a = res.features) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        const valuesToAdd = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.b)(res.features.map((feature) => feature.attributes[queryField]));
        resultValues.push(...valuesToAdd);
      }
    }
    return resultValues;
  }
  const res = await layer.queryRasters(query, { signal: abortSignal });
  if (((_b = res === null || res === void 0 ? void 0 : res.features) === null || _b === void 0 ? void 0 : _b.length) > 0) {
    const valuesToAdd = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.b)(res.features.map((feature) => feature.attributes[queryField]));
    return valuesToAdd;
  }
  return [];
}
/**
 * get min/max value for an attribute field in the imagery layer
 *
 * @param layer - imagery layer
 * @param queryFieldName - query field name
 * @param selectedAOI - selected AOI
 * @param mapExtent - map extent
 * @param abortSignal - abort signal
 * @returns Array<string | number> - min/max value array [min, max]
 */
async function getMinAndMaxValuesForLayerField(layer, queryFieldName, selectedAOI, mapExtent, abortSignal) {
  var _a;
  if (!queryFieldName)
    return [];
  const query = layer.createQuery();
  query.where = "1=1";
  const isConstrainedByMapExtent = selectedAOI === AOI.DisplayExtent || selectedAOI === AOI.Visible;
  query.geometry = isConstrainedByMapExtent ? mapExtent : null;
  query.spatialRelationship = isConstrainedByMapExtent ? "intersects" : null;
  query.returnGeometry = false;
  query.outStatistics = [
    {
      statisticType: "min",
      onStatisticField: queryFieldName,
      outStatisticFieldName: "MIN_FIELD_VALUE"
    },
    {
      statisticType: "max",
      onStatisticField: queryFieldName,
      outStatisticFieldName: "MAX_FIELD_VALUE"
    }
  ];
  const res = await layer.queryRasters(query, { signal: abortSignal });
  if (((_a = res === null || res === void 0 ? void 0 : res.features) === null || _a === void 0 ? void 0 : _a.length) > 0) {
    const [feature] = res.features;
    return [feature.attributes["MIN_FIELD_VALUE"], feature.attributes["MAX_FIELD_VALUE"]];
  }
  return [];
}
/**
 * generate the parameters for imagery layer identify function
 *
 * @param layer - imagery layer
 * @param mapView - current map view
 * @returns __esri.ImageIdentifyParameters
 */
async function generateIdentifyParams(layer, mapView) {
  const [Polygon, Point, ImageIdentifyParameters] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)([
    "esri/geometry/Polygon",
    "esri/geometry/Point",
    "esri/rest/support/ImageIdentifyParameters"
  ]);
  const { extent, width, height } = mapView;
  const polygon = new Polygon(extent.spatialReference);
  polygon.addRing([
    [extent.xmin, extent.ymin],
    [extent.xmin, extent.ymax],
    [extent.xmax, extent.ymax],
    [extent.xmax, extent.ymin],
    [extent.xmin, extent.ymin]
  ]);
  const psX = (extent.xmax - extent.xmin) / width;
  const psY = (extent.ymax - extent.ymin) / height;
  const pixelSize = new Point(psX, psY, extent.spatialReference);
  const identifyParams = new ImageIdentifyParameters();
  identifyParams.geometry = polygon;
  identifyParams.returnGeometry = false;
  identifyParams.pixelSize = pixelSize;
  const mosaicRule = layer.mosaicRule.clone();
  if (layer.definitionExpression) {
    mosaicRule.where = layer.definitionExpression;
  }
  identifyParams.mosaicRule = mosaicRule;
  return identifyParams;
}
/**
 * get visible image items that match the query condition
 *
 * @param layer - imagery layer
 * @param mapView - current map view
 * @param layerQuery - current map view
 * @returns __esri.FeatureSet - raster items
 */
async function getFilteredVisibleImageItems(layer, mapView, layerQuery) {
  var _a;
  let visibleImageItemObjectIds = [];
  const identifyParams = await generateIdentifyParams(layer, mapView);
  if (layer.visible) {
    const identifyResult = await layer.identify(identifyParams);
    if (!((_a = identifyResult === null || identifyResult === void 0 ? void 0 : identifyResult.catalogItems) === null || _a === void 0 ? void 0 : _a.features) || !(identifyResult === null || identifyResult === void 0 ? void 0 : identifyResult.catalogItemVisibilities))
      return null;
    const objectIdFieldName = layer.objectIdField;
    for (let i = 0; i < identifyResult.catalogItems.features.length; i++) {
      if (identifyResult.catalogItemVisibilities[i] > 0) {
        visibleImageItemObjectIds.push(identifyResult.catalogItems.features[i].attributes[objectIdFieldName]);
      }
    }
    if (visibleImageItemObjectIds.length === 0)
      return null;
    const objectIdQueryString = `${layer.objectIdField} in (${visibleImageItemObjectIds
      .map((oid) => `${oid}`)
      .join(",")})`;
    layerQuery.where = `${layerQuery.where} AND ${objectIdQueryString}`;
    layerQuery.outFields = ["*"];
    layerQuery.returnGeometry = true;
    const res = await layer.queryRasters(layerQuery);
    return Array.isArray(res === null || res === void 0 ? void 0 : res.features) ? res : null;
  }
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fbGF5ZXItLTY2ZmQ1Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJEQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFpRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCLE1BQU07QUFDOUQsdUJBQXVCLElBQUk7QUFDM0IsaUJBQWlCO0FBQ2pCLDBCQUEwQixrQkFBa0IsTUFBTSxvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrYiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGF5ZXItZWUwZDY0NWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gIGxldCB0aW1lb3V0O1xuICBsZXQgc3RhdHVzID0gXCJpZGxlXCI7XG4gIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImZsdXNoZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJpbnZva2VkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfVxuICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIGRlYm91bmNlZC5pbnZva2UgPSBpbnZva2U7XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBuIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWRcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCB0aHJvdHRsZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgfSwgZGVsYXkpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogU2V0IGEgbWluaW11bSB0aW1lIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZSAodXNlZnVsIGZvciBwcmV2ZW50aW5nIGZsYXNoIG9mIGxvYWRlcnMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pbkRlbGF5KHByb21pc2UsIG1pbkRlbGF5KSB7XG4gIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBpbmxpbmUgc2V0VGltZW91dCBhcyBhbiBhd2FpdCBpbiBhc3luYyBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gdGltZW91dChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbmNvbnN0IGFycmF5VG9Mb29rdXBNYXAgPSAoZGF0YUFyciwgZ2V0S2V5QW5kSXRlbSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKChkYXRhQXJyIHx8IFtdKS5tYXAoKGl0ZW0pID0+IHtcbiAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gIHJldHVybiBba2V5LCBkYXRhXTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBhbmQgd2hldGhlciB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHNcbiAqIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAqL1xuY29uc3QgYXJyYXlzQXJlRXF1aXZhbGVudCA9IChhcnIxLCBhcnIyKSA9PiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5yZWR1Y2UoKG1lbW8sIHN0cikgPT4gbWVtbyAmJiBhcnIyLmluZGV4T2Yoc3RyKSA+IC0xLCB0cnVlKTtcbmZ1bmN0aW9uIHVuaXF1ZUJ5KG15QXJyLCBnZXRJdGVtSWQpIHtcbiAgY29uc3QgcmVzdWx0QXJyID0gW107XG4gIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICBteUFyci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgaWYgKGxvb2t1cE1hcFtpZF0gPT0gbnVsbCkge1xuICAgICAgbG9va3VwTWFwW2lkXSA9IGl0ZW07XG4gICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gIGNvbnN0IHByaW1pdGl2ZXMgPSB7IGJvb2xlYW46IHt9LCBudW1iZXI6IHt9LCBzdHJpbmc6IHt9IH07XG4gIGNvbnN0IG9ianMgPSBbXTtcbiAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgIGxldCB0eXBlID0gdHlwZW9mIGl0ZW07XG4gICAgaWYgKHR5cGUgaW4gcHJpbWl0aXZlcykge1xuICAgICAgcmV0dXJuIHByaW1pdGl2ZXNbdHlwZV0uaGFzT3duUHJvcGVydHkoaXRlbSkgPyBmYWxzZSA6IChwcmltaXRpdmVzW3R5cGVdW2l0ZW1dID0gdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9ianMuaW5kZXhPZihpdGVtKSA+PSAwID8gZmFsc2UgOiBvYmpzLnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IGNodW5rID0gKGFyciwgc2l6ZSkgPT4gWy4uLkFycmF5KE1hdGguY2VpbChhcnIubGVuZ3RoIC8gc2l6ZSkpXS5tYXAoKF8sIGkpID0+IGFyci5zbGljZShzaXplICogaSwgc2l6ZSArIHNpemUgKiBpKSk7XG5cbmV4cG9ydCB7IGFycmF5VG9Mb29rdXBNYXAgYXMgYSwgdW5pcXVlIGFzIGIsIHRocm90dGxlIGFzIGMsIGRlYm91bmNlIGFzIGQsIGVzY2FwZVJlZ0V4cCBhcyBlLCBhcnJheXNBcmVFcXVpdmFsZW50IGFzIGYsIGNodW5rIGFzIGcsIGlzRGVmaW5lZCBhcyBpLCBtaW5EZWxheSBhcyBtLCB0aW1lb3V0IGFzIHQsIHVuaXF1ZUJ5IGFzIHUgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYWFmMzBiZDYuanMnO1xuaW1wb3J0IHsgYiBhcyB1bmlxdWUgfSBmcm9tICcuL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMnO1xuXG52YXIgTmF2aWdhdGlvblRhYjtcbihmdW5jdGlvbiAoTmF2aWdhdGlvblRhYikge1xuICBOYXZpZ2F0aW9uVGFiW1wiSW5zcGVjdFwiXSA9IFwiaW5zcGVjdFwiO1xuICBOYXZpZ2F0aW9uVGFiW1wiU2VsZWN0XCJdID0gXCJzZWxlY3RcIjtcbn0pKE5hdmlnYXRpb25UYWIgfHwgKE5hdmlnYXRpb25UYWIgPSB7fSkpO1xudmFyIEFPSTtcbihmdW5jdGlvbiAoQU9JKSB7XG4gIEFPSVtcIlZpc2libGVcIl0gPSBcInZpc2libGVcIjtcbiAgQU9JW1wiRGlzcGxheUV4dGVudFwiXSA9IFwiZGlzcGxheUV4dGVudFwiO1xuICBBT0lbXCJBbGxcIl0gPSBcImFsbFwiO1xufSkoQU9JIHx8IChBT0kgPSB7fSkpO1xuLyoqXG4gKiBjaGVjayBpZiB0aGUgZXJyb3IgaXMgYWJvcnQgZXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yXG4gKi9cbmZ1bmN0aW9uIGlzQWJvcnRlZEVycm9yKGVycm9yKSB7XG4gIHJldHVybiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkFib3J0RXJyb3JcIjtcbn1cbi8qKlxuICogY2hlY2sgaWYgZmllbGQgdHlwZSBpcyBudW1lcmljIHR5cGUuXG4gKlxuICogQHBhcmFtIGZpZWxkVHlwZVxuICovXG5mdW5jdGlvbiBpc051bWVyaWNGaWVsZFR5cGUoZmllbGRUeXBlKSB7XG4gIGNvbnN0IG51bWVyaWNGaWVsZFR5cGVzID0gW1wic21hbGwtaW50ZWdlclwiLCBcImJpZy1pbnRlZ2VyXCIsIFwiaW50ZWdlclwiLCBcInNpbmdsZVwiLCBcImRvdWJsZVwiLCBcIm9pZFwiXTtcbiAgcmV0dXJuIG51bWVyaWNGaWVsZFR5cGVzLmluY2x1ZGVzKGZpZWxkVHlwZSk7XG59XG4vKipcbiAqIGdldCBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgZnJvbSBhIHRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0gdW5peFRpbWVzdGFtcCB0aW1lc3RhbXBcbiAqIEByZXR1cm5zIGRhdGUgc3RyaW5nIGluIHRoZSBmb3JtYXQgb2YgXCJ5eXl5LW1tLWRkIGhoOm1tOnNzXCJcbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkRGF0ZVN0cmluZyh1bml4VGltZXN0YW1wKSB7XG4gIGNvbnN0IGRhdGVPYmogPSBuZXcgRGF0ZSh1bml4VGltZXN0YW1wKTtcbiAgcmV0dXJuIGAke2RhdGVPYmouZ2V0RnVsbFllYXIoKX0tJHtwYWRTdHJpbmcoKGRhdGVPYmouZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCksIDIsIFwiMFwiKX0tJHtwYWRTdHJpbmcoZGF0ZU9iai5nZXREYXRlKCkudG9TdHJpbmcoKSwgMiwgXCIwXCIpfSAke3BhZFN0cmluZyhkYXRlT2JqLmdldEhvdXJzKCkudG9TdHJpbmcoKSwgMiwgXCIwXCIpfToke3BhZFN0cmluZyhkYXRlT2JqLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLCAyLCBcIjBcIil9OiR7cGFkU3RyaW5nKGRhdGVPYmouZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCksIDIsIFwiMFwiKX1gO1xufVxuZnVuY3Rpb24gcGFkU3RyaW5nKHN0ciwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgcGFkU3RyaW5nID0gcGFkU3RyaW5nIHx8IFwiIFwiO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIHN0ciA9IHBhZFN0cmluZyArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIGdldCB0aGUgZGVmYXVsdCBzZWxlY3RlZCBsYXllciBmaWVsZCBmb3IgYSBnaXZlbiBsYXllclxuICpcbiAqIEBwYXJhbSBsYXllckZpZWxkcyAtIGxheWVyJ3MgZmllbGRzXG4gKiBAcmV0dXJucyBfX2VzcmkuRmllbGQgLSBkZWZhdWx0IHNlbGVjdGVkIGxheWVyIGZpZWxkXG4gKlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0U2VsZWN0ZWRMYXllckZpZWxkKGxheWVyRmllbGRzKSB7XG4gIGNvbnN0IGJlc3RGaWVsZCA9IGxheWVyRmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYmVzdFwiKTtcbiAgaWYgKGJlc3RGaWVsZCkge1xuICAgIHJldHVybiBiZXN0RmllbGQ7XG4gIH1cbiAgY29uc3QgYWNxdWlzaXRpb25EYXRlRmllbGQgPSBsYXllckZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImFjcXVpc2l0aW9uZGF0ZVwiKTtcbiAgaWYgKGFjcXVpc2l0aW9uRGF0ZUZpZWxkKSB7XG4gICAgcmV0dXJuIGFjcXVpc2l0aW9uRGF0ZUZpZWxkO1xuICB9XG4gIGNvbnN0IGRhdGVUeXBlRmllbGQgPSBsYXllckZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImRhdGVcIik7XG4gIGlmIChkYXRlVHlwZUZpZWxkKSB7XG4gICAgcmV0dXJuIGRhdGVUeXBlRmllbGQ7XG4gIH1cbiAgY29uc3QgaW50T3JEb3VibGVUeXBlRmllbGQgPSBsYXllckZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gXCJkb3VibGVcIiB8fCBmaWVsZC50eXBlID09PSBcImludGVnZXJcIik7XG4gIHJldHVybiBpbnRPckRvdWJsZVR5cGVGaWVsZDtcbn1cbi8qKlxuICogZ2V0IHRoZSBpbWFnZSBpdGVtIGNvdW50IHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGNvbmRpdGlvblxuICpcbiAqIEBwYXJhbSBsYXllciAtIGltYWdlcnkgbGF5ZXJcbiAqIEBwYXJhbSBxdWVyeSAtIGxheWVyIHF1ZXJ5XG4gKiBAcmV0dXJucyBudW1iZXIgLSByYXN0ZXIgaXRlbSBjb3VudFxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2VJdGVtQ291bnQobGF5ZXIsIHF1ZXJ5KSB7XG4gIGxldCBjb3VudDtcbiAgdHJ5IHtcbiAgICBjb3VudCA9IGF3YWl0IGxheWVyLnF1ZXJ5UmFzdGVyQ291bnQocXVlcnkpO1xuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgIC8vXG4gIH1cbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoY291bnQpID8gY291bnQgOiBudWxsO1xufVxuLyoqXG4gKiBnZXQgaW1hZ2UgaXRlbXMgdGhhdCBtYXRjaCB0aGUgcXVlcnkgY29uZGl0aW9uXG4gKlxuICogQHBhcmFtIGxheWVyIC0gaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIHF1ZXJ5IC0gcXVlcnlcbiAqIEByZXR1cm5zIF9fZXNyaS5GZWF0dXJlU2V0IC0gcmFzdGVyIGl0ZW1zXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRGaWx0ZXJlZEltYWdlSXRlbXMobGF5ZXIsIHF1ZXJ5KSB7XG4gIHF1ZXJ5Lm91dEZpZWxkcyA9IFtcIipcIl07XG4gIHF1ZXJ5LnJldHVybkdlb21ldHJ5ID0gdHJ1ZTtcbiAgY29uc3QgcmVzID0gYXdhaXQgbGF5ZXIucXVlcnlSYXN0ZXJzKHF1ZXJ5KTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVzID09PSBudWxsIHx8IHJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzLmZlYXR1cmVzKSA/IHJlcyA6IG51bGw7XG59XG4vKipcbiAqIGdldCB0aGUgZ2VvbWV0cnkgb2YgaW1hZ2UgaXRlbVxuICpcbiAqIEBwYXJhbSBsYXllciAtIGltYWdlcnkgbGF5ZXJcbiAqIEBwYXJhbSBpbWFnZUl0ZW1PYmplY3RJRCAtIGltYWdlIGl0ZW0gb2JqZWN0IGlkXG4gKiBAcmV0dXJucyBfX2VzcmkuR2VvbWV0cnkgLSBpbWFnZSBpdGVtIGdlb21ldHJ5XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZUl0ZW1HZW9tZXRyeShsYXllciwgaW1hZ2VJdGVtT2JqZWN0SUQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gIHF1ZXJ5LndoZXJlID0gYCR7bGF5ZXIub2JqZWN0SWRGaWVsZH0gPSAke2ltYWdlSXRlbU9iamVjdElEfWA7XG4gIHF1ZXJ5LnJldHVybkdlb21ldHJ5ID0gdHJ1ZTtcbiAgbGV0IHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhd2FpdCBsYXllci5xdWVyeVJhc3RlcnMocXVlcnkpO1xuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgIC8vXG4gIH1cbiAgcmV0dXJuICgoX2EgPSByZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMuZmVhdHVyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXS5nZW9tZXRyeSkgfHwgbnVsbDtcbn1cbi8qKlxuICogZ2V0IGRlZmF1bHQgZGlzcGxheWVkIGZpZWxkcyBmb3IgaW1hZ2UgaXRlbSBjYXJkc1xuICpcbiAqIEBwYXJhbSBsYXllciAtIGltYWdlcnkgbGF5ZXJcbiAqIEBwYXJhbSBzZWxlY3RlZFF1ZXJ5RmllbGQgLSBjdXJyZW50IHNlbGVjdGVkIHF1ZXJ5IGZpZWxkXG4gKiBAcmV0dXJucyBfX2VzcmkuRmllbGRbXSAtIGRlZmF1bHQgZGlzcGxheWVkIGZpZWxkc1xuICpcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEltYWdlSXRlbUNhcmREaXNwbGF5ZWRGaWVsZHMobGF5ZXIsIHNlbGVjdGVkUXVlcnlGaWVsZCkge1xuICBjb25zdCBsYXllckZpZWxkcyA9IGxheWVyLmZpZWxkcztcbiAgY29uc3QgbGF5ZXJPYmplY3RJZEZpZWxkTmFtZSA9IGxheWVyLm9iamVjdElkRmllbGQ7XG4gIGxldCBkZWZhdWx0RmllbGQgPSBsYXllckZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcIm5hbWVcIik7XG4gIGlmICghZGVmYXVsdEZpZWxkKSB7XG4gICAgZGVmYXVsdEZpZWxkID0gbGF5ZXJGaWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGxheWVyT2JqZWN0SWRGaWVsZE5hbWUpO1xuICB9XG4gIGlmIChkZWZhdWx0RmllbGQgJiYgZGVmYXVsdEZpZWxkLm5hbWUgIT09IHNlbGVjdGVkUXVlcnlGaWVsZC5uYW1lKSB7XG4gICAgcmV0dXJuIFtkZWZhdWx0RmllbGQsIHNlbGVjdGVkUXVlcnlGaWVsZF07XG4gIH1cbiAgcmV0dXJuIFtzZWxlY3RlZFF1ZXJ5RmllbGRdO1xufVxuLyoqXG4gKiBnZXQgc3VwcG9ydGVkIGxheWVyIGZpZWxkcyBiYXNlZCBvbiBmaWVsZCB0eXBlIGZvciBkaXNwbGF5IGFuZCBzZWxlY3Rpb25cbiAqXG4gKiBAcGFyYW0gbGF5ZXJGaWVsZHMgLSBpbWFnZXJ5IGxheWVyXG4gKiBAcmV0dXJucyBfX2VzcmkuRmllbGRbXSAtIHN1cHBvcnRlZCBmaWVsZHNcbiAqXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZExheWVyRmllbGRzKGxheWVyRmllbGRzKSB7XG4gIGNvbnN0IHN1cHBvcnRlZEZpZWxkVHlwZXMgPSBbXCJzbWFsbC1pbnRlZ2VyXCIsIFwiYmlnLWludGVnZXJcIiwgXCJpbnRlZ2VyXCIsIFwic2luZ2xlXCIsIFwiZG91YmxlXCIsIFwiZGF0ZVwiLCBcIm9pZFwiLCBcInN0cmluZ1wiXTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobGF5ZXJGaWVsZHMpID8gbGF5ZXJGaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gc3VwcG9ydGVkRmllbGRUeXBlcy5pbmNsdWRlcyhmaWVsZC50eXBlKSkgOiBbXTtcbn1cbi8qKlxuICogYnVpbGQgbGF5ZXIgcXVlcnlcbiAqXG4gKiBAcGFyYW0gbGF5ZXJGaWVsZHMgLSBpbWFnZXJ5IGxheWVyXG4gKiBAcGFyYW0gcXVlcnlGaWVsZCAgLSBxdWVyeSBmaWVsZFxuICogQHBhcmFtIHF1ZXJ5VmFsdWUgLSBxdWVyeSB2YWx1ZVxuICogQHBhcmFtIHNlbGVjdGVkQU9JIC0gc2VsZWN0ZWQgYXJlYSBvZiBpbnRlcmVzdFxuICogQHBhcmFtIGlzT3ZlcnZpZXdzSW5jbHVkZWQgLSBpcyBPdmVydmlld3MgaW5jbHVkZWRcbiAqIEBwYXJhbSBtYXBFeHRlbnQgLSBtYXAgZXh0ZW50XG4gKiBAcmV0dXJucyBfX2VzcmkuUXVlcnkgLSBsYXllciBxdWVyeVxuICpcbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXllclF1ZXJ5KGxheWVyLCBxdWVyeUZpZWxkLCBxdWVyeVZhbHVlcywgc2VsZWN0ZWRBT0ksIGlzT3ZlcnZpZXdzSW5jbHVkZWQsIG1hcEV4dGVudCkge1xuICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gIGlmICgocXVlcnlWYWx1ZXMgPT09IG51bGwgfHwgcXVlcnlWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHF1ZXJ5VmFsdWVzLmxlbmd0aCkgPiAwKSB7XG4gICAgbGV0IHF1ZXJ5VmFsdWVXaGVyZUNsYXVzZSA9IFwiXCI7XG4gICAgaWYgKHF1ZXJ5RmllbGQudHlwZSA9PT0gXCJkYXRlXCIpIHtcbiAgICAgIGlmIChxdWVyeVZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUocXVlcnlWYWx1ZXNbMF0pO1xuICAgICAgICBjb25zdCBlbmREYXRlVGltZXN0YW1wID0gc3RhcnREYXRlLnNldFNlY29uZHMoc3RhcnREYXRlLmdldFNlY29uZHMoKSArIDEpO1xuICAgICAgICBxdWVyeVZhbHVlV2hlcmVDbGF1c2UgPSBxdWVyeVZhbHVlV2hlcmVDbGF1c2UgPSBgJHtxdWVyeUZpZWxkLm5hbWV9IEJFVFdFRU4gdGltZXN0YW1wICcke2dldEZvcm1hdHRlZERhdGVTdHJpbmcocXVlcnlWYWx1ZXNbMF0pfScgQU5EIHRpbWVzdGFtcCAnJHtnZXRGb3JtYXR0ZWREYXRlU3RyaW5nKGVuZERhdGVUaW1lc3RhbXApfSdgO1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXJ5VmFsdWVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBxdWVyeVZhbHVlV2hlcmVDbGF1c2UgPSBgJHtxdWVyeUZpZWxkLm5hbWV9IEJFVFdFRU4gdGltZXN0YW1wICcke2dldEZvcm1hdHRlZERhdGVTdHJpbmcocXVlcnlWYWx1ZXNbMF0pfScgQU5EIHRpbWVzdGFtcCAnJHtnZXRGb3JtYXR0ZWREYXRlU3RyaW5nKHF1ZXJ5VmFsdWVzWzFdKX0nYDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAocXVlcnlWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHF1ZXJ5VmFsdWVXaGVyZUNsYXVzZSA9XG4gICAgICAgICAgdHlwZW9mIHF1ZXJ5VmFsdWVzWzBdID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGAke3F1ZXJ5RmllbGQubmFtZX09JyR7cXVlcnlWYWx1ZXNbMF19J2BcbiAgICAgICAgICAgIDogYCR7cXVlcnlGaWVsZC5uYW1lfT0ke3F1ZXJ5VmFsdWVzWzBdfWA7XG4gICAgICB9XG4gICAgICBpZiAocXVlcnlWYWx1ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHF1ZXJ5VmFsdWVXaGVyZUNsYXVzZSA9XG4gICAgICAgICAgdHlwZW9mIHF1ZXJ5VmFsdWVzWzBdID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGAke3F1ZXJ5RmllbGQubmFtZX0gQkVUV0VFTiAnJHtxdWVyeVZhbHVlc1swXX0nIEFORCAnJHtxdWVyeVZhbHVlc1sxXX0nYFxuICAgICAgICAgICAgOiBgJHtxdWVyeUZpZWxkLm5hbWV9IEJFVFdFRU4gJHtxdWVyeVZhbHVlc1swXX0gQU5EICR7cXVlcnlWYWx1ZXNbMV19YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcXVlcnkud2hlcmUgPSBxdWVyeVZhbHVlV2hlcmVDbGF1c2U7XG4gIH1cbiAgY29uc3QgcXVlcnlPdmVydmlld1doZXJlQ2xhdXNlID0gXCIoQ2F0ZWdvcnkgPD4gMilcIjtcbiAgaWYgKCFpc092ZXJ2aWV3c0luY2x1ZGVkKSB7XG4gICAgY29uc3QgbmV3V2hlcmVDbGF1c2UgPSBxdWVyeU92ZXJ2aWV3V2hlcmVDbGF1c2UgKyAocXVlcnkud2hlcmUgPyBcIiBBTkQgXCIgKyBxdWVyeS53aGVyZSA6IFwiXCIpO1xuICAgIHF1ZXJ5LndoZXJlID0gbmV3V2hlcmVDbGF1c2U7XG4gIH1cbiAgZWxzZSB7XG4gICAgcXVlcnkud2hlcmUgPSBxdWVyeS53aGVyZS5yZXBsYWNlKHF1ZXJ5T3ZlcnZpZXdXaGVyZUNsYXVzZSwgXCJcIik7XG4gIH1cbiAgcXVlcnkuZ2VvbWV0cnkgPSBzZWxlY3RlZEFPSSA9PT0gQU9JLkRpc3BsYXlFeHRlbnQgPyBtYXBFeHRlbnQgOiBudWxsO1xuICBxdWVyeS5zcGF0aWFsUmVsYXRpb25zaGlwID0gc2VsZWN0ZWRBT0kgPT09IEFPSS5EaXNwbGF5RXh0ZW50ID8gXCJpbnRlcnNlY3RzXCIgOiBudWxsO1xuICByZXR1cm4gcXVlcnk7XG59XG4vKipcbiAqIGdldCB1bmlxdWUgdmFsdWUgZm9yIGFuIGF0dHJpYnV0ZSBmaWVsZCBpbiB0aGUgaW1hZ2VyeSBsYXllclxuICpcbiAqIEBwYXJhbSBsYXllciAtIGltYWdlcnkgbGF5ZXJcbiAqIEBwYXJhbSBxdWVyeUZpZWxkTmFtZSAtIHF1ZXJ5IGZpZWxkIG5hbWVcbiAqIEBwYXJhbSBzZWxlY3RlZEFPSSAtIHNlbGVjdGVkIEFPSVxuICogQHBhcmFtIG1hcEV4dGVudCAtIG1hcCBleHRlbnRcbiAqIEBwYXJhbSBhYm9ydFNpZ25hbCAtIGFib3J0IHNpZ25hbFxuICogQHBhcmFtIGlzRmV0Y2hpbmdBbGwgLSB3aGV0aGVyIGlzIGZldGNoaW5nIGFsbCByZXN1bHRzXG4gKiBAcmV0dXJucyBBcnJheTxzdHJpbmcgfCBudW1iZXI+IC0gdW5pcXVlIHZhbHVlIGFycmF5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFVuaXF1ZVZhbHVlc0ZvckxheWVyRmllbGQobGF5ZXIsIHF1ZXJ5RmllbGQsIHNlbGVjdGVkQU9JLCBtYXBFeHRlbnQsIGFib3J0U2lnbmFsLCBpc0ZldGNoaW5nQWxsID0gZmFsc2UpIHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKCFxdWVyeUZpZWxkKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcXVlcnkgPSBsYXllci5jcmVhdGVRdWVyeSgpO1xuICBxdWVyeS53aGVyZSA9IFwiMT0xXCI7XG4gIGNvbnN0IGlzQ29uc3RyYWluZWRCeU1hcEV4dGVudCA9IHNlbGVjdGVkQU9JID09PSBBT0kuRGlzcGxheUV4dGVudCB8fCBzZWxlY3RlZEFPSSA9PT0gQU9JLlZpc2libGU7XG4gIHF1ZXJ5Lmdlb21ldHJ5ID0gaXNDb25zdHJhaW5lZEJ5TWFwRXh0ZW50ID8gbWFwRXh0ZW50IDogbnVsbDtcbiAgcXVlcnkuc3BhdGlhbFJlbGF0aW9uc2hpcCA9IGlzQ29uc3RyYWluZWRCeU1hcEV4dGVudCA/IFwiaW50ZXJzZWN0c1wiIDogbnVsbDtcbiAgcXVlcnkub3V0RmllbGRzID0gW3F1ZXJ5RmllbGRdO1xuICBxdWVyeS5vcmRlckJ5RmllbGRzID0gW2Ake3F1ZXJ5RmllbGR9IEFTQ2BdO1xuICBxdWVyeS5yZXR1cm5FeGNlZWRlZExpbWl0RmVhdHVyZXMgPSB0cnVlO1xuICBxdWVyeS5yZXR1cm5HZW9tZXRyeSA9IGZhbHNlO1xuICBjb25zdCByZXN1bHRWYWx1ZXMgPSBbXTtcbiAgaWYgKGlzRmV0Y2hpbmdBbGwpIHtcbiAgICBsZXQgaGFzTW9yZSA9IHRydWU7XG4gICAgd2hpbGUgKGhhc01vcmUpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGxheWVyLnF1ZXJ5UmFzdGVycyhxdWVyeSwgeyBzaWduYWw6IGFib3J0U2lnbmFsIH0pO1xuICAgICAgaGFzTW9yZSA9IHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5leGNlZWRlZFRyYW5zZmVyTGltaXQ7XG4gICAgICBpZiAoKChfYSA9IHJlcy5mZWF0dXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlc1RvQWRkID0gdW5pcXVlKHJlcy5mZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IGZlYXR1cmUuYXR0cmlidXRlc1txdWVyeUZpZWxkXSkpO1xuICAgICAgICByZXN1bHRWYWx1ZXMucHVzaCguLi52YWx1ZXNUb0FkZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRWYWx1ZXM7XG4gIH1cbiAgY29uc3QgcmVzID0gYXdhaXQgbGF5ZXIucXVlcnlSYXN0ZXJzKHF1ZXJ5LCB7IHNpZ25hbDogYWJvcnRTaWduYWwgfSk7XG4gIGlmICgoKF9iID0gcmVzID09PSBudWxsIHx8IHJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzLmZlYXR1cmVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSA+IDApIHtcbiAgICBjb25zdCB2YWx1ZXNUb0FkZCA9IHVuaXF1ZShyZXMuZmVhdHVyZXMubWFwKChmZWF0dXJlKSA9PiBmZWF0dXJlLmF0dHJpYnV0ZXNbcXVlcnlGaWVsZF0pKTtcbiAgICByZXR1cm4gdmFsdWVzVG9BZGQ7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuLyoqXG4gKiBnZXQgbWluL21heCB2YWx1ZSBmb3IgYW4gYXR0cmlidXRlIGZpZWxkIGluIHRoZSBpbWFnZXJ5IGxheWVyXG4gKlxuICogQHBhcmFtIGxheWVyIC0gaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIHF1ZXJ5RmllbGROYW1lIC0gcXVlcnkgZmllbGQgbmFtZVxuICogQHBhcmFtIHNlbGVjdGVkQU9JIC0gc2VsZWN0ZWQgQU9JXG4gKiBAcGFyYW0gbWFwRXh0ZW50IC0gbWFwIGV4dGVudFxuICogQHBhcmFtIGFib3J0U2lnbmFsIC0gYWJvcnQgc2lnbmFsXG4gKiBAcmV0dXJucyBBcnJheTxzdHJpbmcgfCBudW1iZXI+IC0gbWluL21heCB2YWx1ZSBhcnJheSBbbWluLCBtYXhdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE1pbkFuZE1heFZhbHVlc0ZvckxheWVyRmllbGQobGF5ZXIsIHF1ZXJ5RmllbGROYW1lLCBzZWxlY3RlZEFPSSwgbWFwRXh0ZW50LCBhYm9ydFNpZ25hbCkge1xuICB2YXIgX2E7XG4gIGlmICghcXVlcnlGaWVsZE5hbWUpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gIHF1ZXJ5LndoZXJlID0gXCIxPTFcIjtcbiAgY29uc3QgaXNDb25zdHJhaW5lZEJ5TWFwRXh0ZW50ID0gc2VsZWN0ZWRBT0kgPT09IEFPSS5EaXNwbGF5RXh0ZW50IHx8IHNlbGVjdGVkQU9JID09PSBBT0kuVmlzaWJsZTtcbiAgcXVlcnkuZ2VvbWV0cnkgPSBpc0NvbnN0cmFpbmVkQnlNYXBFeHRlbnQgPyBtYXBFeHRlbnQgOiBudWxsO1xuICBxdWVyeS5zcGF0aWFsUmVsYXRpb25zaGlwID0gaXNDb25zdHJhaW5lZEJ5TWFwRXh0ZW50ID8gXCJpbnRlcnNlY3RzXCIgOiBudWxsO1xuICBxdWVyeS5yZXR1cm5HZW9tZXRyeSA9IGZhbHNlO1xuICBxdWVyeS5vdXRTdGF0aXN0aWNzID0gW1xuICAgIHtcbiAgICAgIHN0YXRpc3RpY1R5cGU6IFwibWluXCIsXG4gICAgICBvblN0YXRpc3RpY0ZpZWxkOiBxdWVyeUZpZWxkTmFtZSxcbiAgICAgIG91dFN0YXRpc3RpY0ZpZWxkTmFtZTogXCJNSU5fRklFTERfVkFMVUVcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3RhdGlzdGljVHlwZTogXCJtYXhcIixcbiAgICAgIG9uU3RhdGlzdGljRmllbGQ6IHF1ZXJ5RmllbGROYW1lLFxuICAgICAgb3V0U3RhdGlzdGljRmllbGROYW1lOiBcIk1BWF9GSUVMRF9WQUxVRVwiXG4gICAgfVxuICBdO1xuICBjb25zdCByZXMgPSBhd2FpdCBsYXllci5xdWVyeVJhc3RlcnMocXVlcnksIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9KTtcbiAgaWYgKCgoX2EgPSByZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMuZmVhdHVyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMCkge1xuICAgIGNvbnN0IFtmZWF0dXJlXSA9IHJlcy5mZWF0dXJlcztcbiAgICByZXR1cm4gW2ZlYXR1cmUuYXR0cmlidXRlc1tcIk1JTl9GSUVMRF9WQUxVRVwiXSwgZmVhdHVyZS5hdHRyaWJ1dGVzW1wiTUFYX0ZJRUxEX1ZBTFVFXCJdXTtcbiAgfVxuICByZXR1cm4gW107XG59XG4vKipcbiAqIGdlbmVyYXRlIHRoZSBwYXJhbWV0ZXJzIGZvciBpbWFnZXJ5IGxheWVyIGlkZW50aWZ5IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIGxheWVyIC0gaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIG1hcFZpZXcgLSBjdXJyZW50IG1hcCB2aWV3XG4gKiBAcmV0dXJucyBfX2VzcmkuSW1hZ2VJZGVudGlmeVBhcmFtZXRlcnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVJZGVudGlmeVBhcmFtcyhsYXllciwgbWFwVmlldykge1xuICBjb25zdCBbUG9seWdvbiwgUG9pbnQsIEltYWdlSWRlbnRpZnlQYXJhbWV0ZXJzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICBcImVzcmkvZ2VvbWV0cnkvUG9seWdvblwiLFxuICAgIFwiZXNyaS9nZW9tZXRyeS9Qb2ludFwiLFxuICAgIFwiZXNyaS9yZXN0L3N1cHBvcnQvSW1hZ2VJZGVudGlmeVBhcmFtZXRlcnNcIlxuICBdKTtcbiAgY29uc3QgeyBleHRlbnQsIHdpZHRoLCBoZWlnaHQgfSA9IG1hcFZpZXc7XG4gIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbihleHRlbnQuc3BhdGlhbFJlZmVyZW5jZSk7XG4gIHBvbHlnb24uYWRkUmluZyhbXG4gICAgW2V4dGVudC54bWluLCBleHRlbnQueW1pbl0sXG4gICAgW2V4dGVudC54bWluLCBleHRlbnQueW1heF0sXG4gICAgW2V4dGVudC54bWF4LCBleHRlbnQueW1heF0sXG4gICAgW2V4dGVudC54bWF4LCBleHRlbnQueW1pbl0sXG4gICAgW2V4dGVudC54bWluLCBleHRlbnQueW1pbl1cbiAgXSk7XG4gIGNvbnN0IHBzWCA9IChleHRlbnQueG1heCAtIGV4dGVudC54bWluKSAvIHdpZHRoO1xuICBjb25zdCBwc1kgPSAoZXh0ZW50LnltYXggLSBleHRlbnQueW1pbikgLyBoZWlnaHQ7XG4gIGNvbnN0IHBpeGVsU2l6ZSA9IG5ldyBQb2ludChwc1gsIHBzWSwgZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2UpO1xuICBjb25zdCBpZGVudGlmeVBhcmFtcyA9IG5ldyBJbWFnZUlkZW50aWZ5UGFyYW1ldGVycygpO1xuICBpZGVudGlmeVBhcmFtcy5nZW9tZXRyeSA9IHBvbHlnb247XG4gIGlkZW50aWZ5UGFyYW1zLnJldHVybkdlb21ldHJ5ID0gZmFsc2U7XG4gIGlkZW50aWZ5UGFyYW1zLnBpeGVsU2l6ZSA9IHBpeGVsU2l6ZTtcbiAgY29uc3QgbW9zYWljUnVsZSA9IGxheWVyLm1vc2FpY1J1bGUuY2xvbmUoKTtcbiAgaWYgKGxheWVyLmRlZmluaXRpb25FeHByZXNzaW9uKSB7XG4gICAgbW9zYWljUnVsZS53aGVyZSA9IGxheWVyLmRlZmluaXRpb25FeHByZXNzaW9uO1xuICB9XG4gIGlkZW50aWZ5UGFyYW1zLm1vc2FpY1J1bGUgPSBtb3NhaWNSdWxlO1xuICByZXR1cm4gaWRlbnRpZnlQYXJhbXM7XG59XG4vKipcbiAqIGdldCB2aXNpYmxlIGltYWdlIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGNvbmRpdGlvblxuICpcbiAqIEBwYXJhbSBsYXllciAtIGltYWdlcnkgbGF5ZXJcbiAqIEBwYXJhbSBtYXBWaWV3IC0gY3VycmVudCBtYXAgdmlld1xuICogQHBhcmFtIGxheWVyUXVlcnkgLSBjdXJyZW50IG1hcCB2aWV3XG4gKiBAcmV0dXJucyBfX2VzcmkuRmVhdHVyZVNldCAtIHJhc3RlciBpdGVtc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRGaWx0ZXJlZFZpc2libGVJbWFnZUl0ZW1zKGxheWVyLCBtYXBWaWV3LCBsYXllclF1ZXJ5KSB7XG4gIHZhciBfYTtcbiAgbGV0IHZpc2libGVJbWFnZUl0ZW1PYmplY3RJZHMgPSBbXTtcbiAgY29uc3QgaWRlbnRpZnlQYXJhbXMgPSBhd2FpdCBnZW5lcmF0ZUlkZW50aWZ5UGFyYW1zKGxheWVyLCBtYXBWaWV3KTtcbiAgaWYgKGxheWVyLnZpc2libGUpIHtcbiAgICBjb25zdCBpZGVudGlmeVJlc3VsdCA9IGF3YWl0IGxheWVyLmlkZW50aWZ5KGlkZW50aWZ5UGFyYW1zKTtcbiAgICBpZiAoISgoX2EgPSBpZGVudGlmeVJlc3VsdCA9PT0gbnVsbCB8fCBpZGVudGlmeVJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRlbnRpZnlSZXN1bHQuY2F0YWxvZ0l0ZW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmVhdHVyZXMpIHx8ICEoaWRlbnRpZnlSZXN1bHQgPT09IG51bGwgfHwgaWRlbnRpZnlSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkZW50aWZ5UmVzdWx0LmNhdGFsb2dJdGVtVmlzaWJpbGl0aWVzKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG9iamVjdElkRmllbGROYW1lID0gbGF5ZXIub2JqZWN0SWRGaWVsZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkZW50aWZ5UmVzdWx0LmNhdGFsb2dJdGVtcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkZW50aWZ5UmVzdWx0LmNhdGFsb2dJdGVtVmlzaWJpbGl0aWVzW2ldID4gMCkge1xuICAgICAgICB2aXNpYmxlSW1hZ2VJdGVtT2JqZWN0SWRzLnB1c2goaWRlbnRpZnlSZXN1bHQuY2F0YWxvZ0l0ZW1zLmZlYXR1cmVzW2ldLmF0dHJpYnV0ZXNbb2JqZWN0SWRGaWVsZE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpc2libGVJbWFnZUl0ZW1PYmplY3RJZHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgb2JqZWN0SWRRdWVyeVN0cmluZyA9IGAke2xheWVyLm9iamVjdElkRmllbGR9IGluICgke3Zpc2libGVJbWFnZUl0ZW1PYmplY3RJZHNcbiAgICAgIC5tYXAoKG9pZCkgPT4gYCR7b2lkfWApXG4gICAgICAuam9pbihcIixcIil9KWA7XG4gICAgbGF5ZXJRdWVyeS53aGVyZSA9IGAke2xheWVyUXVlcnkud2hlcmV9IEFORCAke29iamVjdElkUXVlcnlTdHJpbmd9YDtcbiAgICBsYXllclF1ZXJ5Lm91dEZpZWxkcyA9IFtcIipcIl07XG4gICAgbGF5ZXJRdWVyeS5yZXR1cm5HZW9tZXRyeSA9IHRydWU7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgbGF5ZXIucXVlcnlSYXN0ZXJzKGxheWVyUXVlcnkpO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5mZWF0dXJlcykgPyByZXMgOiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB7IEFPSSBhcyBBLCBOYXZpZ2F0aW9uVGFiIGFzIE4sIGdldEltYWdlSXRlbUNvdW50IGFzIGEsIGJ1aWxkTGF5ZXJRdWVyeSBhcyBiLCBnZXRGaWx0ZXJlZEltYWdlSXRlbXMgYXMgYywgZ2V0RGVmYXVsdEltYWdlSXRlbUNhcmREaXNwbGF5ZWRGaWVsZHMgYXMgZCwgZ2V0TWluQW5kTWF4VmFsdWVzRm9yTGF5ZXJGaWVsZCBhcyBlLCBnZXRVbmlxdWVWYWx1ZXNGb3JMYXllckZpZWxkIGFzIGYsIGdldEZpbHRlcmVkVmlzaWJsZUltYWdlSXRlbXMgYXMgZywgZ2V0U3VwcG9ydGVkTGF5ZXJGaWVsZHMgYXMgaCwgaXNBYm9ydGVkRXJyb3IgYXMgaSwgZ2V0RGVmYXVsdFNlbGVjdGVkTGF5ZXJGaWVsZCBhcyBqLCBpc051bWVyaWNGaWVsZFR5cGUgYXMgaywgZ2V0Rm9ybWF0dGVkRGF0ZVN0cmluZyBhcyBsLCBnZXRJbWFnZUl0ZW1HZW9tZXRyeSBhcyBtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=