"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-045495"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-credit-estimate_2.entry.js":
/*!***************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-credit-estimate_2.entry.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_credit_estimate: () => (/* binding */ ArcgisCreditEstimate),
/* harmony export */   arcgis_select: () => (/* binding */ ArcgisSelect)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _util_fd5f9668_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util-fd5f9668.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-fd5f9668.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _guid_4f4176ba_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./guid-4f4176ba.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-4f4176ba.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */









const arcgisCreditEstimateCss = ":host{display:flex;border:1px solid var(--calcite-ui-border-1)}.left{padding-top:1rem;padding-bottom:1rem;padding-left:1.5rem;padding-right:1.5rem;flex:1 1 auto}.right{display:flex;flex-direction:column;justify-content:center;text-align:center;font-size:0.875rem;color:var(--calcite-ui-text-3);padding-top:1rem;padding-bottom:1rem;padding-left:1.5rem;padding-right:1.5rem;flex:0 0 auto;-webkit-border-start:1px solid var(--calcite-ui-border-1);border-inline-start:1px solid var(--calcite-ui-border-1)}.number{font-weight:700;font-size:1.625rem;display:block}.number--blue{color:var(--calcite-ui-brand)}.number--red{color:var(--calcite-ui-danger)}.number--orange{color:#fe583e}.number calcite-icon{vertical-align:-0.25rem;-webkit-margin-end:0.25rem;margin-inline-end:0.25rem}.header{font-weight:500;color:var(--calcite-ui-text-1);font-size:1rem;padding-bottom:0.5rem;margin:0}.text{font-size:0.875rem;color:var(--calcite-ui-text-2);margin-bottom:0.25rem;margin-top:0;display:flex}.text--left{flex:1 1 auto}";

const ArcgisCreditEstimate = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.api = 4;
    this.transactionCreditCost = undefined;
    this.availableCredits = undefined;
    this.showTotal = false;
    this.formattedStrings = undefined;
  }
  updateTransactionCost() {
    this.replaceStrings();
  }
  async componentWillLoad() {
    const locale = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el);
    this.i18n = locale[0];
    await this.replaceStrings();
  }
  async replaceStrings() {
    const { transactionCreditCost, availableCredits, i18n } = this;
    const options = { api: this.api, type: "decimal", places: 2 };
    const available = await (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.f)(availableCredits, options);
    const needed = await (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.f)(transactionCreditCost, options);
    const percent = await (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.f)(transactionCreditCost / availableCredits, Object.assign(Object.assign({}, options), { type: "percent" }));
    this.formattedStrings = Object.assign(Object.assign({}, i18n), { creditsAvailable: i18n.creditsAvailable.replace("${credits}", available), creditsAvailableColon: i18n.creditsAvailableColon.replace("${credits}", available), creditsNeededColon: i18n.creditsNeededColon.replace("${credits}", needed), creditsNeeded: i18n.creditsNeeded.replace("${credits}", needed), creditsNeededPercent: i18n.creditsNeededPercent.replace("${percent}", percent), needed,
      percent });
  }
  render() {
    if (!this.formattedStrings) {
      return null;
    }
    const { transactionCreditCost, availableCredits, showTotal, formattedStrings: i18n, api } = this;
    const color = (0,_util_fd5f9668_js__WEBPACK_IMPORTED_MODULE_3__.g)(transactionCreditCost, availableCredits);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "left" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("h4", { class: "header" }, i18n.creditEstimate), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "text" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "text--left" }, i18n.creditsNeededColon), showTotal && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, i18n.creditsAvailableColon)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-meter", { max: availableCredits, maxLabel: i18n.notEnough, current: transactionCreditCost, min: 0, label: showTotal ? i18n.creditEstimate : i18n.creditsNeededPercent, api: api })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "right" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: `number number--${color}` }, color === "red" && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "exclamation-mark-triangle" }), i18n.needed), i18n.creditsNeeded)));
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "transactionCreditCost": ["updateTransactionCost"],
    "availableCredits": ["updateTransactionCost"]
  }; }
};
ArcgisCreditEstimate.style = arcgisCreditEstimateCss;

const arcgisSelectCss = ":host{position:relative}.select{margin-top:0.25rem;margin-bottom:1rem;position:relative}.select--no-margin{margin:0}.label{font-size:0.875rem;color:var(--calcite-ui-text-1);line-height:18px}.label--bold{font-weight:500}.description{display:block;font-weight:400;font-size:0.875rem;color:var(--calcite-ui-text-3);margin-top:0.5rem;margin-bottom:1rem}.large{font-size:1rem}.dropdown-container{position:absolute;left:0;box-shadow:0 6px 20px -4px rgba(0, 0, 0, 0.1), 0 4px 12px -2px rgba(0, 0, 0, 0.08);width:100%;top:100%;max-height:240px;overflow:auto;z-index:100}";

const ArcgisSelect = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisOptionChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisOptionChange", 7);
    this.guid = (0,_guid_4f4176ba_js__WEBPACK_IMPORTED_MODULE_5__.g)();
    this.handleKeys = (event) => {
      const key = event.key;
      const { options, selectedIndex, selectOpen, selectedOption } = this;
      switch (key) {
        case " " :
        case "Enter":
          this.selectOpen = !this.selectOpen;
          if (selectOpen) {
            this.arcgisOptionChange.emit(options[selectedIndex].value);
          }
          break;
        case "ArrowDown":
          this.selectOpen = true;
          if (this.selectOpen) {
            event.preventDefault();
            this.selectedIndex = (selectedIndex + 1) % options.length;
          }
          break;
        case "ArrowUp":
          if (this.selectOpen) {
            event.preventDefault();
            if (selectedIndex === 0) {
              this.selectedIndex = options.length - 1;
            }
            else {
              this.selectedIndex = selectedIndex - 1;
            }
          }
          break;
        case "Tab":
          if (selectOpen) {
            this.selectedIndex = Math.max(options.findIndex((option) => option.value === selectedOption), 0);
            this.selectOpen = false;
          }
          break;
        case "Escape":
          this.selectedIndex = Math.max(options.findIndex((option) => option.value === selectedOption), 0);
          this.selectOpen = false;
          this.defaultOptionRef.setFocus();
      }
    };
    this.renderOptions = () => {
      return this.options.map(({ optionTitle, description, icon, badge, value }, index) => {
        const isFocusedIndex = index === this.selectedIndex;
        const isSelectedOption = value === this.selectedOption;
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-option", { "aria-selected": isSelectedOption ? "true" : "false", selected: isSelectedOption, active: isFocusedIndex, optionTitle: optionTitle, value: value, badge: badge, description: description, icon: icon, autoFocus: true }));
      });
    };
    this.renderSelectedOption = () => {
      var _a;
      const { selectOpen, selectedOption, emptyText, options, guid } = this;
      const selected = options.find((option) => option.value === selectedOption);
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-option", { "aria-controls": `select_${guid}`, "aria-labelledby": `label_${guid}`, "aria-expanded": selectOpen ? "true" : "false", "aria-activedescendant": ((_a = options[this.selectedIndex]) === null || _a === void 0 ? void 0 : _a.value) || "no-selection", isSelector: true, optionTitle: (selected === null || selected === void 0 ? void 0 : selected.optionTitle) || emptyText, value: (selected === null || selected === void 0 ? void 0 : selected.value) || "", description: (selected === null || selected === void 0 ? void 0 : selected.description) || "", badge: selected === null || selected === void 0 ? void 0 : selected.badge, icon: (selected === null || selected === void 0 ? void 0 : selected.icon) || "", ref: (ele) => (this.defaultOptionRef = ele), onArcgisSelectOpen: () => {
          this.selectOpen = !this.selectOpen;
        } }));
    };
    this.selectOpen = false;
    this.selectedIndex = undefined;
    this.selectedOption = "";
    this.emptyText = undefined;
    this.options = undefined;
    this.label = undefined;
    this.labelDescription = undefined;
    this.labelWeight = "bold";
    this.autoFocus = undefined;
    this.focusDelay = 0;
  }
  async componentDidLoad() {
    this.onSelectedOptionChanged(this.selectedOption);
    if (this.autoFocus && this.selectOpen) {
      await (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_4__.t)(this.focusDelay);
      this.defaultOptionRef.focus();
    }
  }
  async setFocus() {
    this.defaultOptionRef.setFocus();
  }
  // eslint-disable-next-line @stencil/prefer-vdom-listener
  closeOnBlur() {
    this.selectOpen = false;
  }
  onSelectedOptionChanged(newSelectedOption) {
    const optionIndex = this.options.findIndex((option) => option.value === newSelectedOption);
    this.selectedIndex = Math.max(0, optionIndex);
  }
  async arcgisOptionChangeHandler() {
    this.selectOpen = false;
    this.defaultOptionRef.setFocus();
  }
  render() {
    const { label, labelDescription, guid, selectOpen } = this;
    const large = !!(this.label && this.labelDescription);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("label", { id: `label_${guid}`, class: "label" }, label && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: { label: true, "label--bold": this.labelWeight === "bold", large } }, label, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", { name: "afterLabel" }))), labelDescription && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: { description: true, large } }, labelDescription)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "select", onKeyDown: this.handleKeys }, this.renderSelectedOption(), selectOpen && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { role: "listbox", "aria-haspopup": "listbox", id: `select_${guid}`, class: "dropdown-container" }, this.renderOptions())))));
  }
  get element() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "selectedOption": ["onSelectedOptionChanged"]
  }; }
};
ArcgisSelect.style = arcgisSelectCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-4f4176ba.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-4f4176ba.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
function generateId(counts) {
  return counts
    .map((count) => {
    let out = "";
    for (let i = 0; i < count; i++) {
      out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    return out;
  })
    .join("-");
}
const guid = () => generateId([2, 1, 1, 1, 3]);




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



const languageMap = new Map([
  ["ar", "ar"],
  ["bg", "bg"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["cs", "cs"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["es", "es"],
  ["et", "et"],
  ["fi", "fi"],
  ["fr", "fr"],
  ["he", "he"],
  ["hr", "hr"],
  ["hu", "hu"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "ja"],
  ["ko", "ko"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["nb", "nb"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["pt-br", "pt-BR"],
  ["pt-pt", "pt-PT"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sr", "sr"],
  ["sv", "sv"],
  ["th", "th"],
  ["tr", "tr"],
  ["uk", "uk"],
  ["vi", "vi"],
  ["zh-cn", "zh-CN"],
  ["zh-hk", "zh-HK"],
  ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
  return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
  const closestWithProp = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
  return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
  rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
  const { api, type, places } = options || {};
  if (api === 4) {
    const [intl] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
    const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
      places,
      style: type,
      digitSeparator: true
    });
    return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
  }
  const [dojoNumber] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
  return dojoNumber.format(number, {
    type,
    places,
    pattern: options === null || options === void 0 ? void 0 : options.pattern
  });
}
const cache = {};
function formatDate(date) {
  const lang = document.documentElement.lang;
  const dayShortMonthYear = {
    year: "numeric",
    month: "short",
    day: "numeric"
  };
  if (!cache[lang]) {
    cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
  }
  return cache[lang].format(date);
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-fd5f9668.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-fd5f9668.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ getMeterColor)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
function getMeterColor(current, max) {
  const percent = current / max;
  if (percent >= 1 || percent < 0) {
    return "red";
  }
  if (percent > 0.8) {
    return "orange";
  }
  return "blue";
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTA0NTQ5NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7QUFDOUM7QUFDTztBQUNkO0FBQ0E7QUFDVDtBQUNaO0FBQ1I7O0FBRTNCLHVDQUF1QyxhQUFhLDRDQUE0QyxNQUFNLGlCQUFpQixvQkFBb0Isb0JBQW9CLHFCQUFxQixjQUFjLE9BQU8sYUFBYSxzQkFBc0IsdUJBQXVCLGtCQUFrQixtQkFBbUIsK0JBQStCLGlCQUFpQixvQkFBb0Isb0JBQW9CLHFCQUFxQixjQUFjLDBEQUEwRCx5REFBeUQsUUFBUSxnQkFBZ0IsbUJBQW1CLGNBQWMsY0FBYyw4QkFBOEIsYUFBYSwrQkFBK0IsZ0JBQWdCLGNBQWMscUJBQXFCLHdCQUF3QiwyQkFBMkIsMEJBQTBCLFFBQVEsZ0JBQWdCLCtCQUErQixlQUFlLHNCQUFzQixTQUFTLE1BQU0sbUJBQW1CLCtCQUErQixzQkFBc0IsYUFBYSxhQUFhLFlBQVksY0FBYzs7QUFFOWdDO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RCxzQkFBc0I7QUFDdEIsNEJBQTRCLDREQUFZO0FBQ3hDLHlCQUF5Qiw0REFBWTtBQUNyQywwQkFBMEIsNERBQVkseUVBQXlFLGNBQWMsaUJBQWlCO0FBQzlJLDBEQUEwRCxXQUFXLG1EQUFtRCxRQUFRLDRFQUE0RSxRQUFRLHNFQUFzRSxRQUFRLHlEQUF5RCxRQUFRLHVFQUF1RSxRQUFRO0FBQ2xiLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRkFBa0Y7QUFDOUYs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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZSxHQUFHLGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7Ozs7Ozs7Ozs7Ozs7OztBQzlGNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtY3JlZGl0LWVzdGltYXRlXzIuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9ndWlkLTRmNDE3NmJhLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMTNlMDBhNzUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vdXRpbC1mZDVmOTY2OC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgaCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQsIGMgYXMgY3JlYXRlRXZlbnQgfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcbmltcG9ydCB7IGYgYXMgZm9ybWF0TnVtYmVyIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMTNlMDBhNzUuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRNZXRlckNvbG9yIH0gZnJvbSAnLi91dGlsLWZkNWY5NjY4LmpzJztcbmltcG9ydCB7IHQgYXMgdGltZW91dCB9IGZyb20gJy4vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyc7XG5pbXBvcnQgeyBnIGFzIGd1aWQgfSBmcm9tICcuL2d1aWQtNGY0MTc2YmEuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCAnLi9kb20tMTNmNWIwMGMuanMnO1xuXG5jb25zdCBhcmNnaXNDcmVkaXRFc3RpbWF0ZUNzcyA9IFwiOmhvc3R7ZGlzcGxheTpmbGV4O2JvcmRlcjoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMSl9LmxlZnR7cGFkZGluZy10b3A6MXJlbTtwYWRkaW5nLWJvdHRvbToxcmVtO3BhZGRpbmctbGVmdDoxLjVyZW07cGFkZGluZy1yaWdodDoxLjVyZW07ZmxleDoxIDEgYXV0b30ucmlnaHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZTowLjg3NXJlbTtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMyk7cGFkZGluZy10b3A6MXJlbTtwYWRkaW5nLWJvdHRvbToxcmVtO3BhZGRpbmctbGVmdDoxLjVyZW07cGFkZGluZy1yaWdodDoxLjVyZW07ZmxleDowIDAgYXV0bzstd2Via2l0LWJvcmRlci1zdGFydDoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMSk7Ym9yZGVyLWlubGluZS1zdGFydDoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMSl9Lm51bWJlcntmb250LXdlaWdodDo3MDA7Zm9udC1zaXplOjEuNjI1cmVtO2Rpc3BsYXk6YmxvY2t9Lm51bWJlci0tYmx1ZXtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKX0ubnVtYmVyLS1yZWR7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS1kYW5nZXIpfS5udW1iZXItLW9yYW5nZXtjb2xvcjojZmU1ODNlfS5udW1iZXIgY2FsY2l0ZS1pY29ue3ZlcnRpY2FsLWFsaWduOi0wLjI1cmVtOy13ZWJraXQtbWFyZ2luLWVuZDowLjI1cmVtO21hcmdpbi1pbmxpbmUtZW5kOjAuMjVyZW19LmhlYWRlcntmb250LXdlaWdodDo1MDA7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO2ZvbnQtc2l6ZToxcmVtO3BhZGRpbmctYm90dG9tOjAuNXJlbTttYXJnaW46MH0udGV4dHtmb250LXNpemU6MC44NzVyZW07Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTIpO21hcmdpbi1ib3R0b206MC4yNXJlbTttYXJnaW4tdG9wOjA7ZGlzcGxheTpmbGV4fS50ZXh0LS1sZWZ0e2ZsZXg6MSAxIGF1dG99XCI7XG5cbmNvbnN0IEFyY2dpc0NyZWRpdEVzdGltYXRlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFwaSA9IDQ7XG4gICAgdGhpcy50cmFuc2FjdGlvbkNyZWRpdENvc3QgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hdmFpbGFibGVDcmVkaXRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2hvd1RvdGFsID0gZmFsc2U7XG4gICAgdGhpcy5mb3JtYXR0ZWRTdHJpbmdzID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZVRyYW5zYWN0aW9uQ29zdCgpIHtcbiAgICB0aGlzLnJlcGxhY2VTdHJpbmdzKCk7XG4gIH1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgY29uc3QgbG9jYWxlID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmVsKTtcbiAgICB0aGlzLmkxOG4gPSBsb2NhbGVbMF07XG4gICAgYXdhaXQgdGhpcy5yZXBsYWNlU3RyaW5ncygpO1xuICB9XG4gIGFzeW5jIHJlcGxhY2VTdHJpbmdzKCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25DcmVkaXRDb3N0LCBhdmFpbGFibGVDcmVkaXRzLCBpMThuIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGFwaTogdGhpcy5hcGksIHR5cGU6IFwiZGVjaW1hbFwiLCBwbGFjZXM6IDIgfTtcbiAgICBjb25zdCBhdmFpbGFibGUgPSBhd2FpdCBmb3JtYXROdW1iZXIoYXZhaWxhYmxlQ3JlZGl0cywgb3B0aW9ucyk7XG4gICAgY29uc3QgbmVlZGVkID0gYXdhaXQgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uQ3JlZGl0Q29zdCwgb3B0aW9ucyk7XG4gICAgY29uc3QgcGVyY2VudCA9IGF3YWl0IGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbkNyZWRpdENvc3QgLyBhdmFpbGFibGVDcmVkaXRzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHR5cGU6IFwicGVyY2VudFwiIH0pKTtcbiAgICB0aGlzLmZvcm1hdHRlZFN0cmluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGkxOG4pLCB7IGNyZWRpdHNBdmFpbGFibGU6IGkxOG4uY3JlZGl0c0F2YWlsYWJsZS5yZXBsYWNlKFwiJHtjcmVkaXRzfVwiLCBhdmFpbGFibGUpLCBjcmVkaXRzQXZhaWxhYmxlQ29sb246IGkxOG4uY3JlZGl0c0F2YWlsYWJsZUNvbG9uLnJlcGxhY2UoXCIke2NyZWRpdHN9XCIsIGF2YWlsYWJsZSksIGNyZWRpdHNOZWVkZWRDb2xvbjogaTE4bi5jcmVkaXRzTmVlZGVkQ29sb24ucmVwbGFjZShcIiR7Y3JlZGl0c31cIiwgbmVlZGVkKSwgY3JlZGl0c05lZWRlZDogaTE4bi5jcmVkaXRzTmVlZGVkLnJlcGxhY2UoXCIke2NyZWRpdHN9XCIsIG5lZWRlZCksIGNyZWRpdHNOZWVkZWRQZXJjZW50OiBpMThuLmNyZWRpdHNOZWVkZWRQZXJjZW50LnJlcGxhY2UoXCIke3BlcmNlbnR9XCIsIHBlcmNlbnQpLCBuZWVkZWQsXG4gICAgICBwZXJjZW50IH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZm9ybWF0dGVkU3RyaW5ncykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25DcmVkaXRDb3N0LCBhdmFpbGFibGVDcmVkaXRzLCBzaG93VG90YWwsIGZvcm1hdHRlZFN0cmluZ3M6IGkxOG4sIGFwaSB9ID0gdGhpcztcbiAgICBjb25zdCBjb2xvciA9IGdldE1ldGVyQ29sb3IodHJhbnNhY3Rpb25DcmVkaXRDb3N0LCBhdmFpbGFibGVDcmVkaXRzKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImRpdlwiLCB7IGNsYXNzOiBcImxlZnRcIiB9LCBoKFwiaDRcIiwgeyBjbGFzczogXCJoZWFkZXJcIiB9LCBpMThuLmNyZWRpdEVzdGltYXRlKSwgaChcInBcIiwgeyBjbGFzczogXCJ0ZXh0XCIgfSwgaChcInNwYW5cIiwgeyBjbGFzczogXCJ0ZXh0LS1sZWZ0XCIgfSwgaTE4bi5jcmVkaXRzTmVlZGVkQ29sb24pLCBzaG93VG90YWwgJiYgaChcInNwYW5cIiwgbnVsbCwgaTE4bi5jcmVkaXRzQXZhaWxhYmxlQ29sb24pKSwgaChcImFyY2dpcy1tZXRlclwiLCB7IG1heDogYXZhaWxhYmxlQ3JlZGl0cywgbWF4TGFiZWw6IGkxOG4ubm90RW5vdWdoLCBjdXJyZW50OiB0cmFuc2FjdGlvbkNyZWRpdENvc3QsIG1pbjogMCwgbGFiZWw6IHNob3dUb3RhbCA/IGkxOG4uY3JlZGl0RXN0aW1hdGUgOiBpMThuLmNyZWRpdHNOZWVkZWRQZXJjZW50LCBhcGk6IGFwaSB9KSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJyaWdodFwiIH0sIGgoXCJzcGFuXCIsIHsgY2xhc3M6IGBudW1iZXIgbnVtYmVyLS0ke2NvbG9yfWAgfSwgY29sb3IgPT09IFwicmVkXCIgJiYgaChcImNhbGNpdGUtaWNvblwiLCB7IGljb246IFwiZXhjbGFtYXRpb24tbWFyay10cmlhbmdsZVwiIH0pLCBpMThuLm5lZWRlZCksIGkxOG4uY3JlZGl0c05lZWRlZCkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJ0cmFuc2FjdGlvbkNyZWRpdENvc3RcIjogW1widXBkYXRlVHJhbnNhY3Rpb25Db3N0XCJdLFxuICAgIFwiYXZhaWxhYmxlQ3JlZGl0c1wiOiBbXCJ1cGRhdGVUcmFuc2FjdGlvbkNvc3RcIl1cbiAgfTsgfVxufTtcbkFyY2dpc0NyZWRpdEVzdGltYXRlLnN0eWxlID0gYXJjZ2lzQ3JlZGl0RXN0aW1hdGVDc3M7XG5cbmNvbnN0IGFyY2dpc1NlbGVjdENzcyA9IFwiOmhvc3R7cG9zaXRpb246cmVsYXRpdmV9LnNlbGVjdHttYXJnaW4tdG9wOjAuMjVyZW07bWFyZ2luLWJvdHRvbToxcmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5zZWxlY3QtLW5vLW1hcmdpbnttYXJnaW46MH0ubGFiZWx7Zm9udC1zaXplOjAuODc1cmVtO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKTtsaW5lLWhlaWdodDoxOHB4fS5sYWJlbC0tYm9sZHtmb250LXdlaWdodDo1MDB9LmRlc2NyaXB0aW9ue2Rpc3BsYXk6YmxvY2s7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZTowLjg3NXJlbTtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMyk7bWFyZ2luLXRvcDowLjVyZW07bWFyZ2luLWJvdHRvbToxcmVtfS5sYXJnZXtmb250LXNpemU6MXJlbX0uZHJvcGRvd24tY29udGFpbmVye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtib3gtc2hhZG93OjAgNnB4IDIwcHggLTRweCByZ2JhKDAsIDAsIDAsIDAuMSksIDAgNHB4IDEycHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMDgpO3dpZHRoOjEwMCU7dG9wOjEwMCU7bWF4LWhlaWdodDoyNDBweDtvdmVyZmxvdzphdXRvO3otaW5kZXg6MTAwfVwiO1xuXG5jb25zdCBBcmNnaXNTZWxlY3QgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzT3B0aW9uQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNPcHRpb25DaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5ndWlkID0gZ3VpZCgpO1xuICAgIHRoaXMuaGFuZGxlS2V5cyA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gZXZlbnQua2V5O1xuICAgICAgY29uc3QgeyBvcHRpb25zLCBzZWxlY3RlZEluZGV4LCBzZWxlY3RPcGVuLCBzZWxlY3RlZE9wdGlvbiB9ID0gdGhpcztcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCIgXCIgOlxuICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICB0aGlzLnNlbGVjdE9wZW4gPSAhdGhpcy5zZWxlY3RPcGVuO1xuICAgICAgICAgIGlmIChzZWxlY3RPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmFyY2dpc09wdGlvbkNoYW5nZS5lbWl0KG9wdGlvbnNbc2VsZWN0ZWRJbmRleF0udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICAgIHRoaXMuc2VsZWN0T3BlbiA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0T3Blbikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IChzZWxlY3RlZEluZGV4ICsgMSkgJSBvcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0T3Blbikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IG9wdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4IC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJUYWJcIjpcbiAgICAgICAgICBpZiAoc2VsZWN0T3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgob3B0aW9ucy5maW5kSW5kZXgoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBzZWxlY3RlZE9wdGlvbiksIDApO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRXNjYXBlXCI6XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgob3B0aW9ucy5maW5kSW5kZXgoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBzZWxlY3RlZE9wdGlvbiksIDApO1xuICAgICAgICAgIHRoaXMuc2VsZWN0T3BlbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvblJlZi5zZXRGb2N1cygpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZW5kZXJPcHRpb25zID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tYXAoKHsgb3B0aW9uVGl0bGUsIGRlc2NyaXB0aW9uLCBpY29uLCBiYWRnZSwgdmFsdWUgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgaXNGb2N1c2VkSW5kZXggPSBpbmRleCA9PT0gdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkT3B0aW9uID0gdmFsdWUgPT09IHRoaXMuc2VsZWN0ZWRPcHRpb247XG4gICAgICAgIHJldHVybiAoaChcImFyY2dpcy1vcHRpb25cIiwgeyBcImFyaWEtc2VsZWN0ZWRcIjogaXNTZWxlY3RlZE9wdGlvbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLCBzZWxlY3RlZDogaXNTZWxlY3RlZE9wdGlvbiwgYWN0aXZlOiBpc0ZvY3VzZWRJbmRleCwgb3B0aW9uVGl0bGU6IG9wdGlvblRpdGxlLCB2YWx1ZTogdmFsdWUsIGJhZGdlOiBiYWRnZSwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBpY29uOiBpY29uLCBhdXRvRm9jdXM6IHRydWUgfSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlbmRlclNlbGVjdGVkT3B0aW9uID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBzZWxlY3RPcGVuLCBzZWxlY3RlZE9wdGlvbiwgZW1wdHlUZXh0LCBvcHRpb25zLCBndWlkIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBvcHRpb25zLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uLnZhbHVlID09PSBzZWxlY3RlZE9wdGlvbik7XG4gICAgICByZXR1cm4gKGgoXCJhcmNnaXMtb3B0aW9uXCIsIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGBzZWxlY3RfJHtndWlkfWAsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGBsYWJlbF8ke2d1aWR9YCwgXCJhcmlhLWV4cGFuZGVkXCI6IHNlbGVjdE9wZW4gPyBcInRydWVcIiA6IFwiZmFsc2VcIiwgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogKChfYSA9IG9wdGlvbnNbdGhpcy5zZWxlY3RlZEluZGV4XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlKSB8fCBcIm5vLXNlbGVjdGlvblwiLCBpc1NlbGVjdG9yOiB0cnVlLCBvcHRpb25UaXRsZTogKHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5vcHRpb25UaXRsZSkgfHwgZW1wdHlUZXh0LCB2YWx1ZTogKHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC52YWx1ZSkgfHwgXCJcIiwgZGVzY3JpcHRpb246IChzZWxlY3RlZCA9PT0gbnVsbCB8fCBzZWxlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWQuZGVzY3JpcHRpb24pIHx8IFwiXCIsIGJhZGdlOiBzZWxlY3RlZCA9PT0gbnVsbCB8fCBzZWxlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWQuYmFkZ2UsIGljb246IChzZWxlY3RlZCA9PT0gbnVsbCB8fCBzZWxlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWQuaWNvbikgfHwgXCJcIiwgcmVmOiAoZWxlKSA9PiAodGhpcy5kZWZhdWx0T3B0aW9uUmVmID0gZWxlKSwgb25BcmNnaXNTZWxlY3RPcGVuOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RPcGVuID0gIXRoaXMuc2VsZWN0T3BlbjtcbiAgICAgICAgfSB9KSk7XG4gICAgfTtcbiAgICB0aGlzLnNlbGVjdE9wZW4gPSBmYWxzZTtcbiAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IFwiXCI7XG4gICAgdGhpcy5lbXB0eVRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbERlc2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxXZWlnaHQgPSBcImJvbGRcIjtcbiAgICB0aGlzLmF1dG9Gb2N1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvY3VzRGVsYXkgPSAwO1xuICB9XG4gIGFzeW5jIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgdGhpcy5vblNlbGVjdGVkT3B0aW9uQ2hhbmdlZCh0aGlzLnNlbGVjdGVkT3B0aW9uKTtcbiAgICBpZiAodGhpcy5hdXRvRm9jdXMgJiYgdGhpcy5zZWxlY3RPcGVuKSB7XG4gICAgICBhd2FpdCB0aW1lb3V0KHRoaXMuZm9jdXNEZWxheSk7XG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25SZWYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9uUmVmLnNldEZvY3VzKCk7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBzdGVuY2lsL3ByZWZlci12ZG9tLWxpc3RlbmVyXG4gIGNsb3NlT25CbHVyKCkge1xuICAgIHRoaXMuc2VsZWN0T3BlbiA9IGZhbHNlO1xuICB9XG4gIG9uU2VsZWN0ZWRPcHRpb25DaGFuZ2VkKG5ld1NlbGVjdGVkT3B0aW9uKSB7XG4gICAgY29uc3Qgb3B0aW9uSW5kZXggPSB0aGlzLm9wdGlvbnMuZmluZEluZGV4KChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSA9PT0gbmV3U2VsZWN0ZWRPcHRpb24pO1xuICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IE1hdGgubWF4KDAsIG9wdGlvbkluZGV4KTtcbiAgfVxuICBhc3luYyBhcmNnaXNPcHRpb25DaGFuZ2VIYW5kbGVyKCkge1xuICAgIHRoaXMuc2VsZWN0T3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvblJlZi5zZXRGb2N1cygpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBsYWJlbERlc2NyaXB0aW9uLCBndWlkLCBzZWxlY3RPcGVuIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxhcmdlID0gISEodGhpcy5sYWJlbCAmJiB0aGlzLmxhYmVsRGVzY3JpcHRpb24pO1xuICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwibGFiZWxcIiwgeyBpZDogYGxhYmVsXyR7Z3VpZH1gLCBjbGFzczogXCJsYWJlbFwiIH0sIGxhYmVsICYmIChoKFwic3BhblwiLCB7IGNsYXNzOiB7IGxhYmVsOiB0cnVlLCBcImxhYmVsLS1ib2xkXCI6IHRoaXMubGFiZWxXZWlnaHQgPT09IFwiYm9sZFwiLCBsYXJnZSB9IH0sIGxhYmVsLCBoKFwic2xvdFwiLCB7IG5hbWU6IFwiYWZ0ZXJMYWJlbFwiIH0pKSksIGxhYmVsRGVzY3JpcHRpb24gJiYgaChcInNwYW5cIiwgeyBjbGFzczogeyBkZXNjcmlwdGlvbjogdHJ1ZSwgbGFyZ2UgfSB9LCBsYWJlbERlc2NyaXB0aW9uKSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJzZWxlY3RcIiwgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleXMgfSwgdGhpcy5yZW5kZXJTZWxlY3RlZE9wdGlvbigpLCBzZWxlY3RPcGVuICYmIChoKFwiZGl2XCIsIHsgcm9sZTogXCJsaXN0Ym94XCIsIFwiYXJpYS1oYXNwb3B1cFwiOiBcImxpc3Rib3hcIiwgaWQ6IGBzZWxlY3RfJHtndWlkfWAsIGNsYXNzOiBcImRyb3Bkb3duLWNvbnRhaW5lclwiIH0sIHRoaXMucmVuZGVyT3B0aW9ucygpKSkpKSk7XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJzZWxlY3RlZE9wdGlvblwiOiBbXCJvblNlbGVjdGVkT3B0aW9uQ2hhbmdlZFwiXVxuICB9OyB9XG59O1xuQXJjZ2lzU2VsZWN0LnN0eWxlID0gYXJjZ2lzU2VsZWN0Q3NzO1xuXG5leHBvcnQgeyBBcmNnaXNDcmVkaXRFc3RpbWF0ZSBhcyBhcmNnaXNfY3JlZGl0X2VzdGltYXRlLCBBcmNnaXNTZWxlY3QgYXMgYXJjZ2lzX3NlbGVjdCB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gIGxldCB0aW1lb3V0O1xuICBsZXQgc3RhdHVzID0gXCJpZGxlXCI7XG4gIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImZsdXNoZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJpbnZva2VkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfVxuICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIGRlYm91bmNlZC5pbnZva2UgPSBpbnZva2U7XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBuIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWRcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCB0aHJvdHRsZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgfSwgZGVsYXkpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogU2V0IGEgbWluaW11bSB0aW1lIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZSAodXNlZnVsIGZvciBwcmV2ZW50aW5nIGZsYXNoIG9mIGxvYWRlcnMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pbkRlbGF5KHByb21pc2UsIG1pbkRlbGF5KSB7XG4gIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBpbmxpbmUgc2V0VGltZW91dCBhcyBhbiBhd2FpdCBpbiBhc3luYyBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gdGltZW91dChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbmNvbnN0IGFycmF5VG9Mb29rdXBNYXAgPSAoZGF0YUFyciwgZ2V0S2V5QW5kSXRlbSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKChkYXRhQXJyIHx8IFtdKS5tYXAoKGl0ZW0pID0+IHtcbiAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gIHJldHVybiBba2V5LCBkYXRhXTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBhbmQgd2hldGhlciB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHNcbiAqIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAqL1xuY29uc3QgYXJyYXlzQXJlRXF1aXZhbGVudCA9IChhcnIxLCBhcnIyKSA9PiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5yZWR1Y2UoKG1lbW8sIHN0cikgPT4gbWVtbyAmJiBhcnIyLmluZGV4T2Yoc3RyKSA+IC0xLCB0cnVlKTtcbmZ1bmN0aW9uIHVuaXF1ZUJ5KG15QXJyLCBnZXRJdGVtSWQpIHtcbiAgY29uc3QgcmVzdWx0QXJyID0gW107XG4gIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICBteUFyci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgaWYgKGxvb2t1cE1hcFtpZF0gPT0gbnVsbCkge1xuICAgICAgbG9va3VwTWFwW2lkXSA9IGl0ZW07XG4gICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gIGNvbnN0IHByaW1pdGl2ZXMgPSB7IGJvb2xlYW46IHt9LCBudW1iZXI6IHt9LCBzdHJpbmc6IHt9IH07XG4gIGNvbnN0IG9ianMgPSBbXTtcbiAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgIGxldCB0eXBlID0gdHlwZW9mIGl0ZW07XG4gICAgaWYgKHR5cGUgaW4gcHJpbWl0aXZlcykge1xuICAgICAgcmV0dXJuIHByaW1pdGl2ZXNbdHlwZV0uaGFzT3duUHJvcGVydHkoaXRlbSkgPyBmYWxzZSA6IChwcmltaXRpdmVzW3R5cGVdW2l0ZW1dID0gdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9ianMuaW5kZXhPZihpdGVtKSA+PSAwID8gZmFsc2UgOiBvYmpzLnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IGNodW5rID0gKGFyciwgc2l6ZSkgPT4gWy4uLkFycmF5KE1hdGguY2VpbChhcnIubGVuZ3RoIC8gc2l6ZSkpXS5tYXAoKF8sIGkpID0+IGFyci5zbGljZShzaXplICogaSwgc2l6ZSArIHNpemUgKiBpKSk7XG5cbmV4cG9ydCB7IGFycmF5VG9Mb29rdXBNYXAgYXMgYSwgdW5pcXVlIGFzIGIsIHRocm90dGxlIGFzIGMsIGRlYm91bmNlIGFzIGQsIGVzY2FwZVJlZ0V4cCBhcyBlLCBhcnJheXNBcmVFcXVpdmFsZW50IGFzIGYsIGNodW5rIGFzIGcsIGlzRGVmaW5lZCBhcyBpLCBtaW5EZWxheSBhcyBtLCB0aW1lb3V0IGFzIHQsIHVuaXF1ZUJ5IGFzIHUgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJZChjb3VudHMpIHtcbiAgcmV0dXJuIGNvdW50c1xuICAgIC5tYXAoKGNvdW50KSA9PiB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBvdXQgKz0gKCgoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9KVxuICAgIC5qb2luKFwiLVwiKTtcbn1cbmNvbnN0IGd1aWQgPSAoKSA9PiBnZW5lcmF0ZUlkKFsyLCAxLCAxLCAxLCAzXSk7XG5cbmV4cG9ydCB7IGd1aWQgYXMgZyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1hYWYzMGJkNi5qcyc7XG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTEzZjViMDBjLmpzJztcblxuY29uc3QgbGFuZ3VhZ2VNYXAgPSBuZXcgTWFwKFtcbiAgW1wiYXJcIiwgXCJhclwiXSxcbiAgW1wiYmdcIiwgXCJiZ1wiXSxcbiAgW1wiYnNcIiwgXCJic1wiXSxcbiAgW1wiY2FcIiwgXCJjYVwiXSxcbiAgW1wiY3NcIiwgXCJjc1wiXSxcbiAgW1wiZGFcIiwgXCJkYVwiXSxcbiAgW1wiZGVcIiwgXCJkZVwiXSxcbiAgW1wiZWxcIiwgXCJlbFwiXSxcbiAgW1wiZW5cIiwgXCJlblwiXSxcbiAgW1wiZXNcIiwgXCJlc1wiXSxcbiAgW1wiZXRcIiwgXCJldFwiXSxcbiAgW1wiZmlcIiwgXCJmaVwiXSxcbiAgW1wiZnJcIiwgXCJmclwiXSxcbiAgW1wiaGVcIiwgXCJoZVwiXSxcbiAgW1wiaHJcIiwgXCJoclwiXSxcbiAgW1wiaHVcIiwgXCJodVwiXSxcbiAgW1wiaWRcIiwgXCJpZFwiXSxcbiAgW1wiaXRcIiwgXCJpdFwiXSxcbiAgW1wiamFcIiwgXCJqYVwiXSxcbiAgW1wia29cIiwgXCJrb1wiXSxcbiAgW1wibHRcIiwgXCJsdFwiXSxcbiAgW1wibHZcIiwgXCJsdlwiXSxcbiAgW1wibmJcIiwgXCJuYlwiXSxcbiAgW1wibmxcIiwgXCJubFwiXSxcbiAgW1wicGxcIiwgXCJwbFwiXSxcbiAgW1wicHQtYnJcIiwgXCJwdC1CUlwiXSxcbiAgW1wicHQtcHRcIiwgXCJwdC1QVFwiXSxcbiAgW1wicm9cIiwgXCJyb1wiXSxcbiAgW1wicnVcIiwgXCJydVwiXSxcbiAgW1wic2tcIiwgXCJza1wiXSxcbiAgW1wic2xcIiwgXCJzbFwiXSxcbiAgW1wic3JcIiwgXCJzclwiXSxcbiAgW1wic3ZcIiwgXCJzdlwiXSxcbiAgW1widGhcIiwgXCJ0aFwiXSxcbiAgW1widHJcIiwgXCJ0clwiXSxcbiAgW1widWtcIiwgXCJ1a1wiXSxcbiAgW1widmlcIiwgXCJ2aVwiXSxcbiAgW1wiemgtY25cIiwgXCJ6aC1DTlwiXSxcbiAgW1wiemgtaGtcIiwgXCJ6aC1IS1wiXSxcbiAgW1wiemgtdHdcIiwgXCJ6aC1UV1wiXVxuXSk7XG4vLyBydGxcbmZ1bmN0aW9uIGdldEVsZW1lbnREaXIoZWwpIHtcbiAgcmV0dXJuIGdldEVsZW1lbnRQcm9wKGVsLCBcImRpclwiLCBcImx0clwiKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRQcm9wKGVsLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBjbG9zZXN0V2l0aFByb3AgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGBbJHtwcm9wfV1gKTtcbiAgcmV0dXJuIGNsb3Nlc3RXaXRoUHJvcCA/IGNsb3Nlc3RXaXRoUHJvcC5nZXRBdHRyaWJ1dGUocHJvcCkgOiB2YWx1ZTtcbn1cbi8vIGNzc1xuY29uc3QgQ1NTX1VUSUxJVFkgPSB7XG4gIHJ0bDogXCJhcmNnaXMtLXJ0bFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlciwgb3B0aW9ucykge1xuICBjb25zdCB7IGFwaSwgdHlwZSwgcGxhY2VzIH0gPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoYXBpID09PSA0KSB7XG4gICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICBjb25zdCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyA9IGludGwuY29udmVydE51bWJlckZvcm1hdFRvSW50bE9wdGlvbnMoe1xuICAgICAgcGxhY2VzLFxuICAgICAgc3R5bGU6IHR5cGUsXG4gICAgICBkaWdpdFNlcGFyYXRvcjogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBpbnRsLmZvcm1hdE51bWJlcihudW1iZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMpLCB7IHN0eWxlOiB0eXBlIH0pKTtcbiAgfVxuICBjb25zdCBbZG9qb051bWJlcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJkb2pvL251bWJlclwiXSk7XG4gIHJldHVybiBkb2pvTnVtYmVyLmZvcm1hdChudW1iZXIsIHtcbiAgICB0eXBlLFxuICAgIHBsYWNlcyxcbiAgICBwYXR0ZXJuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGF0dGVyblxuICB9KTtcbn1cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgY29uc3QgbGFuZyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nO1xuICBjb25zdCBkYXlTaG9ydE1vbnRoWWVhciA9IHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJzaG9ydFwiLFxuICAgIGRheTogXCJudW1lcmljXCJcbiAgfTtcbiAgaWYgKCFjYWNoZVtsYW5nXSkge1xuICAgIGNhY2hlW2xhbmddID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcsIGRheVNob3J0TW9udGhZZWFyKTtcbiAgfVxuICByZXR1cm4gY2FjaGVbbGFuZ10uZm9ybWF0KGRhdGUpO1xufVxuXG5leHBvcnQgeyBDU1NfVVRJTElUWSBhcyBDLCBmb3JtYXREYXRlIGFzIGEsIGZvcm1hdE51bWJlciBhcyBmLCBnZXRFbGVtZW50RGlyIGFzIGcsIGxhbmd1YWdlTWFwIGFzIGwgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIFwicnUtUlVcIiBtYXBzIHRvIFwicnVcIiB1c2UgY2FzZVxuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZy5zbGljZSgwLCAyKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgLy8gaXQncyBPSyBpZiB3ZSBkb24ndCBoYXZlIHRoZSA0IGxldHRlciBsYW5ndWFnZSBmaWxlIGZvciBpdFxuICAvLyA0IGxldHRlciBsYW5ndWFnZSBjb2RlIG5lZWRlZCBmb3IgZm9ybWF0dGluZyBudW1iZXJzXG4gIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBcImVuXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2goZ2V0QXNzZXRQYXRoKGAuLi9hcmNnaXMtYXBwLWFzc2V0cy9pMThuLyR7Y29tcG9uZW50TmFtZX0uaTE4bi4ke2xvY2FsZX0uanNvbmApKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQub2spXG4gICAgICAgIHJlc29sdmUocmVzdWx0Lmpzb24oKSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlamVjdCgpO1xuICAgIH0sICgpID0+IHJlamVjdCgpKTtcbiAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICBjb25zdCBpZCA9IGAke2NvbXBvbmVudE5hbWV9JHtsb2NhbGV9YDtcbiAgaWYgKCFzdHJpbmdDYWNoZVtpZF0pIHtcbiAgICBzdHJpbmdDYWNoZVtpZF0gPSBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBjb21wb25lbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KTtcbiAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgbGV0IHN0cmluZ3M7XG4gIHRyeSB7XG4gICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBjb21wb25lbnRMYW5ndWFnZSk7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oYG5vIGxvY2FsZSBmb3IgJHtjb21wb25lbnROYW1lfSAoJHtjb21wb25lbnRMYW5ndWFnZX0pIGxvYWRpbmcgZGVmYXVsdCBsb2NhbGUgZW4uYCk7XG4gICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBcImVuXCIpO1xuICB9XG4gIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuZnVuY3Rpb24gZ2V0TWV0ZXJDb2xvcihjdXJyZW50LCBtYXgpIHtcbiAgY29uc3QgcGVyY2VudCA9IGN1cnJlbnQgLyBtYXg7XG4gIGlmIChwZXJjZW50ID49IDEgfHwgcGVyY2VudCA8IDApIHtcbiAgICByZXR1cm4gXCJyZWRcIjtcbiAgfVxuICBpZiAocGVyY2VudCA+IDAuOCkge1xuICAgIHJldHVybiBcIm9yYW5nZVwiO1xuICB9XG4gIHJldHVybiBcImJsdWVcIjtcbn1cblxuZXhwb3J0IHsgZ2V0TWV0ZXJDb2xvciBhcyBnIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=