"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-6ae1db"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-group-browser-filter-access.entry.js":
/*!*************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-group-browser-filter-access.entry.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_group_browser_filter_access: () => (/* binding */ ArcgisGroupBrowserFilterAccess)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/* harmony import */ var _store_6ec1e1e1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./store-6ec1e1e1.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-6ec1e1e1.js");
/* harmony import */ var _store_ff04ba0a_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./store-ff04ba0a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-ff04ba0a.js");
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */







const ArcgisGroupBrowserFilterAccess = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisGroupBrowserFilter = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisGroupBrowserFilter", 7);
    this.options = ["public", "org", "private"];
    this.access = undefined;
    this.expanded = undefined;
  }
  async componentWillLoad() {
    this.store = (0,_store_6ec1e1e1_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el);
    this.i18n = this.store.state.i18n.filterAccess;
  }
  async componentDidLoad() {
    if (this.access) {
      this.arcgisGroupBrowserFilter.emit(this.getEventDetail());
    }
    (0,_store_ff04ba0a_js__WEBPACK_IMPORTED_MODULE_3__.a)("access", this.store, () => (this.access = null));
  }
  getEventDetail() {
    const { access } = this;
    const value = `access: ${access}`;
    const label = this.i18n.label.replace("${label}", this.i18n[access]);
    return { id: "access", param: "q", value, label, access };
  }
  render() {
    if (!(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === null || _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === void 0 ? void 0 : _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c.portal)) {
      return null;
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-browser-filter", { heading: this.i18n.title, expanded: this.expanded, active: !!this.access, onArcgisBrowserFilterRemove: () => {
        this.access = null;
        this.arcgisGroupBrowserFilter.emit(this.getEventDetail());
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tree", { selectionMode: "single", scale: "m", onCalciteTreeSelect: (event) => {
        var _a, _b;
        const node = event.target;
        const access = ((_b = (_a = node.selectedItems) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.dataset.access) || "";
        if (this.access === access) {
          this.access = null;
        }
        else {
          this.access = access;
        }
        this.arcgisGroupBrowserFilter.emit(this.getEventDetail());
      } }, this.options.map((access) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tree-item", { "data-access": access, selected: access === this.access }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("a", null, this.i18n[access])))))));
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ configState),
/* harmony export */   o: () => (/* binding */ onConfigChange)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const configStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  portal: null,
  user: null,
  api: 4,
  scale: "m"
});
const configState = configStore.state;
const onConfigChange = configStore.onChange;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-6ec1e1e1.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-6ec1e1e1.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ groupBrowserState),
/* harmony export */   g: () => (/* binding */ getGroupBrowserStore)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/* harmony import */ var _store_ff04ba0a_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store-ff04ba0a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-ff04ba0a.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



function getGroupBrowserStore(el) {
  return (0,_store_ff04ba0a_js__WEBPACK_IMPORTED_MODULE_1__.g)(el, "arcgis-group-browser");
}
const GroupBrowserStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({ filters: {} });
const groupBrowserState = GroupBrowserStore.state;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-ff04ba0a.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-ff04ba0a.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ onBrowserFilterRemove),
/* harmony export */   g: () => (/* binding */ getStore),
/* harmony export */   o: () => (/* binding */ onPreviewChange)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const onBrowserFilterRemove = (id, store, callback) => {
  // @ts-ignore
  store.onChange("filters", (filters) => {
    if (!filters[id] || !filters[id].value) {
      callback();
    }
  });
};
const onPreviewChange = (store, callback) => {
  // @ts-ignore
  store.onChange("preview", (preview) => {
    callback();
  });
};
const STORE_LOOKUP = new Map();
function getStore(el, browserTag) {
  const existingStore = STORE_LOOKUP.get(el);
  if (existingStore) {
    return existingStore;
  }
  const browser = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(el, browserTag);
  if (browser) {
    STORE_LOOKUP.set(el, browser.store);
    return browser.store;
  }
  return null;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTZhZTFkYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDa0c7QUFDMUM7QUFDUTtBQUNDO0FBQ3BDO0FBQ0Y7O0FBRTNCO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQixvQ0FBb0MscURBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBcUI7QUFDekI7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQiw2QkFBNkIsT0FBTztBQUNwQyw2Q0FBNkMsTUFBTTtBQUNuRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVUsa0RBQVcsYUFBYSxrREFBVyx1QkFBdUIsa0RBQVc7QUFDL0U7QUFDQTtBQUNBLFlBQVkscURBQUMsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTLEVBQUUscURBQUMsbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0MscURBQUMsd0JBQXdCLHlEQUF5RCxFQUFFLHFEQUFDO0FBQzlIO0FBQ0EsYUFBYSxPQUFPLHFEQUFVO0FBQzlCOztBQUVnRjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRGhGO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEOztBQUV2RCxvQkFBb0IscURBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFaUQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmakQ7QUFDQTtBQUNBO0FBQ0E7QUFDNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlLGlEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpREFBVztBQUN0RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0RBQXdELGlEQUFXO0FBQ25FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ0g7O0FBRXBEO0FBQ0EsU0FBUyxxREFBUTtBQUNqQjtBQUNBLDBCQUEwQixxREFBVyxHQUFHLGFBQWE7QUFDckQ7O0FBRTZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1EQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWdyb3VwLWJyb3dzZXItZmlsdGVyLWFjY2Vzcy5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9jb25maWctZWI1ZjdkYzIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtODFkNTQ4YjcuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc3RvcmUtNmVjMWUxZTEuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc3RvcmUtZmYwNGJhMGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuaW1wb3J0IHsgYyBhcyBjb25maWdTdGF0ZSB9IGZyb20gJy4vY29uZmlnLWViNWY3ZGMyLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0R3JvdXBCcm93c2VyU3RvcmUgfSBmcm9tICcuL3N0b3JlLTZlYzFlMWUxLmpzJztcbmltcG9ydCB7IGEgYXMgb25Ccm93c2VyRmlsdGVyUmVtb3ZlIH0gZnJvbSAnLi9zdG9yZS1mZjA0YmEwYS5qcyc7XG5pbXBvcnQgJy4vaW5kZXgtODFkNTQ4YjcuanMnO1xuaW1wb3J0ICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5cbmNvbnN0IEFyY2dpc0dyb3VwQnJvd3NlckZpbHRlckFjY2VzcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5hcmNnaXNHcm91cEJyb3dzZXJGaWx0ZXIgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0dyb3VwQnJvd3NlckZpbHRlclwiLCA3KTtcbiAgICB0aGlzLm9wdGlvbnMgPSBbXCJwdWJsaWNcIiwgXCJvcmdcIiwgXCJwcml2YXRlXCJdO1xuICAgIHRoaXMuYWNjZXNzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZXhwYW5kZWQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdGhpcy5zdG9yZSA9IGdldEdyb3VwQnJvd3NlclN0b3JlKHRoaXMuZWwpO1xuICAgIHRoaXMuaTE4biA9IHRoaXMuc3RvcmUuc3RhdGUuaTE4bi5maWx0ZXJBY2Nlc3M7XG4gIH1cbiAgYXN5bmMgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICBpZiAodGhpcy5hY2Nlc3MpIHtcbiAgICAgIHRoaXMuYXJjZ2lzR3JvdXBCcm93c2VyRmlsdGVyLmVtaXQodGhpcy5nZXRFdmVudERldGFpbCgpKTtcbiAgICB9XG4gICAgb25Ccm93c2VyRmlsdGVyUmVtb3ZlKFwiYWNjZXNzXCIsIHRoaXMuc3RvcmUsICgpID0+ICh0aGlzLmFjY2VzcyA9IG51bGwpKTtcbiAgfVxuICBnZXRFdmVudERldGFpbCgpIHtcbiAgICBjb25zdCB7IGFjY2VzcyB9ID0gdGhpcztcbiAgICBjb25zdCB2YWx1ZSA9IGBhY2Nlc3M6ICR7YWNjZXNzfWA7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmkxOG4ubGFiZWwucmVwbGFjZShcIiR7bGFiZWx9XCIsIHRoaXMuaTE4blthY2Nlc3NdKTtcbiAgICByZXR1cm4geyBpZDogXCJhY2Nlc3NcIiwgcGFyYW06IFwicVwiLCB2YWx1ZSwgbGFiZWwsIGFjY2VzcyB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIShjb25maWdTdGF0ZSA9PT0gbnVsbCB8fCBjb25maWdTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnU3RhdGUucG9ydGFsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoaChcImFyY2dpcy1icm93c2VyLWZpbHRlclwiLCB7IGhlYWRpbmc6IHRoaXMuaTE4bi50aXRsZSwgZXhwYW5kZWQ6IHRoaXMuZXhwYW5kZWQsIGFjdGl2ZTogISF0aGlzLmFjY2Vzcywgb25BcmNnaXNCcm93c2VyRmlsdGVyUmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcmNnaXNHcm91cEJyb3dzZXJGaWx0ZXIuZW1pdCh0aGlzLmdldEV2ZW50RGV0YWlsKCkpO1xuICAgICAgfSB9LCBoKFwiY2FsY2l0ZS10cmVlXCIsIHsgc2VsZWN0aW9uTW9kZTogXCJzaW5nbGVcIiwgc2NhbGU6IFwibVwiLCBvbkNhbGNpdGVUcmVlU2VsZWN0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgYWNjZXNzID0gKChfYiA9IChfYSA9IG5vZGUuc2VsZWN0ZWRJdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0YXNldC5hY2Nlc3MpIHx8IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmFjY2VzcyA9PT0gYWNjZXNzKSB7XG4gICAgICAgICAgdGhpcy5hY2Nlc3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWNjZXNzID0gYWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJjZ2lzR3JvdXBCcm93c2VyRmlsdGVyLmVtaXQodGhpcy5nZXRFdmVudERldGFpbCgpKTtcbiAgICAgIH0gfSwgdGhpcy5vcHRpb25zLm1hcCgoYWNjZXNzKSA9PiAoaChcImNhbGNpdGUtdHJlZS1pdGVtXCIsIHsgXCJkYXRhLWFjY2Vzc1wiOiBhY2Nlc3MsIHNlbGVjdGVkOiBhY2Nlc3MgPT09IHRoaXMuYWNjZXNzIH0sIGgoXCJhXCIsIG51bGwsIHRoaXMuaTE4blthY2Nlc3NdKSkpKSkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuXG5leHBvcnQgeyBBcmNnaXNHcm91cEJyb3dzZXJGaWx0ZXJBY2Nlc3MgYXMgYXJjZ2lzX2dyb3VwX2Jyb3dzZXJfZmlsdGVyX2FjY2VzcyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNyZWF0ZVN0b3JlIH0gZnJvbSAnLi9pbmRleC04MWQ1NDhiNy5qcyc7XG5cbmNvbnN0IGNvbmZpZ1N0b3JlID0gY3JlYXRlU3RvcmUoe1xuICBwb3J0YWw6IG51bGwsXG4gIHVzZXI6IG51bGwsXG4gIGFwaTogNCxcbiAgc2NhbGU6IFwibVwiXG59KTtcbmNvbnN0IGNvbmZpZ1N0YXRlID0gY29uZmlnU3RvcmUuc3RhdGU7XG5jb25zdCBvbkNvbmZpZ0NoYW5nZSA9IGNvbmZpZ1N0b3JlLm9uQ2hhbmdlO1xuXG5leHBvcnQgeyBjb25maWdTdGF0ZSBhcyBjLCBvbkNvbmZpZ0NoYW5nZSBhcyBvIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyaW5nUmVmLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5cbmNvbnN0IGFwcGVuZFRvTWFwID0gKG1hcCwgcHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXAuZ2V0KHByb3BOYW1lKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIG1hcC5zZXQocHJvcE5hbWUsIFt2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRlbXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBkZWJvdW5jZSA9IChmbiwgbXMpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9zc2libGUgZWxlbWVudCBpc0Nvbm5lY3RlZC5cbiAqIFRoZSBwcm9wZXJ0eSBtaWdodCBub3QgYmUgdGhlcmUsIHNvIHdlIGNoZWNrIGZvciBpdC5cbiAqXG4gKiBXZSB3YW50IGl0IHRvIHJldHVybiB0cnVlIGlmIGlzQ29ubmVjdGVkIGlzIG5vdCBhIHByb3BlcnR5LFxuICogb3RoZXJ3aXNlIHdlIHdvdWxkIHJlbW92ZSB0aGVzZSBlbGVtZW50cyBhbmQgd291bGQgbm90IHVwZGF0ZS5cbiAqXG4gKiBCZXR0ZXIgbGVhayBpbiBFZGdlIHRoYW4gdG8gYmUgdXNlbGVzcy5cbiAqL1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobWF5YmVFbGVtZW50KSA9PiAhKCdpc0Nvbm5lY3RlZCcgaW4gbWF5YmVFbGVtZW50KSB8fCBtYXliZUVsZW1lbnQuaXNDb25uZWN0ZWQ7XG5jb25zdCBjbGVhbnVwRWxlbWVudHMgPSBkZWJvdW5jZSgobWFwKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5nZXQoa2V5KS5maWx0ZXIoaXNDb25uZWN0ZWQpKTtcbiAgICB9XG59LCAyMDAwKTtcbmNvbnN0IHN0ZW5jaWxTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnZXRSZW5kZXJpbmdSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIHN0ZW5jaWwgcHJvamVjdCwgd2UgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IGV4cG9ydGVkIGJ5IEBzdGVuY2lsL2NvcmUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxtc1RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGVsbXNUb1VwZGF0ZS5jbGVhcigpLFxuICAgICAgICBnZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gZ2V0UmVuZGVyaW5nUmVmKCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9NYXAoZWxtc1RvVXBkYXRlLCBwcm9wTmFtZSwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxtc1RvVXBkYXRlLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbG1zVG9VcGRhdGUuc2V0KHByb3BOYW1lLCBlbGVtZW50cy5maWx0ZXIoZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgZWxtc1RvVXBkYXRlLmZvckVhY2goKGVsbXMpID0+IGVsbXMuZm9yRWFjaChmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHVud3JhcCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKCkgOiB2YWwpO1xuY29uc3QgY3JlYXRlT2JzZXJ2YWJsZU1hcCA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSA9IChhLCBiKSA9PiBhICE9PSBiKSA9PiB7XG4gICAgY29uc3QgdW53cmFwcGVkU3RhdGUgPSB1bndyYXAoZGVmYXVsdFN0YXRlKTtcbiAgICBsZXQgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh1bndyYXBwZWRTdGF0ZSAhPT0gbnVsbCAmJiB1bndyYXBwZWRTdGF0ZSAhPT0gdm9pZCAwID8gdW53cmFwcGVkU3RhdGUgOiB7fSkpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICBkaXNwb3NlOiBbXSxcbiAgICAgICAgZ2V0OiBbXSxcbiAgICAgICAgc2V0OiBbXSxcbiAgICAgICAgcmVzZXQ6IFtdLFxuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV2hlbiByZXNldHRpbmcgdGhlIHN0YXRlLCB0aGUgZGVmYXVsdCBzdGF0ZSBtYXkgYmUgYSBmdW5jdGlvbiAtIHVud3JhcCBpdCB0byBpbnZva2UgaXQuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHN0YXRlIHdvbid0IGJlIHByb3Blcmx5IHJlc2V0XG4gICAgICAgIHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoKF9hID0gdW53cmFwKGRlZmF1bHRTdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSk7XG4gICAgICAgIGhhbmRsZXJzLnJlc2V0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZmlyc3QgZGlzcG9zZSBhcyByZXNldHRpbmcgdGhlIHN0YXRlIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGxlc3MgdXBkYXRlcyA7KVxuICAgICAgICBoYW5kbGVycy5kaXNwb3NlLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICBoYW5kbGVycy5nZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldCA9IChwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgc3RhdGVzLnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSwgdmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0gKHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7fVxuICAgICAgICA6IG5ldyBQcm94eSh1bndyYXBwZWRTdGF0ZSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmtleXMoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhcyhfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXMuaGFzKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoXywgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgY29uc3Qgb24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBoYW5kbGVyc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGhhbmRsZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHByb3BOYW1lLCBjYikgPT4ge1xuICAgICAgICBjb25zdCB1blNldCA9IG9uKCdzZXQnLCAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVud3JhcCB0aGUgZGVmYXVsdFN0YXRlIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IG5vdCBiZSBzZW5kaW5nIHRoZSByaWdodCByZXNldCB2YWx1ZS5cbiAgICAgICAgY29uc3QgdW5SZXNldCA9IG9uKCdyZXNldCcsICgpID0+IGNiKHVud3JhcChkZWZhdWx0U3RhdGUpW3Byb3BOYW1lXSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5TZXQoKTtcbiAgICAgICAgICAgIHVuUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZSA9ICguLi5zdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3VicyA9IHN1YnNjcmlwdGlvbnMucmVkdWNlKCh1bnN1YnMsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignc2V0Jywgc3Vic2NyaXB0aW9uLnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5nZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZ2V0Jywgc3Vic2NyaXB0aW9uLmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5yZXNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdyZXNldCcsIHN1YnNjcmlwdGlvbi5yZXNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2Rpc3Bvc2UnLCBzdWJzY3JpcHRpb24uZGlzcG9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuc3VicztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5zdWJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihrZXksIG9sZFZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBvbixcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHVzZSxcbiAgICAgICAgZGlzcG9zZSxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGZvcmNlVXBkYXRlLFxuICAgIH07XG59O1xuY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBhcnJheS5sZW5ndGgtLTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGNyZWF0ZU9ic2VydmFibGVNYXAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpO1xuICAgIG1hcC51c2Uoc3RlbmNpbFN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgYXMgYyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNyZWF0ZVN0b3JlIH0gZnJvbSAnLi9pbmRleC04MWQ1NDhiNy5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFN0b3JlIH0gZnJvbSAnLi9zdG9yZS1mZjA0YmEwYS5qcyc7XG5cbmZ1bmN0aW9uIGdldEdyb3VwQnJvd3NlclN0b3JlKGVsKSB7XG4gIHJldHVybiBnZXRTdG9yZShlbCwgXCJhcmNnaXMtZ3JvdXAtYnJvd3NlclwiKTtcbn1cbmNvbnN0IEdyb3VwQnJvd3NlclN0b3JlID0gY3JlYXRlU3RvcmUoeyBmaWx0ZXJzOiB7fSB9KTtcbmNvbnN0IGdyb3VwQnJvd3NlclN0YXRlID0gR3JvdXBCcm93c2VyU3RvcmUuc3RhdGU7XG5cbmV4cG9ydCB7IGdyb3VwQnJvd3NlclN0YXRlIGFzIGEsIGdldEdyb3VwQnJvd3NlclN0b3JlIGFzIGcgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5cbmNvbnN0IG9uQnJvd3NlckZpbHRlclJlbW92ZSA9IChpZCwgc3RvcmUsIGNhbGxiYWNrKSA9PiB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgc3RvcmUub25DaGFuZ2UoXCJmaWx0ZXJzXCIsIChmaWx0ZXJzKSA9PiB7XG4gICAgaWYgKCFmaWx0ZXJzW2lkXSB8fCAhZmlsdGVyc1tpZF0udmFsdWUpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBvblByZXZpZXdDaGFuZ2UgPSAoc3RvcmUsIGNhbGxiYWNrKSA9PiB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgc3RvcmUub25DaGFuZ2UoXCJwcmV2aWV3XCIsIChwcmV2aWV3KSA9PiB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59O1xuY29uc3QgU1RPUkVfTE9PS1VQID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0U3RvcmUoZWwsIGJyb3dzZXJUYWcpIHtcbiAgY29uc3QgZXhpc3RpbmdTdG9yZSA9IFNUT1JFX0xPT0tVUC5nZXQoZWwpO1xuICBpZiAoZXhpc3RpbmdTdG9yZSkge1xuICAgIHJldHVybiBleGlzdGluZ1N0b3JlO1xuICB9XG4gIGNvbnN0IGJyb3dzZXIgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGJyb3dzZXJUYWcpO1xuICBpZiAoYnJvd3Nlcikge1xuICAgIFNUT1JFX0xPT0tVUC5zZXQoZWwsIGJyb3dzZXIuc3RvcmUpO1xuICAgIHJldHVybiBicm93c2VyLnN0b3JlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBvbkJyb3dzZXJGaWx0ZXJSZW1vdmUgYXMgYSwgZ2V0U3RvcmUgYXMgZywgb25QcmV2aWV3Q2hhbmdlIGFzIG8gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==