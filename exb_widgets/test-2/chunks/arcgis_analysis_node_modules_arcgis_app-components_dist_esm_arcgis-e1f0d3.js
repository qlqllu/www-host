"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-e1f0d3"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-lazy-loading-list.entry.js":
/*!***************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-lazy-loading-list.entry.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_lazy_loading_list: () => (/* binding */ ArcgisLazyLoadingList)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */






const arcgisLazyLoadingListCss = ":host{display:flex;flex-direction:column;overflow:hidden}.pop-menu{display:flex;flex-direction:column;position:absolute;max-height:100%;width:100%;overflow-y:hidden;border:1px solid var(--calcite-ui-border-3)}.pop-menu.pop-menu-flyout{top:0px;left:0px;z-index:100}.pop-list{overflow-y:scroll}";

const ArcgisLazyLoadingList = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisLazyLoadingListChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisLazyLoadingListChange", 7);
    this.hasSelectedScrolled = false;
    this.suspendObserver = false;
    this.scrollingDown = true;
    // TODO: dom query actual height (48 + 8) to reduce scroll when the list is very short
    this.filterHeight = 56;
    this.itemHeight = 32.5;
    this.itemHeightAdjusted = false;
    this.listChange = async () => {
      const selectedValues = await this.refListNode.getSelectedItems();
      // risk of 2 when filter is used and the pick list is updated frequently
      // this was found during dev, it's probably no longer the case.
      const selectedValue = [...selectedValues.keys()].pop();
      const selectedIndex = this.list.findIndex(({ value }) => value === selectedValue);
      this.arcgisLazyLoadingListChange.emit({
        selectedValue,
        selectedIndex
      });
    };
    this.updateFilter = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
      const filteredItems = this.refFilterNode
        .filteredItems;
      if (!filteredItems.length) {
        return;
      }
      const set = new Set(filteredItems.map(({ label }) => label));
      this.suspendObserver = true;
      this.filterList = this.list.filter(({ label }) => set.has(label));
      this.pageRanges = [0, 1];
      this.pageId = 0;
    }, 100);
    this.list = undefined;
    this.popoverProps = undefined;
    this.selectedIndex = 0;
    this.strings = undefined;
    this.showFilter = false;
    this.pageSize = 500;
    this.accumulatePages = true;
    this.position = "auto";
    this.pageBufferSize = 10;
    this.flyOut = false;
    this.listType = "pick-list";
    this.pageId = 0;
    this.filterList = undefined;
  }
  watchSelectedIndex(newValue) {
    this.updatePageId(newValue);
  }
  watchList(newValue) {
    // reset locked "auto" position
    this.listLabels = newValue.map(({ label }) => ({ label }));
    this.lockedMenuPosition = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  componentWillLoad() {
    this.listLabels = this.list.map(({ label }) => ({ label }));
    const pageIdMax = Math.floor(this.list.length / this.pageSize);
    if (pageIdMax < 2) {
      return;
    }
    this.updatePageId();
    this.setupObserver(pageIdMax);
  }
  componentDidRender() {
    // manipulate dom style at most once when initial item height is not accurate
    // TODO: delay auto menu position lock until item height adjustment
    if (this.flyOut && !this.itemHeightAdjusted && this.refSelectedNode) {
      const itemHeight = this.refSelectedNode.getBoundingClientRect().height;
      if (this.itemHeight !== itemHeight) {
        this.itemHeight = itemHeight;
        const { height, translateX, translateY } = this.getListPosition();
        this.refMenuNode.style.height = `${height}px`;
        this.refMenuNode.style.transform = `translate(${translateX}px, ${translateY}px)`;
      }
      this.itemHeightAdjusted = true;
    }
    requestAnimationFrame(() => {
      // scroll (at most once) selected node into view
      if (!this.hasSelectedScrolled && this.refSelectedNode) {
        this.refSelectedNode.scrollIntoView();
        this.hasSelectedScrolled = true;
      }
      // scroll anchor nodes when needed
      if (this.pendingScroll) {
        this.pendingScroll();
      }
      requestAnimationFrame(() => {
        // start observing after scrolling
        const { observer, refFirstnode, refLastnode } = this;
        if (observer) {
          this.suspendObserver = false;
          refFirstnode && observer.observe(refFirstnode);
          refLastnode && observer.observe(refLastnode);
        }
      });
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    var _a, _b;
    this.suspendObserver = true;
    let style;
    if (this.flyOut) {
      const { width, height, translateX, translateY } = this.getListPosition();
      // todo: refine translateY when it's drop-up and the list is short
      style = {
        width: `${width}px`,
        height: `${height}px`,
        transform: this.flyOut && `translate(${translateX}px, ${translateY}px)`
      };
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: this.flyOut && "js-app-flyout" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: this.flyOut ? "pop-menu pop-menu-flyout" : "pop-menu", style: style, ref: (node) => (this.refMenuNode = node) }, this.showFilter && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-filter", { items: this.listLabels, messageOverrides: {
        clear: (_a = this.strings) === null || _a === void 0 ? void 0 : _a.clearFilter,
        label: (_b = this.strings) === null || _b === void 0 ? void 0 : _b.filterLabel
      }, onCalciteFilterChange: this.updateFilter, ref: (node) => (this.refFilterNode = node) }))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "pop-list" }, this.renderList()))));
  }
  renderList() {
    const { pageBufferSize } = this;
    const halfPageBufferSize = Math.floor(pageBufferSize / 2);
    const subList = this.getSubList();
    const selectionId = this.getSelectedIndex();
    const selectedItem = this.list[selectionId];
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list", { dir: (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement), ref: (node) => {
        if (this.refListNode) {
          this.refListNode.removeEventListener("calciteListChange", this.listChange);
        }
        node.addEventListener("calciteListChange", this.listChange);
        this.refListNode = node;
      }, multiple: false, filterEnabled: false }, subList.map(({ value, label }, i) => (
    // TODO: this could be refactored to take an external render method, similar to renderRow in DGrid
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-pick-list-item", { value: value, label: label, key: label, selected: value === selectedItem.value, ref: !this.hasSelectedScrolled && label === selectedItem.label
        ? (node) => {
          this.refSelectedNode = node;
        }
        : i === subList.length - halfPageBufferSize
          ? (node) => {
            var _a;
            if (node) {
              this.refLastnode && ((_a = this.observer) === null || _a === void 0 ? void 0 : _a.unobserve(this.refLastnode));
              this.refLastnode = node;
            }
          }
          : i === subList.length - pageBufferSize
            ? (node) => {
              if (node) {
                this.refSecondLastnode = node;
              }
            }
            : i === halfPageBufferSize
              ? (node) => {
                var _a;
                if (node) {
                  this.refFirstnode && ((_a = this.observer) === null || _a === void 0 ? void 0 : _a.unobserve(this.refFirstnode));
                  this.refFirstnode = node;
                }
              }
              : i === pageBufferSize
                ? (node) => {
                  if (node) {
                    this.refSecondnode = node;
                  }
                }
                : null })))));
  }
  // --------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  getSelectedIndex(value = this.selectedIndex) {
    return value >= this.list.length ? 0 : value;
  }
  getListPosition() {
    const { width, left: translateX, top, bottom, containerTop, containerBottom } = this.popoverProps;
    const list = this.filterList || this.list;
    const listHeight = this.itemHeight * list.length + (this.showFilter ? this.filterHeight : 0);
    const clientHeight = containerBottom > bottom ? containerBottom : document.body.clientHeight;
    const spaceBottom = clientHeight - bottom;
    const spaceTop = top - containerTop;
    // autoPosition is only initialized once per list, so it doesn't flip when filterList changes
    if (!this.lockedMenuPosition) {
      if (this.position === "auto") {
        // allow a third of the list to be scrolled, or goden ratio
        this.lockedMenuPosition =
          listHeight * 1.5 <= spaceBottom || spaceTop / (spaceTop + spaceBottom) < 0.618
            ? "down"
            : "up";
      }
      else {
        this.lockedMenuPosition = this.position === "down" ? "down" : "up";
      }
    }
    const isDropdown = this.lockedMenuPosition === "down";
    const height = isDropdown
      ? Math.min(listHeight, spaceBottom - 2)
      : Math.min(listHeight, spaceTop - 2);
    const translateY = isDropdown ? bottom : Math.max(containerTop, top - height);
    return { width, height, translateX, translateY };
  }
  getSubList() {
    const useAccumulatedPageId = !!(this.accumulatePages && this.pageRanges);
    const firstId = useAccumulatedPageId ? Math.min(this.pageRanges[0], this.pageId) : this.pageId;
    const lastId = useAccumulatedPageId
      ? Math.max(this.pageRanges[1], this.pageId + 1)
      : this.pageId + 1;
    const list = this.filterList || this.list;
    const { pageBufferSize } = this;
    // TODO: we could handle a async fetch-ed list here
    const subList = list.slice(firstId === 0 ? 0 : firstId * this.pageSize - pageBufferSize, lastId * this.pageSize + pageBufferSize);
    if (this.accumulatePages) {
      this.pageRanges = [firstId, lastId];
    }
    return subList;
  }
  setupObserver(pageIdMax) {
    // observe anchor nodes to determine whether lazy loading is needed
    this.observer = new IntersectionObserver((entries, _observer) => {
      if (this.suspendObserver) {
        return;
      }
      entries = entries.filter(({ isIntersecting }) => isIntersecting);
      let pageUpdated = false;
      // when only one node is intersecting, increase or decrease page id
      if (entries.length === 1) {
        const entry = entries[0];
        // scrolling downwards to make last item visible
        if (this.refLastnode && entry.target.label === this.refLastnode.label) {
          if (this.pageId < pageIdMax) {
            this.pageId++;
            pageUpdated = true;
            this.scrollingDown = true;
            if (!this.accumulatePages) {
              // hide refFirst node since it will appear and can't be detected by observer
              this.pendingScroll = () => { var _a; return this.pageId > 0 && ((_a = this.refSecondnode) === null || _a === void 0 ? void 0 : _a.scrollIntoView(true)); };
            }
          }
        }
        else if (this.pageId > 0) {
          // scrolling upwards to avoid stuck scroll position by make first item in the old page visible
          this.pageId--;
          if (this.accumulatePages) {
            const node = entry.target;
            this.pendingScroll = () => {
              node.scrollIntoView();
              this.pendingScroll = null;
            };
          }
          else {
            this.pendingScroll = () => {
              var _a;
              // bottom position instead of default center position to avoid bottom node to appear
              (_a = this.refSecondLastnode) === null || _a === void 0 ? void 0 : _a.scrollIntoView(false);
              this.pendingScroll = null;
            };
          }
          pageUpdated = true;
          this.scrollingDown = false;
        }
      }
      else if (entries.length === 2) {
        // both anchor nodes are visible (short page)
        if (this.pageId === pageIdMax) {
          this.pageId--;
          if (this.accumulatePages) {
            const node = this.refLastnode;
            this.pendingScroll = () => {
              // default is center position
              node.scrollIntoView();
              this.pendingScroll = null;
            };
          }
          pageUpdated = true;
          this.scrollingDown = false;
        }
      }
      if (pageUpdated) {
        _observer.unobserve(this.refLastnode);
        _observer.unobserve(this.refFirstnode);
      }
    });
  }
  updatePageId(selectedIndex = this.selectedIndex) {
    selectedIndex = this.getSelectedIndex(selectedIndex);
    const pageId = Math.floor(selectedIndex / this.pageSize);
    if (pageId !== this.pageId) {
      this.pageId = pageId;
    }
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "selectedIndex": ["watchSelectedIndex"],
    "list": ["watchList"]
  }; }
};
ArcgisLazyLoadingList.style = arcgisLazyLoadingListCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



const languageMap = new Map([
  ["ar", "ar"],
  ["bg", "bg"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["cs", "cs"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["es", "es"],
  ["et", "et"],
  ["fi", "fi"],
  ["fr", "fr"],
  ["he", "he"],
  ["hr", "hr"],
  ["hu", "hu"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "ja"],
  ["ko", "ko"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["nb", "nb"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["pt-br", "pt-BR"],
  ["pt-pt", "pt-PT"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sr", "sr"],
  ["sv", "sv"],
  ["th", "th"],
  ["tr", "tr"],
  ["uk", "uk"],
  ["vi", "vi"],
  ["zh-cn", "zh-CN"],
  ["zh-hk", "zh-HK"],
  ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
  return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
  const closestWithProp = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
  return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
  rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
  const { api, type, places } = options || {};
  if (api === 4) {
    const [intl] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
    const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
      places,
      style: type,
      digitSeparator: true
    });
    return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
  }
  const [dojoNumber] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
  return dojoNumber.format(number, {
    type,
    places,
    pattern: options === null || options === void 0 ? void 0 : options.pattern
  });
}
const cache = {};
function formatDate(date) {
  const lang = document.documentElement.lang;
  const dayShortMonthYear = {
    year: "numeric",
    month: "short",
    day: "numeric"
  };
  if (!cache[lang]) {
    cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
  }
  return cache[lang].format(date);
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWUxZjBkMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RztBQUNwRDtBQUNPO0FBQzdCO0FBQ1I7O0FBRTNCLHdDQUF3QyxhQUFhLHNCQUFzQixnQkFBZ0IsVUFBVSxhQUFhLHNCQUFzQixrQkFBa0IsZ0JBQWdCLFdBQVcsa0JBQWtCLDRDQUE0QywwQkFBMEIsUUFBUSxTQUFTLFlBQVksVUFBVSxrQkFBa0I7O0FBRXRVO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQix1Q0FBdUMscURBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLDBEQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTyxRQUFRLE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPLFFBQVEsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRCwyQ0FBMkMsT0FBTztBQUNsRCx3REFBd0QsV0FBVyxNQUFNLFdBQVc7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0EseUJBQXlCLDJEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1FQUFtRSw4QkFBOEIsYUFBYTtBQUM5RztBQUNBLDZCQUE2QiwyREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1sYXp5LWxvYWRpbmctbGlzdC5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9mdW5jdGlvbmFsLWM4MmY1YWI5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcbmltcG9ydCB7IGQgYXMgZGVib3VuY2UgfSBmcm9tICcuL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCAnLi9kb20tMTNmNWIwMGMuanMnO1xuXG5jb25zdCBhcmNnaXNMYXp5TG9hZGluZ0xpc3RDc3MgPSBcIjpob3N0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVufS5wb3AtbWVudXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3Bvc2l0aW9uOmFic29sdXRlO21heC1oZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO292ZXJmbG93LXk6aGlkZGVuO2JvcmRlcjoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMyl9LnBvcC1tZW51LnBvcC1tZW51LWZseW91dHt0b3A6MHB4O2xlZnQ6MHB4O3otaW5kZXg6MTAwfS5wb3AtbGlzdHtvdmVyZmxvdy15OnNjcm9sbH1cIjtcblxuY29uc3QgQXJjZ2lzTGF6eUxvYWRpbmdMaXN0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFyY2dpc0xhenlMb2FkaW5nTGlzdENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzTGF6eUxvYWRpbmdMaXN0Q2hhbmdlXCIsIDcpO1xuICAgIHRoaXMuaGFzU2VsZWN0ZWRTY3JvbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3VzcGVuZE9ic2VydmVyID0gZmFsc2U7XG4gICAgdGhpcy5zY3JvbGxpbmdEb3duID0gdHJ1ZTtcbiAgICAvLyBUT0RPOiBkb20gcXVlcnkgYWN0dWFsIGhlaWdodCAoNDggKyA4KSB0byByZWR1Y2Ugc2Nyb2xsIHdoZW4gdGhlIGxpc3QgaXMgdmVyeSBzaG9ydFxuICAgIHRoaXMuZmlsdGVySGVpZ2h0ID0gNTY7XG4gICAgdGhpcy5pdGVtSGVpZ2h0ID0gMzIuNTtcbiAgICB0aGlzLml0ZW1IZWlnaHRBZGp1c3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubGlzdENoYW5nZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsdWVzID0gYXdhaXQgdGhpcy5yZWZMaXN0Tm9kZS5nZXRTZWxlY3RlZEl0ZW1zKCk7XG4gICAgICAvLyByaXNrIG9mIDIgd2hlbiBmaWx0ZXIgaXMgdXNlZCBhbmQgdGhlIHBpY2sgbGlzdCBpcyB1cGRhdGVkIGZyZXF1ZW50bHlcbiAgICAgIC8vIHRoaXMgd2FzIGZvdW5kIGR1cmluZyBkZXYsIGl0J3MgcHJvYmFibHkgbm8gbG9uZ2VyIHRoZSBjYXNlLlxuICAgICAgY29uc3Qgc2VsZWN0ZWRWYWx1ZSA9IFsuLi5zZWxlY3RlZFZhbHVlcy5rZXlzKCldLnBvcCgpO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHRoaXMubGlzdC5maW5kSW5kZXgoKHsgdmFsdWUgfSkgPT4gdmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpO1xuICAgICAgdGhpcy5hcmNnaXNMYXp5TG9hZGluZ0xpc3RDaGFuZ2UuZW1pdCh7XG4gICAgICAgIHNlbGVjdGVkVmFsdWUsXG4gICAgICAgIHNlbGVjdGVkSW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVGaWx0ZXIgPSBkZWJvdW5jZSgoKSA9PiB7XG4gICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gdGhpcy5yZWZGaWx0ZXJOb2RlXG4gICAgICAgIC5maWx0ZXJlZEl0ZW1zO1xuICAgICAgaWYgKCFmaWx0ZXJlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KGZpbHRlcmVkSXRlbXMubWFwKCh7IGxhYmVsIH0pID0+IGxhYmVsKSk7XG4gICAgICB0aGlzLnN1c3BlbmRPYnNlcnZlciA9IHRydWU7XG4gICAgICB0aGlzLmZpbHRlckxpc3QgPSB0aGlzLmxpc3QuZmlsdGVyKCh7IGxhYmVsIH0pID0+IHNldC5oYXMobGFiZWwpKTtcbiAgICAgIHRoaXMucGFnZVJhbmdlcyA9IFswLCAxXTtcbiAgICAgIHRoaXMucGFnZUlkID0gMDtcbiAgICB9LCAxMDApO1xuICAgIHRoaXMubGlzdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvcG92ZXJQcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIHRoaXMuc3RyaW5ncyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNob3dGaWx0ZXIgPSBmYWxzZTtcbiAgICB0aGlzLnBhZ2VTaXplID0gNTAwO1xuICAgIHRoaXMuYWNjdW11bGF0ZVBhZ2VzID0gdHJ1ZTtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJhdXRvXCI7XG4gICAgdGhpcy5wYWdlQnVmZmVyU2l6ZSA9IDEwO1xuICAgIHRoaXMuZmx5T3V0ID0gZmFsc2U7XG4gICAgdGhpcy5saXN0VHlwZSA9IFwicGljay1saXN0XCI7XG4gICAgdGhpcy5wYWdlSWQgPSAwO1xuICAgIHRoaXMuZmlsdGVyTGlzdCA9IHVuZGVmaW5lZDtcbiAgfVxuICB3YXRjaFNlbGVjdGVkSW5kZXgobmV3VmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZVBhZ2VJZChuZXdWYWx1ZSk7XG4gIH1cbiAgd2F0Y2hMaXN0KG5ld1ZhbHVlKSB7XG4gICAgLy8gcmVzZXQgbG9ja2VkIFwiYXV0b1wiIHBvc2l0aW9uXG4gICAgdGhpcy5saXN0TGFiZWxzID0gbmV3VmFsdWUubWFwKCh7IGxhYmVsIH0pID0+ICh7IGxhYmVsIH0pKTtcbiAgICB0aGlzLmxvY2tlZE1lbnVQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICB0aGlzLmxpc3RMYWJlbHMgPSB0aGlzLmxpc3QubWFwKCh7IGxhYmVsIH0pID0+ICh7IGxhYmVsIH0pKTtcbiAgICBjb25zdCBwYWdlSWRNYXggPSBNYXRoLmZsb29yKHRoaXMubGlzdC5sZW5ndGggLyB0aGlzLnBhZ2VTaXplKTtcbiAgICBpZiAocGFnZUlkTWF4IDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVBhZ2VJZCgpO1xuICAgIHRoaXMuc2V0dXBPYnNlcnZlcihwYWdlSWRNYXgpO1xuICB9XG4gIGNvbXBvbmVudERpZFJlbmRlcigpIHtcbiAgICAvLyBtYW5pcHVsYXRlIGRvbSBzdHlsZSBhdCBtb3N0IG9uY2Ugd2hlbiBpbml0aWFsIGl0ZW0gaGVpZ2h0IGlzIG5vdCBhY2N1cmF0ZVxuICAgIC8vIFRPRE86IGRlbGF5IGF1dG8gbWVudSBwb3NpdGlvbiBsb2NrIHVudGlsIGl0ZW0gaGVpZ2h0IGFkanVzdG1lbnRcbiAgICBpZiAodGhpcy5mbHlPdXQgJiYgIXRoaXMuaXRlbUhlaWdodEFkanVzdGVkICYmIHRoaXMucmVmU2VsZWN0ZWROb2RlKSB7XG4gICAgICBjb25zdCBpdGVtSGVpZ2h0ID0gdGhpcy5yZWZTZWxlY3RlZE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgaWYgKHRoaXMuaXRlbUhlaWdodCAhPT0gaXRlbUhlaWdodCkge1xuICAgICAgICB0aGlzLml0ZW1IZWlnaHQgPSBpdGVtSGVpZ2h0O1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSB9ID0gdGhpcy5nZXRMaXN0UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5yZWZNZW51Tm9kZS5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICAgICAgICB0aGlzLnJlZk1lbnVOb2RlLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt0cmFuc2xhdGVYfXB4LCAke3RyYW5zbGF0ZVl9cHgpYDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXRlbUhlaWdodEFkanVzdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIHNjcm9sbCAoYXQgbW9zdCBvbmNlKSBzZWxlY3RlZCBub2RlIGludG8gdmlld1xuICAgICAgaWYgKCF0aGlzLmhhc1NlbGVjdGVkU2Nyb2xsZWQgJiYgdGhpcy5yZWZTZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgdGhpcy5yZWZTZWxlY3RlZE5vZGUuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgdGhpcy5oYXNTZWxlY3RlZFNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHNjcm9sbCBhbmNob3Igbm9kZXMgd2hlbiBuZWVkZWRcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsKCk7XG4gICAgICB9XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAvLyBzdGFydCBvYnNlcnZpbmcgYWZ0ZXIgc2Nyb2xsaW5nXG4gICAgICAgIGNvbnN0IHsgb2JzZXJ2ZXIsIHJlZkZpcnN0bm9kZSwgcmVmTGFzdG5vZGUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgIHRoaXMuc3VzcGVuZE9ic2VydmVyID0gZmFsc2U7XG4gICAgICAgICAgcmVmRmlyc3Rub2RlICYmIG9ic2VydmVyLm9ic2VydmUocmVmRmlyc3Rub2RlKTtcbiAgICAgICAgICByZWZMYXN0bm9kZSAmJiBvYnNlcnZlci5vYnNlcnZlKHJlZkxhc3Rub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMub2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlciBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdGhpcy5zdXNwZW5kT2JzZXJ2ZXIgPSB0cnVlO1xuICAgIGxldCBzdHlsZTtcbiAgICBpZiAodGhpcy5mbHlPdXQpIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSB9ID0gdGhpcy5nZXRMaXN0UG9zaXRpb24oKTtcbiAgICAgIC8vIHRvZG86IHJlZmluZSB0cmFuc2xhdGVZIHdoZW4gaXQncyBkcm9wLXVwIGFuZCB0aGUgbGlzdCBpcyBzaG9ydFxuICAgICAgc3R5bGUgPSB7XG4gICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgICAgIGhlaWdodDogYCR7aGVpZ2h0fXB4YCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmZseU91dCAmJiBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH1weCwgJHt0cmFuc2xhdGVZfXB4KWBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiB0aGlzLmZseU91dCAmJiBcImpzLWFwcC1mbHlvdXRcIiB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IHRoaXMuZmx5T3V0ID8gXCJwb3AtbWVudSBwb3AtbWVudS1mbHlvdXRcIiA6IFwicG9wLW1lbnVcIiwgc3R5bGU6IHN0eWxlLCByZWY6IChub2RlKSA9PiAodGhpcy5yZWZNZW51Tm9kZSA9IG5vZGUpIH0sIHRoaXMuc2hvd0ZpbHRlciAmJiAoaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1maWx0ZXJcIiwgeyBpdGVtczogdGhpcy5saXN0TGFiZWxzLCBtZXNzYWdlT3ZlcnJpZGVzOiB7XG4gICAgICAgIGNsZWFyOiAoX2EgPSB0aGlzLnN0cmluZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhckZpbHRlcixcbiAgICAgICAgbGFiZWw6IChfYiA9IHRoaXMuc3RyaW5ncykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlckxhYmVsXG4gICAgICB9LCBvbkNhbGNpdGVGaWx0ZXJDaGFuZ2U6IHRoaXMudXBkYXRlRmlsdGVyLCByZWY6IChub2RlKSA9PiAodGhpcy5yZWZGaWx0ZXJOb2RlID0gbm9kZSkgfSkpKSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInBvcC1saXN0XCIgfSwgdGhpcy5yZW5kZXJMaXN0KCkpKSkpO1xuICB9XG4gIHJlbmRlckxpc3QoKSB7XG4gICAgY29uc3QgeyBwYWdlQnVmZmVyU2l6ZSB9ID0gdGhpcztcbiAgICBjb25zdCBoYWxmUGFnZUJ1ZmZlclNpemUgPSBNYXRoLmZsb29yKHBhZ2VCdWZmZXJTaXplIC8gMik7XG4gICAgY29uc3Qgc3ViTGlzdCA9IHRoaXMuZ2V0U3ViTGlzdCgpO1xuICAgIGNvbnN0IHNlbGVjdGlvbklkID0gdGhpcy5nZXRTZWxlY3RlZEluZGV4KCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRJdGVtID0gdGhpcy5saXN0W3NlbGVjdGlvbklkXTtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXBpY2stbGlzdFwiLCB7IGRpcjogZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5yZWZMaXN0Tm9kZSkge1xuICAgICAgICAgIHRoaXMucmVmTGlzdE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbGNpdGVMaXN0Q2hhbmdlXCIsIHRoaXMubGlzdENoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2FsY2l0ZUxpc3RDaGFuZ2VcIiwgdGhpcy5saXN0Q2hhbmdlKTtcbiAgICAgICAgdGhpcy5yZWZMaXN0Tm9kZSA9IG5vZGU7XG4gICAgICB9LCBtdWx0aXBsZTogZmFsc2UsIGZpbHRlckVuYWJsZWQ6IGZhbHNlIH0sIHN1Ykxpc3QubWFwKCh7IHZhbHVlLCBsYWJlbCB9LCBpKSA9PiAoXG4gICAgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSByZWZhY3RvcmVkIHRvIHRha2UgYW4gZXh0ZXJuYWwgcmVuZGVyIG1ldGhvZCwgc2ltaWxhciB0byByZW5kZXJSb3cgaW4gREdyaWRcbiAgICBoKFwiY2FsY2l0ZS1waWNrLWxpc3QtaXRlbVwiLCB7IHZhbHVlOiB2YWx1ZSwgbGFiZWw6IGxhYmVsLCBrZXk6IGxhYmVsLCBzZWxlY3RlZDogdmFsdWUgPT09IHNlbGVjdGVkSXRlbS52YWx1ZSwgcmVmOiAhdGhpcy5oYXNTZWxlY3RlZFNjcm9sbGVkICYmIGxhYmVsID09PSBzZWxlY3RlZEl0ZW0ubGFiZWxcbiAgICAgICAgPyAobm9kZSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVmU2VsZWN0ZWROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICA6IGkgPT09IHN1Ykxpc3QubGVuZ3RoIC0gaGFsZlBhZ2VCdWZmZXJTaXplXG4gICAgICAgICAgPyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZWZMYXN0bm9kZSAmJiAoKF9hID0gdGhpcy5vYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0aGlzLnJlZkxhc3Rub2RlKSk7XG4gICAgICAgICAgICAgIHRoaXMucmVmTGFzdG5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICA6IGkgPT09IHN1Ykxpc3QubGVuZ3RoIC0gcGFnZUJ1ZmZlclNpemVcbiAgICAgICAgICAgID8gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZlNlY29uZExhc3Rub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBpID09PSBoYWxmUGFnZUJ1ZmZlclNpemVcbiAgICAgICAgICAgICAgPyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZWZGaXJzdG5vZGUgJiYgKChfYSA9IHRoaXMub2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGhpcy5yZWZGaXJzdG5vZGUpKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVmRmlyc3Rub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiBpID09PSBwYWdlQnVmZmVyU2l6ZVxuICAgICAgICAgICAgICAgID8gKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmU2Vjb25kbm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSkpKSk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGdldFNlbGVjdGVkSW5kZXgodmFsdWUgPSB0aGlzLnNlbGVjdGVkSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy5saXN0Lmxlbmd0aCA/IDAgOiB2YWx1ZTtcbiAgfVxuICBnZXRMaXN0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgbGVmdDogdHJhbnNsYXRlWCwgdG9wLCBib3R0b20sIGNvbnRhaW5lclRvcCwgY29udGFpbmVyQm90dG9tIH0gPSB0aGlzLnBvcG92ZXJQcm9wcztcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5maWx0ZXJMaXN0IHx8IHRoaXMubGlzdDtcbiAgICBjb25zdCBsaXN0SGVpZ2h0ID0gdGhpcy5pdGVtSGVpZ2h0ICogbGlzdC5sZW5ndGggKyAodGhpcy5zaG93RmlsdGVyID8gdGhpcy5maWx0ZXJIZWlnaHQgOiAwKTtcbiAgICBjb25zdCBjbGllbnRIZWlnaHQgPSBjb250YWluZXJCb3R0b20gPiBib3R0b20gPyBjb250YWluZXJCb3R0b20gOiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBzcGFjZUJvdHRvbSA9IGNsaWVudEhlaWdodCAtIGJvdHRvbTtcbiAgICBjb25zdCBzcGFjZVRvcCA9IHRvcCAtIGNvbnRhaW5lclRvcDtcbiAgICAvLyBhdXRvUG9zaXRpb24gaXMgb25seSBpbml0aWFsaXplZCBvbmNlIHBlciBsaXN0LCBzbyBpdCBkb2Vzbid0IGZsaXAgd2hlbiBmaWx0ZXJMaXN0IGNoYW5nZXNcbiAgICBpZiAoIXRoaXMubG9ja2VkTWVudVBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgLy8gYWxsb3cgYSB0aGlyZCBvZiB0aGUgbGlzdCB0byBiZSBzY3JvbGxlZCwgb3IgZ29kZW4gcmF0aW9cbiAgICAgICAgdGhpcy5sb2NrZWRNZW51UG9zaXRpb24gPVxuICAgICAgICAgIGxpc3RIZWlnaHQgKiAxLjUgPD0gc3BhY2VCb3R0b20gfHwgc3BhY2VUb3AgLyAoc3BhY2VUb3AgKyBzcGFjZUJvdHRvbSkgPCAwLjYxOFxuICAgICAgICAgICAgPyBcImRvd25cIlxuICAgICAgICAgICAgOiBcInVwXCI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2NrZWRNZW51UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID09PSBcImRvd25cIiA/IFwiZG93blwiIDogXCJ1cFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc0Ryb3Bkb3duID0gdGhpcy5sb2NrZWRNZW51UG9zaXRpb24gPT09IFwiZG93blwiO1xuICAgIGNvbnN0IGhlaWdodCA9IGlzRHJvcGRvd25cbiAgICAgID8gTWF0aC5taW4obGlzdEhlaWdodCwgc3BhY2VCb3R0b20gLSAyKVxuICAgICAgOiBNYXRoLm1pbihsaXN0SGVpZ2h0LCBzcGFjZVRvcCAtIDIpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSBpc0Ryb3Bkb3duID8gYm90dG9tIDogTWF0aC5tYXgoY29udGFpbmVyVG9wLCB0b3AgLSBoZWlnaHQpO1xuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkgfTtcbiAgfVxuICBnZXRTdWJMaXN0KCkge1xuICAgIGNvbnN0IHVzZUFjY3VtdWxhdGVkUGFnZUlkID0gISEodGhpcy5hY2N1bXVsYXRlUGFnZXMgJiYgdGhpcy5wYWdlUmFuZ2VzKTtcbiAgICBjb25zdCBmaXJzdElkID0gdXNlQWNjdW11bGF0ZWRQYWdlSWQgPyBNYXRoLm1pbih0aGlzLnBhZ2VSYW5nZXNbMF0sIHRoaXMucGFnZUlkKSA6IHRoaXMucGFnZUlkO1xuICAgIGNvbnN0IGxhc3RJZCA9IHVzZUFjY3VtdWxhdGVkUGFnZUlkXG4gICAgICA/IE1hdGgubWF4KHRoaXMucGFnZVJhbmdlc1sxXSwgdGhpcy5wYWdlSWQgKyAxKVxuICAgICAgOiB0aGlzLnBhZ2VJZCArIDE7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZmlsdGVyTGlzdCB8fCB0aGlzLmxpc3Q7XG4gICAgY29uc3QgeyBwYWdlQnVmZmVyU2l6ZSB9ID0gdGhpcztcbiAgICAvLyBUT0RPOiB3ZSBjb3VsZCBoYW5kbGUgYSBhc3luYyBmZXRjaC1lZCBsaXN0IGhlcmVcbiAgICBjb25zdCBzdWJMaXN0ID0gbGlzdC5zbGljZShmaXJzdElkID09PSAwID8gMCA6IGZpcnN0SWQgKiB0aGlzLnBhZ2VTaXplIC0gcGFnZUJ1ZmZlclNpemUsIGxhc3RJZCAqIHRoaXMucGFnZVNpemUgKyBwYWdlQnVmZmVyU2l6ZSk7XG4gICAgaWYgKHRoaXMuYWNjdW11bGF0ZVBhZ2VzKSB7XG4gICAgICB0aGlzLnBhZ2VSYW5nZXMgPSBbZmlyc3RJZCwgbGFzdElkXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Ykxpc3Q7XG4gIH1cbiAgc2V0dXBPYnNlcnZlcihwYWdlSWRNYXgpIHtcbiAgICAvLyBvYnNlcnZlIGFuY2hvciBub2RlcyB0byBkZXRlcm1pbmUgd2hldGhlciBsYXp5IGxvYWRpbmcgaXMgbmVlZGVkXG4gICAgdGhpcy5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcywgX29ic2VydmVyKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdXNwZW5kT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZW50cmllcyA9IGVudHJpZXMuZmlsdGVyKCh7IGlzSW50ZXJzZWN0aW5nIH0pID0+IGlzSW50ZXJzZWN0aW5nKTtcbiAgICAgIGxldCBwYWdlVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgLy8gd2hlbiBvbmx5IG9uZSBub2RlIGlzIGludGVyc2VjdGluZywgaW5jcmVhc2Ugb3IgZGVjcmVhc2UgcGFnZSBpZFxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICAgICAgLy8gc2Nyb2xsaW5nIGRvd253YXJkcyB0byBtYWtlIGxhc3QgaXRlbSB2aXNpYmxlXG4gICAgICAgIGlmICh0aGlzLnJlZkxhc3Rub2RlICYmIGVudHJ5LnRhcmdldC5sYWJlbCA9PT0gdGhpcy5yZWZMYXN0bm9kZS5sYWJlbCkge1xuICAgICAgICAgIGlmICh0aGlzLnBhZ2VJZCA8IHBhZ2VJZE1heCkge1xuICAgICAgICAgICAgdGhpcy5wYWdlSWQrKztcbiAgICAgICAgICAgIHBhZ2VVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nRG93biA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjdW11bGF0ZVBhZ2VzKSB7XG4gICAgICAgICAgICAgIC8vIGhpZGUgcmVmRmlyc3Qgbm9kZSBzaW5jZSBpdCB3aWxsIGFwcGVhciBhbmQgY2FuJ3QgYmUgZGV0ZWN0ZWQgYnkgb2JzZXJ2ZXJcbiAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsID0gKCkgPT4geyB2YXIgX2E7IHJldHVybiB0aGlzLnBhZ2VJZCA+IDAgJiYgKChfYSA9IHRoaXMucmVmU2Vjb25kbm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjcm9sbEludG9WaWV3KHRydWUpKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYWdlSWQgPiAwKSB7XG4gICAgICAgICAgLy8gc2Nyb2xsaW5nIHVwd2FyZHMgdG8gYXZvaWQgc3R1Y2sgc2Nyb2xsIHBvc2l0aW9uIGJ5IG1ha2UgZmlyc3QgaXRlbSBpbiB0aGUgb2xkIHBhZ2UgdmlzaWJsZVxuICAgICAgICAgIHRoaXMucGFnZUlkLS07XG4gICAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZVBhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZW50cnkudGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgICBub2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Njcm9sbCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Njcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAvLyBib3R0b20gcG9zaXRpb24gaW5zdGVhZCBvZiBkZWZhdWx0IGNlbnRlciBwb3NpdGlvbiB0byBhdm9pZCBib3R0b20gbm9kZSB0byBhcHBlYXJcbiAgICAgICAgICAgICAgKF9hID0gdGhpcy5yZWZTZWNvbmRMYXN0bm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjcm9sbEludG9WaWV3KGZhbHNlKTtcbiAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhZ2VVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnNjcm9sbGluZ0Rvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZW50cmllcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gYm90aCBhbmNob3Igbm9kZXMgYXJlIHZpc2libGUgKHNob3J0IHBhZ2UpXG4gICAgICAgIGlmICh0aGlzLnBhZ2VJZCA9PT0gcGFnZUlkTWF4KSB7XG4gICAgICAgICAgdGhpcy5wYWdlSWQtLTtcbiAgICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlUGFnZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnJlZkxhc3Rub2RlO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIGNlbnRlciBwb3NpdGlvblxuICAgICAgICAgICAgICBub2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Njcm9sbCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYWdlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zY3JvbGxpbmdEb3duID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYWdlVXBkYXRlZCkge1xuICAgICAgICBfb2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMucmVmTGFzdG5vZGUpO1xuICAgICAgICBfb2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMucmVmRmlyc3Rub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1cGRhdGVQYWdlSWQoc2VsZWN0ZWRJbmRleCA9IHRoaXMuc2VsZWN0ZWRJbmRleCkge1xuICAgIHNlbGVjdGVkSW5kZXggPSB0aGlzLmdldFNlbGVjdGVkSW5kZXgoc2VsZWN0ZWRJbmRleCk7XG4gICAgY29uc3QgcGFnZUlkID0gTWF0aC5mbG9vcihzZWxlY3RlZEluZGV4IC8gdGhpcy5wYWdlU2l6ZSk7XG4gICAgaWYgKHBhZ2VJZCAhPT0gdGhpcy5wYWdlSWQpIHtcbiAgICAgIHRoaXMucGFnZUlkID0gcGFnZUlkO1xuICAgIH1cbiAgfVxuICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJzZWxlY3RlZEluZGV4XCI6IFtcIndhdGNoU2VsZWN0ZWRJbmRleFwiXSxcbiAgICBcImxpc3RcIjogW1wid2F0Y2hMaXN0XCJdXG4gIH07IH1cbn07XG5BcmNnaXNMYXp5TG9hZGluZ0xpc3Quc3R5bGUgPSBhcmNnaXNMYXp5TG9hZGluZ0xpc3RDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc0xhenlMb2FkaW5nTGlzdCBhcyBhcmNnaXNfbGF6eV9sb2FkaW5nX2xpc3QgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgIHJldHVybiBzdGF0dXM7XG4gIH1cbiAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICBjb25zdCBvYmpzID0gW107XG4gIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tMTNmNWIwMGMuanMnO1xuXG5jb25zdCBsYW5ndWFnZU1hcCA9IG5ldyBNYXAoW1xuICBbXCJhclwiLCBcImFyXCJdLFxuICBbXCJiZ1wiLCBcImJnXCJdLFxuICBbXCJic1wiLCBcImJzXCJdLFxuICBbXCJjYVwiLCBcImNhXCJdLFxuICBbXCJjc1wiLCBcImNzXCJdLFxuICBbXCJkYVwiLCBcImRhXCJdLFxuICBbXCJkZVwiLCBcImRlXCJdLFxuICBbXCJlbFwiLCBcImVsXCJdLFxuICBbXCJlblwiLCBcImVuXCJdLFxuICBbXCJlc1wiLCBcImVzXCJdLFxuICBbXCJldFwiLCBcImV0XCJdLFxuICBbXCJmaVwiLCBcImZpXCJdLFxuICBbXCJmclwiLCBcImZyXCJdLFxuICBbXCJoZVwiLCBcImhlXCJdLFxuICBbXCJoclwiLCBcImhyXCJdLFxuICBbXCJodVwiLCBcImh1XCJdLFxuICBbXCJpZFwiLCBcImlkXCJdLFxuICBbXCJpdFwiLCBcIml0XCJdLFxuICBbXCJqYVwiLCBcImphXCJdLFxuICBbXCJrb1wiLCBcImtvXCJdLFxuICBbXCJsdFwiLCBcImx0XCJdLFxuICBbXCJsdlwiLCBcImx2XCJdLFxuICBbXCJuYlwiLCBcIm5iXCJdLFxuICBbXCJubFwiLCBcIm5sXCJdLFxuICBbXCJwbFwiLCBcInBsXCJdLFxuICBbXCJwdC1iclwiLCBcInB0LUJSXCJdLFxuICBbXCJwdC1wdFwiLCBcInB0LVBUXCJdLFxuICBbXCJyb1wiLCBcInJvXCJdLFxuICBbXCJydVwiLCBcInJ1XCJdLFxuICBbXCJza1wiLCBcInNrXCJdLFxuICBbXCJzbFwiLCBcInNsXCJdLFxuICBbXCJzclwiLCBcInNyXCJdLFxuICBbXCJzdlwiLCBcInN2XCJdLFxuICBbXCJ0aFwiLCBcInRoXCJdLFxuICBbXCJ0clwiLCBcInRyXCJdLFxuICBbXCJ1a1wiLCBcInVrXCJdLFxuICBbXCJ2aVwiLCBcInZpXCJdLFxuICBbXCJ6aC1jblwiLCBcInpoLUNOXCJdLFxuICBbXCJ6aC1oa1wiLCBcInpoLUhLXCJdLFxuICBbXCJ6aC10d1wiLCBcInpoLVRXXCJdXG5dKTtcbi8vIHJ0bFxuZnVuY3Rpb24gZ2V0RWxlbWVudERpcihlbCkge1xuICByZXR1cm4gZ2V0RWxlbWVudFByb3AoZWwsIFwiZGlyXCIsIFwibHRyXCIpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFByb3AoZWwsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IGNsb3Nlc3RXaXRoUHJvcCA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgYFske3Byb3B9XWApO1xuICByZXR1cm4gY2xvc2VzdFdpdGhQcm9wID8gY2xvc2VzdFdpdGhQcm9wLmdldEF0dHJpYnV0ZShwcm9wKSA6IHZhbHVlO1xufVxuLy8gY3NzXG5jb25zdCBDU1NfVVRJTElUWSA9IHtcbiAgcnRsOiBcImFyY2dpcy0tcnRsXCJcbn07XG5hc3luYyBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYXBpLCB0eXBlLCBwbGFjZXMgfSA9IG9wdGlvbnMgfHwge307XG4gIGlmIChhcGkgPT09IDQpIHtcbiAgICBjb25zdCBbaW50bF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2ludGxcIl0pO1xuICAgIGNvbnN0IG51bWJlckZvcm1hdEludGxPcHRpb25zID0gaW50bC5jb252ZXJ0TnVtYmVyRm9ybWF0VG9JbnRsT3B0aW9ucyh7XG4gICAgICBwbGFjZXMsXG4gICAgICBzdHlsZTogdHlwZSxcbiAgICAgIGRpZ2l0U2VwYXJhdG9yOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGludGwuZm9ybWF0TnVtYmVyKG51bWJlciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyksIHsgc3R5bGU6IHR5cGUgfSkpO1xuICB9XG4gIGNvbnN0IFtkb2pvTnVtYmVyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImRvam8vbnVtYmVyXCJdKTtcbiAgcmV0dXJuIGRvam9OdW1iZXIuZm9ybWF0KG51bWJlciwge1xuICAgIHR5cGUsXG4gICAgcGxhY2VzLFxuICAgIHBhdHRlcm46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXR0ZXJuXG4gIH0pO1xufVxuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICBjb25zdCBsYW5nID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lmxhbmc7XG4gIGNvbnN0IGRheVNob3J0TW9udGhZZWFyID0ge1xuICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIlxuICB9O1xuICBpZiAoIWNhY2hlW2xhbmddKSB7XG4gICAgY2FjaGVbbGFuZ10gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZywgZGF5U2hvcnRNb250aFllYXIpO1xuICB9XG4gIHJldHVybiBjYWNoZVtsYW5nXS5mb3JtYXQoZGF0ZSk7XG59XG5cbmV4cG9ydCB7IENTU19VVElMSVRZIGFzIEMsIGZvcm1hdERhdGUgYXMgYSwgZm9ybWF0TnVtYmVyIGFzIGYsIGdldEVsZW1lbnREaXIgYXMgZywgbGFuZ3VhZ2VNYXAgYXMgbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9