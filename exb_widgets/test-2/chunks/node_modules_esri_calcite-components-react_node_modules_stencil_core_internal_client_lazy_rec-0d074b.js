(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["node_modules_esri_calcite-components-react_node_modules_stencil_core_internal_client_lazy_rec-0d074b"],{

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client lazy recursive ^\\.\\/.*\\.entry\\.js.*$ include: \\.entry\\.js$ exclude: \\.system\\.entry\\.js$":
/*!*************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/ lazy ^\.\/.*\.entry\.js.*$ include: \.entry\.js$ exclude: \.system\.entry\.js$ namespace object ***!
  \*************************************************************************************************************************************************************************************************/
/***/ ((module) => {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(() => {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = () => ([]);
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client lazy recursive ^\\.\\/.*\\.entry\\.js.*$ include: \\.entry\\.js$ exclude: \\.system\\.entry\\.js$";
module.exports = webpackEmptyAsyncContext;

/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/calcite-date-picker-month-header.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/calcite-date-picker-month-header.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CalciteDatePickerMonthHeader: () => (/* binding */ CalciteDatePickerMonthHeader),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _date_picker_month_header_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./date-picker-month-header.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/date-picker-month-header.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */


const CalciteDatePickerMonthHeader = _date_picker_month_header_js__WEBPACK_IMPORTED_MODULE_0__.D;
const defineCustomElement = _date_picker_month_header_js__WEBPACK_IMPORTED_MODULE_0__.d;




/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/date.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/date.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ datePartsFromLocalizedString),
/* harmony export */   b: () => (/* binding */ dateFromLocalizedString),
/* harmony export */   c: () => (/* binding */ dateToISO),
/* harmony export */   d: () => (/* binding */ datePartsFromISO),
/* harmony export */   e: () => (/* binding */ dateFromISO),
/* harmony export */   f: () => (/* binding */ dateFromRange),
/* harmony export */   g: () => (/* binding */ getDaysDiff),
/* harmony export */   h: () => (/* binding */ sameDate),
/* harmony export */   i: () => (/* binding */ inRange),
/* harmony export */   j: () => (/* binding */ getOrder),
/* harmony export */   k: () => (/* binding */ formatCalendarYear),
/* harmony export */   l: () => (/* binding */ parseCalendarYear),
/* harmony export */   n: () => (/* binding */ nextMonth),
/* harmony export */   p: () => (/* binding */ prevMonth),
/* harmony export */   s: () => (/* binding */ setEndOfDay)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/locale.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */


/**
 * Check if date is within a min and max
 *
 * @param date
 * @param min
 * @param max
 */
function inRange(date, min, max) {
  if (!date) {
    return;
  }
  const time = date.getTime();
  const afterMin = !(min instanceof Date) || time >= min.getTime();
  const beforeMax = !(max instanceof Date) || time <= max.getTime();
  return afterMin && beforeMax;
}
/**
 * Ensures date is within range,
 * returns min or max if out of bounds
 *
 * @param date
 * @param min
 * @param max
 */
function dateFromRange(date, min, max) {
  if (!(date instanceof Date)) {
    return null;
  }
  const time = date.getTime();
  const beforeMin = min instanceof Date && time < min.getTime();
  const afterMax = max instanceof Date && time > max.getTime();
  if (beforeMin) {
    return min;
  }
  if (afterMax) {
    return max;
  }
  return date;
}
/**
 * Parse an iso8601 string (YYYY-mm-dd) into a valid date.
 * TODO: handle time when time of day UI is added
 *
 * @param iso8601
 * @param isEndDate
 */
function dateFromISO(iso8601, isEndDate = false) {
  if (iso8601 instanceof Date) {
    return iso8601;
  }
  if (!iso8601 || typeof iso8601 !== "string") {
    return null;
  }
  const d = iso8601.split(/[: T-]/).map(parseFloat);
  const date = new Date(d[0], (d[1] || 1) - 1, d[2] || 1);
  date.setFullYear(d[0]);
  if (isNaN(date.getTime())) {
    throw new Error(`Invalid ISO 8601 date: "${iso8601}"`);
  }
  if (isEndDate) {
    return setEndOfDay(date);
  }
  return date;
}
/**
 * Parse a localized date string into a valid Date.
 * return false if date is invalid, or out of range
 *
 * @param value
 * @param localeData
 */
function dateFromLocalizedString(value, localeData) {
  if (!localeData) {
    return null;
  }
  const { separator } = localeData;
  const parts = parseDateString(value, localeData);
  const { day, month } = parts;
  const year = parseCalendarYear(parts.year, localeData);
  const date = new Date(year, month, day);
  date.setFullYear(year);
  const validDay = day > 0;
  const validMonth = month > -1;
  const validDate = !isNaN(date.getTime());
  const validLength = value.split(separator).filter((c) => c).length > 2;
  const validYear = year.toString().length > 0;
  if (validDay && validMonth && validDate && validLength && validYear) {
    return date;
  }
  return null;
}
function parseCalendarYear(year, localeData) {
  return processCalendarYear(year, localeData, "read");
}
function formatCalendarYear(year, localeData) {
  return processCalendarYear(year, localeData, "write");
}
function processCalendarYear(year, localeData, mode) {
  if (localeData["default-calendar"] !== "buddhist") {
    return year;
  }
  const BUDDHIST_CALENDAR_YEAR_OFFSET = 543;
  const yearOffset = BUDDHIST_CALENDAR_YEAR_OFFSET * (mode === "read" ? -1 : 1);
  return year + yearOffset;
}
/**
 * Retrieve day, month, and year strings from a localized string
 *
 * @param string
 * @param localeData
 */
function datePartsFromLocalizedString(string, localeData) {
  const { separator, unitOrder } = localeData;
  const order = getOrder(unitOrder);
  const values = string.split(separator).map((part) => _locale_js__WEBPACK_IMPORTED_MODULE_0__.n.delocalize(part));
  const day = values[order.indexOf("d")];
  const month = values[order.indexOf("m")];
  const year = values[order.indexOf("y")];
  return { day, month, year };
}
/**
 * Return first portion of ISO string (YYYY-mm-dd)
 *
 * @param date
 */
function dateToISO(date) {
  if (date instanceof Date) {
    return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().split("T")[0];
  }
  return "";
}
/**
 * Retrieve day, month, and year strings from a ISO string (YYYY-mm-dd)
 *
 * @param string
 * @param isoDate
 */
function datePartsFromISO(isoDate) {
  const dateParts = isoDate.split("-");
  return { day: dateParts[2], month: dateParts[1], year: dateParts[0] };
}
/**
 * Check if two dates are the same day, month, year
 *
 * @param d1
 * @param d2
 */
function sameDate(d1, d2) {
  return (d1 instanceof Date &&
    d2 instanceof Date &&
    d1.getDate() === d2.getDate() &&
    d1.getMonth() === d2.getMonth() &&
    d1.getFullYear() === d2.getFullYear());
}
/**
 * Get a date one month in the past
 *
 * @param date
 */
function prevMonth(date) {
  const month = date.getMonth();
  const nextDate = new Date(date);
  nextDate.setMonth(month - 1);
  // date doesn't exist in new month, use last day
  if (month === nextDate.getMonth()) {
    return new Date(date.getFullYear(), month, 0);
  }
  return nextDate;
}
/**
 * Get a date one month in the future
 *
 * @param date
 */
function nextMonth(date) {
  const month = date.getMonth();
  const nextDate = new Date(date);
  nextDate.setMonth(month + 1);
  // date doesn't exist in new month, use last day
  if ((month + 2) % 7 === nextDate.getMonth() % 7) {
    return new Date(date.getFullYear(), month + 2, 0);
  }
  return nextDate;
}
/**
 * Parse numeric units for day, month, and year from a localized string
 * month starts at 0 (can pass to date constructor)
 * can return values as number or string
 *
 * @param string
 * @param localeData
 */
function parseDateString(string, localeData) {
  const { day, month, year } = datePartsFromLocalizedString(string, localeData);
  return {
    day: parseInt(day),
    month: parseInt(month) - 1,
    year: parseInt(year),
  };
}
/**
 * Based on the unitOrder string, find order of month, day, and year for locale
 *
 * @param unitOrder
 */
function getOrder(unitOrder) {
  const signifiers = ["d", "m", "y"];
  const order = unitOrder.toLowerCase();
  return signifiers.sort((a, b) => order.indexOf(a) - order.indexOf(b));
}
/**
 * Get number of days between two dates
 *
 * @param date1
 * @param date2
 */
function getDaysDiff(date1, date2) {
  const ts1 = date1.getTime();
  const ts2 = date2.getTime();
  return (ts1 - ts2) / (1000 * 3600 * 24);
}
/**
 * Set time of the day to the end.
 *
 * @param {Date} date Date.
 * @returns {Date} Date with time set to end of day .
 */
function setEndOfDay(date) {
  date.setHours(23, 59, 59, 999);
  return date;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3Mvbm9kZV9tb2R1bGVzX2VzcmlfY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0X25vZGVfbW9kdWxlc19zdGVuY2lsX2NvcmVfaW50ZXJuYWxfY2xpZW50X2xhenlfcmVjLTBkMDc0Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1Rzs7QUFFdkcscUNBQXFDLDJEQUFxQjtBQUMxRCw0QkFBNEIsMkRBQXFCOztBQUVZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVjdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBLHVEQUF1RCx5Q0FBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy1yZWFjdC9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvIGxhenkgXlxcLlxcLy4qXFwuZW50cnlcXC5qcy4qJCBpbmNsdWRlOiBcXC5lbnRyeVxcLmpzJCBleGNsdWRlOiBcXC5zeXN0ZW1cXC5lbnRyeVxcLmpzJCBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2NhbGNpdGUtZGF0ZS1waWNrZXItbW9udGgtaGVhZGVyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2RhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd2VicGFja0VtcHR5QXN5bmNDb250ZXh0KHJlcSkge1xuXHQvLyBIZXJlIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKSBpcyB1c2VkIGluc3RlYWQgb2YgbmV3IFByb21pc2UoKSB0byBwcmV2ZW50XG5cdC8vIHVuY2F1Z2h0IGV4Y2VwdGlvbiBwb3BwaW5nIHVwIGluIGRldnRvb2xzXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH0pO1xufVxud2VicGFja0VtcHR5QXN5bmNDb250ZXh0LmtleXMgPSAoKSA9PiAoW10pO1xud2VicGFja0VtcHR5QXN5bmNDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlBc3luY0NvbnRleHQ7XG53ZWJwYWNrRW1wdHlBc3luY0NvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy1yZWFjdC9ub2RlX21vZHVsZXMvQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQgbGF6eSByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKlxcXFwuZW50cnlcXFxcLmpzLiokIGluY2x1ZGU6IFxcXFwuZW50cnlcXFxcLmpzJCBleGNsdWRlOiBcXFxcLnN5c3RlbVxcXFwuZW50cnlcXFxcLmpzJFwiO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlBc3luY0NvbnRleHQ7IiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL21haW4vTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjExLjBcbiAqL1xuaW1wb3J0IHsgRCBhcyBEYXRlUGlja2VyTW9udGhIZWFkZXIsIGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxIH0gZnJvbSAnLi9kYXRlLXBpY2tlci1tb250aC1oZWFkZXIuanMnO1xuXG5jb25zdCBDYWxjaXRlRGF0ZVBpY2tlck1vbnRoSGVhZGVyID0gRGF0ZVBpY2tlck1vbnRoSGVhZGVyO1xuY29uc3QgZGVmaW5lQ3VzdG9tRWxlbWVudCA9IGRlZmluZUN1c3RvbUVsZW1lbnQkMTtcblxuZXhwb3J0IHsgQ2FsY2l0ZURhdGVQaWNrZXJNb250aEhlYWRlciwgZGVmaW5lQ3VzdG9tRWxlbWVudCB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL21haW4vTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjExLjBcbiAqL1xuaW1wb3J0IHsgbiBhcyBudW1iZXJTdHJpbmdGb3JtYXR0ZXIgfSBmcm9tICcuL2xvY2FsZS5qcyc7XG5cbi8qKlxuICogQ2hlY2sgaWYgZGF0ZSBpcyB3aXRoaW4gYSBtaW4gYW5kIG1heFxuICpcbiAqIEBwYXJhbSBkYXRlXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKi9cbmZ1bmN0aW9uIGluUmFuZ2UoZGF0ZSwgbWluLCBtYXgpIHtcbiAgaWYgKCFkYXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRpbWUgPSBkYXRlLmdldFRpbWUoKTtcbiAgY29uc3QgYWZ0ZXJNaW4gPSAhKG1pbiBpbnN0YW5jZW9mIERhdGUpIHx8IHRpbWUgPj0gbWluLmdldFRpbWUoKTtcbiAgY29uc3QgYmVmb3JlTWF4ID0gIShtYXggaW5zdGFuY2VvZiBEYXRlKSB8fCB0aW1lIDw9IG1heC5nZXRUaW1lKCk7XG4gIHJldHVybiBhZnRlck1pbiAmJiBiZWZvcmVNYXg7XG59XG4vKipcbiAqIEVuc3VyZXMgZGF0ZSBpcyB3aXRoaW4gcmFuZ2UsXG4gKiByZXR1cm5zIG1pbiBvciBtYXggaWYgb3V0IG9mIGJvdW5kc1xuICpcbiAqIEBwYXJhbSBkYXRlXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKi9cbmZ1bmN0aW9uIGRhdGVGcm9tUmFuZ2UoZGF0ZSwgbWluLCBtYXgpIHtcbiAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdGltZSA9IGRhdGUuZ2V0VGltZSgpO1xuICBjb25zdCBiZWZvcmVNaW4gPSBtaW4gaW5zdGFuY2VvZiBEYXRlICYmIHRpbWUgPCBtaW4uZ2V0VGltZSgpO1xuICBjb25zdCBhZnRlck1heCA9IG1heCBpbnN0YW5jZW9mIERhdGUgJiYgdGltZSA+IG1heC5nZXRUaW1lKCk7XG4gIGlmIChiZWZvcmVNaW4pIHtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGlmIChhZnRlck1heCkge1xuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgcmV0dXJuIGRhdGU7XG59XG4vKipcbiAqIFBhcnNlIGFuIGlzbzg2MDEgc3RyaW5nIChZWVlZLW1tLWRkKSBpbnRvIGEgdmFsaWQgZGF0ZS5cbiAqIFRPRE86IGhhbmRsZSB0aW1lIHdoZW4gdGltZSBvZiBkYXkgVUkgaXMgYWRkZWRcbiAqXG4gKiBAcGFyYW0gaXNvODYwMVxuICogQHBhcmFtIGlzRW5kRGF0ZVxuICovXG5mdW5jdGlvbiBkYXRlRnJvbUlTTyhpc284NjAxLCBpc0VuZERhdGUgPSBmYWxzZSkge1xuICBpZiAoaXNvODYwMSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gaXNvODYwMTtcbiAgfVxuICBpZiAoIWlzbzg2MDEgfHwgdHlwZW9mIGlzbzg2MDEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkID0gaXNvODYwMS5zcGxpdCgvWzogVC1dLykubWFwKHBhcnNlRmxvYXQpO1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZFswXSwgKGRbMV0gfHwgMSkgLSAxLCBkWzJdIHx8IDEpO1xuICBkYXRlLnNldEZ1bGxZZWFyKGRbMF0pO1xuICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElTTyA4NjAxIGRhdGU6IFwiJHtpc284NjAxfVwiYCk7XG4gIH1cbiAgaWYgKGlzRW5kRGF0ZSkge1xuICAgIHJldHVybiBzZXRFbmRPZkRheShkYXRlKTtcbiAgfVxuICByZXR1cm4gZGF0ZTtcbn1cbi8qKlxuICogUGFyc2UgYSBsb2NhbGl6ZWQgZGF0ZSBzdHJpbmcgaW50byBhIHZhbGlkIERhdGUuXG4gKiByZXR1cm4gZmFsc2UgaWYgZGF0ZSBpcyBpbnZhbGlkLCBvciBvdXQgb2YgcmFuZ2VcbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBsb2NhbGVEYXRhXG4gKi9cbmZ1bmN0aW9uIGRhdGVGcm9tTG9jYWxpemVkU3RyaW5nKHZhbHVlLCBsb2NhbGVEYXRhKSB7XG4gIGlmICghbG9jYWxlRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHsgc2VwYXJhdG9yIH0gPSBsb2NhbGVEYXRhO1xuICBjb25zdCBwYXJ0cyA9IHBhcnNlRGF0ZVN0cmluZyh2YWx1ZSwgbG9jYWxlRGF0YSk7XG4gIGNvbnN0IHsgZGF5LCBtb250aCB9ID0gcGFydHM7XG4gIGNvbnN0IHllYXIgPSBwYXJzZUNhbGVuZGFyWWVhcihwYXJ0cy55ZWFyLCBsb2NhbGVEYXRhKTtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuICBjb25zdCB2YWxpZERheSA9IGRheSA+IDA7XG4gIGNvbnN0IHZhbGlkTW9udGggPSBtb250aCA+IC0xO1xuICBjb25zdCB2YWxpZERhdGUgPSAhaXNOYU4oZGF0ZS5nZXRUaW1lKCkpO1xuICBjb25zdCB2YWxpZExlbmd0aCA9IHZhbHVlLnNwbGl0KHNlcGFyYXRvcikuZmlsdGVyKChjKSA9PiBjKS5sZW5ndGggPiAyO1xuICBjb25zdCB2YWxpZFllYXIgPSB5ZWFyLnRvU3RyaW5nKCkubGVuZ3RoID4gMDtcbiAgaWYgKHZhbGlkRGF5ICYmIHZhbGlkTW9udGggJiYgdmFsaWREYXRlICYmIHZhbGlkTGVuZ3RoICYmIHZhbGlkWWVhcikge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxlbmRhclllYXIoeWVhciwgbG9jYWxlRGF0YSkge1xuICByZXR1cm4gcHJvY2Vzc0NhbGVuZGFyWWVhcih5ZWFyLCBsb2NhbGVEYXRhLCBcInJlYWRcIik7XG59XG5mdW5jdGlvbiBmb3JtYXRDYWxlbmRhclllYXIoeWVhciwgbG9jYWxlRGF0YSkge1xuICByZXR1cm4gcHJvY2Vzc0NhbGVuZGFyWWVhcih5ZWFyLCBsb2NhbGVEYXRhLCBcIndyaXRlXCIpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NhbGVuZGFyWWVhcih5ZWFyLCBsb2NhbGVEYXRhLCBtb2RlKSB7XG4gIGlmIChsb2NhbGVEYXRhW1wiZGVmYXVsdC1jYWxlbmRhclwiXSAhPT0gXCJidWRkaGlzdFwiKSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH1cbiAgY29uc3QgQlVEREhJU1RfQ0FMRU5EQVJfWUVBUl9PRkZTRVQgPSA1NDM7XG4gIGNvbnN0IHllYXJPZmZzZXQgPSBCVURESElTVF9DQUxFTkRBUl9ZRUFSX09GRlNFVCAqIChtb2RlID09PSBcInJlYWRcIiA/IC0xIDogMSk7XG4gIHJldHVybiB5ZWFyICsgeWVhck9mZnNldDtcbn1cbi8qKlxuICogUmV0cmlldmUgZGF5LCBtb250aCwgYW5kIHllYXIgc3RyaW5ncyBmcm9tIGEgbG9jYWxpemVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBzdHJpbmdcbiAqIEBwYXJhbSBsb2NhbGVEYXRhXG4gKi9cbmZ1bmN0aW9uIGRhdGVQYXJ0c0Zyb21Mb2NhbGl6ZWRTdHJpbmcoc3RyaW5nLCBsb2NhbGVEYXRhKSB7XG4gIGNvbnN0IHsgc2VwYXJhdG9yLCB1bml0T3JkZXIgfSA9IGxvY2FsZURhdGE7XG4gIGNvbnN0IG9yZGVyID0gZ2V0T3JkZXIodW5pdE9yZGVyKTtcbiAgY29uc3QgdmFsdWVzID0gc3RyaW5nLnNwbGl0KHNlcGFyYXRvcikubWFwKChwYXJ0KSA9PiBudW1iZXJTdHJpbmdGb3JtYXR0ZXIuZGVsb2NhbGl6ZShwYXJ0KSk7XG4gIGNvbnN0IGRheSA9IHZhbHVlc1tvcmRlci5pbmRleE9mKFwiZFwiKV07XG4gIGNvbnN0IG1vbnRoID0gdmFsdWVzW29yZGVyLmluZGV4T2YoXCJtXCIpXTtcbiAgY29uc3QgeWVhciA9IHZhbHVlc1tvcmRlci5pbmRleE9mKFwieVwiKV07XG4gIHJldHVybiB7IGRheSwgbW9udGgsIHllYXIgfTtcbn1cbi8qKlxuICogUmV0dXJuIGZpcnN0IHBvcnRpb24gb2YgSVNPIHN0cmluZyAoWVlZWS1tbS1kZClcbiAqXG4gKiBAcGFyYW0gZGF0ZVxuICovXG5mdW5jdGlvbiBkYXRlVG9JU08oZGF0ZSkge1xuICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF07XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG4vKipcbiAqIFJldHJpZXZlIGRheSwgbW9udGgsIGFuZCB5ZWFyIHN0cmluZ3MgZnJvbSBhIElTTyBzdHJpbmcgKFlZWVktbW0tZGQpXG4gKlxuICogQHBhcmFtIHN0cmluZ1xuICogQHBhcmFtIGlzb0RhdGVcbiAqL1xuZnVuY3Rpb24gZGF0ZVBhcnRzRnJvbUlTTyhpc29EYXRlKSB7XG4gIGNvbnN0IGRhdGVQYXJ0cyA9IGlzb0RhdGUuc3BsaXQoXCItXCIpO1xuICByZXR1cm4geyBkYXk6IGRhdGVQYXJ0c1syXSwgbW9udGg6IGRhdGVQYXJ0c1sxXSwgeWVhcjogZGF0ZVBhcnRzWzBdIH07XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byBkYXRlcyBhcmUgdGhlIHNhbWUgZGF5LCBtb250aCwgeWVhclxuICpcbiAqIEBwYXJhbSBkMVxuICogQHBhcmFtIGQyXG4gKi9cbmZ1bmN0aW9uIHNhbWVEYXRlKGQxLCBkMikge1xuICByZXR1cm4gKGQxIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgIGQyIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgIGQxLmdldERhdGUoKSA9PT0gZDIuZ2V0RGF0ZSgpICYmXG4gICAgZDEuZ2V0TW9udGgoKSA9PT0gZDIuZ2V0TW9udGgoKSAmJlxuICAgIGQxLmdldEZ1bGxZZWFyKCkgPT09IGQyLmdldEZ1bGxZZWFyKCkpO1xufVxuLyoqXG4gKiBHZXQgYSBkYXRlIG9uZSBtb250aCBpbiB0aGUgcGFzdFxuICpcbiAqIEBwYXJhbSBkYXRlXG4gKi9cbmZ1bmN0aW9uIHByZXZNb250aChkYXRlKSB7XG4gIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICBjb25zdCBuZXh0RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICBuZXh0RGF0ZS5zZXRNb250aChtb250aCAtIDEpO1xuICAvLyBkYXRlIGRvZXNuJ3QgZXhpc3QgaW4gbmV3IG1vbnRoLCB1c2UgbGFzdCBkYXlcbiAgaWYgKG1vbnRoID09PSBuZXh0RGF0ZS5nZXRNb250aCgpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgbW9udGgsIDApO1xuICB9XG4gIHJldHVybiBuZXh0RGF0ZTtcbn1cbi8qKlxuICogR2V0IGEgZGF0ZSBvbmUgbW9udGggaW4gdGhlIGZ1dHVyZVxuICpcbiAqIEBwYXJhbSBkYXRlXG4gKi9cbmZ1bmN0aW9uIG5leHRNb250aChkYXRlKSB7XG4gIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICBjb25zdCBuZXh0RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICBuZXh0RGF0ZS5zZXRNb250aChtb250aCArIDEpO1xuICAvLyBkYXRlIGRvZXNuJ3QgZXhpc3QgaW4gbmV3IG1vbnRoLCB1c2UgbGFzdCBkYXlcbiAgaWYgKChtb250aCArIDIpICUgNyA9PT0gbmV4dERhdGUuZ2V0TW9udGgoKSAlIDcpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBtb250aCArIDIsIDApO1xuICB9XG4gIHJldHVybiBuZXh0RGF0ZTtcbn1cbi8qKlxuICogUGFyc2UgbnVtZXJpYyB1bml0cyBmb3IgZGF5LCBtb250aCwgYW5kIHllYXIgZnJvbSBhIGxvY2FsaXplZCBzdHJpbmdcbiAqIG1vbnRoIHN0YXJ0cyBhdCAwIChjYW4gcGFzcyB0byBkYXRlIGNvbnN0cnVjdG9yKVxuICogY2FuIHJldHVybiB2YWx1ZXMgYXMgbnVtYmVyIG9yIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBzdHJpbmdcbiAqIEBwYXJhbSBsb2NhbGVEYXRhXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZVN0cmluZyhzdHJpbmcsIGxvY2FsZURhdGEpIHtcbiAgY29uc3QgeyBkYXksIG1vbnRoLCB5ZWFyIH0gPSBkYXRlUGFydHNGcm9tTG9jYWxpemVkU3RyaW5nKHN0cmluZywgbG9jYWxlRGF0YSk7XG4gIHJldHVybiB7XG4gICAgZGF5OiBwYXJzZUludChkYXkpLFxuICAgIG1vbnRoOiBwYXJzZUludChtb250aCkgLSAxLFxuICAgIHllYXI6IHBhcnNlSW50KHllYXIpLFxuICB9O1xufVxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgdW5pdE9yZGVyIHN0cmluZywgZmluZCBvcmRlciBvZiBtb250aCwgZGF5LCBhbmQgeWVhciBmb3IgbG9jYWxlXG4gKlxuICogQHBhcmFtIHVuaXRPcmRlclxuICovXG5mdW5jdGlvbiBnZXRPcmRlcih1bml0T3JkZXIpIHtcbiAgY29uc3Qgc2lnbmlmaWVycyA9IFtcImRcIiwgXCJtXCIsIFwieVwiXTtcbiAgY29uc3Qgb3JkZXIgPSB1bml0T3JkZXIudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHNpZ25pZmllcnMuc29ydCgoYSwgYikgPT4gb3JkZXIuaW5kZXhPZihhKSAtIG9yZGVyLmluZGV4T2YoYikpO1xufVxuLyoqXG4gKiBHZXQgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0d28gZGF0ZXNcbiAqXG4gKiBAcGFyYW0gZGF0ZTFcbiAqIEBwYXJhbSBkYXRlMlxuICovXG5mdW5jdGlvbiBnZXREYXlzRGlmZihkYXRlMSwgZGF0ZTIpIHtcbiAgY29uc3QgdHMxID0gZGF0ZTEuZ2V0VGltZSgpO1xuICBjb25zdCB0czIgPSBkYXRlMi5nZXRUaW1lKCk7XG4gIHJldHVybiAodHMxIC0gdHMyKSAvICgxMDAwICogMzYwMCAqIDI0KTtcbn1cbi8qKlxuICogU2V0IHRpbWUgb2YgdGhlIGRheSB0byB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSBEYXRlLlxuICogQHJldHVybnMge0RhdGV9IERhdGUgd2l0aCB0aW1lIHNldCB0byBlbmQgb2YgZGF5IC5cbiAqL1xuZnVuY3Rpb24gc2V0RW5kT2ZEYXkoZGF0ZSkge1xuICBkYXRlLnNldEhvdXJzKDIzLCA1OSwgNTksIDk5OSk7XG4gIHJldHVybiBkYXRlO1xufVxuXG5leHBvcnQgeyBkYXRlUGFydHNGcm9tTG9jYWxpemVkU3RyaW5nIGFzIGEsIGRhdGVGcm9tTG9jYWxpemVkU3RyaW5nIGFzIGIsIGRhdGVUb0lTTyBhcyBjLCBkYXRlUGFydHNGcm9tSVNPIGFzIGQsIGRhdGVGcm9tSVNPIGFzIGUsIGRhdGVGcm9tUmFuZ2UgYXMgZiwgZ2V0RGF5c0RpZmYgYXMgZywgc2FtZURhdGUgYXMgaCwgaW5SYW5nZSBhcyBpLCBnZXRPcmRlciBhcyBqLCBmb3JtYXRDYWxlbmRhclllYXIgYXMgaywgcGFyc2VDYWxlbmRhclllYXIgYXMgbCwgbmV4dE1vbnRoIGFzIG4sIHByZXZNb250aCBhcyBwLCBzZXRFbmRPZkRheSBhcyBzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=