"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-734c67"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-97d577a9.js":
/*!**************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-97d577a9.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ addItemState),
/* harmony export */   b: () => (/* binding */ addItemUrlState),
/* harmony export */   c: () => (/* binding */ addItemRequestState),
/* harmony export */   d: () => (/* binding */ addItemStore)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const addItemStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  typeKeywords: [],
  customParameters: [],
  analyzedLocationTypes: [],
  allowStoredAuth: true,
  isSecured: null,
  checkAuth: false
});
// Entire add item state object
const addItemState = addItemStore.state;
// Subsets of add item state
const addItemRequestState = addItemStore.state;
const addItemUrlState = addItemStore.state;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-new-item-pages-tile-layer-from-url.entry.js":
/*!********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-new-item-pages-tile-layer-from-url.entry.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_new_item_pages_tile_layer_from_url: () => (/* binding */ ArcgisNewItemPagesTileLayerFromUrl)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add-item-97d577a9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-97d577a9.js");
/* harmony import */ var _ui_ecf86bba_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui-ecf86bba.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ui-ecf86bba.js");
/* harmony import */ var _functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functional-9f648bee.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-9f648bee.js");
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */







const arcgisNewItemPagesTileLayerFromUrlCss = ".input-container{margin-bottom:1.5rem}.label{color:var(--calcite-ui-text-1);display:block;font-size:0.875rem;font-weight:500;margin-top:0;margin-bottom:0;line-height:18px}calcite-label{--calcite-label-margin-bottom:0}.subdomain-container{margin-bottom:1.5rem}";

const ArcgisNewItemPagesTileLayerFromUrl = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.workflowComplete = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "workflowComplete", 7);
    this.showSubdomains = false;
    this.handleChange = (event) => {
      const checked = event.target.checked;
      _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_1__.a.storeAuth = checked;
    };
    this.handleLoaderUpdate = (event) => {
      this.loading = event.detail;
    };
    this.getPlaceholder = (type) => {
      const { i18n } = this;
      switch (type) {
        case "title":
          return i18n.titlePlaceholder;
        case "attribution":
          return i18n.attribution;
        case "subdomain":
          return "https://{subDomain}.domain.com/<path>/{level}/{col}/{row}.png";
      }
    };
    this.assignRef = (ref, type) => {
      if (type === "title") {
        this.titleInputRef = ref;
      }
      else {
        this.attributionInputRef = ref;
      }
    };
    this.handleKeydown = (e) => {
      var _a;
      // If user typed a comma, treat as enter.
      // TODO: remove after calcite enables comma support (https://github.com/Esri/calcite-components/issues/4672)
      if (e.key === ",") {
        const target = e.target;
        const input = (_a = target === null || target === void 0 ? void 0 : target.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector("input");
        if (input === null || input === void 0 ? void 0 : input.value) {
          e.preventDefault();
          const existing = target.querySelector(`calcite-combobox-item[value="${input.value}"]`);
          if (existing) {
            existing.selected = true;
          }
          else {
            const item = document.createElement("calcite-combobox-item");
            item.value = input.value;
            item.textLabel = input.value;
            item.selected = true;
            target === null || target === void 0 ? void 0 : target.appendChild(item);
          }
          input.value = "";
        }
      }
    };
    this.i18n = undefined;
    this.errorMessage = undefined;
    this.loading = false;
    this.title = "";
    this.attribution = null;
    this.subdomains = [];
    this.useCurrentExtent = false;
  }
  async handleNext() {
    const { i18n, title, attribution, subdomains = null, useCurrentExtent } = this;
    const { url, customParameters, addAsBasemap } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_1__.a;
    this.errorMessage = null;
    if (!title) {
      this.errorMessage = i18n.error.title;
      this.titleInputRef.setFocus();
      return;
    }
    if (!attribution) {
      this.errorMessage = i18n.error.attribution;
      this.attributionInputRef.setFocus();
      return;
    }
    this.loading = true;
    if (this.isAddToMapTerminalPage()) {
      this.workflowComplete.emit({
        title,
        attribution,
        subdomain: subdomains.join(","),
        useCurrentExtent,
        url,
        customParameters,
        type: "Tile Layer",
        addAsBasemap
      });
    }
  }
  async componentWillLoad() {
    const i18n = _ui_ecf86bba_js__WEBPACK_IMPORTED_MODULE_2__.u.i18n;
    this.i18n = i18n.tileLayerFromUrl;
    if (this.isAddToMapTerminalPage()) {
      _ui_ecf86bba_js__WEBPACK_IMPORTED_MODULE_2__.u.nextText = "addToMap";
    }
    this.showSubdomains = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_1__.a.url.toLowerCase().includes("{subdomain}");
    // TODO: assign state from store once this is not a terminal page
  }
  isAddToMapTerminalPage() {
    // ! Note: this page only supports direct mode for now
    return true;
  }
  render() {
    const { loading, errorMessage, i18n, getPlaceholder, assignRef, handleKeydown, showSubdomains } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-loader", { active: loading }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-alert", { active: !!errorMessage, description: errorMessage, onAlertDismiss: () => (this.errorMessage = "") }), ["title", "attribution"].map((type) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "label" }, i18n[type]), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { class: "input-container", placeholder: getPlaceholder(type), ref: (ref) => assignRef(ref, type), value: this[type], required: true, onCalciteInputInput: (e) => (this[type] = e.target.value) })))), showSubdomains && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "subdomain-container" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "label" }, i18n.subdomain), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-combobox", { label: i18n.subdomain, allowCustomValues: true, placeholder: i18n.subDomainPlaceholder, onKeyDown: handleKeydown, onCalciteComboboxChange: (event) => {
        event.stopPropagation();
        const node = event.target;
        this.subdomains = (0,_functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_3__.f)(node.selectedItems.map((item) => item.value));
      } })))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-switch-card", { header: i18n.setTileExtent, onSwitchChange: (event) => {
        this.useCurrentExtent = event.detail;
      } })));
  }
  get element() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisNewItemPagesTileLayerFromUrl.style = arcgisNewItemPagesTileLayerFromUrlCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-9f648bee.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-9f648bee.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ formatFileName),
/* harmony export */   f: () => (/* binding */ formatTags),
/* harmony export */   s: () => (/* binding */ streamPromises)
/* harmony export */ });
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const formatFileName = (title) => (title === null || title === void 0 ? void 0 : title.replace(/(\s+|:)/g, "_")) || "";
const formatTags = (tags) => {
  const cleanTags = (tagObj) => {
    return tagObj
      .split(",")
      .map((tag) => tag.trim())
      .filter((tag) => tag);
  };
  if (!tags) {
    return [];
  }
  else if (typeof tags === "string") {
    return (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_0__.b)(cleanTags(tags));
  }
  else {
    return (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_0__.b)(tags.flatMap((tag) => {
      return [...cleanTags(tag)];
    }));
  }
};
const resolveOnFirstPromise = async (promiseList) => {
  return new Promise((resolve, reject) => {
    for (let i = 0; i < promiseList.length; i++) {
      promiseList[i]
        .then((result) => {
        const newArr = [...promiseList];
        newArr.splice(i, 1);
        resolve({ remainingPromises: newArr, result });
      })
        .catch(reject);
    }
  });
};
/**
 * Similar to Promise.all but will resolve on the first promise that resolves then continuously swap out the resolved promise with the next promise in the list
 * @param getNextPromise A function that returns the next promise to resolve
 */
async function streamPromises(getNextPromise, options) {
  var _a, _b;
  const results = [];
  const { getBatchSize, onPromiseCompleted, onPromiseThrow, shouldContinue } = options !== null && options !== void 0 ? options : {};
  let remainingPromises = [];
  for (let i = 0; i < ((_a = getBatchSize === null || getBatchSize === void 0 ? void 0 : getBatchSize()) !== null && _a !== void 0 ? _a : 1); i++) {
    try {
      const nextElement = getNextPromise();
      nextElement && remainingPromises.push(nextElement);
    }
    catch (e) {
      onPromiseThrow === null || onPromiseThrow === void 0 ? void 0 : onPromiseThrow(e);
    }
  }
  let lastResult = null;
  while (remainingPromises.length > 0 && (!shouldContinue || shouldContinue(lastResult))) {
    try {
      const { remainingPromises: _remainingPromises, result } = await resolveOnFirstPromise(remainingPromises);
      remainingPromises = _remainingPromises;
      lastResult = result;
      !!result && results.push(result);
      onPromiseCompleted === null || onPromiseCompleted === void 0 ? void 0 : onPromiseCompleted(result);
      // Update batch size after the new result is bubbled up
      const batchSize = (_b = getBatchSize === null || getBatchSize === void 0 ? void 0 : getBatchSize()) !== null && _b !== void 0 ? _b : 1;
      while (remainingPromises.length < batchSize) {
        const nextElement = getNextPromise();
        nextElement && remainingPromises.push(nextElement);
        if (nextElement == null) {
          break;
        }
      }
    }
    catch (e) {
      onPromiseThrow === null || onPromiseThrow === void 0 ? void 0 : onPromiseThrow(e);
    }
  }
  return results;
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ui-ecf86bba.js":
/*!********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ui-ecf86bba.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ uiStore),
/* harmony export */   u: () => (/* binding */ uiStoreState)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const uiStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  nextText: "next",
  workflow: "content",
  scale: "m",
  disableScroll: false,
  featureFlags: { tileLayer3dTiles: false }
});
const uiStoreState = uiStore.state;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTczNGM2Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEOztBQUV2RCxxQkFBcUIscURBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQmhHO0FBQ0E7QUFDQTtBQUNBO0FBQzZHO0FBQ2xEO0FBQ047QUFDTTtBQUM5QjtBQUNLOztBQUVsQyxnRUFBZ0UscUJBQXFCLE9BQU8sK0JBQStCLGNBQWMsbUJBQW1CLGdCQUFnQixhQUFhLGdCQUFnQixpQkFBaUIsY0FBYyxnQ0FBZ0MscUJBQXFCLHFCQUFxQjs7QUFFbFQ7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCLDRCQUE0QixxREFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFZO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsb0JBQW9CLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixZQUFZO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFnRTtBQUM1RSxZQUFZLHNDQUFzQyxF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QUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEOztBQUV2RCxnQkFBZ0IscURBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsQ0FBQztBQUNEOztBQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FkZC1pdGVtLTk3ZDU3N2E5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1uZXctaXRlbS1wYWdlcy10aWxlLWxheWVyLWZyb20tdXJsLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtOWY2NDhiZWUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9pbmRleC04MWQ1NDhiNy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS91aS1lY2Y4NmJiYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlU3RvcmUgfSBmcm9tICcuL2luZGV4LTgxZDU0OGI3LmpzJztcblxuY29uc3QgYWRkSXRlbVN0b3JlID0gY3JlYXRlU3RvcmUoe1xuICB0eXBlS2V5d29yZHM6IFtdLFxuICBjdXN0b21QYXJhbWV0ZXJzOiBbXSxcbiAgYW5hbHl6ZWRMb2NhdGlvblR5cGVzOiBbXSxcbiAgYWxsb3dTdG9yZWRBdXRoOiB0cnVlLFxuICBpc1NlY3VyZWQ6IG51bGwsXG4gIGNoZWNrQXV0aDogZmFsc2Vcbn0pO1xuLy8gRW50aXJlIGFkZCBpdGVtIHN0YXRlIG9iamVjdFxuY29uc3QgYWRkSXRlbVN0YXRlID0gYWRkSXRlbVN0b3JlLnN0YXRlO1xuLy8gU3Vic2V0cyBvZiBhZGQgaXRlbSBzdGF0ZVxuY29uc3QgYWRkSXRlbVJlcXVlc3RTdGF0ZSA9IGFkZEl0ZW1TdG9yZS5zdGF0ZTtcbmNvbnN0IGFkZEl0ZW1VcmxTdGF0ZSA9IGFkZEl0ZW1TdG9yZS5zdGF0ZTtcblxuZXhwb3J0IHsgYWRkSXRlbVN0YXRlIGFzIGEsIGFkZEl0ZW1VcmxTdGF0ZSBhcyBiLCBhZGRJdGVtUmVxdWVzdFN0YXRlIGFzIGMsIGFkZEl0ZW1TdG9yZSBhcyBkIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcbmltcG9ydCB7IGEgYXMgYWRkSXRlbVN0YXRlIH0gZnJvbSAnLi9hZGQtaXRlbS05N2Q1NzdhOS5qcyc7XG5pbXBvcnQgeyB1IGFzIHVpU3RvcmVTdGF0ZSB9IGZyb20gJy4vdWktZWNmODZiYmEuanMnO1xuaW1wb3J0IHsgZiBhcyBmb3JtYXRUYWdzIH0gZnJvbSAnLi9mdW5jdGlvbmFsLTlmNjQ4YmVlLmpzJztcbmltcG9ydCAnLi9pbmRleC04MWQ1NDhiNy5qcyc7XG5pbXBvcnQgJy4vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyc7XG5cbmNvbnN0IGFyY2dpc05ld0l0ZW1QYWdlc1RpbGVMYXllckZyb21VcmxDc3MgPSBcIi5pbnB1dC1jb250YWluZXJ7bWFyZ2luLWJvdHRvbToxLjVyZW19LmxhYmVse2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKTtkaXNwbGF5OmJsb2NrO2ZvbnQtc2l6ZTowLjg3NXJlbTtmb250LXdlaWdodDo1MDA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDtsaW5lLWhlaWdodDoxOHB4fWNhbGNpdGUtbGFiZWx7LS1jYWxjaXRlLWxhYmVsLW1hcmdpbi1ib3R0b206MH0uc3ViZG9tYWluLWNvbnRhaW5lcnttYXJnaW4tYm90dG9tOjEuNXJlbX1cIjtcblxuY29uc3QgQXJjZ2lzTmV3SXRlbVBhZ2VzVGlsZUxheWVyRnJvbVVybCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy53b3JrZmxvd0NvbXBsZXRlID0gY3JlYXRlRXZlbnQodGhpcywgXCJ3b3JrZmxvd0NvbXBsZXRlXCIsIDcpO1xuICAgIHRoaXMuc2hvd1N1YmRvbWFpbnMgPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgY2hlY2tlZCA9IGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgYWRkSXRlbVN0YXRlLnN0b3JlQXV0aCA9IGNoZWNrZWQ7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUxvYWRlclVwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5sb2FkaW5nID0gZXZlbnQuZGV0YWlsO1xuICAgIH07XG4gICAgdGhpcy5nZXRQbGFjZWhvbGRlciA9ICh0eXBlKSA9PiB7XG4gICAgICBjb25zdCB7IGkxOG4gfSA9IHRoaXM7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgcmV0dXJuIGkxOG4udGl0bGVQbGFjZWhvbGRlcjtcbiAgICAgICAgY2FzZSBcImF0dHJpYnV0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIGkxOG4uYXR0cmlidXRpb247XG4gICAgICAgIGNhc2UgXCJzdWJkb21haW5cIjpcbiAgICAgICAgICByZXR1cm4gXCJodHRwczovL3tzdWJEb21haW59LmRvbWFpbi5jb20vPHBhdGg+L3tsZXZlbH0ve2NvbH0ve3Jvd30ucG5nXCI7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFzc2lnblJlZiA9IChyZWYsIHR5cGUpID0+IHtcbiAgICAgIGlmICh0eXBlID09PSBcInRpdGxlXCIpIHtcbiAgICAgICAgdGhpcy50aXRsZUlucHV0UmVmID0gcmVmO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRpb25JbnB1dFJlZiA9IHJlZjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlS2V5ZG93biA9IChlKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAvLyBJZiB1c2VyIHR5cGVkIGEgY29tbWEsIHRyZWF0IGFzIGVudGVyLlxuICAgICAgLy8gVE9ETzogcmVtb3ZlIGFmdGVyIGNhbGNpdGUgZW5hYmxlcyBjb21tYSBzdXBwb3J0IChodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvaXNzdWVzLzQ2NzIpXG4gICAgICBpZiAoZS5rZXkgPT09IFwiLFwiKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBjb25zdCBpbnB1dCA9IChfYSA9IHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYGNhbGNpdGUtY29tYm9ib3gtaXRlbVt2YWx1ZT1cIiR7aW5wdXQudmFsdWV9XCJdYCk7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICBleGlzdGluZy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYWxjaXRlLWNvbWJvYm94LWl0ZW1cIik7XG4gICAgICAgICAgICBpdGVtLnZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICBpdGVtLnRleHRMYWJlbCA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pMThuID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMudGl0bGUgPSBcIlwiO1xuICAgIHRoaXMuYXR0cmlidXRpb24gPSBudWxsO1xuICAgIHRoaXMuc3ViZG9tYWlucyA9IFtdO1xuICAgIHRoaXMudXNlQ3VycmVudEV4dGVudCA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIGhhbmRsZU5leHQoKSB7XG4gICAgY29uc3QgeyBpMThuLCB0aXRsZSwgYXR0cmlidXRpb24sIHN1YmRvbWFpbnMgPSBudWxsLCB1c2VDdXJyZW50RXh0ZW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdXJsLCBjdXN0b21QYXJhbWV0ZXJzLCBhZGRBc0Jhc2VtYXAgfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBpMThuLmVycm9yLnRpdGxlO1xuICAgICAgdGhpcy50aXRsZUlucHV0UmVmLnNldEZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghYXR0cmlidXRpb24pIHtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gaTE4bi5lcnJvci5hdHRyaWJ1dGlvbjtcbiAgICAgIHRoaXMuYXR0cmlidXRpb25JbnB1dFJlZi5zZXRGb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmlzQWRkVG9NYXBUZXJtaW5hbFBhZ2UoKSkge1xuICAgICAgdGhpcy53b3JrZmxvd0NvbXBsZXRlLmVtaXQoe1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgYXR0cmlidXRpb24sXG4gICAgICAgIHN1YmRvbWFpbjogc3ViZG9tYWlucy5qb2luKFwiLFwiKSxcbiAgICAgICAgdXNlQ3VycmVudEV4dGVudCxcbiAgICAgICAgdXJsLFxuICAgICAgICBjdXN0b21QYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlOiBcIlRpbGUgTGF5ZXJcIixcbiAgICAgICAgYWRkQXNCYXNlbWFwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgY29uc3QgaTE4biA9IHVpU3RvcmVTdGF0ZS5pMThuO1xuICAgIHRoaXMuaTE4biA9IGkxOG4udGlsZUxheWVyRnJvbVVybDtcbiAgICBpZiAodGhpcy5pc0FkZFRvTWFwVGVybWluYWxQYWdlKCkpIHtcbiAgICAgIHVpU3RvcmVTdGF0ZS5uZXh0VGV4dCA9IFwiYWRkVG9NYXBcIjtcbiAgICB9XG4gICAgdGhpcy5zaG93U3ViZG9tYWlucyA9IGFkZEl0ZW1TdGF0ZS51cmwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIntzdWJkb21haW59XCIpO1xuICAgIC8vIFRPRE86IGFzc2lnbiBzdGF0ZSBmcm9tIHN0b3JlIG9uY2UgdGhpcyBpcyBub3QgYSB0ZXJtaW5hbCBwYWdlXG4gIH1cbiAgaXNBZGRUb01hcFRlcm1pbmFsUGFnZSgpIHtcbiAgICAvLyAhIE5vdGU6IHRoaXMgcGFnZSBvbmx5IHN1cHBvcnRzIGRpcmVjdCBtb2RlIGZvciBub3dcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBsb2FkaW5nLCBlcnJvck1lc3NhZ2UsIGkxOG4sIGdldFBsYWNlaG9sZGVyLCBhc3NpZ25SZWYsIGhhbmRsZUtleWRvd24sIHNob3dTdWJkb21haW5zIH0gPSB0aGlzO1xuICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiYXJjZ2lzLW5ldy1pdGVtLWxvYWRlclwiLCB7IGFjdGl2ZTogbG9hZGluZyB9KSwgaChcImFyY2dpcy1uZXctaXRlbS1hbGVydFwiLCB7IGFjdGl2ZTogISFlcnJvck1lc3NhZ2UsIGRlc2NyaXB0aW9uOiBlcnJvck1lc3NhZ2UsIG9uQWxlcnREaXNtaXNzOiAoKSA9PiAodGhpcy5lcnJvck1lc3NhZ2UgPSBcIlwiKSB9KSwgW1widGl0bGVcIiwgXCJhdHRyaWJ1dGlvblwiXS5tYXAoKHR5cGUpID0+IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBoKFwicFwiLCB7IGNsYXNzOiBcImxhYmVsXCIgfSwgaTE4blt0eXBlXSksIGgoXCJjYWxjaXRlLWlucHV0XCIsIHsgY2xhc3M6IFwiaW5wdXQtY29udGFpbmVyXCIsIHBsYWNlaG9sZGVyOiBnZXRQbGFjZWhvbGRlcih0eXBlKSwgcmVmOiAocmVmKSA9PiBhc3NpZ25SZWYocmVmLCB0eXBlKSwgdmFsdWU6IHRoaXNbdHlwZV0sIHJlcXVpcmVkOiB0cnVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZSkgPT4gKHRoaXNbdHlwZV0gPSBlLnRhcmdldC52YWx1ZSkgfSkpKSksIHNob3dTdWJkb21haW5zICYmIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwic3ViZG9tYWluLWNvbnRhaW5lclwiIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIGgoXCJwXCIsIHsgY2xhc3M6IFwibGFiZWxcIiB9LCBpMThuLnN1YmRvbWFpbiksIGgoXCJjYWxjaXRlLWNvbWJvYm94XCIsIHsgbGFiZWw6IGkxOG4uc3ViZG9tYWluLCBhbGxvd0N1c3RvbVZhbHVlczogdHJ1ZSwgcGxhY2Vob2xkZXI6IGkxOG4uc3ViRG9tYWluUGxhY2Vob2xkZXIsIG9uS2V5RG93bjogaGFuZGxlS2V5ZG93biwgb25DYWxjaXRlQ29tYm9ib3hDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdGhpcy5zdWJkb21haW5zID0gZm9ybWF0VGFncyhub2RlLnNlbGVjdGVkSXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLnZhbHVlKSk7XG4gICAgICB9IH0pKSkpLCBoKFwiYXJjZ2lzLW5ldy1pdGVtLXN3aXRjaC1jYXJkXCIsIHsgaGVhZGVyOiBpMThuLnNldFRpbGVFeHRlbnQsIG9uU3dpdGNoQ2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy51c2VDdXJyZW50RXh0ZW50ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgfSB9KSkpO1xuICB9XG4gIGdldCBlbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc05ld0l0ZW1QYWdlc1RpbGVMYXllckZyb21Vcmwuc3R5bGUgPSBhcmNnaXNOZXdJdGVtUGFnZXNUaWxlTGF5ZXJGcm9tVXJsQ3NzO1xuXG5leHBvcnQgeyBBcmNnaXNOZXdJdGVtUGFnZXNUaWxlTGF5ZXJGcm9tVXJsIGFzIGFyY2dpc19uZXdfaXRlbV9wYWdlc190aWxlX2xheWVyX2Zyb21fdXJsIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGIgYXMgdW5pcXVlIH0gZnJvbSAnLi9mdW5jdGlvbmFsLWM4MmY1YWI5LmpzJztcblxuY29uc3QgZm9ybWF0RmlsZU5hbWUgPSAodGl0bGUpID0+ICh0aXRsZSA9PT0gbnVsbCB8fCB0aXRsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGl0bGUucmVwbGFjZSgvKFxccyt8OikvZywgXCJfXCIpKSB8fCBcIlwiO1xuY29uc3QgZm9ybWF0VGFncyA9ICh0YWdzKSA9PiB7XG4gIGNvbnN0IGNsZWFuVGFncyA9ICh0YWdPYmopID0+IHtcbiAgICByZXR1cm4gdGFnT2JqXG4gICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAubWFwKCh0YWcpID0+IHRhZy50cmltKCkpXG4gICAgICAuZmlsdGVyKCh0YWcpID0+IHRhZyk7XG4gIH07XG4gIGlmICghdGFncykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgdGFncyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB1bmlxdWUoY2xlYW5UYWdzKHRhZ3MpKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdW5pcXVlKHRhZ3MuZmxhdE1hcCgodGFnKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLmNsZWFuVGFncyh0YWcpXTtcbiAgICB9KSk7XG4gIH1cbn07XG5jb25zdCByZXNvbHZlT25GaXJzdFByb21pc2UgPSBhc3luYyAocHJvbWlzZUxpc3QpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlTGlzdFtpXVxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0FyciA9IFsuLi5wcm9taXNlTGlzdF07XG4gICAgICAgIG5ld0Fyci5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJlc29sdmUoeyByZW1haW5pbmdQcm9taXNlczogbmV3QXJyLCByZXN1bHQgfSk7XG4gICAgICB9KVxuICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qKlxuICogU2ltaWxhciB0byBQcm9taXNlLmFsbCBidXQgd2lsbCByZXNvbHZlIG9uIHRoZSBmaXJzdCBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlbiBjb250aW51b3VzbHkgc3dhcCBvdXQgdGhlIHJlc29sdmVkIHByb21pc2Ugd2l0aCB0aGUgbmV4dCBwcm9taXNlIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0gZ2V0TmV4dFByb21pc2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgcHJvbWlzZSB0byByZXNvbHZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVByb21pc2VzKGdldE5leHRQcm9taXNlLCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBnZXRCYXRjaFNpemUsIG9uUHJvbWlzZUNvbXBsZXRlZCwgb25Qcm9taXNlVGhyb3csIHNob3VsZENvbnRpbnVlIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgbGV0IHJlbWFpbmluZ1Byb21pc2VzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgKChfYSA9IGdldEJhdGNoU2l6ZSA9PT0gbnVsbCB8fCBnZXRCYXRjaFNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldEJhdGNoU2l6ZSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKTsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZ2V0TmV4dFByb21pc2UoKTtcbiAgICAgIG5leHRFbGVtZW50ICYmIHJlbWFpbmluZ1Byb21pc2VzLnB1c2gobmV4dEVsZW1lbnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgb25Qcm9taXNlVGhyb3cgPT09IG51bGwgfHwgb25Qcm9taXNlVGhyb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUHJvbWlzZVRocm93KGUpO1xuICAgIH1cbiAgfVxuICBsZXQgbGFzdFJlc3VsdCA9IG51bGw7XG4gIHdoaWxlIChyZW1haW5pbmdQcm9taXNlcy5sZW5ndGggPiAwICYmICghc2hvdWxkQ29udGludWUgfHwgc2hvdWxkQ29udGludWUobGFzdFJlc3VsdCkpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgcmVtYWluaW5nUHJvbWlzZXM6IF9yZW1haW5pbmdQcm9taXNlcywgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlT25GaXJzdFByb21pc2UocmVtYWluaW5nUHJvbWlzZXMpO1xuICAgICAgcmVtYWluaW5nUHJvbWlzZXMgPSBfcmVtYWluaW5nUHJvbWlzZXM7XG4gICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgISFyZXN1bHQgJiYgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICBvblByb21pc2VDb21wbGV0ZWQgPT09IG51bGwgfHwgb25Qcm9taXNlQ29tcGxldGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblByb21pc2VDb21wbGV0ZWQocmVzdWx0KTtcbiAgICAgIC8vIFVwZGF0ZSBiYXRjaCBzaXplIGFmdGVyIHRoZSBuZXcgcmVzdWx0IGlzIGJ1YmJsZWQgdXBcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IChfYiA9IGdldEJhdGNoU2l6ZSA9PT0gbnVsbCB8fCBnZXRCYXRjaFNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldEJhdGNoU2l6ZSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ1Byb21pc2VzLmxlbmd0aCA8IGJhdGNoU2l6ZSkge1xuICAgICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGdldE5leHRQcm9taXNlKCk7XG4gICAgICAgIG5leHRFbGVtZW50ICYmIHJlbWFpbmluZ1Byb21pc2VzLnB1c2gobmV4dEVsZW1lbnQpO1xuICAgICAgICBpZiAobmV4dEVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBvblByb21pc2VUaHJvdyA9PT0gbnVsbCB8fCBvblByb21pc2VUaHJvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Qcm9taXNlVGhyb3coZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgeyBmb3JtYXRGaWxlTmFtZSBhcyBhLCBmb3JtYXRUYWdzIGFzIGYsIHN0cmVhbVByb21pc2VzIGFzIHMgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgIHJldHVybiBzdGF0dXM7XG4gIH1cbiAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICBjb25zdCBvYmpzID0gW107XG4gIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyaW5nUmVmLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5cbmNvbnN0IGFwcGVuZFRvTWFwID0gKG1hcCwgcHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXAuZ2V0KHByb3BOYW1lKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIG1hcC5zZXQocHJvcE5hbWUsIFt2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRlbXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBkZWJvdW5jZSA9IChmbiwgbXMpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9zc2libGUgZWxlbWVudCBpc0Nvbm5lY3RlZC5cbiAqIFRoZSBwcm9wZXJ0eSBtaWdodCBub3QgYmUgdGhlcmUsIHNvIHdlIGNoZWNrIGZvciBpdC5cbiAqXG4gKiBXZSB3YW50IGl0IHRvIHJldHVybiB0cnVlIGlmIGlzQ29ubmVjdGVkIGlzIG5vdCBhIHByb3BlcnR5LFxuICogb3RoZXJ3aXNlIHdlIHdvdWxkIHJlbW92ZSB0aGVzZSBlbGVtZW50cyBhbmQgd291bGQgbm90IHVwZGF0ZS5cbiAqXG4gKiBCZXR0ZXIgbGVhayBpbiBFZGdlIHRoYW4gdG8gYmUgdXNlbGVzcy5cbiAqL1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobWF5YmVFbGVtZW50KSA9PiAhKCdpc0Nvbm5lY3RlZCcgaW4gbWF5YmVFbGVtZW50KSB8fCBtYXliZUVsZW1lbnQuaXNDb25uZWN0ZWQ7XG5jb25zdCBjbGVhbnVwRWxlbWVudHMgPSBkZWJvdW5jZSgobWFwKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5nZXQoa2V5KS5maWx0ZXIoaXNDb25uZWN0ZWQpKTtcbiAgICB9XG59LCAyMDAwKTtcbmNvbnN0IHN0ZW5jaWxTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnZXRSZW5kZXJpbmdSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIHN0ZW5jaWwgcHJvamVjdCwgd2UgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IGV4cG9ydGVkIGJ5IEBzdGVuY2lsL2NvcmUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxtc1RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGVsbXNUb1VwZGF0ZS5jbGVhcigpLFxuICAgICAgICBnZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gZ2V0UmVuZGVyaW5nUmVmKCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9NYXAoZWxtc1RvVXBkYXRlLCBwcm9wTmFtZSwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxtc1RvVXBkYXRlLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbG1zVG9VcGRhdGUuc2V0KHByb3BOYW1lLCBlbGVtZW50cy5maWx0ZXIoZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgZWxtc1RvVXBkYXRlLmZvckVhY2goKGVsbXMpID0+IGVsbXMuZm9yRWFjaChmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHVud3JhcCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKCkgOiB2YWwpO1xuY29uc3QgY3JlYXRlT2JzZXJ2YWJsZU1hcCA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSA9IChhLCBiKSA9PiBhICE9PSBiKSA9PiB7XG4gICAgY29uc3QgdW53cmFwcGVkU3RhdGUgPSB1bndyYXAoZGVmYXVsdFN0YXRlKTtcbiAgICBsZXQgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh1bndyYXBwZWRTdGF0ZSAhPT0gbnVsbCAmJiB1bndyYXBwZWRTdGF0ZSAhPT0gdm9pZCAwID8gdW53cmFwcGVkU3RhdGUgOiB7fSkpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICBkaXNwb3NlOiBbXSxcbiAgICAgICAgZ2V0OiBbXSxcbiAgICAgICAgc2V0OiBbXSxcbiAgICAgICAgcmVzZXQ6IFtdLFxuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV2hlbiByZXNldHRpbmcgdGhlIHN0YXRlLCB0aGUgZGVmYXVsdCBzdGF0ZSBtYXkgYmUgYSBmdW5jdGlvbiAtIHVud3JhcCBpdCB0byBpbnZva2UgaXQuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHN0YXRlIHdvbid0IGJlIHByb3Blcmx5IHJlc2V0XG4gICAgICAgIHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoKF9hID0gdW53cmFwKGRlZmF1bHRTdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSk7XG4gICAgICAgIGhhbmRsZXJzLnJlc2V0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZmlyc3QgZGlzcG9zZSBhcyByZXNldHRpbmcgdGhlIHN0YXRlIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGxlc3MgdXBkYXRlcyA7KVxuICAgICAgICBoYW5kbGVycy5kaXNwb3NlLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICBoYW5kbGVycy5nZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldCA9IChwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgc3RhdGVzLnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSwgdmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0gKHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7fVxuICAgICAgICA6IG5ldyBQcm94eSh1bndyYXBwZWRTdGF0ZSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmtleXMoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhcyhfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXMuaGFzKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoXywgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgY29uc3Qgb24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBoYW5kbGVyc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGhhbmRsZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHByb3BOYW1lLCBjYikgPT4ge1xuICAgICAgICBjb25zdCB1blNldCA9IG9uKCdzZXQnLCAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVud3JhcCB0aGUgZGVmYXVsdFN0YXRlIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IG5vdCBiZSBzZW5kaW5nIHRoZSByaWdodCByZXNldCB2YWx1ZS5cbiAgICAgICAgY29uc3QgdW5SZXNldCA9IG9uKCdyZXNldCcsICgpID0+IGNiKHVud3JhcChkZWZhdWx0U3RhdGUpW3Byb3BOYW1lXSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5TZXQoKTtcbiAgICAgICAgICAgIHVuUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZSA9ICguLi5zdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3VicyA9IHN1YnNjcmlwdGlvbnMucmVkdWNlKCh1bnN1YnMsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignc2V0Jywgc3Vic2NyaXB0aW9uLnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5nZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZ2V0Jywgc3Vic2NyaXB0aW9uLmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5yZXNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdyZXNldCcsIHN1YnNjcmlwdGlvbi5yZXNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2Rpc3Bvc2UnLCBzdWJzY3JpcHRpb24uZGlzcG9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuc3VicztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5zdWJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihrZXksIG9sZFZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBvbixcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHVzZSxcbiAgICAgICAgZGlzcG9zZSxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGZvcmNlVXBkYXRlLFxuICAgIH07XG59O1xuY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBhcnJheS5sZW5ndGgtLTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGNyZWF0ZU9ic2VydmFibGVNYXAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpO1xuICAgIG1hcC51c2Uoc3RlbmNpbFN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgYXMgYyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNyZWF0ZVN0b3JlIH0gZnJvbSAnLi9pbmRleC04MWQ1NDhiNy5qcyc7XG5cbmNvbnN0IHVpU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gIG5leHRUZXh0OiBcIm5leHRcIixcbiAgd29ya2Zsb3c6IFwiY29udGVudFwiLFxuICBzY2FsZTogXCJtXCIsXG4gIGRpc2FibGVTY3JvbGw6IGZhbHNlLFxuICBmZWF0dXJlRmxhZ3M6IHsgdGlsZUxheWVyM2RUaWxlczogZmFsc2UgfVxufSk7XG5jb25zdCB1aVN0b3JlU3RhdGUgPSB1aVN0b3JlLnN0YXRlO1xuXG5leHBvcnQgeyB1aVN0b3JlIGFzIGEsIHVpU3RvcmVTdGF0ZSBhcyB1IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=