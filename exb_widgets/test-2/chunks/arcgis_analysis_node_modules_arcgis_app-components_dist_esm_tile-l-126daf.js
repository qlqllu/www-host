"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_tile-l-126daf"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/tile-layer-f8be7028.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/tile-layer-f8be7028.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ canUseLayerForPublishTiles),
/* harmony export */   b: () => (/* binding */ getTileLayerInfo),
/* harmony export */   c: () => (/* binding */ canUseRendererForPublishTiles),
/* harmony export */   d: () => (/* binding */ getPublishTileLayerParams),
/* harmony export */   e: () => (/* binding */ getSuggestedScaleRange),
/* harmony export */   f: () => (/* binding */ formUpdateItemDataForTileLayer),
/* harmony export */   g: () => (/* binding */ getDatastoreServers),
/* harmony export */   h: () => (/* binding */ checkTilesOnDemandSupport),
/* harmony export */   l: () => (/* binding */ layerHasClustering),
/* harmony export */   p: () => (/* binding */ publishTileLayer)
/* harmony export */ });
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _tile_layer_90a6b901_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tile-layer-90a6b901.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/tile-layer-90a6b901.js");
/* harmony import */ var _feature_layer_38cdae87_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./feature-layer-38cdae87.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-38cdae87.js");
/* harmony import */ var _functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-9f648bee.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-9f648bee.js");
/* harmony import */ var _server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./server-item-f12153e6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/server-item-f12153e6.js");
/* harmony import */ var _portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./portal-79caaeff.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */








// TODO: test --- add unit test!
var __rest = ( false) || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
const addScaleLabels = (tileInfo) => (Object.assign(Object.assign({}, tileInfo), { lods: (tileInfo.lods || []).map((lod) => (Object.assign(Object.assign({}, lod), { label: `1:${Math.round(lod.scale).toLocaleString("en-EN", { maximumFractionDigits: 0 })}` }))) }));
const normalizeMaxScale = (min, max, lods) => {
  var _a, _b;
  // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/10524
  if (min <= max && (lods === null || lods === void 0 ? void 0 : lods.length) > 0) {
    let maxIdx = -1;
    // go through lods and find closest lod to min scale, then find max scale two lods down, or last one
    for (let i = lods.length - 1; i >= 0; i--) {
      if (min < lods[i].scale) {
        maxIdx = i + 2;
        break;
      }
    }
    maxIdx = maxIdx > lods.length - 1 ? lods.length - 1 : maxIdx;
    return (_b = (_a = lods[maxIdx]) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : max;
  }
  return max;
};
/** Check if we support on demand, exclusively for "tiles" type */
const checkTilesOnDemandSupport = (layers, tilesOnDemandEnabled) => {
  let canShowTilesOnDemand = false;
  if (tilesOnDemandEnabled && (layers === null || layers === void 0 ? void 0 : layers.length) > 0) {
    canShowTilesOnDemand = !layers.some(
    // tiles on demand aren't allowed when labeling turned on
    (layer) => !canUseLayerForPublish(layer, false, "tiles"));
  }
  return canShowTilesOnDemand;
};
// * --- Publishing tile stuff
function canUseLayerForPublish(layerInfo, allowLabels, type) {
  if (layerInfo.type !== "Feature Layer" || !layerInfo.drawingInfo) {
    // Wrong layer type
    return false;
  }
  if (type === "scenes") {
    return canUseLayerForPublishScene(layerInfo, allowLabels);
  }
  return canUseLayerForPublishTiles(layerInfo, allowLabels);
}
function canUseLayerForPublishTiles(layerInfo, allowLabels) {
  var _a, _b;
  if (layerInfo.geometryType === "esriGeometryMultiPatch") {
    // MultiPatch
    return false;
  }
  const renderer = (_a = layerInfo.drawingInfo) === null || _a === void 0 ? void 0 : _a.renderer;
  const labelingInfo = (_b = layerInfo.drawingInfo) === null || _b === void 0 ? void 0 : _b.labelingInfo;
  const fields = layerInfo.fields;
  // clustering
  if (layerHasClustering(layerInfo)) {
    return false;
  }
  if (renderer &&
    layerInfo.geometryType &&
    (fields === null || fields === void 0 ? void 0 : fields.length) > 0 &&
    !canUseRendererForPublishTiles(renderer, layerInfo.geometryType, fields)) {
    return false;
  }
  // labels
  if (!allowLabels && (labelingInfo === null || labelingInfo === void 0 ? void 0 : labelingInfo.length)) {
    return false;
  }
  return true;
}
const layerHasClustering = (layerInfo) => {
  var _a, _b;
  const featureReduction = (_a = layerInfo.featureReduction) !== null && _a !== void 0 ? _a : (_b = layerInfo.layerDefinition) === null || _b === void 0 ? void 0 : _b.featureReduction;
  return !!featureReduction && Object.keys(featureReduction).length > 0;
};
const canUseRendererForPublishTiles = (renderer, geometryType, fields) => {
  var _a;
  // heatmap renderer
  if (renderer.type === "heatmap") {
    return false;
  }
  // scale dependent marker sizing on polygon layer
  /*
    if (layerInfo.geometryType === "esriGeometryPolygon" && renderer.visualVariables) {
      if (array.some(renderer.visualVariables, function (visVar) {
          // {target: "outline"} is OK
          if (visVar.type === "sizeInfo" && !visVar.target &&
            (typeof visVar.minSize === "object" || typeof visVar.maxSize === "object")) {
            return true;
          }
        })
      ) {
        return false;
      }
    }
    */
  // type + size on polygon layer
  if (geometryType === "esriGeometryPolygon" && renderer.uniqueValueInfos && renderer.visualVariables) {
    if (renderer.visualVariables.some((visVar) => {
      if (visVar.type === "sizeInfo" && !visVar.target) {
        return true;
      }
    })) {
      return false;
    }
  }
  // date fields
  const dateFields = fields.filter((field) => field.type === "esriFieldTypeDate").map((field) => field.name);
  if (dateFields.length) {
    // renderer using date field
    if (dateFields.indexOf(renderer.field) > -1 || dateFields.indexOf(renderer.field1) > -1) {
      return false;
    }
    // visual variables with date field
    if ((_a = renderer.visualVariables) === null || _a === void 0 ? void 0 : _a.some((visVar) => dateFields.indexOf(visVar.field) > -1)) {
      return false;
    }
  }
  return true;
};
function canUseLayerForPublishScene(layerInfo, allowLabels) {
  var _a, _b, _c;
  const renderer = layerInfo.drawingInfo.renderer;
  const labelingInfo = layerInfo.drawingInfo.labelingInfo;
  const featureReduction = layerInfo.featureReduction;
  const fields = layerInfo.fields;
  // only point or multiPatch layers
  if (["esriGeometryPoint", "esriGeometryMultiPatch"].indexOf(layerInfo.geometryType) === -1) {
    return false;
  }
  // stream layer
  if (renderer.observationRenderer || renderer.latestObservationRenderer) {
    return false;
  }
  // heatmap renderer
  if (renderer.type === "heatmap") {
    return false;
  }
  // Arcade expressions
  if ((_a = renderer.valueExpression) === null || _a === void 0 ? void 0 : _a.length) {
    return false;
  }
  if ((_b = renderer.visualVariables) === null || _b === void 0 ? void 0 : _b.some((visVar) => visVar.valueExpression.length)) {
    return false;
  }
  // date fields
  const dateFields = fields.filter((field) => field.type === "esriFieldTypeDate").map((field) => field.name);
  if (dateFields.length) {
    // renderer using date field
    if (dateFields.indexOf(renderer.field) > -1 || dateFields.indexOf(renderer.field1) > -1) {
      return false;
    }
    // visual variables with date field
    if ((_c = renderer.visualVariables) === null || _c === void 0 ? void 0 : _c.some((visVar) => visVar.field && dateFields.indexOf(visVar.field) > -1)) {
      return false;
    }
  }
  // clustering
  if (featureReduction) {
    return false;
  }
  // labels
  if (!allowLabels && (labelingInfo === null || labelingInfo === void 0 ? void 0 : labelingInfo.length)) {
    return false;
  }
  return true;
}
const getPublishTileLayerParams = (itemInfo, publishInfo, isEnterprise) => {
  const { publishType, cacheOnDemand, tileInfo, cacheOnDemandMinScale, scale, layers } = publishInfo;
  const { maxScale, minScale } = scale;
  const cacheStorageInfo = {
    storageFormat: isEnterprise || publishInfo.publishType === "vectorTiles"
      ? "esriMapCacheStorageModeCompactV2"
      : "esriMapCacheStorageModeExploded",
    packetSize: 128
  };
  const tileCacheInfo = Object.assign(Object.assign({}, (publishType === "vectorTiles" ? _tile_layer_90a6b901_js__WEBPACK_IMPORTED_MODULE_2__.p : _tile_layer_90a6b901_js__WEBPACK_IMPORTED_MODULE_2__.a)), tileInfo);
  if (tileCacheInfo.dpi && !tileCacheInfo.preciseDpi) {
    tileCacheInfo.preciseDpi = tileCacheInfo.dpi;
  }
  tileCacheInfo.lods = tileCacheInfo.lods.map((_a) => {
    var lod = __rest(_a, ["label"]);
    return lod;
  });
  // --- Main info
  const tileImageInfo = publishType === "vectorTiles" ? Object.assign({}, _tile_layer_90a6b901_js__WEBPACK_IMPORTED_MODULE_2__.b) : Object.assign({}, _tile_layer_90a6b901_js__WEBPACK_IMPORTED_MODULE_2__.c);
  let publishParameters = {
    name: (0,_functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_4__.a)(itemInfo.title),
    tilingSchema: { tileCacheInfo, tileImageInfo, cacheStorageInfo },
    minScale,
    maxScale
  };
  if (layers) {
    publishParameters.layers = layers.map(({ layerDefinition, id, drawingInfo }) => 
    // Override drawingInfo if it exists
    (layerDefinition === null || layerDefinition === void 0 ? void 0 : layerDefinition.drawingInfo)
      ? { id, drawingInfo: Object.assign(Object.assign({}, drawingInfo), layerDefinition.drawingInfo) }
      : { id, drawingInfo });
  }
  if (publishType !== "vectorTiles") {
    // On demand stuff
    publishParameters.cacheOnDemand = cacheOnDemand;
    if (cacheOnDemand) {
      publishParameters = Object.assign(Object.assign({}, publishParameters), { capabilities: "Map,ChangeTracking", cacheOnDemandMinScale });
    }
  }
  const publishContent = {
    itemId: itemInfo.id,
    filetype: "featureService",
    outputType: publishType,
    publishParameters: JSON.stringify(publishParameters),
    buildInitialCache: false
  };
  return { publishContent, publishParameters };
};

const getTileLayerInfo = async (url, isVectorTiles) => {
  const isValidUrlType = url.includes(isVectorTiles ? "/VectorTileServer" : "/MapServer");
  if (!isValidUrlType) {
    return { error: { code: "invalidUrl" } };
  }
  try {
    const result = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_6__.r)(url, {}, { addTokenManually: false });
    if (result && result.singleFusedMapCache && result.tileInfo) {
      return { result: addScaleLabels(result.tileInfo) };
    }
    else if (result && isVectorTiles && result.tileInfo) {
      return { result: result.tileInfo };
    }
    return { error: { code: "noTilingSchemeFound" } };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "mapServiceError", message: JSON.stringify(error) } };
  }
};
const getSuggestedScaleRangeForLayer = async (url) => {
  try {
    // TODO: Test more thoroughly as this has only been tested with 0 sampling
    const [FeatureLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_1__.l)(["esri/layers/FeatureLayer"]);
    const featureLayer = new FeatureLayer(url);
    const pluggedInFeatureLayer = await featureLayer.addPlugin("esri/plugins/FeatureLayerStatistics");
    const suggestedScale = await pluggedInFeatureLayer.target.statisticsPlugin.getSuggestedScaleRange({
      sampleSize: 100,
      forPublishingTiles: true
    });
    return { result: suggestedScale };
  }
  catch (error) {
    if (typeof error === "string" && error.toLowerCase().includes("sampling returned 0 features")) {
      return { result: null, error: null };
    }
    console.error(error);
    return { error: { code: "unhandledError", message: JSON.stringify(error) } };
  }
};
const getSuggestedScaleRange = async (constraints, curLods, featureLayerInfos, itemUrl) => {
  // constraints and initial min/maxScale values will be the same initially
  const lod15Scale = 18055.954822;
  let maxSupportedMinScale = null;
  let cacheOnDemandMinScale = _tile_layer_90a6b901_js__WEBPACK_IMPORTED_MODULE_2__.T;
  const calculatedScale = {
    constraints: constraints,
    minScale: constraints.minScale,
    maxScale: constraints.maxScale || lod15Scale
  };
  if (!itemUrl) {
    return { maxSupportedMinScale, cacheOnDemandMinScale, calculatedScale };
  }
  try {
    const results = await Promise.allSettled(featureLayerInfos.map(({ id }) => getSuggestedScaleRangeForLayer(`${itemUrl}/${id}`)));
    let maxOfMinScale = 0;
    let minOfMaxScale = Infinity;
    results.forEach((result) => {
      if (result.status === "rejected") {
        return;
      }
      const fetchData = result.value.result;
      if (!fetchData) {
        return;
      }
      const { maxScale, minScale } = fetchData;
      maxOfMinScale = minScale == null || minScale <= maxOfMinScale ? maxOfMinScale : minScale;
      minOfMaxScale = maxScale == null || maxScale >= minOfMaxScale ? minOfMaxScale : maxScale;
      // find the floor of the minScales for multi-layer feature services for the cache on demand min scale
      cacheOnDemandMinScale = minScale == null || minScale >= cacheOnDemandMinScale ? cacheOnDemandMinScale : minScale;
    });
    maxSupportedMinScale = constraints.minScale || _tile_layer_90a6b901_js__WEBPACK_IMPORTED_MODULE_2__.T;
    cacheOnDemandMinScale || (cacheOnDemandMinScale = maxOfMinScale);
    calculatedScale.minScale = cacheOnDemandMinScale || constraints.minScale;
    calculatedScale.maxScale = minOfMaxScale || calculatedScale.maxScale; // don't allow maxScale of 0
    // * --- Normalize min and max scale downward to match feature layer constraints if necessary
    if (calculatedScale.minScale > constraints.minScale && constraints.minScale > 0) {
      calculatedScale.minScale = constraints.minScale;
    }
    if (calculatedScale.maxScale >= calculatedScale.minScale && calculatedScale.minScale > 0) {
      calculatedScale.maxScale = normalizeMaxScale(calculatedScale.minScale, calculatedScale.maxScale, curLods);
    }
  }
  catch (error) {
    console.error(error);
    // * --- Error retrieving suggested scale range, continue without notification
    calculatedScale.minScale = constraints.minScale;
  }
  return { maxSupportedMinScale, cacheOnDemandMinScale, calculatedScale };
};
const publishTileLayer = async (tileLayerPublishContent, publishInfo, updateData) => {
  var _a;
  const { publishType, user, folder, title, tags, snippet, categories } = publishInfo;
  let publishContent = Object.assign({}, tileLayerPublishContent);
  if (title) {
    const publishParameters = JSON.parse(publishContent.publishParameters);
    publishParameters.name = (0,_functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_4__.a)(title);
    publishContent.publishParameters = JSON.stringify(publishParameters);
  }
  const url = `${user.userContentUrl}/publish`;
  const { services } = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_6__.r)(url, publishContent, {}, "post");
  const { jobId, serviceItemId, serviceurl, error, type } = services[0] || {};
  if (error) {
    console.error(error);
    // TODO: refactor to the new error system
    throw error;
  }
  await (0,_feature_layer_38cdae87_js__WEBPACK_IMPORTED_MODULE_3__.w)(serviceItemId, { jobId, success: true });
  publishType !== "scenes" && (await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_5__.e)(serviceItemId, { title, tags, snippet, categories }));
  updateData && (await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_5__.e)(serviceItemId, { text: JSON.stringify(updateData) }));
  folder.id !== ((_a = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.initialFolder) === null || _a === void 0 ? void 0 : _a.id) &&
    (await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_5__.m)(serviceItemId, (0,_feature_layer_38cdae87_js__WEBPACK_IMPORTED_MODULE_3__.q)(folder) ? "/" : folder.id));
  return { id: serviceItemId, jobId, serviceType: type, serviceUrl: serviceurl };
};
const getDatastoreServers = async (datastoreId) => {
  var _a;
  // https://developers.arcgis.com/rest/users-groups-and-items/get-servers-for-data-store.htm
  const portal = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.portal;
  const restBaseUrl = `${(_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl}portals/${portal.id}`;
  const serverIdApiUrl = `${restBaseUrl}/datastores/getServers`;
  const serverIdApiPayload = { datastoreId: datastoreId, f: "json" };
  try {
    const response = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_6__.r)(serverIdApiUrl, serverIdApiPayload, {}, "post");
    return { result: response.servers };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError", message: JSON.stringify(error) } };
  }
};
const formUpdateItemDataForTileLayer = async ({ itemId, itemUrl, portal, publishType, fullLayers }) => {
  try {
    const itemData = await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_5__.p)(itemId, portal);
    // update the layers with a popup to include the url property for the feature service layer
    const layerList = ((itemData === null || itemData === void 0 ? void 0 : itemData.layers) || [])
      .map((layer, index) => {
      var _a, _b, _c, _d;
      if (!layer) {
        return null;
      }
      const layerId = (_a = layer.id) !== null && _a !== void 0 ? _a : index;
      let newLayer = Object.assign(Object.assign({}, layer), { id: layerId, layerUrl: `${itemUrl}/${layerId}`, layerItemId: itemId, layerDefinition: layer.layerDefinition });
      if (publishType === "vector") {
        delete newLayer.popupInfo;
      }
      if (layer.popupInfo) {
        newLayer = Object.assign(Object.assign({}, newLayer), { popupInfo: layer.popupInfo });
      }
      if (layer.showLegend != null) {
        newLayer = Object.assign(Object.assign({}, newLayer), { showLegend: layer.showLegend });
      }
      const correspondingFullLayer = fullLayers.find((fullLayer) => fullLayer.id === layerId);
      // Using the correspondingFullLayer as the fallback of the drawingInfo
      newLayer = Object.assign(Object.assign({}, newLayer), { drawingInfo: Object.assign(Object.assign(Object.assign({}, correspondingFullLayer === null || correspondingFullLayer === void 0 ? void 0 : correspondingFullLayer.drawingInfo), layer.drawingInfo), { renderer: (_c = (_b = layer.drawingInfo) === null || _b === void 0 ? void 0 : _b.renderer) !== null && _c !== void 0 ? _c : (_d = correspondingFullLayer === null || correspondingFullLayer === void 0 ? void 0 : correspondingFullLayer.drawingInfo) === null || _d === void 0 ? void 0 : _d.renderer }) });
      return newLayer;
    })
      .filter((layer) => layer != null);
    return { result: Object.assign(Object.assign({}, itemData), { layers: layerList }) };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError", message: JSON.stringify(error) } };
  }
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fdGlsZS1sLTEyNmRhZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dEO0FBQ0s7QUFDd0k7QUFDakg7QUFDckI7QUFDOEI7QUFDekM7O0FBRXBEO0FBQ0EsY0FBYyxNQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZUFBZSx3RUFBd0UsVUFBVSxZQUFZLGdEQUFnRCwwQkFBMEIsRUFBRSxHQUFHLEtBQUs7QUFDclE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QUFVLFVBQVU7QUFDckgsNEJBQTRCLFlBQVk7QUFDeEMsK0JBQStCO0FBQy9CO0FBQ0EsMkJBQTJCLHNEQUFPLHVDQUF1QztBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxnREFBZ0Qsa0RBQWtEO0FBQ2xHO0FBQ0EsMkJBQTJCLDJEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWSwwQkFBMEIsUUFBUSxHQUFHLFFBQVEsZ0VBQWdFO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWUsNEJBQTRCO0FBQzVGO0FBQ0E7QUFDQSxpREFBaUQsZUFBZSw4QkFBOEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGVBQWUseURBQXlELDZJQUE2SSx3U0FBd1MsR0FBRztBQUMvaUI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLHNDQUFzQyxlQUFlLG1CQUFtQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFa1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS90aWxlLWxheWVyLWY4YmU3MDI4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgYyBhcyBjb25maWdTdGF0ZSB9IGZyb20gJy4vY29uZmlnLWViNWY3ZGMyLmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCB7IHAgYXMgcHJlc2V0VmVjdG9yVGlsZUNhY2hlSW5mbywgYSBhcyBwcmVzZXRSYXN0ZXJUaWxlQ2FjaGVJbmZvLCBiIGFzIHByZXNldFZlY3RvclRpbGVJbWFnZUluZm8sIGMgYXMgcHJlc2V0UmFzdGVyVGlsZUltYWdlSW5mbywgVCBhcyBUSUxFX0xBWUVSX1NDQUxFX01JTiB9IGZyb20gJy4vdGlsZS1sYXllci05MGE2YjkwMS5qcyc7XG5pbXBvcnQgeyB3IGFzIGdldEl0ZW1TdGF0dXMsIHEgYXMgaXNGb2xkZXJSb290IH0gZnJvbSAnLi9mZWF0dXJlLWxheWVyLTM4Y2RhZTg3LmpzJztcbmltcG9ydCB7IGEgYXMgZm9ybWF0RmlsZU5hbWUgfSBmcm9tICcuL2Z1bmN0aW9uYWwtOWY2NDhiZWUuanMnO1xuaW1wb3J0IHsgZSBhcyB1cGRhdGVJdGVtLCBtIGFzIG1vdmVJdGVtLCBwIGFzIGdldEl0ZW1EYXRhIH0gZnJvbSAnLi9zZXJ2ZXItaXRlbS1mMTIxNTNlNi5qcyc7XG5pbXBvcnQgeyByIGFzIHJlcXVlc3QgfSBmcm9tICcuL3BvcnRhbC03OWNhYWVmZi5qcyc7XG5cbi8vIFRPRE86IHRlc3QgLS0tIGFkZCB1bml0IHRlc3QhXG52YXIgX19yZXN0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgfVxuICByZXR1cm4gdDtcbn07XG5jb25zdCBhZGRTY2FsZUxhYmVscyA9ICh0aWxlSW5mbykgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGlsZUluZm8pLCB7IGxvZHM6ICh0aWxlSW5mby5sb2RzIHx8IFtdKS5tYXAoKGxvZCkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9kKSwgeyBsYWJlbDogYDE6JHtNYXRoLnJvdW5kKGxvZC5zY2FsZSkudG9Mb2NhbGVTdHJpbmcoXCJlbi1FTlwiLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCB9KX1gIH0pKSkgfSkpO1xuY29uc3Qgbm9ybWFsaXplTWF4U2NhbGUgPSAobWluLCBtYXgsIGxvZHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgLy8gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvaXNzdWVzLzEwNTI0XG4gIGlmIChtaW4gPD0gbWF4ICYmIChsb2RzID09PSBudWxsIHx8IGxvZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZHMubGVuZ3RoKSA+IDApIHtcbiAgICBsZXQgbWF4SWR4ID0gLTE7XG4gICAgLy8gZ28gdGhyb3VnaCBsb2RzIGFuZCBmaW5kIGNsb3Nlc3QgbG9kIHRvIG1pbiBzY2FsZSwgdGhlbiBmaW5kIG1heCBzY2FsZSB0d28gbG9kcyBkb3duLCBvciBsYXN0IG9uZVxuICAgIGZvciAobGV0IGkgPSBsb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAobWluIDwgbG9kc1tpXS5zY2FsZSkge1xuICAgICAgICBtYXhJZHggPSBpICsgMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIG1heElkeCA9IG1heElkeCA+IGxvZHMubGVuZ3RoIC0gMSA/IGxvZHMubGVuZ3RoIC0gMSA6IG1heElkeDtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gbG9kc1ttYXhJZHhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG1heDtcbiAgfVxuICByZXR1cm4gbWF4O1xufTtcbi8qKiBDaGVjayBpZiB3ZSBzdXBwb3J0IG9uIGRlbWFuZCwgZXhjbHVzaXZlbHkgZm9yIFwidGlsZXNcIiB0eXBlICovXG5jb25zdCBjaGVja1RpbGVzT25EZW1hbmRTdXBwb3J0ID0gKGxheWVycywgdGlsZXNPbkRlbWFuZEVuYWJsZWQpID0+IHtcbiAgbGV0IGNhblNob3dUaWxlc09uRGVtYW5kID0gZmFsc2U7XG4gIGlmICh0aWxlc09uRGVtYW5kRW5hYmxlZCAmJiAobGF5ZXJzID09PSBudWxsIHx8IGxheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJzLmxlbmd0aCkgPiAwKSB7XG4gICAgY2FuU2hvd1RpbGVzT25EZW1hbmQgPSAhbGF5ZXJzLnNvbWUoXG4gICAgLy8gdGlsZXMgb24gZGVtYW5kIGFyZW4ndCBhbGxvd2VkIHdoZW4gbGFiZWxpbmcgdHVybmVkIG9uXG4gICAgKGxheWVyKSA9PiAhY2FuVXNlTGF5ZXJGb3JQdWJsaXNoKGxheWVyLCBmYWxzZSwgXCJ0aWxlc1wiKSk7XG4gIH1cbiAgcmV0dXJuIGNhblNob3dUaWxlc09uRGVtYW5kO1xufTtcbi8vICogLS0tIFB1Ymxpc2hpbmcgdGlsZSBzdHVmZlxuZnVuY3Rpb24gY2FuVXNlTGF5ZXJGb3JQdWJsaXNoKGxheWVySW5mbywgYWxsb3dMYWJlbHMsIHR5cGUpIHtcbiAgaWYgKGxheWVySW5mby50eXBlICE9PSBcIkZlYXR1cmUgTGF5ZXJcIiB8fCAhbGF5ZXJJbmZvLmRyYXdpbmdJbmZvKSB7XG4gICAgLy8gV3JvbmcgbGF5ZXIgdHlwZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJzY2VuZXNcIikge1xuICAgIHJldHVybiBjYW5Vc2VMYXllckZvclB1Ymxpc2hTY2VuZShsYXllckluZm8sIGFsbG93TGFiZWxzKTtcbiAgfVxuICByZXR1cm4gY2FuVXNlTGF5ZXJGb3JQdWJsaXNoVGlsZXMobGF5ZXJJbmZvLCBhbGxvd0xhYmVscyk7XG59XG5mdW5jdGlvbiBjYW5Vc2VMYXllckZvclB1Ymxpc2hUaWxlcyhsYXllckluZm8sIGFsbG93TGFiZWxzKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmIChsYXllckluZm8uZ2VvbWV0cnlUeXBlID09PSBcImVzcmlHZW9tZXRyeU11bHRpUGF0Y2hcIikge1xuICAgIC8vIE11bHRpUGF0Y2hcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcmVuZGVyZXIgPSAoX2EgPSBsYXllckluZm8uZHJhd2luZ0luZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW5kZXJlcjtcbiAgY29uc3QgbGFiZWxpbmdJbmZvID0gKF9iID0gbGF5ZXJJbmZvLmRyYXdpbmdJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGFiZWxpbmdJbmZvO1xuICBjb25zdCBmaWVsZHMgPSBsYXllckluZm8uZmllbGRzO1xuICAvLyBjbHVzdGVyaW5nXG4gIGlmIChsYXllckhhc0NsdXN0ZXJpbmcobGF5ZXJJbmZvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocmVuZGVyZXIgJiZcbiAgICBsYXllckluZm8uZ2VvbWV0cnlUeXBlICYmXG4gICAgKGZpZWxkcyA9PT0gbnVsbCB8fCBmaWVsZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkcy5sZW5ndGgpID4gMCAmJlxuICAgICFjYW5Vc2VSZW5kZXJlckZvclB1Ymxpc2hUaWxlcyhyZW5kZXJlciwgbGF5ZXJJbmZvLmdlb21ldHJ5VHlwZSwgZmllbGRzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBsYWJlbHNcbiAgaWYgKCFhbGxvd0xhYmVscyAmJiAobGFiZWxpbmdJbmZvID09PSBudWxsIHx8IGxhYmVsaW5nSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFiZWxpbmdJbmZvLmxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBsYXllckhhc0NsdXN0ZXJpbmcgPSAobGF5ZXJJbmZvKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGZlYXR1cmVSZWR1Y3Rpb24gPSAoX2EgPSBsYXllckluZm8uZmVhdHVyZVJlZHVjdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gbGF5ZXJJbmZvLmxheWVyRGVmaW5pdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZlYXR1cmVSZWR1Y3Rpb247XG4gIHJldHVybiAhIWZlYXR1cmVSZWR1Y3Rpb24gJiYgT2JqZWN0LmtleXMoZmVhdHVyZVJlZHVjdGlvbikubGVuZ3RoID4gMDtcbn07XG5jb25zdCBjYW5Vc2VSZW5kZXJlckZvclB1Ymxpc2hUaWxlcyA9IChyZW5kZXJlciwgZ2VvbWV0cnlUeXBlLCBmaWVsZHMpID0+IHtcbiAgdmFyIF9hO1xuICAvLyBoZWF0bWFwIHJlbmRlcmVyXG4gIGlmIChyZW5kZXJlci50eXBlID09PSBcImhlYXRtYXBcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBzY2FsZSBkZXBlbmRlbnQgbWFya2VyIHNpemluZyBvbiBwb2x5Z29uIGxheWVyXG4gIC8qXG4gICAgaWYgKGxheWVySW5mby5nZW9tZXRyeVR5cGUgPT09IFwiZXNyaUdlb21ldHJ5UG9seWdvblwiICYmIHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcykge1xuICAgICAgaWYgKGFycmF5LnNvbWUocmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLCBmdW5jdGlvbiAodmlzVmFyKSB7XG4gICAgICAgICAgLy8ge3RhcmdldDogXCJvdXRsaW5lXCJ9IGlzIE9LXG4gICAgICAgICAgaWYgKHZpc1Zhci50eXBlID09PSBcInNpemVJbmZvXCIgJiYgIXZpc1Zhci50YXJnZXQgJiZcbiAgICAgICAgICAgICh0eXBlb2YgdmlzVmFyLm1pblNpemUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZpc1Zhci5tYXhTaXplID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgKi9cbiAgLy8gdHlwZSArIHNpemUgb24gcG9seWdvbiBsYXllclxuICBpZiAoZ2VvbWV0cnlUeXBlID09PSBcImVzcmlHZW9tZXRyeVBvbHlnb25cIiAmJiByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zICYmIHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcykge1xuICAgIGlmIChyZW5kZXJlci52aXN1YWxWYXJpYWJsZXMuc29tZSgodmlzVmFyKSA9PiB7XG4gICAgICBpZiAodmlzVmFyLnR5cGUgPT09IFwic2l6ZUluZm9cIiAmJiAhdmlzVmFyLnRhcmdldCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBkYXRlIGZpZWxkc1xuICBjb25zdCBkYXRlRmllbGRzID0gZmllbGRzLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLnR5cGUgPT09IFwiZXNyaUZpZWxkVHlwZURhdGVcIikubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSk7XG4gIGlmIChkYXRlRmllbGRzLmxlbmd0aCkge1xuICAgIC8vIHJlbmRlcmVyIHVzaW5nIGRhdGUgZmllbGRcbiAgICBpZiAoZGF0ZUZpZWxkcy5pbmRleE9mKHJlbmRlcmVyLmZpZWxkKSA+IC0xIHx8IGRhdGVGaWVsZHMuaW5kZXhPZihyZW5kZXJlci5maWVsZDEpID4gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gdmlzdWFsIHZhcmlhYmxlcyB3aXRoIGRhdGUgZmllbGRcbiAgICBpZiAoKF9hID0gcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgodmlzVmFyKSA9PiBkYXRlRmllbGRzLmluZGV4T2YodmlzVmFyLmZpZWxkKSA+IC0xKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBjYW5Vc2VMYXllckZvclB1Ymxpc2hTY2VuZShsYXllckluZm8sIGFsbG93TGFiZWxzKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCByZW5kZXJlciA9IGxheWVySW5mby5kcmF3aW5nSW5mby5yZW5kZXJlcjtcbiAgY29uc3QgbGFiZWxpbmdJbmZvID0gbGF5ZXJJbmZvLmRyYXdpbmdJbmZvLmxhYmVsaW5nSW5mbztcbiAgY29uc3QgZmVhdHVyZVJlZHVjdGlvbiA9IGxheWVySW5mby5mZWF0dXJlUmVkdWN0aW9uO1xuICBjb25zdCBmaWVsZHMgPSBsYXllckluZm8uZmllbGRzO1xuICAvLyBvbmx5IHBvaW50IG9yIG11bHRpUGF0Y2ggbGF5ZXJzXG4gIGlmIChbXCJlc3JpR2VvbWV0cnlQb2ludFwiLCBcImVzcmlHZW9tZXRyeU11bHRpUGF0Y2hcIl0uaW5kZXhPZihsYXllckluZm8uZ2VvbWV0cnlUeXBlKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gc3RyZWFtIGxheWVyXG4gIGlmIChyZW5kZXJlci5vYnNlcnZhdGlvblJlbmRlcmVyIHx8IHJlbmRlcmVyLmxhdGVzdE9ic2VydmF0aW9uUmVuZGVyZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGVhdG1hcCByZW5kZXJlclxuICBpZiAocmVuZGVyZXIudHlwZSA9PT0gXCJoZWF0bWFwXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXJjYWRlIGV4cHJlc3Npb25zXG4gIGlmICgoX2EgPSByZW5kZXJlci52YWx1ZUV4cHJlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKChfYiA9IHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHZpc1ZhcikgPT4gdmlzVmFyLnZhbHVlRXhwcmVzc2lvbi5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGRhdGUgZmllbGRzXG4gIGNvbnN0IGRhdGVGaWVsZHMgPSBmaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gXCJlc3JpRmllbGRUeXBlRGF0ZVwiKS5tYXAoKGZpZWxkKSA9PiBmaWVsZC5uYW1lKTtcbiAgaWYgKGRhdGVGaWVsZHMubGVuZ3RoKSB7XG4gICAgLy8gcmVuZGVyZXIgdXNpbmcgZGF0ZSBmaWVsZFxuICAgIGlmIChkYXRlRmllbGRzLmluZGV4T2YocmVuZGVyZXIuZmllbGQpID4gLTEgfHwgZGF0ZUZpZWxkcy5pbmRleE9mKHJlbmRlcmVyLmZpZWxkMSkgPiAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB2aXN1YWwgdmFyaWFibGVzIHdpdGggZGF0ZSBmaWVsZFxuICAgIGlmICgoX2MgPSByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zb21lKCh2aXNWYXIpID0+IHZpc1Zhci5maWVsZCAmJiBkYXRlRmllbGRzLmluZGV4T2YodmlzVmFyLmZpZWxkKSA+IC0xKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBjbHVzdGVyaW5nXG4gIGlmIChmZWF0dXJlUmVkdWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGxhYmVsc1xuICBpZiAoIWFsbG93TGFiZWxzICYmIChsYWJlbGluZ0luZm8gPT09IG51bGwgfHwgbGFiZWxpbmdJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYWJlbGluZ0luZm8ubGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGdldFB1Ymxpc2hUaWxlTGF5ZXJQYXJhbXMgPSAoaXRlbUluZm8sIHB1Ymxpc2hJbmZvLCBpc0VudGVycHJpc2UpID0+IHtcbiAgY29uc3QgeyBwdWJsaXNoVHlwZSwgY2FjaGVPbkRlbWFuZCwgdGlsZUluZm8sIGNhY2hlT25EZW1hbmRNaW5TY2FsZSwgc2NhbGUsIGxheWVycyB9ID0gcHVibGlzaEluZm87XG4gIGNvbnN0IHsgbWF4U2NhbGUsIG1pblNjYWxlIH0gPSBzY2FsZTtcbiAgY29uc3QgY2FjaGVTdG9yYWdlSW5mbyA9IHtcbiAgICBzdG9yYWdlRm9ybWF0OiBpc0VudGVycHJpc2UgfHwgcHVibGlzaEluZm8ucHVibGlzaFR5cGUgPT09IFwidmVjdG9yVGlsZXNcIlxuICAgICAgPyBcImVzcmlNYXBDYWNoZVN0b3JhZ2VNb2RlQ29tcGFjdFYyXCJcbiAgICAgIDogXCJlc3JpTWFwQ2FjaGVTdG9yYWdlTW9kZUV4cGxvZGVkXCIsXG4gICAgcGFja2V0U2l6ZTogMTI4XG4gIH07XG4gIGNvbnN0IHRpbGVDYWNoZUluZm8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChwdWJsaXNoVHlwZSA9PT0gXCJ2ZWN0b3JUaWxlc1wiID8gcHJlc2V0VmVjdG9yVGlsZUNhY2hlSW5mbyA6IHByZXNldFJhc3RlclRpbGVDYWNoZUluZm8pKSwgdGlsZUluZm8pO1xuICBpZiAodGlsZUNhY2hlSW5mby5kcGkgJiYgIXRpbGVDYWNoZUluZm8ucHJlY2lzZURwaSkge1xuICAgIHRpbGVDYWNoZUluZm8ucHJlY2lzZURwaSA9IHRpbGVDYWNoZUluZm8uZHBpO1xuICB9XG4gIHRpbGVDYWNoZUluZm8ubG9kcyA9IHRpbGVDYWNoZUluZm8ubG9kcy5tYXAoKF9hKSA9PiB7XG4gICAgdmFyIGxvZCA9IF9fcmVzdChfYSwgW1wibGFiZWxcIl0pO1xuICAgIHJldHVybiBsb2Q7XG4gIH0pO1xuICAvLyAtLS0gTWFpbiBpbmZvXG4gIGNvbnN0IHRpbGVJbWFnZUluZm8gPSBwdWJsaXNoVHlwZSA9PT0gXCJ2ZWN0b3JUaWxlc1wiID8gT2JqZWN0LmFzc2lnbih7fSwgcHJlc2V0VmVjdG9yVGlsZUltYWdlSW5mbykgOiBPYmplY3QuYXNzaWduKHt9LCBwcmVzZXRSYXN0ZXJUaWxlSW1hZ2VJbmZvKTtcbiAgbGV0IHB1Ymxpc2hQYXJhbWV0ZXJzID0ge1xuICAgIG5hbWU6IGZvcm1hdEZpbGVOYW1lKGl0ZW1JbmZvLnRpdGxlKSxcbiAgICB0aWxpbmdTY2hlbWE6IHsgdGlsZUNhY2hlSW5mbywgdGlsZUltYWdlSW5mbywgY2FjaGVTdG9yYWdlSW5mbyB9LFxuICAgIG1pblNjYWxlLFxuICAgIG1heFNjYWxlXG4gIH07XG4gIGlmIChsYXllcnMpIHtcbiAgICBwdWJsaXNoUGFyYW1ldGVycy5sYXllcnMgPSBsYXllcnMubWFwKCh7IGxheWVyRGVmaW5pdGlvbiwgaWQsIGRyYXdpbmdJbmZvIH0pID0+IFxuICAgIC8vIE92ZXJyaWRlIGRyYXdpbmdJbmZvIGlmIGl0IGV4aXN0c1xuICAgIChsYXllckRlZmluaXRpb24gPT09IG51bGwgfHwgbGF5ZXJEZWZpbml0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllckRlZmluaXRpb24uZHJhd2luZ0luZm8pXG4gICAgICA/IHsgaWQsIGRyYXdpbmdJbmZvOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRyYXdpbmdJbmZvKSwgbGF5ZXJEZWZpbml0aW9uLmRyYXdpbmdJbmZvKSB9XG4gICAgICA6IHsgaWQsIGRyYXdpbmdJbmZvIH0pO1xuICB9XG4gIGlmIChwdWJsaXNoVHlwZSAhPT0gXCJ2ZWN0b3JUaWxlc1wiKSB7XG4gICAgLy8gT24gZGVtYW5kIHN0dWZmXG4gICAgcHVibGlzaFBhcmFtZXRlcnMuY2FjaGVPbkRlbWFuZCA9IGNhY2hlT25EZW1hbmQ7XG4gICAgaWYgKGNhY2hlT25EZW1hbmQpIHtcbiAgICAgIHB1Ymxpc2hQYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWJsaXNoUGFyYW1ldGVycyksIHsgY2FwYWJpbGl0aWVzOiBcIk1hcCxDaGFuZ2VUcmFja2luZ1wiLCBjYWNoZU9uRGVtYW5kTWluU2NhbGUgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHB1Ymxpc2hDb250ZW50ID0ge1xuICAgIGl0ZW1JZDogaXRlbUluZm8uaWQsXG4gICAgZmlsZXR5cGU6IFwiZmVhdHVyZVNlcnZpY2VcIixcbiAgICBvdXRwdXRUeXBlOiBwdWJsaXNoVHlwZSxcbiAgICBwdWJsaXNoUGFyYW1ldGVyczogSlNPTi5zdHJpbmdpZnkocHVibGlzaFBhcmFtZXRlcnMpLFxuICAgIGJ1aWxkSW5pdGlhbENhY2hlOiBmYWxzZVxuICB9O1xuICByZXR1cm4geyBwdWJsaXNoQ29udGVudCwgcHVibGlzaFBhcmFtZXRlcnMgfTtcbn07XG5cbmNvbnN0IGdldFRpbGVMYXllckluZm8gPSBhc3luYyAodXJsLCBpc1ZlY3RvclRpbGVzKSA9PiB7XG4gIGNvbnN0IGlzVmFsaWRVcmxUeXBlID0gdXJsLmluY2x1ZGVzKGlzVmVjdG9yVGlsZXMgPyBcIi9WZWN0b3JUaWxlU2VydmVyXCIgOiBcIi9NYXBTZXJ2ZXJcIik7XG4gIGlmICghaXNWYWxpZFVybFR5cGUpIHtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImludmFsaWRVcmxcIiB9IH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0KHVybCwge30sIHsgYWRkVG9rZW5NYW51YWxseTogZmFsc2UgfSk7XG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc2luZ2xlRnVzZWRNYXBDYWNoZSAmJiByZXN1bHQudGlsZUluZm8pIHtcbiAgICAgIHJldHVybiB7IHJlc3VsdDogYWRkU2NhbGVMYWJlbHMocmVzdWx0LnRpbGVJbmZvKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgJiYgaXNWZWN0b3JUaWxlcyAmJiByZXN1bHQudGlsZUluZm8pIHtcbiAgICAgIHJldHVybiB7IHJlc3VsdDogcmVzdWx0LnRpbGVJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwibm9UaWxpbmdTY2hlbWVGb3VuZFwiIH0gfTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcIm1hcFNlcnZpY2VFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICB9XG59O1xuY29uc3QgZ2V0U3VnZ2VzdGVkU2NhbGVSYW5nZUZvckxheWVyID0gYXN5bmMgKHVybCkgPT4ge1xuICB0cnkge1xuICAgIC8vIFRPRE86IFRlc3QgbW9yZSB0aG9yb3VnaGx5IGFzIHRoaXMgaGFzIG9ubHkgYmVlbiB0ZXN0ZWQgd2l0aCAwIHNhbXBsaW5nXG4gICAgY29uc3QgW0ZlYXR1cmVMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9GZWF0dXJlTGF5ZXJcIl0pO1xuICAgIGNvbnN0IGZlYXR1cmVMYXllciA9IG5ldyBGZWF0dXJlTGF5ZXIodXJsKTtcbiAgICBjb25zdCBwbHVnZ2VkSW5GZWF0dXJlTGF5ZXIgPSBhd2FpdCBmZWF0dXJlTGF5ZXIuYWRkUGx1Z2luKFwiZXNyaS9wbHVnaW5zL0ZlYXR1cmVMYXllclN0YXRpc3RpY3NcIik7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU2NhbGUgPSBhd2FpdCBwbHVnZ2VkSW5GZWF0dXJlTGF5ZXIudGFyZ2V0LnN0YXRpc3RpY3NQbHVnaW4uZ2V0U3VnZ2VzdGVkU2NhbGVSYW5nZSh7XG4gICAgICBzYW1wbGVTaXplOiAxMDAsXG4gICAgICBmb3JQdWJsaXNoaW5nVGlsZXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4geyByZXN1bHQ6IHN1Z2dlc3RlZFNjYWxlIH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2FtcGxpbmcgcmV0dXJuZWQgMCBmZWF0dXJlc1wiKSkge1xuICAgICAgcmV0dXJuIHsgcmVzdWx0OiBudWxsLCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9IH07XG4gIH1cbn07XG5jb25zdCBnZXRTdWdnZXN0ZWRTY2FsZVJhbmdlID0gYXN5bmMgKGNvbnN0cmFpbnRzLCBjdXJMb2RzLCBmZWF0dXJlTGF5ZXJJbmZvcywgaXRlbVVybCkgPT4ge1xuICAvLyBjb25zdHJhaW50cyBhbmQgaW5pdGlhbCBtaW4vbWF4U2NhbGUgdmFsdWVzIHdpbGwgYmUgdGhlIHNhbWUgaW5pdGlhbGx5XG4gIGNvbnN0IGxvZDE1U2NhbGUgPSAxODA1NS45NTQ4MjI7XG4gIGxldCBtYXhTdXBwb3J0ZWRNaW5TY2FsZSA9IG51bGw7XG4gIGxldCBjYWNoZU9uRGVtYW5kTWluU2NhbGUgPSBUSUxFX0xBWUVSX1NDQUxFX01JTjtcbiAgY29uc3QgY2FsY3VsYXRlZFNjYWxlID0ge1xuICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50cyxcbiAgICBtaW5TY2FsZTogY29uc3RyYWludHMubWluU2NhbGUsXG4gICAgbWF4U2NhbGU6IGNvbnN0cmFpbnRzLm1heFNjYWxlIHx8IGxvZDE1U2NhbGVcbiAgfTtcbiAgaWYgKCFpdGVtVXJsKSB7XG4gICAgcmV0dXJuIHsgbWF4U3VwcG9ydGVkTWluU2NhbGUsIGNhY2hlT25EZW1hbmRNaW5TY2FsZSwgY2FsY3VsYXRlZFNjYWxlIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGZlYXR1cmVMYXllckluZm9zLm1hcCgoeyBpZCB9KSA9PiBnZXRTdWdnZXN0ZWRTY2FsZVJhbmdlRm9yTGF5ZXIoYCR7aXRlbVVybH0vJHtpZH1gKSkpO1xuICAgIGxldCBtYXhPZk1pblNjYWxlID0gMDtcbiAgICBsZXQgbWluT2ZNYXhTY2FsZSA9IEluZmluaXR5O1xuICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZldGNoRGF0YSA9IHJlc3VsdC52YWx1ZS5yZXN1bHQ7XG4gICAgICBpZiAoIWZldGNoRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IG1heFNjYWxlLCBtaW5TY2FsZSB9ID0gZmV0Y2hEYXRhO1xuICAgICAgbWF4T2ZNaW5TY2FsZSA9IG1pblNjYWxlID09IG51bGwgfHwgbWluU2NhbGUgPD0gbWF4T2ZNaW5TY2FsZSA/IG1heE9mTWluU2NhbGUgOiBtaW5TY2FsZTtcbiAgICAgIG1pbk9mTWF4U2NhbGUgPSBtYXhTY2FsZSA9PSBudWxsIHx8IG1heFNjYWxlID49IG1pbk9mTWF4U2NhbGUgPyBtaW5PZk1heFNjYWxlIDogbWF4U2NhbGU7XG4gICAgICAvLyBmaW5kIHRoZSBmbG9vciBvZiB0aGUgbWluU2NhbGVzIGZvciBtdWx0aS1sYXllciBmZWF0dXJlIHNlcnZpY2VzIGZvciB0aGUgY2FjaGUgb24gZGVtYW5kIG1pbiBzY2FsZVxuICAgICAgY2FjaGVPbkRlbWFuZE1pblNjYWxlID0gbWluU2NhbGUgPT0gbnVsbCB8fCBtaW5TY2FsZSA+PSBjYWNoZU9uRGVtYW5kTWluU2NhbGUgPyBjYWNoZU9uRGVtYW5kTWluU2NhbGUgOiBtaW5TY2FsZTtcbiAgICB9KTtcbiAgICBtYXhTdXBwb3J0ZWRNaW5TY2FsZSA9IGNvbnN0cmFpbnRzLm1pblNjYWxlIHx8IFRJTEVfTEFZRVJfU0NBTEVfTUlOO1xuICAgIGNhY2hlT25EZW1hbmRNaW5TY2FsZSB8fCAoY2FjaGVPbkRlbWFuZE1pblNjYWxlID0gbWF4T2ZNaW5TY2FsZSk7XG4gICAgY2FsY3VsYXRlZFNjYWxlLm1pblNjYWxlID0gY2FjaGVPbkRlbWFuZE1pblNjYWxlIHx8IGNvbnN0cmFpbnRzLm1pblNjYWxlO1xuICAgIGNhbGN1bGF0ZWRTY2FsZS5tYXhTY2FsZSA9IG1pbk9mTWF4U2NhbGUgfHwgY2FsY3VsYXRlZFNjYWxlLm1heFNjYWxlOyAvLyBkb24ndCBhbGxvdyBtYXhTY2FsZSBvZiAwXG4gICAgLy8gKiAtLS0gTm9ybWFsaXplIG1pbiBhbmQgbWF4IHNjYWxlIGRvd253YXJkIHRvIG1hdGNoIGZlYXR1cmUgbGF5ZXIgY29uc3RyYWludHMgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKGNhbGN1bGF0ZWRTY2FsZS5taW5TY2FsZSA+IGNvbnN0cmFpbnRzLm1pblNjYWxlICYmIGNvbnN0cmFpbnRzLm1pblNjYWxlID4gMCkge1xuICAgICAgY2FsY3VsYXRlZFNjYWxlLm1pblNjYWxlID0gY29uc3RyYWludHMubWluU2NhbGU7XG4gICAgfVxuICAgIGlmIChjYWxjdWxhdGVkU2NhbGUubWF4U2NhbGUgPj0gY2FsY3VsYXRlZFNjYWxlLm1pblNjYWxlICYmIGNhbGN1bGF0ZWRTY2FsZS5taW5TY2FsZSA+IDApIHtcbiAgICAgIGNhbGN1bGF0ZWRTY2FsZS5tYXhTY2FsZSA9IG5vcm1hbGl6ZU1heFNjYWxlKGNhbGN1bGF0ZWRTY2FsZS5taW5TY2FsZSwgY2FsY3VsYXRlZFNjYWxlLm1heFNjYWxlLCBjdXJMb2RzKTtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgLy8gKiAtLS0gRXJyb3IgcmV0cmlldmluZyBzdWdnZXN0ZWQgc2NhbGUgcmFuZ2UsIGNvbnRpbnVlIHdpdGhvdXQgbm90aWZpY2F0aW9uXG4gICAgY2FsY3VsYXRlZFNjYWxlLm1pblNjYWxlID0gY29uc3RyYWludHMubWluU2NhbGU7XG4gIH1cbiAgcmV0dXJuIHsgbWF4U3VwcG9ydGVkTWluU2NhbGUsIGNhY2hlT25EZW1hbmRNaW5TY2FsZSwgY2FsY3VsYXRlZFNjYWxlIH07XG59O1xuY29uc3QgcHVibGlzaFRpbGVMYXllciA9IGFzeW5jICh0aWxlTGF5ZXJQdWJsaXNoQ29udGVudCwgcHVibGlzaEluZm8sIHVwZGF0ZURhdGEpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHB1Ymxpc2hUeXBlLCB1c2VyLCBmb2xkZXIsIHRpdGxlLCB0YWdzLCBzbmlwcGV0LCBjYXRlZ29yaWVzIH0gPSBwdWJsaXNoSW5mbztcbiAgbGV0IHB1Ymxpc2hDb250ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGlsZUxheWVyUHVibGlzaENvbnRlbnQpO1xuICBpZiAodGl0bGUpIHtcbiAgICBjb25zdCBwdWJsaXNoUGFyYW1ldGVycyA9IEpTT04ucGFyc2UocHVibGlzaENvbnRlbnQucHVibGlzaFBhcmFtZXRlcnMpO1xuICAgIHB1Ymxpc2hQYXJhbWV0ZXJzLm5hbWUgPSBmb3JtYXRGaWxlTmFtZSh0aXRsZSk7XG4gICAgcHVibGlzaENvbnRlbnQucHVibGlzaFBhcmFtZXRlcnMgPSBKU09OLnN0cmluZ2lmeShwdWJsaXNoUGFyYW1ldGVycyk7XG4gIH1cbiAgY29uc3QgdXJsID0gYCR7dXNlci51c2VyQ29udGVudFVybH0vcHVibGlzaGA7XG4gIGNvbnN0IHsgc2VydmljZXMgfSA9IGF3YWl0IHJlcXVlc3QodXJsLCBwdWJsaXNoQ29udGVudCwge30sIFwicG9zdFwiKTtcbiAgY29uc3QgeyBqb2JJZCwgc2VydmljZUl0ZW1JZCwgc2VydmljZXVybCwgZXJyb3IsIHR5cGUgfSA9IHNlcnZpY2VzWzBdIHx8IHt9O1xuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAvLyBUT0RPOiByZWZhY3RvciB0byB0aGUgbmV3IGVycm9yIHN5c3RlbVxuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGF3YWl0IGdldEl0ZW1TdGF0dXMoc2VydmljZUl0ZW1JZCwgeyBqb2JJZCwgc3VjY2VzczogdHJ1ZSB9KTtcbiAgcHVibGlzaFR5cGUgIT09IFwic2NlbmVzXCIgJiYgKGF3YWl0IHVwZGF0ZUl0ZW0oc2VydmljZUl0ZW1JZCwgeyB0aXRsZSwgdGFncywgc25pcHBldCwgY2F0ZWdvcmllcyB9KSk7XG4gIHVwZGF0ZURhdGEgJiYgKGF3YWl0IHVwZGF0ZUl0ZW0oc2VydmljZUl0ZW1JZCwgeyB0ZXh0OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSB9KSk7XG4gIGZvbGRlci5pZCAhPT0gKChfYSA9IGNvbmZpZ1N0YXRlLmluaXRpYWxGb2xkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgJiZcbiAgICAoYXdhaXQgbW92ZUl0ZW0oc2VydmljZUl0ZW1JZCwgaXNGb2xkZXJSb290KGZvbGRlcikgPyBcIi9cIiA6IGZvbGRlci5pZCkpO1xuICByZXR1cm4geyBpZDogc2VydmljZUl0ZW1JZCwgam9iSWQsIHNlcnZpY2VUeXBlOiB0eXBlLCBzZXJ2aWNlVXJsOiBzZXJ2aWNldXJsIH07XG59O1xuY29uc3QgZ2V0RGF0YXN0b3JlU2VydmVycyA9IGFzeW5jIChkYXRhc3RvcmVJZCkgPT4ge1xuICB2YXIgX2E7XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5hcmNnaXMuY29tL3Jlc3QvdXNlcnMtZ3JvdXBzLWFuZC1pdGVtcy9nZXQtc2VydmVycy1mb3ItZGF0YS1zdG9yZS5odG1cbiAgY29uc3QgcG9ydGFsID0gY29uZmlnU3RhdGUucG9ydGFsO1xuICBjb25zdCByZXN0QmFzZVVybCA9IGAkeyhfYSA9IHBvcnRhbC5yZXN0VXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3J0YWwucG9ydGFsVXJsfXBvcnRhbHMvJHtwb3J0YWwuaWR9YDtcbiAgY29uc3Qgc2VydmVySWRBcGlVcmwgPSBgJHtyZXN0QmFzZVVybH0vZGF0YXN0b3Jlcy9nZXRTZXJ2ZXJzYDtcbiAgY29uc3Qgc2VydmVySWRBcGlQYXlsb2FkID0geyBkYXRhc3RvcmVJZDogZGF0YXN0b3JlSWQsIGY6IFwianNvblwiIH07XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHNlcnZlcklkQXBpVXJsLCBzZXJ2ZXJJZEFwaVBheWxvYWQsIHt9LCBcInBvc3RcIik7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiByZXNwb25zZS5zZXJ2ZXJzIH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICB9XG59O1xuY29uc3QgZm9ybVVwZGF0ZUl0ZW1EYXRhRm9yVGlsZUxheWVyID0gYXN5bmMgKHsgaXRlbUlkLCBpdGVtVXJsLCBwb3J0YWwsIHB1Ymxpc2hUeXBlLCBmdWxsTGF5ZXJzIH0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpdGVtRGF0YSA9IGF3YWl0IGdldEl0ZW1EYXRhKGl0ZW1JZCwgcG9ydGFsKTtcbiAgICAvLyB1cGRhdGUgdGhlIGxheWVycyB3aXRoIGEgcG9wdXAgdG8gaW5jbHVkZSB0aGUgdXJsIHByb3BlcnR5IGZvciB0aGUgZmVhdHVyZSBzZXJ2aWNlIGxheWVyXG4gICAgY29uc3QgbGF5ZXJMaXN0ID0gKChpdGVtRGF0YSA9PT0gbnVsbCB8fCBpdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbURhdGEubGF5ZXJzKSB8fCBbXSlcbiAgICAgIC5tYXAoKGxheWVyLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxheWVySWQgPSAoX2EgPSBsYXllci5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogaW5kZXg7XG4gICAgICBsZXQgbmV3TGF5ZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxheWVyKSwgeyBpZDogbGF5ZXJJZCwgbGF5ZXJVcmw6IGAke2l0ZW1Vcmx9LyR7bGF5ZXJJZH1gLCBsYXllckl0ZW1JZDogaXRlbUlkLCBsYXllckRlZmluaXRpb246IGxheWVyLmxheWVyRGVmaW5pdGlvbiB9KTtcbiAgICAgIGlmIChwdWJsaXNoVHlwZSA9PT0gXCJ2ZWN0b3JcIikge1xuICAgICAgICBkZWxldGUgbmV3TGF5ZXIucG9wdXBJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKGxheWVyLnBvcHVwSW5mbykge1xuICAgICAgICBuZXdMYXllciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3TGF5ZXIpLCB7IHBvcHVwSW5mbzogbGF5ZXIucG9wdXBJbmZvIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGxheWVyLnNob3dMZWdlbmQgIT0gbnVsbCkge1xuICAgICAgICBuZXdMYXllciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3TGF5ZXIpLCB7IHNob3dMZWdlbmQ6IGxheWVyLnNob3dMZWdlbmQgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb3JyZXNwb25kaW5nRnVsbExheWVyID0gZnVsbExheWVycy5maW5kKChmdWxsTGF5ZXIpID0+IGZ1bGxMYXllci5pZCA9PT0gbGF5ZXJJZCk7XG4gICAgICAvLyBVc2luZyB0aGUgY29ycmVzcG9uZGluZ0Z1bGxMYXllciBhcyB0aGUgZmFsbGJhY2sgb2YgdGhlIGRyYXdpbmdJbmZvXG4gICAgICBuZXdMYXllciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3TGF5ZXIpLCB7IGRyYXdpbmdJbmZvOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ycmVzcG9uZGluZ0Z1bGxMYXllciA9PT0gbnVsbCB8fCBjb3JyZXNwb25kaW5nRnVsbExheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb3JyZXNwb25kaW5nRnVsbExheWVyLmRyYXdpbmdJbmZvKSwgbGF5ZXIuZHJhd2luZ0luZm8pLCB7IHJlbmRlcmVyOiAoX2MgPSAoX2IgPSBsYXllci5kcmF3aW5nSW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbmRlcmVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSBjb3JyZXNwb25kaW5nRnVsbExheWVyID09PSBudWxsIHx8IGNvcnJlc3BvbmRpbmdGdWxsTGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvcnJlc3BvbmRpbmdGdWxsTGF5ZXIuZHJhd2luZ0luZm8pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZW5kZXJlciB9KSB9KTtcbiAgICAgIHJldHVybiBuZXdMYXllcjtcbiAgICB9KVxuICAgICAgLmZpbHRlcigobGF5ZXIpID0+IGxheWVyICE9IG51bGwpO1xuICAgIHJldHVybiB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtRGF0YSksIHsgbGF5ZXJzOiBsYXllckxpc3QgfSkgfTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9IH07XG4gIH1cbn07XG5cbmV4cG9ydCB7IGNhblVzZUxheWVyRm9yUHVibGlzaFRpbGVzIGFzIGEsIGdldFRpbGVMYXllckluZm8gYXMgYiwgY2FuVXNlUmVuZGVyZXJGb3JQdWJsaXNoVGlsZXMgYXMgYywgZ2V0UHVibGlzaFRpbGVMYXllclBhcmFtcyBhcyBkLCBnZXRTdWdnZXN0ZWRTY2FsZVJhbmdlIGFzIGUsIGZvcm1VcGRhdGVJdGVtRGF0YUZvclRpbGVMYXllciBhcyBmLCBnZXREYXRhc3RvcmVTZXJ2ZXJzIGFzIGcsIGNoZWNrVGlsZXNPbkRlbWFuZFN1cHBvcnQgYXMgaCwgbGF5ZXJIYXNDbHVzdGVyaW5nIGFzIGwsIHB1Ymxpc2hUaWxlTGF5ZXIgYXMgcCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9