"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-f669eb"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/key-b75491c4.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/key-b75491c4.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ isActivationKey),
/* harmony export */   n: () => (/* binding */ numberKeys)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function isActivationKey(key) {
  return key === "Enter" || key === " ";
}
const numberKeys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];



//# sourceMappingURL=key-b75491c4.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/locale-f7b2fbb0.js":
/*!************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/locale-f7b2fbb0.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getSupportedNumberingSystem),
/* harmony export */   b: () => (/* binding */ defaultNumberingSystem),
/* harmony export */   c: () => (/* binding */ connectLocalized),
/* harmony export */   d: () => (/* binding */ disconnectLocalized),
/* harmony export */   g: () => (/* binding */ getSupportedLocale),
/* harmony export */   i: () => (/* binding */ isValidNumber),
/* harmony export */   n: () => (/* binding */ numberStringFormatter),
/* harmony export */   p: () => (/* binding */ parseNumberString),
/* harmony export */   s: () => (/* binding */ sanitizeNumberString)
/* harmony export */ });
/* harmony import */ var _dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-f1ee4d04.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/dom-f1ee4d04.js");
/* harmony import */ var _key_b75491c4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./key-b75491c4.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/key-b75491c4.js");
/* harmony import */ var _observers_56740e99_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observers-56740e99.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/observers-56740e99.js");




/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const defaultMinusSignRegex = new RegExp("-", "g");
const unnecessaryDecimalRegex = new RegExp("\\.?0+$");
// adopted from https://stackoverflow.com/a/66939244
class BigDecimal {
  constructor(input) {
    this.add = (num) => BigDecimal.fromBigInt(this.value + new BigDecimal(num).value);
    this.subtract = (num) => BigDecimal.fromBigInt(this.value - new BigDecimal(num).value);
    this.multiply = (num) => BigDecimal._divRound(this.value * new BigDecimal(num).value, BigDecimal.SHIFT);
    this.divide = (num) => BigDecimal._divRound(this.value * BigDecimal.SHIFT, new BigDecimal(num).value);
    if (input instanceof BigDecimal) {
      return input;
    }
    const [integers, decimals] = String(input).split(".").concat("");
    this.value =
      BigInt(integers + decimals.padEnd(BigDecimal.DECIMALS, "0").slice(0, BigDecimal.DECIMALS)) +
        BigInt(BigDecimal.ROUNDED && decimals[BigDecimal.DECIMALS] >= "5");
    this.isNegative = input.charAt(0) === "-";
  }
  getIntegersAndDecimals() {
    const s = this.value
      .toString()
      .replace(defaultMinusSignRegex, "")
      .padStart(BigDecimal.DECIMALS + 1, "0");
    const integers = s.slice(0, -BigDecimal.DECIMALS);
    const decimals = s.slice(-BigDecimal.DECIMALS).replace(unnecessaryDecimalRegex, "");
    return { integers, decimals };
  }
  toString() {
    const { integers, decimals } = this.getIntegersAndDecimals();
    return `${this.isNegative ? "-" : ""}${integers}${decimals.length ? "." + decimals : ""}`;
  }
  formatToParts(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const parts = formatter.numberFormatter.formatToParts(BigInt(integers));
    this.isNegative && parts.unshift({ type: "minusSign", value: formatter.minusSign });
    if (decimals.length) {
      parts.push({ type: "decimal", value: formatter.decimal });
      decimals.split("").forEach((char) => parts.push({ type: "fraction", value: char }));
    }
    return parts;
  }
  format(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const integersFormatted = `${this.isNegative ? formatter.minusSign : ""}${formatter.numberFormatter.format(BigInt(integers))}`;
    const decimalsFormatted = decimals.length
      ? `${formatter.decimal}${decimals
        .split("")
        .map((char) => formatter.numberFormatter.format(Number(char)))
        .join("")}`
      : "";
    return `${integersFormatted}${decimalsFormatted}`;
  }
}
// Configuration: constants
BigDecimal.DECIMALS = 100; // number of decimals on all instances
BigDecimal.ROUNDED = true; // numbers are truncated (false) or rounded (true)
BigDecimal.SHIFT = BigInt("1" + "0".repeat(BigDecimal.DECIMALS)); // derived constant
BigDecimal._divRound = (dividend, divisor) => BigDecimal.fromBigInt(dividend / divisor + (BigDecimal.ROUNDED ? ((dividend * BigInt(2)) / divisor) % BigInt(2) : BigInt(0)));
BigDecimal.fromBigInt = (bigint) => Object.assign(Object.create(BigDecimal.prototype), { value: bigint });
function isValidNumber(numberString) {
  return !(!numberString || isNaN(Number(numberString)));
}
function parseNumberString(numberString) {
  if (!numberString || !stringContainsNumbers(numberString)) {
    return "";
  }
  return sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
    let containsDecimal = false;
    const result = nonExpoNumString
      .split("")
      .filter((value, i) => {
      if (value.match(/\./g) && !containsDecimal) {
        containsDecimal = true;
        return true;
      }
      if (value.match(/\-/g) && i === 0) {
        return true;
      }
      return _key_b75491c4_js__WEBPACK_IMPORTED_MODULE_0__.n.includes(value);
    })
      .reduce((string, part) => string + part);
    return isValidNumber(result) ? new BigDecimal(result).toString() : "";
  });
}
// regex for number sanitization
const allLeadingZerosOptionallyNegative = /^([-0])0+(?=\d)/;
const decimalOnlyAtEndOfString = /(?!^\.)\.$/;
const allHyphensExceptTheStart = /(?!^-)-/g;
const isNegativeDecimalOnlyZeros = /^-\b0\b\.?0*$/;
const sanitizeNumberString = (numberString) => sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
  const sanitizedValue = nonExpoNumString
    .replace(allHyphensExceptTheStart, "")
    .replace(decimalOnlyAtEndOfString, "")
    .replace(allLeadingZerosOptionallyNegative, "$1");
  return isValidNumber(sanitizedValue)
    ? isNegativeDecimalOnlyZeros.test(sanitizedValue)
      ? sanitizedValue
      : new BigDecimal(sanitizedValue).toString()
    : nonExpoNumString;
});
function sanitizeExponentialNumberString(numberString, func) {
  if (!numberString) {
    return numberString;
  }
  const firstE = numberString.toLowerCase().indexOf("e") + 1;
  if (!firstE) {
    return func(numberString);
  }
  return numberString
    .replace(/[eE]*$/g, "")
    .substring(0, firstE)
    .concat(numberString.slice(firstE).replace(/[eE]/g, ""))
    .split(/[eE]/)
    .map((section, i) => (i === 1 ? func(section.replace(/\./g, "")) : func(section)))
    .join("e")
    .replace(/^e/, "1e");
}
function stringContainsNumbers(string) {
  return _key_b75491c4_js__WEBPACK_IMPORTED_MODULE_0__.n.some((number) => string.includes(number));
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const defaultLocale = "en";
const t9nLocales = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "el",
  defaultLocale,
  "es",
  "et",
  "fi",
  "fr",
  "he",
  "hr",
  "hu",
  "id",
  "it",
  "ja",
  "ko",
  "lt",
  "lv",
  "no",
  "nl",
  "pl",
  "pt-BR",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
];
const locales = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "de-CH",
  "el",
  defaultLocale,
  "en-AU",
  "en-CA",
  "en-GB",
  "es",
  "es-MX",
  "et",
  "fi",
  "fr",
  "fr-CH",
  "he",
  "hi",
  "hr",
  "hu",
  "id",
  "it",
  "it-CH",
  "ja",
  "ko",
  "lt",
  "lv",
  "mk",
  "no",
  "nl",
  "pl",
  "pt",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
];
const numberingSystems = [
  "arab",
  "arabext",
  "bali",
  "beng",
  "deva",
  "fullwide",
  "gujr",
  "guru",
  "hanidec",
  "khmr",
  "knda",
  "laoo",
  "latn",
  "limb",
  "mlym",
  "mong",
  "mymr",
  "orya",
  "tamldec",
  "telu",
  "thai",
  "tibt"
];
const isNumberingSystemSupported = (numberingSystem) => numberingSystems.includes(numberingSystem);
const browserNumberingSystem = new Intl.NumberFormat().resolvedOptions().numberingSystem;
const defaultNumberingSystem = browserNumberingSystem === "arab" || !isNumberingSystemSupported(browserNumberingSystem)
  ? "latn"
  : browserNumberingSystem;
const getSupportedNumberingSystem = (numberingSystem) => isNumberingSystemSupported(numberingSystem) ? numberingSystem : defaultNumberingSystem;
/**
 * Gets the locale that best matches the context.
 *
 * @param locale â€“ the BCP 47 locale code
 * @param context - specifies whether the locale code should match in the context of CLDR or T9N (translation)
 */
function getSupportedLocale(locale, context = "cldr") {
  const contextualLocales = context === "cldr" ? locales : t9nLocales;
  if (!locale) {
    return defaultLocale;
  }
  if (contextualLocales.includes(locale)) {
    return locale;
  }
  locale = locale.toLowerCase();
  // we support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  if (locale === "nb") {
    return "no";
  }
  // we use `pt-BR` as it will have the same translations as `pt`, which has no corresponding bundle
  if (context === "t9n" && locale === "pt") {
    return "pt-BR";
  }
  if (locale.includes("-")) {
    locale = locale.replace(/(\w+)-(\w+)/, (_match, language, region) => `${language}-${region.toUpperCase()}`);
    if (!contextualLocales.includes(locale)) {
      locale = locale.split("-")[0];
    }
  }
  // we can `zh-CN` as base translation for chinese locales which has no corresponding bundle.
  if (locale === "zh") {
    return "zh-CN";
  }
  if (!contextualLocales.includes(locale)) {
    console.warn(`Translations for the "${locale}" locale are not available and will fall back to the default, English (en).`);
    return defaultLocale;
  }
  return locale;
}
const connectedComponents = new Set();
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback` before any logic that depends on locale
 *
 * @param component
 */
function connectLocalized(component) {
  updateEffectiveLocale(component);
  if (connectedComponents.size === 0) {
    mutationObserver?.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["lang"],
      subtree: true
    });
  }
  connectedComponents.add(component);
}
/**
 * This is only exported for components that implemented the now deprecated `locale` prop.
 *
 * Do not use this utils for new components.
 *
 * @param component
 */
function updateEffectiveLocale(component) {
  component.effectiveLocale = getLocale(component);
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectLocalized(component) {
  connectedComponents.delete(component);
  if (connectedComponents.size === 0) {
    mutationObserver.disconnect();
  }
}
const mutationObserver = (0,_observers_56740e99_js__WEBPACK_IMPORTED_MODULE_1__.c)("mutation", (records) => {
  records.forEach((record) => {
    const el = record.target;
    connectedComponents.forEach((component) => {
      const inUnrelatedSubtree = !(0,_dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_2__.a)(el, component.el);
      if (inUnrelatedSubtree) {
        return;
      }
      const closestLangEl = (0,_dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_2__.c)(component.el, "[lang]");
      if (!closestLangEl) {
        component.effectiveLocale = defaultLocale;
        return;
      }
      const closestLang = closestLangEl.lang;
      component.effectiveLocale =
        // user set lang="" means unknown language, so we use default
        closestLangEl.hasAttribute("lang") && closestLang === "" ? defaultLocale : closestLang;
    });
  });
});
/**
 * This util helps resolve a component's locale.
 * It will also fall back on the deprecated `locale` if a component implemented this previously.
 *
 * @param component
 */
function getLocale(component) {
  return (component.el.lang ||
    (0,_dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_2__.c)(component.el, "[lang]")?.lang ||
    document.documentElement.lang ||
    defaultLocale);
}
/**
 * This util formats and parses numbers for localization
 */
class NumberStringFormat {
  constructor() {
    this.delocalize = (numberString) => 
    // For performance, (de)localization is skipped if the formatter isn't initialized.
    // In order to localize/delocalize, e.g. when lang/numberingSystem props are not default values,
    // `numberFormatOptions` must be set in a component to create and cache the formatter.
    this._numberFormatOptions
      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => nonExpoNumString
        .trim()
        .replace(new RegExp(`[${this._minusSign}]`, "g"), "-")
        .replace(new RegExp(`[${this._group}]`, "g"), "")
        .replace(new RegExp(`[${this._decimal}]`, "g"), ".")
        .replace(new RegExp(`[${this._digits.join("")}]`, "g"), this._getDigitIndex))
      : numberString;
    this.localize = (numberString) => this._numberFormatOptions
      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => isValidNumber(nonExpoNumString.trim())
        ? new BigDecimal(nonExpoNumString.trim())
          .format(this)
          .replace(new RegExp(`[${this._actualGroup}]`, "g"), this._group)
        : nonExpoNumString)
      : numberString;
  }
  get group() {
    return this._group;
  }
  get decimal() {
    return this._decimal;
  }
  get minusSign() {
    return this._minusSign;
  }
  get digits() {
    return this._digits;
  }
  get numberFormatter() {
    return this._numberFormatter;
  }
  get numberFormatOptions() {
    return this._numberFormatOptions;
  }
  /**
   * numberFormatOptions needs to be set before localize/delocalize is called to ensure the options are up to date
   */
  set numberFormatOptions(options) {
    options.locale = getSupportedLocale(options?.locale);
    options.numberingSystem = getSupportedNumberingSystem(options?.numberingSystem);
    if (
    // No need to create the formatter if `locale` and `numberingSystem`
    // are the default values and `numberFormatOptions` has not been set
    (!this._numberFormatOptions &&
      options.locale === defaultLocale &&
      options.numberingSystem === defaultNumberingSystem &&
      // don't skip initialization if any options besides locale/numberingSystem are set
      Object.keys(options).length === 2) ||
      // cache formatter by only recreating when options change
      JSON.stringify(this._numberFormatOptions) === JSON.stringify(options)) {
      return;
    }
    this._numberFormatOptions = options;
    this._numberFormatter = new Intl.NumberFormat(this._numberFormatOptions.locale, this._numberFormatOptions);
    this._digits = [
      ...new Intl.NumberFormat(this._numberFormatOptions.locale, {
        useGrouping: false,
        numberingSystem: this._numberFormatOptions.numberingSystem
      }).format(9876543210)
    ].reverse();
    const index = new Map(this._digits.map((d, i) => [d, i]));
    const parts = new Intl.NumberFormat(this._numberFormatOptions.locale).formatToParts(-12345678.9);
    this._actualGroup = parts.find((d) => d.type === "group").value;
    // change whitespace group characters that don't render correctly
    this._group = this._actualGroup.trim().length === 0 ? " " : this._actualGroup;
    this._decimal = parts.find((d) => d.type === "decimal").value;
    this._minusSign = parts.find((d) => d.type === "minusSign").value;
    this._getDigitIndex = (d) => index.get(d);
  }
}
const numberStringFormatter = new NumberStringFormat();



//# sourceMappingURL=locale-f7b2fbb0.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/observers-56740e99.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/observers-56740e99.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createObserver)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
/**
 * This utility ensures observers are created only for browser contexts.
 *
 * @param type - the type of observer to create
 * @param callback - the observer callback
 * @param options - the observer options
 */
function createObserver(type, callback, options) {
  const Observer = getObserver(type);
  return new Observer(callback, options);
}
function getObserver(type) {
  // based on https://github.com/whatwg/dom/issues/126#issuecomment-1049814948
  class ExtendedMutationObserver extends window.MutationObserver {
    constructor(callback) {
      super(callback);
      this.observedEntry = [];
      this.callback = callback;
    }
    observe(target, options) {
      this.observedEntry.push({ target, options });
      return super.observe(target, options);
    }
    unobserve(target) {
      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);
      this.observedEntry = [];
      this.callback(super.takeRecords(), this);
      this.disconnect();
      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));
    }
  }
  return (function () {
    return (type === "intersection"
      ? window.IntersectionObserver
      : type === "mutation"
        ? ExtendedMutationObserver
        : window.ResizeObserver);
  })();
}



//# sourceMappingURL=observers-56740e99.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLWY2NjllYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUQ7O0FBRWpEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWjZHO0FBQ3pEO0FBQ1U7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsY0FBYywyQkFBMkIsRUFBRSxTQUFTLEVBQUUsc0NBQXNDO0FBQzVGO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLHVDQUF1QywrQ0FBK0M7QUFDdEY7QUFDQSxtQkFBbUIsMkNBQTJDO0FBQzlELHdEQUF3RCwrQkFBK0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxpQ0FBaUMsMkNBQTJDLEVBQUUsbURBQW1EO0FBQ2pJO0FBQ0EsV0FBVyxrQkFBa0IsRUFBRTtBQUMvQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsY0FBYyxrQkFBa0IsRUFBRSxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixrRUFBa0U7QUFDbEU7QUFDQSx5RkFBeUYsZUFBZTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQVU7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQ0FBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsU0FBUyxHQUFHLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtREFBMkI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQWlDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQsZ0NBQWdDLFlBQVk7QUFDNUMsZ0NBQWdDLGNBQWM7QUFDOUMsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzUDs7QUFFdFA7Ozs7Ozs7Ozs7Ozs7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFK0I7O0FBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9iYS1pbmZvZ3JhcGhpYy9ub2RlX21vZHVsZXMvQGFyY2dpcy9idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHMvZGlzdC9zdGVuY2lsLWNvbXBvbmVudHMvZGlzdC9lc20va2V5LWI3NTQ5MWM0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYmEtaW5mb2dyYXBoaWMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYnVzaW5lc3MtYW5hbHlzdC1jb21wb25lbnRzL2Rpc3Qvc3RlbmNpbC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS1mN2IyZmJiMC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9vYnNlcnZlcnMtNTY3NDBlOTkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmZ1bmN0aW9uIGlzQWN0aXZhdGlvbktleShrZXkpIHtcbiAgcmV0dXJuIGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCIgXCI7XG59XG5jb25zdCBudW1iZXJLZXlzID0gW1wiMFwiLCBcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiXTtcblxuZXhwb3J0IHsgaXNBY3RpdmF0aW9uS2V5IGFzIGksIG51bWJlcktleXMgYXMgbiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXktYjc1NDkxYzQuanMubWFwIiwiaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnksIGEgYXMgY29udGFpbnNDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tZjFlZTRkMDQuanMnO1xuaW1wb3J0IHsgbiBhcyBudW1iZXJLZXlzIH0gZnJvbSAnLi9rZXktYjc1NDkxYzQuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVPYnNlcnZlciB9IGZyb20gJy4vb2JzZXJ2ZXJzLTU2NzQwZTk5LmpzJztcblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmNvbnN0IGRlZmF1bHRNaW51c1NpZ25SZWdleCA9IG5ldyBSZWdFeHAoXCItXCIsIFwiZ1wiKTtcbmNvbnN0IHVubmVjZXNzYXJ5RGVjaW1hbFJlZ2V4ID0gbmV3IFJlZ0V4cChcIlxcXFwuPzArJFwiKTtcbi8vIGFkb3B0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjY5MzkyNDRcbmNsYXNzIEJpZ0RlY2ltYWwge1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIHRoaXMuYWRkID0gKG51bSkgPT4gQmlnRGVjaW1hbC5mcm9tQmlnSW50KHRoaXMudmFsdWUgKyBuZXcgQmlnRGVjaW1hbChudW0pLnZhbHVlKTtcbiAgICB0aGlzLnN1YnRyYWN0ID0gKG51bSkgPT4gQmlnRGVjaW1hbC5mcm9tQmlnSW50KHRoaXMudmFsdWUgLSBuZXcgQmlnRGVjaW1hbChudW0pLnZhbHVlKTtcbiAgICB0aGlzLm11bHRpcGx5ID0gKG51bSkgPT4gQmlnRGVjaW1hbC5fZGl2Um91bmQodGhpcy52YWx1ZSAqIG5ldyBCaWdEZWNpbWFsKG51bSkudmFsdWUsIEJpZ0RlY2ltYWwuU0hJRlQpO1xuICAgIHRoaXMuZGl2aWRlID0gKG51bSkgPT4gQmlnRGVjaW1hbC5fZGl2Um91bmQodGhpcy52YWx1ZSAqIEJpZ0RlY2ltYWwuU0hJRlQsIG5ldyBCaWdEZWNpbWFsKG51bSkudmFsdWUpO1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEJpZ0RlY2ltYWwpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgW2ludGVnZXJzLCBkZWNpbWFsc10gPSBTdHJpbmcoaW5wdXQpLnNwbGl0KFwiLlwiKS5jb25jYXQoXCJcIik7XG4gICAgdGhpcy52YWx1ZSA9XG4gICAgICBCaWdJbnQoaW50ZWdlcnMgKyBkZWNpbWFscy5wYWRFbmQoQmlnRGVjaW1hbC5ERUNJTUFMUywgXCIwXCIpLnNsaWNlKDAsIEJpZ0RlY2ltYWwuREVDSU1BTFMpKSArXG4gICAgICAgIEJpZ0ludChCaWdEZWNpbWFsLlJPVU5ERUQgJiYgZGVjaW1hbHNbQmlnRGVjaW1hbC5ERUNJTUFMU10gPj0gXCI1XCIpO1xuICAgIHRoaXMuaXNOZWdhdGl2ZSA9IGlucHV0LmNoYXJBdCgwKSA9PT0gXCItXCI7XG4gIH1cbiAgZ2V0SW50ZWdlcnNBbmREZWNpbWFscygpIHtcbiAgICBjb25zdCBzID0gdGhpcy52YWx1ZVxuICAgICAgLnRvU3RyaW5nKClcbiAgICAgIC5yZXBsYWNlKGRlZmF1bHRNaW51c1NpZ25SZWdleCwgXCJcIilcbiAgICAgIC5wYWRTdGFydChCaWdEZWNpbWFsLkRFQ0lNQUxTICsgMSwgXCIwXCIpO1xuICAgIGNvbnN0IGludGVnZXJzID0gcy5zbGljZSgwLCAtQmlnRGVjaW1hbC5ERUNJTUFMUyk7XG4gICAgY29uc3QgZGVjaW1hbHMgPSBzLnNsaWNlKC1CaWdEZWNpbWFsLkRFQ0lNQUxTKS5yZXBsYWNlKHVubmVjZXNzYXJ5RGVjaW1hbFJlZ2V4LCBcIlwiKTtcbiAgICByZXR1cm4geyBpbnRlZ2VycywgZGVjaW1hbHMgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCB7IGludGVnZXJzLCBkZWNpbWFscyB9ID0gdGhpcy5nZXRJbnRlZ2Vyc0FuZERlY2ltYWxzKCk7XG4gICAgcmV0dXJuIGAke3RoaXMuaXNOZWdhdGl2ZSA/IFwiLVwiIDogXCJcIn0ke2ludGVnZXJzfSR7ZGVjaW1hbHMubGVuZ3RoID8gXCIuXCIgKyBkZWNpbWFscyA6IFwiXCJ9YDtcbiAgfVxuICBmb3JtYXRUb1BhcnRzKGZvcm1hdHRlcikge1xuICAgIGNvbnN0IHsgaW50ZWdlcnMsIGRlY2ltYWxzIH0gPSB0aGlzLmdldEludGVnZXJzQW5kRGVjaW1hbHMoKTtcbiAgICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhCaWdJbnQoaW50ZWdlcnMpKTtcbiAgICB0aGlzLmlzTmVnYXRpdmUgJiYgcGFydHMudW5zaGlmdCh7IHR5cGU6IFwibWludXNTaWduXCIsIHZhbHVlOiBmb3JtYXR0ZXIubWludXNTaWduIH0pO1xuICAgIGlmIChkZWNpbWFscy5sZW5ndGgpIHtcbiAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiBcImRlY2ltYWxcIiwgdmFsdWU6IGZvcm1hdHRlci5kZWNpbWFsIH0pO1xuICAgICAgZGVjaW1hbHMuc3BsaXQoXCJcIikuZm9yRWFjaCgoY2hhcikgPT4gcGFydHMucHVzaCh7IHR5cGU6IFwiZnJhY3Rpb25cIiwgdmFsdWU6IGNoYXIgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cbiAgZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIGNvbnN0IHsgaW50ZWdlcnMsIGRlY2ltYWxzIH0gPSB0aGlzLmdldEludGVnZXJzQW5kRGVjaW1hbHMoKTtcbiAgICBjb25zdCBpbnRlZ2Vyc0Zvcm1hdHRlZCA9IGAke3RoaXMuaXNOZWdhdGl2ZSA/IGZvcm1hdHRlci5taW51c1NpZ24gOiBcIlwifSR7Zm9ybWF0dGVyLm51bWJlckZvcm1hdHRlci5mb3JtYXQoQmlnSW50KGludGVnZXJzKSl9YDtcbiAgICBjb25zdCBkZWNpbWFsc0Zvcm1hdHRlZCA9IGRlY2ltYWxzLmxlbmd0aFxuICAgICAgPyBgJHtmb3JtYXR0ZXIuZGVjaW1hbH0ke2RlY2ltYWxzXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAubWFwKChjaGFyKSA9PiBmb3JtYXR0ZXIubnVtYmVyRm9ybWF0dGVyLmZvcm1hdChOdW1iZXIoY2hhcikpKVxuICAgICAgICAuam9pbihcIlwiKX1gXG4gICAgICA6IFwiXCI7XG4gICAgcmV0dXJuIGAke2ludGVnZXJzRm9ybWF0dGVkfSR7ZGVjaW1hbHNGb3JtYXR0ZWR9YDtcbiAgfVxufVxuLy8gQ29uZmlndXJhdGlvbjogY29uc3RhbnRzXG5CaWdEZWNpbWFsLkRFQ0lNQUxTID0gMTAwOyAvLyBudW1iZXIgb2YgZGVjaW1hbHMgb24gYWxsIGluc3RhbmNlc1xuQmlnRGVjaW1hbC5ST1VOREVEID0gdHJ1ZTsgLy8gbnVtYmVycyBhcmUgdHJ1bmNhdGVkIChmYWxzZSkgb3Igcm91bmRlZCAodHJ1ZSlcbkJpZ0RlY2ltYWwuU0hJRlQgPSBCaWdJbnQoXCIxXCIgKyBcIjBcIi5yZXBlYXQoQmlnRGVjaW1hbC5ERUNJTUFMUykpOyAvLyBkZXJpdmVkIGNvbnN0YW50XG5CaWdEZWNpbWFsLl9kaXZSb3VuZCA9IChkaXZpZGVuZCwgZGl2aXNvcikgPT4gQmlnRGVjaW1hbC5mcm9tQmlnSW50KGRpdmlkZW5kIC8gZGl2aXNvciArIChCaWdEZWNpbWFsLlJPVU5ERUQgPyAoKGRpdmlkZW5kICogQmlnSW50KDIpKSAvIGRpdmlzb3IpICUgQmlnSW50KDIpIDogQmlnSW50KDApKSk7XG5CaWdEZWNpbWFsLmZyb21CaWdJbnQgPSAoYmlnaW50KSA9PiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoQmlnRGVjaW1hbC5wcm90b3R5cGUpLCB7IHZhbHVlOiBiaWdpbnQgfSk7XG5mdW5jdGlvbiBpc1ZhbGlkTnVtYmVyKG51bWJlclN0cmluZykge1xuICByZXR1cm4gISghbnVtYmVyU3RyaW5nIHx8IGlzTmFOKE51bWJlcihudW1iZXJTdHJpbmcpKSk7XG59XG5mdW5jdGlvbiBwYXJzZU51bWJlclN0cmluZyhudW1iZXJTdHJpbmcpIHtcbiAgaWYgKCFudW1iZXJTdHJpbmcgfHwgIXN0cmluZ0NvbnRhaW5zTnVtYmVycyhudW1iZXJTdHJpbmcpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIHNhbml0aXplRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nLCAobm9uRXhwb051bVN0cmluZykgPT4ge1xuICAgIGxldCBjb250YWluc0RlY2ltYWwgPSBmYWxzZTtcbiAgICBjb25zdCByZXN1bHQgPSBub25FeHBvTnVtU3RyaW5nXG4gICAgICAuc3BsaXQoXCJcIilcbiAgICAgIC5maWx0ZXIoKHZhbHVlLCBpKSA9PiB7XG4gICAgICBpZiAodmFsdWUubWF0Y2goL1xcLi9nKSAmJiAhY29udGFpbnNEZWNpbWFsKSB7XG4gICAgICAgIGNvbnRhaW5zRGVjaW1hbCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLm1hdGNoKC9cXC0vZykgJiYgaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXJLZXlzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9KVxuICAgICAgLnJlZHVjZSgoc3RyaW5nLCBwYXJ0KSA9PiBzdHJpbmcgKyBwYXJ0KTtcbiAgICByZXR1cm4gaXNWYWxpZE51bWJlcihyZXN1bHQpID8gbmV3IEJpZ0RlY2ltYWwocmVzdWx0KS50b1N0cmluZygpIDogXCJcIjtcbiAgfSk7XG59XG4vLyByZWdleCBmb3IgbnVtYmVyIHNhbml0aXphdGlvblxuY29uc3QgYWxsTGVhZGluZ1plcm9zT3B0aW9uYWxseU5lZ2F0aXZlID0gL14oWy0wXSkwKyg/PVxcZCkvO1xuY29uc3QgZGVjaW1hbE9ubHlBdEVuZE9mU3RyaW5nID0gLyg/IV5cXC4pXFwuJC87XG5jb25zdCBhbGxIeXBoZW5zRXhjZXB0VGhlU3RhcnQgPSAvKD8hXi0pLS9nO1xuY29uc3QgaXNOZWdhdGl2ZURlY2ltYWxPbmx5WmVyb3MgPSAvXi1cXGIwXFxiXFwuPzAqJC87XG5jb25zdCBzYW5pdGl6ZU51bWJlclN0cmluZyA9IChudW1iZXJTdHJpbmcpID0+IHNhbml0aXplRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nLCAobm9uRXhwb051bVN0cmluZykgPT4ge1xuICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IG5vbkV4cG9OdW1TdHJpbmdcbiAgICAucmVwbGFjZShhbGxIeXBoZW5zRXhjZXB0VGhlU3RhcnQsIFwiXCIpXG4gICAgLnJlcGxhY2UoZGVjaW1hbE9ubHlBdEVuZE9mU3RyaW5nLCBcIlwiKVxuICAgIC5yZXBsYWNlKGFsbExlYWRpbmdaZXJvc09wdGlvbmFsbHlOZWdhdGl2ZSwgXCIkMVwiKTtcbiAgcmV0dXJuIGlzVmFsaWROdW1iZXIoc2FuaXRpemVkVmFsdWUpXG4gICAgPyBpc05lZ2F0aXZlRGVjaW1hbE9ubHlaZXJvcy50ZXN0KHNhbml0aXplZFZhbHVlKVxuICAgICAgPyBzYW5pdGl6ZWRWYWx1ZVxuICAgICAgOiBuZXcgQmlnRGVjaW1hbChzYW5pdGl6ZWRWYWx1ZSkudG9TdHJpbmcoKVxuICAgIDogbm9uRXhwb051bVN0cmluZztcbn0pO1xuZnVuY3Rpb24gc2FuaXRpemVFeHBvbmVudGlhbE51bWJlclN0cmluZyhudW1iZXJTdHJpbmcsIGZ1bmMpIHtcbiAgaWYgKCFudW1iZXJTdHJpbmcpIHtcbiAgICByZXR1cm4gbnVtYmVyU3RyaW5nO1xuICB9XG4gIGNvbnN0IGZpcnN0RSA9IG51bWJlclN0cmluZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJlXCIpICsgMTtcbiAgaWYgKCFmaXJzdEUpIHtcbiAgICByZXR1cm4gZnVuYyhudW1iZXJTdHJpbmcpO1xuICB9XG4gIHJldHVybiBudW1iZXJTdHJpbmdcbiAgICAucmVwbGFjZSgvW2VFXSokL2csIFwiXCIpXG4gICAgLnN1YnN0cmluZygwLCBmaXJzdEUpXG4gICAgLmNvbmNhdChudW1iZXJTdHJpbmcuc2xpY2UoZmlyc3RFKS5yZXBsYWNlKC9bZUVdL2csIFwiXCIpKVxuICAgIC5zcGxpdCgvW2VFXS8pXG4gICAgLm1hcCgoc2VjdGlvbiwgaSkgPT4gKGkgPT09IDEgPyBmdW5jKHNlY3Rpb24ucmVwbGFjZSgvXFwuL2csIFwiXCIpKSA6IGZ1bmMoc2VjdGlvbikpKVxuICAgIC5qb2luKFwiZVwiKVxuICAgIC5yZXBsYWNlKC9eZS8sIFwiMWVcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdDb250YWluc051bWJlcnMoc3RyaW5nKSB7XG4gIHJldHVybiBudW1iZXJLZXlzLnNvbWUoKG51bWJlcikgPT4gc3RyaW5nLmluY2x1ZGVzKG51bWJlcikpO1xufVxuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuY29uc3QgZGVmYXVsdExvY2FsZSA9IFwiZW5cIjtcbmNvbnN0IHQ5bkxvY2FsZXMgPSBbXG4gIFwiYXJcIixcbiAgXCJiZ1wiLFxuICBcImJzXCIsXG4gIFwiY2FcIixcbiAgXCJjc1wiLFxuICBcImRhXCIsXG4gIFwiZGVcIixcbiAgXCJlbFwiLFxuICBkZWZhdWx0TG9jYWxlLFxuICBcImVzXCIsXG4gIFwiZXRcIixcbiAgXCJmaVwiLFxuICBcImZyXCIsXG4gIFwiaGVcIixcbiAgXCJoclwiLFxuICBcImh1XCIsXG4gIFwiaWRcIixcbiAgXCJpdFwiLFxuICBcImphXCIsXG4gIFwia29cIixcbiAgXCJsdFwiLFxuICBcImx2XCIsXG4gIFwibm9cIixcbiAgXCJubFwiLFxuICBcInBsXCIsXG4gIFwicHQtQlJcIixcbiAgXCJwdC1QVFwiLFxuICBcInJvXCIsXG4gIFwicnVcIixcbiAgXCJza1wiLFxuICBcInNsXCIsXG4gIFwic3JcIixcbiAgXCJzdlwiLFxuICBcInRoXCIsXG4gIFwidHJcIixcbiAgXCJ1a1wiLFxuICBcInZpXCIsXG4gIFwiemgtQ05cIixcbiAgXCJ6aC1IS1wiLFxuICBcInpoLVRXXCJcbl07XG5jb25zdCBsb2NhbGVzID0gW1xuICBcImFyXCIsXG4gIFwiYmdcIixcbiAgXCJic1wiLFxuICBcImNhXCIsXG4gIFwiY3NcIixcbiAgXCJkYVwiLFxuICBcImRlXCIsXG4gIFwiZGUtQ0hcIixcbiAgXCJlbFwiLFxuICBkZWZhdWx0TG9jYWxlLFxuICBcImVuLUFVXCIsXG4gIFwiZW4tQ0FcIixcbiAgXCJlbi1HQlwiLFxuICBcImVzXCIsXG4gIFwiZXMtTVhcIixcbiAgXCJldFwiLFxuICBcImZpXCIsXG4gIFwiZnJcIixcbiAgXCJmci1DSFwiLFxuICBcImhlXCIsXG4gIFwiaGlcIixcbiAgXCJoclwiLFxuICBcImh1XCIsXG4gIFwiaWRcIixcbiAgXCJpdFwiLFxuICBcIml0LUNIXCIsXG4gIFwiamFcIixcbiAgXCJrb1wiLFxuICBcImx0XCIsXG4gIFwibHZcIixcbiAgXCJta1wiLFxuICBcIm5vXCIsXG4gIFwibmxcIixcbiAgXCJwbFwiLFxuICBcInB0XCIsXG4gIFwicHQtUFRcIixcbiAgXCJyb1wiLFxuICBcInJ1XCIsXG4gIFwic2tcIixcbiAgXCJzbFwiLFxuICBcInNyXCIsXG4gIFwic3ZcIixcbiAgXCJ0aFwiLFxuICBcInRyXCIsXG4gIFwidWtcIixcbiAgXCJ2aVwiLFxuICBcInpoLUNOXCIsXG4gIFwiemgtSEtcIixcbiAgXCJ6aC1UV1wiXG5dO1xuY29uc3QgbnVtYmVyaW5nU3lzdGVtcyA9IFtcbiAgXCJhcmFiXCIsXG4gIFwiYXJhYmV4dFwiLFxuICBcImJhbGlcIixcbiAgXCJiZW5nXCIsXG4gIFwiZGV2YVwiLFxuICBcImZ1bGx3aWRlXCIsXG4gIFwiZ3VqclwiLFxuICBcImd1cnVcIixcbiAgXCJoYW5pZGVjXCIsXG4gIFwia2htclwiLFxuICBcImtuZGFcIixcbiAgXCJsYW9vXCIsXG4gIFwibGF0blwiLFxuICBcImxpbWJcIixcbiAgXCJtbHltXCIsXG4gIFwibW9uZ1wiLFxuICBcIm15bXJcIixcbiAgXCJvcnlhXCIsXG4gIFwidGFtbGRlY1wiLFxuICBcInRlbHVcIixcbiAgXCJ0aGFpXCIsXG4gIFwidGlidFwiXG5dO1xuY29uc3QgaXNOdW1iZXJpbmdTeXN0ZW1TdXBwb3J0ZWQgPSAobnVtYmVyaW5nU3lzdGVtKSA9PiBudW1iZXJpbmdTeXN0ZW1zLmluY2x1ZGVzKG51bWJlcmluZ1N5c3RlbSk7XG5jb25zdCBicm93c2VyTnVtYmVyaW5nU3lzdGVtID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtO1xuY29uc3QgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IGJyb3dzZXJOdW1iZXJpbmdTeXN0ZW0gPT09IFwiYXJhYlwiIHx8ICFpc051bWJlcmluZ1N5c3RlbVN1cHBvcnRlZChicm93c2VyTnVtYmVyaW5nU3lzdGVtKVxuICA/IFwibGF0blwiXG4gIDogYnJvd3Nlck51bWJlcmluZ1N5c3RlbTtcbmNvbnN0IGdldFN1cHBvcnRlZE51bWJlcmluZ1N5c3RlbSA9IChudW1iZXJpbmdTeXN0ZW0pID0+IGlzTnVtYmVyaW5nU3lzdGVtU3VwcG9ydGVkKG51bWJlcmluZ1N5c3RlbSkgPyBudW1iZXJpbmdTeXN0ZW0gOiBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtO1xuLyoqXG4gKiBHZXRzIHRoZSBsb2NhbGUgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGxvY2FsZSDigJMgdGhlIEJDUCA0NyBsb2NhbGUgY29kZVxuICogQHBhcmFtIGNvbnRleHQgLSBzcGVjaWZpZXMgd2hldGhlciB0aGUgbG9jYWxlIGNvZGUgc2hvdWxkIG1hdGNoIGluIHRoZSBjb250ZXh0IG9mIENMRFIgb3IgVDlOICh0cmFuc2xhdGlvbilcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkTG9jYWxlKGxvY2FsZSwgY29udGV4dCA9IFwiY2xkclwiKSB7XG4gIGNvbnN0IGNvbnRleHR1YWxMb2NhbGVzID0gY29udGV4dCA9PT0gXCJjbGRyXCIgPyBsb2NhbGVzIDogdDluTG9jYWxlcztcbiAgaWYgKCFsb2NhbGUpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuICBpZiAoY29udGV4dHVhbExvY2FsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgIHJldHVybiBsb2NhbGU7XG4gIH1cbiAgbG9jYWxlID0gbG9jYWxlLnRvTG93ZXJDYXNlKCk7XG4gIC8vIHdlIHN1cHBvcnQgYm90aCAnbmInIGFuZCAnbm8nIChCQ1AgNDcpIGZvciBOb3J3ZWdpYW4gYnV0IG9ubHkgYG5vYCBoYXMgY29ycmVzcG9uZGluZyBidW5kbGVcbiAgaWYgKGxvY2FsZSA9PT0gXCJuYlwiKSB7XG4gICAgcmV0dXJuIFwibm9cIjtcbiAgfVxuICAvLyB3ZSB1c2UgYHB0LUJSYCBhcyBpdCB3aWxsIGhhdmUgdGhlIHNhbWUgdHJhbnNsYXRpb25zIGFzIGBwdGAsIHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIGJ1bmRsZVxuICBpZiAoY29udGV4dCA9PT0gXCJ0OW5cIiAmJiBsb2NhbGUgPT09IFwicHRcIikge1xuICAgIHJldHVybiBcInB0LUJSXCI7XG4gIH1cbiAgaWYgKGxvY2FsZS5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICBsb2NhbGUgPSBsb2NhbGUucmVwbGFjZSgvKFxcdyspLShcXHcrKS8sIChfbWF0Y2gsIGxhbmd1YWdlLCByZWdpb24pID0+IGAke2xhbmd1YWdlfS0ke3JlZ2lvbi50b1VwcGVyQ2FzZSgpfWApO1xuICAgIGlmICghY29udGV4dHVhbExvY2FsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgbG9jYWxlID0gbG9jYWxlLnNwbGl0KFwiLVwiKVswXTtcbiAgICB9XG4gIH1cbiAgLy8gd2UgY2FuIGB6aC1DTmAgYXMgYmFzZSB0cmFuc2xhdGlvbiBmb3IgY2hpbmVzZSBsb2NhbGVzIHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIGJ1bmRsZS5cbiAgaWYgKGxvY2FsZSA9PT0gXCJ6aFwiKSB7XG4gICAgcmV0dXJuIFwiemgtQ05cIjtcbiAgfVxuICBpZiAoIWNvbnRleHR1YWxMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICBjb25zb2xlLndhcm4oYFRyYW5zbGF0aW9ucyBmb3IgdGhlIFwiJHtsb2NhbGV9XCIgbG9jYWxlIGFyZSBub3QgYXZhaWxhYmxlIGFuZCB3aWxsIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCwgRW5nbGlzaCAoZW4pLmApO1xuICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICB9XG4gIHJldHVybiBsb2NhbGU7XG59XG5jb25zdCBjb25uZWN0ZWRDb21wb25lbnRzID0gbmV3IFNldCgpO1xuLyoqXG4gKiBUaGlzIHV0aWxpdHkgc2V0cyB1cCBpbnRlcm5hbHMgZm9yIG1lc3NhZ2VzIHN1cHBvcnQuXG4gKlxuICogSXQgbmVlZHMgdG8gYmUgY2FsbGVkIGluIGBjb25uZWN0ZWRDYWxsYmFja2AgYmVmb3JlIGFueSBsb2dpYyB0aGF0IGRlcGVuZHMgb24gbG9jYWxlXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBjb25uZWN0TG9jYWxpemVkKGNvbXBvbmVudCkge1xuICB1cGRhdGVFZmZlY3RpdmVMb2NhbGUoY29tcG9uZW50KTtcbiAgaWYgKGNvbm5lY3RlZENvbXBvbmVudHMuc2l6ZSA9PT0gMCkge1xuICAgIG11dGF0aW9uT2JzZXJ2ZXI/Lm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJsYW5nXCJdLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbm5lY3RlZENvbXBvbmVudHMuYWRkKGNvbXBvbmVudCk7XG59XG4vKipcbiAqIFRoaXMgaXMgb25seSBleHBvcnRlZCBmb3IgY29tcG9uZW50cyB0aGF0IGltcGxlbWVudGVkIHRoZSBub3cgZGVwcmVjYXRlZCBgbG9jYWxlYCBwcm9wLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyB1dGlscyBmb3IgbmV3IGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RpdmVMb2NhbGUoY29tcG9uZW50KSB7XG4gIGNvbXBvbmVudC5lZmZlY3RpdmVMb2NhbGUgPSBnZXRMb2NhbGUoY29tcG9uZW50KTtcbn1cbi8qKlxuICogVGhpcyB1dGlsaXR5IHRlYXJzIGRvd24gaW50ZXJuYWxzIGZvciBtZXNzYWdlcyBzdXBwb3J0LlxuICpcbiAqIEl0IG5lZWRzIHRvIGJlIGNhbGxlZCBpbiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBkaXNjb25uZWN0TG9jYWxpemVkKGNvbXBvbmVudCkge1xuICBjb25uZWN0ZWRDb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuICBpZiAoY29ubmVjdGVkQ29tcG9uZW50cy5zaXplID09PSAwKSB7XG4gICAgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbn1cbmNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcihcIm11dGF0aW9uXCIsIChyZWNvcmRzKSA9PiB7XG4gIHJlY29yZHMuZm9yRWFjaCgocmVjb3JkKSA9PiB7XG4gICAgY29uc3QgZWwgPSByZWNvcmQudGFyZ2V0O1xuICAgIGNvbm5lY3RlZENvbXBvbmVudHMuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICBjb25zdCBpblVucmVsYXRlZFN1YnRyZWUgPSAhY29udGFpbnNDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBjb21wb25lbnQuZWwpO1xuICAgICAgaWYgKGluVW5yZWxhdGVkU3VidHJlZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjbG9zZXN0TGFuZ0VsID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGNvbXBvbmVudC5lbCwgXCJbbGFuZ11cIik7XG4gICAgICBpZiAoIWNsb3Nlc3RMYW5nRWwpIHtcbiAgICAgICAgY29tcG9uZW50LmVmZmVjdGl2ZUxvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsb3Nlc3RMYW5nID0gY2xvc2VzdExhbmdFbC5sYW5nO1xuICAgICAgY29tcG9uZW50LmVmZmVjdGl2ZUxvY2FsZSA9XG4gICAgICAgIC8vIHVzZXIgc2V0IGxhbmc9XCJcIiBtZWFucyB1bmtub3duIGxhbmd1YWdlLCBzbyB3ZSB1c2UgZGVmYXVsdFxuICAgICAgICBjbG9zZXN0TGFuZ0VsLmhhc0F0dHJpYnV0ZShcImxhbmdcIikgJiYgY2xvc2VzdExhbmcgPT09IFwiXCIgPyBkZWZhdWx0TG9jYWxlIDogY2xvc2VzdExhbmc7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4vKipcbiAqIFRoaXMgdXRpbCBoZWxwcyByZXNvbHZlIGEgY29tcG9uZW50J3MgbG9jYWxlLlxuICogSXQgd2lsbCBhbHNvIGZhbGwgYmFjayBvbiB0aGUgZGVwcmVjYXRlZCBgbG9jYWxlYCBpZiBhIGNvbXBvbmVudCBpbXBsZW1lbnRlZCB0aGlzIHByZXZpb3VzbHkuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBnZXRMb2NhbGUoY29tcG9uZW50KSB7XG4gIHJldHVybiAoY29tcG9uZW50LmVsLmxhbmcgfHxcbiAgICBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoY29tcG9uZW50LmVsLCBcIltsYW5nXVwiKT8ubGFuZyB8fFxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nIHx8XG4gICAgZGVmYXVsdExvY2FsZSk7XG59XG4vKipcbiAqIFRoaXMgdXRpbCBmb3JtYXRzIGFuZCBwYXJzZXMgbnVtYmVycyBmb3IgbG9jYWxpemF0aW9uXG4gKi9cbmNsYXNzIE51bWJlclN0cmluZ0Zvcm1hdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVsb2NhbGl6ZSA9IChudW1iZXJTdHJpbmcpID0+IFxuICAgIC8vIEZvciBwZXJmb3JtYW5jZSwgKGRlKWxvY2FsaXphdGlvbiBpcyBza2lwcGVkIGlmIHRoZSBmb3JtYXR0ZXIgaXNuJ3QgaW5pdGlhbGl6ZWQuXG4gICAgLy8gSW4gb3JkZXIgdG8gbG9jYWxpemUvZGVsb2NhbGl6ZSwgZS5nLiB3aGVuIGxhbmcvbnVtYmVyaW5nU3lzdGVtIHByb3BzIGFyZSBub3QgZGVmYXVsdCB2YWx1ZXMsXG4gICAgLy8gYG51bWJlckZvcm1hdE9wdGlvbnNgIG11c3QgYmUgc2V0IGluIGEgY29tcG9uZW50IHRvIGNyZWF0ZSBhbmQgY2FjaGUgdGhlIGZvcm1hdHRlci5cbiAgICB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zXG4gICAgICA/IHNhbml0aXplRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nLCAobm9uRXhwb051bVN0cmluZykgPT4gbm9uRXhwb051bVN0cmluZ1xuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX21pbnVzU2lnbn1dYCwgXCJnXCIpLCBcIi1cIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fZ3JvdXB9XWAsIFwiZ1wiKSwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fZGVjaW1hbH1dYCwgXCJnXCIpLCBcIi5cIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fZGlnaXRzLmpvaW4oXCJcIil9XWAsIFwiZ1wiKSwgdGhpcy5fZ2V0RGlnaXRJbmRleCkpXG4gICAgICA6IG51bWJlclN0cmluZztcbiAgICB0aGlzLmxvY2FsaXplID0gKG51bWJlclN0cmluZykgPT4gdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9uc1xuICAgICAgPyBzYW5pdGl6ZUV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKG51bWJlclN0cmluZywgKG5vbkV4cG9OdW1TdHJpbmcpID0+IGlzVmFsaWROdW1iZXIobm9uRXhwb051bVN0cmluZy50cmltKCkpXG4gICAgICAgID8gbmV3IEJpZ0RlY2ltYWwobm9uRXhwb051bVN0cmluZy50cmltKCkpXG4gICAgICAgICAgLmZvcm1hdCh0aGlzKVxuICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX2FjdHVhbEdyb3VwfV1gLCBcImdcIiksIHRoaXMuX2dyb3VwKVxuICAgICAgICA6IG5vbkV4cG9OdW1TdHJpbmcpXG4gICAgICA6IG51bWJlclN0cmluZztcbiAgfVxuICBnZXQgZ3JvdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyb3VwO1xuICB9XG4gIGdldCBkZWNpbWFsKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNpbWFsO1xuICB9XG4gIGdldCBtaW51c1NpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnVzU2lnbjtcbiAgfVxuICBnZXQgZGlnaXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9kaWdpdHM7XG4gIH1cbiAgZ2V0IG51bWJlckZvcm1hdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyRm9ybWF0dGVyO1xuICB9XG4gIGdldCBudW1iZXJGb3JtYXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBudW1iZXJGb3JtYXRPcHRpb25zIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgbG9jYWxpemUvZGVsb2NhbGl6ZSBpcyBjYWxsZWQgdG8gZW5zdXJlIHRoZSBvcHRpb25zIGFyZSB1cCB0byBkYXRlXG4gICAqL1xuICBzZXQgbnVtYmVyRm9ybWF0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5sb2NhbGUgPSBnZXRTdXBwb3J0ZWRMb2NhbGUob3B0aW9ucz8ubG9jYWxlKTtcbiAgICBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSA9IGdldFN1cHBvcnRlZE51bWJlcmluZ1N5c3RlbShvcHRpb25zPy5udW1iZXJpbmdTeXN0ZW0pO1xuICAgIGlmIChcbiAgICAvLyBObyBuZWVkIHRvIGNyZWF0ZSB0aGUgZm9ybWF0dGVyIGlmIGBsb2NhbGVgIGFuZCBgbnVtYmVyaW5nU3lzdGVtYFxuICAgIC8vIGFyZSB0aGUgZGVmYXVsdCB2YWx1ZXMgYW5kIGBudW1iZXJGb3JtYXRPcHRpb25zYCBoYXMgbm90IGJlZW4gc2V0XG4gICAgKCF0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zICYmXG4gICAgICBvcHRpb25zLmxvY2FsZSA9PT0gZGVmYXVsdExvY2FsZSAmJlxuICAgICAgb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gPT09IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIC8vIGRvbid0IHNraXAgaW5pdGlhbGl6YXRpb24gaWYgYW55IG9wdGlvbnMgYmVzaWRlcyBsb2NhbGUvbnVtYmVyaW5nU3lzdGVtIGFyZSBzZXRcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMikgfHxcbiAgICAgIC8vIGNhY2hlIGZvcm1hdHRlciBieSBvbmx5IHJlY3JlYXRpbmcgd2hlbiBvcHRpb25zIGNoYW5nZVxuICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucykgPT09IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX251bWJlckZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLmxvY2FsZSwgdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucyk7XG4gICAgdGhpcy5fZGlnaXRzID0gW1xuICAgICAgLi4ubmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMubG9jYWxlLCB7XG4gICAgICAgIHVzZUdyb3VwaW5nOiBmYWxzZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLm51bWJlcmluZ1N5c3RlbVxuICAgICAgfSkuZm9ybWF0KDk4NzY1NDMyMTApXG4gICAgXS5yZXZlcnNlKCk7XG4gICAgY29uc3QgaW5kZXggPSBuZXcgTWFwKHRoaXMuX2RpZ2l0cy5tYXAoKGQsIGkpID0+IFtkLCBpXSkpO1xuICAgIGNvbnN0IHBhcnRzID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMubG9jYWxlKS5mb3JtYXRUb1BhcnRzKC0xMjM0NTY3OC45KTtcbiAgICB0aGlzLl9hY3R1YWxHcm91cCA9IHBhcnRzLmZpbmQoKGQpID0+IGQudHlwZSA9PT0gXCJncm91cFwiKS52YWx1ZTtcbiAgICAvLyBjaGFuZ2Ugd2hpdGVzcGFjZSBncm91cCBjaGFyYWN0ZXJzIHRoYXQgZG9uJ3QgcmVuZGVyIGNvcnJlY3RseVxuICAgIHRoaXMuX2dyb3VwID0gdGhpcy5fYWN0dWFsR3JvdXAudHJpbSgpLmxlbmd0aCA9PT0gMCA/IFwiIFwiIDogdGhpcy5fYWN0dWFsR3JvdXA7XG4gICAgdGhpcy5fZGVjaW1hbCA9IHBhcnRzLmZpbmQoKGQpID0+IGQudHlwZSA9PT0gXCJkZWNpbWFsXCIpLnZhbHVlO1xuICAgIHRoaXMuX21pbnVzU2lnbiA9IHBhcnRzLmZpbmQoKGQpID0+IGQudHlwZSA9PT0gXCJtaW51c1NpZ25cIikudmFsdWU7XG4gICAgdGhpcy5fZ2V0RGlnaXRJbmRleCA9IChkKSA9PiBpbmRleC5nZXQoZCk7XG4gIH1cbn1cbmNvbnN0IG51bWJlclN0cmluZ0Zvcm1hdHRlciA9IG5ldyBOdW1iZXJTdHJpbmdGb3JtYXQoKTtcblxuZXhwb3J0IHsgZ2V0U3VwcG9ydGVkTnVtYmVyaW5nU3lzdGVtIGFzIGEsIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gYXMgYiwgY29ubmVjdExvY2FsaXplZCBhcyBjLCBkaXNjb25uZWN0TG9jYWxpemVkIGFzIGQsIGdldFN1cHBvcnRlZExvY2FsZSBhcyBnLCBpc1ZhbGlkTnVtYmVyIGFzIGksIG51bWJlclN0cmluZ0Zvcm1hdHRlciBhcyBuLCBwYXJzZU51bWJlclN0cmluZyBhcyBwLCBzYW5pdGl6ZU51bWJlclN0cmluZyBhcyBzIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZS1mN2IyZmJiMC5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZW5zdXJlcyBvYnNlcnZlcnMgYXJlIGNyZWF0ZWQgb25seSBmb3IgYnJvd3NlciBjb250ZXh0cy5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIG9ic2VydmVyIHRvIGNyZWF0ZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvYnNlcnZlciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGNvbnN0IE9ic2VydmVyID0gZ2V0T2JzZXJ2ZXIodHlwZSk7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIoY2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXIodHlwZSkge1xuICAvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2RvbS9pc3N1ZXMvMTI2I2lzc3VlY29tbWVudC0xMDQ5ODE0OTQ4XG4gIGNsYXNzIEV4dGVuZGVkTXV0YXRpb25PYnNlcnZlciBleHRlbmRzIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgc3VwZXIoY2FsbGJhY2spO1xuICAgICAgdGhpcy5vYnNlcnZlZEVudHJ5ID0gW107XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9ic2VydmUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9ic2VydmVkRW50cnkucHVzaCh7IHRhcmdldCwgb3B0aW9ucyB9KTtcbiAgICAgIHJldHVybiBzdXBlci5vYnNlcnZlKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHVub2JzZXJ2ZSh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IG5ld09ic2VydmVkRW50cmllcyA9IHRoaXMub2JzZXJ2ZWRFbnRyeS5maWx0ZXIoKG9ic2VydmVkKSA9PiBvYnNlcnZlZC50YXJnZXQgIT09IHRhcmdldCk7XG4gICAgICB0aGlzLm9ic2VydmVkRW50cnkgPSBbXTtcbiAgICAgIHRoaXMuY2FsbGJhY2soc3VwZXIudGFrZVJlY29yZHMoKSwgdGhpcyk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG5ld09ic2VydmVkRW50cmllcy5mb3JFYWNoKChvYnNlcnZlZCkgPT4gdGhpcy5vYnNlcnZlKG9ic2VydmVkLnRhcmdldCwgb2JzZXJ2ZWQub3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHR5cGUgPT09IFwiaW50ZXJzZWN0aW9uXCJcbiAgICAgID8gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgICA6IHR5cGUgPT09IFwibXV0YXRpb25cIlxuICAgICAgICA/IEV4dGVuZGVkTXV0YXRpb25PYnNlcnZlclxuICAgICAgICA6IHdpbmRvdy5SZXNpemVPYnNlcnZlcik7XG4gIH0pKCk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU9ic2VydmVyIGFzIGMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXJzLTU2NzQwZTk5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==