"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_esri_calcite-components-react_node_modules_esri_calcite-components_dist_-5abfb9"],{

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/color-picker-hex-input.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/color-picker-hex-input.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS$1),
/* harmony export */   D: () => (/* binding */ DEFAULT_COLOR$1),
/* harmony export */   H: () => (/* binding */ HSV_LIMITS),
/* harmony export */   O: () => (/* binding */ OPACITY_LIMITS),
/* harmony export */   R: () => (/* binding */ RGB_LIMITS),
/* harmony export */   S: () => (/* binding */ SCOPE_SIZE),
/* harmony export */   a: () => (/* binding */ DIMENSIONS),
/* harmony export */   b: () => (/* binding */ HUE_LIMIT_CONSTRAINED),
/* harmony export */   c: () => (/* binding */ DEFAULT_STORAGE_KEY_PREFIX),
/* harmony export */   d: () => (/* binding */ defineCustomElement),
/* harmony export */   e: () => (/* binding */ ColorPickerHexInput)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/utils.js");
/* harmony import */ var _index2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index2.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/index2.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/dom.js");
/* harmony import */ var _loadable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadable.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/loadable.js");
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./icon.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/icon.js");
/* harmony import */ var _input_number_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./input-number.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/input-number.js");
/* harmony import */ var _input_text_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./input-text.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/input-text.js");
/* harmony import */ var _progress_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./progress.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/progress.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */










const CSS$1 = {
  channel: "channel",
  channels: "channels",
  colorField: "color-field",
  colorFieldScope: "scope--color-field",
  colorMode: "color-mode",
  colorModeContainer: "color-mode-container",
  container: "container",
  control: "control",
  controlAndScope: "control-and-scope",
  controlSection: "control-section",
  deleteColor: "delete-color",
  header: "header",
  hexAndChannelsGroup: "hex-and-channels-group",
  hexOptions: "color-hex-options",
  hueScope: "scope--hue",
  hueSlider: "hue-slider",
  opacityScope: "scope--opacity",
  opacitySlider: "opacity-slider",
  preview: "preview",
  previewAndSliders: "preview-and-sliders",
  saveColor: "save-color",
  savedColor: "saved-color",
  savedColors: "saved-colors",
  savedColorsButtons: "saved-colors-buttons",
  savedColorsSection: "saved-colors-section",
  scope: "scope",
  section: "section",
  slider: "slider",
  sliders: "sliders",
  splitSection: "section--split",
};
const DEFAULT_COLOR$1 = (0,_index2_js__WEBPACK_IMPORTED_MODULE_1__.c)("#007AC2");
const DEFAULT_STORAGE_KEY_PREFIX = "calcite-color-";
const RGB_LIMITS = {
  r: 255,
  g: 255,
  b: 255,
};
const HSV_LIMITS = {
  h: 360,
  s: 100,
  v: 100,
};
// 0 and 360 represent the same value, so we limit the hue to 359
const HUE_LIMIT_CONSTRAINED = HSV_LIMITS.h - 1;
const OPACITY_LIMITS = {
  min: 0,
  max: 100,
};
const DIMENSIONS = {
  s: {
    slider: {
      height: 12,
      width: 104,
    },
    colorField: {
      height: 80,
      width: 160,
    },
    thumb: {
      radius: 10,
    },
  },
  m: {
    slider: {
      height: 12,
      width: 204,
    },
    colorField: {
      height: 150,
      width: 272,
    },
    thumb: {
      radius: 10,
    },
  },
  l: {
    slider: {
      height: 12,
      width: 384,
    },
    colorField: {
      height: 200,
      width: 464,
    },
    thumb: {
      radius: 10,
    },
  },
};
const SCOPE_SIZE = 1;

const CSS = {
  container: "container",
  hexInput: "hex-input",
  opacityInput: "opacity-input",
};

const colorPickerHexInputCss = ":host{display:block}.container{display:flex;inline-size:100%;flex-wrap:nowrap;align-items:center}.hex-input{flex-grow:1;text-transform:uppercase}.opacity-input{inline-size:68px;margin-inline-start:-1px}:host([scale=s]) .container{flex-wrap:wrap;row-gap:0.125rem}:host([scale=s]) .opacity-input{inline-size:unset;margin-inline-start:unset}:host([scale=l]) .opacity-input{inline-size:88px}:host([hidden]){display:none}[hidden]{display:none}";

const DEFAULT_COLOR = (0,_index2_js__WEBPACK_IMPORTED_MODULE_1__.c)();
const ColorPickerHexInput = /*@__PURE__*/ (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_8__.proxyCustomElement)(class extends _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_8__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteColorPickerHexInputChange = (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_8__.createEvent)(this, "calciteColorPickerHexInputChange", 6);
    this.onHexInputBlur = () => {
      const node = this.hexInputNode;
      const inputValue = node.value;
      const hex = `#${inputValue}`;
      const { allowEmpty, internalColor } = this;
      const willClearValue = allowEmpty && !inputValue;
      const isLonghand = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.j)(hex);
      // ensure modified pasted hex values are committed since we prevent default to remove the # char.
      this.onHexInputChange();
      if (willClearValue || ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.i)(hex) && isLonghand)) {
        return;
      }
      // manipulating DOM directly since rerender doesn't update input value
      node.value =
        allowEmpty && !internalColor
          ? ""
          : this.formatHexForInternalInput((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.r)(
          // always display hex input in RRGGBB format
          internalColor.object()));
    };
    this.onOpacityInputBlur = () => {
      const node = this.opacityInputNode;
      const inputValue = node.value;
      const { allowEmpty, internalColor } = this;
      const willClearValue = allowEmpty && !inputValue;
      if (willClearValue) {
        return;
      }
      // manipulating DOM directly since rerender doesn't update input value
      node.value =
        allowEmpty && !internalColor ? "" : this.formatOpacityForInternalInput(internalColor);
    };
    this.onHexInputChange = () => {
      const nodeValue = this.hexInputNode.value;
      let value = nodeValue;
      if (value) {
        const normalized = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.n)(value, false);
        const preserveExistingAlpha = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.i)(normalized) && this.alphaChannel;
        if (preserveExistingAlpha && this.internalColor) {
          const alphaHex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.n)(this.internalColor.hexa(), true).slice(-2);
          value = `${normalized + alphaHex}`;
        }
      }
      this.internalSetValue(value, this.value);
    };
    this.onOpacityInputChange = () => {
      const node = this.opacityInputNode;
      let value;
      if (!node.value) {
        value = node.value;
      }
      else {
        const alpha = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.o)(Number(node.value));
        value = this.internalColor?.alpha(alpha).hexa();
      }
      this.internalSetValue(value, this.value);
    };
    this.onInputKeyDown = (event) => {
      const { altKey, ctrlKey, metaKey, shiftKey } = event;
      const { alphaChannel, hexInputNode, internalColor, value } = this;
      const { key } = event;
      const composedPath = event.composedPath();
      if (key === "Tab" || key === "Enter") {
        if (composedPath.includes(hexInputNode)) {
          this.onHexInputChange();
        }
        else {
          this.onOpacityInputChange();
        }
        if (key === "Enter") {
          event.preventDefault();
        }
        return;
      }
      const isNudgeKey = key === "ArrowDown" || key === "ArrowUp";
      const oldValue = this.value;
      if (isNudgeKey) {
        if (!value) {
          this.internalSetValue(this.previousNonNullValue, oldValue);
          event.preventDefault();
          return;
        }
        const direction = key === "ArrowUp" ? 1 : -1;
        const bump = shiftKey ? 10 : 1;
        this.internalSetValue((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.nudgeRGBChannels(internalColor, bump * direction, composedPath.includes(hexInputNode) ? "rgb" : "a"), alphaChannel), oldValue);
        event.preventDefault();
        return;
      }
      const withModifiers = altKey || ctrlKey || metaKey;
      const singleChar = key.length === 1;
      const validHexChar = _utils_js__WEBPACK_IMPORTED_MODULE_0__.k.test(key);
      if (singleChar && !withModifiers && !validHexChar) {
        event.preventDefault();
      }
    };
    this.onHexInputPaste = (event) => {
      const hex = event.clipboardData.getData("text");
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.i)(hex)) {
        event.preventDefault();
        this.hexInputNode.value = hex.slice(1);
      }
    };
    this.previousNonNullValue = this.value;
    this.storeHexInputRef = (node) => {
      this.hexInputNode = node;
    };
    this.storeOpacityInputRef = (node) => {
      this.opacityInputNode = node;
    };
    this.allowEmpty = false;
    this.alphaChannel = false;
    this.hexLabel = "Hex";
    this.messages = undefined;
    this.numberingSystem = undefined;
    this.scale = "m";
    this.value = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.n)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.h)(DEFAULT_COLOR, this.alphaChannel), this.alphaChannel, true);
    this.internalColor = DEFAULT_COLOR;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    const { allowEmpty, alphaChannel, value } = this;
    if (value) {
      const normalized = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.n)(value, alphaChannel);
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.i)(normalized, alphaChannel)) {
        this.internalSetValue(normalized, normalized, false);
      }
      return;
    }
    if (allowEmpty) {
      this.internalSetValue(null, null, false);
    }
  }
  componentWillLoad() {
    (0,_loadable_js__WEBPACK_IMPORTED_MODULE_3__.a)(this);
  }
  componentDidLoad() {
    (0,_loadable_js__WEBPACK_IMPORTED_MODULE_3__.s)(this);
  }
  handleValueChange(value, oldValue) {
    this.internalSetValue(value, oldValue, false);
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    const { alphaChannel, hexLabel, internalColor, messages, scale, value } = this;
    const hexInputValue = this.formatHexForInternalInput(value);
    const opacityInputValue = this.formatOpacityForInternalInput(internalColor);
    const inputScale = scale === "l" ? "m" : "s";
    return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_8__.h)("div", { class: CSS.container }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_8__.h)("calcite-input-text", { class: CSS.hexInput, label: messages?.hex || hexLabel, maxLength: 6, onCalciteInputTextChange: this.onHexInputChange, onCalciteInternalInputTextBlur: this.onHexInputBlur, onKeyDown: this.onInputKeyDown, onPaste: this.onHexInputPaste, prefixText: "#", scale: inputScale, value: hexInputValue,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.storeHexInputRef }), alphaChannel ? ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_8__.h)("calcite-input-number", { class: CSS.opacityInput, key: "opacity-input", label: messages?.opacity, max: OPACITY_LIMITS.max, maxLength: 3, min: OPACITY_LIMITS.min, numberButtonType: "none", numberingSystem: this.numberingSystem, onCalciteInputNumberChange: this.onOpacityInputChange, onCalciteInternalInputNumberBlur: this.onOpacityInputBlur, onKeyDown: this.onInputKeyDown, scale: inputScale, suffixText: "%", value: opacityInputValue,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: this.storeOpacityInputRef })) : null));
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /** Sets focus on the component. */
  async setFocus() {
    await (0,_loadable_js__WEBPACK_IMPORTED_MODULE_3__.c)(this);
    return (0,_dom_js__WEBPACK_IMPORTED_MODULE_2__.k)(this.hexInputNode);
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  internalSetValue(value, oldValue, emit = true) {
    if (value) {
      const { alphaChannel } = this;
      const normalized = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.n)(value, alphaChannel, alphaChannel);
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.i)(normalized, alphaChannel)) {
        const { internalColor: currentColor } = this;
        const nextColor = (0,_index2_js__WEBPACK_IMPORTED_MODULE_1__.c)(normalized);
        const normalizedLonghand = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.n)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.h)(nextColor, alphaChannel), alphaChannel);
        const changed = !currentColor ||
          normalizedLonghand !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.n)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.h)(currentColor, alphaChannel), alphaChannel);
        this.internalColor = nextColor;
        this.previousNonNullValue = normalizedLonghand;
        this.value = normalizedLonghand;
        if (changed && emit) {
          this.calciteColorPickerHexInputChange.emit();
        }
        return;
      }
    }
    else if (this.allowEmpty) {
      this.internalColor = null;
      this.value = null;
      if (emit) {
        this.calciteColorPickerHexInputChange.emit();
      }
      return;
    }
    this.value = oldValue;
  }
  formatHexForInternalInput(hex) {
    return hex ? hex.replace("#", "").slice(0, 6) : "";
  }
  formatOpacityForInternalInput(color) {
    return color ? `${(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.b)(color.alpha())}` : "";
  }
  nudgeRGBChannels(color$1, amount, context) {
    let nudgedChannels;
    const channels = color$1.array();
    const rgbChannels = channels.slice(0, 3);
    if (context === "rgb") {
      const nudgedRGBChannels = rgbChannels.map((channel) => channel + amount);
      nudgedChannels = [
        ...nudgedRGBChannels,
        this.alphaChannel ? channels[3] : undefined,
      ];
    }
    else {
      const nudgedAlpha = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.o)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.b)(color$1.alpha()) + amount);
      nudgedChannels = [...rgbChannels, nudgedAlpha];
    }
    return (0,_index2_js__WEBPACK_IMPORTED_MODULE_1__.c)(nudgedChannels);
  }
  get el() { return this; }
  static get watchers() { return {
    "value": ["handleValueChange"]
  }; }
  static get style() { return colorPickerHexInputCss; }
}, [1, "calcite-color-picker-hex-input", {
    "allowEmpty": [4, "allow-empty"],
    "alphaChannel": [4, "alpha-channel"],
    "hexLabel": [1, "hex-label"],
    "messages": [16],
    "numberingSystem": [1, "numbering-system"],
    "scale": [513],
    "value": [1537],
    "internalColor": [32],
    "setFocus": [64]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-color-picker-hex-input", "calcite-icon", "calcite-input-number", "calcite-input-text", "calcite-progress"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-color-picker-hex-input":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, ColorPickerHexInput);
      }
      break;
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        (0,_icon_js__WEBPACK_IMPORTED_MODULE_4__.d)();
      }
      break;
    case "calcite-input-number":
      if (!customElements.get(tagName)) {
        (0,_input_number_js__WEBPACK_IMPORTED_MODULE_5__.d)();
      }
      break;
    case "calcite-input-text":
      if (!customElements.get(tagName)) {
        (0,_input_text_js__WEBPACK_IMPORTED_MODULE_6__.d)();
      }
      break;
    case "calcite-progress":
      if (!customElements.get(tagName)) {
        (0,_progress_js__WEBPACK_IMPORTED_MODULE_7__.d)();
      }
      break;
  } });
}
defineCustomElement();




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHMtcmVhY3Rfbm9kZV9tb2R1bGVzX2VzcmlfY2FsY2l0ZS1jb21wb25lbnRzX2Rpc3RfLTVhYmZiOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUc7QUFDK0Q7QUFDL0g7QUFDSTtBQUNpRTtBQUN2RDtBQUNRO0FBQ0Y7QUFDRjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLGNBQWMsV0FBVyxhQUFhLGlCQUFpQixpQkFBaUIsbUJBQW1CLFdBQVcsWUFBWSx5QkFBeUIsZUFBZSxpQkFBaUIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUFjLENBQUMsNENBQWM7QUFDdkQ7QUFDQTtBQUNBLFdBQVcsNkNBQUs7QUFDaEI7QUFDQSxhQUFhO0FBQ2IsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBcUI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVzUCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2NvbG9yLXBpY2tlci1oZXgtaW5wdXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL21haW4vTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjExLjBcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgY3JlYXRlRXZlbnQsIGggfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyc7XG5pbXBvcnQgeyBqIGFzIGlzTG9uZ2hhbmRIZXgsIGkgYXMgaXNWYWxpZEhleCwgciBhcyByZ2JUb0hleCwgbiBhcyBub3JtYWxpemVIZXgsIG8gYXMgb3BhY2l0eVRvQWxwaGEsIGggYXMgaGV4aWZ5LCBrIGFzIGhleENoYXIsIGIgYXMgYWxwaGFUb09wYWNpdHkgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGMgYXMgY29sb3IgfSBmcm9tICcuL2luZGV4Mi5qcyc7XG5pbXBvcnQgeyBrIGFzIGZvY3VzRWxlbWVudCB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGEgYXMgc2V0VXBMb2FkYWJsZUNvbXBvbmVudCwgcyBhcyBzZXRDb21wb25lbnRMb2FkZWQsIGMgYXMgY29tcG9uZW50Rm9jdXNhYmxlIH0gZnJvbSAnLi9sb2FkYWJsZS5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkNCB9IGZyb20gJy4vaWNvbi5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMyB9IGZyb20gJy4vaW5wdXQtbnVtYmVyLmpzJztcbmltcG9ydCB7IGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQyIH0gZnJvbSAnLi9pbnB1dC10ZXh0LmpzJztcbmltcG9ydCB7IGQgYXMgZGVmaW5lQ3VzdG9tRWxlbWVudCQxIH0gZnJvbSAnLi9wcm9ncmVzcy5qcyc7XG5cbmNvbnN0IENTUyQxID0ge1xuICBjaGFubmVsOiBcImNoYW5uZWxcIixcbiAgY2hhbm5lbHM6IFwiY2hhbm5lbHNcIixcbiAgY29sb3JGaWVsZDogXCJjb2xvci1maWVsZFwiLFxuICBjb2xvckZpZWxkU2NvcGU6IFwic2NvcGUtLWNvbG9yLWZpZWxkXCIsXG4gIGNvbG9yTW9kZTogXCJjb2xvci1tb2RlXCIsXG4gIGNvbG9yTW9kZUNvbnRhaW5lcjogXCJjb2xvci1tb2RlLWNvbnRhaW5lclwiLFxuICBjb250YWluZXI6IFwiY29udGFpbmVyXCIsXG4gIGNvbnRyb2w6IFwiY29udHJvbFwiLFxuICBjb250cm9sQW5kU2NvcGU6IFwiY29udHJvbC1hbmQtc2NvcGVcIixcbiAgY29udHJvbFNlY3Rpb246IFwiY29udHJvbC1zZWN0aW9uXCIsXG4gIGRlbGV0ZUNvbG9yOiBcImRlbGV0ZS1jb2xvclwiLFxuICBoZWFkZXI6IFwiaGVhZGVyXCIsXG4gIGhleEFuZENoYW5uZWxzR3JvdXA6IFwiaGV4LWFuZC1jaGFubmVscy1ncm91cFwiLFxuICBoZXhPcHRpb25zOiBcImNvbG9yLWhleC1vcHRpb25zXCIsXG4gIGh1ZVNjb3BlOiBcInNjb3BlLS1odWVcIixcbiAgaHVlU2xpZGVyOiBcImh1ZS1zbGlkZXJcIixcbiAgb3BhY2l0eVNjb3BlOiBcInNjb3BlLS1vcGFjaXR5XCIsXG4gIG9wYWNpdHlTbGlkZXI6IFwib3BhY2l0eS1zbGlkZXJcIixcbiAgcHJldmlldzogXCJwcmV2aWV3XCIsXG4gIHByZXZpZXdBbmRTbGlkZXJzOiBcInByZXZpZXctYW5kLXNsaWRlcnNcIixcbiAgc2F2ZUNvbG9yOiBcInNhdmUtY29sb3JcIixcbiAgc2F2ZWRDb2xvcjogXCJzYXZlZC1jb2xvclwiLFxuICBzYXZlZENvbG9yczogXCJzYXZlZC1jb2xvcnNcIixcbiAgc2F2ZWRDb2xvcnNCdXR0b25zOiBcInNhdmVkLWNvbG9ycy1idXR0b25zXCIsXG4gIHNhdmVkQ29sb3JzU2VjdGlvbjogXCJzYXZlZC1jb2xvcnMtc2VjdGlvblwiLFxuICBzY29wZTogXCJzY29wZVwiLFxuICBzZWN0aW9uOiBcInNlY3Rpb25cIixcbiAgc2xpZGVyOiBcInNsaWRlclwiLFxuICBzbGlkZXJzOiBcInNsaWRlcnNcIixcbiAgc3BsaXRTZWN0aW9uOiBcInNlY3Rpb24tLXNwbGl0XCIsXG59O1xuY29uc3QgREVGQVVMVF9DT0xPUiQxID0gY29sb3IoXCIjMDA3QUMyXCIpO1xuY29uc3QgREVGQVVMVF9TVE9SQUdFX0tFWV9QUkVGSVggPSBcImNhbGNpdGUtY29sb3ItXCI7XG5jb25zdCBSR0JfTElNSVRTID0ge1xuICByOiAyNTUsXG4gIGc6IDI1NSxcbiAgYjogMjU1LFxufTtcbmNvbnN0IEhTVl9MSU1JVFMgPSB7XG4gIGg6IDM2MCxcbiAgczogMTAwLFxuICB2OiAxMDAsXG59O1xuLy8gMCBhbmQgMzYwIHJlcHJlc2VudCB0aGUgc2FtZSB2YWx1ZSwgc28gd2UgbGltaXQgdGhlIGh1ZSB0byAzNTlcbmNvbnN0IEhVRV9MSU1JVF9DT05TVFJBSU5FRCA9IEhTVl9MSU1JVFMuaCAtIDE7XG5jb25zdCBPUEFDSVRZX0xJTUlUUyA9IHtcbiAgbWluOiAwLFxuICBtYXg6IDEwMCxcbn07XG5jb25zdCBESU1FTlNJT05TID0ge1xuICBzOiB7XG4gICAgc2xpZGVyOiB7XG4gICAgICBoZWlnaHQ6IDEyLFxuICAgICAgd2lkdGg6IDEwNCxcbiAgICB9LFxuICAgIGNvbG9yRmllbGQ6IHtcbiAgICAgIGhlaWdodDogODAsXG4gICAgICB3aWR0aDogMTYwLFxuICAgIH0sXG4gICAgdGh1bWI6IHtcbiAgICAgIHJhZGl1czogMTAsXG4gICAgfSxcbiAgfSxcbiAgbToge1xuICAgIHNsaWRlcjoge1xuICAgICAgaGVpZ2h0OiAxMixcbiAgICAgIHdpZHRoOiAyMDQsXG4gICAgfSxcbiAgICBjb2xvckZpZWxkOiB7XG4gICAgICBoZWlnaHQ6IDE1MCxcbiAgICAgIHdpZHRoOiAyNzIsXG4gICAgfSxcbiAgICB0aHVtYjoge1xuICAgICAgcmFkaXVzOiAxMCxcbiAgICB9LFxuICB9LFxuICBsOiB7XG4gICAgc2xpZGVyOiB7XG4gICAgICBoZWlnaHQ6IDEyLFxuICAgICAgd2lkdGg6IDM4NCxcbiAgICB9LFxuICAgIGNvbG9yRmllbGQ6IHtcbiAgICAgIGhlaWdodDogMjAwLFxuICAgICAgd2lkdGg6IDQ2NCxcbiAgICB9LFxuICAgIHRodW1iOiB7XG4gICAgICByYWRpdXM6IDEwLFxuICAgIH0sXG4gIH0sXG59O1xuY29uc3QgU0NPUEVfU0laRSA9IDE7XG5cbmNvbnN0IENTUyA9IHtcbiAgY29udGFpbmVyOiBcImNvbnRhaW5lclwiLFxuICBoZXhJbnB1dDogXCJoZXgtaW5wdXRcIixcbiAgb3BhY2l0eUlucHV0OiBcIm9wYWNpdHktaW5wdXRcIixcbn07XG5cbmNvbnN0IGNvbG9yUGlja2VySGV4SW5wdXRDc3MgPSBcIjpob3N0e2Rpc3BsYXk6YmxvY2t9LmNvbnRhaW5lcntkaXNwbGF5OmZsZXg7aW5saW5lLXNpemU6MTAwJTtmbGV4LXdyYXA6bm93cmFwO2FsaWduLWl0ZW1zOmNlbnRlcn0uaGV4LWlucHV0e2ZsZXgtZ3JvdzoxO3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZX0ub3BhY2l0eS1pbnB1dHtpbmxpbmUtc2l6ZTo2OHB4O21hcmdpbi1pbmxpbmUtc3RhcnQ6LTFweH06aG9zdChbc2NhbGU9c10pIC5jb250YWluZXJ7ZmxleC13cmFwOndyYXA7cm93LWdhcDowLjEyNXJlbX06aG9zdChbc2NhbGU9c10pIC5vcGFjaXR5LWlucHV0e2lubGluZS1zaXplOnVuc2V0O21hcmdpbi1pbmxpbmUtc3RhcnQ6dW5zZXR9Omhvc3QoW3NjYWxlPWxdKSAub3BhY2l0eS1pbnB1dHtpbmxpbmUtc2l6ZTo4OHB4fTpob3N0KFtoaWRkZW5dKXtkaXNwbGF5Om5vbmV9W2hpZGRlbl17ZGlzcGxheTpub25lfVwiO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gY29sb3IoKTtcbmNvbnN0IENvbG9yUGlja2VySGV4SW5wdXQgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VySGV4SW5wdXRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVDb2xvclBpY2tlckhleElucHV0Q2hhbmdlXCIsIDYpO1xuICAgIHRoaXMub25IZXhJbnB1dEJsdXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5oZXhJbnB1dE5vZGU7XG4gICAgICBjb25zdCBpbnB1dFZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIGNvbnN0IGhleCA9IGAjJHtpbnB1dFZhbHVlfWA7XG4gICAgICBjb25zdCB7IGFsbG93RW1wdHksIGludGVybmFsQ29sb3IgfSA9IHRoaXM7XG4gICAgICBjb25zdCB3aWxsQ2xlYXJWYWx1ZSA9IGFsbG93RW1wdHkgJiYgIWlucHV0VmFsdWU7XG4gICAgICBjb25zdCBpc0xvbmdoYW5kID0gaXNMb25naGFuZEhleChoZXgpO1xuICAgICAgLy8gZW5zdXJlIG1vZGlmaWVkIHBhc3RlZCBoZXggdmFsdWVzIGFyZSBjb21taXR0ZWQgc2luY2Ugd2UgcHJldmVudCBkZWZhdWx0IHRvIHJlbW92ZSB0aGUgIyBjaGFyLlxuICAgICAgdGhpcy5vbkhleElucHV0Q2hhbmdlKCk7XG4gICAgICBpZiAod2lsbENsZWFyVmFsdWUgfHwgKGlzVmFsaWRIZXgoaGV4KSAmJiBpc0xvbmdoYW5kKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBtYW5pcHVsYXRpbmcgRE9NIGRpcmVjdGx5IHNpbmNlIHJlcmVuZGVyIGRvZXNuJ3QgdXBkYXRlIGlucHV0IHZhbHVlXG4gICAgICBub2RlLnZhbHVlID1cbiAgICAgICAgYWxsb3dFbXB0eSAmJiAhaW50ZXJuYWxDb2xvclxuICAgICAgICAgID8gXCJcIlxuICAgICAgICAgIDogdGhpcy5mb3JtYXRIZXhGb3JJbnRlcm5hbElucHV0KHJnYlRvSGV4KFxuICAgICAgICAgIC8vIGFsd2F5cyBkaXNwbGF5IGhleCBpbnB1dCBpbiBSUkdHQkIgZm9ybWF0XG4gICAgICAgICAgaW50ZXJuYWxDb2xvci5vYmplY3QoKSkpO1xuICAgIH07XG4gICAgdGhpcy5vbk9wYWNpdHlJbnB1dEJsdXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5vcGFjaXR5SW5wdXROb2RlO1xuICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBjb25zdCB7IGFsbG93RW1wdHksIGludGVybmFsQ29sb3IgfSA9IHRoaXM7XG4gICAgICBjb25zdCB3aWxsQ2xlYXJWYWx1ZSA9IGFsbG93RW1wdHkgJiYgIWlucHV0VmFsdWU7XG4gICAgICBpZiAod2lsbENsZWFyVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gbWFuaXB1bGF0aW5nIERPTSBkaXJlY3RseSBzaW5jZSByZXJlbmRlciBkb2Vzbid0IHVwZGF0ZSBpbnB1dCB2YWx1ZVxuICAgICAgbm9kZS52YWx1ZSA9XG4gICAgICAgIGFsbG93RW1wdHkgJiYgIWludGVybmFsQ29sb3IgPyBcIlwiIDogdGhpcy5mb3JtYXRPcGFjaXR5Rm9ySW50ZXJuYWxJbnB1dChpbnRlcm5hbENvbG9yKTtcbiAgICB9O1xuICAgIHRoaXMub25IZXhJbnB1dENoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRoaXMuaGV4SW5wdXROb2RlLnZhbHVlO1xuICAgICAgbGV0IHZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVIZXgodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcHJlc2VydmVFeGlzdGluZ0FscGhhID0gaXNWYWxpZEhleChub3JtYWxpemVkKSAmJiB0aGlzLmFscGhhQ2hhbm5lbDtcbiAgICAgICAgaWYgKHByZXNlcnZlRXhpc3RpbmdBbHBoYSAmJiB0aGlzLmludGVybmFsQ29sb3IpIHtcbiAgICAgICAgICBjb25zdCBhbHBoYUhleCA9IG5vcm1hbGl6ZUhleCh0aGlzLmludGVybmFsQ29sb3IuaGV4YSgpLCB0cnVlKS5zbGljZSgtMik7XG4gICAgICAgICAgdmFsdWUgPSBgJHtub3JtYWxpemVkICsgYWxwaGFIZXh9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5pbnRlcm5hbFNldFZhbHVlKHZhbHVlLCB0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMub25PcGFjaXR5SW5wdXRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5vcGFjaXR5SW5wdXROb2RlO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgaWYgKCFub2RlLnZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhbHBoYSA9IG9wYWNpdHlUb0FscGhhKE51bWJlcihub2RlLnZhbHVlKSk7XG4gICAgICAgIHZhbHVlID0gdGhpcy5pbnRlcm5hbENvbG9yPy5hbHBoYShhbHBoYSkuaGV4YSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnRlcm5hbFNldFZhbHVlKHZhbHVlLCB0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMub25JbnB1dEtleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgYWx0S2V5LCBjdHJsS2V5LCBtZXRhS2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCB7IGFscGhhQ2hhbm5lbCwgaGV4SW5wdXROb2RlLCBpbnRlcm5hbENvbG9yLCB2YWx1ZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHsga2V5IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgaWYgKGtleSA9PT0gXCJUYWJcIiB8fCBrZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICBpZiAoY29tcG9zZWRQYXRoLmluY2x1ZGVzKGhleElucHV0Tm9kZSkpIHtcbiAgICAgICAgICB0aGlzLm9uSGV4SW5wdXRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uT3BhY2l0eUlucHV0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc051ZGdlS2V5ID0ga2V5ID09PSBcIkFycm93RG93blwiIHx8IGtleSA9PT0gXCJBcnJvd1VwXCI7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBpZiAoaXNOdWRnZUtleSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbFNldFZhbHVlKHRoaXMucHJldmlvdXNOb25OdWxsVmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBrZXkgPT09IFwiQXJyb3dVcFwiID8gMSA6IC0xO1xuICAgICAgICBjb25zdCBidW1wID0gc2hpZnRLZXkgPyAxMCA6IDE7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTZXRWYWx1ZShoZXhpZnkodGhpcy5udWRnZVJHQkNoYW5uZWxzKGludGVybmFsQ29sb3IsIGJ1bXAgKiBkaXJlY3Rpb24sIGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhoZXhJbnB1dE5vZGUpID8gXCJyZ2JcIiA6IFwiYVwiKSwgYWxwaGFDaGFubmVsKSwgb2xkVmFsdWUpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB3aXRoTW9kaWZpZXJzID0gYWx0S2V5IHx8IGN0cmxLZXkgfHwgbWV0YUtleTtcbiAgICAgIGNvbnN0IHNpbmdsZUNoYXIgPSBrZXkubGVuZ3RoID09PSAxO1xuICAgICAgY29uc3QgdmFsaWRIZXhDaGFyID0gaGV4Q2hhci50ZXN0KGtleSk7XG4gICAgICBpZiAoc2luZ2xlQ2hhciAmJiAhd2l0aE1vZGlmaWVycyAmJiAhdmFsaWRIZXhDaGFyKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uSGV4SW5wdXRQYXN0ZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgaGV4ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dFwiKTtcbiAgICAgIGlmIChpc1ZhbGlkSGV4KGhleCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5oZXhJbnB1dE5vZGUudmFsdWUgPSBoZXguc2xpY2UoMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnByZXZpb3VzTm9uTnVsbFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLnN0b3JlSGV4SW5wdXRSZWYgPSAobm9kZSkgPT4ge1xuICAgICAgdGhpcy5oZXhJbnB1dE5vZGUgPSBub2RlO1xuICAgIH07XG4gICAgdGhpcy5zdG9yZU9wYWNpdHlJbnB1dFJlZiA9IChub2RlKSA9PiB7XG4gICAgICB0aGlzLm9wYWNpdHlJbnB1dE5vZGUgPSBub2RlO1xuICAgIH07XG4gICAgdGhpcy5hbGxvd0VtcHR5ID0gZmFsc2U7XG4gICAgdGhpcy5hbHBoYUNoYW5uZWwgPSBmYWxzZTtcbiAgICB0aGlzLmhleExhYmVsID0gXCJIZXhcIjtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgICB0aGlzLnZhbHVlID0gbm9ybWFsaXplSGV4KGhleGlmeShERUZBVUxUX0NPTE9SLCB0aGlzLmFscGhhQ2hhbm5lbCksIHRoaXMuYWxwaGFDaGFubmVsLCB0cnVlKTtcbiAgICB0aGlzLmludGVybmFsQ29sb3IgPSBERUZBVUxUX0NPTE9SO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHsgYWxsb3dFbXB0eSwgYWxwaGFDaGFubmVsLCB2YWx1ZSB9ID0gdGhpcztcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVIZXgodmFsdWUsIGFscGhhQ2hhbm5lbCk7XG4gICAgICBpZiAoaXNWYWxpZEhleChub3JtYWxpemVkLCBhbHBoYUNoYW5uZWwpKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTZXRWYWx1ZShub3JtYWxpemVkLCBub3JtYWxpemVkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbGxvd0VtcHR5KSB7XG4gICAgICB0aGlzLmludGVybmFsU2V0VmFsdWUobnVsbCwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBzZXRVcExvYWRhYmxlQ29tcG9uZW50KHRoaXMpO1xuICB9XG4gIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgc2V0Q29tcG9uZW50TG9hZGVkKHRoaXMpO1xuICB9XG4gIGhhbmRsZVZhbHVlQ2hhbmdlKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHRoaXMuaW50ZXJuYWxTZXRWYWx1ZSh2YWx1ZSwgb2xkVmFsdWUsIGZhbHNlKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBhbHBoYUNoYW5uZWwsIGhleExhYmVsLCBpbnRlcm5hbENvbG9yLCBtZXNzYWdlcywgc2NhbGUsIHZhbHVlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhleElucHV0VmFsdWUgPSB0aGlzLmZvcm1hdEhleEZvckludGVybmFsSW5wdXQodmFsdWUpO1xuICAgIGNvbnN0IG9wYWNpdHlJbnB1dFZhbHVlID0gdGhpcy5mb3JtYXRPcGFjaXR5Rm9ySW50ZXJuYWxJbnB1dChpbnRlcm5hbENvbG9yKTtcbiAgICBjb25zdCBpbnB1dFNjYWxlID0gc2NhbGUgPT09IFwibFwiID8gXCJtXCIgOiBcInNcIjtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRhaW5lciB9LCBoKFwiY2FsY2l0ZS1pbnB1dC10ZXh0XCIsIHsgY2xhc3M6IENTUy5oZXhJbnB1dCwgbGFiZWw6IG1lc3NhZ2VzPy5oZXggfHwgaGV4TGFiZWwsIG1heExlbmd0aDogNiwgb25DYWxjaXRlSW5wdXRUZXh0Q2hhbmdlOiB0aGlzLm9uSGV4SW5wdXRDaGFuZ2UsIG9uQ2FsY2l0ZUludGVybmFsSW5wdXRUZXh0Qmx1cjogdGhpcy5vbkhleElucHV0Qmx1ciwgb25LZXlEb3duOiB0aGlzLm9uSW5wdXRLZXlEb3duLCBvblBhc3RlOiB0aGlzLm9uSGV4SW5wdXRQYXN0ZSwgcHJlZml4VGV4dDogXCIjXCIsIHNjYWxlOiBpbnB1dFNjYWxlLCB2YWx1ZTogaGV4SW5wdXRWYWx1ZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtc29ydC1wcm9wcyAtLSByZWYgc2hvdWxkIGJlIGxhc3Qgc28gbm9kZSBhdHRycy9wcm9wcyBhcmUgaW4gc3luYyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9wdWxsLzY1MzApXG4gICAgICByZWY6IHRoaXMuc3RvcmVIZXhJbnB1dFJlZiB9KSwgYWxwaGFDaGFubmVsID8gKGgoXCJjYWxjaXRlLWlucHV0LW51bWJlclwiLCB7IGNsYXNzOiBDU1Mub3BhY2l0eUlucHV0LCBrZXk6IFwib3BhY2l0eS1pbnB1dFwiLCBsYWJlbDogbWVzc2FnZXM/Lm9wYWNpdHksIG1heDogT1BBQ0lUWV9MSU1JVFMubWF4LCBtYXhMZW5ndGg6IDMsIG1pbjogT1BBQ0lUWV9MSU1JVFMubWluLCBudW1iZXJCdXR0b25UeXBlOiBcIm5vbmVcIiwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgb25DYWxjaXRlSW5wdXROdW1iZXJDaGFuZ2U6IHRoaXMub25PcGFjaXR5SW5wdXRDaGFuZ2UsIG9uQ2FsY2l0ZUludGVybmFsSW5wdXROdW1iZXJCbHVyOiB0aGlzLm9uT3BhY2l0eUlucHV0Qmx1ciwgb25LZXlEb3duOiB0aGlzLm9uSW5wdXRLZXlEb3duLCBzY2FsZTogaW5wdXRTY2FsZSwgc3VmZml4VGV4dDogXCIlXCIsIHZhbHVlOiBvcGFjaXR5SW5wdXRWYWx1ZSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtc29ydC1wcm9wcyAtLSByZWYgc2hvdWxkIGJlIGxhc3Qgc28gbm9kZSBhdHRycy9wcm9wcyBhcmUgaW4gc3luYyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9wdWxsLzY1MzApXG4gICAgICByZWY6IHRoaXMuc3RvcmVPcGFjaXR5SW5wdXRSZWYgfSkpIDogbnVsbCkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFB1YmxpYyBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqIFNldHMgZm9jdXMgb24gdGhlIGNvbXBvbmVudC4gKi9cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgYXdhaXQgY29tcG9uZW50Rm9jdXNhYmxlKHRoaXMpO1xuICAgIHJldHVybiBmb2N1c0VsZW1lbnQodGhpcy5oZXhJbnB1dE5vZGUpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGludGVybmFsU2V0VmFsdWUodmFsdWUsIG9sZFZhbHVlLCBlbWl0ID0gdHJ1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY29uc3QgeyBhbHBoYUNoYW5uZWwgfSA9IHRoaXM7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplSGV4KHZhbHVlLCBhbHBoYUNoYW5uZWwsIGFscGhhQ2hhbm5lbCk7XG4gICAgICBpZiAoaXNWYWxpZEhleChub3JtYWxpemVkLCBhbHBoYUNoYW5uZWwpKSB7XG4gICAgICAgIGNvbnN0IHsgaW50ZXJuYWxDb2xvcjogY3VycmVudENvbG9yIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBuZXh0Q29sb3IgPSBjb2xvcihub3JtYWxpemVkKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZExvbmdoYW5kID0gbm9ybWFsaXplSGV4KGhleGlmeShuZXh0Q29sb3IsIGFscGhhQ2hhbm5lbCksIGFscGhhQ2hhbm5lbCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhY3VycmVudENvbG9yIHx8XG4gICAgICAgICAgbm9ybWFsaXplZExvbmdoYW5kICE9PSBub3JtYWxpemVIZXgoaGV4aWZ5KGN1cnJlbnRDb2xvciwgYWxwaGFDaGFubmVsKSwgYWxwaGFDaGFubmVsKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENvbG9yID0gbmV4dENvbG9yO1xuICAgICAgICB0aGlzLnByZXZpb3VzTm9uTnVsbFZhbHVlID0gbm9ybWFsaXplZExvbmdoYW5kO1xuICAgICAgICB0aGlzLnZhbHVlID0gbm9ybWFsaXplZExvbmdoYW5kO1xuICAgICAgICBpZiAoY2hhbmdlZCAmJiBlbWl0KSB7XG4gICAgICAgICAgdGhpcy5jYWxjaXRlQ29sb3JQaWNrZXJIZXhJbnB1dENoYW5nZS5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmFsbG93RW1wdHkpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvciA9IG51bGw7XG4gICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VySGV4SW5wdXRDaGFuZ2UuZW1pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gb2xkVmFsdWU7XG4gIH1cbiAgZm9ybWF0SGV4Rm9ySW50ZXJuYWxJbnB1dChoZXgpIHtcbiAgICByZXR1cm4gaGV4ID8gaGV4LnJlcGxhY2UoXCIjXCIsIFwiXCIpLnNsaWNlKDAsIDYpIDogXCJcIjtcbiAgfVxuICBmb3JtYXRPcGFjaXR5Rm9ySW50ZXJuYWxJbnB1dChjb2xvcikge1xuICAgIHJldHVybiBjb2xvciA/IGAke2FscGhhVG9PcGFjaXR5KGNvbG9yLmFscGhhKCkpfWAgOiBcIlwiO1xuICB9XG4gIG51ZGdlUkdCQ2hhbm5lbHMoY29sb3IkMSwgYW1vdW50LCBjb250ZXh0KSB7XG4gICAgbGV0IG51ZGdlZENoYW5uZWxzO1xuICAgIGNvbnN0IGNoYW5uZWxzID0gY29sb3IkMS5hcnJheSgpO1xuICAgIGNvbnN0IHJnYkNoYW5uZWxzID0gY2hhbm5lbHMuc2xpY2UoMCwgMyk7XG4gICAgaWYgKGNvbnRleHQgPT09IFwicmdiXCIpIHtcbiAgICAgIGNvbnN0IG51ZGdlZFJHQkNoYW5uZWxzID0gcmdiQ2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjaGFubmVsICsgYW1vdW50KTtcbiAgICAgIG51ZGdlZENoYW5uZWxzID0gW1xuICAgICAgICAuLi5udWRnZWRSR0JDaGFubmVscyxcbiAgICAgICAgdGhpcy5hbHBoYUNoYW5uZWwgPyBjaGFubmVsc1szXSA6IHVuZGVmaW5lZCxcbiAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbnVkZ2VkQWxwaGEgPSBvcGFjaXR5VG9BbHBoYShhbHBoYVRvT3BhY2l0eShjb2xvciQxLmFscGhhKCkpICsgYW1vdW50KTtcbiAgICAgIG51ZGdlZENoYW5uZWxzID0gWy4uLnJnYkNoYW5uZWxzLCBudWRnZWRBbHBoYV07XG4gICAgfVxuICAgIHJldHVybiBjb2xvcihudWRnZWRDaGFubmVscyk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwidmFsdWVcIjogW1wiaGFuZGxlVmFsdWVDaGFuZ2VcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gY29sb3JQaWNrZXJIZXhJbnB1dENzczsgfVxufSwgWzEsIFwiY2FsY2l0ZS1jb2xvci1waWNrZXItaGV4LWlucHV0XCIsIHtcbiAgICBcImFsbG93RW1wdHlcIjogWzQsIFwiYWxsb3ctZW1wdHlcIl0sXG4gICAgXCJhbHBoYUNoYW5uZWxcIjogWzQsIFwiYWxwaGEtY2hhbm5lbFwiXSxcbiAgICBcImhleExhYmVsXCI6IFsxLCBcImhleC1sYWJlbFwiXSxcbiAgICBcIm1lc3NhZ2VzXCI6IFsxNl0sXG4gICAgXCJudW1iZXJpbmdTeXN0ZW1cIjogWzEsIFwibnVtYmVyaW5nLXN5c3RlbVwiXSxcbiAgICBcInNjYWxlXCI6IFs1MTNdLFxuICAgIFwidmFsdWVcIjogWzE1MzddLFxuICAgIFwiaW50ZXJuYWxDb2xvclwiOiBbMzJdLFxuICAgIFwic2V0Rm9jdXNcIjogWzY0XVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJjYWxjaXRlLWNvbG9yLXBpY2tlci1oZXgtaW5wdXRcIiwgXCJjYWxjaXRlLWljb25cIiwgXCJjYWxjaXRlLWlucHV0LW51bWJlclwiLCBcImNhbGNpdGUtaW5wdXQtdGV4dFwiLCBcImNhbGNpdGUtcHJvZ3Jlc3NcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtY29sb3ItcGlja2VyLWhleC1pbnB1dFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIENvbG9yUGlja2VySGV4SW5wdXQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhbGNpdGUtaWNvblwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCQ0KCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2FsY2l0ZS1pbnB1dC1udW1iZXJcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQkMygpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhbGNpdGUtaW5wdXQtdGV4dFwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCQyKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2FsY2l0ZS1wcm9ncmVzc1wiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cbmRlZmluZUN1c3RvbUVsZW1lbnQoKTtcblxuZXhwb3J0IHsgQ1NTJDEgYXMgQywgREVGQVVMVF9DT0xPUiQxIGFzIEQsIEhTVl9MSU1JVFMgYXMgSCwgT1BBQ0lUWV9MSU1JVFMgYXMgTywgUkdCX0xJTUlUUyBhcyBSLCBTQ09QRV9TSVpFIGFzIFMsIERJTUVOU0lPTlMgYXMgYSwgSFVFX0xJTUlUX0NPTlNUUkFJTkVEIGFzIGIsIERFRkFVTFRfU1RPUkFHRV9LRVlfUFJFRklYIGFzIGMsIGRlZmluZUN1c3RvbUVsZW1lbnQgYXMgZCwgQ29sb3JQaWNrZXJIZXhJbnB1dCBhcyBlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=