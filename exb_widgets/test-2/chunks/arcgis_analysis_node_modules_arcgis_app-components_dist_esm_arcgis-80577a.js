"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-80577a"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional.entry.js":
/*!*********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional.entry.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_raster_multidimensional: () => (/* binding */ ArcgisRasterMultidimensional)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multidimensional-279ffd6e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-279ffd6e.js");
/* harmony import */ var _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./commonEnums-f98a323c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-f98a323c.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commonFunctions-5262b094.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-5262b094.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */










const arcgisRasterMultidimensionalCss = ":host{display:flex;flex:1 1 auto;overflow:hidden}.variable-section-boarder{border:1px solid var(--arcgis-app-border)}.variable-select{display:flex;justify-content:center}.multidimensional-extent>div{margin:10px 0}.multidimensional-extent-compact{display:flex;width:100%}.multidimensional-extent-compact>div{width:50%}.multidimensional-extent-compact>div:first-child{margin:0 20px 0 0}.multidimensional-unsupported{margin:20px}.dimension-zone{padding:10px;border:1px solid var(--arcgis-app-border);margin:10px 0}.dimension-select-container{display:flex;width:100%;align-items:center}.dimension-select-container .dimension-select{flex-grow:1}.arcgis--rtl .extent-compact>div:first-child{margin:0 0 0 20px}";

const undefined_dimension_value = Number.MAX_VALUE - 1;
const ArcgisRasterMultidimensional = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisRasterMultidimensionalChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterMultidimensionalChange", 7);
    this.arcgisRasterMultidimensionalSave = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterMultidimensionalSave", 7);
    this.arcgisRasterMultidimensionalCancel = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisRasterMultidimensionalCancel", 7);
    this.valuePickers = {
      time: null,
      z: null
    };
    this.containerTop = 0;
    this.aoiIndex = 0;
    this.previousPickedListSize = -1;
    this.pauseLayerUpdate = false;
    this.apply = () => {
      var _a;
      if (!this.multidimensionalInfo) {
        return;
      }
      this.originalLayerSetting.definition = this.esriLang.clone(this.activeMultidimensionalDefinition);
      this.originalLayerSetting.subset = this.activeMultidimensionalSubset.clone();
      const { layer } = this;
      if (this.isImageryLayer(layer)) {
        this.originalLayerSetting.mosaicRule = (_a = layer.mosaicRule) === null || _a === void 0 ? void 0 : _a.clone();
      }
      if (!this.makeLiveLayerUpdate) {
        this.updateLayerMultidimensionalDefinition();
        this.updateLayerMultidimensionalSubset();
      }
      this.closePopover();
      this.arcgisRasterMultidimensionalSave.emit();
    };
    this.cancel = () => {
      if (!this.multidimensionalInfo) {
        return;
      }
      const { layer, originalLayerSetting } = this;
      const definition = this.esriLang.clone(originalLayerSetting.definition);
      const subset = this.esriLang.clone(originalLayerSetting.subset);
      if (this.updateStateWhenCancel) {
        this.pauseLayerUpdate = true;
        this.activeMultidimensionalSubset = subset !== null && subset !== void 0 ? subset : this.getDefaultMultidimensionalSubset();
        this.activeMultidimensionalDefinition = definition;
        this.pauseLayerUpdate = false;
      }
      if (this.isImageryLayer(layer)) {
        layer.mosaicRule = originalLayerSetting.mosaicRule;
      }
      else {
        layer.multidimensionalDefinition = definition;
      }
      layer.renderer = originalLayerSetting.renderer;
      layer.multidimensionalSubset = subset;
      this.closePopover();
      this.arcgisRasterMultidimensionalCancel.emit();
    };
    this.updateDefinitionDimensionValue = (selectedDimensionName, value, updateValuePicker = false) => {
      var _a, _b;
      const newDef = this.esriLang.clone(this.activeMultidimensionalDefinition);
      const selectedDef = newDef.find(({ dimensionName }) => dimensionName === selectedDimensionName);
      selectedDef.values = [value];
      this.activeMultidimensionalDefinition = newDef;
      if (!updateValuePicker) {
        return;
      }
      // find the matching value picker
      const { valuePickers } = this;
      const valuePicker = ((_a = valuePickers.time) === null || _a === void 0 ? void 0 : _a.dimensionName) === selectedDimensionName
        ? valuePickers.time
        : ((_b = valuePickers.z) === null || _b === void 0 ? void 0 : _b.dimensionName) === selectedDimensionName
          ? valuePickers.z
          : null;
      if (valuePicker) {
        const index = valuePicker.dimensionValues.findIndex((dimValue) => Array.isArray(value) && Array.isArray(dimValue)
          ? value.join("-") === dimValue.join("-")
          : value === dimValue);
        valuePicker.slider.values = this.getSelectedSliderValue(index, valuePicker.slider.component.reversed, valuePicker.dimensionValues.length);
      }
    };
    this.updateDefinitionVariableName = (variableName) => {
      // normalize empty variable name (3.x), * (rft result), default variable string UI
      if (this.isDefaultUnspecifiedVariable(variableName)) {
        variableName = "";
      }
      const newDef = this.getNewMultidimensionalDefinition(variableName);
      this.activeMultidimensionalDefinition = newDef;
    };
    this.updateExtentDimensionSubset = (selectedDimensionName, valueOrExtent, replaceBoth = "both") => {
      const { activeMultidimensionalSubset } = this;
      const dim = activeMultidimensionalSubset.dimensions.find((dimension) => dimension.name === selectedDimensionName);
      const dimExtent = [...dim.extent];
      if (replaceBoth === "both") {
        // avoid updating when existing value matches new value
        if (dimExtent[0] === valueOrExtent[0] && dimExtent[1] === valueOrExtent[1]) {
          return;
        }
        [dimExtent[0], dimExtent[1]] = valueOrExtent;
      }
      else if (replaceBoth === "start") {
        let wasNotRange = dimExtent[1] === dimExtent[0];
        dimExtent[0] = Array.isArray(valueOrExtent) ? valueOrExtent[0] : valueOrExtent;
        if (wasNotRange) {
          dimExtent[1] = dimExtent[0];
        }
      }
      else {
        if (valueOrExtent === undefined_dimension_value) {
          dimExtent[1] = dimExtent[0];
        }
        else {
          dimExtent[1] = Array.isArray(valueOrExtent)
            ? valueOrExtent[valueOrExtent.length - 1]
            : valueOrExtent;
        }
      }
      if (dimExtent[1] < dimExtent[0] || dimExtent[1] == null) {
        dimExtent[1] = dimExtent[0];
      }
      const newActiveSubset = activeMultidimensionalSubset.clone();
      const { subsetDefinitions } = newActiveSubset;
      subsetDefinitions.forEach((def) => {
        if (def.dimensionName === selectedDimensionName) {
          def.values = [dimExtent[0], dimExtent[1]];
        }
      });
      this.activeMultidimensionalSubset = newActiveSubset;
      const { animatedDimensions } = this;
      const hasTimePicker = animatedDimensions.time === selectedDimensionName;
      const hasZPicker = animatedDimensions.z === selectedDimensionName;
      if (hasTimePicker || hasZPicker) {
        const variableInfo = this.getVariableInfo(this.activeMultidimensionalDefinition[0].variableName);
        const dimInfo = variableInfo === null || variableInfo === void 0 ? void 0 : variableInfo.dimensions.find(({ name }) => name === selectedDimensionName);
        this.createValuePicker(dimInfo);
        // when there's single or 0 (can it be 0?) slices, keep enabled state as it's clipped by extent
        if (hasTimePicker) {
          animatedDimensions.time = selectedDimensionName;
        }
        else {
          animatedDimensions.z = selectedDimensionName;
        }
      }
    };
    this.updateExtentVariables = (selectedVariables) => {
      let { activeMultidimensionalSubset } = this;
      if (selectedVariables.length &&
        activeMultidimensionalSubset.variables.length &&
        selectedVariables.join(",") === activeMultidimensionalSubset.variables.join(",")) {
        return;
      }
      this.previousPickedListSize = selectedVariables.length;
      if (selectedVariables.length === 0) {
        selectedVariables = this.allVariables.map(({ name }) => name);
      }
      // start wtih default dimensions, use existing definition when exist, remove dimensions that are no longer part of selected variables
      const selectedDefaultSubset = this.getDefaultMultidimensionalSubset(selectedVariables);
      const { subsetDefinitions } = selectedDefaultSubset.clone();
      subsetDefinitions.forEach((defaultDef) => {
        const matchingDefinition = activeMultidimensionalSubset.subsetDefinitions.find((def) => def.variableName === defaultDef.variableName &&
          def.dimensionName === defaultDef.dimensionName);
        if (matchingDefinition) {
          defaultDef.values = matchingDefinition.values;
        }
        else {
          const matchingDimensionExtent = activeMultidimensionalSubset.dimensions.find((dimension) => dimension.name === defaultDef.dimensionName);
          if (matchingDimensionExtent) {
            defaultDef.values = [...matchingDimensionExtent.extent];
          }
        }
      });
      const newAtiveMultidimensionalSubset = activeMultidimensionalSubset.clone();
      newAtiveMultidimensionalSubset.subsetDefinitions = subsetDefinitions;
      this.activeMultidimensionalSubset = newAtiveMultidimensionalSubset;
    };
    this.updateExtentAOI = (aoi) => {
      const newAtiveMultidimensionalSubset = this.activeMultidimensionalSubset.clone();
      newAtiveMultidimensionalSubset.areaOfInterest = aoi === null || aoi === void 0 ? void 0 : aoi.clone();
      this.activeMultidimensionalSubset = newAtiveMultidimensionalSubset;
    };
    this.updateExtentFromTime = (timeExtent) => {
      if (!this.multidimensionalInfo) {
        return;
      }
      const originalDef = this.esriLang.clone(this.originalLayerSetting.definition);
      // todo expose this a utilty function in API
      const { multidimensionalDefinition: newDef } = this.layer.normalizeRasterFetchOptions({
        multidimensionalDefinition: originalDef,
        timeExtent
      });
      if (newDef && this.isPropertyValueChanged(newDef, this.activeMultidimensionalDefinition)) {
        this.activeMultidimensionalDefinition = newDef;
      }
    };
    this.updateSorting = (dimensionName) => {
      // not initialized (undefined) will be changed to descending
      const sortDirections = Object.assign({}, this.sortDirections);
      sortDirections[dimensionName] =
        sortDirections[dimensionName] === "descending" ? "ascending" : "descending";
      this.sortDirections = sortDirections;
    };
    this.updateLayerMultidimensionalDefinition = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
      var _a, _b, _c;
      const { activeMultidimensionalDefinition, layer } = this;
      const isDynamicImagery = this.isImageryLayer(layer);
      const isDefinitionChanged = isDynamicImagery
        ? this.isPropertyValueChanged(activeMultidimensionalDefinition, (_a = layer.mosaicRule) === null || _a === void 0 ? void 0 : _a.multidimensionalDefinition)
        : this.isPropertyValueChanged(activeMultidimensionalDefinition, layer.multidimensionalDefinition);
      if (!isDefinitionChanged) {
        return;
      }
      const oldDefinition = this.getMultidimensionalDefinition(layer);
      const isVariableChanged = !oldDefinition ||
        oldDefinition.length === 0 ||
        oldDefinition[0].variableName !== activeMultidimensionalDefinition[0].variableName;
      if (isDynamicImagery) {
        const mosaicRule = ((_b = layer.mosaicRule) !== null && _b !== void 0 ? _b : layer.defaultMosaicRule).clone();
        if (this.isDefaultUnspecifiedVariable(activeMultidimensionalDefinition[0].variableName)) {
          const newDefinition = activeMultidimensionalDefinition.map((def) => {
            const newDef = def.clone();
            newDef.variableName = "";
            return newDef;
          });
          mosaicRule.multidimensionalDefinition = newDefinition;
        }
        else {
          mosaicRule.multidimensionalDefinition = activeMultidimensionalDefinition;
        }
        layer.mosaicRule = mosaicRule;
      }
      else {
        layer.multidimensionalDefinition = activeMultidimensionalDefinition;
      }
      if (isVariableChanged) {
        const variableInfo = this.getVariableInfo(activeMultidimensionalDefinition[0].variableName);
        const { renderer } = layer;
        if ((renderer === null || renderer === void 0 ? void 0 : renderer.type) === "raster-stretch" && ((_c = variableInfo.statistics) === null || _c === void 0 ? void 0 : _c.length)) {
          const newRenderer = renderer.clone();
          newRenderer.statistics = variableInfo.statistics.map((stats) => (Object.assign({}, stats)));
          layer.renderer = newRenderer;
        }
      }
    }, 100);
    this.updateLayerMultidimensionalSubset = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
      const { activeMultidimensionalSubset, layer } = this;
      const fullDimensionalSubset = this.getDefaultMultidimensionalSubset();
      // this is a simple comparison (to default) to optimize persisted layer's size
      // it does no harm if a custom layer contains definitions with altered variable order.
      const isSubsetDefinitionsSpecified = this.isPropertyValueChanged(activeMultidimensionalSubset.subsetDefinitions, fullDimensionalSubset.subsetDefinitions);
      const isAOISpecified = activeMultidimensionalSubset.areaOfInterest != null;
      if (!isSubsetDefinitionsSpecified && !isAOISpecified) {
        layer.multidimensionalSubset = null;
      }
      else {
        if (!isSubsetDefinitionsSpecified) {
          const newSubset = activeMultidimensionalSubset.clone();
          newSubset.subsetDefinitions = [];
          layer.multidimensionalSubset = newSubset;
        }
        else {
          layer.multidimensionalSubset = activeMultidimensionalSubset;
        }
      }
    }, 100);
    this.hidePanelHeading = false;
    this.panelHeading = undefined;
    this.dismissible = false;
    this.hideButtons = false;
    this.hideExtentSection = false;
    this.hideAOI = false;
    this.isDimensionListSortable = false;
    this.collapseExtentSection = false;
    this.useCompactExtentDropdowns = false;
    this.showVariableFilter = undefined;
    this.watchViewTime = false;
    this.watchRasterFunction = false;
    this.updateStateWhenCancel = true;
    this.makeLiveLayerUpdate = true;
    this.showAnimationControls = false;
    this.showAnimationOnStartUp = false;
    this.showAnimationTooltip = false;
    this.animationSetting = {
      playRate: 3000,
      timeClassName: "imagery-dimension-picker-t",
      zClassName: "imagery-dimension-picker-z",
      timeTooltipPlacement: "top",
      zTooltipPlacement: "auto"
    };
    this.layer = undefined;
    this.view = undefined;
    this.multidimensionalInfo = undefined;
    this.activeMultidimensionalDefinition = undefined;
    this.activeMultidimensionalSubset = undefined;
    this.sortDirections = {};
    this.animatedDimensions = { time: "", z: "" };
  }
  watchLayer(newValue, _oldValue) {
    var _a, _b;
    this.closePopover();
    this.multidimensionalInfo = null;
    (_a = this.watchHandleViewTime) === null || _a === void 0 ? void 0 : _a.remove();
    this.watchHandleLayer = null;
    (_b = this.watchHandleLayer) === null || _b === void 0 ? void 0 : _b.remove();
    this.watchHandleLayer = null;
    this.initLayer(newValue);
  }
  watchActiveMultidimensionalDefinition(newValue, oldValue) {
    // oldValue is null during initialization, newValue can't be null
    if (newValue == null || oldValue == null) {
      return;
    }
    this.sortDirections = {};
    if (!this.pauseLayerUpdate && this.makeLiveLayerUpdate) {
      this.updateLayerMultidimensionalDefinition();
    }
    this.arcgisRasterMultidimensionalChange.emit({
      multidimensionalDefinition: newValue
    });
    // destroy value picker when the corresponding dimension does not exist for the new variable
    const { animatedDimensions, showAnimationControls } = this;
    if (showAnimationControls &&
      (animatedDimensions.time || animatedDimensions.z) &&
      newValue[0].variableName !== oldValue[0].variableName) {
      const variableInfo = this.getVariableInfo(newValue[0].variableName);
      if (!variableInfo.dimensions.some(({ name }) => name === animatedDimensions.time)) {
        this.destroyValuePicker("time");
      }
      if (!variableInfo.dimensions.some(({ name }) => name === animatedDimensions.z)) {
        this.destroyValuePicker("z");
      }
    }
  }
  watchactiveMultidimensionalSubset(newValue, _oldValue) {
    var _a;
    // todo: API support
    if (!this.pauseLayerUpdate && this.makeLiveLayerUpdate) {
      this.updateLayerMultidimensionalSubset();
    }
    const { activeMultidimensionalDefinition } = this;
    if (((_a = newValue.variables) === null || _a === void 0 ? void 0 : _a.length) && (activeMultidimensionalDefinition === null || activeMultidimensionalDefinition === void 0 ? void 0 : activeMultidimensionalDefinition.length)) {
      // use original order
      const variableNames = this.allVariables
        .filter(({ name }) => newValue.variables.includes(name))
        .map(({ name }) => name);
      const activeVariableName = activeMultidimensionalDefinition[0].variableName;
      const newVariableName = activeVariableName === "" || newValue.variables.includes(activeVariableName)
        ? activeVariableName
        : variableNames[0];
      const newDef = this.getNewMultidimensionalDefinition(newVariableName);
      const isDefinitionChanged = this.isMultidimensionalDefinitionChanged(newDef);
      if (isDefinitionChanged) {
        this.activeMultidimensionalDefinition = newDef;
      }
    }
    const data = {
        multidimensionalSubset: newValue
      };
    this.arcgisRasterMultidimensionalChange.emit(data);
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    [this.strings] = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement);
    [
      this.esriLang,
      this.intl,
      this.DimensionalDefinition,
      this.MultidimensionalSubset,
      this.ValuePicker
    ] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_3__.l)([
      "esri/core/lang",
      "esri/intl",
      "esri/layers/support/DimensionalDefinition",
      "esri/layers/support/MultidimensionalSubset",
      "esri/widgets/ValuePicker"
    ]);
    const { layer } = this;
    if (layer.loaded) {
      // load multidimensional info (may or may not involve actual async fetching)
      await this.initLayer(layer);
    }
    else {
      // load layer (show loading sign) and multidimensional info
      this.initLayer(layer);
    }
    this.containerTop = this.hostElement.getBoundingClientRect().top;
  }
  disconnectedCallback() {
    var _a, _b;
    this.closePopover();
    this.destroyValuePicker("both");
    (_a = this.watchHandleViewTime) === null || _a === void 0 ? void 0 : _a.remove();
    (_b = this.watchHandleLayer) === null || _b === void 0 ? void 0 : _b.remove();
  }
  // --------------------------------------------------------------------------
  //
  //  public methods
  //
  // --------------------------------------------------------------------------
  async setFocus(focusId) {
    var _a;
    if (focusId === "dismiss-button" || (!focusId && this.dismissible)) {
      (_a = this.refCloseButtonNode) === null || _a === void 0 ? void 0 : _a.setFocus();
    }
    else {
      this.refPanelNode.setFocus();
    }
  }
  async done() {
    this.apply();
  }
  // --------------------------------------------------------------------------
  //
  //  Renderer methods
  //
  // --------------------------------------------------------------------------
  render() {
    var _a;
    if (this.popOver) {
      this.updatePopoverProps();
    }
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_4__.g)(this.hostElement) === "rtl";
    const { hidePanelHeading, dismissible, hideButtons, panelHeading, hideExtentSection, strings: strings } = this;
    const loading = !((_a = this.layer) === null || _a === void 0 ? void 0 : _a.loaded);
    if (!this.multidimensionalInfo) {
      const unsupportedDiv = loading ? null : ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "multidimensional-unsupported" }, strings.general.unsupported));
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { loading: loading, heading: !hidePanelHeading ? panelHeading !== null && panelHeading !== void 0 ? panelHeading : strings.title : undefined, class: {
          panel: true,
          [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_4__.C.rtl]: rtl
        }, ref: (node) => (this.refPanelNode = node) }, dismissible && this.renderClose(), unsupportedDiv, !hideButtons && this.renderDoneButton(), !hideButtons && this.renderCancelButton()));
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { loading: false, heading: !hidePanelHeading ? panelHeading !== null && panelHeading !== void 0 ? panelHeading : strings.title : undefined, class: {
        panel: true,
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_4__.C.rtl]: rtl
      }, ref: (node) => (this.refPanelNode = node) }, dismissible ? this.renderClose() : null, hideExtentSection ? null : this.renderExtent(), this.renderCurrentDisplay(), hideButtons ? null : this.renderDoneButton(), hideButtons ? null : this.renderCancelButton())));
  }
  renderCurrentDisplay() {
    var _a;
    const { activeMultidimensionalDefinition, strings } = this;
    const subsetVariables = this.activeMultidimensionalSubset.variables;
    const variables = this.allVariables.filter(({ name }) => !subsetVariables.length || subsetVariables.includes(name));
    const { layer } = this;
    const isDynamicImagery = this.isImageryLayer(layer);
    const hasStarOrNewVariable = isDynamicImagery &&
      (variables.some(({ name }) => name === "*") ||
        this.hasNewVariable(this.multidimensionalInfo));
    // since multidimensionalDefinition can only be used for selection, it cannot be used to
    // work with new variables after rasterFunction
    let activeVariableName = activeMultidimensionalDefinition[0].variableName;
    // handle special variable name from a server side rft.
    // for 10.9+ servers, an rft with query definition will result a * variable, which is equivalent of unspecified variable name
    if (isDynamicImagery) {
      const { rasterFunction, version } = layer;
      const hasRasterFunction = rasterFunction && ((_a = rasterFunction.functionName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== "none";
      if (hasRasterFunction) {
        if (version <= _multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.m) {
          variables.unshift(Object.assign(Object.assign({}, variables[0]), { name: strings.display.defaultVariable, label: strings.display.defaultVariable }));
        }
        if (activeVariableName === "") {
          activeVariableName = hasStarOrNewVariable
            ? variables[0].name
            : strings.display.defaultVariable;
        }
      }
    }
    const selectedIndex = variables.findIndex((variableInfo) => variableInfo.name === activeVariableName);
    const selectStrings = {
      clearFilter: strings.select.clearFilter,
      filterText: strings.select.filterText,
      filterLabel: strings.extent.searchVariables,
      selectLabel: strings.extent.selectVariables
    };
    const variableSelect = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.display.variable, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-lazy-loading-select", { selectedIndex: selectedIndex === -1 ? 0 : selectedIndex, list: variables.map((variableInfo) => (Object.assign(Object.assign({}, variableInfo), { value: variableInfo.name }))), strings: selectStrings, key: this.sourceKey, onArcgisLazyLoadingSelectChange: (evt) => {
        const selectedVariableName = evt.detail.selectedValue;
        this.updateDefinitionVariableName(selectedVariableName);
      }, containerTop: this.containerTop }))));
    // restore special activeVariableName. star variable is fine for the following variableInfo lookup
    if (activeVariableName === strings.display.defaultVariable) {
      activeVariableName = "";
    }
    const variableInfo = this.getVariableInfo(activeVariableName);
    const dimensionBlocks = variableInfo.dimensions.map((dimInfo) => {
      dimInfo = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.g)(dimInfo, this.activeMultidimensionalSubset);
      return this.renderDimension(dimInfo);
    });
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: strings.display.current, collapsible: true, open: true }, variableSelect, dimensionBlocks));
  }
  renderPickListPopover() {
    if (this.popOver) {
      return;
    }
    const popOver = document.createElement("arcgis-field-pick-list");
    const popoverWidth = this.refPanelNode.getBoundingClientRect().width;
    popOver.popoverProps = {
      refElement: this.refPanelNode,
      placement: "leading-end",
      offsetDistance: 1,
      offsetSkidding: 48,
      popoverWidth
    };
    popOver.heading = this.strings.extent.selectVariables;
    popOver.filterPlaceholderText = this.strings.extent.searchVariables;
    popOver.showFieldInfo = false;
    popOver.showFieldName = false;
    popOver.showDescription = true;
    popOver.showSelectionAll = true;
    popOver.showCancel = false;
    popOver.showSort = false;
    popOver.sortBy = _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_6__.L.default;
    popOver.multiple = true;
    this.popOver = popOver;
    this.previousPickedListSize = -1;
    this.updatePopoverProps();
    popOver.addEventListener("arcgisFieldPickListChange", (evt) => {
      let selectedVariables = evt.detail.selectedFields || [];
      this.updateExtentVariables(selectedVariables);
    });
    popOver.addEventListener("arcgisFieldPickListDismissed", (_evt) => {
      this.closePopover();
    });
    document.body.appendChild(popOver);
  }
  renderExtent() {
    const variableList = this.renderVariableList();
    const { extent: extentStrings } = this.strings;
    const variableSelectButton = this.allVariables.length > 1 && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "variable-select" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { scale: "s", appearance: "outline-fill", kind: "neutral", round: true, alignment: "center", iconStart: "plus", onClick: () => this.renderPickListPopover() }, extentStrings.variables)));
    const allDimensiosn = [];
    this.multidimensionalInfo.variables.forEach(({ dimensions }) => allDimensiosn.push(...dimensions));
    const extentBlocks = this.activeMultidimensionalSubset.dimensions.map(({ name, extent }) => {
      const dimInfo = allDimensiosn.find(({ name: dimName }) => dimName === name);
      return this.renderDimensionExtent(dimInfo, extent);
    });
    const aoiBlock = this.hideAOI ? undefined : this.renderAOI();
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: extentStrings.extent, collapsible: true, open: !this.collapseExtentSection, onCalciteBlockToggle: () => this.closePopover() }, variableList, variableSelectButton, extentBlocks, aoiBlock));
  }
  renderVariableList() {
    const subsetVariables = this.activeMultidimensionalSubset.variables;
    const variables = this.allVariables.filter(({ name }) => !subsetVariables.length || subsetVariables.includes(name));
    const { strings } = this;
    const hidden = this.allVariables.length === 1;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.variables, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", { class: "variable-section-boarder" }, variables.map(({ name, label, description }) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { label: label, description: description, key: name }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "x", scale: "s", text: strings.general.close, slot: "actions-end", hidden: hidden, onClick: () => this._removeVariable(name) }))))))));
  }
  renderAOI() {
    const { strings } = this;
    const aoiOptions = [
      { value: "default", label: strings.extent.default, selected: this.aoiIndex === 0 },
      { value: "map", label: strings.extent.mapExtent, selected: this.aoiIndex === 1 }
    ];
    const selectedIndex = aoiOptions.findIndex(({ selected }) => selected);
    const selectStrings = {
      clearFilter: this.strings.select.clearFilter,
      filterText: this.strings.select.filterText,
      filterLabel: this.strings.extent.searchAOI,
      selectLabel: this.strings.extent.selectAOI
    };
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.aoi, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-lazy-loading-select", { selectedIndex: selectedIndex, list: aoiOptions, strings: selectStrings, onArcgisLazyLoadingSelectChange: (evt) => {
        var _a;
        const value = evt.detail.selectedValue;
        const aoi = value === "default" ? null : (_a = this.view) === null || _a === void 0 ? void 0 : _a.extent;
        this.aoiIndex = value === "default" ? 0 : 1;
        this.updateExtentAOI(aoi);
      }, containerTop: this.containerTop }))));
  }
  _removeVariable(variableName) {
    const newActiveMultidimensionalSubset = this.activeMultidimensionalSubset.clone();
    let subsetDefinitions = newActiveMultidimensionalSubset.subsetDefinitions.filter((def) => def.variableName !== variableName);
    if (subsetDefinitions.length === 0) {
      subsetDefinitions = this.getDefaultMultidimensionalSubset().subsetDefinitions;
    }
    newActiveMultidimensionalSubset.subsetDefinitions = subsetDefinitions;
    this.activeMultidimensionalSubset = newActiveMultidimensionalSubset;
  }
  renderDimensionList(dimensionInfo, options) {
    var _a;
    let { selectedValue, key } = options;
    const isStartOrEnd = (key === null || key === void 0 ? void 0 : key.includes("start")) || (key === null || key === void 0 ? void 0 : key.includes("end"));
    if (Array.isArray((_a = dimensionInfo.values) === null || _a === void 0 ? void 0 : _a[0]) && typeof selectedValue === "number") {
      const dimValues = dimensionInfo.values;
      if (isStartOrEnd) {
        selectedValue = dimValues.find((value) => key.includes("start") ? value[0] === selectedValue : value[1] === selectedValue);
      }
      else {
        // match start, then match end
        selectedValue = dimValues.find((value) => value[0] === selectedValue);
        if (selectedValue == null) {
          selectedValue = dimValues.find((value) => value[1] === selectedValue);
        }
      }
    }
    const isUndefinedValue = selectedValue === undefined_dimension_value ||
      options.selectedValue === undefined_dimension_value;
    const activeDimensionLabel = isUndefinedValue
      ? "undefined"
      : (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.f)(selectedValue, dimensionInfo, {
        intl: this.intl,
        useRecurringTimeLabel: true
      });
    // number is not well supported by calcite-select
    // <option label="0" value="">0</option> (null/truthy check issue?)
    // start/end time column renders same (how is this related to number?)
    const separator = " - ";
    const isAscending = options.sortable
      ? this.sortDirections[dimensionInfo.name] !== "descending"
      : true;
    const dimensionValues = isAscending
      ? dimensionInfo.values
      : [...dimensionInfo.values].reverse();
    const values = dimensionValues.map((value) => {
      const label = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.f)(value, dimensionInfo, {
        intl: this.intl,
        useRecurringTimeLabel: true
      });
      const valueStr = Array.isArray(value) ? value.join(separator) : String(value);
      const selected = label === activeDimensionLabel;
      const key = `${options.key}-${valueStr}}`;
      return {
        key,
        value: valueStr,
        label,
        selected
      };
    });
    if (options.showEnd) {
      values.push({
        key: `${dimensionInfo.name}-end-undefined}`,
        value: String(undefined_dimension_value),
        label: this.strings.extent.endUndefined,
        selected: isUndefinedValue
      });
    }
    const onArcgisLazyLoadingSelectChange = (evt) => {
      var _a;
      const value = evt.detail.selectedValue.split(separator).map((val) => Number(val));
      (_a = options.onChange) === null || _a === void 0 ? void 0 : _a.call(options, value.length === 1 ? value[0] : value);
    };
    let sortIcon = null;
    if (options.sortable) {
      // icon is the what user want to change to
      const sortIconName = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo)
        ? isAscending
          ? "clock-up"
          : "clock-down"
        : isAscending
          ? "sort-ascending-arrow"
          : "sort-descending-arrow";
      sortIcon = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: sortIconName, scale: "s", text: this.strings.display.sort, slot: "actions-end", onClick: () => {
          this.updateSorting(dimensionInfo.name);
        } }));
    }
    const selectedIndex = values.findIndex(({ selected }) => selected);
    const selectStrings = {
      clearFilter: this.strings.select.clearFilter,
      filterText: this.strings.select.filterText,
      filterLabel: this.strings.extent.searchDimensions,
      selectLabel: this.strings.extent.selectDimensions
    };
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "dimension-select-container" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-lazy-loading-select", { selectedIndex: selectedIndex === -1 ? 0 : selectedIndex, list: values, strings: selectStrings, onArcgisLazyLoadingSelectChange: onArcgisLazyLoadingSelectChange, containerTop: this.containerTop }), sortIcon));
  }
  renderDimension(dimensionInfo) {
    const { activeMultidimensionalDefinition } = this;
    const definition = activeMultidimensionalDefinition.find((def) => def.dimensionName === dimensionInfo.name);
    const onChange = (value) => this.updateDefinitionDimensionValue(dimensionInfo.name, value, true);
    const dimensionSelect = this.renderDimensionList(dimensionInfo, {
      selectedValue: definition.values[0],
      sortable: this.isDimensionListSortable,
      key: dimensionInfo.name,
      onChange
    });
    const { strings } = this;
    const dimensionLabel = dimensionInfo.name === "StdTime"
      ? strings.display.stdTimeDimension
      : dimensionInfo.name === "StdZ"
        ? strings.display.stdZDimension
        : strings.display.generalDimension.replace("${dimensionName}", dimensionInfo.name);
    const isTime = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true);
    const dimName = isTime ? "time" : "z";
    const clippedDimensionInfo = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.g)(dimensionInfo, this.activeMultidimensionalSubset);
    const isZeroOrSingleSlice = clippedDimensionInfo.values.length < 2;
    const { showAnimationControls } = this;
    const animationSwitch = showAnimationControls && !isZeroOrSingleSlice ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { scale: "s", checked: this.animatedDimensions[dimName] === dimensionInfo.name, label: strings.display.showDimensionSlider, onCalciteSwitchChange: (event) => {
        const node = event.target;
        if (node.checked) {
          this.createValuePicker(dimensionInfo);
        }
        else {
          this.destroyValuePicker(isTime ? "time" : "z");
        }
      } }), strings.display.showDimensionSlider)) : null;
    return showAnimationControls ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "dimension-zone" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, dimensionLabel), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.display.defaultPosition, dimensionSelect), animationSwitch)) : ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, dimensionLabel, dimensionSelect)));
  }
  renderDimensionExtent(dimensionInfo, extent) {
    var _a;
    const startValues = [];
    const endValues = [];
    dimensionInfo.values.forEach((value) => {
      if (Array.isArray(value)) {
        if (value[1] <= extent[1]) {
          startValues.push(value);
        }
        if (value[0] >= extent[0]) {
          endValues.push(value);
        }
      }
      else {
        if (value < extent[1]) {
          startValues.push(value);
        }
        if (value > extent[0]) {
          endValues.push(value);
        }
      }
    });
    const isSliceMode = extent[1] === extent[0] ||
      (Array.isArray(dimensionInfo.values[0]) &&
        dimensionInfo.values.some((val) => val[0] === extent[0] && val[1] === extent[1]));
    const startInfo = isSliceMode
      ? dimensionInfo
      : Object.assign(Object.assign({}, dimensionInfo), { values: startValues });
    const startList = this.renderDimensionList(startInfo, {
      selectedValue: extent[0],
      sortable: false,
      key: dimensionInfo.name + "-start",
      onChange: (value) => this.updateExtentDimensionSubset(dimensionInfo.name, value, "start")
    });
    const endInfo = Object.assign(Object.assign({}, dimensionInfo), { values: endValues });
    const endList = this.renderDimensionList(endInfo, {
      selectedValue: isSliceMode ? undefined_dimension_value : extent[1],
      sortable: false,
      key: dimensionInfo.name + "-end",
      showEnd: true,
      onChange: (value) => this.updateExtentDimensionSubset(dimensionInfo.name, value, "end")
    });
    const { strings } = this;
    const dimensionLabel = dimensionInfo.name === "StdTime"
      ? strings.extent.stdTimeExtent
      : dimensionInfo.name === "StdZ"
        ? strings.extent.stdZExtent
        : strings.extent.generalExtent.replace("${dimensionName}", dimensionInfo.name);
    const allValues = dimensionInfo.values;
    const sliceCount = allValues.length;
    // using closure here, there's one slider per dimension, doesn't need to keep track of them at the compoennt level
    let sliderTarget;
    const onSliderChange = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.d)(() => {
      var _a;
      // evt.target is not the slider itself in case of onCalciteSliderChange (onCalciteSliderInput is not fired when drag middle of two thumbs)
      let start, end;
      if (Array.isArray(sliderTarget.value)) {
        start = allValues[sliderTarget.value[0]];
        end = allValues[(_a = sliderTarget.value[1]) !== null && _a !== void 0 ? _a : sliderTarget.value[0]];
      }
      else {
        start = end = allValues[sliderTarget.value];
      }
      const startValue = Array.isArray(start) ? start[0] : start;
      const endValue = Array.isArray(end) ? end[1] : end;
      this.updateExtentDimensionSubset(dimensionInfo.name, [startValue, endValue]);
    }, 100);
    let minIndex = 0;
    let maxIndex = sliceCount - 1;
    const dimExtent = (_a = this.activeMultidimensionalSubset.dimensions.find(({ name }) => name === dimensionInfo.name)) === null || _a === void 0 ? void 0 : _a.extent;
    if (dimExtent) {
      minIndex = allValues.findIndex((val) => (Array.isArray(val) ? val[0] : val) === dimExtent[0]);
      if (minIndex === -1) {
        minIndex = 0;
      }
      maxIndex = allValues.findIndex((val) => (Array.isArray(val) ? val[1] : val) === dimExtent[1]);
      if (maxIndex === -1) {
        maxIndex = sliceCount - 1;
      }
    }
    const slider = extent[0] === extent[1] ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: false, min: 0, max: sliceCount - 1, value: minIndex, step: 1, snap: true, labelTicks: false, ticks: sliceCount, onCalciteSliderInput: onSliderChange, onCalciteSliderChange: onSliderChange, ref: (node) => (sliderTarget = node) })) : ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: false, min: 0, max: sliceCount - 1, "min-value": minIndex, "max-value": maxIndex, step: 1, snap: true, labelTicks: false, ticks: sliceCount, onCalciteSliderInput: onSliderChange, onCalciteSliderChange: onSliderChange, ref: (node) => (sliderTarget = node) }));
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "dimension-zone" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, dimensionLabel), slider, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: this.useCompactExtentDropdowns
        ? "multidimensional-extent-compact"
        : "multidimensional-extent" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.start, startList)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.extent.end, endList)))));
  }
  renderClose() {
    const { strings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.general.close, icon: "x", slot: "header-actions-end", onClick: this.cancel, ref: (node) => {
        this.refCloseButtonNode = node;
      } }));
  }
  renderDoneButton() {
    const { strings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.apply, appearance: "solid", width: "half", label: strings.general.done }, strings.general.done));
  }
  renderCancelButton() {
    const { strings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", onClick: this.cancel, appearance: "outline-fill", width: "half", label: strings.general.cancel }, strings.general.cancel));
  }
  // --------------------------------------------------------------------------
  //
  //  Private methods
  //
  // --------------------------------------------------------------------------
  async initLayer(layer) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!layer) {
      return;
    }
    if (!layer.loaded) {
      await layer.load();
    }
    this.rawMultidimensionalInfo = await (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.a)(layer, true);
    if (!this.rawMultidimensionalInfo) {
      return;
    }
    const isDynamicImagery = this.isImageryLayer(layer);
    let functionName = "none";
    if (isDynamicImagery) {
      const multidimensionalInfo = (_a = (await (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.a)(layer))) !== null && _a !== void 0 ? _a : this.rawMultidimensionalInfo;
      const hasMultipleNewVariables = ((_b = multidimensionalInfo.variables) === null || _b === void 0 ? void 0 : _b.length) > 1 && this.hasNewVariable(multidimensionalInfo);
      // todo: variable a/b/c to d/e/f is NOT supported since it requires extracting (not selecting) a variable, no test case as well.
      this.multidimensionalInfo = hasMultipleNewVariables
        ? this.rawMultidimensionalInfo
        : multidimensionalInfo;
      functionName = (_c = layer.rasterFunction) === null || _c === void 0 ? void 0 : _c.functionName;
    }
    else {
      this.multidimensionalInfo = this.rawMultidimensionalInfo;
    }
    this.sourceKey = `${layer.url}-${functionName}`;
    this.allVariables = this.multidimensionalInfo.variables.map(({ name, unit, description, dimensions, statistics }) => ({
      name,
      label: unit ? `${name} (${unit})` : name,
      description,
      dimensionNames: dimensions.map(({ name }) => name).join(", "),
      statisticsRange: statistics === null || statistics === void 0 ? void 0 : statistics.map(({ min, max }) => [min, max].join(", ")).join("; ")
    }));
    // keep original setting
    const definition = this.getMultidimensionalDefinition(layer);
    const mosaicRule = isDynamicImagery ? (_d = layer.mosaicRule) === null || _d === void 0 ? void 0 : _d.clone() : null;
    const renderer = (_e = layer.renderer) === null || _e === void 0 ? void 0 : _e.clone();
    const subset = (_f = layer.multidimensionalSubset) === null || _f === void 0 ? void 0 : _f.clone();
    this.originalLayerSetting = {
      subset,
      mosaicRule,
      definition,
      renderer
    };
    // active subset and definitions
    this.activeMultidimensionalDefinition = this.esriLang.clone(this.originalLayerSetting.definition);
    let activeMultidimensionalSubset = null;
    if ((_h = (_g = layer.multidimensionalSubset) === null || _g === void 0 ? void 0 : _g.subsetDefinitions) === null || _h === void 0 ? void 0 : _h.length) {
      activeMultidimensionalSubset = layer.multidimensionalSubset;
      if (activeMultidimensionalSubset.variables.some((variableName) => !this.multidimensionalInfo.variables.some((variablInfo) => variablInfo.name === variableName))) {
        layer.multidimensionalSubset = null;
        this.originalLayerSetting.subset = null;
        activeMultidimensionalSubset = this.getDefaultMultidimensionalSubset();
      }
    }
    else {
      activeMultidimensionalSubset = this.getDefaultMultidimensionalSubset();
    }
    this.activeMultidimensionalSubset = activeMultidimensionalSubset;
    this.showAnimationOnStartUp && this.launchDimensionalSliders();
    if (this.watchViewTime && this.view && !this.watchHandleViewTime) {
      this.watchHandleViewTime = this.view.watch("timeExtent", this.updateExtentFromTime);
    }
    if (this.watchRasterFunction && !this.watchHandleLayer && isDynamicImagery) {
      this.watchHandleLayer = layer.watch("rasterFunction", (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.d)(async (newValue, oldValue) => {
        if ((newValue === null || newValue === void 0 ? void 0 : newValue.functionName) === (oldValue === null || oldValue === void 0 ? void 0 : oldValue.functionName)) {
          return;
        }
        const mdInfo = await (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.a)(layer);
        if (this.isPropertyValueChanged(mdInfo, this.multidimensionalInfo)) {
          this.closePopover();
          this.initLayer(layer);
        }
      }, 100));
    }
  }
  closePopover() {
    if (this.popOver) {
      document.body.removeChild(this.popOver);
      this.popOver = null;
    }
  }
  getMultidimensionalDefinition(layer) {
    const multidimensionalDefinition = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.c)(layer);
    if (multidimensionalDefinition === null || multidimensionalDefinition === void 0 ? void 0 : multidimensionalDefinition.length) {
      return multidimensionalDefinition;
    }
    return this.getNewMultidimensionalDefinition(this.allVariables[0].name);
  }
  getNewMultidimensionalDefinition(selectedVariableName) {
    var _a;
    const selectedVariableInfo = this.getVariableInfo(selectedVariableName);
    const dimensions = (_a = selectedVariableInfo.dimensions) !== null && _a !== void 0 ? _a : [];
    const selectedDimensionNames = dimensions.map((dimInfo) => dimInfo.name);
    const activeMultidimensionalDefinition = this.activeMultidimensionalDefinition || [];
    const newDef = this.esriLang.clone(activeMultidimensionalDefinition);
    const activeDimensionNames = activeMultidimensionalDefinition.map((def) => def.dimensionName);
    // handle special dimension-less case
    if (selectedDimensionNames.length === 0) {
      newDef.forEach((def) => {
        def.variableName = selectedVariableName;
        def.dimensionName = "";
        def.values = [];
        def.isSlice = true;
      });
      return newDef;
    }
    const isSameDimensionList = activeDimensionNames.length === selectedDimensionNames.length &&
      selectedDimensionNames.every((name) => activeDimensionNames.includes(name));
    if (isSameDimensionList) {
      newDef.forEach((def) => {
        def.variableName = selectedVariableName;
        const dimensionInfo = dimensions.find(({ name }) => name === def.dimensionName);
        (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.u)(def, dimensionInfo, this.activeMultidimensionalSubset);
      });
      return newDef;
    }
    newDef.length = 0;
    dimensions.forEach((dimensionInfo) => {
      var _a;
      let def = (_a = activeMultidimensionalDefinition
        .find((def) => def.dimensionName === dimensionInfo.name)) === null || _a === void 0 ? void 0 : _a.clone();
      if (def) {
        def.variableName = selectedVariableName;
      }
      else {
        const value = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.b)(dimensionInfo);
        def = new this.DimensionalDefinition({
          variableName: selectedVariableName,
          dimensionName: dimensionInfo.name,
          values: [value],
          isSlice: true
        });
      }
      (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.u)(def, dimensionInfo, this.activeMultidimensionalSubset);
      newDef.push(def);
    });
    return newDef;
  }
  isMultidimensionalDefinitionChanged(newDef) {
    return JSON.stringify(newDef) !== JSON.stringify(this.activeMultidimensionalDefinition);
  }
  launchDimensionalSliders() {
    var _a;
    this.destroyValuePicker("both");
    const { activeMultidimensionalDefinition, multidimensionalInfo } = this;
    const activeVariableName = activeMultidimensionalDefinition[0].variableName;
    const activeVariableInfo = (_a = multidimensionalInfo.variables.find(({ name }) => name === activeVariableName)) !== null && _a !== void 0 ? _a : multidimensionalInfo.variables[0];
    const timeDimension = activeVariableInfo.dimensions.find((dimensionInfo) => (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true));
    this.createValuePicker(timeDimension);
    const zDimension = activeVariableInfo.dimensions.find((dimensionInfo) => !(0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true));
    this.createValuePicker(zDimension);
  }
  destroyValuePicker(target) {
    var _a, _b, _c, _d;
    if (target === "time" || target === "both") {
      (_a = this.valuePickers.time) === null || _a === void 0 ? void 0 : _a.handle.remove();
      (_b = this.valuePickers.time) === null || _b === void 0 ? void 0 : _b.slider.destroy();
      this.valuePickers.time = null;
      this.animatedDimensions.time = "";
    }
    if (target === "z" || target === "both") {
      (_c = this.valuePickers.z) === null || _c === void 0 ? void 0 : _c.handle.remove();
      (_d = this.valuePickers.z) === null || _d === void 0 ? void 0 : _d.slider.destroy();
      this.valuePickers.z = null;
      this.animatedDimensions.z = "";
    }
  }
  createValueTicks(steps, count) {
    return Array.from({ length: count }, (_, i) => i === 0
      ? 0
      : i === count - 1
        ? steps.length - 1
        : Math.round((i * (steps.length - 1)) / (count - 1)));
  }
  createValuePicker(dimensionInfo) {
    var _a, _b, _c;
    if (!dimensionInfo || !this.showAnimationControls) {
      return;
    }
    // process dimensionInfo clipping
    if (this.activeMultidimensionalSubset) {
      dimensionInfo = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.g)(dimensionInfo, this.activeMultidimensionalSubset);
    }
    // only have a single instance of time or z value picker
    const isTime = (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.i)(dimensionInfo, true);
    const isZeroOrSingleSlice = dimensionInfo.values.length < 2;
    let prevValuePickerConfig = isTime ? this.valuePickers.time : this.valuePickers.z;
    if (isZeroOrSingleSlice ||
      (prevValuePickerConfig && prevValuePickerConfig.dimensionName !== dimensionInfo.name)) {
      this.destroyValuePicker(isTime ? "time" : "z");
      prevValuePickerConfig = null;
    }
    if (isZeroOrSingleSlice) {
      return;
    }
    // get picker parameters
    const activeDimensionValue = (_a = this.activeMultidimensionalDefinition.find(({ dimensionName }) => dimensionName === dimensionInfo.name)) === null || _a === void 0 ? void 0 : _a.values;
    const activeIndex = activeDimensionValue
      ? dimensionInfo.values.findIndex((value) => Array.isArray(value) && Array.isArray(activeDimensionValue[0])
        ? value.join() === activeDimensionValue.join()
        : value === activeDimensionValue[0])
      : 0;
    const dimValues = [...dimensionInfo.values];
    let lastDimValue = dimValues[dimValues.length - 1];
    if (Array.isArray(lastDimValue)) {
      lastDimValue = lastDimValue[lastDimValue.length - 1];
    }
    // API's default z layout is rising up: suitable when z dimension presents above-ground information
    // for ocean data, we need to reverse multiple places to "dive into the ocean"
    const reversed = !isTime && lastDimValue <= 0;
    const steps = dimValues.map((_val, i) => i);
    const stepCount = steps.length;
    // limit major ticks to 4 and avoid crowded minor ticks.
    const majorTicksCount = stepCount <= 4 ? 2 : isTime || stepCount <= 10 ? 3 : 4;
    const majorTicks = this.createValueTicks(steps, majorTicksCount);
    // align major tick to middle using 19: (1 + 9 * 2) for time, (1 + 6 * 3) for z
    const minorTicksCount = Math.min(19, stepCount > 19 ? Math.floor(stepCount / 2) : stepCount);
    const minorTicks = this.createValueTicks(steps, minorTicksCount);
    const labels = [...majorTicks];
    const formatter = (value, valueType) => {
      const index = reversed ? dimValues.length - 1 - value : value;
      return valueType === "tick"
        ? (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.f)(dimValues[index], dimensionInfo, {
          intl: this.intl,
          useRecurringTimeLabel: true,
          useFriendlyISOFormat: true,
          useStartOrEndForRangedValue: true
        })
        : (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_5__.f)(dimValues[index], dimensionInfo, {
          intl: this.intl,
          useRecurringTimeLabel: true,
          useFriendlyISOFormat: true,
          format: "short-date-long-time"
        });
    };
    // create and add to view ui
    const valuePickerDiv = document.createElement("div");
    const { animationSetting } = this;
    valuePickerDiv.classList.add(isTime ? animationSetting.timeClassName : animationSetting.zClassName);
    document.body.appendChild(valuePickerDiv);
    // guard for 0 or negative playrate. tiled imagery can use a shorter interval
    const playRate = animationSetting.playRate <= 0
      ? this.isImageryLayer(this.layer)
        ? 3000
        : 2000
      : animationSetting.playRate;
    // update or create value picker
    const component = {
      type: "slider",
      min: 0,
      max: dimValues.length - 1,
      steps,
      minorTicks,
      majorTicks,
      labels,
      reversed,
      visibleElements: {
        thumbTooltip: this.showAnimationTooltip
      },
      labelFormatFunction: formatter
    };
    const values = this.getSelectedSliderValue(activeIndex, reversed, dimValues.length);
    if (prevValuePickerConfig) {
      prevValuePickerConfig.handle.remove();
      const valuePicker = prevValuePickerConfig.slider;
      valuePicker.component = component;
      valuePicker.values = values;
      prevValuePickerConfig.dimensionValues = dimValues;
      prevValuePickerConfig.handle = valuePicker.watch("values", (v) => {
        const index = reversed ? dimValues.length - 1 - v[0] : v[0];
        this.updateDefinitionDimensionValue(dimensionInfo.name, dimValues[index]);
      });
      return;
    }
    const valuePicker = new this.ValuePicker({
      caption: dimensionInfo.name,
      layout: isTime ? "horizontal" : "vertical",
      container: valuePickerDiv,
      label: dimensionInfo.name,
      playRate,
      component,
      values
    });
    this.view.ui.add(valuePicker, { position: "manual" });
    const handle = valuePicker.watch("values", (v) => {
      const index = reversed ? dimValues.length - 1 - v[0] : v[0];
      this.updateDefinitionDimensionValue(dimensionInfo.name, dimValues[index]);
    });
    // avoid obstruction for horizontal value picker with default top placement
    const tooltipPlacement = isTime
      ? (_b = this.animationSetting.timeTooltipPlacement) !== null && _b !== void 0 ? _b : "top"
      : (_c = this.animationSetting.zTooltipPlacement) !== null && _c !== void 0 ? _c : "auto";
    if (tooltipPlacement !== "auto") {
      setTimeout(() => (valuePickerDiv.getElementsByTagName("calcite-tooltip")[0].placement = tooltipPlacement), 1000);
    }
    const pickerConfig = {
      slider: valuePicker,
      dimensionName: dimensionInfo.name,
      dimensionValues: dimValues,
      handle
    };
    if (isTime) {
      this.valuePickers.time = pickerConfig;
      this.animatedDimensions.time = dimensionInfo.name;
    }
    else {
      this.valuePickers.z = pickerConfig;
      this.animatedDimensions.z = dimensionInfo.name;
    }
  }
  updatePopoverProps() {
    const subsetVariables = this.activeMultidimensionalSubset.variables;
    // special case: do not update popover when all unselected
    if (this.previousPickedListSize === 0 &&
      subsetVariables.length === this.multidimensionalInfo.variables.length) {
      return;
    }
    const { allVariables, popOver } = this;
    popOver.selectedFields = subsetVariables;
    popOver.fields = allVariables.map((variable) => ({
      name: variable.name,
      alias: variable.name,
      type: "String",
      description: variable.description
    }));
    const threshold = allVariables[0].description ? 5 : 10;
    popOver.showFilterLength =
      this.showVariableFilter == null
        ? threshold
        : this.showVariableFilter
          ? 1
          : allVariables.length + 1;
  }
  getDefaultMultidimensionalSubset(variableNames) {
    // subset definitions
    const { variables } = this.multidimensionalInfo;
    const subsetDefinitions = [];
    for (let i = 0; i < variables.length; i++) {
      const { name: variableName, dimensions } = variables[i];
      if ((variableNames === null || variableNames === void 0 ? void 0 : variableNames.length) && !variableNames.includes(variableName)) {
        continue;
      }
      if (dimensions.length === 0) {
        subsetDefinitions.push({ variableName, dimensionName: "", values: [], isSlice: false });
      }
      else {
        for (let j = 0; j < dimensions.length; j++) {
          const dimensionName = dimensions[j].name;
          const values = [...dimensions[j].extent];
          subsetDefinitions.push({ variableName, dimensionName, values, isSlice: false });
        }
      }
    }
    return new this.MultidimensionalSubset({
      areaOfInterest: null,
      subsetDefinitions
    });
  }
  getVariableInfo(variableName) {
    var _a;
    const { variables } = this.multidimensionalInfo;
    return this.isDefaultUnspecifiedVariable(variableName)
      ? variables[0]
      : (_a = variables.find((info) => info.name === variableName)) !== null && _a !== void 0 ? _a : variables[0];
  }
  getSelectedSliderValue(dimIndex, reversed, count) {
    return [dimIndex === -1 ? 0 : reversed ? count - 1 - dimIndex : dimIndex];
  }
  isDefaultUnspecifiedVariable(variableName) {
    return ["", "*", this.strings.display.defaultVariable].includes(variableName);
  }
  isPropertyValueChanged(newValue, oldValue) {
    return JSON.stringify(newValue !== null && newValue !== void 0 ? newValue : undefined) !== JSON.stringify(oldValue !== null && oldValue !== void 0 ? oldValue : undefined);
  }
  hasNewVariable(multidimensionalInfo) {
    return multidimensionalInfo.variables.some((variableInfo) => !this.rawMultidimensionalInfo.variables.some((rawVariableInfo) => rawVariableInfo.name === variableInfo.name));
  }
  isImageryLayer(layer) {
    return layer.type === "imagery";
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "layer": ["watchLayer"],
    "activeMultidimensionalDefinition": ["watchActiveMultidimensionalDefinition"],
    "activeMultidimensionalSubset": ["watchactiveMultidimensionalSubset"]
  }; }
};
ArcgisRasterMultidimensional.style = arcgisRasterMultidimensionalCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-279ffd6e.js":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-279ffd6e.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getMultidimensionalInfo),
/* harmony export */   b: () => (/* binding */ getDefaultDimensionSliceValue),
/* harmony export */   c: () => (/* binding */ getMultidimensionalDefinition),
/* harmony export */   f: () => (/* binding */ formatDimensionValue),
/* harmony export */   g: () => (/* binding */ getClippedDimensionInfo),
/* harmony export */   i: () => (/* binding */ isTimeDimension),
/* harmony export */   m: () => (/* binding */ minVersionRFTMultidimensionalInfo),
/* harmony export */   u: () => (/* binding */ updateDimensionalDefinition)
/* harmony export */ });
/* harmony import */ var _commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonFunctions-5262b094.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-5262b094.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const minVersionRFTMultidimensionalInfo = 10.9;
function formatTime(value, options) {
  const date = new Date(value);
  const { useFriendlyISOFormat, intl, format } = options;
  if (useFriendlyISOFormat && intl) {
    return intl.formatDate(date, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(format !== null && format !== void 0 ? format : "short-date-long-time")), { timeZone: "UTC" }));
  }
  let isoTimeString = new Date(value).toISOString();
  isoTimeString = isoTimeString.slice(0, isoTimeString.indexOf(".")) + "Z";
  return isoTimeString;
}
function formatMonth(value_base1, intl, format = "long") {
  // using an arbitrary date (the day the code was written) to avoid side effects of setMonth near the end of the month
  // setMonth will move the date to the next month when new month doesn't have current date (e.g. 9/31, 2/30)
  // date = new Date(2002, 9, 31); date.setMonth(8); console.log(date.toLocaleDateString())
  const date = new Date(2022, 9, 10);
  date.setMonth(value_base1 - 1);
  return intl.formatDate(date, { month: format });
}
function formatQuarter(value_base1, intl) {
  const startMonth = formatMonth((value_base1 - 1) * 3 + 1, intl, "short");
  const endMonth = formatMonth(value_base1 * 3, intl, "short");
  return `${startMonth} - ${endMonth}`;
}
function formatDimensionValue(value, dimensionInfo, options = {}) {
  var _a, _b, _c, _d;
  if (value == null) {
    return "";
  }
  const { intl, useRecurringTimeLabel } = options;
  if (useRecurringTimeLabel && intl && !Array.isArray(value)) {
    const intervalUnit = (_a = dimensionInfo.intervalUnit) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim();
    // weekly and daily are not supported yet
    const canUseRecurringTimeLabel = isRecurringTimeDimension(dimensionInfo) && (intervalUnit === "months" || intervalUnit === "quarters");
    if (canUseRecurringTimeLabel) {
      return intervalUnit === "months" ? formatMonth(value, intl) : formatQuarter(value, intl);
    }
  }
  // this is prefered when labeling a slider alike control
  const lastElement = (_b = dimensionInfo.values) === null || _b === void 0 ? void 0 : _b[dimensionInfo.values.length - 1];
  if (options.useStartOrEndForRangedValue && Array.isArray(value) && value.length === 2 && Array.isArray(lastElement)) {
    const isLastElement = value.join("-") === lastElement.join("-");
    value = isLastElement ? value[1] : value[0];
  }
  const isTime = isTimeDimension(dimensionInfo);
  if (!isTime) {
    return Array.isArray(value)
      ? value.map((element) => { var _a; return (_a = intl === null || intl === void 0 ? void 0 : intl.formatNumber(element)) !== null && _a !== void 0 ? _a : String(element); }).join(" - ")
      : (_c = intl === null || intl === void 0 ? void 0 : intl.formatNumber(value)) !== null && _c !== void 0 ? _c : String(value);
  }
  if (options.useFriendlyISOFormat && !options.format) {
    let resolution = (_d = dimensionInfo.intervalUnit) === null || _d === void 0 ? void 0 : _d.toLowerCase().trim();
    let { interval, extent } = dimensionInfo;
    if (resolution === "months") {
      if (interval > 11) {
        resolution = "year";
      }
    }
    else if (resolution === "days") {
      if (interval > 364) {
        resolution = "year";
      }
      else if (interval > 27) {
        resolution = "months";
      }
    }
    else if (resolution === "hours") {
      resolution = "days";
    }
    if (!["years", "months", "days"].includes(resolution) && (extent === null || extent === void 0 ? void 0 : extent.length)) {
      const interval = (extent[1] - extent[0]) / dimensionInfo.values.length;
      const day = 86400000;
      if (interval >= 365 * day) {
        resolution = "years";
      }
      else if (interval >= 28 * day) {
        resolution = "months";
      }
    }
    const format = resolution === "years" ? "year" : resolution === "months" ? "short-month-year" : "short-date";
    options = Object.assign({ format }, options);
  }
  return Array.isArray(value)
    ? value.map((element) => formatTime(element, options)).join(" - ")
    : formatTime(value, options);
}
function getClippedDimensionInfo(dimensionInfo, multidimensionalSubset) {
  var _a;
  const constraint = (_a = multidimensionalSubset === null || multidimensionalSubset === void 0 ? void 0 : multidimensionalSubset.dimensions) === null || _a === void 0 ? void 0 : _a.find(({ name }) => name === dimensionInfo.name);
  if (!(constraint === null || constraint === void 0 ? void 0 : constraint.extent)) {
    return dimensionInfo;
  }
  const extent = [...constraint.extent];
  const values = dimensionInfo.values.filter((value) => {
    // must be contained, intersection is not sufficient
    if (Array.isArray(value)) {
      if (!(0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_0__.i)(extent[1]) || extent[0] === extent[1]) {
        return value[0] === extent[0];
      }
      return value[0] >= extent[0] && value[0] <= extent[1] && value[1] >= extent[0] && value[1] <= extent[1];
    }
    return value >= extent[0] && value <= extent[1];
  });
  // this is a special case, when last slice of a ranged dimension series is used
  if (values.length === 0) {
    const lastValue = dimensionInfo.values[dimensionInfo.values.length - 1];
    if (Array.isArray(lastValue) && lastValue[1] === extent[0]) {
      values.push(lastValue);
    }
  }
  return Object.assign(Object.assign({}, dimensionInfo), { extent, values });
}
function getDefaultDimensionSliceValue(dimensionInfo) {
  var _a;
  const { values, extent, name } = dimensionInfo;
  let value = (_a = values === null || values === void 0 ? void 0 : values[0]) !== null && _a !== void 0 ? _a : extent[0];
  if (name.toLowerCase() === "stdz" &&
    !dimensionInfo.hasRanges &&
    Math.abs(extent[1]) <= Math.abs(extent[0])) {
    if (values === null || values === void 0 ? void 0 : values.length) {
      value = values[values.length - 1];
    }
    else {
      value = extent[1];
    }
  }
  return value;
}
function getMultidimensionalDefinition(layer) {
  var _a, _b;
  return layer.type === "imagery-tile"
    ? layer.multidimensionalDefinition
    : (_b = ((_a = layer.mosaicRule) !== null && _a !== void 0 ? _a : layer._defaultServiceMosaicRule)) === null || _b === void 0 ? void 0 : _b.multidimensionalDefinition;
}
async function getMultidimensionalInfo(layer, useRawSourceInfo) {
  var _a, _b;
  if (layer.type === "imagery-tile") {
    return layer.rasterInfo.multidimensionalInfo;
  }
  const { rasterFunction, version } = layer;
  if (useRawSourceInfo ||
    version <= minVersionRFTMultidimensionalInfo ||
    !rasterFunction ||
    ((_a = rasterFunction.functionName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "none") {
    return layer.serviceRasterInfo.multidimensionalInfo;
  }
  const rasterInfo = (_b = (await layer.generateRasterInfo(layer.rasterFunction))) !== null && _b !== void 0 ? _b : layer.serviceRasterInfo;
  return rasterInfo.multidimensionalInfo;
}
function isTimeDimension(dimensionInfo, ignoreRecuring = false) {
  return dimensionInfo.name === "StdTime" && (ignoreRecuring || !dimensionInfo.recurring);
}
function isRecurringTimeDimension(dimensionInfo) {
  return dimensionInfo.name === "StdTime" && !!dimensionInfo.recurring;
}
function updateDimensionalDefinition(def, dimensionInfo, activeMultidimensionalSubset) {
  dimensionInfo = getClippedDimensionInfo(dimensionInfo, activeMultidimensionalSubset);
  const originalFormattedValue = formatDimensionValue(def.values[0], dimensionInfo);
  const hasOriginalFormattedValue = dimensionInfo.values.some((val) => originalFormattedValue === formatDimensionValue(val, dimensionInfo));
  if (!hasOriginalFormattedValue) {
    // get default slice value when def.values is invalid
    const value = getDefaultDimensionSliceValue(dimensionInfo);
    def.values = [value];
  }
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTgwNTc3YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7QUFDcEQ7QUFDYTtBQUNUO0FBQ3FCO0FBQzZOO0FBQ2xQO0FBQ2xDO0FBQ1k7O0FBRXZDLCtDQUErQyxhQUFhLGNBQWMsZ0JBQWdCLDBCQUEwQiwwQ0FBMEMsaUJBQWlCLGFBQWEsdUJBQXVCLDZCQUE2QixjQUFjLGlDQUFpQyxhQUFhLFdBQVcscUNBQXFDLFVBQVUsaURBQWlELGtCQUFrQiw4QkFBOEIsWUFBWSxnQkFBZ0IsYUFBYSwwQ0FBMEMsY0FBYyw0QkFBNEIsYUFBYSxXQUFXLG1CQUFtQiw4Q0FBOEMsWUFBWSw2Q0FBNkMsa0JBQWtCOztBQUV4dUI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBZ0I7QUFDcEIsOENBQThDLHFEQUFXO0FBQ3pELDRDQUE0QyxxREFBVztBQUN2RCw4Q0FBOEMscURBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRLHdJQUF3STtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOExBQThMLE1BQU07QUFDcE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CLGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtcmFzdGVyLW11bHRpZGltZW5zaW9uYWwuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMTNlMDBhNzUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbXVsdGlkaW1lbnNpb25hbC0yNzlmZmQ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcbmltcG9ydCB7IGQgYXMgZGVib3VuY2UgfSBmcm9tICcuL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMTNlMDBhNzUuanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYWFmMzBiZDYuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyLCBDIGFzIENTU19VVElMSVRZIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0IHsgbSBhcyBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8sIGcgYXMgZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8sIGYgYXMgZm9ybWF0RGltZW5zaW9uVmFsdWUsIGEgYXMgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8sIHUgYXMgdXBkYXRlRGltZW5zaW9uYWxEZWZpbml0aW9uLCBiIGFzIGdldERlZmF1bHREaW1lbnNpb25TbGljZVZhbHVlLCBpIGFzIGlzVGltZURpbWVuc2lvbiwgYyBhcyBnZXRNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiB9IGZyb20gJy4vbXVsdGlkaW1lbnNpb25hbC0yNzlmZmQ2ZS5qcyc7XG5pbXBvcnQgeyBMIGFzIExhc3RTb3J0eUJ5IH0gZnJvbSAnLi9jb21tb25FbnVtcy1mOThhMzIzYy5qcyc7XG5pbXBvcnQgJy4vZG9tLTEzZjViMDBjLmpzJztcbmltcG9ydCAnLi9jb21tb25GdW5jdGlvbnMtNTI2MmIwOTQuanMnO1xuXG5jb25zdCBhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleDoxIDEgYXV0bztvdmVyZmxvdzpoaWRkZW59LnZhcmlhYmxlLXNlY3Rpb24tYm9hcmRlcntib3JkZXI6MXB4IHNvbGlkIHZhcigtLWFyY2dpcy1hcHAtYm9yZGVyKX0udmFyaWFibGUtc2VsZWN0e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5tdWx0aWRpbWVuc2lvbmFsLWV4dGVudD5kaXZ7bWFyZ2luOjEwcHggMH0ubXVsdGlkaW1lbnNpb25hbC1leHRlbnQtY29tcGFjdHtkaXNwbGF5OmZsZXg7d2lkdGg6MTAwJX0ubXVsdGlkaW1lbnNpb25hbC1leHRlbnQtY29tcGFjdD5kaXZ7d2lkdGg6NTAlfS5tdWx0aWRpbWVuc2lvbmFsLWV4dGVudC1jb21wYWN0PmRpdjpmaXJzdC1jaGlsZHttYXJnaW46MCAyMHB4IDAgMH0ubXVsdGlkaW1lbnNpb25hbC11bnN1cHBvcnRlZHttYXJnaW46MjBweH0uZGltZW5zaW9uLXpvbmV7cGFkZGluZzoxMHB4O2JvcmRlcjoxcHggc29saWQgdmFyKC0tYXJjZ2lzLWFwcC1ib3JkZXIpO21hcmdpbjoxMHB4IDB9LmRpbWVuc2lvbi1zZWxlY3QtY29udGFpbmVye2Rpc3BsYXk6ZmxleDt3aWR0aDoxMDAlO2FsaWduLWl0ZW1zOmNlbnRlcn0uZGltZW5zaW9uLXNlbGVjdC1jb250YWluZXIgLmRpbWVuc2lvbi1zZWxlY3R7ZmxleC1ncm93OjF9LmFyY2dpcy0tcnRsIC5leHRlbnQtY29tcGFjdD5kaXY6Zmlyc3QtY2hpbGR7bWFyZ2luOjAgMCAwIDIwcHh9XCI7XG5cbmNvbnN0IHVuZGVmaW5lZF9kaW1lbnNpb25fdmFsdWUgPSBOdW1iZXIuTUFYX1ZBTFVFIC0gMTtcbmNvbnN0IEFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbENoYW5nZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxTYXZlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsU2F2ZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxDYW5jZWwgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxDYW5jZWxcIiwgNyk7XG4gICAgdGhpcy52YWx1ZVBpY2tlcnMgPSB7XG4gICAgICB0aW1lOiBudWxsLFxuICAgICAgejogbnVsbFxuICAgIH07XG4gICAgdGhpcy5jb250YWluZXJUb3AgPSAwO1xuICAgIHRoaXMuYW9pSW5kZXggPSAwO1xuICAgIHRoaXMucHJldmlvdXNQaWNrZWRMaXN0U2l6ZSA9IC0xO1xuICAgIHRoaXMucGF1c2VMYXllclVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuYXBwbHkgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vcmlnaW5hbExheWVyU2V0dGluZy5kZWZpbml0aW9uID0gdGhpcy5lc3JpTGFuZy5jbG9uZSh0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKTtcbiAgICAgIHRoaXMub3JpZ2luYWxMYXllclNldHRpbmcuc3Vic2V0ID0gdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmNsb25lKCk7XG4gICAgICBjb25zdCB7IGxheWVyIH0gPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaXNJbWFnZXJ5TGF5ZXIobGF5ZXIpKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxMYXllclNldHRpbmcubW9zYWljUnVsZSA9IChfYSA9IGxheWVyLm1vc2FpY1J1bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1ha2VMaXZlTGF5ZXJVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVMYXllck11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGF5ZXJNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgdGhpcy5hcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsU2F2ZS5lbWl0KCk7XG4gICAgfTtcbiAgICB0aGlzLmNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGxheWVyLCBvcmlnaW5hbExheWVyU2V0dGluZyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmVzcmlMYW5nLmNsb25lKG9yaWdpbmFsTGF5ZXJTZXR0aW5nLmRlZmluaXRpb24pO1xuICAgICAgY29uc3Qgc3Vic2V0ID0gdGhpcy5lc3JpTGFuZy5jbG9uZShvcmlnaW5hbExheWVyU2V0dGluZy5zdWJzZXQpO1xuICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGVXaGVuQ2FuY2VsKSB7XG4gICAgICAgIHRoaXMucGF1c2VMYXllclVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IHN1YnNldCAhPT0gbnVsbCAmJiBzdWJzZXQgIT09IHZvaWQgMCA/IHN1YnNldCA6IHRoaXMuZ2V0RGVmYXVsdE11bHRpZGltZW5zaW9uYWxTdWJzZXQoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgIHRoaXMucGF1c2VMYXllclVwZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNJbWFnZXJ5TGF5ZXIobGF5ZXIpKSB7XG4gICAgICAgIGxheWVyLm1vc2FpY1J1bGUgPSBvcmlnaW5hbExheWVyU2V0dGluZy5tb3NhaWNSdWxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxheWVyLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgIH1cbiAgICAgIGxheWVyLnJlbmRlcmVyID0gb3JpZ2luYWxMYXllclNldHRpbmcucmVuZGVyZXI7XG4gICAgICBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gc3Vic2V0O1xuICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgIHRoaXMuYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbENhbmNlbC5lbWl0KCk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZURlZmluaXRpb25EaW1lbnNpb25WYWx1ZSA9IChzZWxlY3RlZERpbWVuc2lvbk5hbWUsIHZhbHVlLCB1cGRhdGVWYWx1ZVBpY2tlciA9IGZhbHNlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgbmV3RGVmID0gdGhpcy5lc3JpTGFuZy5jbG9uZSh0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRGVmID0gbmV3RGVmLmZpbmQoKHsgZGltZW5zaW9uTmFtZSB9KSA9PiBkaW1lbnNpb25OYW1lID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWUpO1xuICAgICAgc2VsZWN0ZWREZWYudmFsdWVzID0gW3ZhbHVlXTtcbiAgICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPSBuZXdEZWY7XG4gICAgICBpZiAoIXVwZGF0ZVZhbHVlUGlja2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGZpbmQgdGhlIG1hdGNoaW5nIHZhbHVlIHBpY2tlclxuICAgICAgY29uc3QgeyB2YWx1ZVBpY2tlcnMgfSA9IHRoaXM7XG4gICAgICBjb25zdCB2YWx1ZVBpY2tlciA9ICgoX2EgPSB2YWx1ZVBpY2tlcnMudGltZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpbWVuc2lvbk5hbWUpID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWVcbiAgICAgICAgPyB2YWx1ZVBpY2tlcnMudGltZVxuICAgICAgICA6ICgoX2IgPSB2YWx1ZVBpY2tlcnMueikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpbWVuc2lvbk5hbWUpID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWVcbiAgICAgICAgICA/IHZhbHVlUGlja2Vycy56XG4gICAgICAgICAgOiBudWxsO1xuICAgICAgaWYgKHZhbHVlUGlja2VyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdmFsdWVQaWNrZXIuZGltZW5zaW9uVmFsdWVzLmZpbmRJbmRleCgoZGltVmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkoZGltVmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS5qb2luKFwiLVwiKSA9PT0gZGltVmFsdWUuam9pbihcIi1cIilcbiAgICAgICAgICA6IHZhbHVlID09PSBkaW1WYWx1ZSk7XG4gICAgICAgIHZhbHVlUGlja2VyLnNsaWRlci52YWx1ZXMgPSB0aGlzLmdldFNlbGVjdGVkU2xpZGVyVmFsdWUoaW5kZXgsIHZhbHVlUGlja2VyLnNsaWRlci5jb21wb25lbnQucmV2ZXJzZWQsIHZhbHVlUGlja2VyLmRpbWVuc2lvblZhbHVlcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51cGRhdGVEZWZpbml0aW9uVmFyaWFibGVOYW1lID0gKHZhcmlhYmxlTmFtZSkgPT4ge1xuICAgICAgLy8gbm9ybWFsaXplIGVtcHR5IHZhcmlhYmxlIG5hbWUgKDMueCksICogKHJmdCByZXN1bHQpLCBkZWZhdWx0IHZhcmlhYmxlIHN0cmluZyBVSVxuICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0VW5zcGVjaWZpZWRWYXJpYWJsZSh2YXJpYWJsZU5hbWUpKSB7XG4gICAgICAgIHZhcmlhYmxlTmFtZSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdEZWYgPSB0aGlzLmdldE5ld011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKHZhcmlhYmxlTmFtZSk7XG4gICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gbmV3RGVmO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVFeHRlbnREaW1lbnNpb25TdWJzZXQgPSAoc2VsZWN0ZWREaW1lbnNpb25OYW1lLCB2YWx1ZU9yRXh0ZW50LCByZXBsYWNlQm90aCA9IFwiYm90aFwiKSA9PiB7XG4gICAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgfSA9IHRoaXM7XG4gICAgICBjb25zdCBkaW0gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmRpbWVuc2lvbnMuZmluZCgoZGltZW5zaW9uKSA9PiBkaW1lbnNpb24ubmFtZSA9PT0gc2VsZWN0ZWREaW1lbnNpb25OYW1lKTtcbiAgICAgIGNvbnN0IGRpbUV4dGVudCA9IFsuLi5kaW0uZXh0ZW50XTtcbiAgICAgIGlmIChyZXBsYWNlQm90aCA9PT0gXCJib3RoXCIpIHtcbiAgICAgICAgLy8gYXZvaWQgdXBkYXRpbmcgd2hlbiBleGlzdGluZyB2YWx1ZSBtYXRjaGVzIG5ldyB2YWx1ZVxuICAgICAgICBpZiAoZGltRXh0ZW50WzBdID09PSB2YWx1ZU9yRXh0ZW50WzBdICYmIGRpbUV4dGVudFsxXSA9PT0gdmFsdWVPckV4dGVudFsxXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBbZGltRXh0ZW50WzBdLCBkaW1FeHRlbnRbMV1dID0gdmFsdWVPckV4dGVudDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlcGxhY2VCb3RoID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgbGV0IHdhc05vdFJhbmdlID0gZGltRXh0ZW50WzFdID09PSBkaW1FeHRlbnRbMF07XG4gICAgICAgIGRpbUV4dGVudFswXSA9IEFycmF5LmlzQXJyYXkodmFsdWVPckV4dGVudCkgPyB2YWx1ZU9yRXh0ZW50WzBdIDogdmFsdWVPckV4dGVudDtcbiAgICAgICAgaWYgKHdhc05vdFJhbmdlKSB7XG4gICAgICAgICAgZGltRXh0ZW50WzFdID0gZGltRXh0ZW50WzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlT3JFeHRlbnQgPT09IHVuZGVmaW5lZF9kaW1lbnNpb25fdmFsdWUpIHtcbiAgICAgICAgICBkaW1FeHRlbnRbMV0gPSBkaW1FeHRlbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGltRXh0ZW50WzFdID0gQXJyYXkuaXNBcnJheSh2YWx1ZU9yRXh0ZW50KVxuICAgICAgICAgICAgPyB2YWx1ZU9yRXh0ZW50W3ZhbHVlT3JFeHRlbnQubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIDogdmFsdWVPckV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpbUV4dGVudFsxXSA8IGRpbUV4dGVudFswXSB8fCBkaW1FeHRlbnRbMV0gPT0gbnVsbCkge1xuICAgICAgICBkaW1FeHRlbnRbMV0gPSBkaW1FeHRlbnRbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdBY3RpdmVTdWJzZXQgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmNsb25lKCk7XG4gICAgICBjb25zdCB7IHN1YnNldERlZmluaXRpb25zIH0gPSBuZXdBY3RpdmVTdWJzZXQ7XG4gICAgICBzdWJzZXREZWZpbml0aW9ucy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgaWYgKGRlZi5kaW1lbnNpb25OYW1lID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWUpIHtcbiAgICAgICAgICBkZWYudmFsdWVzID0gW2RpbUV4dGVudFswXSwgZGltRXh0ZW50WzFdXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBuZXdBY3RpdmVTdWJzZXQ7XG4gICAgICBjb25zdCB7IGFuaW1hdGVkRGltZW5zaW9ucyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGhhc1RpbWVQaWNrZXIgPSBhbmltYXRlZERpbWVuc2lvbnMudGltZSA9PT0gc2VsZWN0ZWREaW1lbnNpb25OYW1lO1xuICAgICAgY29uc3QgaGFzWlBpY2tlciA9IGFuaW1hdGVkRGltZW5zaW9ucy56ID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWU7XG4gICAgICBpZiAoaGFzVGltZVBpY2tlciB8fCBoYXNaUGlja2VyKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlSW5mbyA9IHRoaXMuZ2V0VmFyaWFibGVJbmZvKHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25bMF0udmFyaWFibGVOYW1lKTtcbiAgICAgICAgY29uc3QgZGltSW5mbyA9IHZhcmlhYmxlSW5mbyA9PT0gbnVsbCB8fCB2YXJpYWJsZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhcmlhYmxlSW5mby5kaW1lbnNpb25zLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBzZWxlY3RlZERpbWVuc2lvbk5hbWUpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbHVlUGlja2VyKGRpbUluZm8pO1xuICAgICAgICAvLyB3aGVuIHRoZXJlJ3Mgc2luZ2xlIG9yIDAgKGNhbiBpdCBiZSAwPykgc2xpY2VzLCBrZWVwIGVuYWJsZWQgc3RhdGUgYXMgaXQncyBjbGlwcGVkIGJ5IGV4dGVudFxuICAgICAgICBpZiAoaGFzVGltZVBpY2tlcikge1xuICAgICAgICAgIGFuaW1hdGVkRGltZW5zaW9ucy50aW1lID0gc2VsZWN0ZWREaW1lbnNpb25OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGVkRGltZW5zaW9ucy56ID0gc2VsZWN0ZWREaW1lbnNpb25OYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUV4dGVudFZhcmlhYmxlcyA9IChzZWxlY3RlZFZhcmlhYmxlcykgPT4ge1xuICAgICAgbGV0IHsgYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCB9ID0gdGhpcztcbiAgICAgIGlmIChzZWxlY3RlZFZhcmlhYmxlcy5sZW5ndGggJiZcbiAgICAgICAgYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC52YXJpYWJsZXMubGVuZ3RoICYmXG4gICAgICAgIHNlbGVjdGVkVmFyaWFibGVzLmpvaW4oXCIsXCIpID09PSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnZhcmlhYmxlcy5qb2luKFwiLFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZpb3VzUGlja2VkTGlzdFNpemUgPSBzZWxlY3RlZFZhcmlhYmxlcy5sZW5ndGg7XG4gICAgICBpZiAoc2VsZWN0ZWRWYXJpYWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGVjdGVkVmFyaWFibGVzID0gdGhpcy5hbGxWYXJpYWJsZXMubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSk7XG4gICAgICB9XG4gICAgICAvLyBzdGFydCB3dGloIGRlZmF1bHQgZGltZW5zaW9ucywgdXNlIGV4aXN0aW5nIGRlZmluaXRpb24gd2hlbiBleGlzdCwgcmVtb3ZlIGRpbWVuc2lvbnMgdGhhdCBhcmUgbm8gbG9uZ2VyIHBhcnQgb2Ygc2VsZWN0ZWQgdmFyaWFibGVzXG4gICAgICBjb25zdCBzZWxlY3RlZERlZmF1bHRTdWJzZXQgPSB0aGlzLmdldERlZmF1bHRNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KHNlbGVjdGVkVmFyaWFibGVzKTtcbiAgICAgIGNvbnN0IHsgc3Vic2V0RGVmaW5pdGlvbnMgfSA9IHNlbGVjdGVkRGVmYXVsdFN1YnNldC5jbG9uZSgpO1xuICAgICAgc3Vic2V0RGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmYXVsdERlZikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0RlZmluaXRpb24gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnN1YnNldERlZmluaXRpb25zLmZpbmQoKGRlZikgPT4gZGVmLnZhcmlhYmxlTmFtZSA9PT0gZGVmYXVsdERlZi52YXJpYWJsZU5hbWUgJiZcbiAgICAgICAgICBkZWYuZGltZW5zaW9uTmFtZSA9PT0gZGVmYXVsdERlZi5kaW1lbnNpb25OYW1lKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nRGVmaW5pdGlvbikge1xuICAgICAgICAgIGRlZmF1bHREZWYudmFsdWVzID0gbWF0Y2hpbmdEZWZpbml0aW9uLnZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGluZ0RpbWVuc2lvbkV4dGVudCA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQuZGltZW5zaW9ucy5maW5kKChkaW1lbnNpb24pID0+IGRpbWVuc2lvbi5uYW1lID09PSBkZWZhdWx0RGVmLmRpbWVuc2lvbk5hbWUpO1xuICAgICAgICAgIGlmIChtYXRjaGluZ0RpbWVuc2lvbkV4dGVudCkge1xuICAgICAgICAgICAgZGVmYXVsdERlZi52YWx1ZXMgPSBbLi4ubWF0Y2hpbmdEaW1lbnNpb25FeHRlbnQuZXh0ZW50XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV3QXRpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5jbG9uZSgpO1xuICAgICAgbmV3QXRpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnN1YnNldERlZmluaXRpb25zID0gc3Vic2V0RGVmaW5pdGlvbnM7XG4gICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBuZXdBdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQ7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUV4dGVudEFPSSA9IChhb2kpID0+IHtcbiAgICAgIGNvbnN0IG5ld0F0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5jbG9uZSgpO1xuICAgICAgbmV3QXRpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmFyZWFPZkludGVyZXN0ID0gYW9pID09PSBudWxsIHx8IGFvaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW9pLmNsb25lKCk7XG4gICAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBuZXdBdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQ7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUV4dGVudEZyb21UaW1lID0gKHRpbWVFeHRlbnQpID0+IHtcbiAgICAgIGlmICghdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcmlnaW5hbERlZiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUodGhpcy5vcmlnaW5hbExheWVyU2V0dGluZy5kZWZpbml0aW9uKTtcbiAgICAgIC8vIHRvZG8gZXhwb3NlIHRoaXMgYSB1dGlsdHkgZnVuY3Rpb24gaW4gQVBJXG4gICAgICBjb25zdCB7IG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uOiBuZXdEZWYgfSA9IHRoaXMubGF5ZXIubm9ybWFsaXplUmFzdGVyRmV0Y2hPcHRpb25zKHtcbiAgICAgICAgbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb246IG9yaWdpbmFsRGVmLFxuICAgICAgICB0aW1lRXh0ZW50XG4gICAgICB9KTtcbiAgICAgIGlmIChuZXdEZWYgJiYgdGhpcy5pc1Byb3BlcnR5VmFsdWVDaGFuZ2VkKG5ld0RlZiwgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbikpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IG5ld0RlZjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlU29ydGluZyA9IChkaW1lbnNpb25OYW1lKSA9PiB7XG4gICAgICAvLyBub3QgaW5pdGlhbGl6ZWQgKHVuZGVmaW5lZCkgd2lsbCBiZSBjaGFuZ2VkIHRvIGRlc2NlbmRpbmdcbiAgICAgIGNvbnN0IHNvcnREaXJlY3Rpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zb3J0RGlyZWN0aW9ucyk7XG4gICAgICBzb3J0RGlyZWN0aW9uc1tkaW1lbnNpb25OYW1lXSA9XG4gICAgICAgIHNvcnREaXJlY3Rpb25zW2RpbWVuc2lvbk5hbWVdID09PSBcImRlc2NlbmRpbmdcIiA/IFwiYXNjZW5kaW5nXCIgOiBcImRlc2NlbmRpbmdcIjtcbiAgICAgIHRoaXMuc29ydERpcmVjdGlvbnMgPSBzb3J0RGlyZWN0aW9ucztcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlTGF5ZXJNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgY29uc3QgeyBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiwgbGF5ZXIgfSA9IHRoaXM7XG4gICAgICBjb25zdCBpc0R5bmFtaWNJbWFnZXJ5ID0gdGhpcy5pc0ltYWdlcnlMYXllcihsYXllcik7XG4gICAgICBjb25zdCBpc0RlZmluaXRpb25DaGFuZ2VkID0gaXNEeW5hbWljSW1hZ2VyeVxuICAgICAgICA/IHRoaXMuaXNQcm9wZXJ0eVZhbHVlQ2hhbmdlZChhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiwgKF9hID0gbGF5ZXIubW9zYWljUnVsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKVxuICAgICAgICA6IHRoaXMuaXNQcm9wZXJ0eVZhbHVlQ2hhbmdlZChhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiwgbGF5ZXIubXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24pO1xuICAgICAgaWYgKCFpc0RlZmluaXRpb25DaGFuZ2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZERlZmluaXRpb24gPSB0aGlzLmdldE11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKGxheWVyKTtcbiAgICAgIGNvbnN0IGlzVmFyaWFibGVDaGFuZ2VkID0gIW9sZERlZmluaXRpb24gfHxcbiAgICAgICAgb2xkRGVmaW5pdGlvbi5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgb2xkRGVmaW5pdGlvblswXS52YXJpYWJsZU5hbWUgIT09IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uWzBdLnZhcmlhYmxlTmFtZTtcbiAgICAgIGlmIChpc0R5bmFtaWNJbWFnZXJ5KSB7XG4gICAgICAgIGNvbnN0IG1vc2FpY1J1bGUgPSAoKF9iID0gbGF5ZXIubW9zYWljUnVsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbGF5ZXIuZGVmYXVsdE1vc2FpY1J1bGUpLmNsb25lKCk7XG4gICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdFVuc3BlY2lmaWVkVmFyaWFibGUoYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25bMF0udmFyaWFibGVOYW1lKSkge1xuICAgICAgICAgIGNvbnN0IG5ld0RlZmluaXRpb24gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5tYXAoKGRlZikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3RGVmID0gZGVmLmNsb25lKCk7XG4gICAgICAgICAgICBuZXdEZWYudmFyaWFibGVOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBuZXdEZWY7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbW9zYWljUnVsZS5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IG5ld0RlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbW9zYWljUnVsZS5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLm1vc2FpY1J1bGUgPSBtb3NhaWNSdWxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxheWVyLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNWYXJpYWJsZUNoYW5nZWQpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVJbmZvID0gdGhpcy5nZXRWYXJpYWJsZUluZm8oYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25bMF0udmFyaWFibGVOYW1lKTtcbiAgICAgICAgY29uc3QgeyByZW5kZXJlciB9ID0gbGF5ZXI7XG4gICAgICAgIGlmICgocmVuZGVyZXIgPT09IG51bGwgfHwgcmVuZGVyZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlcmVyLnR5cGUpID09PSBcInJhc3Rlci1zdHJldGNoXCIgJiYgKChfYyA9IHZhcmlhYmxlSW5mby5zdGF0aXN0aWNzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSkge1xuICAgICAgICAgIGNvbnN0IG5ld1JlbmRlcmVyID0gcmVuZGVyZXIuY2xvbmUoKTtcbiAgICAgICAgICBuZXdSZW5kZXJlci5zdGF0aXN0aWNzID0gdmFyaWFibGVJbmZvLnN0YXRpc3RpY3MubWFwKChzdGF0cykgPT4gKE9iamVjdC5hc3NpZ24oe30sIHN0YXRzKSkpO1xuICAgICAgICAgIGxheWVyLnJlbmRlcmVyID0gbmV3UmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICAgIHRoaXMudXBkYXRlTGF5ZXJNdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgY29uc3QgeyBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LCBsYXllciB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGZ1bGxEaW1lbnNpb25hbFN1YnNldCA9IHRoaXMuZ2V0RGVmYXVsdE11bHRpZGltZW5zaW9uYWxTdWJzZXQoKTtcbiAgICAgIC8vIHRoaXMgaXMgYSBzaW1wbGUgY29tcGFyaXNvbiAodG8gZGVmYXVsdCkgdG8gb3B0aW1pemUgcGVyc2lzdGVkIGxheWVyJ3Mgc2l6ZVxuICAgICAgLy8gaXQgZG9lcyBubyBoYXJtIGlmIGEgY3VzdG9tIGxheWVyIGNvbnRhaW5zIGRlZmluaXRpb25zIHdpdGggYWx0ZXJlZCB2YXJpYWJsZSBvcmRlci5cbiAgICAgIGNvbnN0IGlzU3Vic2V0RGVmaW5pdGlvbnNTcGVjaWZpZWQgPSB0aGlzLmlzUHJvcGVydHlWYWx1ZUNoYW5nZWQoYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5zdWJzZXREZWZpbml0aW9ucywgZnVsbERpbWVuc2lvbmFsU3Vic2V0LnN1YnNldERlZmluaXRpb25zKTtcbiAgICAgIGNvbnN0IGlzQU9JU3BlY2lmaWVkID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5hcmVhT2ZJbnRlcmVzdCAhPSBudWxsO1xuICAgICAgaWYgKCFpc1N1YnNldERlZmluaXRpb25zU3BlY2lmaWVkICYmICFpc0FPSVNwZWNpZmllZCkge1xuICAgICAgICBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWlzU3Vic2V0RGVmaW5pdGlvbnNTcGVjaWZpZWQpIHtcbiAgICAgICAgICBjb25zdCBuZXdTdWJzZXQgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmNsb25lKCk7XG4gICAgICAgICAgbmV3U3Vic2V0LnN1YnNldERlZmluaXRpb25zID0gW107XG4gICAgICAgICAgbGF5ZXIubXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IG5ld1N1YnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gICAgdGhpcy5oaWRlUGFuZWxIZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYW5lbEhlYWRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNtaXNzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaGlkZUJ1dHRvbnMgPSBmYWxzZTtcbiAgICB0aGlzLmhpZGVFeHRlbnRTZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5oaWRlQU9JID0gZmFsc2U7XG4gICAgdGhpcy5pc0RpbWVuc2lvbkxpc3RTb3J0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY29sbGFwc2VFeHRlbnRTZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy51c2VDb21wYWN0RXh0ZW50RHJvcGRvd25zID0gZmFsc2U7XG4gICAgdGhpcy5zaG93VmFyaWFibGVGaWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53YXRjaFZpZXdUaW1lID0gZmFsc2U7XG4gICAgdGhpcy53YXRjaFJhc3RlckZ1bmN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTdGF0ZVdoZW5DYW5jZWwgPSB0cnVlO1xuICAgIHRoaXMubWFrZUxpdmVMYXllclVwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5zaG93QW5pbWF0aW9uQ29udHJvbHMgPSBmYWxzZTtcbiAgICB0aGlzLnNob3dBbmltYXRpb25PblN0YXJ0VXAgPSBmYWxzZTtcbiAgICB0aGlzLnNob3dBbmltYXRpb25Ub29sdGlwID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25TZXR0aW5nID0ge1xuICAgICAgcGxheVJhdGU6IDMwMDAsXG4gICAgICB0aW1lQ2xhc3NOYW1lOiBcImltYWdlcnktZGltZW5zaW9uLXBpY2tlci10XCIsXG4gICAgICB6Q2xhc3NOYW1lOiBcImltYWdlcnktZGltZW5zaW9uLXBpY2tlci16XCIsXG4gICAgICB0aW1lVG9vbHRpcFBsYWNlbWVudDogXCJ0b3BcIixcbiAgICAgIHpUb29sdGlwUGxhY2VtZW50OiBcImF1dG9cIlxuICAgIH07XG4gICAgdGhpcy5sYXllciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZpZXcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNvcnREaXJlY3Rpb25zID0ge307XG4gICAgdGhpcy5hbmltYXRlZERpbWVuc2lvbnMgPSB7IHRpbWU6IFwiXCIsIHo6IFwiXCIgfTtcbiAgfVxuICB3YXRjaExheWVyKG5ld1ZhbHVlLCBfb2xkVmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IG51bGw7XG4gICAgKF9hID0gdGhpcy53YXRjaEhhbmRsZVZpZXdUaW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgdGhpcy53YXRjaEhhbmRsZUxheWVyID0gbnVsbDtcbiAgICAoX2IgPSB0aGlzLndhdGNoSGFuZGxlTGF5ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmUoKTtcbiAgICB0aGlzLndhdGNoSGFuZGxlTGF5ZXIgPSBudWxsO1xuICAgIHRoaXMuaW5pdExheWVyKG5ld1ZhbHVlKTtcbiAgfVxuICB3YXRjaEFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIC8vIG9sZFZhbHVlIGlzIG51bGwgZHVyaW5nIGluaXRpYWxpemF0aW9uLCBuZXdWYWx1ZSBjYW4ndCBiZSBudWxsXG4gICAgaWYgKG5ld1ZhbHVlID09IG51bGwgfHwgb2xkVmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNvcnREaXJlY3Rpb25zID0ge307XG4gICAgaWYgKCF0aGlzLnBhdXNlTGF5ZXJVcGRhdGUgJiYgdGhpcy5tYWtlTGl2ZUxheWVyVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5hcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2hhbmdlLmVtaXQoe1xuICAgICAgbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb246IG5ld1ZhbHVlXG4gICAgfSk7XG4gICAgLy8gZGVzdHJveSB2YWx1ZSBwaWNrZXIgd2hlbiB0aGUgY29ycmVzcG9uZGluZyBkaW1lbnNpb24gZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBuZXcgdmFyaWFibGVcbiAgICBjb25zdCB7IGFuaW1hdGVkRGltZW5zaW9ucywgc2hvd0FuaW1hdGlvbkNvbnRyb2xzIH0gPSB0aGlzO1xuICAgIGlmIChzaG93QW5pbWF0aW9uQ29udHJvbHMgJiZcbiAgICAgIChhbmltYXRlZERpbWVuc2lvbnMudGltZSB8fCBhbmltYXRlZERpbWVuc2lvbnMueikgJiZcbiAgICAgIG5ld1ZhbHVlWzBdLnZhcmlhYmxlTmFtZSAhPT0gb2xkVmFsdWVbMF0udmFyaWFibGVOYW1lKSB7XG4gICAgICBjb25zdCB2YXJpYWJsZUluZm8gPSB0aGlzLmdldFZhcmlhYmxlSW5mbyhuZXdWYWx1ZVswXS52YXJpYWJsZU5hbWUpO1xuICAgICAgaWYgKCF2YXJpYWJsZUluZm8uZGltZW5zaW9ucy5zb21lKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gYW5pbWF0ZWREaW1lbnNpb25zLnRpbWUpKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVZhbHVlUGlja2VyKFwidGltZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFyaWFibGVJbmZvLmRpbWVuc2lvbnMuc29tZSgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGFuaW1hdGVkRGltZW5zaW9ucy56KSkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lWYWx1ZVBpY2tlcihcInpcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdhdGNoYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldChuZXdWYWx1ZSwgX29sZFZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIHRvZG86IEFQSSBzdXBwb3J0XG4gICAgaWYgKCF0aGlzLnBhdXNlTGF5ZXJVcGRhdGUgJiYgdGhpcy5tYWtlTGl2ZUxheWVyVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyTXVsdGlkaW1lbnNpb25hbFN1YnNldCgpO1xuICAgIH1cbiAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uIH0gPSB0aGlzO1xuICAgIGlmICgoKF9hID0gbmV3VmFsdWUudmFyaWFibGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJiAoYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPT09IG51bGwgfHwgYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uLmxlbmd0aCkpIHtcbiAgICAgIC8vIHVzZSBvcmlnaW5hbCBvcmRlclxuICAgICAgY29uc3QgdmFyaWFibGVOYW1lcyA9IHRoaXMuYWxsVmFyaWFibGVzXG4gICAgICAgIC5maWx0ZXIoKHsgbmFtZSB9KSA9PiBuZXdWYWx1ZS52YXJpYWJsZXMuaW5jbHVkZXMobmFtZSkpXG4gICAgICAgIC5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKTtcbiAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhYmxlTmFtZSA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uWzBdLnZhcmlhYmxlTmFtZTtcbiAgICAgIGNvbnN0IG5ld1ZhcmlhYmxlTmFtZSA9IGFjdGl2ZVZhcmlhYmxlTmFtZSA9PT0gXCJcIiB8fCBuZXdWYWx1ZS52YXJpYWJsZXMuaW5jbHVkZXMoYWN0aXZlVmFyaWFibGVOYW1lKVxuICAgICAgICA/IGFjdGl2ZVZhcmlhYmxlTmFtZVxuICAgICAgICA6IHZhcmlhYmxlTmFtZXNbMF07XG4gICAgICBjb25zdCBuZXdEZWYgPSB0aGlzLmdldE5ld011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKG5ld1ZhcmlhYmxlTmFtZSk7XG4gICAgICBjb25zdCBpc0RlZmluaXRpb25DaGFuZ2VkID0gdGhpcy5pc011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uQ2hhbmdlZChuZXdEZWYpO1xuICAgICAgaWYgKGlzRGVmaW5pdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9IG5ld0RlZjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgbXVsdGlkaW1lbnNpb25hbFN1YnNldDogbmV3VmFsdWVcbiAgICAgIH07XG4gICAgdGhpcy5hcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsQ2hhbmdlLmVtaXQoZGF0YSk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgW3RoaXMuc3RyaW5nc10gPSBhd2FpdCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgIFtcbiAgICAgIHRoaXMuZXNyaUxhbmcsXG4gICAgICB0aGlzLmludGwsXG4gICAgICB0aGlzLkRpbWVuc2lvbmFsRGVmaW5pdGlvbixcbiAgICAgIHRoaXMuTXVsdGlkaW1lbnNpb25hbFN1YnNldCxcbiAgICAgIHRoaXMuVmFsdWVQaWNrZXJcbiAgICBdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgXCJlc3JpL2NvcmUvbGFuZ1wiLFxuICAgICAgXCJlc3JpL2ludGxcIixcbiAgICAgIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9EaW1lbnNpb25hbERlZmluaXRpb25cIixcbiAgICAgIFwiZXNyaS9sYXllcnMvc3VwcG9ydC9NdWx0aWRpbWVuc2lvbmFsU3Vic2V0XCIsXG4gICAgICBcImVzcmkvd2lkZ2V0cy9WYWx1ZVBpY2tlclwiXG4gICAgXSk7XG4gICAgY29uc3QgeyBsYXllciB9ID0gdGhpcztcbiAgICBpZiAobGF5ZXIubG9hZGVkKSB7XG4gICAgICAvLyBsb2FkIG11bHRpZGltZW5zaW9uYWwgaW5mbyAobWF5IG9yIG1heSBub3QgaW52b2x2ZSBhY3R1YWwgYXN5bmMgZmV0Y2hpbmcpXG4gICAgICBhd2FpdCB0aGlzLmluaXRMYXllcihsYXllcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gbG9hZCBsYXllciAoc2hvdyBsb2FkaW5nIHNpZ24pIGFuZCBtdWx0aWRpbWVuc2lvbmFsIGluZm9cbiAgICAgIHRoaXMuaW5pdExheWVyKGxheWVyKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXJUb3AgPSB0aGlzLmhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgdGhpcy5kZXN0cm95VmFsdWVQaWNrZXIoXCJib3RoXCIpO1xuICAgIChfYSA9IHRoaXMud2F0Y2hIYW5kbGVWaWV3VGltZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgIChfYiA9IHRoaXMud2F0Y2hIYW5kbGVMYXllcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW92ZSgpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBwdWJsaWMgbWV0aG9kc1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBzZXRGb2N1cyhmb2N1c0lkKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChmb2N1c0lkID09PSBcImRpc21pc3MtYnV0dG9uXCIgfHwgKCFmb2N1c0lkICYmIHRoaXMuZGlzbWlzc2libGUpKSB7XG4gICAgICAoX2EgPSB0aGlzLnJlZkNsb3NlQnV0dG9uTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZWZQYW5lbE5vZGUuc2V0Rm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZG9uZSgpIHtcbiAgICB0aGlzLmFwcGx5KCk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlcmVyIG1ldGhvZHNcbiAgLy9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5wb3BPdmVyKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBvcG92ZXJQcm9wcygpO1xuICAgIH1cbiAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgIGNvbnN0IHsgaGlkZVBhbmVsSGVhZGluZywgZGlzbWlzc2libGUsIGhpZGVCdXR0b25zLCBwYW5lbEhlYWRpbmcsIGhpZGVFeHRlbnRTZWN0aW9uLCBzdHJpbmdzOiBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxvYWRpbmcgPSAhKChfYSA9IHRoaXMubGF5ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2FkZWQpO1xuICAgIGlmICghdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgICAgY29uc3QgdW5zdXBwb3J0ZWREaXYgPSBsb2FkaW5nID8gbnVsbCA6IChoKFwiZGl2XCIsIHsgY2xhc3M6IFwibXVsdGlkaW1lbnNpb25hbC11bnN1cHBvcnRlZFwiIH0sIHN0cmluZ3MuZ2VuZXJhbC51bnN1cHBvcnRlZCkpO1xuICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1wYW5lbFwiLCB7IGxvYWRpbmc6IGxvYWRpbmcsIGhlYWRpbmc6ICFoaWRlUGFuZWxIZWFkaW5nID8gcGFuZWxIZWFkaW5nICE9PSBudWxsICYmIHBhbmVsSGVhZGluZyAhPT0gdm9pZCAwID8gcGFuZWxIZWFkaW5nIDogc3RyaW5ncy50aXRsZSA6IHVuZGVmaW5lZCwgY2xhc3M6IHtcbiAgICAgICAgICBwYW5lbDogdHJ1ZSxcbiAgICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICAgIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLnJlZlBhbmVsTm9kZSA9IG5vZGUpIH0sIGRpc21pc3NpYmxlICYmIHRoaXMucmVuZGVyQ2xvc2UoKSwgdW5zdXBwb3J0ZWREaXYsICFoaWRlQnV0dG9ucyAmJiB0aGlzLnJlbmRlckRvbmVCdXR0b24oKSwgIWhpZGVCdXR0b25zICYmIHRoaXMucmVuZGVyQ2FuY2VsQnV0dG9uKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJjYWxjaXRlLXBhbmVsXCIsIHsgbG9hZGluZzogZmFsc2UsIGhlYWRpbmc6ICFoaWRlUGFuZWxIZWFkaW5nID8gcGFuZWxIZWFkaW5nICE9PSBudWxsICYmIHBhbmVsSGVhZGluZyAhPT0gdm9pZCAwID8gcGFuZWxIZWFkaW5nIDogc3RyaW5ncy50aXRsZSA6IHVuZGVmaW5lZCwgY2xhc3M6IHtcbiAgICAgICAgcGFuZWw6IHRydWUsXG4gICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLnJlZlBhbmVsTm9kZSA9IG5vZGUpIH0sIGRpc21pc3NpYmxlID8gdGhpcy5yZW5kZXJDbG9zZSgpIDogbnVsbCwgaGlkZUV4dGVudFNlY3Rpb24gPyBudWxsIDogdGhpcy5yZW5kZXJFeHRlbnQoKSwgdGhpcy5yZW5kZXJDdXJyZW50RGlzcGxheSgpLCBoaWRlQnV0dG9ucyA/IG51bGwgOiB0aGlzLnJlbmRlckRvbmVCdXR0b24oKSwgaGlkZUJ1dHRvbnMgPyBudWxsIDogdGhpcy5yZW5kZXJDYW5jZWxCdXR0b24oKSkpKTtcbiAgfVxuICByZW5kZXJDdXJyZW50RGlzcGxheSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiwgc3RyaW5ncyB9ID0gdGhpcztcbiAgICBjb25zdCBzdWJzZXRWYXJpYWJsZXMgPSB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQudmFyaWFibGVzO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuYWxsVmFyaWFibGVzLmZpbHRlcigoeyBuYW1lIH0pID0+ICFzdWJzZXRWYXJpYWJsZXMubGVuZ3RoIHx8IHN1YnNldFZhcmlhYmxlcy5pbmNsdWRlcyhuYW1lKSk7XG4gICAgY29uc3QgeyBsYXllciB9ID0gdGhpcztcbiAgICBjb25zdCBpc0R5bmFtaWNJbWFnZXJ5ID0gdGhpcy5pc0ltYWdlcnlMYXllcihsYXllcik7XG4gICAgY29uc3QgaGFzU3Rhck9yTmV3VmFyaWFibGUgPSBpc0R5bmFtaWNJbWFnZXJ5ICYmXG4gICAgICAodmFyaWFibGVzLnNvbWUoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBcIipcIikgfHxcbiAgICAgICAgdGhpcy5oYXNOZXdWYXJpYWJsZSh0aGlzLm11bHRpZGltZW5zaW9uYWxJbmZvKSk7XG4gICAgLy8gc2luY2UgbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gY2FuIG9ubHkgYmUgdXNlZCBmb3Igc2VsZWN0aW9uLCBpdCBjYW5ub3QgYmUgdXNlZCB0b1xuICAgIC8vIHdvcmsgd2l0aCBuZXcgdmFyaWFibGVzIGFmdGVyIHJhc3RlckZ1bmN0aW9uXG4gICAgbGV0IGFjdGl2ZVZhcmlhYmxlTmFtZSA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uWzBdLnZhcmlhYmxlTmFtZTtcbiAgICAvLyBoYW5kbGUgc3BlY2lhbCB2YXJpYWJsZSBuYW1lIGZyb20gYSBzZXJ2ZXIgc2lkZSByZnQuXG4gICAgLy8gZm9yIDEwLjkrIHNlcnZlcnMsIGFuIHJmdCB3aXRoIHF1ZXJ5IGRlZmluaXRpb24gd2lsbCByZXN1bHQgYSAqIHZhcmlhYmxlLCB3aGljaCBpcyBlcXVpdmFsZW50IG9mIHVuc3BlY2lmaWVkIHZhcmlhYmxlIG5hbWVcbiAgICBpZiAoaXNEeW5hbWljSW1hZ2VyeSkge1xuICAgICAgY29uc3QgeyByYXN0ZXJGdW5jdGlvbiwgdmVyc2lvbiB9ID0gbGF5ZXI7XG4gICAgICBjb25zdCBoYXNSYXN0ZXJGdW5jdGlvbiA9IHJhc3RlckZ1bmN0aW9uICYmICgoX2EgPSByYXN0ZXJGdW5jdGlvbi5mdW5jdGlvbk5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSAhPT0gXCJub25lXCI7XG4gICAgICBpZiAoaGFzUmFzdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPD0gbWluVmVyc2lvblJGVE11bHRpZGltZW5zaW9uYWxJbmZvKSB7XG4gICAgICAgICAgdmFyaWFibGVzLnVuc2hpZnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXJpYWJsZXNbMF0pLCB7IG5hbWU6IHN0cmluZ3MuZGlzcGxheS5kZWZhdWx0VmFyaWFibGUsIGxhYmVsOiBzdHJpbmdzLmRpc3BsYXkuZGVmYXVsdFZhcmlhYmxlIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlVmFyaWFibGVOYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgYWN0aXZlVmFyaWFibGVOYW1lID0gaGFzU3Rhck9yTmV3VmFyaWFibGVcbiAgICAgICAgICAgID8gdmFyaWFibGVzWzBdLm5hbWVcbiAgICAgICAgICAgIDogc3RyaW5ncy5kaXNwbGF5LmRlZmF1bHRWYXJpYWJsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdmFyaWFibGVzLmZpbmRJbmRleCgodmFyaWFibGVJbmZvKSA9PiB2YXJpYWJsZUluZm8ubmFtZSA9PT0gYWN0aXZlVmFyaWFibGVOYW1lKTtcbiAgICBjb25zdCBzZWxlY3RTdHJpbmdzID0ge1xuICAgICAgY2xlYXJGaWx0ZXI6IHN0cmluZ3Muc2VsZWN0LmNsZWFyRmlsdGVyLFxuICAgICAgZmlsdGVyVGV4dDogc3RyaW5ncy5zZWxlY3QuZmlsdGVyVGV4dCxcbiAgICAgIGZpbHRlckxhYmVsOiBzdHJpbmdzLmV4dGVudC5zZWFyY2hWYXJpYWJsZXMsXG4gICAgICBzZWxlY3RMYWJlbDogc3RyaW5ncy5leHRlbnQuc2VsZWN0VmFyaWFibGVzXG4gICAgfTtcbiAgICBjb25zdCB2YXJpYWJsZVNlbGVjdCA9IChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHN0cmluZ3MuZGlzcGxheS52YXJpYWJsZSwgaChcImFyY2dpcy1sYXp5LWxvYWRpbmctc2VsZWN0XCIsIHsgc2VsZWN0ZWRJbmRleDogc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyAwIDogc2VsZWN0ZWRJbmRleCwgbGlzdDogdmFyaWFibGVzLm1hcCgodmFyaWFibGVJbmZvKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXJpYWJsZUluZm8pLCB7IHZhbHVlOiB2YXJpYWJsZUluZm8ubmFtZSB9KSkpLCBzdHJpbmdzOiBzZWxlY3RTdHJpbmdzLCBrZXk6IHRoaXMuc291cmNlS2V5LCBvbkFyY2dpc0xhenlMb2FkaW5nU2VsZWN0Q2hhbmdlOiAoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVmFyaWFibGVOYW1lID0gZXZ0LmRldGFpbC5zZWxlY3RlZFZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZURlZmluaXRpb25WYXJpYWJsZU5hbWUoc2VsZWN0ZWRWYXJpYWJsZU5hbWUpO1xuICAgICAgfSwgY29udGFpbmVyVG9wOiB0aGlzLmNvbnRhaW5lclRvcCB9KSkpKTtcbiAgICAvLyByZXN0b3JlIHNwZWNpYWwgYWN0aXZlVmFyaWFibGVOYW1lLiBzdGFyIHZhcmlhYmxlIGlzIGZpbmUgZm9yIHRoZSBmb2xsb3dpbmcgdmFyaWFibGVJbmZvIGxvb2t1cFxuICAgIGlmIChhY3RpdmVWYXJpYWJsZU5hbWUgPT09IHN0cmluZ3MuZGlzcGxheS5kZWZhdWx0VmFyaWFibGUpIHtcbiAgICAgIGFjdGl2ZVZhcmlhYmxlTmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhYmxlSW5mbyA9IHRoaXMuZ2V0VmFyaWFibGVJbmZvKGFjdGl2ZVZhcmlhYmxlTmFtZSk7XG4gICAgY29uc3QgZGltZW5zaW9uQmxvY2tzID0gdmFyaWFibGVJbmZvLmRpbWVuc2lvbnMubWFwKChkaW1JbmZvKSA9PiB7XG4gICAgICBkaW1JbmZvID0gZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8oZGltSW5mbywgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KTtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckRpbWVuc2lvbihkaW1JbmZvKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJsb2NrXCIsIHsgaGVhZGluZzogc3RyaW5ncy5kaXNwbGF5LmN1cnJlbnQsIGNvbGxhcHNpYmxlOiB0cnVlLCBvcGVuOiB0cnVlIH0sIHZhcmlhYmxlU2VsZWN0LCBkaW1lbnNpb25CbG9ja3MpKTtcbiAgfVxuICByZW5kZXJQaWNrTGlzdFBvcG92ZXIoKSB7XG4gICAgaWYgKHRoaXMucG9wT3Zlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwb3BPdmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1maWVsZC1waWNrLWxpc3RcIik7XG4gICAgY29uc3QgcG9wb3ZlcldpZHRoID0gdGhpcy5yZWZQYW5lbE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgcG9wT3Zlci5wb3BvdmVyUHJvcHMgPSB7XG4gICAgICByZWZFbGVtZW50OiB0aGlzLnJlZlBhbmVsTm9kZSxcbiAgICAgIHBsYWNlbWVudDogXCJsZWFkaW5nLWVuZFwiLFxuICAgICAgb2Zmc2V0RGlzdGFuY2U6IDEsXG4gICAgICBvZmZzZXRTa2lkZGluZzogNDgsXG4gICAgICBwb3BvdmVyV2lkdGhcbiAgICB9O1xuICAgIHBvcE92ZXIuaGVhZGluZyA9IHRoaXMuc3RyaW5ncy5leHRlbnQuc2VsZWN0VmFyaWFibGVzO1xuICAgIHBvcE92ZXIuZmlsdGVyUGxhY2Vob2xkZXJUZXh0ID0gdGhpcy5zdHJpbmdzLmV4dGVudC5zZWFyY2hWYXJpYWJsZXM7XG4gICAgcG9wT3Zlci5zaG93RmllbGRJbmZvID0gZmFsc2U7XG4gICAgcG9wT3Zlci5zaG93RmllbGROYW1lID0gZmFsc2U7XG4gICAgcG9wT3Zlci5zaG93RGVzY3JpcHRpb24gPSB0cnVlO1xuICAgIHBvcE92ZXIuc2hvd1NlbGVjdGlvbkFsbCA9IHRydWU7XG4gICAgcG9wT3Zlci5zaG93Q2FuY2VsID0gZmFsc2U7XG4gICAgcG9wT3Zlci5zaG93U29ydCA9IGZhbHNlO1xuICAgIHBvcE92ZXIuc29ydEJ5ID0gTGFzdFNvcnR5QnkuZGVmYXVsdDtcbiAgICBwb3BPdmVyLm11bHRpcGxlID0gdHJ1ZTtcbiAgICB0aGlzLnBvcE92ZXIgPSBwb3BPdmVyO1xuICAgIHRoaXMucHJldmlvdXNQaWNrZWRMaXN0U2l6ZSA9IC0xO1xuICAgIHRoaXMudXBkYXRlUG9wb3ZlclByb3BzKCk7XG4gICAgcG9wT3Zlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzRmllbGRQaWNrTGlzdENoYW5nZVwiLCAoZXZ0KSA9PiB7XG4gICAgICBsZXQgc2VsZWN0ZWRWYXJpYWJsZXMgPSBldnQuZGV0YWlsLnNlbGVjdGVkRmllbGRzIHx8IFtdO1xuICAgICAgdGhpcy51cGRhdGVFeHRlbnRWYXJpYWJsZXMoc2VsZWN0ZWRWYXJpYWJsZXMpO1xuICAgIH0pO1xuICAgIHBvcE92ZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc0ZpZWxkUGlja0xpc3REaXNtaXNzZWRcIiwgKF9ldnQpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3BPdmVyKTtcbiAgfVxuICByZW5kZXJFeHRlbnQoKSB7XG4gICAgY29uc3QgdmFyaWFibGVMaXN0ID0gdGhpcy5yZW5kZXJWYXJpYWJsZUxpc3QoKTtcbiAgICBjb25zdCB7IGV4dGVudDogZXh0ZW50U3RyaW5ncyB9ID0gdGhpcy5zdHJpbmdzO1xuICAgIGNvbnN0IHZhcmlhYmxlU2VsZWN0QnV0dG9uID0gdGhpcy5hbGxWYXJpYWJsZXMubGVuZ3RoID4gMSAmJiAoaChcImRpdlwiLCB7IGNsYXNzOiBcInZhcmlhYmxlLXNlbGVjdFwiIH0sIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNjYWxlOiBcInNcIiwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJuZXV0cmFsXCIsIHJvdW5kOiB0cnVlLCBhbGlnbm1lbnQ6IFwiY2VudGVyXCIsIGljb25TdGFydDogXCJwbHVzXCIsIG9uQ2xpY2s6ICgpID0+IHRoaXMucmVuZGVyUGlja0xpc3RQb3BvdmVyKCkgfSwgZXh0ZW50U3RyaW5ncy52YXJpYWJsZXMpKSk7XG4gICAgY29uc3QgYWxsRGltZW5zaW9zbiA9IFtdO1xuICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzLmZvckVhY2goKHsgZGltZW5zaW9ucyB9KSA9PiBhbGxEaW1lbnNpb3NuLnB1c2goLi4uZGltZW5zaW9ucykpO1xuICAgIGNvbnN0IGV4dGVudEJsb2NrcyA9IHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5kaW1lbnNpb25zLm1hcCgoeyBuYW1lLCBleHRlbnQgfSkgPT4ge1xuICAgICAgY29uc3QgZGltSW5mbyA9IGFsbERpbWVuc2lvc24uZmluZCgoeyBuYW1lOiBkaW1OYW1lIH0pID0+IGRpbU5hbWUgPT09IG5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRGltZW5zaW9uRXh0ZW50KGRpbUluZm8sIGV4dGVudCk7XG4gICAgfSk7XG4gICAgY29uc3QgYW9pQmxvY2sgPSB0aGlzLmhpZGVBT0kgPyB1bmRlZmluZWQgOiB0aGlzLnJlbmRlckFPSSgpO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtYmxvY2tcIiwgeyBoZWFkaW5nOiBleHRlbnRTdHJpbmdzLmV4dGVudCwgY29sbGFwc2libGU6IHRydWUsIG9wZW46ICF0aGlzLmNvbGxhcHNlRXh0ZW50U2VjdGlvbiwgb25DYWxjaXRlQmxvY2tUb2dnbGU6ICgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkgfSwgdmFyaWFibGVMaXN0LCB2YXJpYWJsZVNlbGVjdEJ1dHRvbiwgZXh0ZW50QmxvY2tzLCBhb2lCbG9jaykpO1xuICB9XG4gIHJlbmRlclZhcmlhYmxlTGlzdCgpIHtcbiAgICBjb25zdCBzdWJzZXRWYXJpYWJsZXMgPSB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQudmFyaWFibGVzO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuYWxsVmFyaWFibGVzLmZpbHRlcigoeyBuYW1lIH0pID0+ICFzdWJzZXRWYXJpYWJsZXMubGVuZ3RoIHx8IHN1YnNldFZhcmlhYmxlcy5pbmNsdWRlcyhuYW1lKSk7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhpZGRlbiA9IHRoaXMuYWxsVmFyaWFibGVzLmxlbmd0aCA9PT0gMTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgc3RyaW5ncy5leHRlbnQudmFyaWFibGVzLCBoKFwiY2FsY2l0ZS1saXN0XCIsIHsgY2xhc3M6IFwidmFyaWFibGUtc2VjdGlvbi1ib2FyZGVyXCIgfSwgdmFyaWFibGVzLm1hcCgoeyBuYW1lLCBsYWJlbCwgZGVzY3JpcHRpb24gfSkgPT4gKGgoXCJjYWxjaXRlLWxpc3QtaXRlbVwiLCB7IGxhYmVsOiBsYWJlbCwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBrZXk6IG5hbWUgfSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgaWNvbjogXCJ4XCIsIHNjYWxlOiBcInNcIiwgdGV4dDogc3RyaW5ncy5nZW5lcmFsLmNsb3NlLCBzbG90OiBcImFjdGlvbnMtZW5kXCIsIGhpZGRlbjogaGlkZGVuLCBvbkNsaWNrOiAoKSA9PiB0aGlzLl9yZW1vdmVWYXJpYWJsZShuYW1lKSB9KSkpKSkpKSk7XG4gIH1cbiAgcmVuZGVyQU9JKCkge1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gdGhpcztcbiAgICBjb25zdCBhb2lPcHRpb25zID0gW1xuICAgICAgeyB2YWx1ZTogXCJkZWZhdWx0XCIsIGxhYmVsOiBzdHJpbmdzLmV4dGVudC5kZWZhdWx0LCBzZWxlY3RlZDogdGhpcy5hb2lJbmRleCA9PT0gMCB9LFxuICAgICAgeyB2YWx1ZTogXCJtYXBcIiwgbGFiZWw6IHN0cmluZ3MuZXh0ZW50Lm1hcEV4dGVudCwgc2VsZWN0ZWQ6IHRoaXMuYW9pSW5kZXggPT09IDEgfVxuICAgIF07XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGFvaU9wdGlvbnMuZmluZEluZGV4KCh7IHNlbGVjdGVkIH0pID0+IHNlbGVjdGVkKTtcbiAgICBjb25zdCBzZWxlY3RTdHJpbmdzID0ge1xuICAgICAgY2xlYXJGaWx0ZXI6IHRoaXMuc3RyaW5ncy5zZWxlY3QuY2xlYXJGaWx0ZXIsXG4gICAgICBmaWx0ZXJUZXh0OiB0aGlzLnN0cmluZ3Muc2VsZWN0LmZpbHRlclRleHQsXG4gICAgICBmaWx0ZXJMYWJlbDogdGhpcy5zdHJpbmdzLmV4dGVudC5zZWFyY2hBT0ksXG4gICAgICBzZWxlY3RMYWJlbDogdGhpcy5zdHJpbmdzLmV4dGVudC5zZWxlY3RBT0lcbiAgICB9O1xuICAgIHJldHVybiAoaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmV4dGVudC5hb2ksIGgoXCJhcmNnaXMtbGF6eS1sb2FkaW5nLXNlbGVjdFwiLCB7IHNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsIGxpc3Q6IGFvaU9wdGlvbnMsIHN0cmluZ3M6IHNlbGVjdFN0cmluZ3MsIG9uQXJjZ2lzTGF6eUxvYWRpbmdTZWxlY3RDaGFuZ2U6IChldnQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV2dC5kZXRhaWwuc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgY29uc3QgYW9pID0gdmFsdWUgPT09IFwiZGVmYXVsdFwiID8gbnVsbCA6IChfYSA9IHRoaXMudmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4dGVudDtcbiAgICAgICAgdGhpcy5hb2lJbmRleCA9IHZhbHVlID09PSBcImRlZmF1bHRcIiA/IDAgOiAxO1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVudEFPSShhb2kpO1xuICAgICAgfSwgY29udGFpbmVyVG9wOiB0aGlzLmNvbnRhaW5lclRvcCB9KSkpKTtcbiAgfVxuICBfcmVtb3ZlVmFyaWFibGUodmFyaWFibGVOYW1lKSB7XG4gICAgY29uc3QgbmV3QWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldC5jbG9uZSgpO1xuICAgIGxldCBzdWJzZXREZWZpbml0aW9ucyA9IG5ld0FjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQuc3Vic2V0RGVmaW5pdGlvbnMuZmlsdGVyKChkZWYpID0+IGRlZi52YXJpYWJsZU5hbWUgIT09IHZhcmlhYmxlTmFtZSk7XG4gICAgaWYgKHN1YnNldERlZmluaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc3Vic2V0RGVmaW5pdGlvbnMgPSB0aGlzLmdldERlZmF1bHRNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KCkuc3Vic2V0RGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIG5ld0FjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQuc3Vic2V0RGVmaW5pdGlvbnMgPSBzdWJzZXREZWZpbml0aW9ucztcbiAgICB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBuZXdBY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0O1xuICB9XG4gIHJlbmRlckRpbWVuc2lvbkxpc3QoZGltZW5zaW9uSW5mbywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBzZWxlY3RlZFZhbHVlLCBrZXkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNTdGFydE9yRW5kID0gKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGtleS5pbmNsdWRlcyhcInN0YXJ0XCIpKSB8fCAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdm9pZCAwID8gdm9pZCAwIDoga2V5LmluY2x1ZGVzKFwiZW5kXCIpKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSgoX2EgPSBkaW1lbnNpb25JbmZvLnZhbHVlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAmJiB0eXBlb2Ygc2VsZWN0ZWRWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgZGltVmFsdWVzID0gZGltZW5zaW9uSW5mby52YWx1ZXM7XG4gICAgICBpZiAoaXNTdGFydE9yRW5kKSB7XG4gICAgICAgIHNlbGVjdGVkVmFsdWUgPSBkaW1WYWx1ZXMuZmluZCgodmFsdWUpID0+IGtleS5pbmNsdWRlcyhcInN0YXJ0XCIpID8gdmFsdWVbMF0gPT09IHNlbGVjdGVkVmFsdWUgOiB2YWx1ZVsxXSA9PT0gc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbWF0Y2ggc3RhcnQsIHRoZW4gbWF0Y2ggZW5kXG4gICAgICAgIHNlbGVjdGVkVmFsdWUgPSBkaW1WYWx1ZXMuZmluZCgodmFsdWUpID0+IHZhbHVlWzBdID09PSBzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBkaW1WYWx1ZXMuZmluZCgodmFsdWUpID0+IHZhbHVlWzFdID09PSBzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc1VuZGVmaW5lZFZhbHVlID0gc2VsZWN0ZWRWYWx1ZSA9PT0gdW5kZWZpbmVkX2RpbWVuc2lvbl92YWx1ZSB8fFxuICAgICAgb3B0aW9ucy5zZWxlY3RlZFZhbHVlID09PSB1bmRlZmluZWRfZGltZW5zaW9uX3ZhbHVlO1xuICAgIGNvbnN0IGFjdGl2ZURpbWVuc2lvbkxhYmVsID0gaXNVbmRlZmluZWRWYWx1ZVxuICAgICAgPyBcInVuZGVmaW5lZFwiXG4gICAgICA6IGZvcm1hdERpbWVuc2lvblZhbHVlKHNlbGVjdGVkVmFsdWUsIGRpbWVuc2lvbkluZm8sIHtcbiAgICAgICAgaW50bDogdGhpcy5pbnRsLFxuICAgICAgICB1c2VSZWN1cnJpbmdUaW1lTGFiZWw6IHRydWVcbiAgICAgIH0pO1xuICAgIC8vIG51bWJlciBpcyBub3Qgd2VsbCBzdXBwb3J0ZWQgYnkgY2FsY2l0ZS1zZWxlY3RcbiAgICAvLyA8b3B0aW9uIGxhYmVsPVwiMFwiIHZhbHVlPVwiXCI+MDwvb3B0aW9uPiAobnVsbC90cnV0aHkgY2hlY2sgaXNzdWU/KVxuICAgIC8vIHN0YXJ0L2VuZCB0aW1lIGNvbHVtbiByZW5kZXJzIHNhbWUgKGhvdyBpcyB0aGlzIHJlbGF0ZWQgdG8gbnVtYmVyPylcbiAgICBjb25zdCBzZXBhcmF0b3IgPSBcIiAtIFwiO1xuICAgIGNvbnN0IGlzQXNjZW5kaW5nID0gb3B0aW9ucy5zb3J0YWJsZVxuICAgICAgPyB0aGlzLnNvcnREaXJlY3Rpb25zW2RpbWVuc2lvbkluZm8ubmFtZV0gIT09IFwiZGVzY2VuZGluZ1wiXG4gICAgICA6IHRydWU7XG4gICAgY29uc3QgZGltZW5zaW9uVmFsdWVzID0gaXNBc2NlbmRpbmdcbiAgICAgID8gZGltZW5zaW9uSW5mby52YWx1ZXNcbiAgICAgIDogWy4uLmRpbWVuc2lvbkluZm8udmFsdWVzXS5yZXZlcnNlKCk7XG4gICAgY29uc3QgdmFsdWVzID0gZGltZW5zaW9uVmFsdWVzLm1hcCgodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZm9ybWF0RGltZW5zaW9uVmFsdWUodmFsdWUsIGRpbWVuc2lvbkluZm8sIHtcbiAgICAgICAgaW50bDogdGhpcy5pbnRsLFxuICAgICAgICB1c2VSZWN1cnJpbmdUaW1lTGFiZWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmFsdWVTdHIgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oc2VwYXJhdG9yKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IGxhYmVsID09PSBhY3RpdmVEaW1lbnNpb25MYWJlbDtcbiAgICAgIGNvbnN0IGtleSA9IGAke29wdGlvbnMua2V5fS0ke3ZhbHVlU3RyfX1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVTdHIsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBzZWxlY3RlZFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5zaG93RW5kKSB7XG4gICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgIGtleTogYCR7ZGltZW5zaW9uSW5mby5uYW1lfS1lbmQtdW5kZWZpbmVkfWAsXG4gICAgICAgIHZhbHVlOiBTdHJpbmcodW5kZWZpbmVkX2RpbWVuc2lvbl92YWx1ZSksXG4gICAgICAgIGxhYmVsOiB0aGlzLnN0cmluZ3MuZXh0ZW50LmVuZFVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0ZWQ6IGlzVW5kZWZpbmVkVmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBvbkFyY2dpc0xhenlMb2FkaW5nU2VsZWN0Q2hhbmdlID0gKGV2dCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdmFsdWUgPSBldnQuZGV0YWlsLnNlbGVjdGVkVmFsdWUuc3BsaXQoc2VwYXJhdG9yKS5tYXAoKHZhbCkgPT4gTnVtYmVyKHZhbCkpO1xuICAgICAgKF9hID0gb3B0aW9ucy5vbkNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdmFsdWUubGVuZ3RoID09PSAxID8gdmFsdWVbMF0gOiB2YWx1ZSk7XG4gICAgfTtcbiAgICBsZXQgc29ydEljb24gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLnNvcnRhYmxlKSB7XG4gICAgICAvLyBpY29uIGlzIHRoZSB3aGF0IHVzZXIgd2FudCB0byBjaGFuZ2UgdG9cbiAgICAgIGNvbnN0IHNvcnRJY29uTmFtZSA9IGlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvKVxuICAgICAgICA/IGlzQXNjZW5kaW5nXG4gICAgICAgICAgPyBcImNsb2NrLXVwXCJcbiAgICAgICAgICA6IFwiY2xvY2stZG93blwiXG4gICAgICAgIDogaXNBc2NlbmRpbmdcbiAgICAgICAgICA/IFwic29ydC1hc2NlbmRpbmctYXJyb3dcIlxuICAgICAgICAgIDogXCJzb3J0LWRlc2NlbmRpbmctYXJyb3dcIjtcbiAgICAgIHNvcnRJY29uID0gKGgoXCJjYWxjaXRlLWFjdGlvblwiLCB7IGljb246IHNvcnRJY29uTmFtZSwgc2NhbGU6IFwic1wiLCB0ZXh0OiB0aGlzLnN0cmluZ3MuZGlzcGxheS5zb3J0LCBzbG90OiBcImFjdGlvbnMtZW5kXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVNvcnRpbmcoZGltZW5zaW9uSW5mby5uYW1lKTtcbiAgICAgICAgfSB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSB2YWx1ZXMuZmluZEluZGV4KCh7IHNlbGVjdGVkIH0pID0+IHNlbGVjdGVkKTtcbiAgICBjb25zdCBzZWxlY3RTdHJpbmdzID0ge1xuICAgICAgY2xlYXJGaWx0ZXI6IHRoaXMuc3RyaW5ncy5zZWxlY3QuY2xlYXJGaWx0ZXIsXG4gICAgICBmaWx0ZXJUZXh0OiB0aGlzLnN0cmluZ3Muc2VsZWN0LmZpbHRlclRleHQsXG4gICAgICBmaWx0ZXJMYWJlbDogdGhpcy5zdHJpbmdzLmV4dGVudC5zZWFyY2hEaW1lbnNpb25zLFxuICAgICAgc2VsZWN0TGFiZWw6IHRoaXMuc3RyaW5ncy5leHRlbnQuc2VsZWN0RGltZW5zaW9uc1xuICAgIH07XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZGltZW5zaW9uLXNlbGVjdC1jb250YWluZXJcIiB9LCBoKFwiYXJjZ2lzLWxhenktbG9hZGluZy1zZWxlY3RcIiwgeyBzZWxlY3RlZEluZGV4OiBzZWxlY3RlZEluZGV4ID09PSAtMSA/IDAgOiBzZWxlY3RlZEluZGV4LCBsaXN0OiB2YWx1ZXMsIHN0cmluZ3M6IHNlbGVjdFN0cmluZ3MsIG9uQXJjZ2lzTGF6eUxvYWRpbmdTZWxlY3RDaGFuZ2U6IG9uQXJjZ2lzTGF6eUxvYWRpbmdTZWxlY3RDaGFuZ2UsIGNvbnRhaW5lclRvcDogdGhpcy5jb250YWluZXJUb3AgfSksIHNvcnRJY29uKSk7XG4gIH1cbiAgcmVuZGVyRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pIHtcbiAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5maW5kKChkZWYpID0+IGRlZi5kaW1lbnNpb25OYW1lID09PSBkaW1lbnNpb25JbmZvLm5hbWUpO1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHZhbHVlKSA9PiB0aGlzLnVwZGF0ZURlZmluaXRpb25EaW1lbnNpb25WYWx1ZShkaW1lbnNpb25JbmZvLm5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICBjb25zdCBkaW1lbnNpb25TZWxlY3QgPSB0aGlzLnJlbmRlckRpbWVuc2lvbkxpc3QoZGltZW5zaW9uSW5mbywge1xuICAgICAgc2VsZWN0ZWRWYWx1ZTogZGVmaW5pdGlvbi52YWx1ZXNbMF0sXG4gICAgICBzb3J0YWJsZTogdGhpcy5pc0RpbWVuc2lvbkxpc3RTb3J0YWJsZSxcbiAgICAgIGtleTogZGltZW5zaW9uSW5mby5uYW1lLFxuICAgICAgb25DaGFuZ2VcbiAgICB9KTtcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgY29uc3QgZGltZW5zaW9uTGFiZWwgPSBkaW1lbnNpb25JbmZvLm5hbWUgPT09IFwiU3RkVGltZVwiXG4gICAgICA/IHN0cmluZ3MuZGlzcGxheS5zdGRUaW1lRGltZW5zaW9uXG4gICAgICA6IGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRaXCJcbiAgICAgICAgPyBzdHJpbmdzLmRpc3BsYXkuc3RkWkRpbWVuc2lvblxuICAgICAgICA6IHN0cmluZ3MuZGlzcGxheS5nZW5lcmFsRGltZW5zaW9uLnJlcGxhY2UoXCIke2RpbWVuc2lvbk5hbWV9XCIsIGRpbWVuc2lvbkluZm8ubmFtZSk7XG4gICAgY29uc3QgaXNUaW1lID0gaXNUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8sIHRydWUpO1xuICAgIGNvbnN0IGRpbU5hbWUgPSBpc1RpbWUgPyBcInRpbWVcIiA6IFwielwiO1xuICAgIGNvbnN0IGNsaXBwZWREaW1lbnNpb25JbmZvID0gZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8oZGltZW5zaW9uSW5mbywgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KTtcbiAgICBjb25zdCBpc1plcm9PclNpbmdsZVNsaWNlID0gY2xpcHBlZERpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aCA8IDI7XG4gICAgY29uc3QgeyBzaG93QW5pbWF0aW9uQ29udHJvbHMgfSA9IHRoaXM7XG4gICAgY29uc3QgYW5pbWF0aW9uU3dpdGNoID0gc2hvd0FuaW1hdGlvbkNvbnRyb2xzICYmICFpc1plcm9PclNpbmdsZVNsaWNlID8gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgbGF5b3V0OiBcImlubGluZVwiIH0sIGgoXCJjYWxjaXRlLXN3aXRjaFwiLCB7IHNjYWxlOiBcInNcIiwgY2hlY2tlZDogdGhpcy5hbmltYXRlZERpbWVuc2lvbnNbZGltTmFtZV0gPT09IGRpbWVuc2lvbkluZm8ubmFtZSwgbGFiZWw6IHN0cmluZ3MuZGlzcGxheS5zaG93RGltZW5zaW9uU2xpZGVyLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAobm9kZS5jaGVja2VkKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVWYWx1ZVBpY2tlcihkaW1lbnNpb25JbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lWYWx1ZVBpY2tlcihpc1RpbWUgPyBcInRpbWVcIiA6IFwielwiKTtcbiAgICAgICAgfVxuICAgICAgfSB9KSwgc3RyaW5ncy5kaXNwbGF5LnNob3dEaW1lbnNpb25TbGlkZXIpKSA6IG51bGw7XG4gICAgcmV0dXJuIHNob3dBbmltYXRpb25Db250cm9scyA/IChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiZGltZW5zaW9uLXpvbmVcIiB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBkaW1lbnNpb25MYWJlbCksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHN0cmluZ3MuZGlzcGxheS5kZWZhdWx0UG9zaXRpb24sIGRpbWVuc2lvblNlbGVjdCksIGFuaW1hdGlvblN3aXRjaCkpIDogKGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgZGltZW5zaW9uTGFiZWwsIGRpbWVuc2lvblNlbGVjdCkpKTtcbiAgfVxuICByZW5kZXJEaW1lbnNpb25FeHRlbnQoZGltZW5zaW9uSW5mbywgZXh0ZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHN0YXJ0VmFsdWVzID0gW107XG4gICAgY29uc3QgZW5kVmFsdWVzID0gW107XG4gICAgZGltZW5zaW9uSW5mby52YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWVbMV0gPD0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgc3RhcnRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlWzBdID49IGV4dGVudFswXSkge1xuICAgICAgICAgIGVuZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IGV4dGVudFsxXSkge1xuICAgICAgICAgIHN0YXJ0VmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA+IGV4dGVudFswXSkge1xuICAgICAgICAgIGVuZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGlzU2xpY2VNb2RlID0gZXh0ZW50WzFdID09PSBleHRlbnRbMF0gfHxcbiAgICAgIChBcnJheS5pc0FycmF5KGRpbWVuc2lvbkluZm8udmFsdWVzWzBdKSAmJlxuICAgICAgICBkaW1lbnNpb25JbmZvLnZhbHVlcy5zb21lKCh2YWwpID0+IHZhbFswXSA9PT0gZXh0ZW50WzBdICYmIHZhbFsxXSA9PT0gZXh0ZW50WzFdKSk7XG4gICAgY29uc3Qgc3RhcnRJbmZvID0gaXNTbGljZU1vZGVcbiAgICAgID8gZGltZW5zaW9uSW5mb1xuICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRpbWVuc2lvbkluZm8pLCB7IHZhbHVlczogc3RhcnRWYWx1ZXMgfSk7XG4gICAgY29uc3Qgc3RhcnRMaXN0ID0gdGhpcy5yZW5kZXJEaW1lbnNpb25MaXN0KHN0YXJ0SW5mbywge1xuICAgICAgc2VsZWN0ZWRWYWx1ZTogZXh0ZW50WzBdLFxuICAgICAgc29ydGFibGU6IGZhbHNlLFxuICAgICAga2V5OiBkaW1lbnNpb25JbmZvLm5hbWUgKyBcIi1zdGFydFwiLFxuICAgICAgb25DaGFuZ2U6ICh2YWx1ZSkgPT4gdGhpcy51cGRhdGVFeHRlbnREaW1lbnNpb25TdWJzZXQoZGltZW5zaW9uSW5mby5uYW1lLCB2YWx1ZSwgXCJzdGFydFwiKVxuICAgIH0pO1xuICAgIGNvbnN0IGVuZEluZm8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRpbWVuc2lvbkluZm8pLCB7IHZhbHVlczogZW5kVmFsdWVzIH0pO1xuICAgIGNvbnN0IGVuZExpc3QgPSB0aGlzLnJlbmRlckRpbWVuc2lvbkxpc3QoZW5kSW5mbywge1xuICAgICAgc2VsZWN0ZWRWYWx1ZTogaXNTbGljZU1vZGUgPyB1bmRlZmluZWRfZGltZW5zaW9uX3ZhbHVlIDogZXh0ZW50WzFdLFxuICAgICAgc29ydGFibGU6IGZhbHNlLFxuICAgICAga2V5OiBkaW1lbnNpb25JbmZvLm5hbWUgKyBcIi1lbmRcIixcbiAgICAgIHNob3dFbmQ6IHRydWUsXG4gICAgICBvbkNoYW5nZTogKHZhbHVlKSA9PiB0aGlzLnVwZGF0ZUV4dGVudERpbWVuc2lvblN1YnNldChkaW1lbnNpb25JbmZvLm5hbWUsIHZhbHVlLCBcImVuZFwiKVxuICAgIH0pO1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gdGhpcztcbiAgICBjb25zdCBkaW1lbnNpb25MYWJlbCA9IGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRUaW1lXCJcbiAgICAgID8gc3RyaW5ncy5leHRlbnQuc3RkVGltZUV4dGVudFxuICAgICAgOiBkaW1lbnNpb25JbmZvLm5hbWUgPT09IFwiU3RkWlwiXG4gICAgICAgID8gc3RyaW5ncy5leHRlbnQuc3RkWkV4dGVudFxuICAgICAgICA6IHN0cmluZ3MuZXh0ZW50LmdlbmVyYWxFeHRlbnQucmVwbGFjZShcIiR7ZGltZW5zaW9uTmFtZX1cIiwgZGltZW5zaW9uSW5mby5uYW1lKTtcbiAgICBjb25zdCBhbGxWYWx1ZXMgPSBkaW1lbnNpb25JbmZvLnZhbHVlcztcbiAgICBjb25zdCBzbGljZUNvdW50ID0gYWxsVmFsdWVzLmxlbmd0aDtcbiAgICAvLyB1c2luZyBjbG9zdXJlIGhlcmUsIHRoZXJlJ3Mgb25lIHNsaWRlciBwZXIgZGltZW5zaW9uLCBkb2Vzbid0IG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGVtIGF0IHRoZSBjb21wb2VubnQgbGV2ZWxcbiAgICBsZXQgc2xpZGVyVGFyZ2V0O1xuICAgIGNvbnN0IG9uU2xpZGVyQ2hhbmdlID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgLy8gZXZ0LnRhcmdldCBpcyBub3QgdGhlIHNsaWRlciBpdHNlbGYgaW4gY2FzZSBvZiBvbkNhbGNpdGVTbGlkZXJDaGFuZ2UgKG9uQ2FsY2l0ZVNsaWRlcklucHV0IGlzIG5vdCBmaXJlZCB3aGVuIGRyYWcgbWlkZGxlIG9mIHR3byB0aHVtYnMpXG4gICAgICBsZXQgc3RhcnQsIGVuZDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNsaWRlclRhcmdldC52YWx1ZSkpIHtcbiAgICAgICAgc3RhcnQgPSBhbGxWYWx1ZXNbc2xpZGVyVGFyZ2V0LnZhbHVlWzBdXTtcbiAgICAgICAgZW5kID0gYWxsVmFsdWVzWyhfYSA9IHNsaWRlclRhcmdldC52YWx1ZVsxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2xpZGVyVGFyZ2V0LnZhbHVlWzBdXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IGVuZCA9IGFsbFZhbHVlc1tzbGlkZXJUYXJnZXQudmFsdWVdO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9IEFycmF5LmlzQXJyYXkoc3RhcnQpID8gc3RhcnRbMF0gOiBzdGFydDtcbiAgICAgIGNvbnN0IGVuZFZhbHVlID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kWzFdIDogZW5kO1xuICAgICAgdGhpcy51cGRhdGVFeHRlbnREaW1lbnNpb25TdWJzZXQoZGltZW5zaW9uSW5mby5uYW1lLCBbc3RhcnRWYWx1ZSwgZW5kVmFsdWVdKTtcbiAgICB9LCAxMDApO1xuICAgIGxldCBtaW5JbmRleCA9IDA7XG4gICAgbGV0IG1heEluZGV4ID0gc2xpY2VDb3VudCAtIDE7XG4gICAgY29uc3QgZGltRXh0ZW50ID0gKF9hID0gdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LmRpbWVuc2lvbnMuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGRpbWVuc2lvbkluZm8ubmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHRlbnQ7XG4gICAgaWYgKGRpbUV4dGVudCkge1xuICAgICAgbWluSW5kZXggPSBhbGxWYWx1ZXMuZmluZEluZGV4KCh2YWwpID0+IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWxbMF0gOiB2YWwpID09PSBkaW1FeHRlbnRbMF0pO1xuICAgICAgaWYgKG1pbkluZGV4ID09PSAtMSkge1xuICAgICAgICBtaW5JbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBtYXhJbmRleCA9IGFsbFZhbHVlcy5maW5kSW5kZXgoKHZhbCkgPT4gKEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFsxXSA6IHZhbCkgPT09IGRpbUV4dGVudFsxXSk7XG4gICAgICBpZiAobWF4SW5kZXggPT09IC0xKSB7XG4gICAgICAgIG1heEluZGV4ID0gc2xpY2VDb3VudCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNsaWRlciA9IGV4dGVudFswXSA9PT0gZXh0ZW50WzFdID8gKGgoXCJjYWxjaXRlLXNsaWRlclwiLCB7IGRpc2FibGVkOiBmYWxzZSwgbWluOiAwLCBtYXg6IHNsaWNlQ291bnQgLSAxLCB2YWx1ZTogbWluSW5kZXgsIHN0ZXA6IDEsIHNuYXA6IHRydWUsIGxhYmVsVGlja3M6IGZhbHNlLCB0aWNrczogc2xpY2VDb3VudCwgb25DYWxjaXRlU2xpZGVySW5wdXQ6IG9uU2xpZGVyQ2hhbmdlLCBvbkNhbGNpdGVTbGlkZXJDaGFuZ2U6IG9uU2xpZGVyQ2hhbmdlLCByZWY6IChub2RlKSA9PiAoc2xpZGVyVGFyZ2V0ID0gbm9kZSkgfSkpIDogKGgoXCJjYWxjaXRlLXNsaWRlclwiLCB7IGRpc2FibGVkOiBmYWxzZSwgbWluOiAwLCBtYXg6IHNsaWNlQ291bnQgLSAxLCBcIm1pbi12YWx1ZVwiOiBtaW5JbmRleCwgXCJtYXgtdmFsdWVcIjogbWF4SW5kZXgsIHN0ZXA6IDEsIHNuYXA6IHRydWUsIGxhYmVsVGlja3M6IGZhbHNlLCB0aWNrczogc2xpY2VDb3VudCwgb25DYWxjaXRlU2xpZGVySW5wdXQ6IG9uU2xpZGVyQ2hhbmdlLCBvbkNhbGNpdGVTbGlkZXJDaGFuZ2U6IG9uU2xpZGVyQ2hhbmdlLCByZWY6IChub2RlKSA9PiAoc2xpZGVyVGFyZ2V0ID0gbm9kZSkgfSkpO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBcImRpbWVuc2lvbi16b25lXCIgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgZGltZW5zaW9uTGFiZWwpLCBzbGlkZXIsIGgoXCJkaXZcIiwgeyBjbGFzczogdGhpcy51c2VDb21wYWN0RXh0ZW50RHJvcGRvd25zXG4gICAgICAgID8gXCJtdWx0aWRpbWVuc2lvbmFsLWV4dGVudC1jb21wYWN0XCJcbiAgICAgICAgOiBcIm11bHRpZGltZW5zaW9uYWwtZXh0ZW50XCIgfSwgaChcImRpdlwiLCBudWxsLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBzdHJpbmdzLmV4dGVudC5zdGFydCwgc3RhcnRMaXN0KSksIGgoXCJkaXZcIiwgbnVsbCwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgc3RyaW5ncy5leHRlbnQuZW5kLCBlbmRMaXN0KSkpKSk7XG4gIH1cbiAgcmVuZGVyQ2xvc2UoKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5nZW5lcmFsLmNsb3NlLCBpY29uOiBcInhcIiwgc2xvdDogXCJoZWFkZXItYWN0aW9ucy1lbmRcIiwgb25DbGljazogdGhpcy5jYW5jZWwsIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgdGhpcy5yZWZDbG9zZUJ1dHRvbk5vZGUgPSBub2RlO1xuICAgICAgfSB9KSk7XG4gIH1cbiAgcmVuZGVyRG9uZUJ1dHRvbigpIHtcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBzbG90OiBcImZvb3RlclwiLCBvbkNsaWNrOiB0aGlzLmFwcGx5LCBhcHBlYXJhbmNlOiBcInNvbGlkXCIsIHdpZHRoOiBcImhhbGZcIiwgbGFiZWw6IHN0cmluZ3MuZ2VuZXJhbC5kb25lIH0sIHN0cmluZ3MuZ2VuZXJhbC5kb25lKSk7XG4gIH1cbiAgcmVuZGVyQ2FuY2VsQnV0dG9uKCkge1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gdGhpcztcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIG9uQ2xpY2s6IHRoaXMuY2FuY2VsLCBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCB3aWR0aDogXCJoYWxmXCIsIGxhYmVsOiBzdHJpbmdzLmdlbmVyYWwuY2FuY2VsIH0sIHN0cmluZ3MuZ2VuZXJhbC5jYW5jZWwpKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGluaXRMYXllcihsYXllcikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgaWYgKCFsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWxheWVyLmxvYWRlZCkge1xuICAgICAgYXdhaXQgbGF5ZXIubG9hZCgpO1xuICAgIH1cbiAgICB0aGlzLnJhd011bHRpZGltZW5zaW9uYWxJbmZvID0gYXdhaXQgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8obGF5ZXIsIHRydWUpO1xuICAgIGlmICghdGhpcy5yYXdNdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0R5bmFtaWNJbWFnZXJ5ID0gdGhpcy5pc0ltYWdlcnlMYXllcihsYXllcik7XG4gICAgbGV0IGZ1bmN0aW9uTmFtZSA9IFwibm9uZVwiO1xuICAgIGlmIChpc0R5bmFtaWNJbWFnZXJ5KSB7XG4gICAgICBjb25zdCBtdWx0aWRpbWVuc2lvbmFsSW5mbyA9IChfYSA9IChhd2FpdCBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyhsYXllcikpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJhd011bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgICAgY29uc3QgaGFzTXVsdGlwbGVOZXdWYXJpYWJsZXMgPSAoKF9iID0gbXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSA+IDEgJiYgdGhpcy5oYXNOZXdWYXJpYWJsZShtdWx0aWRpbWVuc2lvbmFsSW5mbyk7XG4gICAgICAvLyB0b2RvOiB2YXJpYWJsZSBhL2IvYyB0byBkL2UvZiBpcyBOT1Qgc3VwcG9ydGVkIHNpbmNlIGl0IHJlcXVpcmVzIGV4dHJhY3RpbmcgKG5vdCBzZWxlY3RpbmcpIGEgdmFyaWFibGUsIG5vIHRlc3QgY2FzZSBhcyB3ZWxsLlxuICAgICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IGhhc011bHRpcGxlTmV3VmFyaWFibGVzXG4gICAgICAgID8gdGhpcy5yYXdNdWx0aWRpbWVuc2lvbmFsSW5mb1xuICAgICAgICA6IG11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgICAgZnVuY3Rpb25OYW1lID0gKF9jID0gbGF5ZXIucmFzdGVyRnVuY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mdW5jdGlvbk5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IHRoaXMucmF3TXVsdGlkaW1lbnNpb25hbEluZm87XG4gICAgfVxuICAgIHRoaXMuc291cmNlS2V5ID0gYCR7bGF5ZXIudXJsfS0ke2Z1bmN0aW9uTmFtZX1gO1xuICAgIHRoaXMuYWxsVmFyaWFibGVzID0gdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXMubWFwKCh7IG5hbWUsIHVuaXQsIGRlc2NyaXB0aW9uLCBkaW1lbnNpb25zLCBzdGF0aXN0aWNzIH0pID0+ICh7XG4gICAgICBuYW1lLFxuICAgICAgbGFiZWw6IHVuaXQgPyBgJHtuYW1lfSAoJHt1bml0fSlgIDogbmFtZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgZGltZW5zaW9uTmFtZXM6IGRpbWVuc2lvbnMubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSkuam9pbihcIiwgXCIpLFxuICAgICAgc3RhdGlzdGljc1JhbmdlOiBzdGF0aXN0aWNzID09PSBudWxsIHx8IHN0YXRpc3RpY3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRpc3RpY3MubWFwKCh7IG1pbiwgbWF4IH0pID0+IFttaW4sIG1heF0uam9pbihcIiwgXCIpKS5qb2luKFwiOyBcIilcbiAgICB9KSk7XG4gICAgLy8ga2VlcCBvcmlnaW5hbCBzZXR0aW5nXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpO1xuICAgIGNvbnN0IG1vc2FpY1J1bGUgPSBpc0R5bmFtaWNJbWFnZXJ5ID8gKF9kID0gbGF5ZXIubW9zYWljUnVsZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNsb25lKCkgOiBudWxsO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gKF9lID0gbGF5ZXIucmVuZGVyZXIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jbG9uZSgpO1xuICAgIGNvbnN0IHN1YnNldCA9IChfZiA9IGxheWVyLm11bHRpZGltZW5zaW9uYWxTdWJzZXQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jbG9uZSgpO1xuICAgIHRoaXMub3JpZ2luYWxMYXllclNldHRpbmcgPSB7XG4gICAgICBzdWJzZXQsXG4gICAgICBtb3NhaWNSdWxlLFxuICAgICAgZGVmaW5pdGlvbixcbiAgICAgIHJlbmRlcmVyXG4gICAgfTtcbiAgICAvLyBhY3RpdmUgc3Vic2V0IGFuZCBkZWZpbml0aW9uc1xuICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPSB0aGlzLmVzcmlMYW5nLmNsb25lKHRoaXMub3JpZ2luYWxMYXllclNldHRpbmcuZGVmaW5pdGlvbik7XG4gICAgbGV0IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBudWxsO1xuICAgIGlmICgoX2ggPSAoX2cgPSBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc3Vic2V0RGVmaW5pdGlvbnMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5sZW5ndGgpIHtcbiAgICAgIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0O1xuICAgICAgaWYgKGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQudmFyaWFibGVzLnNvbWUoKHZhcmlhYmxlTmFtZSkgPT4gIXRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzLnNvbWUoKHZhcmlhYmxJbmZvKSA9PiB2YXJpYWJsSW5mby5uYW1lID09PSB2YXJpYWJsZU5hbWUpKSkge1xuICAgICAgICBsYXllci5tdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbExheWVyU2V0dGluZy5zdWJzZXQgPSBudWxsO1xuICAgICAgICBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID0gdGhpcy5nZXREZWZhdWx0TXVsdGlkaW1lbnNpb25hbFN1YnNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQgPSB0aGlzLmdldERlZmF1bHRNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KCk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQ7XG4gICAgdGhpcy5zaG93QW5pbWF0aW9uT25TdGFydFVwICYmIHRoaXMubGF1bmNoRGltZW5zaW9uYWxTbGlkZXJzKCk7XG4gICAgaWYgKHRoaXMud2F0Y2hWaWV3VGltZSAmJiB0aGlzLnZpZXcgJiYgIXRoaXMud2F0Y2hIYW5kbGVWaWV3VGltZSkge1xuICAgICAgdGhpcy53YXRjaEhhbmRsZVZpZXdUaW1lID0gdGhpcy52aWV3LndhdGNoKFwidGltZUV4dGVudFwiLCB0aGlzLnVwZGF0ZUV4dGVudEZyb21UaW1lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud2F0Y2hSYXN0ZXJGdW5jdGlvbiAmJiAhdGhpcy53YXRjaEhhbmRsZUxheWVyICYmIGlzRHluYW1pY0ltYWdlcnkpIHtcbiAgICAgIHRoaXMud2F0Y2hIYW5kbGVMYXllciA9IGxheWVyLndhdGNoKFwicmFzdGVyRnVuY3Rpb25cIiwgZGVib3VuY2UoYXN5bmMgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAoKG5ld1ZhbHVlID09PSBudWxsIHx8IG5ld1ZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdWYWx1ZS5mdW5jdGlvbk5hbWUpID09PSAob2xkVmFsdWUgPT09IG51bGwgfHwgb2xkVmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFZhbHVlLmZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWRJbmZvID0gYXdhaXQgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8obGF5ZXIpO1xuICAgICAgICBpZiAodGhpcy5pc1Byb3BlcnR5VmFsdWVDaGFuZ2VkKG1kSW5mbywgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbykpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgICAgICAgIHRoaXMuaW5pdExheWVyKGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKSk7XG4gICAgfVxuICB9XG4gIGNsb3NlUG9wb3ZlcigpIHtcbiAgICBpZiAodGhpcy5wb3BPdmVyKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucG9wT3Zlcik7XG4gICAgICB0aGlzLnBvcE92ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnZXRNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbihsYXllcikge1xuICAgIGNvbnN0IG11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uID0gZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpO1xuICAgIGlmIChtdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9PT0gbnVsbCB8fCBtdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE5ld011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKHRoaXMuYWxsVmFyaWFibGVzWzBdLm5hbWUpO1xuICB9XG4gIGdldE5ld011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKHNlbGVjdGVkVmFyaWFibGVOYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNlbGVjdGVkVmFyaWFibGVJbmZvID0gdGhpcy5nZXRWYXJpYWJsZUluZm8oc2VsZWN0ZWRWYXJpYWJsZU5hbWUpO1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSAoX2EgPSBzZWxlY3RlZFZhcmlhYmxlSW5mby5kaW1lbnNpb25zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBjb25zdCBzZWxlY3RlZERpbWVuc2lvbk5hbWVzID0gZGltZW5zaW9ucy5tYXAoKGRpbUluZm8pID0+IGRpbUluZm8ubmFtZSk7XG4gICAgY29uc3QgYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gPSB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uIHx8IFtdO1xuICAgIGNvbnN0IG5ld0RlZiA9IHRoaXMuZXNyaUxhbmcuY2xvbmUoYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24pO1xuICAgIGNvbnN0IGFjdGl2ZURpbWVuc2lvbk5hbWVzID0gYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24ubWFwKChkZWYpID0+IGRlZi5kaW1lbnNpb25OYW1lKTtcbiAgICAvLyBoYW5kbGUgc3BlY2lhbCBkaW1lbnNpb24tbGVzcyBjYXNlXG4gICAgaWYgKHNlbGVjdGVkRGltZW5zaW9uTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXdEZWYuZm9yRWFjaCgoZGVmKSA9PiB7XG4gICAgICAgIGRlZi52YXJpYWJsZU5hbWUgPSBzZWxlY3RlZFZhcmlhYmxlTmFtZTtcbiAgICAgICAgZGVmLmRpbWVuc2lvbk5hbWUgPSBcIlwiO1xuICAgICAgICBkZWYudmFsdWVzID0gW107XG4gICAgICAgIGRlZi5pc1NsaWNlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ld0RlZjtcbiAgICB9XG4gICAgY29uc3QgaXNTYW1lRGltZW5zaW9uTGlzdCA9IGFjdGl2ZURpbWVuc2lvbk5hbWVzLmxlbmd0aCA9PT0gc2VsZWN0ZWREaW1lbnNpb25OYW1lcy5sZW5ndGggJiZcbiAgICAgIHNlbGVjdGVkRGltZW5zaW9uTmFtZXMuZXZlcnkoKG5hbWUpID0+IGFjdGl2ZURpbWVuc2lvbk5hbWVzLmluY2x1ZGVzKG5hbWUpKTtcbiAgICBpZiAoaXNTYW1lRGltZW5zaW9uTGlzdCkge1xuICAgICAgbmV3RGVmLmZvckVhY2goKGRlZikgPT4ge1xuICAgICAgICBkZWYudmFyaWFibGVOYW1lID0gc2VsZWN0ZWRWYXJpYWJsZU5hbWU7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbkluZm8gPSBkaW1lbnNpb25zLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkZWYuZGltZW5zaW9uTmFtZSk7XG4gICAgICAgIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbihkZWYsIGRpbWVuc2lvbkluZm8sIHRoaXMuYWN0aXZlTXVsdGlkaW1lbnNpb25hbFN1YnNldCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdEZWY7XG4gICAgfVxuICAgIG5ld0RlZi5sZW5ndGggPSAwO1xuICAgIGRpbWVuc2lvbnMuZm9yRWFjaCgoZGltZW5zaW9uSW5mbykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgbGV0IGRlZiA9IChfYSA9IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uXG4gICAgICAgIC5maW5kKChkZWYpID0+IGRlZi5kaW1lbnNpb25OYW1lID09PSBkaW1lbnNpb25JbmZvLm5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvbmUoKTtcbiAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgZGVmLnZhcmlhYmxlTmFtZSA9IHNlbGVjdGVkVmFyaWFibGVOYW1lO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUoZGltZW5zaW9uSW5mbyk7XG4gICAgICAgIGRlZiA9IG5ldyB0aGlzLkRpbWVuc2lvbmFsRGVmaW5pdGlvbih7XG4gICAgICAgICAgdmFyaWFibGVOYW1lOiBzZWxlY3RlZFZhcmlhYmxlTmFtZSxcbiAgICAgICAgICBkaW1lbnNpb25OYW1lOiBkaW1lbnNpb25JbmZvLm5hbWUsXG4gICAgICAgICAgdmFsdWVzOiBbdmFsdWVdLFxuICAgICAgICAgIGlzU2xpY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVEaW1lbnNpb25hbERlZmluaXRpb24oZGVmLCBkaW1lbnNpb25JbmZvLCB0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQpO1xuICAgICAgbmV3RGVmLnB1c2goZGVmKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3RGVmO1xuICB9XG4gIGlzTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25DaGFuZ2VkKG5ld0RlZikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuZXdEZWYpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uKTtcbiAgfVxuICBsYXVuY2hEaW1lbnNpb25hbFNsaWRlcnMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuZGVzdHJveVZhbHVlUGlja2VyKFwiYm90aFwiKTtcbiAgICBjb25zdCB7IGFjdGl2ZU11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uLCBtdWx0aWRpbWVuc2lvbmFsSW5mbyB9ID0gdGhpcztcbiAgICBjb25zdCBhY3RpdmVWYXJpYWJsZU5hbWUgPSBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvblswXS52YXJpYWJsZU5hbWU7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFibGVJbmZvID0gKF9hID0gbXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBhY3RpdmVWYXJpYWJsZU5hbWUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBtdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXNbMF07XG4gICAgY29uc3QgdGltZURpbWVuc2lvbiA9IGFjdGl2ZVZhcmlhYmxlSW5mby5kaW1lbnNpb25zLmZpbmQoKGRpbWVuc2lvbkluZm8pID0+IGlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCB0cnVlKSk7XG4gICAgdGhpcy5jcmVhdGVWYWx1ZVBpY2tlcih0aW1lRGltZW5zaW9uKTtcbiAgICBjb25zdCB6RGltZW5zaW9uID0gYWN0aXZlVmFyaWFibGVJbmZvLmRpbWVuc2lvbnMuZmluZCgoZGltZW5zaW9uSW5mbykgPT4gIWlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCB0cnVlKSk7XG4gICAgdGhpcy5jcmVhdGVWYWx1ZVBpY2tlcih6RGltZW5zaW9uKTtcbiAgfVxuICBkZXN0cm95VmFsdWVQaWNrZXIodGFyZ2V0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICh0YXJnZXQgPT09IFwidGltZVwiIHx8IHRhcmdldCA9PT0gXCJib3RoXCIpIHtcbiAgICAgIChfYSA9IHRoaXMudmFsdWVQaWNrZXJzLnRpbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGUucmVtb3ZlKCk7XG4gICAgICAoX2IgPSB0aGlzLnZhbHVlUGlja2Vycy50aW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2xpZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudmFsdWVQaWNrZXJzLnRpbWUgPSBudWxsO1xuICAgICAgdGhpcy5hbmltYXRlZERpbWVuc2lvbnMudGltZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT09IFwielwiIHx8IHRhcmdldCA9PT0gXCJib3RoXCIpIHtcbiAgICAgIChfYyA9IHRoaXMudmFsdWVQaWNrZXJzLnopID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5oYW5kbGUucmVtb3ZlKCk7XG4gICAgICAoX2QgPSB0aGlzLnZhbHVlUGlja2Vycy56KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2xpZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudmFsdWVQaWNrZXJzLnogPSBudWxsO1xuICAgICAgdGhpcy5hbmltYXRlZERpbWVuc2lvbnMueiA9IFwiXCI7XG4gICAgfVxuICB9XG4gIGNyZWF0ZVZhbHVlVGlja3Moc3RlcHMsIGNvdW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiBpID09PSAwXG4gICAgICA/IDBcbiAgICAgIDogaSA9PT0gY291bnQgLSAxXG4gICAgICAgID8gc3RlcHMubGVuZ3RoIC0gMVxuICAgICAgICA6IE1hdGgucm91bmQoKGkgKiAoc3RlcHMubGVuZ3RoIC0gMSkpIC8gKGNvdW50IC0gMSkpKTtcbiAgfVxuICBjcmVhdGVWYWx1ZVBpY2tlcihkaW1lbnNpb25JbmZvKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKCFkaW1lbnNpb25JbmZvIHx8ICF0aGlzLnNob3dBbmltYXRpb25Db250cm9scykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwcm9jZXNzIGRpbWVuc2lvbkluZm8gY2xpcHBpbmdcbiAgICBpZiAodGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KSB7XG4gICAgICBkaW1lbnNpb25JbmZvID0gZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8oZGltZW5zaW9uSW5mbywgdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KTtcbiAgICB9XG4gICAgLy8gb25seSBoYXZlIGEgc2luZ2xlIGluc3RhbmNlIG9mIHRpbWUgb3IgeiB2YWx1ZSBwaWNrZXJcbiAgICBjb25zdCBpc1RpbWUgPSBpc1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbywgdHJ1ZSk7XG4gICAgY29uc3QgaXNaZXJvT3JTaW5nbGVTbGljZSA9IGRpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aCA8IDI7XG4gICAgbGV0IHByZXZWYWx1ZVBpY2tlckNvbmZpZyA9IGlzVGltZSA/IHRoaXMudmFsdWVQaWNrZXJzLnRpbWUgOiB0aGlzLnZhbHVlUGlja2Vycy56O1xuICAgIGlmIChpc1plcm9PclNpbmdsZVNsaWNlIHx8XG4gICAgICAocHJldlZhbHVlUGlja2VyQ29uZmlnICYmIHByZXZWYWx1ZVBpY2tlckNvbmZpZy5kaW1lbnNpb25OYW1lICE9PSBkaW1lbnNpb25JbmZvLm5hbWUpKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lWYWx1ZVBpY2tlcihpc1RpbWUgPyBcInRpbWVcIiA6IFwielwiKTtcbiAgICAgIHByZXZWYWx1ZVBpY2tlckNvbmZpZyA9IG51bGw7XG4gICAgfVxuICAgIGlmIChpc1plcm9PclNpbmdsZVNsaWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGdldCBwaWNrZXIgcGFyYW1ldGVyc1xuICAgIGNvbnN0IGFjdGl2ZURpbWVuc2lvblZhbHVlID0gKF9hID0gdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbi5maW5kKCh7IGRpbWVuc2lvbk5hbWUgfSkgPT4gZGltZW5zaW9uTmFtZSA9PT0gZGltZW5zaW9uSW5mby5uYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlcztcbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IGFjdGl2ZURpbWVuc2lvblZhbHVlXG4gICAgICA/IGRpbWVuc2lvbkluZm8udmFsdWVzLmZpbmRJbmRleCgodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkoYWN0aXZlRGltZW5zaW9uVmFsdWVbMF0pXG4gICAgICAgID8gdmFsdWUuam9pbigpID09PSBhY3RpdmVEaW1lbnNpb25WYWx1ZS5qb2luKClcbiAgICAgICAgOiB2YWx1ZSA9PT0gYWN0aXZlRGltZW5zaW9uVmFsdWVbMF0pXG4gICAgICA6IDA7XG4gICAgY29uc3QgZGltVmFsdWVzID0gWy4uLmRpbWVuc2lvbkluZm8udmFsdWVzXTtcbiAgICBsZXQgbGFzdERpbVZhbHVlID0gZGltVmFsdWVzW2RpbVZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsYXN0RGltVmFsdWUpKSB7XG4gICAgICBsYXN0RGltVmFsdWUgPSBsYXN0RGltVmFsdWVbbGFzdERpbVZhbHVlLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICAvLyBBUEkncyBkZWZhdWx0IHogbGF5b3V0IGlzIHJpc2luZyB1cDogc3VpdGFibGUgd2hlbiB6IGRpbWVuc2lvbiBwcmVzZW50cyBhYm92ZS1ncm91bmQgaW5mb3JtYXRpb25cbiAgICAvLyBmb3Igb2NlYW4gZGF0YSwgd2UgbmVlZCB0byByZXZlcnNlIG11bHRpcGxlIHBsYWNlcyB0byBcImRpdmUgaW50byB0aGUgb2NlYW5cIlxuICAgIGNvbnN0IHJldmVyc2VkID0gIWlzVGltZSAmJiBsYXN0RGltVmFsdWUgPD0gMDtcbiAgICBjb25zdCBzdGVwcyA9IGRpbVZhbHVlcy5tYXAoKF92YWwsIGkpID0+IGkpO1xuICAgIGNvbnN0IHN0ZXBDb3VudCA9IHN0ZXBzLmxlbmd0aDtcbiAgICAvLyBsaW1pdCBtYWpvciB0aWNrcyB0byA0IGFuZCBhdm9pZCBjcm93ZGVkIG1pbm9yIHRpY2tzLlxuICAgIGNvbnN0IG1ham9yVGlja3NDb3VudCA9IHN0ZXBDb3VudCA8PSA0ID8gMiA6IGlzVGltZSB8fCBzdGVwQ291bnQgPD0gMTAgPyAzIDogNDtcbiAgICBjb25zdCBtYWpvclRpY2tzID0gdGhpcy5jcmVhdGVWYWx1ZVRpY2tzKHN0ZXBzLCBtYWpvclRpY2tzQ291bnQpO1xuICAgIC8vIGFsaWduIG1ham9yIHRpY2sgdG8gbWlkZGxlIHVzaW5nIDE5OiAoMSArIDkgKiAyKSBmb3IgdGltZSwgKDEgKyA2ICogMykgZm9yIHpcbiAgICBjb25zdCBtaW5vclRpY2tzQ291bnQgPSBNYXRoLm1pbigxOSwgc3RlcENvdW50ID4gMTkgPyBNYXRoLmZsb29yKHN0ZXBDb3VudCAvIDIpIDogc3RlcENvdW50KTtcbiAgICBjb25zdCBtaW5vclRpY2tzID0gdGhpcy5jcmVhdGVWYWx1ZVRpY2tzKHN0ZXBzLCBtaW5vclRpY2tzQ291bnQpO1xuICAgIGNvbnN0IGxhYmVscyA9IFsuLi5tYWpvclRpY2tzXTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSAodmFsdWUsIHZhbHVlVHlwZSkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSByZXZlcnNlZCA/IGRpbVZhbHVlcy5sZW5ndGggLSAxIC0gdmFsdWUgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZVR5cGUgPT09IFwidGlja1wiXG4gICAgICAgID8gZm9ybWF0RGltZW5zaW9uVmFsdWUoZGltVmFsdWVzW2luZGV4XSwgZGltZW5zaW9uSW5mbywge1xuICAgICAgICAgIGludGw6IHRoaXMuaW50bCxcbiAgICAgICAgICB1c2VSZWN1cnJpbmdUaW1lTGFiZWw6IHRydWUsXG4gICAgICAgICAgdXNlRnJpZW5kbHlJU09Gb3JtYXQ6IHRydWUsXG4gICAgICAgICAgdXNlU3RhcnRPckVuZEZvclJhbmdlZFZhbHVlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgIDogZm9ybWF0RGltZW5zaW9uVmFsdWUoZGltVmFsdWVzW2luZGV4XSwgZGltZW5zaW9uSW5mbywge1xuICAgICAgICAgIGludGw6IHRoaXMuaW50bCxcbiAgICAgICAgICB1c2VSZWN1cnJpbmdUaW1lTGFiZWw6IHRydWUsXG4gICAgICAgICAgdXNlRnJpZW5kbHlJU09Gb3JtYXQ6IHRydWUsXG4gICAgICAgICAgZm9ybWF0OiBcInNob3J0LWRhdGUtbG9uZy10aW1lXCJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBjcmVhdGUgYW5kIGFkZCB0byB2aWV3IHVpXG4gICAgY29uc3QgdmFsdWVQaWNrZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uU2V0dGluZyB9ID0gdGhpcztcbiAgICB2YWx1ZVBpY2tlckRpdi5jbGFzc0xpc3QuYWRkKGlzVGltZSA/IGFuaW1hdGlvblNldHRpbmcudGltZUNsYXNzTmFtZSA6IGFuaW1hdGlvblNldHRpbmcuekNsYXNzTmFtZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2YWx1ZVBpY2tlckRpdik7XG4gICAgLy8gZ3VhcmQgZm9yIDAgb3IgbmVnYXRpdmUgcGxheXJhdGUuIHRpbGVkIGltYWdlcnkgY2FuIHVzZSBhIHNob3J0ZXIgaW50ZXJ2YWxcbiAgICBjb25zdCBwbGF5UmF0ZSA9IGFuaW1hdGlvblNldHRpbmcucGxheVJhdGUgPD0gMFxuICAgICAgPyB0aGlzLmlzSW1hZ2VyeUxheWVyKHRoaXMubGF5ZXIpXG4gICAgICAgID8gMzAwMFxuICAgICAgICA6IDIwMDBcbiAgICAgIDogYW5pbWF0aW9uU2V0dGluZy5wbGF5UmF0ZTtcbiAgICAvLyB1cGRhdGUgb3IgY3JlYXRlIHZhbHVlIHBpY2tlclxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHtcbiAgICAgIHR5cGU6IFwic2xpZGVyXCIsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IGRpbVZhbHVlcy5sZW5ndGggLSAxLFxuICAgICAgc3RlcHMsXG4gICAgICBtaW5vclRpY2tzLFxuICAgICAgbWFqb3JUaWNrcyxcbiAgICAgIGxhYmVscyxcbiAgICAgIHJldmVyc2VkLFxuICAgICAgdmlzaWJsZUVsZW1lbnRzOiB7XG4gICAgICAgIHRodW1iVG9vbHRpcDogdGhpcy5zaG93QW5pbWF0aW9uVG9vbHRpcFxuICAgICAgfSxcbiAgICAgIGxhYmVsRm9ybWF0RnVuY3Rpb246IGZvcm1hdHRlclxuICAgIH07XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5nZXRTZWxlY3RlZFNsaWRlclZhbHVlKGFjdGl2ZUluZGV4LCByZXZlcnNlZCwgZGltVmFsdWVzLmxlbmd0aCk7XG4gICAgaWYgKHByZXZWYWx1ZVBpY2tlckNvbmZpZykge1xuICAgICAgcHJldlZhbHVlUGlja2VyQ29uZmlnLmhhbmRsZS5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IHZhbHVlUGlja2VyID0gcHJldlZhbHVlUGlja2VyQ29uZmlnLnNsaWRlcjtcbiAgICAgIHZhbHVlUGlja2VyLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgIHZhbHVlUGlja2VyLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHByZXZWYWx1ZVBpY2tlckNvbmZpZy5kaW1lbnNpb25WYWx1ZXMgPSBkaW1WYWx1ZXM7XG4gICAgICBwcmV2VmFsdWVQaWNrZXJDb25maWcuaGFuZGxlID0gdmFsdWVQaWNrZXIud2F0Y2goXCJ2YWx1ZXNcIiwgKHYpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXZlcnNlZCA/IGRpbVZhbHVlcy5sZW5ndGggLSAxIC0gdlswXSA6IHZbMF07XG4gICAgICAgIHRoaXMudXBkYXRlRGVmaW5pdGlvbkRpbWVuc2lvblZhbHVlKGRpbWVuc2lvbkluZm8ubmFtZSwgZGltVmFsdWVzW2luZGV4XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVQaWNrZXIgPSBuZXcgdGhpcy5WYWx1ZVBpY2tlcih7XG4gICAgICBjYXB0aW9uOiBkaW1lbnNpb25JbmZvLm5hbWUsXG4gICAgICBsYXlvdXQ6IGlzVGltZSA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgY29udGFpbmVyOiB2YWx1ZVBpY2tlckRpdixcbiAgICAgIGxhYmVsOiBkaW1lbnNpb25JbmZvLm5hbWUsXG4gICAgICBwbGF5UmF0ZSxcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIHZhbHVlc1xuICAgIH0pO1xuICAgIHRoaXMudmlldy51aS5hZGQodmFsdWVQaWNrZXIsIHsgcG9zaXRpb246IFwibWFudWFsXCIgfSk7XG4gICAgY29uc3QgaGFuZGxlID0gdmFsdWVQaWNrZXIud2F0Y2goXCJ2YWx1ZXNcIiwgKHYpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmV2ZXJzZWQgPyBkaW1WYWx1ZXMubGVuZ3RoIC0gMSAtIHZbMF0gOiB2WzBdO1xuICAgICAgdGhpcy51cGRhdGVEZWZpbml0aW9uRGltZW5zaW9uVmFsdWUoZGltZW5zaW9uSW5mby5uYW1lLCBkaW1WYWx1ZXNbaW5kZXhdKTtcbiAgICB9KTtcbiAgICAvLyBhdm9pZCBvYnN0cnVjdGlvbiBmb3IgaG9yaXpvbnRhbCB2YWx1ZSBwaWNrZXIgd2l0aCBkZWZhdWx0IHRvcCBwbGFjZW1lbnRcbiAgICBjb25zdCB0b29sdGlwUGxhY2VtZW50ID0gaXNUaW1lXG4gICAgICA/IChfYiA9IHRoaXMuYW5pbWF0aW9uU2V0dGluZy50aW1lVG9vbHRpcFBsYWNlbWVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJ0b3BcIlxuICAgICAgOiAoX2MgPSB0aGlzLmFuaW1hdGlvblNldHRpbmcuelRvb2x0aXBQbGFjZW1lbnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiYXV0b1wiO1xuICAgIGlmICh0b29sdGlwUGxhY2VtZW50ICE9PSBcImF1dG9cIikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiAodmFsdWVQaWNrZXJEaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYWxjaXRlLXRvb2x0aXBcIilbMF0ucGxhY2VtZW50ID0gdG9vbHRpcFBsYWNlbWVudCksIDEwMDApO1xuICAgIH1cbiAgICBjb25zdCBwaWNrZXJDb25maWcgPSB7XG4gICAgICBzbGlkZXI6IHZhbHVlUGlja2VyLFxuICAgICAgZGltZW5zaW9uTmFtZTogZGltZW5zaW9uSW5mby5uYW1lLFxuICAgICAgZGltZW5zaW9uVmFsdWVzOiBkaW1WYWx1ZXMsXG4gICAgICBoYW5kbGVcbiAgICB9O1xuICAgIGlmIChpc1RpbWUpIHtcbiAgICAgIHRoaXMudmFsdWVQaWNrZXJzLnRpbWUgPSBwaWNrZXJDb25maWc7XG4gICAgICB0aGlzLmFuaW1hdGVkRGltZW5zaW9ucy50aW1lID0gZGltZW5zaW9uSW5mby5uYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWVQaWNrZXJzLnogPSBwaWNrZXJDb25maWc7XG4gICAgICB0aGlzLmFuaW1hdGVkRGltZW5zaW9ucy56ID0gZGltZW5zaW9uSW5mby5uYW1lO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQb3BvdmVyUHJvcHMoKSB7XG4gICAgY29uc3Qgc3Vic2V0VmFyaWFibGVzID0gdGhpcy5hY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0LnZhcmlhYmxlcztcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGRvIG5vdCB1cGRhdGUgcG9wb3ZlciB3aGVuIGFsbCB1bnNlbGVjdGVkXG4gICAgaWYgKHRoaXMucHJldmlvdXNQaWNrZWRMaXN0U2l6ZSA9PT0gMCAmJlxuICAgICAgc3Vic2V0VmFyaWFibGVzLmxlbmd0aCA9PT0gdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgYWxsVmFyaWFibGVzLCBwb3BPdmVyIH0gPSB0aGlzO1xuICAgIHBvcE92ZXIuc2VsZWN0ZWRGaWVsZHMgPSBzdWJzZXRWYXJpYWJsZXM7XG4gICAgcG9wT3Zlci5maWVsZHMgPSBhbGxWYXJpYWJsZXMubWFwKCh2YXJpYWJsZSkgPT4gKHtcbiAgICAgIG5hbWU6IHZhcmlhYmxlLm5hbWUsXG4gICAgICBhbGlhczogdmFyaWFibGUubmFtZSxcbiAgICAgIHR5cGU6IFwiU3RyaW5nXCIsXG4gICAgICBkZXNjcmlwdGlvbjogdmFyaWFibGUuZGVzY3JpcHRpb25cbiAgICB9KSk7XG4gICAgY29uc3QgdGhyZXNob2xkID0gYWxsVmFyaWFibGVzWzBdLmRlc2NyaXB0aW9uID8gNSA6IDEwO1xuICAgIHBvcE92ZXIuc2hvd0ZpbHRlckxlbmd0aCA9XG4gICAgICB0aGlzLnNob3dWYXJpYWJsZUZpbHRlciA9PSBudWxsXG4gICAgICAgID8gdGhyZXNob2xkXG4gICAgICAgIDogdGhpcy5zaG93VmFyaWFibGVGaWx0ZXJcbiAgICAgICAgICA/IDFcbiAgICAgICAgICA6IGFsbFZhcmlhYmxlcy5sZW5ndGggKyAxO1xuICB9XG4gIGdldERlZmF1bHRNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KHZhcmlhYmxlTmFtZXMpIHtcbiAgICAvLyBzdWJzZXQgZGVmaW5pdGlvbnNcbiAgICBjb25zdCB7IHZhcmlhYmxlcyB9ID0gdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbiAgICBjb25zdCBzdWJzZXREZWZpbml0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IG5hbWU6IHZhcmlhYmxlTmFtZSwgZGltZW5zaW9ucyB9ID0gdmFyaWFibGVzW2ldO1xuICAgICAgaWYgKCh2YXJpYWJsZU5hbWVzID09PSBudWxsIHx8IHZhcmlhYmxlTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhcmlhYmxlTmFtZXMubGVuZ3RoKSAmJiAhdmFyaWFibGVOYW1lcy5pbmNsdWRlcyh2YXJpYWJsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRpbWVuc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN1YnNldERlZmluaXRpb25zLnB1c2goeyB2YXJpYWJsZU5hbWUsIGRpbWVuc2lvbk5hbWU6IFwiXCIsIHZhbHVlczogW10sIGlzU2xpY2U6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25zW2pdLm5hbWU7XG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gWy4uLmRpbWVuc2lvbnNbal0uZXh0ZW50XTtcbiAgICAgICAgICBzdWJzZXREZWZpbml0aW9ucy5wdXNoKHsgdmFyaWFibGVOYW1lLCBkaW1lbnNpb25OYW1lLCB2YWx1ZXMsIGlzU2xpY2U6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcy5NdWx0aWRpbWVuc2lvbmFsU3Vic2V0KHtcbiAgICAgIGFyZWFPZkludGVyZXN0OiBudWxsLFxuICAgICAgc3Vic2V0RGVmaW5pdGlvbnNcbiAgICB9KTtcbiAgfVxuICBnZXRWYXJpYWJsZUluZm8odmFyaWFibGVOYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgdmFyaWFibGVzIH0gPSB0aGlzLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgIHJldHVybiB0aGlzLmlzRGVmYXVsdFVuc3BlY2lmaWVkVmFyaWFibGUodmFyaWFibGVOYW1lKVxuICAgICAgPyB2YXJpYWJsZXNbMF1cbiAgICAgIDogKF9hID0gdmFyaWFibGVzLmZpbmQoKGluZm8pID0+IGluZm8ubmFtZSA9PT0gdmFyaWFibGVOYW1lKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFyaWFibGVzWzBdO1xuICB9XG4gIGdldFNlbGVjdGVkU2xpZGVyVmFsdWUoZGltSW5kZXgsIHJldmVyc2VkLCBjb3VudCkge1xuICAgIHJldHVybiBbZGltSW5kZXggPT09IC0xID8gMCA6IHJldmVyc2VkID8gY291bnQgLSAxIC0gZGltSW5kZXggOiBkaW1JbmRleF07XG4gIH1cbiAgaXNEZWZhdWx0VW5zcGVjaWZpZWRWYXJpYWJsZSh2YXJpYWJsZU5hbWUpIHtcbiAgICByZXR1cm4gW1wiXCIsIFwiKlwiLCB0aGlzLnN0cmluZ3MuZGlzcGxheS5kZWZhdWx0VmFyaWFibGVdLmluY2x1ZGVzKHZhcmlhYmxlTmFtZSk7XG4gIH1cbiAgaXNQcm9wZXJ0eVZhbHVlQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUgIT09IG51bGwgJiYgbmV3VmFsdWUgIT09IHZvaWQgMCA/IG5ld1ZhbHVlIDogdW5kZWZpbmVkKSAhPT0gSlNPTi5zdHJpbmdpZnkob2xkVmFsdWUgIT09IG51bGwgJiYgb2xkVmFsdWUgIT09IHZvaWQgMCA/IG9sZFZhbHVlIDogdW5kZWZpbmVkKTtcbiAgfVxuICBoYXNOZXdWYXJpYWJsZShtdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgIHJldHVybiBtdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXMuc29tZSgodmFyaWFibGVJbmZvKSA9PiAhdGhpcy5yYXdNdWx0aWRpbWVuc2lvbmFsSW5mby52YXJpYWJsZXMuc29tZSgocmF3VmFyaWFibGVJbmZvKSA9PiByYXdWYXJpYWJsZUluZm8ubmFtZSA9PT0gdmFyaWFibGVJbmZvLm5hbWUpKTtcbiAgfVxuICBpc0ltYWdlcnlMYXllcihsYXllcikge1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcImltYWdlcnlcIjtcbiAgfVxuICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJsYXllclwiOiBbXCJ3YXRjaExheWVyXCJdLFxuICAgIFwiYWN0aXZlTXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25cIjogW1wid2F0Y2hBY3RpdmVNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvblwiXSxcbiAgICBcImFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXRcIjogW1wid2F0Y2hhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0XCJdXG4gIH07IH1cbn07XG5BcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsLnN0eWxlID0gYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbENzcztcblxuZXhwb3J0IHsgQXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbCBhcyBhcmNnaXNfcmFzdGVyX211bHRpZGltZW5zaW9uYWwgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgIHJldHVybiBzdGF0dXM7XG4gIH1cbiAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICBjb25zdCBvYmpzID0gW107XG4gIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tMTNmNWIwMGMuanMnO1xuaW1wb3J0IHsgbCBhcyBsYW5ndWFnZU1hcCB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLTIyMjU4YzkwLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9zdGVuY2lsLXRyaWNrcy9pbXBsZW1lbnRpbmctaW50ZXJuYXRpb25hbGlzYXRpb24taTE4bi13aXRoLXN0ZW5jaWwtNWU2NTU5NTU0MTE3XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcuc2xpY2UoMCwgMikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBcImVuXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIC8vIGl0J3MgT0sgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgNCBsZXR0ZXIgbGFuZ3VhZ2UgZmlsZSBmb3IgaXRcbiAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgIC8vIHdlIHN1cHBvcnQgdGhlIDIgbGV0dGVyIGNvZGVkIGxhbmd1YWdlXG4gICAgICAvLyBlLmcuIGl0LUNIIHZzIGl0XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoKGdldEFzc2V0UGF0aChgLi4vYXJjZ2lzLWFwcC1hc3NldHMvaTE4bi8ke2NvbXBvbmVudE5hbWV9LmkxOG4uJHtsb2NhbGV9Lmpzb25gKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0Lm9rKVxuICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgZWxzZVxuICAgICAgICByZWplY3QoKTtcbiAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gIH0pO1xufVxuY29uc3Qgc3RyaW5nQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgY29uc3QgaWQgPSBgJHtjb21wb25lbnROYW1lfSR7bG9jYWxlfWA7XG4gIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgc3RyaW5nQ2FjaGVbaWRdID0gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ0NhY2hlW2lkXTtcbn1cbi8qKlxuICogR2V0IHN0cmluZ3MgYW5kIGxhbmd1YWdlIGNvZGVzLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyAyIGxhbmd1YWdlIGNvZGVzLlxuICogVGhlIGZpcnN0IG9uZSByZXR1cm5zIGEgY29kZSB0aGF0J3MgYWxzbyBzdXBwb3J0ZWQgYXMgYSBsYW5ndWFnZSBmaWxlLlxuICogVGhlIHNlY29uZCBvbmUgcmV0dXJucyBhIGNvZGUgd2hlcmUgdGhlcmUgaXMgc3VwcG9ydCBmb3IgdGhlIGZpcnN0IDIgbGV0dGVycyBvZiB0aGUgY29kZSBhcyBwYXJ0IG9mIGEgbGFuZ3VhZ2UgZmlsZSxcbiAqIGJ1dCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgNCBsZXR0ZXIgY29kZSBmcm9tIHRoZSBwYWdlLlxuICogRS5nLiBGb3IgXCJpdC1jaFwiIGl0IHdpbGwgcmV0dXJuIFwiaXRcIiBhcyB0aGUgZmlyc3QgbGFuZ3VhZ2UgY29kZSBhbmQgXCJpdC1jaFwiIGFzIHRoZSBzZWNvbmQuXG4gKiBUaGUgc2Vjb25kIG9uZSBpcyByZXF1aXJlZCBmb3IgZXNyaS5pbnRsLnNldExvY2FsZSgpIHRvIGdldCB0aGUgY29ycmVjdCBmb3JtYXR0aW5nLlxuICpcbiAqIElmIGEgdGFnTmFtZSBpcyBwcm92aWRlZCBpdCB3aWxsIG92ZXJ3aXRlIHRoZSBlbGVtZW50J3MgdGFnTmFtZVxuICpcbiAqICBAcmV0dXJuIFsgc3RyaW5ncywgZmlyc3QgbGFuZ3VhZ2UgY29kZSwgc2Vjb25kIGxhbmd1YWdlIGNvZGVdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MoZWxlbWVudCwgdGFnTmFtZSkge1xuICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlSW50bCA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCk7XG4gIGxldCBzdHJpbmdzO1xuICB0cnkge1xuICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50TGFuZ3VhZ2UpO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgXCJlblwiKTtcbiAgfVxuICByZXR1cm4gW3N0cmluZ3MsIGNvbXBvbmVudExhbmd1YWdlLCBjb21wb25lbnRMYW5ndWFnZUludGxdO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgYXMgYSwgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyBhcyBnIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGkgYXMgaXNEZWZpbmVkIH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtNTI2MmIwOTQuanMnO1xuXG5jb25zdCBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8gPSAxMC45O1xuZnVuY3Rpb24gZm9ybWF0VGltZSh2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICBjb25zdCB7IHVzZUZyaWVuZGx5SVNPRm9ybWF0LCBpbnRsLCBmb3JtYXQgfSA9IG9wdGlvbnM7XG4gIGlmICh1c2VGcmllbmRseUlTT0Zvcm1hdCAmJiBpbnRsKSB7XG4gICAgcmV0dXJuIGludGwuZm9ybWF0RGF0ZShkYXRlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKGZvcm1hdCAhPT0gbnVsbCAmJiBmb3JtYXQgIT09IHZvaWQgMCA/IGZvcm1hdCA6IFwic2hvcnQtZGF0ZS1sb25nLXRpbWVcIikpLCB7IHRpbWVab25lOiBcIlVUQ1wiIH0pKTtcbiAgfVxuICBsZXQgaXNvVGltZVN0cmluZyA9IG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpO1xuICBpc29UaW1lU3RyaW5nID0gaXNvVGltZVN0cmluZy5zbGljZSgwLCBpc29UaW1lU3RyaW5nLmluZGV4T2YoXCIuXCIpKSArIFwiWlwiO1xuICByZXR1cm4gaXNvVGltZVN0cmluZztcbn1cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoKHZhbHVlX2Jhc2UxLCBpbnRsLCBmb3JtYXQgPSBcImxvbmdcIikge1xuICAvLyB1c2luZyBhbiBhcmJpdHJhcnkgZGF0ZSAodGhlIGRheSB0aGUgY29kZSB3YXMgd3JpdHRlbikgdG8gYXZvaWQgc2lkZSBlZmZlY3RzIG9mIHNldE1vbnRoIG5lYXIgdGhlIGVuZCBvZiB0aGUgbW9udGhcbiAgLy8gc2V0TW9udGggd2lsbCBtb3ZlIHRoZSBkYXRlIHRvIHRoZSBuZXh0IG1vbnRoIHdoZW4gbmV3IG1vbnRoIGRvZXNuJ3QgaGF2ZSBjdXJyZW50IGRhdGUgKGUuZy4gOS8zMSwgMi8zMClcbiAgLy8gZGF0ZSA9IG5ldyBEYXRlKDIwMDIsIDksIDMxKTsgZGF0ZS5zZXRNb250aCg4KTsgY29uc29sZS5sb2coZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKSlcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDIwMjIsIDksIDEwKTtcbiAgZGF0ZS5zZXRNb250aCh2YWx1ZV9iYXNlMSAtIDEpO1xuICByZXR1cm4gaW50bC5mb3JtYXREYXRlKGRhdGUsIHsgbW9udGg6IGZvcm1hdCB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFF1YXJ0ZXIodmFsdWVfYmFzZTEsIGludGwpIHtcbiAgY29uc3Qgc3RhcnRNb250aCA9IGZvcm1hdE1vbnRoKCh2YWx1ZV9iYXNlMSAtIDEpICogMyArIDEsIGludGwsIFwic2hvcnRcIik7XG4gIGNvbnN0IGVuZE1vbnRoID0gZm9ybWF0TW9udGgodmFsdWVfYmFzZTEgKiAzLCBpbnRsLCBcInNob3J0XCIpO1xuICByZXR1cm4gYCR7c3RhcnRNb250aH0gLSAke2VuZE1vbnRofWA7XG59XG5mdW5jdGlvbiBmb3JtYXREaW1lbnNpb25WYWx1ZSh2YWx1ZSwgZGltZW5zaW9uSW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCB7IGludGwsIHVzZVJlY3VycmluZ1RpbWVMYWJlbCB9ID0gb3B0aW9ucztcbiAgaWYgKHVzZVJlY3VycmluZ1RpbWVMYWJlbCAmJiBpbnRsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGludGVydmFsVW5pdCA9IChfYSA9IGRpbWVuc2lvbkluZm8uaW50ZXJ2YWxVbml0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgLy8gd2Vla2x5IGFuZCBkYWlseSBhcmUgbm90IHN1cHBvcnRlZCB5ZXRcbiAgICBjb25zdCBjYW5Vc2VSZWN1cnJpbmdUaW1lTGFiZWwgPSBpc1JlY3VycmluZ1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbykgJiYgKGludGVydmFsVW5pdCA9PT0gXCJtb250aHNcIiB8fCBpbnRlcnZhbFVuaXQgPT09IFwicXVhcnRlcnNcIik7XG4gICAgaWYgKGNhblVzZVJlY3VycmluZ1RpbWVMYWJlbCkge1xuICAgICAgcmV0dXJuIGludGVydmFsVW5pdCA9PT0gXCJtb250aHNcIiA/IGZvcm1hdE1vbnRoKHZhbHVlLCBpbnRsKSA6IGZvcm1hdFF1YXJ0ZXIodmFsdWUsIGludGwpO1xuICAgIH1cbiAgfVxuICAvLyB0aGlzIGlzIHByZWZlcmVkIHdoZW4gbGFiZWxpbmcgYSBzbGlkZXIgYWxpa2UgY29udHJvbFxuICBjb25zdCBsYXN0RWxlbWVudCA9IChfYiA9IGRpbWVuc2lvbkluZm8udmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gIGlmIChvcHRpb25zLnVzZVN0YXJ0T3JFbmRGb3JSYW5nZWRWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgQXJyYXkuaXNBcnJheShsYXN0RWxlbWVudCkpIHtcbiAgICBjb25zdCBpc0xhc3RFbGVtZW50ID0gdmFsdWUuam9pbihcIi1cIikgPT09IGxhc3RFbGVtZW50LmpvaW4oXCItXCIpO1xuICAgIHZhbHVlID0gaXNMYXN0RWxlbWVudCA/IHZhbHVlWzFdIDogdmFsdWVbMF07XG4gIH1cbiAgY29uc3QgaXNUaW1lID0gaXNUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pO1xuICBpZiAoIWlzVGltZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgPyB2YWx1ZS5tYXAoKGVsZW1lbnQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gaW50bCA9PT0gbnVsbCB8fCBpbnRsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRsLmZvcm1hdE51bWJlcihlbGVtZW50KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyaW5nKGVsZW1lbnQpOyB9KS5qb2luKFwiIC0gXCIpXG4gICAgICA6IChfYyA9IGludGwgPT09IG51bGwgfHwgaW50bCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50bC5mb3JtYXROdW1iZXIodmFsdWUpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBTdHJpbmcodmFsdWUpO1xuICB9XG4gIGlmIChvcHRpb25zLnVzZUZyaWVuZGx5SVNPRm9ybWF0ICYmICFvcHRpb25zLmZvcm1hdCkge1xuICAgIGxldCByZXNvbHV0aW9uID0gKF9kID0gZGltZW5zaW9uSW5mby5pbnRlcnZhbFVuaXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBsZXQgeyBpbnRlcnZhbCwgZXh0ZW50IH0gPSBkaW1lbnNpb25JbmZvO1xuICAgIGlmIChyZXNvbHV0aW9uID09PSBcIm1vbnRoc1wiKSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgPiAxMSkge1xuICAgICAgICByZXNvbHV0aW9uID0gXCJ5ZWFyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc29sdXRpb24gPT09IFwiZGF5c1wiKSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgPiAzNjQpIHtcbiAgICAgICAgcmVzb2x1dGlvbiA9IFwieWVhclwiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaW50ZXJ2YWwgPiAyNykge1xuICAgICAgICByZXNvbHV0aW9uID0gXCJtb250aHNcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzb2x1dGlvbiA9PT0gXCJob3Vyc1wiKSB7XG4gICAgICByZXNvbHV0aW9uID0gXCJkYXlzXCI7XG4gICAgfVxuICAgIGlmICghW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLmluY2x1ZGVzKHJlc29sdXRpb24pICYmIChleHRlbnQgPT09IG51bGwgfHwgZXh0ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnQubGVuZ3RoKSkge1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKSAvIGRpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGRheSA9IDg2NDAwMDAwO1xuICAgICAgaWYgKGludGVydmFsID49IDM2NSAqIGRheSkge1xuICAgICAgICByZXNvbHV0aW9uID0gXCJ5ZWFyc1wiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaW50ZXJ2YWwgPj0gMjggKiBkYXkpIHtcbiAgICAgICAgcmVzb2x1dGlvbiA9IFwibW9udGhzXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHJlc29sdXRpb24gPT09IFwieWVhcnNcIiA/IFwieWVhclwiIDogcmVzb2x1dGlvbiA9PT0gXCJtb250aHNcIiA/IFwic2hvcnQtbW9udGgteWVhclwiIDogXCJzaG9ydC1kYXRlXCI7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBmb3JtYXQgfSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgPyB2YWx1ZS5tYXAoKGVsZW1lbnQpID0+IGZvcm1hdFRpbWUoZWxlbWVudCwgb3B0aW9ucykpLmpvaW4oXCIgLSBcIilcbiAgICA6IGZvcm1hdFRpbWUodmFsdWUsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8oZGltZW5zaW9uSW5mbywgbXVsdGlkaW1lbnNpb25hbFN1YnNldCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGNvbnN0cmFpbnQgPSAoX2EgPSBtdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID09PSBudWxsIHx8IG11bHRpZGltZW5zaW9uYWxTdWJzZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11bHRpZGltZW5zaW9uYWxTdWJzZXQuZGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkaW1lbnNpb25JbmZvLm5hbWUpO1xuICBpZiAoIShjb25zdHJhaW50ID09PSBudWxsIHx8IGNvbnN0cmFpbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnN0cmFpbnQuZXh0ZW50KSkge1xuICAgIHJldHVybiBkaW1lbnNpb25JbmZvO1xuICB9XG4gIGNvbnN0IGV4dGVudCA9IFsuLi5jb25zdHJhaW50LmV4dGVudF07XG4gIGNvbnN0IHZhbHVlcyA9IGRpbWVuc2lvbkluZm8udmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHtcbiAgICAvLyBtdXN0IGJlIGNvbnRhaW5lZCwgaW50ZXJzZWN0aW9uIGlzIG5vdCBzdWZmaWNpZW50XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoIWlzRGVmaW5lZChleHRlbnRbMV0pIHx8IGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVswXSA9PT0gZXh0ZW50WzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlWzBdID49IGV4dGVudFswXSAmJiB2YWx1ZVswXSA8PSBleHRlbnRbMV0gJiYgdmFsdWVbMV0gPj0gZXh0ZW50WzBdICYmIHZhbHVlWzFdIDw9IGV4dGVudFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID49IGV4dGVudFswXSAmJiB2YWx1ZSA8PSBleHRlbnRbMV07XG4gIH0pO1xuICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlLCB3aGVuIGxhc3Qgc2xpY2Ugb2YgYSByYW5nZWQgZGltZW5zaW9uIHNlcmllcyBpcyB1c2VkXG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgbGFzdFZhbHVlID0gZGltZW5zaW9uSW5mby52YWx1ZXNbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGFzdFZhbHVlKSAmJiBsYXN0VmFsdWVbMV0gPT09IGV4dGVudFswXSkge1xuICAgICAgdmFsdWVzLnB1c2gobGFzdFZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGltZW5zaW9uSW5mbyksIHsgZXh0ZW50LCB2YWx1ZXMgfSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZShkaW1lbnNpb25JbmZvKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyB2YWx1ZXMsIGV4dGVudCwgbmFtZSB9ID0gZGltZW5zaW9uSW5mbztcbiAgbGV0IHZhbHVlID0gKF9hID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleHRlbnRbMF07XG4gIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3RkelwiICYmXG4gICAgIWRpbWVuc2lvbkluZm8uaGFzUmFuZ2VzICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50WzFdKSA8PSBNYXRoLmFicyhleHRlbnRbMF0pKSB7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YWx1ZSA9IGV4dGVudFsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCJcbiAgICA/IGxheWVyLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uXG4gICAgOiAoX2IgPSAoKF9hID0gbGF5ZXIubW9zYWljUnVsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGF5ZXIuX2RlZmF1bHRTZXJ2aWNlTW9zYWljUnVsZSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE11bHRpZGltZW5zaW9uYWxJbmZvKGxheWVyLCB1c2VSYXdTb3VyY2VJbmZvKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmIChsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiKSB7XG4gICAgcmV0dXJuIGxheWVyLnJhc3RlckluZm8ubXVsdGlkaW1lbnNpb25hbEluZm87XG4gIH1cbiAgY29uc3QgeyByYXN0ZXJGdW5jdGlvbiwgdmVyc2lvbiB9ID0gbGF5ZXI7XG4gIGlmICh1c2VSYXdTb3VyY2VJbmZvIHx8XG4gICAgdmVyc2lvbiA8PSBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8gfHxcbiAgICAhcmFzdGVyRnVuY3Rpb24gfHxcbiAgICAoKF9hID0gcmFzdGVyRnVuY3Rpb24uZnVuY3Rpb25OYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGxheWVyLnNlcnZpY2VSYXN0ZXJJbmZvLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICB9XG4gIGNvbnN0IHJhc3RlckluZm8gPSAoX2IgPSAoYXdhaXQgbGF5ZXIuZ2VuZXJhdGVSYXN0ZXJJbmZvKGxheWVyLnJhc3RlckZ1bmN0aW9uKSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxheWVyLnNlcnZpY2VSYXN0ZXJJbmZvO1xuICByZXR1cm4gcmFzdGVySW5mby5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbn1cbmZ1bmN0aW9uIGlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCBpZ25vcmVSZWN1cmluZyA9IGZhbHNlKSB7XG4gIHJldHVybiBkaW1lbnNpb25JbmZvLm5hbWUgPT09IFwiU3RkVGltZVwiICYmIChpZ25vcmVSZWN1cmluZyB8fCAhZGltZW5zaW9uSW5mby5yZWN1cnJpbmcpO1xufVxuZnVuY3Rpb24gaXNSZWN1cnJpbmdUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pIHtcbiAgcmV0dXJuIGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRUaW1lXCIgJiYgISFkaW1lbnNpb25JbmZvLnJlY3VycmluZztcbn1cbmZ1bmN0aW9uIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbihkZWYsIGRpbWVuc2lvbkluZm8sIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQpIHtcbiAgZGltZW5zaW9uSW5mbyA9IGdldENsaXBwZWREaW1lbnNpb25JbmZvKGRpbWVuc2lvbkluZm8sIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQpO1xuICBjb25zdCBvcmlnaW5hbEZvcm1hdHRlZFZhbHVlID0gZm9ybWF0RGltZW5zaW9uVmFsdWUoZGVmLnZhbHVlc1swXSwgZGltZW5zaW9uSW5mbyk7XG4gIGNvbnN0IGhhc09yaWdpbmFsRm9ybWF0dGVkVmFsdWUgPSBkaW1lbnNpb25JbmZvLnZhbHVlcy5zb21lKCh2YWwpID0+IG9yaWdpbmFsRm9ybWF0dGVkVmFsdWUgPT09IGZvcm1hdERpbWVuc2lvblZhbHVlKHZhbCwgZGltZW5zaW9uSW5mbykpO1xuICBpZiAoIWhhc09yaWdpbmFsRm9ybWF0dGVkVmFsdWUpIHtcbiAgICAvLyBnZXQgZGVmYXVsdCBzbGljZSB2YWx1ZSB3aGVuIGRlZi52YWx1ZXMgaXMgaW52YWxpZFxuICAgIGNvbnN0IHZhbHVlID0gZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUoZGltZW5zaW9uSW5mbyk7XG4gICAgZGVmLnZhbHVlcyA9IFt2YWx1ZV07XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8gYXMgYSwgZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUgYXMgYiwgZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gYXMgYywgZm9ybWF0RGltZW5zaW9uVmFsdWUgYXMgZiwgZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8gYXMgZywgaXNUaW1lRGltZW5zaW9uIGFzIGksIG1pblZlcnNpb25SRlRNdWx0aWRpbWVuc2lvbmFsSW5mbyBhcyBtLCB1cGRhdGVEaW1lbnNpb25hbERlZmluaXRpb24gYXMgdSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9