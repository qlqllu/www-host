"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_portal-671419"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ configState),
/* harmony export */   o: () => (/* binding */ onConfigChange)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const configStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  portal: null,
  user: null,
  api: 4,
  scale: "m"
});
const configState = configStore.state;
const onConfigChange = configStore.onChange;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getPortalRestInfo),
/* harmony export */   b: () => (/* binding */ getPortalRestInfoFromUrl),
/* harmony export */   c: () => (/* binding */ clearCache),
/* harmony export */   d: () => (/* binding */ getPortalToken),
/* harmony export */   e: () => (/* binding */ formRequest),
/* harmony export */   f: () => (/* binding */ fromCache),
/* harmony export */   g: () => (/* binding */ getRestBaseUrl),
/* harmony export */   h: () => (/* binding */ getToken),
/* harmony export */   i: () => (/* binding */ isPortalBackedBySDS),
/* harmony export */   j: () => (/* binding */ inCache),
/* harmony export */   k: () => (/* binding */ getPortalRestBaseUrl),
/* harmony export */   l: () => (/* binding */ getFederatedServers),
/* harmony export */   p: () => (/* binding */ pollForStatus),
/* harmony export */   q: () => (/* binding */ queryGroups),
/* harmony export */   r: () => (/* binding */ request)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/* harmony import */ var _privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./privileges-ccd5f37d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */





function getToken(portal) {
  var _a, _b, _c, _d;
  portal !== null && portal !== void 0 ? portal : (portal = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === null || _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === void 0 ? void 0 : _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c.portal);
  return (((_a = portal === null || portal === void 0 ? void 0 : portal.credential) === null || _a === void 0 ? void 0 : _a.token) || (portal === null || portal === void 0 ? void 0 : portal.token) || ((_c = (_b = portal === null || portal === void 0 ? void 0 : portal.user) === null || _b === void 0 ? void 0 : _b.credential) === null || _c === void 0 ? void 0 : _c.token) || ((_d = portal === null || portal === void 0 ? void 0 : portal.portalUser) === null || _d === void 0 ? void 0 : _d.token) || "");
}

function useSSL(url) {
  var _a;
  const { config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  // if user logged in via pop-up in viewer, the page might still be under http but the self response might have allSSL
  if (window.location.protocol === "https:" || ((_a = config === null || config === void 0 ? void 0 : config.self) === null || _a === void 0 ? void 0 : _a.allSSL) === true) {
    return url.replace("http:", "https:");
  }
  return url;
}
async function formRequest(url, form, options = {}, method) {
  const [esriRequest] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/request"]);
  const { api } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  if (!url.includes("f=")) {
    form.append("f", "json");
  }
  const token = getToken();
  if (token && !form.has("token")) {
    form.append("token", token);
  }
  return new Promise((resolve, reject) => {
    if (api === 3) {
      const request = { url: options.addSSL === false ? url : useSSL(url), form, timeout: options.timeout || 0 };
      const v3Options = method === "post" ? Object.assign({ usePost: true }, options) : options;
      esriRequest(request, v3Options).then(resolve, reject);
    }
    else {
      esriRequest(url, Object.assign(Object.assign({ body: form }, options), { timeout: options.timeout || 0, method: method || "auto" }))
        .then((response) => {
        resolve(response.data);
      })
        .catch((error) => reject(error));
    }
  });
}
async function request(url, params = {}, options = {}, method, extraOption) {
  const [esriRequest] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/request"]);
  // TODO: refactor this dude out
  const { api, portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  const content = Object.assign({}, params);
  if (!url.includes("f=") && (extraOption === null || extraOption === void 0 ? void 0 : extraOption.excludeJson) !== true) {
    content.f = "json";
  }
  if (options.addTokenManually !== false) {
    const token = await getPortalToken(portal, api);
    content.token = token;
  }
  const requestUrl = options.addSSL === false ? url : useSSL(url);
  if (api === 3) {
    const v3Request = Object.assign({ url: requestUrl, content, timeout: options.timeout || 0, withCredentials: options.withCredentials }, extraOption === null || extraOption === void 0 ? void 0 : extraOption.v3Request);
    const v3Options = method === "post" ? Object.assign({ usePost: true }, options) : options;
    return esriRequest(v3Request, v3Options);
  }
  else {
    const v4Options = Object.assign(Object.assign(Object.assign({ query: content, method: method || "auto" }, options), { timeout: options.timeout || 0 }), ((options === null || options === void 0 ? void 0 : options.disableIdentityLookup) ? { authMode: "anonymous" } : {}));
    const response = await esriRequest(requestUrl, v4Options);
    return response.data;
  }
}
// https://devtopia.esri.com/WebGIS/arcgis-portal-app/blob/master/src/js/arcgisonline/pages/item/widgets/typeOptions/featureSupport.ts#L37-L66
const ASYNC_INTERVALS = [
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 15, 15, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 120
];
function asyncIntervalTimerFunction(callCount) {
  // if call count out of bounds, use last interval, otherwise use interval at callCount
  const index = callCount > -1 && callCount < ASYNC_INTERVALS.length - 1 ? callCount : ASYNC_INTERVALS.length - 1;
  // ASYNC_INTERVALS defined in seconds, convert to milliseconds on return
  return ASYNC_INTERVALS[index] * 1000;
}
const pollForStatus = async (url, options, method) => {
  var _a, _b;
  const pendingStatuses = (_a = options === null || options === void 0 ? void 0 : options.pendingStatuses) !== null && _a !== void 0 ? _a : ["processing", "partial", "Pending", "InProgress", "EXECUTING"];
  const successStatuses = (_b = options === null || options === void 0 ? void 0 : options.successStatuses) !== null && _b !== void 0 ? _b : ["completed", "Completed", "COMPLETED"];
  let pollCount = 0;
  const poll = async () => {
    // Keep polling status until either completed or failed
    // Do failures report as success (status 200)? May need to manually throw error on status check failure
    const statusResponse = await request(url, options === null || options === void 0 ? void 0 : options.requestParams, {}, method);
    const status = statusResponse.status || statusResponse.jobStatus;
    if (pendingStatuses.includes(status)) {
      await (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_3__.t)(asyncIntervalTimerFunction(pollCount++));
      return poll();
    }
    else if (successStatuses.includes(status)) {
      return statusResponse;
    }
    else {
      throw statusResponse;
    }
  };
  try {
    return poll();
  }
  catch (e) {
    console.error(e);
    throw e;
  }
};

const cache = {};
const requestCache = {};
const cacheMetadata = {};
/**
 * Allows memory caching of requests which are expected to be called multiple times
 * @param requester - function which fetches the data to be cached
 * @param key - unique global name for this cache type - see {@link CacheType}
 * @param id - unique id for this result inside this particular cache
 */
async function fromCache(requester, key, id, cacheOption) {
  var _a, _b, _c, _d;
  const cacheExpirationTime = (_b = (_a = cacheMetadata[key]) === null || _a === void 0 ? void 0 : _a[id]) === null || _b === void 0 ? void 0 : _b.expireAt;
  const isExpired = !!cacheExpirationTime && new Date().getTime() > cacheExpirationTime;
  if (((_c = cache[key]) === null || _c === void 0 ? void 0 : _c[id]) && !isExpired) {
    return cache[key][id];
  }
  if (!requestCache[key]) {
    requestCache[key] = {};
  }
  // If it's expired, we want to re-run the entire request again, not just using the old promise
  // else we'll use the outdated data
  if (!requestCache[key][id] || isExpired) {
    requestCache[key][id] = requester();
  }
  const result = (await requestCache[key][id]);
  if (!cache[key]) {
    cache[key] = {};
  }
  if (!cacheMetadata[key]) {
    cacheMetadata[key] = {};
  }
  cache[key][id] = result;
  if (cacheOption) {
    const { expireAfter, getExpireAfterFromResult } = cacheOption;
    const expireAt = getExpireAfterFromResult || expireAfter
      ? new Date().getTime() + ((_d = getExpireAfterFromResult === null || getExpireAfterFromResult === void 0 ? void 0 : getExpireAfterFromResult(result)) !== null && _d !== void 0 ? _d : expireAfter)
      : null;
    cacheMetadata[key][id] = Object.assign(Object.assign({}, cacheMetadata[key][id]), { expireAt });
  }
  return result;
}
/**
 * Checks for a value in the cache and returns if there
 * If missing, no requests will be performed
 * @param key - unique global name for this cache type - see {@link CacheType}
 * @param id - unique id for this result inside this particular cache, will clear all entries if not provided
 * @example
 * inCache("serviceInfo", "uniqueitemid");
 */
function inCache(key, id) {
  var _a;
  return (_a = cache === null || cache === void 0 ? void 0 : cache[key]) === null || _a === void 0 ? void 0 : _a[id];
}
/**
 * Clear a particular cache entry or all entries for a particular cache type
 * @param key - unique global name for this cache type - see {@link CacheType}
 * @param id - unique id for this result inside this particular cache, will clear all entries if not provided
 * @example
 * clearCache("userGroups", "unique");
 * clearCache("userGroups");
 */
const clearCache = (key, id) => {
  var _a, _b;
  if (id) {
    (_a = cache[key]) === null || _a === void 0 ? true : delete _a[id];
    (_b = requestCache[key]) === null || _b === void 0 ? true : delete _b[id];
  }
  else {
    delete cache[key];
    delete requestCache[key];
  }
};

function getRestBaseUrl(portal) {
  var _a;
  const { portal: configPortal, config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c || {};
  return (_a = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.d)(config === null || config === void 0 ? void 0 : config.restBaseUrl)) !== null && _a !== void 0 ? _a : getPortalRestBaseUrl(portal || configPortal);
}
function getPortalRestBaseUrl(portal) {
  var _a;
  return (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.d)((_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl);
}
/**
 * Get the portal's token and also handle web-tier authentication Enterprise case
 */
const getPortalToken = async (portal, api) => {
  var _a, _b;
  // `portal` can be unexpectedly undefined
  // https://devtopia.esri.com/WebGIS/arcgis-app-components/pull/5113
  if (!(portal === null || portal === void 0 ? void 0 : portal.isPortal) || !portal.isWebTierAuth) {
    return getToken(portal);
  }
  const { token } = await fromCache(() => getPlatformSelf(portal, api !== null && api !== void 0 ? api : _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === null || _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c === void 0 ? void 0 : _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c.api), "platformSelf", (_b = (_a = portal.user) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : portal.id, { getExpireAfterFromResult: (result) => result.expires_in });
  return token;
};
/**
 * Get the active client id. Defaults to "arcgisonline".
 */
const getClientId = async (portal, api) => {
  var _a, _b, _c, _d;
  const is3x = api === 3;
  const [IdentityManager] = await _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.e.loadModules([is3x ? "esri/IdentityManager" : "esri/identity/IdentityManager"]);
  const credential = await fromCache(() => IdentityManager.getCredential(getRestBaseUrl(portal), { oAuthPopupConfirmation: false }), "credential", (_a = portal.user) === null || _a === void 0 ? void 0 : _a.id);
  return ((_d = (is3x
    ? (_b = credential._oAuthCred) === null || _b === void 0 ? void 0 : _b.appId
    : (_c = credential.oAuthState) === null || _c === void 0 ? void 0 : _c.appId)) !== null && _d !== void 0 ? _d : "arcgisonline");
};
/**
 * Useful to get the token in web-tier authenticated Enterprise portals
 * Based on https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/master/esri/IdentityManagerBase.js#L1952-L1966
 */
const getPlatformSelf = async (portal, apiVersion) => {
  const appId = await getClientId(portal, apiVersion);
  const headers = {
    "X-Esri-Auth-Client-Id": appId,
    "X-Esri-Auth-Redirect-Uri": window.location.href.replace(/#.*$/, "")
  };
  return request(`${getRestBaseUrl(portal)}/oauth2/platformSelf`, {}, {
    disableIdentityLookup: true,
    headers: apiVersion === 4 ? headers : undefined,
    // To avoid infinite loop since `request` will call this again
    addTokenManually: false,
    withCredentials: true
  }, "post", { v3Request: { headers } });
};
/**
 * `portal.queryGroups` expects slightly different formats in 3.x vs 4.x
 * This is a version-agnostic replacement
 **/
async function queryGroups(params = {}, portal) {
  return request(`${getRestBaseUrl(portal)}/community/groups`, params);
}
/**
 * Get the on premise portals federated servers (must be signed in user to make this call)
 */
const getFederatedServers = async (user, portal) => {
  var _a;
  // Since the user must be signed in to make the call, this is required
  if (!user) {
    return [];
  }
  const restBaseUrl = `${(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.d)((_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl)}portals/self/servers`;
  const result = await request(restBaseUrl);
  return result === null || result === void 0 ? void 0 : result.servers;
};
const getPortalRestInfo = (portal) => {
  return getPortalRestInfoFromUrl(getPortalRestBaseUrl(portal));
};
const getPortalRestInfoFromUrl = (url) => {
  var _a;
  // Sometimes serviceUrl/info will return nothing so we need to extract the `rest` out
  const infoUrl = `${(0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.d)((_a = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.l)(url)) !== null && _a !== void 0 ? _a : url)}info`;
  // Most likely this info won't change so it's safe to use `fromCache`
  return fromCache(() => request(infoUrl, {}, { addTokenManually: false }), "portalInfo", infoUrl);
};
const isPortalBackedBySDS = async (portal, user) => {
  if (portal.isBackedBySDS) {
    return { result: true };
  }
  // Only full admin or specific admin privileges on a custom role are
  // allowed to access the server admin endpoint
  const isAdmin = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.e)(user) ||
    (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.f)(user) ||
    (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.g)(user) ||
    (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.h)(user) ||
    (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.j)(user);
  if (portal.isPortal && user && (isAdmin || (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.k)(user))) {
    try {
      // Only on-premise portals need to be checked if they support sds
      // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/3112
      // Get the hosted managed federated Servers (this call requires a signed in user)
      const managedServers = await getManagedServers(user, portal);
      return { result: !!(managedServers === null || managedServers === void 0 ? void 0 : managedServers[0]) };
    }
    catch (error) {
      console.error(error);
      return { error: { code: "unhandledError", message: JSON.stringify(error) }, result: false };
    }
  }
  // If not portal then it will always supports everything SDS supports
  return { result: true };
};
/**
 * Get the on premise portals managed servers
 */
const getManagedServers = async (user, portal) => {
  const hostedServer = await getHostedFederatedServer(user, portal);
  if (!hostedServer) {
    return null;
  }
  // Find managed servers
  const findItemsUrl = `${hostedServer.adminUrl}/admin/data/findItems`;
  const managedServers = await request(findItemsUrl, { managed: true });
  // where provider is "ArcGIS Data Store"
  return managedServers.items.filter((managedServer) => { var _a; return ((_a = managedServer.provider) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "arcgis data store"; });
};
/**
 * Get the on premise portals hosted federated servers
 */
const getHostedFederatedServer = async (user, portal) => {
  var _a;
  const federatedServers = (_a = (await getFederatedServers(user, portal))) !== null && _a !== void 0 ? _a : [];
  return federatedServers.filter((server) => server.isHosted)[0];
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fcG9ydGFsLTY3MTQxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RDs7QUFFdkQsb0JBQW9CLHFEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRWlEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmakQ7QUFDQTtBQUNBO0FBQ0E7QUFDOEU7QUFDdEI7QUFDK0s7QUFDL0s7O0FBRXhEO0FBQ0E7QUFDQSw0REFBNEQsa0RBQVcsYUFBYSxrREFBVyx1QkFBdUIsa0RBQVc7QUFDakk7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEVBQUUsa0RBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELDhCQUE4QiwyREFBVztBQUN6QyxVQUFVLE1BQU0sRUFBRSxrREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNERBQTRELGVBQWU7QUFDM0U7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVksY0FBYyx5REFBeUQ7QUFDeEk7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQsOEJBQThCLDJEQUFXO0FBQ3pDO0FBQ0EsVUFBVSxjQUFjLEVBQUUsa0RBQVc7QUFDckMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtR0FBbUc7QUFDekksMERBQTBELGVBQWU7QUFDekU7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDBDQUEwQyxjQUFjLCtCQUErQiwwRkFBMEYsd0JBQXdCLElBQUk7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ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9jb25maWctZWI1ZjdkYzIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcG9ydGFsLTc5Y2FhZWZmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVTdG9yZSB9IGZyb20gJy4vaW5kZXgtODFkNTQ4YjcuanMnO1xuXG5jb25zdCBjb25maWdTdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgcG9ydGFsOiBudWxsLFxuICB1c2VyOiBudWxsLFxuICBhcGk6IDQsXG4gIHNjYWxlOiBcIm1cIlxufSk7XG5jb25zdCBjb25maWdTdGF0ZSA9IGNvbmZpZ1N0b3JlLnN0YXRlO1xuY29uc3Qgb25Db25maWdDaGFuZ2UgPSBjb25maWdTdG9yZS5vbkNoYW5nZTtcblxuZXhwb3J0IHsgY29uZmlnU3RhdGUgYXMgYywgb25Db25maWdDaGFuZ2UgYXMgbyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzLCBlIGFzIGVzcmlMb2FkZXIgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCB7IGMgYXMgY29uZmlnU3RhdGUgfSBmcm9tICcuL2NvbmZpZy1lYjVmN2RjMi5qcyc7XG5pbXBvcnQgeyBkIGFzIGFkZFRyYWlsaW5nU2xhc2hJZk1pc3NpbmcsIGUgYXMgaXNPcmdBZG1pbiwgZiBhcyBjYW5NYW5hZ2VTZWN1cml0eSwgZyBhcyBjYW5NYW5hZ2VTZXJ2ZXJzLCBoIGFzIGNhblVwZGF0ZU9yZ0l0ZW1zLCBqIGFzIGNhbkRlbGV0ZU9yZ0l0ZW1zLCBrIGFzIGlzT3JnUHVibGlzaGVyLCBsIGFzIGdldFJlc3RVcmxGcm9tVXJsIH0gZnJvbSAnLi9wcml2aWxlZ2VzLWNjZDVmMzdkLmpzJztcbmltcG9ydCB7IHQgYXMgdGltZW91dCB9IGZyb20gJy4vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyc7XG5cbmZ1bmN0aW9uIGdldFRva2VuKHBvcnRhbCkge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIHBvcnRhbCAhPT0gbnVsbCAmJiBwb3J0YWwgIT09IHZvaWQgMCA/IHBvcnRhbCA6IChwb3J0YWwgPSBjb25maWdTdGF0ZSA9PT0gbnVsbCB8fCBjb25maWdTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnU3RhdGUucG9ydGFsKTtcbiAgcmV0dXJuICgoKF9hID0gcG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLmNyZWRlbnRpYWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2tlbikgfHwgKHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC50b2tlbikgfHwgKChfYyA9IChfYiA9IHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC51c2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3JlZGVudGlhbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRva2VuKSB8fCAoKF9kID0gcG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLnBvcnRhbFVzZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b2tlbikgfHwgXCJcIik7XG59XG5cbmZ1bmN0aW9uIHVzZVNTTCh1cmwpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IGNvbmZpZyB9ID0gY29uZmlnU3RhdGU7XG4gIC8vIGlmIHVzZXIgbG9nZ2VkIGluIHZpYSBwb3AtdXAgaW4gdmlld2VyLCB0aGUgcGFnZSBtaWdodCBzdGlsbCBiZSB1bmRlciBodHRwIGJ1dCB0aGUgc2VsZiByZXNwb25zZSBtaWdodCBoYXZlIGFsbFNTTFxuICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiIHx8ICgoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuc2VsZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFsbFNTTCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoXCJodHRwOlwiLCBcImh0dHBzOlwiKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuYXN5bmMgZnVuY3Rpb24gZm9ybVJlcXVlc3QodXJsLCBmb3JtLCBvcHRpb25zID0ge30sIG1ldGhvZCkge1xuICBjb25zdCBbZXNyaVJlcXVlc3RdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9yZXF1ZXN0XCJdKTtcbiAgY29uc3QgeyBhcGkgfSA9IGNvbmZpZ1N0YXRlO1xuICBpZiAoIXVybC5pbmNsdWRlcyhcImY9XCIpKSB7XG4gICAgZm9ybS5hcHBlbmQoXCJmXCIsIFwianNvblwiKTtcbiAgfVxuICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XG4gIGlmICh0b2tlbiAmJiAhZm9ybS5oYXMoXCJ0b2tlblwiKSkge1xuICAgIGZvcm0uYXBwZW5kKFwidG9rZW5cIiwgdG9rZW4pO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGFwaSA9PT0gMykge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHsgdXJsOiBvcHRpb25zLmFkZFNTTCA9PT0gZmFsc2UgPyB1cmwgOiB1c2VTU0wodXJsKSwgZm9ybSwgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAgfTtcbiAgICAgIGNvbnN0IHYzT3B0aW9ucyA9IG1ldGhvZCA9PT0gXCJwb3N0XCIgPyBPYmplY3QuYXNzaWduKHsgdXNlUG9zdDogdHJ1ZSB9LCBvcHRpb25zKSA6IG9wdGlvbnM7XG4gICAgICBlc3JpUmVxdWVzdChyZXF1ZXN0LCB2M09wdGlvbnMpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlc3JpUmVxdWVzdCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGJvZHk6IGZvcm0gfSwgb3B0aW9ucyksIHsgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAsIG1ldGhvZDogbWV0aG9kIHx8IFwiYXV0b1wiIH0pKVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcbiAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHJlamVjdChlcnJvcikpO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0KHVybCwgcGFyYW1zID0ge30sIG9wdGlvbnMgPSB7fSwgbWV0aG9kLCBleHRyYU9wdGlvbikge1xuICBjb25zdCBbZXNyaVJlcXVlc3RdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9yZXF1ZXN0XCJdKTtcbiAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyBkdWRlIG91dFxuICBjb25zdCB7IGFwaSwgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgY29uc3QgY29udGVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gIGlmICghdXJsLmluY2x1ZGVzKFwiZj1cIikgJiYgKGV4dHJhT3B0aW9uID09PSBudWxsIHx8IGV4dHJhT3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRyYU9wdGlvbi5leGNsdWRlSnNvbikgIT09IHRydWUpIHtcbiAgICBjb250ZW50LmYgPSBcImpzb25cIjtcbiAgfVxuICBpZiAob3B0aW9ucy5hZGRUb2tlbk1hbnVhbGx5ICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0UG9ydGFsVG9rZW4ocG9ydGFsLCBhcGkpO1xuICAgIGNvbnRlbnQudG9rZW4gPSB0b2tlbjtcbiAgfVxuICBjb25zdCByZXF1ZXN0VXJsID0gb3B0aW9ucy5hZGRTU0wgPT09IGZhbHNlID8gdXJsIDogdXNlU1NMKHVybCk7XG4gIGlmIChhcGkgPT09IDMpIHtcbiAgICBjb25zdCB2M1JlcXVlc3QgPSBPYmplY3QuYXNzaWduKHsgdXJsOiByZXF1ZXN0VXJsLCBjb250ZW50LCB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfHwgMCwgd2l0aENyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyB9LCBleHRyYU9wdGlvbiA9PT0gbnVsbCB8fCBleHRyYU9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0cmFPcHRpb24udjNSZXF1ZXN0KTtcbiAgICBjb25zdCB2M09wdGlvbnMgPSBtZXRob2QgPT09IFwicG9zdFwiID8gT2JqZWN0LmFzc2lnbih7IHVzZVBvc3Q6IHRydWUgfSwgb3B0aW9ucykgOiBvcHRpb25zO1xuICAgIHJldHVybiBlc3JpUmVxdWVzdCh2M1JlcXVlc3QsIHYzT3B0aW9ucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgdjRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBxdWVyeTogY29udGVudCwgbWV0aG9kOiBtZXRob2QgfHwgXCJhdXRvXCIgfSwgb3B0aW9ucyksIHsgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAgfSksICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVJZGVudGl0eUxvb2t1cCkgPyB7IGF1dGhNb2RlOiBcImFub255bW91c1wiIH0gOiB7fSkpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZXNyaVJlcXVlc3QocmVxdWVzdFVybCwgdjRPcHRpb25zKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxufVxuLy8gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvYmxvYi9tYXN0ZXIvc3JjL2pzL2FyY2dpc29ubGluZS9wYWdlcy9pdGVtL3dpZGdldHMvdHlwZU9wdGlvbnMvZmVhdHVyZVN1cHBvcnQudHMjTDM3LUw2NlxuY29uc3QgQVNZTkNfSU5URVJWQUxTID0gW1xuICAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAxNSwgMTUsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAxMjBcbl07XG5mdW5jdGlvbiBhc3luY0ludGVydmFsVGltZXJGdW5jdGlvbihjYWxsQ291bnQpIHtcbiAgLy8gaWYgY2FsbCBjb3VudCBvdXQgb2YgYm91bmRzLCB1c2UgbGFzdCBpbnRlcnZhbCwgb3RoZXJ3aXNlIHVzZSBpbnRlcnZhbCBhdCBjYWxsQ291bnRcbiAgY29uc3QgaW5kZXggPSBjYWxsQ291bnQgPiAtMSAmJiBjYWxsQ291bnQgPCBBU1lOQ19JTlRFUlZBTFMubGVuZ3RoIC0gMSA/IGNhbGxDb3VudCA6IEFTWU5DX0lOVEVSVkFMUy5sZW5ndGggLSAxO1xuICAvLyBBU1lOQ19JTlRFUlZBTFMgZGVmaW5lZCBpbiBzZWNvbmRzLCBjb252ZXJ0IHRvIG1pbGxpc2Vjb25kcyBvbiByZXR1cm5cbiAgcmV0dXJuIEFTWU5DX0lOVEVSVkFMU1tpbmRleF0gKiAxMDAwO1xufVxuY29uc3QgcG9sbEZvclN0YXR1cyA9IGFzeW5jICh1cmwsIG9wdGlvbnMsIG1ldGhvZCkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBwZW5kaW5nU3RhdHVzZXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGVuZGluZ1N0YXR1c2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXCJwcm9jZXNzaW5nXCIsIFwicGFydGlhbFwiLCBcIlBlbmRpbmdcIiwgXCJJblByb2dyZXNzXCIsIFwiRVhFQ1VUSU5HXCJdO1xuICBjb25zdCBzdWNjZXNzU3RhdHVzZXMgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3VjY2Vzc1N0YXR1c2VzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXCJjb21wbGV0ZWRcIiwgXCJDb21wbGV0ZWRcIiwgXCJDT01QTEVURURcIl07XG4gIGxldCBwb2xsQ291bnQgPSAwO1xuICBjb25zdCBwb2xsID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIEtlZXAgcG9sbGluZyBzdGF0dXMgdW50aWwgZWl0aGVyIGNvbXBsZXRlZCBvciBmYWlsZWRcbiAgICAvLyBEbyBmYWlsdXJlcyByZXBvcnQgYXMgc3VjY2VzcyAoc3RhdHVzIDIwMCk/IE1heSBuZWVkIHRvIG1hbnVhbGx5IHRocm93IGVycm9yIG9uIHN0YXR1cyBjaGVjayBmYWlsdXJlXG4gICAgY29uc3Qgc3RhdHVzUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHVybCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcXVlc3RQYXJhbXMsIHt9LCBtZXRob2QpO1xuICAgIGNvbnN0IHN0YXR1cyA9IHN0YXR1c1Jlc3BvbnNlLnN0YXR1cyB8fCBzdGF0dXNSZXNwb25zZS5qb2JTdGF0dXM7XG4gICAgaWYgKHBlbmRpbmdTdGF0dXNlcy5pbmNsdWRlcyhzdGF0dXMpKSB7XG4gICAgICBhd2FpdCB0aW1lb3V0KGFzeW5jSW50ZXJ2YWxUaW1lckZ1bmN0aW9uKHBvbGxDb3VudCsrKSk7XG4gICAgICByZXR1cm4gcG9sbCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdWNjZXNzU3RhdHVzZXMuaW5jbHVkZXMoc3RhdHVzKSkge1xuICAgICAgcmV0dXJuIHN0YXR1c1Jlc3BvbnNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IHN0YXR1c1Jlc3BvbnNlO1xuICAgIH1cbiAgfTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcG9sbCgpO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5jb25zdCBjYWNoZSA9IHt9O1xuY29uc3QgcmVxdWVzdENhY2hlID0ge307XG5jb25zdCBjYWNoZU1ldGFkYXRhID0ge307XG4vKipcbiAqIEFsbG93cyBtZW1vcnkgY2FjaGluZyBvZiByZXF1ZXN0cyB3aGljaCBhcmUgZXhwZWN0ZWQgdG8gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gKiBAcGFyYW0gcmVxdWVzdGVyIC0gZnVuY3Rpb24gd2hpY2ggZmV0Y2hlcyB0aGUgZGF0YSB0byBiZSBjYWNoZWRcbiAqIEBwYXJhbSBrZXkgLSB1bmlxdWUgZ2xvYmFsIG5hbWUgZm9yIHRoaXMgY2FjaGUgdHlwZSAtIHNlZSB7QGxpbmsgQ2FjaGVUeXBlfVxuICogQHBhcmFtIGlkIC0gdW5pcXVlIGlkIGZvciB0aGlzIHJlc3VsdCBpbnNpZGUgdGhpcyBwYXJ0aWN1bGFyIGNhY2hlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZyb21DYWNoZShyZXF1ZXN0ZXIsIGtleSwgaWQsIGNhY2hlT3B0aW9uKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgY2FjaGVFeHBpcmF0aW9uVGltZSA9IChfYiA9IChfYSA9IGNhY2hlTWV0YWRhdGFba2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2lkXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4cGlyZUF0O1xuICBjb25zdCBpc0V4cGlyZWQgPSAhIWNhY2hlRXhwaXJhdGlvblRpbWUgJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgPiBjYWNoZUV4cGlyYXRpb25UaW1lO1xuICBpZiAoKChfYyA9IGNhY2hlW2tleV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tpZF0pICYmICFpc0V4cGlyZWQpIHtcbiAgICByZXR1cm4gY2FjaGVba2V5XVtpZF07XG4gIH1cbiAgaWYgKCFyZXF1ZXN0Q2FjaGVba2V5XSkge1xuICAgIHJlcXVlc3RDYWNoZVtrZXldID0ge307XG4gIH1cbiAgLy8gSWYgaXQncyBleHBpcmVkLCB3ZSB3YW50IHRvIHJlLXJ1biB0aGUgZW50aXJlIHJlcXVlc3QgYWdhaW4sIG5vdCBqdXN0IHVzaW5nIHRoZSBvbGQgcHJvbWlzZVxuICAvLyBlbHNlIHdlJ2xsIHVzZSB0aGUgb3V0ZGF0ZWQgZGF0YVxuICBpZiAoIXJlcXVlc3RDYWNoZVtrZXldW2lkXSB8fCBpc0V4cGlyZWQpIHtcbiAgICByZXF1ZXN0Q2FjaGVba2V5XVtpZF0gPSByZXF1ZXN0ZXIoKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSAoYXdhaXQgcmVxdWVzdENhY2hlW2tleV1baWRdKTtcbiAgaWYgKCFjYWNoZVtrZXldKSB7XG4gICAgY2FjaGVba2V5XSA9IHt9O1xuICB9XG4gIGlmICghY2FjaGVNZXRhZGF0YVtrZXldKSB7XG4gICAgY2FjaGVNZXRhZGF0YVtrZXldID0ge307XG4gIH1cbiAgY2FjaGVba2V5XVtpZF0gPSByZXN1bHQ7XG4gIGlmIChjYWNoZU9wdGlvbikge1xuICAgIGNvbnN0IHsgZXhwaXJlQWZ0ZXIsIGdldEV4cGlyZUFmdGVyRnJvbVJlc3VsdCB9ID0gY2FjaGVPcHRpb247XG4gICAgY29uc3QgZXhwaXJlQXQgPSBnZXRFeHBpcmVBZnRlckZyb21SZXN1bHQgfHwgZXhwaXJlQWZ0ZXJcbiAgICAgID8gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAoKF9kID0gZ2V0RXhwaXJlQWZ0ZXJGcm9tUmVzdWx0ID09PSBudWxsIHx8IGdldEV4cGlyZUFmdGVyRnJvbVJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0RXhwaXJlQWZ0ZXJGcm9tUmVzdWx0KHJlc3VsdCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGV4cGlyZUFmdGVyKVxuICAgICAgOiBudWxsO1xuICAgIGNhY2hlTWV0YWRhdGFba2V5XVtpZF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhY2hlTWV0YWRhdGFba2V5XVtpZF0pLCB7IGV4cGlyZUF0IH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENoZWNrcyBmb3IgYSB2YWx1ZSBpbiB0aGUgY2FjaGUgYW5kIHJldHVybnMgaWYgdGhlcmVcbiAqIElmIG1pc3NpbmcsIG5vIHJlcXVlc3RzIHdpbGwgYmUgcGVyZm9ybWVkXG4gKiBAcGFyYW0ga2V5IC0gdW5pcXVlIGdsb2JhbCBuYW1lIGZvciB0aGlzIGNhY2hlIHR5cGUgLSBzZWUge0BsaW5rIENhY2hlVHlwZX1cbiAqIEBwYXJhbSBpZCAtIHVuaXF1ZSBpZCBmb3IgdGhpcyByZXN1bHQgaW5zaWRlIHRoaXMgcGFydGljdWxhciBjYWNoZSwgd2lsbCBjbGVhciBhbGwgZW50cmllcyBpZiBub3QgcHJvdmlkZWRcbiAqIEBleGFtcGxlXG4gKiBpbkNhY2hlKFwic2VydmljZUluZm9cIiwgXCJ1bmlxdWVpdGVtaWRcIik7XG4gKi9cbmZ1bmN0aW9uIGluQ2FjaGUoa2V5LCBpZCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBjYWNoZSA9PT0gbnVsbCB8fCBjYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVba2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2lkXTtcbn1cbi8qKlxuICogQ2xlYXIgYSBwYXJ0aWN1bGFyIGNhY2hlIGVudHJ5IG9yIGFsbCBlbnRyaWVzIGZvciBhIHBhcnRpY3VsYXIgY2FjaGUgdHlwZVxuICogQHBhcmFtIGtleSAtIHVuaXF1ZSBnbG9iYWwgbmFtZSBmb3IgdGhpcyBjYWNoZSB0eXBlIC0gc2VlIHtAbGluayBDYWNoZVR5cGV9XG4gKiBAcGFyYW0gaWQgLSB1bmlxdWUgaWQgZm9yIHRoaXMgcmVzdWx0IGluc2lkZSB0aGlzIHBhcnRpY3VsYXIgY2FjaGUsIHdpbGwgY2xlYXIgYWxsIGVudHJpZXMgaWYgbm90IHByb3ZpZGVkXG4gKiBAZXhhbXBsZVxuICogY2xlYXJDYWNoZShcInVzZXJHcm91cHNcIiwgXCJ1bmlxdWVcIik7XG4gKiBjbGVhckNhY2hlKFwidXNlckdyb3Vwc1wiKTtcbiAqL1xuY29uc3QgY2xlYXJDYWNoZSA9IChrZXksIGlkKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGlmIChpZCkge1xuICAgIChfYSA9IGNhY2hlW2tleV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB0cnVlIDogZGVsZXRlIF9hW2lkXTtcbiAgICAoX2IgPSByZXF1ZXN0Q2FjaGVba2V5XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHRydWUgOiBkZWxldGUgX2JbaWRdO1xuICB9XG4gIGVsc2Uge1xuICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICAgIGRlbGV0ZSByZXF1ZXN0Q2FjaGVba2V5XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0UmVzdEJhc2VVcmwocG9ydGFsKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBwb3J0YWw6IGNvbmZpZ1BvcnRhbCwgY29uZmlnIH0gPSBjb25maWdTdGF0ZSB8fCB7fTtcbiAgcmV0dXJuIChfYSA9IGFkZFRyYWlsaW5nU2xhc2hJZk1pc3NpbmcoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnJlc3RCYXNlVXJsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2V0UG9ydGFsUmVzdEJhc2VVcmwocG9ydGFsIHx8IGNvbmZpZ1BvcnRhbCk7XG59XG5mdW5jdGlvbiBnZXRQb3J0YWxSZXN0QmFzZVVybChwb3J0YWwpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gYWRkVHJhaWxpbmdTbGFzaElmTWlzc2luZygoX2EgPSBwb3J0YWwucmVzdFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9ydGFsLnBvcnRhbFVybCk7XG59XG4vKipcbiAqIEdldCB0aGUgcG9ydGFsJ3MgdG9rZW4gYW5kIGFsc28gaGFuZGxlIHdlYi10aWVyIGF1dGhlbnRpY2F0aW9uIEVudGVycHJpc2UgY2FzZVxuICovXG5jb25zdCBnZXRQb3J0YWxUb2tlbiA9IGFzeW5jIChwb3J0YWwsIGFwaSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICAvLyBgcG9ydGFsYCBjYW4gYmUgdW5leHBlY3RlZGx5IHVuZGVmaW5lZFxuICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtYXBwLWNvbXBvbmVudHMvcHVsbC81MTEzXG4gIGlmICghKHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5pc1BvcnRhbCkgfHwgIXBvcnRhbC5pc1dlYlRpZXJBdXRoKSB7XG4gICAgcmV0dXJuIGdldFRva2VuKHBvcnRhbCk7XG4gIH1cbiAgY29uc3QgeyB0b2tlbiB9ID0gYXdhaXQgZnJvbUNhY2hlKCgpID0+IGdldFBsYXRmb3JtU2VsZihwb3J0YWwsIGFwaSAhPT0gbnVsbCAmJiBhcGkgIT09IHZvaWQgMCA/IGFwaSA6IGNvbmZpZ1N0YXRlID09PSBudWxsIHx8IGNvbmZpZ1N0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWdTdGF0ZS5hcGkpLCBcInBsYXRmb3JtU2VsZlwiLCAoX2IgPSAoX2EgPSBwb3J0YWwudXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwb3J0YWwuaWQsIHsgZ2V0RXhwaXJlQWZ0ZXJGcm9tUmVzdWx0OiAocmVzdWx0KSA9PiByZXN1bHQuZXhwaXJlc19pbiB9KTtcbiAgcmV0dXJuIHRva2VuO1xufTtcbi8qKlxuICogR2V0IHRoZSBhY3RpdmUgY2xpZW50IGlkLiBEZWZhdWx0cyB0byBcImFyY2dpc29ubGluZVwiLlxuICovXG5jb25zdCBnZXRDbGllbnRJZCA9IGFzeW5jIChwb3J0YWwsIGFwaSkgPT4ge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IGlzM3ggPSBhcGkgPT09IDM7XG4gIGNvbnN0IFtJZGVudGl0eU1hbmFnZXJdID0gYXdhaXQgZXNyaUxvYWRlci5sb2FkTW9kdWxlcyhbaXMzeCA/IFwiZXNyaS9JZGVudGl0eU1hbmFnZXJcIiA6IFwiZXNyaS9pZGVudGl0eS9JZGVudGl0eU1hbmFnZXJcIl0pO1xuICBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgZnJvbUNhY2hlKCgpID0+IElkZW50aXR5TWFuYWdlci5nZXRDcmVkZW50aWFsKGdldFJlc3RCYXNlVXJsKHBvcnRhbCksIHsgb0F1dGhQb3B1cENvbmZpcm1hdGlvbjogZmFsc2UgfSksIFwiY3JlZGVudGlhbFwiLCAoX2EgPSBwb3J0YWwudXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKTtcbiAgcmV0dXJuICgoX2QgPSAoaXMzeFxuICAgID8gKF9iID0gY3JlZGVudGlhbC5fb0F1dGhDcmVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYXBwSWRcbiAgICA6IChfYyA9IGNyZWRlbnRpYWwub0F1dGhTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFwcElkKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogXCJhcmNnaXNvbmxpbmVcIik7XG59O1xuLyoqXG4gKiBVc2VmdWwgdG8gZ2V0IHRoZSB0b2tlbiBpbiB3ZWItdGllciBhdXRoZW50aWNhdGVkIEVudGVycHJpc2UgcG9ydGFsc1xuICogQmFzZWQgb24gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWpzLWFwaS9ibG9iL21hc3Rlci9lc3JpL0lkZW50aXR5TWFuYWdlckJhc2UuanMjTDE5NTItTDE5NjZcbiAqL1xuY29uc3QgZ2V0UGxhdGZvcm1TZWxmID0gYXN5bmMgKHBvcnRhbCwgYXBpVmVyc2lvbikgPT4ge1xuICBjb25zdCBhcHBJZCA9IGF3YWl0IGdldENsaWVudElkKHBvcnRhbCwgYXBpVmVyc2lvbik7XG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgXCJYLUVzcmktQXV0aC1DbGllbnQtSWRcIjogYXBwSWQsXG4gICAgXCJYLUVzcmktQXV0aC1SZWRpcmVjdC1VcmlcIjogd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qJC8sIFwiXCIpXG4gIH07XG4gIHJldHVybiByZXF1ZXN0KGAke2dldFJlc3RCYXNlVXJsKHBvcnRhbCl9L29hdXRoMi9wbGF0Zm9ybVNlbGZgLCB7fSwge1xuICAgIGRpc2FibGVJZGVudGl0eUxvb2t1cDogdHJ1ZSxcbiAgICBoZWFkZXJzOiBhcGlWZXJzaW9uID09PSA0ID8gaGVhZGVycyA6IHVuZGVmaW5lZCxcbiAgICAvLyBUbyBhdm9pZCBpbmZpbml0ZSBsb29wIHNpbmNlIGByZXF1ZXN0YCB3aWxsIGNhbGwgdGhpcyBhZ2FpblxuICAgIGFkZFRva2VuTWFudWFsbHk6IGZhbHNlLFxuICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZVxuICB9LCBcInBvc3RcIiwgeyB2M1JlcXVlc3Q6IHsgaGVhZGVycyB9IH0pO1xufTtcbi8qKlxuICogYHBvcnRhbC5xdWVyeUdyb3Vwc2AgZXhwZWN0cyBzbGlnaHRseSBkaWZmZXJlbnQgZm9ybWF0cyBpbiAzLnggdnMgNC54XG4gKiBUaGlzIGlzIGEgdmVyc2lvbi1hZ25vc3RpYyByZXBsYWNlbWVudFxuICoqL1xuYXN5bmMgZnVuY3Rpb24gcXVlcnlHcm91cHMocGFyYW1zID0ge30sIHBvcnRhbCkge1xuICByZXR1cm4gcmVxdWVzdChgJHtnZXRSZXN0QmFzZVVybChwb3J0YWwpfS9jb21tdW5pdHkvZ3JvdXBzYCwgcGFyYW1zKTtcbn1cbi8qKlxuICogR2V0IHRoZSBvbiBwcmVtaXNlIHBvcnRhbHMgZmVkZXJhdGVkIHNlcnZlcnMgKG11c3QgYmUgc2lnbmVkIGluIHVzZXIgdG8gbWFrZSB0aGlzIGNhbGwpXG4gKi9cbmNvbnN0IGdldEZlZGVyYXRlZFNlcnZlcnMgPSBhc3luYyAodXNlciwgcG9ydGFsKSA9PiB7XG4gIHZhciBfYTtcbiAgLy8gU2luY2UgdGhlIHVzZXIgbXVzdCBiZSBzaWduZWQgaW4gdG8gbWFrZSB0aGUgY2FsbCwgdGhpcyBpcyByZXF1aXJlZFxuICBpZiAoIXVzZXIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVzdEJhc2VVcmwgPSBgJHthZGRUcmFpbGluZ1NsYXNoSWZNaXNzaW5nKChfYSA9IHBvcnRhbC5yZXN0VXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3J0YWwucG9ydGFsVXJsKX1wb3J0YWxzL3NlbGYvc2VydmVyc2A7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QocmVzdEJhc2VVcmwpO1xuICByZXR1cm4gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LnNlcnZlcnM7XG59O1xuY29uc3QgZ2V0UG9ydGFsUmVzdEluZm8gPSAocG9ydGFsKSA9PiB7XG4gIHJldHVybiBnZXRQb3J0YWxSZXN0SW5mb0Zyb21VcmwoZ2V0UG9ydGFsUmVzdEJhc2VVcmwocG9ydGFsKSk7XG59O1xuY29uc3QgZ2V0UG9ydGFsUmVzdEluZm9Gcm9tVXJsID0gKHVybCkgPT4ge1xuICB2YXIgX2E7XG4gIC8vIFNvbWV0aW1lcyBzZXJ2aWNlVXJsL2luZm8gd2lsbCByZXR1cm4gbm90aGluZyBzbyB3ZSBuZWVkIHRvIGV4dHJhY3QgdGhlIGByZXN0YCBvdXRcbiAgY29uc3QgaW5mb1VybCA9IGAke2FkZFRyYWlsaW5nU2xhc2hJZk1pc3NpbmcoKF9hID0gZ2V0UmVzdFVybEZyb21VcmwodXJsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdXJsKX1pbmZvYDtcbiAgLy8gTW9zdCBsaWtlbHkgdGhpcyBpbmZvIHdvbid0IGNoYW5nZSBzbyBpdCdzIHNhZmUgdG8gdXNlIGBmcm9tQ2FjaGVgXG4gIHJldHVybiBmcm9tQ2FjaGUoKCkgPT4gcmVxdWVzdChpbmZvVXJsLCB7fSwgeyBhZGRUb2tlbk1hbnVhbGx5OiBmYWxzZSB9KSwgXCJwb3J0YWxJbmZvXCIsIGluZm9VcmwpO1xufTtcbmNvbnN0IGlzUG9ydGFsQmFja2VkQnlTRFMgPSBhc3luYyAocG9ydGFsLCB1c2VyKSA9PiB7XG4gIGlmIChwb3J0YWwuaXNCYWNrZWRCeVNEUykge1xuICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICB9XG4gIC8vIE9ubHkgZnVsbCBhZG1pbiBvciBzcGVjaWZpYyBhZG1pbiBwcml2aWxlZ2VzIG9uIGEgY3VzdG9tIHJvbGUgYXJlXG4gIC8vIGFsbG93ZWQgdG8gYWNjZXNzIHRoZSBzZXJ2ZXIgYWRtaW4gZW5kcG9pbnRcbiAgY29uc3QgaXNBZG1pbiA9IGlzT3JnQWRtaW4odXNlcikgfHxcbiAgICBjYW5NYW5hZ2VTZWN1cml0eSh1c2VyKSB8fFxuICAgIGNhbk1hbmFnZVNlcnZlcnModXNlcikgfHxcbiAgICBjYW5VcGRhdGVPcmdJdGVtcyh1c2VyKSB8fFxuICAgIGNhbkRlbGV0ZU9yZ0l0ZW1zKHVzZXIpO1xuICBpZiAocG9ydGFsLmlzUG9ydGFsICYmIHVzZXIgJiYgKGlzQWRtaW4gfHwgaXNPcmdQdWJsaXNoZXIodXNlcikpKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE9ubHkgb24tcHJlbWlzZSBwb3J0YWxzIG5lZWQgdG8gYmUgY2hlY2tlZCBpZiB0aGV5IHN1cHBvcnQgc2RzXG4gICAgICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvMzExMlxuICAgICAgLy8gR2V0IHRoZSBob3N0ZWQgbWFuYWdlZCBmZWRlcmF0ZWQgU2VydmVycyAodGhpcyBjYWxsIHJlcXVpcmVzIGEgc2lnbmVkIGluIHVzZXIpXG4gICAgICBjb25zdCBtYW5hZ2VkU2VydmVycyA9IGF3YWl0IGdldE1hbmFnZWRTZXJ2ZXJzKHVzZXIsIHBvcnRhbCk7XG4gICAgICByZXR1cm4geyByZXN1bHQ6ICEhKG1hbmFnZWRTZXJ2ZXJzID09PSBudWxsIHx8IG1hbmFnZWRTZXJ2ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYW5hZ2VkU2VydmVyc1swXSkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH0sIHJlc3VsdDogZmFsc2UgfTtcbiAgICB9XG4gIH1cbiAgLy8gSWYgbm90IHBvcnRhbCB0aGVuIGl0IHdpbGwgYWx3YXlzIHN1cHBvcnRzIGV2ZXJ5dGhpbmcgU0RTIHN1cHBvcnRzXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xufTtcbi8qKlxuICogR2V0IHRoZSBvbiBwcmVtaXNlIHBvcnRhbHMgbWFuYWdlZCBzZXJ2ZXJzXG4gKi9cbmNvbnN0IGdldE1hbmFnZWRTZXJ2ZXJzID0gYXN5bmMgKHVzZXIsIHBvcnRhbCkgPT4ge1xuICBjb25zdCBob3N0ZWRTZXJ2ZXIgPSBhd2FpdCBnZXRIb3N0ZWRGZWRlcmF0ZWRTZXJ2ZXIodXNlciwgcG9ydGFsKTtcbiAgaWYgKCFob3N0ZWRTZXJ2ZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBGaW5kIG1hbmFnZWQgc2VydmVyc1xuICBjb25zdCBmaW5kSXRlbXNVcmwgPSBgJHtob3N0ZWRTZXJ2ZXIuYWRtaW5Vcmx9L2FkbWluL2RhdGEvZmluZEl0ZW1zYDtcbiAgY29uc3QgbWFuYWdlZFNlcnZlcnMgPSBhd2FpdCByZXF1ZXN0KGZpbmRJdGVtc1VybCwgeyBtYW5hZ2VkOiB0cnVlIH0pO1xuICAvLyB3aGVyZSBwcm92aWRlciBpcyBcIkFyY0dJUyBEYXRhIFN0b3JlXCJcbiAgcmV0dXJuIG1hbmFnZWRTZXJ2ZXJzLml0ZW1zLmZpbHRlcigobWFuYWdlZFNlcnZlcikgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gbWFuYWdlZFNlcnZlci5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpID09PSBcImFyY2dpcyBkYXRhIHN0b3JlXCI7IH0pO1xufTtcbi8qKlxuICogR2V0IHRoZSBvbiBwcmVtaXNlIHBvcnRhbHMgaG9zdGVkIGZlZGVyYXRlZCBzZXJ2ZXJzXG4gKi9cbmNvbnN0IGdldEhvc3RlZEZlZGVyYXRlZFNlcnZlciA9IGFzeW5jICh1c2VyLCBwb3J0YWwpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBmZWRlcmF0ZWRTZXJ2ZXJzID0gKF9hID0gKGF3YWl0IGdldEZlZGVyYXRlZFNlcnZlcnModXNlciwgcG9ydGFsKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICByZXR1cm4gZmVkZXJhdGVkU2VydmVycy5maWx0ZXIoKHNlcnZlcikgPT4gc2VydmVyLmlzSG9zdGVkKVswXTtcbn07XG5cbmV4cG9ydCB7IGdldFBvcnRhbFJlc3RJbmZvIGFzIGEsIGdldFBvcnRhbFJlc3RJbmZvRnJvbVVybCBhcyBiLCBjbGVhckNhY2hlIGFzIGMsIGdldFBvcnRhbFRva2VuIGFzIGQsIGZvcm1SZXF1ZXN0IGFzIGUsIGZyb21DYWNoZSBhcyBmLCBnZXRSZXN0QmFzZVVybCBhcyBnLCBnZXRUb2tlbiBhcyBoLCBpc1BvcnRhbEJhY2tlZEJ5U0RTIGFzIGksIGluQ2FjaGUgYXMgaiwgZ2V0UG9ydGFsUmVzdEJhc2VVcmwgYXMgaywgZ2V0RmVkZXJhdGVkU2VydmVycyBhcyBsLCBwb2xsRm9yU3RhdHVzIGFzIHAsIHF1ZXJ5R3JvdXBzIGFzIHEsIHJlcXVlc3QgYXMgciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9