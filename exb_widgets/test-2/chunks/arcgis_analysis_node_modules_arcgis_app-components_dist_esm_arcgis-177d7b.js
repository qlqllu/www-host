"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-177d7b"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-popup-color-button.entry.js":
/*!****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-popup-color-button.entry.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_popup_color_button: () => (/* binding */ ArcgisPopupColorButton)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./popupStore-a5d93b58.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-a5d93b58.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */







const arcgisPopupColorButtonCss = ".color-selector{display:flex;padding:6px;justify-content:space-between;align-items:center;border-radius:0;cursor:pointer;background-color:var(--calcite-ui-foreground-1);color:var(--calcite-ui-text-1);border-color:var(--calcite-ui-foreground-3);border-width:1px;border-style:solid;box-shadow:transparent 0px 0px 0px 1px inset}.color-selector:hover{box-shadow:inset 0 0 0 1px var(--calcite-ui-foreground-3)}.color-selector:active{box-shadow:inset 0 0 0 2px var(--calcite-ui-foreground-3)}.color-selector:focus{box-shadow:inset 0 0 0 2px var(--calcite-ui-foreground-3);outline:2px solid var(--calcite-ui-brand);outline-offset:2px}.color-selector.selected{box-shadow:inset 0 0 0 2px var(--calcite-ui-foreground-3)}.color-icon-section{height:16px;display:inline-block}.color-icon{width:100%;height:16px;overflow:hidden;border-radius:0}.color-icon.transparent{height:15px;width:100%}.color-icon.transparent svg{height:15px;width:95%;stroke:#e0e0e0;stroke-width:1px}.color-edit-button{padding:1px;height:18px;width:18px;border:none;cursor:pointer;color:var(--calcite-ui-icon-color)}.color-edit-button:focus{outline:none}";

const MAX_RAMP_COLORS = 10;
const ArcgisPopupColorButton = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisPopupColorButtonChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupColorButtonChange", 7);
    this.arcgisPopupColorButtonBeforeOpen = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupColorButtonBeforeOpen", 7);
    this.resizeObserver = new ResizeObserver(() => {
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
    });
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    this.handleClick = async () => {
      const { popoverReferenceElement, popoverNode, buttonNode, colors, strings, esriColor, esriLang } = this;
      if (popoverNode) {
        this.onPopoverClose();
      }
      else if (colors.length === 1) {
        this.arcgisPopupColorButtonBeforeOpen.emit();
        this.selected = true;
        const popover = document.createElement("arcgis-popup-color-popover");
        popover.heading = strings.selectColor;
        popover.intlDone = strings.done;
        popover.label = strings.selectColor;
        popover.hexColor = colors[0].toHex();
        popover.popoverProps = {
          placement: "leading-start",
          offsetDistance: 1,
          offsetSkidding: 52,
          pointerDisabled: "true",
          popoverWidth: 315,
          //overlayPositioning: "fixed", -- buggy, offset issue
          refElement: typeof popoverReferenceElement === "string"
            ? document.getElementById(popoverReferenceElement)
            : popoverReferenceElement
        };
        popover.addEventListener("arcgisPopupColorPopoverClose", () => {
          this.popoverNode = null;
        });
        popover.addEventListener("arcgisPopupColorPopoverChange", ({ detail: hexColor }) => {
          this.colors[0] = new esriColor(hexColor);
          // once the user makes a change we save all colors
          this.chartMediaInfo.value.colors = esriLang.clone(this.colors);
          this.arcgisPopupColorButtonChange.emit(esriLang.clone(this.colors));
          (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
        });
        document.body.appendChild(popover);
        popover.setOpen(true);
        this.popoverNode = popover;
      }
      else {
        this.arcgisPopupColorButtonBeforeOpen.emit();
        this.selected = true;
        const symbolStylerDiv = document.createElement("div");
        symbolStylerDiv.className = "symbol-styler-div";
        this.popoverNode = this.createSymbolStylerPopover({
          referenceElement: typeof popoverReferenceElement === "string"
            ? document.getElementById(popoverReferenceElement)
            : popoverReferenceElement
        });
        this.popoverNode.addEventListener("arcgisPopupStylerPopoverClose", () => {
          this.onPopoverClose();
          // if we do this too early the enter key executes on the focused div
          setTimeout(() => buttonNode.focus(), 300);
        });
        this.popoverNode.addEventListener("arcgisPopupStylerPopoverDisconnected", () => {
          this.onPopoverClose();
        });
        this.symbolStylerWatchScaleHandle = await this.buildSymbolStylerForRamp({
          popoverNode: this.popoverNode,
          onChange: () => {
            var _a;
            // once the user makes a change we save all colors
            ((_a = this.chartMediaInfo) === null || _a === void 0 ? void 0 : _a.value).colors = esriLang.clone(this.colors);
            this.arcgisPopupColorButtonChange.emit(esriLang.clone(this.colors));
          }
        });
      }
    };
    this.popoverReferenceElement = undefined;
    this.chartMediaInfo = undefined;
    this.colors = undefined;
    this.selected = false;
    this.symbolNodeWidth = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  public calls
  //
  //--------------------------------------------------------------------------
  async setFocus() {
    var _a;
    (_a = this.buttonNode) === null || _a === void 0 ? void 0 : _a.focus();
  }
  async closePopover() {
    this.onPopoverClose();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    this.layer = _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_1__.p.layer;
    this.mapView = _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_1__.p.mapView;
    this.strings = _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_1__.p.strings;
    this.portal = _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_1__.p.portal;
    this.popupTemplate = _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_1__.p.popupTemplate;
    const [esriLang, esriColor, pieChartSchemes, SimpleFillSymbol] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_2__.l)([
      "esri/core/lang",
      "esri/Color",
      "esri/smartMapping/symbology/pieChart",
      "esri/symbols/SimpleFillSymbol"
    ]);
    this.esriLang = esriLang;
    this.esriColor = esriColor;
    this.pieChartSchemes = pieChartSchemes;
    this.SimpleFillSymbol = SimpleFillSymbol;
  }
  async componentDidLoad() {
    // for correct width
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
    this.resizeObserver.observe(this.buttonNode);
  }
  disconnectedCallback() {
    this.resizeObserver.unobserve(this.buttonNode);
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { strings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { id: "color-button-label", scale: "s" }, strings.color, this.renderButton())));
  }
  renderButton() {
    const { colors, selected } = this;
    let colorsIcon = (colors === null || colors === void 0 ? void 0 : colors.length)
      ? colors
        .filter((_, idx2) => idx2 < MAX_RAMP_COLORS)
        .map((color, idx) => {
        var _a;
        return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `color-button-icon-${idx}`, class: "color-icon-section", style: {
            width: `${95 / Math.min(10, Math.min(MAX_RAMP_COLORS, colors.length))}%`,
            backgroundColor: `${(_a = color === null || color === void 0 ? void 0 : color.toHex()) !== null && _a !== void 0 ? _a : "#ffffff"}`
          } }));
      })
      : null;
    const colorClasses = {
      "color-selector": true,
      selected
    };
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: colorClasses, onClick: this.handleClick, role: "button", tabIndex: 0, "aria-labelledby": "color-button-label", "aria-haspopup": "true", "aria-expanded": !!selected, ref: (node) => {
        this.buttonNode = node;
        node.addEventListener("keyup", (event) => {
          if (event.key === " " || event.key === "Enter") {
            this.handleClick();
          }
        });
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "color-icon", "aria-hidden": "true" }, colorsIcon), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "color-edit-button" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "pencil" }))));
  }
  onPopoverClose() {
    var _a;
    if (this.colors.length === 1) {
      this.popoverNode && document.body.removeChild(this.popoverNode);
    }
    else {
      (_a = this.symbolStylerWatchScaleHandle) === null || _a === void 0 ? void 0 : _a.remove();
      this.popoverNode &&
        this.removeSymbolStylerPopover(this.popoverNode);
    }
    this.selected = false;
    this.popoverNode = undefined;
  }
  createSymbolStylerPopover(props) {
    const { referenceElement } = props;
    const popover = document.createElement("arcgis-popup-styler-popover");
    popover.referenceElement = referenceElement;
    document.body.appendChild(popover);
    popover.setOpen(true);
    popover.reposition();
    return popover;
  }
  removeSymbolStylerPopover(popover) {
    var _a;
    if (popover === null || popover === void 0 ? void 0 : popover.parentNode) {
      popover.open = false;
      (_a = popover.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(popover);
    }
  }
  async createSymbolStylerElement(popoverNode) {
    const symbolStyler = document.createElement("arcgis-symbol-styler");
    symbolStyler.style = "max-height: max(calc(100vh - 200px), 300px)"; // not the best, but easiest
    symbolStyler.popoverProps = {
      placement: "bottom-end",
      offsetDistance: 10,
      offsetSkidding: (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement) === "rtl" ? 3 : -3,
      pointerDisabled: "true",
      popoverWidth: 315,
      //overlayPositioning: "fixed", -- buggy, offset issue
      refElement: await popoverNode.getPopoverRefElement()
    };
    return symbolStyler;
  }
  async buildSymbolStylerForRamp(options) {
    const { mapView, portal, colors, strings, esriLang } = this;
    const { popoverNode } = options;
    const currentColors = this.esriLang.clone(colors.filter((_, idx2) => idx2 < MAX_RAMP_COLORS));
    const schemes = this.pieChartSchemes.getSchemes({
      basemap: mapView.map.basemap,
      geometryType: "polygon",
      numColors: Math.min(MAX_RAMP_COLORS, colors.length)
    });
    const colorRampsAndSchemes = this.getColorRampsWithSchemes(schemes);
    const colorRamps = colorRampsAndSchemes.map((obj) => {
      return {
        stops: obj.colors.reverse(),
        tags: obj.scheme.tags,
        name: obj.scheme.name
      };
    });
    const onStylerEdit = ({ detail: { 
    //symbol,
    info: { /* marker, stroke, */ fill } } }) => {
      var _a;
      const colors = esriLang.clone(fill.color).reverse();
      if (colors.length < this.colors.length) {
        // repeat
        const len = colors.length;
        for (let i = len; i < this.colors.length; i++) {
          colors.push(this.esriLang.clone(colors[i % MAX_RAMP_COLORS]));
        }
      }
      ((_a = this.chartMediaInfo) === null || _a === void 0 ? void 0 : _a.value).colors = colors;
      this.colors = colors;
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
      this.arcgisPopupColorButtonChange.emit(this.esriLang.clone(this.colors));
    };
    const symbolStyler = await this.createSymbolStylerElement(popoverNode);
    const edit = symbolStyler.edit(new this.SimpleFillSymbol(), {
      portal,
      sections: {
        marker: {
          parts: {
            preview: false,
            rotation: false,
            size: false
          }
        },
        fill: {
          type: "color-ramp",
          style: "discrete",
          open: true,
          colorRampsOpen: true,
          colorRamps,
          parts: {
            transparency: false // temp /arcgis-js-api/issues/27188
          }
        }
      },
      fill: {
        color: currentColors.reverse()
      }
    });
    symbolStyler.stringOverrides = {
      fillColor: strings.color
    };
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEdit);
    popoverNode.addStyler(symbolStyler);
    await edit;
  }
  getColorRampsWithSchemes(schemes) {
    const allSchemes = [schemes.primaryScheme].concat(schemes.secondarySchemes), colorRampsAndSchemes = [];
    allSchemes.forEach((scheme) => {
      colorRampsAndSchemes.push({
        colors: scheme.colors,
        scheme
      });
    });
    return colorRampsAndSchemes;
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisPopupColorButton.style = arcgisPopupColorButtonCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



const languageMap = new Map([
  ["ar", "ar"],
  ["bg", "bg"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["cs", "cs"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["es", "es"],
  ["et", "et"],
  ["fi", "fi"],
  ["fr", "fr"],
  ["he", "he"],
  ["hr", "hr"],
  ["hu", "hu"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "ja"],
  ["ko", "ko"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["nb", "nb"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["pt-br", "pt-BR"],
  ["pt-pt", "pt-PT"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sr", "sr"],
  ["sv", "sv"],
  ["th", "th"],
  ["tr", "tr"],
  ["uk", "uk"],
  ["vi", "vi"],
  ["zh-cn", "zh-CN"],
  ["zh-hk", "zh-HK"],
  ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
  return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
  const closestWithProp = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
  return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
  rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
  const { api, type, places } = options || {};
  if (api === 4) {
    const [intl] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
    const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
      places,
      style: type,
      digitSeparator: true
    });
    return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
  }
  const [dojoNumber] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
  return dojoNumber.format(number, {
    type,
    places,
    pattern: options === null || options === void 0 ? void 0 : options.pattern
  });
}
const cache = {};
function formatDate(date) {
  const lang = document.documentElement.lang;
  const dayShortMonthYear = {
    year: "numeric",
    month: "short",
    day: "numeric"
  };
  if (!cache[lang]) {
    cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
  }
  return cache[lang].format(date);
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-a5d93b58.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-a5d93b58.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ clearPopupState),
/* harmony export */   p: () => (/* binding */ popupState)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const popupStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  layer: null,
  mapView: null,
  portal: null,
  config: null,
  strings: null,
  currentLanguage: null,
  currentLanguageIntl: null,
  serviceType: null,
  popupTemplate: null,
  layerHasAttachment: null,
  layerHasET: null,
  layerHasAttributes: null,
  layerHasCharts: null,
  layerHasImages: null,
  layerHasText: null,
  layerDisplayType: null,
  supportsArcade: null,
  layerHasRelatedRecords: false
});
// workaround for starting a panel with a clean state
function clearPopupState(popupState) {
  popupState.layer = null;
  popupState.mapView = null;
  popupState.portal = null;
  popupState.config = null;
  popupState.strings = null;
  popupState.currentLanguage = null;
  popupState.currentLanguageIntl = null;
  popupState.serviceType = null;
  popupState.popupTemplate = null;
  popupState.layerHasAttachment = null;
  popupState.layerHasET = null;
  popupState.layerHasAttributes = null;
  popupState.layerHasCharts = null;
  popupState.layerHasImages = null;
  popupState.layerHasText = null;
  popupState.layerDisplayType = null;
  popupState.supportsArcade = null;
  popupState.layerHasRelatedRecords = false;
}
const popupState = popupStore.state;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTE3N2Q3Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDK0g7QUFDcEU7QUFDRTtBQUNHO0FBQ25DO0FBQ0Y7O0FBRTNCLG1EQUFtRCxhQUFhLFlBQVksOEJBQThCLG1CQUFtQixnQkFBZ0IsZUFBZSxnREFBZ0QsK0JBQStCLDRDQUE0QyxpQkFBaUIsbUJBQW1CLDZDQUE2QyxzQkFBc0IsMERBQTBELHVCQUF1QiwwREFBMEQsc0JBQXNCLDBEQUEwRCwwQ0FBMEMsbUJBQW1CLHlCQUF5QiwwREFBMEQsb0JBQW9CLFlBQVkscUJBQXFCLFlBQVksV0FBVyxZQUFZLGdCQUFnQixnQkFBZ0Isd0JBQXdCLFlBQVksV0FBVyw0QkFBNEIsWUFBWSxVQUFVLGVBQWUsaUJBQWlCLG1CQUFtQixZQUFZLFlBQVksV0FBVyxZQUFZLGVBQWUsbUNBQW1DLHlCQUF5QixhQUFhOztBQUU1bkM7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBZ0I7QUFDcEIsd0NBQXdDLHFEQUFXO0FBQ25ELDRDQUE0QyxxREFBVztBQUN2RDtBQUNBLE1BQU0scURBQVc7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUZBQXlGO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxRUFBcUUsa0JBQWtCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBVztBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1wb3B1cC1jb2xvci1idXR0b24uZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtODFkNTQ4YjcuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGFuZ3VhZ2VVdGlsLTIyMjU4YzkwLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3BvcHVwU3RvcmUtYTVkOTNiNTguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGYgYXMgZm9yY2VVcGRhdGUsIGgsIEggYXMgSG9zdCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5pbXBvcnQgeyBwIGFzIHBvcHVwU3RhdGUgfSBmcm9tICcuL3BvcHVwU3RvcmUtYTVkOTNiNTguanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYWFmMzBiZDYuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0ICcuL2luZGV4LTgxZDU0OGI3LmpzJztcbmltcG9ydCAnLi9kb20tMTNmNWIwMGMuanMnO1xuXG5jb25zdCBhcmNnaXNQb3B1cENvbG9yQnV0dG9uQ3NzID0gXCIuY29sb3Itc2VsZWN0b3J7ZGlzcGxheTpmbGV4O3BhZGRpbmc6NnB4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcjtib3JkZXItcmFkaXVzOjA7Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMSk7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO2JvcmRlci1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMyk7Ym9yZGVyLXdpZHRoOjFweDtib3JkZXItc3R5bGU6c29saWQ7Ym94LXNoYWRvdzp0cmFuc3BhcmVudCAwcHggMHB4IDBweCAxcHggaW5zZXR9LmNvbG9yLXNlbGVjdG9yOmhvdmVye2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4IHZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0zKX0uY29sb3Itc2VsZWN0b3I6YWN0aXZle2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMnB4IHZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0zKX0uY29sb3Itc2VsZWN0b3I6Zm9jdXN7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAycHggdmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTMpO291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO291dGxpbmUtb2Zmc2V0OjJweH0uY29sb3Itc2VsZWN0b3Iuc2VsZWN0ZWR7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAycHggdmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTMpfS5jb2xvci1pY29uLXNlY3Rpb257aGVpZ2h0OjE2cHg7ZGlzcGxheTppbmxpbmUtYmxvY2t9LmNvbG9yLWljb257d2lkdGg6MTAwJTtoZWlnaHQ6MTZweDtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyLXJhZGl1czowfS5jb2xvci1pY29uLnRyYW5zcGFyZW50e2hlaWdodDoxNXB4O3dpZHRoOjEwMCV9LmNvbG9yLWljb24udHJhbnNwYXJlbnQgc3Zne2hlaWdodDoxNXB4O3dpZHRoOjk1JTtzdHJva2U6I2UwZTBlMDtzdHJva2Utd2lkdGg6MXB4fS5jb2xvci1lZGl0LWJ1dHRvbntwYWRkaW5nOjFweDtoZWlnaHQ6MThweDt3aWR0aDoxOHB4O2JvcmRlcjpub25lO2N1cnNvcjpwb2ludGVyO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktaWNvbi1jb2xvcil9LmNvbG9yLWVkaXQtYnV0dG9uOmZvY3Vze291dGxpbmU6bm9uZX1cIjtcblxuY29uc3QgTUFYX1JBTVBfQ09MT1JTID0gMTA7XG5jb25zdCBBcmNnaXNQb3B1cENvbG9yQnV0dG9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFyY2dpc1BvcHVwQ29sb3JCdXR0b25DaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1BvcHVwQ29sb3JCdXR0b25DaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yQnV0dG9uQmVmb3JlT3BlbiA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzUG9wdXBDb2xvckJ1dHRvbkJlZm9yZU9wZW5cIiwgNyk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICB9KTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBwb3BvdmVyUmVmZXJlbmNlRWxlbWVudCwgcG9wb3Zlck5vZGUsIGJ1dHRvbk5vZGUsIGNvbG9ycywgc3RyaW5ncywgZXNyaUNvbG9yLCBlc3JpTGFuZyB9ID0gdGhpcztcbiAgICAgIGlmIChwb3BvdmVyTm9kZSkge1xuICAgICAgICB0aGlzLm9uUG9wb3ZlckNsb3NlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuYXJjZ2lzUG9wdXBDb2xvckJ1dHRvbkJlZm9yZU9wZW4uZW1pdCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcG9wb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtcG9wdXAtY29sb3ItcG9wb3ZlclwiKTtcbiAgICAgICAgcG9wb3Zlci5oZWFkaW5nID0gc3RyaW5ncy5zZWxlY3RDb2xvcjtcbiAgICAgICAgcG9wb3Zlci5pbnRsRG9uZSA9IHN0cmluZ3MuZG9uZTtcbiAgICAgICAgcG9wb3Zlci5sYWJlbCA9IHN0cmluZ3Muc2VsZWN0Q29sb3I7XG4gICAgICAgIHBvcG92ZXIuaGV4Q29sb3IgPSBjb2xvcnNbMF0udG9IZXgoKTtcbiAgICAgICAgcG9wb3Zlci5wb3BvdmVyUHJvcHMgPSB7XG4gICAgICAgICAgcGxhY2VtZW50OiBcImxlYWRpbmctc3RhcnRcIixcbiAgICAgICAgICBvZmZzZXREaXN0YW5jZTogMSxcbiAgICAgICAgICBvZmZzZXRTa2lkZGluZzogNTIsXG4gICAgICAgICAgcG9pbnRlckRpc2FibGVkOiBcInRydWVcIixcbiAgICAgICAgICBwb3BvdmVyV2lkdGg6IDMxNSxcbiAgICAgICAgICAvL292ZXJsYXlQb3NpdGlvbmluZzogXCJmaXhlZFwiLCAtLSBidWdneSwgb2Zmc2V0IGlzc3VlXG4gICAgICAgICAgcmVmRWxlbWVudDogdHlwZW9mIHBvcG92ZXJSZWZlcmVuY2VFbGVtZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvcG92ZXJSZWZlcmVuY2VFbGVtZW50KVxuICAgICAgICAgICAgOiBwb3BvdmVyUmVmZXJlbmNlRWxlbWVudFxuICAgICAgICB9O1xuICAgICAgICBwb3BvdmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNQb3B1cENvbG9yUG9wb3ZlckNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnBvcG92ZXJOb2RlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvcG92ZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1BvcHVwQ29sb3JQb3BvdmVyQ2hhbmdlXCIsICh7IGRldGFpbDogaGV4Q29sb3IgfSkgPT4ge1xuICAgICAgICAgIHRoaXMuY29sb3JzWzBdID0gbmV3IGVzcmlDb2xvcihoZXhDb2xvcik7XG4gICAgICAgICAgLy8gb25jZSB0aGUgdXNlciBtYWtlcyBhIGNoYW5nZSB3ZSBzYXZlIGFsbCBjb2xvcnNcbiAgICAgICAgICB0aGlzLmNoYXJ0TWVkaWFJbmZvLnZhbHVlLmNvbG9ycyA9IGVzcmlMYW5nLmNsb25lKHRoaXMuY29sb3JzKTtcbiAgICAgICAgICB0aGlzLmFyY2dpc1BvcHVwQ29sb3JCdXR0b25DaGFuZ2UuZW1pdChlc3JpTGFuZy5jbG9uZSh0aGlzLmNvbG9ycykpO1xuICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3BvdmVyKTtcbiAgICAgICAgcG9wb3Zlci5zZXRPcGVuKHRydWUpO1xuICAgICAgICB0aGlzLnBvcG92ZXJOb2RlID0gcG9wb3ZlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFyY2dpc1BvcHVwQ29sb3JCdXR0b25CZWZvcmVPcGVuLmVtaXQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN5bWJvbFN0eWxlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHN5bWJvbFN0eWxlckRpdi5jbGFzc05hbWUgPSBcInN5bWJvbC1zdHlsZXItZGl2XCI7XG4gICAgICAgIHRoaXMucG9wb3Zlck5vZGUgPSB0aGlzLmNyZWF0ZVN5bWJvbFN0eWxlclBvcG92ZXIoe1xuICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQ6IHR5cGVvZiBwb3BvdmVyUmVmZXJlbmNlRWxlbWVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3BvdmVyUmVmZXJlbmNlRWxlbWVudClcbiAgICAgICAgICAgIDogcG9wb3ZlclJlZmVyZW5jZUVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9wb3Zlck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1BvcHVwU3R5bGVyUG9wb3ZlckNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9uUG9wb3ZlckNsb3NlKCk7XG4gICAgICAgICAgLy8gaWYgd2UgZG8gdGhpcyB0b28gZWFybHkgdGhlIGVudGVyIGtleSBleGVjdXRlcyBvbiB0aGUgZm9jdXNlZCBkaXZcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGJ1dHRvbk5vZGUuZm9jdXMoKSwgMzAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9wb3Zlck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1BvcHVwU3R5bGVyUG9wb3ZlckRpc2Nvbm5lY3RlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vblBvcG92ZXJDbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zeW1ib2xTdHlsZXJXYXRjaFNjYWxlSGFuZGxlID0gYXdhaXQgdGhpcy5idWlsZFN5bWJvbFN0eWxlckZvclJhbXAoe1xuICAgICAgICAgIHBvcG92ZXJOb2RlOiB0aGlzLnBvcG92ZXJOb2RlLFxuICAgICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBvbmNlIHRoZSB1c2VyIG1ha2VzIGEgY2hhbmdlIHdlIHNhdmUgYWxsIGNvbG9yc1xuICAgICAgICAgICAgKChfYSA9IHRoaXMuY2hhcnRNZWRpYUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkuY29sb3JzID0gZXNyaUxhbmcuY2xvbmUodGhpcy5jb2xvcnMpO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yQnV0dG9uQ2hhbmdlLmVtaXQoZXNyaUxhbmcuY2xvbmUodGhpcy5jb2xvcnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb3BvdmVyUmVmZXJlbmNlRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0TWVkaWFJbmZvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN5bWJvbE5vZGVXaWR0aCA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBwdWJsaWMgY2FsbHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBzZXRGb2N1cygpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5idXR0b25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgfVxuICBhc3luYyBjbG9zZVBvcG92ZXIoKSB7XG4gICAgdGhpcy5vblBvcG92ZXJDbG9zZSgpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMubGF5ZXIgPSBwb3B1cFN0YXRlLmxheWVyO1xuICAgIHRoaXMubWFwVmlldyA9IHBvcHVwU3RhdGUubWFwVmlldztcbiAgICB0aGlzLnN0cmluZ3MgPSBwb3B1cFN0YXRlLnN0cmluZ3M7XG4gICAgdGhpcy5wb3J0YWwgPSBwb3B1cFN0YXRlLnBvcnRhbDtcbiAgICB0aGlzLnBvcHVwVGVtcGxhdGUgPSBwb3B1cFN0YXRlLnBvcHVwVGVtcGxhdGU7XG4gICAgY29uc3QgW2VzcmlMYW5nLCBlc3JpQ29sb3IsIHBpZUNoYXJ0U2NoZW1lcywgU2ltcGxlRmlsbFN5bWJvbF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICBcImVzcmkvY29yZS9sYW5nXCIsXG4gICAgICBcImVzcmkvQ29sb3JcIixcbiAgICAgIFwiZXNyaS9zbWFydE1hcHBpbmcvc3ltYm9sb2d5L3BpZUNoYXJ0XCIsXG4gICAgICBcImVzcmkvc3ltYm9scy9TaW1wbGVGaWxsU3ltYm9sXCJcbiAgICBdKTtcbiAgICB0aGlzLmVzcmlMYW5nID0gZXNyaUxhbmc7XG4gICAgdGhpcy5lc3JpQ29sb3IgPSBlc3JpQ29sb3I7XG4gICAgdGhpcy5waWVDaGFydFNjaGVtZXMgPSBwaWVDaGFydFNjaGVtZXM7XG4gICAgdGhpcy5TaW1wbGVGaWxsU3ltYm9sID0gU2ltcGxlRmlsbFN5bWJvbDtcbiAgfVxuICBhc3luYyBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIC8vIGZvciBjb3JyZWN0IHdpZHRoXG4gICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuYnV0dG9uTm9kZSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy5idXR0b25Ob2RlKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGlkOiBcImNvbG9yLWJ1dHRvbi1sYWJlbFwiLCBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5jb2xvciwgdGhpcy5yZW5kZXJCdXR0b24oKSkpKTtcbiAgfVxuICByZW5kZXJCdXR0b24oKSB7XG4gICAgY29uc3QgeyBjb2xvcnMsIHNlbGVjdGVkIH0gPSB0aGlzO1xuICAgIGxldCBjb2xvcnNJY29uID0gKGNvbG9ycyA9PT0gbnVsbCB8fCBjb2xvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9ycy5sZW5ndGgpXG4gICAgICA/IGNvbG9yc1xuICAgICAgICAuZmlsdGVyKChfLCBpZHgyKSA9PiBpZHgyIDwgTUFYX1JBTVBfQ09MT1JTKVxuICAgICAgICAubWFwKChjb2xvciwgaWR4KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsga2V5OiBgY29sb3ItYnV0dG9uLWljb24tJHtpZHh9YCwgY2xhc3M6IFwiY29sb3ItaWNvbi1zZWN0aW9uXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogYCR7OTUgLyBNYXRoLm1pbigxMCwgTWF0aC5taW4oTUFYX1JBTVBfQ09MT1JTLCBjb2xvcnMubGVuZ3RoKSl9JWAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGAkeyhfYSA9IGNvbG9yID09PSBudWxsIHx8IGNvbG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xvci50b0hleCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIiNmZmZmZmZcIn1gXG4gICAgICAgICAgfSB9KSk7XG4gICAgICB9KVxuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGNvbG9yQ2xhc3NlcyA9IHtcbiAgICAgIFwiY29sb3Itc2VsZWN0b3JcIjogdHJ1ZSxcbiAgICAgIHNlbGVjdGVkXG4gICAgfTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogY29sb3JDbGFzc2VzLCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCByb2xlOiBcImJ1dHRvblwiLCB0YWJJbmRleDogMCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJjb2xvci1idXR0b24tbGFiZWxcIiwgXCJhcmlhLWhhc3BvcHVwXCI6IFwidHJ1ZVwiLCBcImFyaWEtZXhwYW5kZWRcIjogISFzZWxlY3RlZCwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICB0aGlzLmJ1dHRvbk5vZGUgPSBub2RlO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIiBcIiB8fCBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IH0sIGgoXCJkaXZcIiwgeyBjbGFzczogXCJjb2xvci1pY29uXCIsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSwgY29sb3JzSWNvbiksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJjb2xvci1lZGl0LWJ1dHRvblwiIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBzY2FsZTogXCJzXCIsIGljb246IFwicGVuY2lsXCIgfSkpKSk7XG4gIH1cbiAgb25Qb3BvdmVyQ2xvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLmNvbG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMucG9wb3Zlck5vZGUgJiYgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnBvcG92ZXJOb2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAoX2EgPSB0aGlzLnN5bWJvbFN0eWxlcldhdGNoU2NhbGVIYW5kbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgIHRoaXMucG9wb3Zlck5vZGUgJiZcbiAgICAgICAgdGhpcy5yZW1vdmVTeW1ib2xTdHlsZXJQb3BvdmVyKHRoaXMucG9wb3Zlck5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5wb3BvdmVyTm9kZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBjcmVhdGVTeW1ib2xTdHlsZXJQb3BvdmVyKHByb3BzKSB7XG4gICAgY29uc3QgeyByZWZlcmVuY2VFbGVtZW50IH0gPSBwcm9wcztcbiAgICBjb25zdCBwb3BvdmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1wb3B1cC1zdHlsZXItcG9wb3ZlclwiKTtcbiAgICBwb3BvdmVyLnJlZmVyZW5jZUVsZW1lbnQgPSByZWZlcmVuY2VFbGVtZW50O1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9wb3Zlcik7XG4gICAgcG9wb3Zlci5zZXRPcGVuKHRydWUpO1xuICAgIHBvcG92ZXIucmVwb3NpdGlvbigpO1xuICAgIHJldHVybiBwb3BvdmVyO1xuICB9XG4gIHJlbW92ZVN5bWJvbFN0eWxlclBvcG92ZXIocG9wb3Zlcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAocG9wb3ZlciA9PT0gbnVsbCB8fCBwb3BvdmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3BvdmVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHBvcG92ZXIub3BlbiA9IGZhbHNlO1xuICAgICAgKF9hID0gcG9wb3Zlci5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQocG9wb3Zlcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpIHtcbiAgICBjb25zdCBzeW1ib2xTdHlsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXJcIik7XG4gICAgc3ltYm9sU3R5bGVyLnN0eWxlID0gXCJtYXgtaGVpZ2h0OiBtYXgoY2FsYygxMDB2aCAtIDIwMHB4KSwgMzAwcHgpXCI7IC8vIG5vdCB0aGUgYmVzdCwgYnV0IGVhc2llc3RcbiAgICBzeW1ib2xTdHlsZXIucG9wb3ZlclByb3BzID0ge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICAgIG9mZnNldERpc3RhbmNlOiAxMCxcbiAgICAgIG9mZnNldFNraWRkaW5nOiBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiID8gMyA6IC0zLFxuICAgICAgcG9pbnRlckRpc2FibGVkOiBcInRydWVcIixcbiAgICAgIHBvcG92ZXJXaWR0aDogMzE1LFxuICAgICAgLy9vdmVybGF5UG9zaXRpb25pbmc6IFwiZml4ZWRcIiwgLS0gYnVnZ3ksIG9mZnNldCBpc3N1ZVxuICAgICAgcmVmRWxlbWVudDogYXdhaXQgcG9wb3Zlck5vZGUuZ2V0UG9wb3ZlclJlZkVsZW1lbnQoKVxuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbFN0eWxlcjtcbiAgfVxuICBhc3luYyBidWlsZFN5bWJvbFN0eWxlckZvclJhbXAob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbWFwVmlldywgcG9ydGFsLCBjb2xvcnMsIHN0cmluZ3MsIGVzcmlMYW5nIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3VycmVudENvbG9ycyA9IHRoaXMuZXNyaUxhbmcuY2xvbmUoY29sb3JzLmZpbHRlcigoXywgaWR4MikgPT4gaWR4MiA8IE1BWF9SQU1QX0NPTE9SUykpO1xuICAgIGNvbnN0IHNjaGVtZXMgPSB0aGlzLnBpZUNoYXJ0U2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgIGJhc2VtYXA6IG1hcFZpZXcubWFwLmJhc2VtYXAsXG4gICAgICBnZW9tZXRyeVR5cGU6IFwicG9seWdvblwiLFxuICAgICAgbnVtQ29sb3JzOiBNYXRoLm1pbihNQVhfUkFNUF9DT0xPUlMsIGNvbG9ycy5sZW5ndGgpXG4gICAgfSk7XG4gICAgY29uc3QgY29sb3JSYW1wc0FuZFNjaGVtZXMgPSB0aGlzLmdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyhzY2hlbWVzKTtcbiAgICBjb25zdCBjb2xvclJhbXBzID0gY29sb3JSYW1wc0FuZFNjaGVtZXMubWFwKChvYmopID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0b3BzOiBvYmouY29sb3JzLnJldmVyc2UoKSxcbiAgICAgICAgdGFnczogb2JqLnNjaGVtZS50YWdzLFxuICAgICAgICBuYW1lOiBvYmouc2NoZW1lLm5hbWVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgb25TdHlsZXJFZGl0ID0gKHsgZGV0YWlsOiB7IFxuICAgIC8vc3ltYm9sLFxuICAgIGluZm86IHsgLyogbWFya2VyLCBzdHJva2UsICovIGZpbGwgfSB9IH0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGNvbG9ycyA9IGVzcmlMYW5nLmNsb25lKGZpbGwuY29sb3IpLnJldmVyc2UoKTtcbiAgICAgIGlmIChjb2xvcnMubGVuZ3RoIDwgdGhpcy5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlcGVhdFxuICAgICAgICBjb25zdCBsZW4gPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gbGVuOyBpIDwgdGhpcy5jb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb2xvcnMucHVzaCh0aGlzLmVzcmlMYW5nLmNsb25lKGNvbG9yc1tpICUgTUFYX1JBTVBfQ09MT1JTXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoKF9hID0gdGhpcy5jaGFydE1lZGlhSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlKS5jb2xvcnMgPSBjb2xvcnM7XG4gICAgICB0aGlzLmNvbG9ycyA9IGNvbG9ycztcbiAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yQnV0dG9uQ2hhbmdlLmVtaXQodGhpcy5lc3JpTGFuZy5jbG9uZSh0aGlzLmNvbG9ycykpO1xuICAgIH07XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgdGhpcy5jcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKTtcbiAgICBjb25zdCBlZGl0ID0gc3ltYm9sU3R5bGVyLmVkaXQobmV3IHRoaXMuU2ltcGxlRmlsbFN5bWJvbCgpLCB7XG4gICAgICBwb3J0YWwsXG4gICAgICBzZWN0aW9uczoge1xuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICByb3RhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBzaXplOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIHR5cGU6IFwiY29sb3ItcmFtcFwiLFxuICAgICAgICAgIHN0eWxlOiBcImRpc2NyZXRlXCIsXG4gICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICBjb2xvclJhbXBzT3BlbjogdHJ1ZSxcbiAgICAgICAgICBjb2xvclJhbXBzLFxuICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICB0cmFuc3BhcmVuY3k6IGZhbHNlIC8vIHRlbXAgL2FyY2dpcy1qcy1hcGkvaXNzdWVzLzI3MTg4XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmlsbDoge1xuICAgICAgICBjb2xvcjogY3VycmVudENvbG9ycy5yZXZlcnNlKClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzeW1ib2xTdHlsZXIuc3RyaW5nT3ZlcnJpZGVzID0ge1xuICAgICAgZmlsbENvbG9yOiBzdHJpbmdzLmNvbG9yXG4gICAgfTtcbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgb25TdHlsZXJFZGl0KTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xuICB9XG4gIGdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyhzY2hlbWVzKSB7XG4gICAgY29uc3QgYWxsU2NoZW1lcyA9IFtzY2hlbWVzLnByaW1hcnlTY2hlbWVdLmNvbmNhdChzY2hlbWVzLnNlY29uZGFyeVNjaGVtZXMpLCBjb2xvclJhbXBzQW5kU2NoZW1lcyA9IFtdO1xuICAgIGFsbFNjaGVtZXMuZm9yRWFjaCgoc2NoZW1lKSA9PiB7XG4gICAgICBjb2xvclJhbXBzQW5kU2NoZW1lcy5wdXNoKHtcbiAgICAgICAgY29sb3JzOiBzY2hlbWUuY29sb3JzLFxuICAgICAgICBzY2hlbWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2xvclJhbXBzQW5kU2NoZW1lcztcbiAgfVxuICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzUG9wdXBDb2xvckJ1dHRvbi5zdHlsZSA9IGFyY2dpc1BvcHVwQ29sb3JCdXR0b25Dc3M7XG5cbmV4cG9ydCB7IEFyY2dpc1BvcHVwQ29sb3JCdXR0b24gYXMgYXJjZ2lzX3BvcHVwX2NvbG9yX2J1dHRvbiB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBnIGFzIGdldFJlbmRlcmluZ1JlZiwgZiBhcyBmb3JjZVVwZGF0ZSB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuXG5jb25zdCBhcHBlbmRUb01hcCA9IChtYXAsIHByb3BOYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gbWFwLmdldChwcm9wTmFtZSk7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgICBtYXAuc2V0KHByb3BOYW1lLCBbdmFsdWVdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWl0ZW1zLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIG1zKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSAwO1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvc3NpYmxlIGVsZW1lbnQgaXNDb25uZWN0ZWQuXG4gKiBUaGUgcHJvcGVydHkgbWlnaHQgbm90IGJlIHRoZXJlLCBzbyB3ZSBjaGVjayBmb3IgaXQuXG4gKlxuICogV2Ugd2FudCBpdCB0byByZXR1cm4gdHJ1ZSBpZiBpc0Nvbm5lY3RlZCBpcyBub3QgYSBwcm9wZXJ0eSxcbiAqIG90aGVyd2lzZSB3ZSB3b3VsZCByZW1vdmUgdGhlc2UgZWxlbWVudHMgYW5kIHdvdWxkIG5vdCB1cGRhdGUuXG4gKlxuICogQmV0dGVyIGxlYWsgaW4gRWRnZSB0aGFuIHRvIGJlIHVzZWxlc3MuXG4gKi9cbmNvbnN0IGlzQ29ubmVjdGVkID0gKG1heWJlRWxlbWVudCkgPT4gISgnaXNDb25uZWN0ZWQnIGluIG1heWJlRWxlbWVudCkgfHwgbWF5YmVFbGVtZW50LmlzQ29ubmVjdGVkO1xuY29uc3QgY2xlYW51cEVsZW1lbnRzID0gZGVib3VuY2UoKG1hcCkgPT4ge1xuICAgIGZvciAobGV0IGtleSBvZiBtYXAua2V5cygpKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBtYXAuZ2V0KGtleSkuZmlsdGVyKGlzQ29ubmVjdGVkKSk7XG4gICAgfVxufSwgMjAwMCk7XG5jb25zdCBzdGVuY2lsU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2V0UmVuZGVyaW5nUmVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBub3QgaW4gYSBzdGVuY2lsIHByb2plY3QsIHdlIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlYWxseSBleHBvcnRlZCBieSBAc3RlbmNpbC9jb3JlLlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGVsbXNUb1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwb3NlOiAoKSA9PiBlbG1zVG9VcGRhdGUuY2xlYXIoKSxcbiAgICAgICAgZ2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IGdldFJlbmRlcmluZ1JlZigpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZFRvTWFwKGVsbXNUb1VwZGF0ZSwgcHJvcE5hbWUsIGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKHByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGVsbXNUb1VwZGF0ZS5nZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZWxtc1RvVXBkYXRlLnNldChwcm9wTmFtZSwgZWxlbWVudHMuZmlsdGVyKGZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwRWxlbWVudHMoZWxtc1RvVXBkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGVsbXNUb1VwZGF0ZS5mb3JFYWNoKChlbG1zKSA9PiBlbG1zLmZvckVhY2goZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCB1bndyYXAgPSAodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHZhbCgpIDogdmFsKTtcbmNvbnN0IGNyZWF0ZU9ic2VydmFibGVNYXAgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUgPSAoYSwgYikgPT4gYSAhPT0gYikgPT4ge1xuICAgIGNvbnN0IHVud3JhcHBlZFN0YXRlID0gdW53cmFwKGRlZmF1bHRTdGF0ZSk7XG4gICAgbGV0IHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXModW53cmFwcGVkU3RhdGUgIT09IG51bGwgJiYgdW53cmFwcGVkU3RhdGUgIT09IHZvaWQgMCA/IHVud3JhcHBlZFN0YXRlIDoge30pKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgZGlzcG9zZTogW10sXG4gICAgICAgIGdldDogW10sXG4gICAgICAgIHNldDogW10sXG4gICAgICAgIHJlc2V0OiBbXSxcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFdoZW4gcmVzZXR0aW5nIHRoZSBzdGF0ZSwgdGhlIGRlZmF1bHQgc3RhdGUgbWF5IGJlIGEgZnVuY3Rpb24gLSB1bndyYXAgaXQgdG8gaW52b2tlIGl0LlxuICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBzdGF0ZSB3b24ndCBiZSBwcm9wZXJseSByZXNldFxuICAgICAgICBzdGF0ZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKChfYSA9IHVud3JhcChkZWZhdWx0U3RhdGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSkpO1xuICAgICAgICBoYW5kbGVycy5yZXNldC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgfTtcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAvLyBDYWxsIGZpcnN0IGRpc3Bvc2UgYXMgcmVzZXR0aW5nIHRoZSBzdGF0ZSB3b3VsZFxuICAgICAgICAvLyBjYXVzZSBsZXNzIHVwZGF0ZXMgOylcbiAgICAgICAgaGFuZGxlcnMuZGlzcG9zZS5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQgPSAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgaGFuZGxlcnMuZ2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSkpO1xuICAgICAgICByZXR1cm4gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXQgPSAocHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUodmFsdWUsIG9sZFZhbHVlLCBwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIHN0YXRlcy5zZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2IocHJvcE5hbWUsIHZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9ICh0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8ge31cbiAgICAgICAgOiBuZXcgUHJveHkodW53cmFwcGVkU3RhdGUsIHtcbiAgICAgICAgICAgIGdldChfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXMoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXRlcy5rZXlzKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXMoXywgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzLmhhcyhwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KF8sIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIGNvbnN0IG9uID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheShoYW5kbGVyc1tldmVudE5hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IChwcm9wTmFtZSwgY2IpID0+IHtcbiAgICAgICAgY29uc3QgdW5TZXQgPSBvbignc2V0JywgKGtleSwgbmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2IobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1bndyYXAgdGhlIGRlZmF1bHRTdGF0ZSBiZWNhdXNlIGl0IG1pZ2h0IGJlIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBtaWdodCBub3QgYmUgc2VuZGluZyB0aGUgcmlnaHQgcmVzZXQgdmFsdWUuXG4gICAgICAgIGNvbnN0IHVuUmVzZXQgPSBvbigncmVzZXQnLCAoKSA9PiBjYih1bndyYXAoZGVmYXVsdFN0YXRlKVtwcm9wTmFtZV0pKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVuU2V0KCk7XG4gICAgICAgICAgICB1blJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB1c2UgPSAoLi4uc3Vic2NyaXB0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnMgPSBzdWJzY3JpcHRpb25zLnJlZHVjZSgodW5zdWJzLCBzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uc2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ3NldCcsIHN1YnNjcmlwdGlvbi5zZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZ2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2dldCcsIHN1YnNjcmlwdGlvbi5nZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ucmVzZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbigncmVzZXQnLCBzdWJzY3JpcHRpb24ucmVzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdkaXNwb3NlJywgc3Vic2NyaXB0aW9uLmRpc3Bvc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bnN1YnM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHVuc3Vicy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2Ioa2V5LCBvbGRWYWx1ZSwgb2xkVmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHNldCxcbiAgICAgICAgb24sXG4gICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICB1c2UsXG4gICAgICAgIGRpc3Bvc2UsXG4gICAgICAgIHJlc2V0LFxuICAgICAgICBmb3JjZVVwZGF0ZSxcbiAgICB9O1xufTtcbmNvbnN0IHJlbW92ZUZyb21BcnJheSA9IChhcnJheSwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgYXJyYXkubGVuZ3RoLS07XG4gICAgfVxufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpID0+IHtcbiAgICBjb25zdCBtYXAgPSBjcmVhdGVPYnNlcnZhYmxlTWFwKGRlZmF1bHRTdGF0ZSwgc2hvdWxkVXBkYXRlKTtcbiAgICBtYXAudXNlKHN0ZW5jaWxTdWJzY3JpcHRpb24oKSk7XG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlIGFzIGMgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYWFmMzBiZDYuanMnO1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5cbmNvbnN0IGxhbmd1YWdlTWFwID0gbmV3IE1hcChbXG4gIFtcImFyXCIsIFwiYXJcIl0sXG4gIFtcImJnXCIsIFwiYmdcIl0sXG4gIFtcImJzXCIsIFwiYnNcIl0sXG4gIFtcImNhXCIsIFwiY2FcIl0sXG4gIFtcImNzXCIsIFwiY3NcIl0sXG4gIFtcImRhXCIsIFwiZGFcIl0sXG4gIFtcImRlXCIsIFwiZGVcIl0sXG4gIFtcImVsXCIsIFwiZWxcIl0sXG4gIFtcImVuXCIsIFwiZW5cIl0sXG4gIFtcImVzXCIsIFwiZXNcIl0sXG4gIFtcImV0XCIsIFwiZXRcIl0sXG4gIFtcImZpXCIsIFwiZmlcIl0sXG4gIFtcImZyXCIsIFwiZnJcIl0sXG4gIFtcImhlXCIsIFwiaGVcIl0sXG4gIFtcImhyXCIsIFwiaHJcIl0sXG4gIFtcImh1XCIsIFwiaHVcIl0sXG4gIFtcImlkXCIsIFwiaWRcIl0sXG4gIFtcIml0XCIsIFwiaXRcIl0sXG4gIFtcImphXCIsIFwiamFcIl0sXG4gIFtcImtvXCIsIFwia29cIl0sXG4gIFtcImx0XCIsIFwibHRcIl0sXG4gIFtcImx2XCIsIFwibHZcIl0sXG4gIFtcIm5iXCIsIFwibmJcIl0sXG4gIFtcIm5sXCIsIFwibmxcIl0sXG4gIFtcInBsXCIsIFwicGxcIl0sXG4gIFtcInB0LWJyXCIsIFwicHQtQlJcIl0sXG4gIFtcInB0LXB0XCIsIFwicHQtUFRcIl0sXG4gIFtcInJvXCIsIFwicm9cIl0sXG4gIFtcInJ1XCIsIFwicnVcIl0sXG4gIFtcInNrXCIsIFwic2tcIl0sXG4gIFtcInNsXCIsIFwic2xcIl0sXG4gIFtcInNyXCIsIFwic3JcIl0sXG4gIFtcInN2XCIsIFwic3ZcIl0sXG4gIFtcInRoXCIsIFwidGhcIl0sXG4gIFtcInRyXCIsIFwidHJcIl0sXG4gIFtcInVrXCIsIFwidWtcIl0sXG4gIFtcInZpXCIsIFwidmlcIl0sXG4gIFtcInpoLWNuXCIsIFwiemgtQ05cIl0sXG4gIFtcInpoLWhrXCIsIFwiemgtSEtcIl0sXG4gIFtcInpoLXR3XCIsIFwiemgtVFdcIl1cbl0pO1xuLy8gcnRsXG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gIHJldHVybiBnZXRFbGVtZW50UHJvcChlbCwgXCJkaXJcIiwgXCJsdHJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgY2xvc2VzdFdpdGhQcm9wID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBgWyR7cHJvcH1dYCk7XG4gIHJldHVybiBjbG9zZXN0V2l0aFByb3AgPyBjbG9zZXN0V2l0aFByb3AuZ2V0QXR0cmlidXRlKHByb3ApIDogdmFsdWU7XG59XG4vLyBjc3NcbmNvbnN0IENTU19VVElMSVRZID0ge1xuICBydGw6IFwiYXJjZ2lzLS1ydGxcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhcGksIHR5cGUsIHBsYWNlcyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKGFwaSA9PT0gNCkge1xuICAgIGNvbnN0IFtpbnRsXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaW50bFwiXSk7XG4gICAgY29uc3QgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMgPSBpbnRsLmNvbnZlcnROdW1iZXJGb3JtYXRUb0ludGxPcHRpb25zKHtcbiAgICAgIHBsYWNlcyxcbiAgICAgIHN0eWxlOiB0eXBlLFxuICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gaW50bC5mb3JtYXROdW1iZXIobnVtYmVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlckZvcm1hdEludGxPcHRpb25zKSwgeyBzdHlsZTogdHlwZSB9KSk7XG4gIH1cbiAgY29uc3QgW2Rvam9OdW1iZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZG9qby9udW1iZXJcIl0pO1xuICByZXR1cm4gZG9qb051bWJlci5mb3JtYXQobnVtYmVyLCB7XG4gICAgdHlwZSxcbiAgICBwbGFjZXMsXG4gICAgcGF0dGVybjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhdHRlcm5cbiAgfSk7XG59XG5jb25zdCBjYWNoZSA9IHt9O1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIGNvbnN0IGxhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZztcbiAgY29uc3QgZGF5U2hvcnRNb250aFllYXIgPSB7XG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwic2hvcnRcIixcbiAgICBkYXk6IFwibnVtZXJpY1wiXG4gIH07XG4gIGlmICghY2FjaGVbbGFuZ10pIHtcbiAgICBjYWNoZVtsYW5nXSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nLCBkYXlTaG9ydE1vbnRoWWVhcik7XG4gIH1cbiAgcmV0dXJuIGNhY2hlW2xhbmddLmZvcm1hdChkYXRlKTtcbn1cblxuZXhwb3J0IHsgQ1NTX1VUSUxJVFkgYXMgQywgZm9ybWF0RGF0ZSBhcyBhLCBmb3JtYXROdW1iZXIgYXMgZiwgZ2V0RWxlbWVudERpciBhcyBnLCBsYW5ndWFnZU1hcCBhcyBsIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlU3RvcmUgfSBmcm9tICcuL2luZGV4LTgxZDU0OGI3LmpzJztcblxuY29uc3QgcG9wdXBTdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgbGF5ZXI6IG51bGwsXG4gIG1hcFZpZXc6IG51bGwsXG4gIHBvcnRhbDogbnVsbCxcbiAgY29uZmlnOiBudWxsLFxuICBzdHJpbmdzOiBudWxsLFxuICBjdXJyZW50TGFuZ3VhZ2U6IG51bGwsXG4gIGN1cnJlbnRMYW5ndWFnZUludGw6IG51bGwsXG4gIHNlcnZpY2VUeXBlOiBudWxsLFxuICBwb3B1cFRlbXBsYXRlOiBudWxsLFxuICBsYXllckhhc0F0dGFjaG1lbnQ6IG51bGwsXG4gIGxheWVySGFzRVQ6IG51bGwsXG4gIGxheWVySGFzQXR0cmlidXRlczogbnVsbCxcbiAgbGF5ZXJIYXNDaGFydHM6IG51bGwsXG4gIGxheWVySGFzSW1hZ2VzOiBudWxsLFxuICBsYXllckhhc1RleHQ6IG51bGwsXG4gIGxheWVyRGlzcGxheVR5cGU6IG51bGwsXG4gIHN1cHBvcnRzQXJjYWRlOiBudWxsLFxuICBsYXllckhhc1JlbGF0ZWRSZWNvcmRzOiBmYWxzZVxufSk7XG4vLyB3b3JrYXJvdW5kIGZvciBzdGFydGluZyBhIHBhbmVsIHdpdGggYSBjbGVhbiBzdGF0ZVxuZnVuY3Rpb24gY2xlYXJQb3B1cFN0YXRlKHBvcHVwU3RhdGUpIHtcbiAgcG9wdXBTdGF0ZS5sYXllciA9IG51bGw7XG4gIHBvcHVwU3RhdGUubWFwVmlldyA9IG51bGw7XG4gIHBvcHVwU3RhdGUucG9ydGFsID0gbnVsbDtcbiAgcG9wdXBTdGF0ZS5jb25maWcgPSBudWxsO1xuICBwb3B1cFN0YXRlLnN0cmluZ3MgPSBudWxsO1xuICBwb3B1cFN0YXRlLmN1cnJlbnRMYW5ndWFnZSA9IG51bGw7XG4gIHBvcHVwU3RhdGUuY3VycmVudExhbmd1YWdlSW50bCA9IG51bGw7XG4gIHBvcHVwU3RhdGUuc2VydmljZVR5cGUgPSBudWxsO1xuICBwb3B1cFN0YXRlLnBvcHVwVGVtcGxhdGUgPSBudWxsO1xuICBwb3B1cFN0YXRlLmxheWVySGFzQXR0YWNobWVudCA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJIYXNFVCA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJIYXNBdHRyaWJ1dGVzID0gbnVsbDtcbiAgcG9wdXBTdGF0ZS5sYXllckhhc0NoYXJ0cyA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJIYXNJbWFnZXMgPSBudWxsO1xuICBwb3B1cFN0YXRlLmxheWVySGFzVGV4dCA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJEaXNwbGF5VHlwZSA9IG51bGw7XG4gIHBvcHVwU3RhdGUuc3VwcG9ydHNBcmNhZGUgPSBudWxsO1xuICBwb3B1cFN0YXRlLmxheWVySGFzUmVsYXRlZFJlY29yZHMgPSBmYWxzZTtcbn1cbmNvbnN0IHBvcHVwU3RhdGUgPSBwb3B1cFN0b3JlLnN0YXRlO1xuXG5leHBvcnQgeyBjbGVhclBvcHVwU3RhdGUgYXMgYywgcG9wdXBTdGF0ZSBhcyBwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=