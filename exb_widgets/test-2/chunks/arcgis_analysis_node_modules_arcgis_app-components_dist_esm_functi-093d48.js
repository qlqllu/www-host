"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_functi-093d48"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/previewPopup-05f5d196.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/previewPopup-05f5d196.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ generateMasterFieldInfo),
/* harmony export */   p: () => (/* binding */ previewPopup)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commonEnums-f98a323c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-f98a323c.js");
/* harmony import */ var _commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-5262b094.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-5262b094.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




async function generatefieldInfo(layer, popupTemplate) {
  return new Promise((resolve, reject) => {
    (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/popup/FieldInfo"]).then(async ([FieldInfo]) => {
      var _a, _b, _c;
      const masterFieldInfo = [];
      // map original fieldinfo
      const fieldInfoMap = new Map((_a = popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.fieldInfos) === null || _a === void 0 ? void 0 : _a.map((fieldInfo) => [
        fieldInfo.fieldName,
        fieldInfo
      ]));
      // map fields from service
      const layerFieldsMap = 
      /* getServiceType(layer) !== serviceTypeEnum.imageryTile ? */ await (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_2__.d)(layer); /* : null */
      // loop over popup fieldinfo first to maintain field order, than add new fields
      if (layerFieldsMap === null || layerFieldsMap === void 0 ? void 0 : layerFieldsMap.size) {
        fieldInfoMap.forEach((fieldInfo) => {
          if (layerFieldsMap.has(fieldInfo.fieldName)) {
            masterFieldInfo.push(fieldInfo);
            // wont use layerFields anymore, so remove them here
            layerFieldsMap.delete(fieldInfo.fieldName);
          }
        });
        // remaining fields are new fields in the service
        layerFieldsMap.forEach((field) => {
          if (["geometry"].indexOf(field.type) === -1) {
            const tempFieldInfo = new FieldInfo();
            tempFieldInfo.fieldName = field.name;
            tempFieldInfo.label = field.alias;
            tempFieldInfo.visible = false;
            masterFieldInfo.push(tempFieldInfo);
          }
        });
        layerFieldsMap.clear();
      }
      // expressions
      if (popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.expressionInfos) {
        (_b = popupTemplate.expressionInfos) === null || _b === void 0 ? void 0 : _b.forEach((expression) => {
          const expressionNameWithPrefix = `${_commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.f.expression}${expression.name}`;
          if (fieldInfoMap.has(expressionNameWithPrefix)) {
            masterFieldInfo.push(fieldInfoMap.get(expressionNameWithPrefix));
          }
          else {
            const tempFieldInfo = new FieldInfo();
            tempFieldInfo.fieldName = expressionNameWithPrefix;
            tempFieldInfo.visible = false;
            masterFieldInfo.push(tempFieldInfo);
          }
        });
      }
      // relationships: todo
      (_c = popupTemplate === null || popupTemplate === void 0 ? void 0 : popupTemplate.fieldInfos) === null || _c === void 0 ? void 0 : _c.forEach((field) => {
        // raster fields get returned via generateLayerFieldsMap now
        if (field.fieldName.indexOf(_commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.f.relationship) !== -1 /*||
        field.fieldName.indexOf(fieldInfoPrefixEnum.raster) !== -1 */) {
          masterFieldInfo.push(field);
        }
      });
      resolve(masterFieldInfo);
    }, (error) => {
      reject(error);
    });
  });
}
const generateMasterFieldInfo = (layer, popupTemplate) => generatefieldInfo(layer, popupTemplate);

const previewPopup = async (mapView, layer, previewPopupController) => {
  var _a, _b;
  mapView.closePopup();
  let singleFeature = null;
  const serviceType = (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_2__.c)(layer);
  // if scene layer, check for associated FS, else do regular preview popup
  if (serviceType === _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.s.scene && !(layer === null || layer === void 0 ? void 0 : layer.associatedLayer)) {
    // to do
    // singleFeature = await getSingleSceneFeatureToDisplay(mapView, layer as __esri.SceneLayer, previewPopupController);
    return;
  }
  else {
    singleFeature = await getSingleFeatureToDisplay(mapView, layer, previewPopupController, serviceType);
  }
  if (singleFeature) {
    if ("dockEnabled" in mapView.popup) {
      mapView.popup.dockEnabled = true;
    }
    mapView.openPopup({
      features: [singleFeature],
      location: ((_b = (_a = singleFeature.geometry) === null || _a === void 0 ? void 0 : _a.extent) === null || _b === void 0 ? void 0 : _b.center) || singleFeature.geometry
    });
    return singleFeature;
  }
};
const getSingleFeatureToDisplay = async (mapView, layer, previewPopupController, serviceType) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  try {
    let currentLayer = null;
    let popupFeature;
    if (serviceType === _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.s.ogcFeature) {
      currentLayer = (await mapView.whenLayerView(layer));
      // wait for features to load, else layerview queries dont return anything
      const [reactiveUtils] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/core/reactiveUtils"]);
      await reactiveUtils.whenOnce(() => !currentLayer.updating);
    }
    else if (serviceType === _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.s.stream) {
      currentLayer = (await mapView.whenLayerView(layer));
      // wait for features to load, else layerview queries dont return anything
      const [reactiveUtils] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/core/reactiveUtils"]);
      await reactiveUtils.whenOnce(() => !currentLayer.updating);
    }
    else {
      currentLayer = layer;
    }
    // imagery tile layer cannot use query operation
    if (serviceType === _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.s.imageryTile) {
      const layerView = mapView.allLayerViews.find((view) => view.layer.id === layer.id);
      const features = await layerView.fetchPopupFeatures(layer.fullExtent.center);
      return features === null || features === void 0 ? void 0 : features[0];
    }
    // if sublayer supports identity, return the 1st feature for popup preview.
    if (serviceType === _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.s.mapImage &&
      layer.layer.version >= 10.5 &&
      !((_b = (_a = layer.layer.capabilities) === null || _a === void 0 ? void 0 : _a.operations) === null || _b === void 0 ? void 0 : _b.supportsQuery) &&
      ((_d = (_c = layer.layer.capabilities) === null || _c === void 0 ? void 0 : _c.operations) === null || _d === void 0 ? void 0 : _d.supportsIdentify)) {
      const currFeature = await (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_2__.f)(layer, mapView);
      // attaching source layer is needed for popup to display
      if (currFeature) {
        currFeature.sourceLayer = layer;
      }
      return currFeature;
    }
    const isTable = "isTable" in layer && layer.isTable;
    // query center
    const centerQueryParams = currentLayer.createQuery();
    if (!isTable) {
      centerQueryParams.geometry = mapView.center;
      centerQueryParams.distance = mapView.resolution;
    }
    centerQueryParams.outFields = ["*"];
    const featureSetCenter = await currentLayer.queryFeatures(centerQueryParams, {
      signal: previewPopupController.signal
    });
    if (((_e = featureSetCenter === null || featureSetCenter === void 0 ? void 0 : featureSetCenter.features) === null || _e === void 0 ? void 0 : _e.length) === 0) {
      // feature by extent
      const extentQueryParams = currentLayer.createQuery();
      extentQueryParams.geometry = mapView.extent;
      extentQueryParams.outFields = ["*"];
      const featureSetExtent = await currentLayer.queryFeatures(extentQueryParams, {
        signal: previewPopupController.signal
      });
      if (((_f = featureSetExtent === null || featureSetExtent === void 0 ? void 0 : featureSetExtent.features) === null || _f === void 0 ? void 0 : _f.length) > 0) {
        // get closest to center
        popupFeature = await getClosestToCenter(featureSetExtent, mapView, layer);
      }
      else {
        // get any feature
        const singleFeatureQueryParams = currentLayer.createQuery();
        singleFeatureQueryParams.where =
          currentLayer.definitionExpression || "1=1";
        singleFeatureQueryParams.outFields = ["*"];
        if (((_h = (_g = layer.sourceJSON) === null || _g === void 0 ? void 0 : _g.advancedQueryCapabilities) === null || _h === void 0 ? void 0 : _h.supportsPagination) ||
          serviceType === _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.s.ogcFeature) {
          singleFeatureQueryParams.start = 0;
          singleFeatureQueryParams.num = 1;
        }
        singleFeatureQueryParams.outSpatialReference = mapView.spatialReference;
        popupFeature = (_k = (_j = (await currentLayer.queryFeatures(singleFeatureQueryParams, { signal: previewPopupController.signal }))) === null || _j === void 0 ? void 0 : _j.features) === null || _k === void 0 ? void 0 : _k[0];
      }
    }
    else {
      popupFeature = (_l = featureSetCenter === null || featureSetCenter === void 0 ? void 0 : featureSetCenter.features) === null || _l === void 0 ? void 0 : _l[0];
    }
    if (popupFeature && serviceType === _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_1__.s.imagery) {
      popupFeature = await getSingleFeatureToDisplayForImagery(layer, popupFeature);
    }
    return popupFeature;
  }
  catch (error) {
    // abort error
    console.log(error);
  }
};
const getSingleFeatureToDisplayForImagery = async (layer, defaultGraphic) => {
  var _a;
  const query = layer.createQuery();
  // in api, "*" is a special keyword for query only. pseudo raster fields must be appended explicitly.
  // this could be revisited, e.g. introduce an additional option.
  query.outFields = ["*"].concat(layer.rasterFields.map((field) => field.name).filter((name) => name.startsWith("Raster.")));
  query.geometry = defaultGraphic.geometry;
  query.outSpatialReference = defaultGraphic.geometry.spatialReference;
  const features = await layer.queryVisibleRasters(query, {
    returnTopmostRaster: true,
    returnDomainValues: true
  });
  return (_a = features === null || features === void 0 ? void 0 : features[0]) !== null && _a !== void 0 ? _a : defaultGraphic;
};
const getClosestToCenter = async (featureSet, mapView, layer) => {
  const geometryType = await (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_2__.h)(layer);
  // point based on point distance
  if (geometryType === "point") {
    let featureAndDistance = null;
    for (let x = 0; x < featureSet.features.length; x++) {
      const pointDistance = featureSet.features[x].geometry.distance(mapView.center);
      if (x === 0 || (featureAndDistance === null || featureAndDistance === void 0 ? void 0 : featureAndDistance[1]) > pointDistance) {
        featureAndDistance = [featureSet.features[x], pointDistance];
      }
    }
    return featureAndDistance[0];
  }
  // polyline with grate
  else if (geometryType === "polyline") {
    let featureAndDistance = null;
    const [geometryEngine] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/geometry/geometryEngine"]);
    for (let x = 0; x < featureSet.features.length; x++) {
      const lineDistance = geometryEngine.nearestVertex(featureSet.features[x].geometry, mapView.center).distance;
      if (x === 0 || (featureAndDistance === null || featureAndDistance === void 0 ? void 0 : featureAndDistance[1]) > lineDistance) {
        featureAndDistance = [featureSet.features[x], lineDistance];
      }
    }
    return featureAndDistance[0];
  }
  // polygon based on centroid distance
  else if (geometryType === "polygon" || (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_2__.c)(layer) === "imagery") {
    let featureAndDistance = null;
    for (let x = 0; x < featureSet.features.length; x++) {
      const centroidDistance = featureSet.features[x].geometry.centroid.distance(mapView.center);
      if (x === 0 || (featureAndDistance === null || featureAndDistance === void 0 ? void 0 : featureAndDistance[1]) > centroidDistance) {
        featureAndDistance = [featureSet.features[x], centroidDistance];
      }
    }
    return featureAndDistance[0];
  }
  // table, any other use case, send the 1st one
  else {
    return featureSet.features[0];
  }
};
// const getSingleSceneFeatureToDisplay = async (
//   mapView: __esri.MapView,
//   layer: __esri.SceneLayer,
//   previewPopupController: AbortController
// ): Promise<__esri.Graphic> => {
//   try {
//     const layerView = await mapView.whenLayerView(layer);
//     const query = layer.createQuery();
//     query.start = 0;
//     query.num = 1;
//     query.outFields = ["*"];
//     const tempResult = await layerView.queryFeatures(query, { signal: previewPopupController.signal });
//     return tempResult.features?.[0];
//   } catch (error) {
//     // abort error
//     return null;
//   }
// };




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZnVuY3RpLTA5M2Q0OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyx1Q0FBdUM7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyREFBVztBQUM5QyxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQWM7QUFDdkQ7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsdUNBQXVDO0FBQ3hHO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUUyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTEzZTAwYTc1LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3ByZXZpZXdQb3B1cC0wNWY1ZDE5Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICByZXR1cm4gc3RhdHVzO1xuICB9XG4gIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICB9LCBkZWxheSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgY29uc3QgbG9va3VwTWFwID0ge307XG4gIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgY29uc3Qgb2JqcyA9IFtdO1xuICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTEzZjViMDBjLmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICB9XG4gIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICBsZXQgc3RyaW5ncztcbiAgdHJ5IHtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gIH1cbiAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1hYWYzMGJkNi5qcyc7XG5pbXBvcnQgeyBmIGFzIGZpZWxkSW5mb1ByZWZpeEVudW0sIHMgYXMgc2VydmljZVR5cGVFbnVtIH0gZnJvbSAnLi9jb21tb25FbnVtcy1mOThhMzIzYy5qcyc7XG5pbXBvcnQgeyBkIGFzIGdlbmVyYXRlTGF5ZXJGaWVsZHNNYXAsIGMgYXMgZ2V0U2VydmljZVR5cGUsIGYgYXMgaWRlbnRpZnlPbk1hcEltYWdlTGF5ZXIsIGggYXMgZ2V0TGF5ZXJHZW9tZXRyeVR5cGUgfSBmcm9tICcuL2NvbW1vbkZ1bmN0aW9ucy01MjYyYjA5NC5qcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlZmllbGRJbmZvKGxheWVyLCBwb3B1cFRlbXBsYXRlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbG9hZE1vZHVsZXMoW1wiZXNyaS9wb3B1cC9GaWVsZEluZm9cIl0pLnRoZW4oYXN5bmMgKFtGaWVsZEluZm9dKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGNvbnN0IG1hc3RlckZpZWxkSW5mbyA9IFtdO1xuICAgICAgLy8gbWFwIG9yaWdpbmFsIGZpZWxkaW5mb1xuICAgICAgY29uc3QgZmllbGRJbmZvTWFwID0gbmV3IE1hcCgoX2EgPSBwb3B1cFRlbXBsYXRlID09PSBudWxsIHx8IHBvcHVwVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcHVwVGVtcGxhdGUuZmllbGRJbmZvcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZmllbGRJbmZvKSA9PiBbXG4gICAgICAgIGZpZWxkSW5mby5maWVsZE5hbWUsXG4gICAgICAgIGZpZWxkSW5mb1xuICAgICAgXSkpO1xuICAgICAgLy8gbWFwIGZpZWxkcyBmcm9tIHNlcnZpY2VcbiAgICAgIGNvbnN0IGxheWVyRmllbGRzTWFwID0gXG4gICAgICAvKiBnZXRTZXJ2aWNlVHlwZShsYXllcikgIT09IHNlcnZpY2VUeXBlRW51bS5pbWFnZXJ5VGlsZSA/ICovIGF3YWl0IGdlbmVyYXRlTGF5ZXJGaWVsZHNNYXAobGF5ZXIpOyAvKiA6IG51bGwgKi9cbiAgICAgIC8vIGxvb3Agb3ZlciBwb3B1cCBmaWVsZGluZm8gZmlyc3QgdG8gbWFpbnRhaW4gZmllbGQgb3JkZXIsIHRoYW4gYWRkIG5ldyBmaWVsZHNcbiAgICAgIGlmIChsYXllckZpZWxkc01hcCA9PT0gbnVsbCB8fCBsYXllckZpZWxkc01hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJGaWVsZHNNYXAuc2l6ZSkge1xuICAgICAgICBmaWVsZEluZm9NYXAuZm9yRWFjaCgoZmllbGRJbmZvKSA9PiB7XG4gICAgICAgICAgaWYgKGxheWVyRmllbGRzTWFwLmhhcyhmaWVsZEluZm8uZmllbGROYW1lKSkge1xuICAgICAgICAgICAgbWFzdGVyRmllbGRJbmZvLnB1c2goZmllbGRJbmZvKTtcbiAgICAgICAgICAgIC8vIHdvbnQgdXNlIGxheWVyRmllbGRzIGFueW1vcmUsIHNvIHJlbW92ZSB0aGVtIGhlcmVcbiAgICAgICAgICAgIGxheWVyRmllbGRzTWFwLmRlbGV0ZShmaWVsZEluZm8uZmllbGROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW1haW5pbmcgZmllbGRzIGFyZSBuZXcgZmllbGRzIGluIHRoZSBzZXJ2aWNlXG4gICAgICAgIGxheWVyRmllbGRzTWFwLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgaWYgKFtcImdlb21ldHJ5XCJdLmluZGV4T2YoZmllbGQudHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wRmllbGRJbmZvID0gbmV3IEZpZWxkSW5mbygpO1xuICAgICAgICAgICAgdGVtcEZpZWxkSW5mby5maWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuICAgICAgICAgICAgdGVtcEZpZWxkSW5mby5sYWJlbCA9IGZpZWxkLmFsaWFzO1xuICAgICAgICAgICAgdGVtcEZpZWxkSW5mby52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBtYXN0ZXJGaWVsZEluZm8ucHVzaCh0ZW1wRmllbGRJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXllckZpZWxkc01hcC5jbGVhcigpO1xuICAgICAgfVxuICAgICAgLy8gZXhwcmVzc2lvbnNcbiAgICAgIGlmIChwb3B1cFRlbXBsYXRlID09PSBudWxsIHx8IHBvcHVwVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcHVwVGVtcGxhdGUuZXhwcmVzc2lvbkluZm9zKSB7XG4gICAgICAgIChfYiA9IHBvcHVwVGVtcGxhdGUuZXhwcmVzc2lvbkluZm9zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgoZXhwcmVzc2lvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25OYW1lV2l0aFByZWZpeCA9IGAke2ZpZWxkSW5mb1ByZWZpeEVudW0uZXhwcmVzc2lvbn0ke2V4cHJlc3Npb24ubmFtZX1gO1xuICAgICAgICAgIGlmIChmaWVsZEluZm9NYXAuaGFzKGV4cHJlc3Npb25OYW1lV2l0aFByZWZpeCkpIHtcbiAgICAgICAgICAgIG1hc3RlckZpZWxkSW5mby5wdXNoKGZpZWxkSW5mb01hcC5nZXQoZXhwcmVzc2lvbk5hbWVXaXRoUHJlZml4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGVtcEZpZWxkSW5mbyA9IG5ldyBGaWVsZEluZm8oKTtcbiAgICAgICAgICAgIHRlbXBGaWVsZEluZm8uZmllbGROYW1lID0gZXhwcmVzc2lvbk5hbWVXaXRoUHJlZml4O1xuICAgICAgICAgICAgdGVtcEZpZWxkSW5mby52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBtYXN0ZXJGaWVsZEluZm8ucHVzaCh0ZW1wRmllbGRJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gcmVsYXRpb25zaGlwczogdG9kb1xuICAgICAgKF9jID0gcG9wdXBUZW1wbGF0ZSA9PT0gbnVsbCB8fCBwb3B1cFRlbXBsYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3B1cFRlbXBsYXRlLmZpZWxkSW5mb3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAvLyByYXN0ZXIgZmllbGRzIGdldCByZXR1cm5lZCB2aWEgZ2VuZXJhdGVMYXllckZpZWxkc01hcCBub3dcbiAgICAgICAgaWYgKGZpZWxkLmZpZWxkTmFtZS5pbmRleE9mKGZpZWxkSW5mb1ByZWZpeEVudW0ucmVsYXRpb25zaGlwKSAhPT0gLTEgLyp8fFxuICAgICAgICBmaWVsZC5maWVsZE5hbWUuaW5kZXhPZihmaWVsZEluZm9QcmVmaXhFbnVtLnJhc3RlcikgIT09IC0xICovKSB7XG4gICAgICAgICAgbWFzdGVyRmllbGRJbmZvLnB1c2goZmllbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlc29sdmUobWFzdGVyRmllbGRJbmZvKTtcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xufVxuY29uc3QgZ2VuZXJhdGVNYXN0ZXJGaWVsZEluZm8gPSAobGF5ZXIsIHBvcHVwVGVtcGxhdGUpID0+IGdlbmVyYXRlZmllbGRJbmZvKGxheWVyLCBwb3B1cFRlbXBsYXRlKTtcblxuY29uc3QgcHJldmlld1BvcHVwID0gYXN5bmMgKG1hcFZpZXcsIGxheWVyLCBwcmV2aWV3UG9wdXBDb250cm9sbGVyKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIG1hcFZpZXcuY2xvc2VQb3B1cCgpO1xuICBsZXQgc2luZ2xlRmVhdHVyZSA9IG51bGw7XG4gIGNvbnN0IHNlcnZpY2VUeXBlID0gZ2V0U2VydmljZVR5cGUobGF5ZXIpO1xuICAvLyBpZiBzY2VuZSBsYXllciwgY2hlY2sgZm9yIGFzc29jaWF0ZWQgRlMsIGVsc2UgZG8gcmVndWxhciBwcmV2aWV3IHBvcHVwXG4gIGlmIChzZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLnNjZW5lICYmICEobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmFzc29jaWF0ZWRMYXllcikpIHtcbiAgICAvLyB0byBkb1xuICAgIC8vIHNpbmdsZUZlYXR1cmUgPSBhd2FpdCBnZXRTaW5nbGVTY2VuZUZlYXR1cmVUb0Rpc3BsYXkobWFwVmlldywgbGF5ZXIgYXMgX19lc3JpLlNjZW5lTGF5ZXIsIHByZXZpZXdQb3B1cENvbnRyb2xsZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBlbHNlIHtcbiAgICBzaW5nbGVGZWF0dXJlID0gYXdhaXQgZ2V0U2luZ2xlRmVhdHVyZVRvRGlzcGxheShtYXBWaWV3LCBsYXllciwgcHJldmlld1BvcHVwQ29udHJvbGxlciwgc2VydmljZVR5cGUpO1xuICB9XG4gIGlmIChzaW5nbGVGZWF0dXJlKSB7XG4gICAgaWYgKFwiZG9ja0VuYWJsZWRcIiBpbiBtYXBWaWV3LnBvcHVwKSB7XG4gICAgICBtYXBWaWV3LnBvcHVwLmRvY2tFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbWFwVmlldy5vcGVuUG9wdXAoe1xuICAgICAgZmVhdHVyZXM6IFtzaW5nbGVGZWF0dXJlXSxcbiAgICAgIGxvY2F0aW9uOiAoKF9iID0gKF9hID0gc2luZ2xlRmVhdHVyZS5nZW9tZXRyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4dGVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNlbnRlcikgfHwgc2luZ2xlRmVhdHVyZS5nZW9tZXRyeVxuICAgIH0pO1xuICAgIHJldHVybiBzaW5nbGVGZWF0dXJlO1xuICB9XG59O1xuY29uc3QgZ2V0U2luZ2xlRmVhdHVyZVRvRGlzcGxheSA9IGFzeW5jIChtYXBWaWV3LCBsYXllciwgcHJldmlld1BvcHVwQ29udHJvbGxlciwgc2VydmljZVR5cGUpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbDtcbiAgdHJ5IHtcbiAgICBsZXQgY3VycmVudExheWVyID0gbnVsbDtcbiAgICBsZXQgcG9wdXBGZWF0dXJlO1xuICAgIGlmIChzZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGVFbnVtLm9nY0ZlYXR1cmUpIHtcbiAgICAgIGN1cnJlbnRMYXllciA9IChhd2FpdCBtYXBWaWV3LndoZW5MYXllclZpZXcobGF5ZXIpKTtcbiAgICAgIC8vIHdhaXQgZm9yIGZlYXR1cmVzIHRvIGxvYWQsIGVsc2UgbGF5ZXJ2aWV3IHF1ZXJpZXMgZG9udCByZXR1cm4gYW55dGhpbmdcbiAgICAgIGNvbnN0IFtyZWFjdGl2ZVV0aWxzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvY29yZS9yZWFjdGl2ZVV0aWxzXCJdKTtcbiAgICAgIGF3YWl0IHJlYWN0aXZlVXRpbHMud2hlbk9uY2UoKCkgPT4gIWN1cnJlbnRMYXllci51cGRhdGluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlcnZpY2VUeXBlID09PSBzZXJ2aWNlVHlwZUVudW0uc3RyZWFtKSB7XG4gICAgICBjdXJyZW50TGF5ZXIgPSAoYXdhaXQgbWFwVmlldy53aGVuTGF5ZXJWaWV3KGxheWVyKSk7XG4gICAgICAvLyB3YWl0IGZvciBmZWF0dXJlcyB0byBsb2FkLCBlbHNlIGxheWVydmlldyBxdWVyaWVzIGRvbnQgcmV0dXJuIGFueXRoaW5nXG4gICAgICBjb25zdCBbcmVhY3RpdmVVdGlsc10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2NvcmUvcmVhY3RpdmVVdGlsc1wiXSk7XG4gICAgICBhd2FpdCByZWFjdGl2ZVV0aWxzLndoZW5PbmNlKCgpID0+ICFjdXJyZW50TGF5ZXIudXBkYXRpbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGN1cnJlbnRMYXllciA9IGxheWVyO1xuICAgIH1cbiAgICAvLyBpbWFnZXJ5IHRpbGUgbGF5ZXIgY2Fubm90IHVzZSBxdWVyeSBvcGVyYXRpb25cbiAgICBpZiAoc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlRW51bS5pbWFnZXJ5VGlsZSkge1xuICAgICAgY29uc3QgbGF5ZXJWaWV3ID0gbWFwVmlldy5hbGxMYXllclZpZXdzLmZpbmQoKHZpZXcpID0+IHZpZXcubGF5ZXIuaWQgPT09IGxheWVyLmlkKTtcbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gYXdhaXQgbGF5ZXJWaWV3LmZldGNoUG9wdXBGZWF0dXJlcyhsYXllci5mdWxsRXh0ZW50LmNlbnRlcik7XG4gICAgICByZXR1cm4gZmVhdHVyZXMgPT09IG51bGwgfHwgZmVhdHVyZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlYXR1cmVzWzBdO1xuICAgIH1cbiAgICAvLyBpZiBzdWJsYXllciBzdXBwb3J0cyBpZGVudGl0eSwgcmV0dXJuIHRoZSAxc3QgZmVhdHVyZSBmb3IgcG9wdXAgcHJldmlldy5cbiAgICBpZiAoc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlRW51bS5tYXBJbWFnZSAmJlxuICAgICAgbGF5ZXIubGF5ZXIudmVyc2lvbiA+PSAxMC41ICYmXG4gICAgICAhKChfYiA9IChfYSA9IGxheWVyLmxheWVyLmNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZXJhdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdXBwb3J0c1F1ZXJ5KSAmJlxuICAgICAgKChfZCA9IChfYyA9IGxheWVyLmxheWVyLmNhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm9wZXJhdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zdXBwb3J0c0lkZW50aWZ5KSkge1xuICAgICAgY29uc3QgY3VyckZlYXR1cmUgPSBhd2FpdCBpZGVudGlmeU9uTWFwSW1hZ2VMYXllcihsYXllciwgbWFwVmlldyk7XG4gICAgICAvLyBhdHRhY2hpbmcgc291cmNlIGxheWVyIGlzIG5lZWRlZCBmb3IgcG9wdXAgdG8gZGlzcGxheVxuICAgICAgaWYgKGN1cnJGZWF0dXJlKSB7XG4gICAgICAgIGN1cnJGZWF0dXJlLnNvdXJjZUxheWVyID0gbGF5ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyckZlYXR1cmU7XG4gICAgfVxuICAgIGNvbnN0IGlzVGFibGUgPSBcImlzVGFibGVcIiBpbiBsYXllciAmJiBsYXllci5pc1RhYmxlO1xuICAgIC8vIHF1ZXJ5IGNlbnRlclxuICAgIGNvbnN0IGNlbnRlclF1ZXJ5UGFyYW1zID0gY3VycmVudExheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgaWYgKCFpc1RhYmxlKSB7XG4gICAgICBjZW50ZXJRdWVyeVBhcmFtcy5nZW9tZXRyeSA9IG1hcFZpZXcuY2VudGVyO1xuICAgICAgY2VudGVyUXVlcnlQYXJhbXMuZGlzdGFuY2UgPSBtYXBWaWV3LnJlc29sdXRpb247XG4gICAgfVxuICAgIGNlbnRlclF1ZXJ5UGFyYW1zLm91dEZpZWxkcyA9IFtcIipcIl07XG4gICAgY29uc3QgZmVhdHVyZVNldENlbnRlciA9IGF3YWl0IGN1cnJlbnRMYXllci5xdWVyeUZlYXR1cmVzKGNlbnRlclF1ZXJ5UGFyYW1zLCB7XG4gICAgICBzaWduYWw6IHByZXZpZXdQb3B1cENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKCgoX2UgPSBmZWF0dXJlU2V0Q2VudGVyID09PSBudWxsIHx8IGZlYXR1cmVTZXRDZW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlYXR1cmVTZXRDZW50ZXIuZmVhdHVyZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5sZW5ndGgpID09PSAwKSB7XG4gICAgICAvLyBmZWF0dXJlIGJ5IGV4dGVudFxuICAgICAgY29uc3QgZXh0ZW50UXVlcnlQYXJhbXMgPSBjdXJyZW50TGF5ZXIuY3JlYXRlUXVlcnkoKTtcbiAgICAgIGV4dGVudFF1ZXJ5UGFyYW1zLmdlb21ldHJ5ID0gbWFwVmlldy5leHRlbnQ7XG4gICAgICBleHRlbnRRdWVyeVBhcmFtcy5vdXRGaWVsZHMgPSBbXCIqXCJdO1xuICAgICAgY29uc3QgZmVhdHVyZVNldEV4dGVudCA9IGF3YWl0IGN1cnJlbnRMYXllci5xdWVyeUZlYXR1cmVzKGV4dGVudFF1ZXJ5UGFyYW1zLCB7XG4gICAgICAgIHNpZ25hbDogcHJldmlld1BvcHVwQ29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgaWYgKCgoX2YgPSBmZWF0dXJlU2V0RXh0ZW50ID09PSBudWxsIHx8IGZlYXR1cmVTZXRFeHRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlYXR1cmVTZXRFeHRlbnQuZmVhdHVyZXMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5sZW5ndGgpID4gMCkge1xuICAgICAgICAvLyBnZXQgY2xvc2VzdCB0byBjZW50ZXJcbiAgICAgICAgcG9wdXBGZWF0dXJlID0gYXdhaXQgZ2V0Q2xvc2VzdFRvQ2VudGVyKGZlYXR1cmVTZXRFeHRlbnQsIG1hcFZpZXcsIGxheWVyKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBnZXQgYW55IGZlYXR1cmVcbiAgICAgICAgY29uc3Qgc2luZ2xlRmVhdHVyZVF1ZXJ5UGFyYW1zID0gY3VycmVudExheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgICAgIHNpbmdsZUZlYXR1cmVRdWVyeVBhcmFtcy53aGVyZSA9XG4gICAgICAgICAgY3VycmVudExheWVyLmRlZmluaXRpb25FeHByZXNzaW9uIHx8IFwiMT0xXCI7XG4gICAgICAgIHNpbmdsZUZlYXR1cmVRdWVyeVBhcmFtcy5vdXRGaWVsZHMgPSBbXCIqXCJdO1xuICAgICAgICBpZiAoKChfaCA9IChfZyA9IGxheWVyLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hZHZhbmNlZFF1ZXJ5Q2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc3VwcG9ydHNQYWdpbmF0aW9uKSB8fFxuICAgICAgICAgIHNlcnZpY2VUeXBlID09PSBzZXJ2aWNlVHlwZUVudW0ub2djRmVhdHVyZSkge1xuICAgICAgICAgIHNpbmdsZUZlYXR1cmVRdWVyeVBhcmFtcy5zdGFydCA9IDA7XG4gICAgICAgICAgc2luZ2xlRmVhdHVyZVF1ZXJ5UGFyYW1zLm51bSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgc2luZ2xlRmVhdHVyZVF1ZXJ5UGFyYW1zLm91dFNwYXRpYWxSZWZlcmVuY2UgPSBtYXBWaWV3LnNwYXRpYWxSZWZlcmVuY2U7XG4gICAgICAgIHBvcHVwRmVhdHVyZSA9IChfayA9IChfaiA9IChhd2FpdCBjdXJyZW50TGF5ZXIucXVlcnlGZWF0dXJlcyhzaW5nbGVGZWF0dXJlUXVlcnlQYXJhbXMsIHsgc2lnbmFsOiBwcmV2aWV3UG9wdXBDb250cm9sbGVyLnNpZ25hbCB9KSkpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5mZWF0dXJlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBvcHVwRmVhdHVyZSA9IChfbCA9IGZlYXR1cmVTZXRDZW50ZXIgPT09IG51bGwgfHwgZmVhdHVyZVNldENlbnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVhdHVyZVNldENlbnRlci5mZWF0dXJlcykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sWzBdO1xuICAgIH1cbiAgICBpZiAocG9wdXBGZWF0dXJlICYmIHNlcnZpY2VUeXBlID09PSBzZXJ2aWNlVHlwZUVudW0uaW1hZ2VyeSkge1xuICAgICAgcG9wdXBGZWF0dXJlID0gYXdhaXQgZ2V0U2luZ2xlRmVhdHVyZVRvRGlzcGxheUZvckltYWdlcnkobGF5ZXIsIHBvcHVwRmVhdHVyZSk7XG4gICAgfVxuICAgIHJldHVybiBwb3B1cEZlYXR1cmU7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gYWJvcnQgZXJyb3JcbiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gIH1cbn07XG5jb25zdCBnZXRTaW5nbGVGZWF0dXJlVG9EaXNwbGF5Rm9ySW1hZ2VyeSA9IGFzeW5jIChsYXllciwgZGVmYXVsdEdyYXBoaWMpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gIC8vIGluIGFwaSwgXCIqXCIgaXMgYSBzcGVjaWFsIGtleXdvcmQgZm9yIHF1ZXJ5IG9ubHkuIHBzZXVkbyByYXN0ZXIgZmllbGRzIG11c3QgYmUgYXBwZW5kZWQgZXhwbGljaXRseS5cbiAgLy8gdGhpcyBjb3VsZCBiZSByZXZpc2l0ZWQsIGUuZy4gaW50cm9kdWNlIGFuIGFkZGl0aW9uYWwgb3B0aW9uLlxuICBxdWVyeS5vdXRGaWVsZHMgPSBbXCIqXCJdLmNvbmNhdChsYXllci5yYXN0ZXJGaWVsZHMubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSkuZmlsdGVyKChuYW1lKSA9PiBuYW1lLnN0YXJ0c1dpdGgoXCJSYXN0ZXIuXCIpKSk7XG4gIHF1ZXJ5Lmdlb21ldHJ5ID0gZGVmYXVsdEdyYXBoaWMuZ2VvbWV0cnk7XG4gIHF1ZXJ5Lm91dFNwYXRpYWxSZWZlcmVuY2UgPSBkZWZhdWx0R3JhcGhpYy5nZW9tZXRyeS5zcGF0aWFsUmVmZXJlbmNlO1xuICBjb25zdCBmZWF0dXJlcyA9IGF3YWl0IGxheWVyLnF1ZXJ5VmlzaWJsZVJhc3RlcnMocXVlcnksIHtcbiAgICByZXR1cm5Ub3Btb3N0UmFzdGVyOiB0cnVlLFxuICAgIHJldHVybkRvbWFpblZhbHVlczogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIChfYSA9IGZlYXR1cmVzID09PSBudWxsIHx8IGZlYXR1cmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlc1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdEdyYXBoaWM7XG59O1xuY29uc3QgZ2V0Q2xvc2VzdFRvQ2VudGVyID0gYXN5bmMgKGZlYXR1cmVTZXQsIG1hcFZpZXcsIGxheWVyKSA9PiB7XG4gIGNvbnN0IGdlb21ldHJ5VHlwZSA9IGF3YWl0IGdldExheWVyR2VvbWV0cnlUeXBlKGxheWVyKTtcbiAgLy8gcG9pbnQgYmFzZWQgb24gcG9pbnQgZGlzdGFuY2VcbiAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gXCJwb2ludFwiKSB7XG4gICAgbGV0IGZlYXR1cmVBbmREaXN0YW5jZSA9IG51bGw7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBmZWF0dXJlU2V0LmZlYXR1cmVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICBjb25zdCBwb2ludERpc3RhbmNlID0gZmVhdHVyZVNldC5mZWF0dXJlc1t4XS5nZW9tZXRyeS5kaXN0YW5jZShtYXBWaWV3LmNlbnRlcik7XG4gICAgICBpZiAoeCA9PT0gMCB8fCAoZmVhdHVyZUFuZERpc3RhbmNlID09PSBudWxsIHx8IGZlYXR1cmVBbmREaXN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVhdHVyZUFuZERpc3RhbmNlWzFdKSA+IHBvaW50RGlzdGFuY2UpIHtcbiAgICAgICAgZmVhdHVyZUFuZERpc3RhbmNlID0gW2ZlYXR1cmVTZXQuZmVhdHVyZXNbeF0sIHBvaW50RGlzdGFuY2VdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZUFuZERpc3RhbmNlWzBdO1xuICB9XG4gIC8vIHBvbHlsaW5lIHdpdGggZ3JhdGVcbiAgZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09PSBcInBvbHlsaW5lXCIpIHtcbiAgICBsZXQgZmVhdHVyZUFuZERpc3RhbmNlID0gbnVsbDtcbiAgICBjb25zdCBbZ2VvbWV0cnlFbmdpbmVdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9nZW9tZXRyeS9nZW9tZXRyeUVuZ2luZVwiXSk7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBmZWF0dXJlU2V0LmZlYXR1cmVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICBjb25zdCBsaW5lRGlzdGFuY2UgPSBnZW9tZXRyeUVuZ2luZS5uZWFyZXN0VmVydGV4KGZlYXR1cmVTZXQuZmVhdHVyZXNbeF0uZ2VvbWV0cnksIG1hcFZpZXcuY2VudGVyKS5kaXN0YW5jZTtcbiAgICAgIGlmICh4ID09PSAwIHx8IChmZWF0dXJlQW5kRGlzdGFuY2UgPT09IG51bGwgfHwgZmVhdHVyZUFuZERpc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0dXJlQW5kRGlzdGFuY2VbMV0pID4gbGluZURpc3RhbmNlKSB7XG4gICAgICAgIGZlYXR1cmVBbmREaXN0YW5jZSA9IFtmZWF0dXJlU2V0LmZlYXR1cmVzW3hdLCBsaW5lRGlzdGFuY2VdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZUFuZERpc3RhbmNlWzBdO1xuICB9XG4gIC8vIHBvbHlnb24gYmFzZWQgb24gY2VudHJvaWQgZGlzdGFuY2VcbiAgZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09PSBcInBvbHlnb25cIiB8fCBnZXRTZXJ2aWNlVHlwZShsYXllcikgPT09IFwiaW1hZ2VyeVwiKSB7XG4gICAgbGV0IGZlYXR1cmVBbmREaXN0YW5jZSA9IG51bGw7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBmZWF0dXJlU2V0LmZlYXR1cmVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICBjb25zdCBjZW50cm9pZERpc3RhbmNlID0gZmVhdHVyZVNldC5mZWF0dXJlc1t4XS5nZW9tZXRyeS5jZW50cm9pZC5kaXN0YW5jZShtYXBWaWV3LmNlbnRlcik7XG4gICAgICBpZiAoeCA9PT0gMCB8fCAoZmVhdHVyZUFuZERpc3RhbmNlID09PSBudWxsIHx8IGZlYXR1cmVBbmREaXN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVhdHVyZUFuZERpc3RhbmNlWzFdKSA+IGNlbnRyb2lkRGlzdGFuY2UpIHtcbiAgICAgICAgZmVhdHVyZUFuZERpc3RhbmNlID0gW2ZlYXR1cmVTZXQuZmVhdHVyZXNbeF0sIGNlbnRyb2lkRGlzdGFuY2VdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZUFuZERpc3RhbmNlWzBdO1xuICB9XG4gIC8vIHRhYmxlLCBhbnkgb3RoZXIgdXNlIGNhc2UsIHNlbmQgdGhlIDFzdCBvbmVcbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZlYXR1cmVTZXQuZmVhdHVyZXNbMF07XG4gIH1cbn07XG4vLyBjb25zdCBnZXRTaW5nbGVTY2VuZUZlYXR1cmVUb0Rpc3BsYXkgPSBhc3luYyAoXG4vLyAgIG1hcFZpZXc6IF9fZXNyaS5NYXBWaWV3LFxuLy8gICBsYXllcjogX19lc3JpLlNjZW5lTGF5ZXIsXG4vLyAgIHByZXZpZXdQb3B1cENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlclxuLy8gKTogUHJvbWlzZTxfX2VzcmkuR3JhcGhpYz4gPT4ge1xuLy8gICB0cnkge1xuLy8gICAgIGNvbnN0IGxheWVyVmlldyA9IGF3YWl0IG1hcFZpZXcud2hlbkxheWVyVmlldyhsYXllcik7XG4vLyAgICAgY29uc3QgcXVlcnkgPSBsYXllci5jcmVhdGVRdWVyeSgpO1xuLy8gICAgIHF1ZXJ5LnN0YXJ0ID0gMDtcbi8vICAgICBxdWVyeS5udW0gPSAxO1xuLy8gICAgIHF1ZXJ5Lm91dEZpZWxkcyA9IFtcIipcIl07XG4vLyAgICAgY29uc3QgdGVtcFJlc3VsdCA9IGF3YWl0IGxheWVyVmlldy5xdWVyeUZlYXR1cmVzKHF1ZXJ5LCB7IHNpZ25hbDogcHJldmlld1BvcHVwQ29udHJvbGxlci5zaWduYWwgfSk7XG4vLyAgICAgcmV0dXJuIHRlbXBSZXN1bHQuZmVhdHVyZXM/LlswXTtcbi8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbi8vICAgICAvLyBhYm9ydCBlcnJvclxuLy8gICAgIHJldHVybiBudWxsO1xuLy8gICB9XG4vLyB9O1xuXG5leHBvcnQgeyBnZW5lcmF0ZU1hc3RlckZpZWxkSW5mbyBhcyBnLCBwcmV2aWV3UG9wdXAgYXMgcCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9