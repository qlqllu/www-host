"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-d99497"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-symbol-styler.entry.js":
/*!***********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-symbol-styler.entry.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_symbol_styler: () => (/* binding */ ArcGISSymbolStyler)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorRampUtils-7e6d2ad8.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorRampUtils-7e6d2ad8.js");
/* harmony import */ var _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color-776689e9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/color-776689e9.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */









function equal(rampStops1, rampStops2, matchAlpha = false, reverse = true) {
  if (!rampStops1 || !rampStops2) {
    return false;
  }
  const equalMatch = rampStops1.every((color1, index) => {
    const color2 = rampStops2[index];
    return (color1.r === color2.r && color1.g === color2.g && color1.b === color2.b && (!matchAlpha || color1.a === color2.a));
  });
  if (!reverse) {
    return equalMatch;
  }
  return equalMatch || equal(rampStops1.slice().reverse(), rampStops2, matchAlpha, false);
}

function cimSymbolWalker(symbol, onVisit) {
  return visit(symbol, onVisit);
}
function visit(node, onVisit) {
  if (Array.isArray(node)) {
    for (let i = 0; i < node.length; i++) {
      const child = node[i];
      const result = visit(child, onVisit);
      if (result !== undefined) {
        return result;
      }
    }
    return;
  }
  const result = onVisit(node);
  if (result !== undefined) {
    return result;
  }
  if (node.type === "cim") {
    return visit(node.data.symbol, onVisit);
  }
  if (node.type === "CIMSymbolReference" || node.type === "CIMMarkerGraphic") {
    return visit(node.symbol, onVisit);
  }
  if (node.type === "CIMPointSymbol" || node.type === "CIMPolygonSymbol" || node.type === "CIMLineSymbol") {
    return visit(node.symbolLayers, onVisit);
  }
  if (node.type === "CIMHatchFill") {
    return visit(node.lineSymbol, onVisit);
  }
  if (node.type === "CIMVectorMarker") {
    return visit(node.markerGraphics, onVisit);
  }
  if (node.type === "CIMPictureMarker" ||
    node.type === "CIMTextSymbol" ||
    node.type === "CIMGradientFill" ||
    node.type === "CIMGradientStroke" ||
    node.type === "CIMObjectMarker3D" ||
    node.type === "CIMCharacterMarker" ||
    node.type === "CIMMaterialSymbolLayer" ||
    node.type === "CIMPictureStroke" ||
    node.type === "CIMPictureFill" ||
    node.type === "CIMSolidFill" ||
    node.type === "CIMSolidStroke") {
    /* end of the line â€“ intentional no-op */
    return;
  }
}
function updateSymbolLayerColor(symbolLayer, color, context) {
  const colorJSON = color.toJSON();
  cimSymbolWalker(symbolLayer, (node) => {
    if (context === "fill") {
      if (node.type === "CIMSolidFill") {
        node.color = colorJSON;
      }
      if (node.type === "CIMPictureFill" || node.type === "CIMPictureMarker") {
        node.tintColor = colorJSON;
      }
    }
    if (context === "stroke") {
      if (node.type === "CIMSolidStroke") {
        node.color = colorJSON;
      }
      if (node.type === "CIMPictureStroke") {
        node.tintColor = colorJSON;
      }
    }
  });
}
function getChildSymbolLayerColorContext(symbolLayer) {
  const observedTypes = new Set();
  observedTypes.add(cimSymbolWalker(symbolLayer, (node) => {
    if (node.type === "CIMSolidFill" ||
      node.type === "CIMHatchFill" ||
      node.type === "CIMPictureFill" ||
      node.type === "CIMPictureMarker") {
      return "fill";
    }
  }));
  observedTypes.add(cimSymbolWalker(symbolLayer, (node) => {
    if (node.type === "CIMSolidStroke" || node.type === "CIMPictureStroke") {
      return "stroke";
    }
  }));
  return Array.from(observedTypes).filter(Boolean);
}
function getVectorMarkerColor(vectorMarkerSymbolLayer, context) {
  const colorJSON = cimSymbolWalker(vectorMarkerSymbolLayer, (node) => {
    if (context === "fill") {
      if (node.type === "CIMSolidFill") {
        return node.color;
      }
      if (node.type === "CIMPictureFill" || node.type === "CIMPictureMarker") {
        return node.tintColor;
      }
    }
    if (context === "stroke") {
      if (node.type === "CIMSolidStroke") {
        return node.color;
      }
      if (node.type === "CIMPictureStroke") {
        return node.tintColor;
      }
    }
  });
  return _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.Color.fromJSON(colorJSON);
}
function getVectorMarkerSize(vectorMarkerSymbolLayer, context) {
  let size = 0;
  cimSymbolWalker(vectorMarkerSymbolLayer, (node) => {
    if (context === "fill") {
      if (node.type === "CIMVectorMarker" || node.type === "CIMPictureMarker") {
        if (node.size > size) {
          size = node.size;
        }
      }
    }
    if (context === "stroke") {
      if (node.type === "CIMSolidStroke" || node.type === "CIMPictureStroke") {
        if (node.width > size) {
          size = node.width;
        }
      }
    }
  });
  return size;
}
function updateSymbolLayerSize(symbolLayer, size, context) {
  cimSymbolWalker(symbolLayer, (node) => {
    if (context === "fill") {
      if (node.type === "CIMVectorMarker" || node.type === "CIMPictureMarker") {
        node.size = size;
      }
    }
    if (context === "stroke") {
      if (node.type === "CIMSolidStroke" || node.type === "CIMPictureStroke") {
        node.width = size;
      }
    }
  });
}
function getCIMStrokeWidthBounds() {
  // width should always use minWidthInPx/maxWidthInPx
  // except for CIMPictureStroke there we treat them as marker sizes with sizeMin/sizeMax
  return { min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.m, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.a };
}
function validateEditable(symbol) {
  if (!symbol) {
    return "missing symbol to edit";
  }
  if (symbol.type === "text" || symbol.type === "picture-fill") {
    return `editing symbol of type ${symbol.type} is not supported`;
  }
}
function adjustTransparencyIfNeeded(previous, next) {
  if (previous.a === 0) {
    next.a = 1;
  }
  return next;
}
function supportsFill(symbol) {
  return (((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) && (isMVCompatible(symbol) || isFillOnlyCIM(symbol))) ||
    ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) && !isLineOnlySymbol(symbol)) ||
    (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol));
}
function supportsStroke(symbol) {
  return (((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) && isMVCompatible(symbol)) || (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) || (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.c)(symbol) || (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol));
}
function isLineOnlySymbol(symbol) {
  return !!((symbol === null || symbol === void 0 ? void 0 : symbol.type) === "simple-marker" && (symbol.style === "x" || symbol.style === "cross"));
}
function normalizeSizeProp(payloadWithSizeProp, newSize = payloadWithSizeProp.size) {
  return Object.assign(Object.assign({}, payloadWithSizeProp), { size: normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(newSize)) });
}
function normalizePxOrPt(pxOrPt) {
  const fractionDigits = Number.isInteger(pxOrPt) ? 0 : 2;
  return Number(pxOrPt.toFixed(fractionDigits));
}
function normalizePx(pxOrPt) {
  const fractionDigits = Number.isInteger(pxOrPt) ? 0 : 2;
  return Number(pxOrPt.toFixed(fractionDigits));
}
function normalizePt(pxOrPt) {
  const fractionDigits = Number.isInteger(pxOrPt) ? 0 : 3;
  return Number(pxOrPt.toFixed(fractionDigits));
}
function parseSize(size, fallback) {
  return !isNaN(size) ? normalizePxOrPt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(size)) : fallback;
}
function getSymbolRotation(symbol) {
  var _a;
  if (!symbol || symbol.type === "simple-line" || symbol.type === "simple-fill") {
    return 0;
  }
  return (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) ? _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolRotation(symbol, true) : (_a = symbol.angle) !== null && _a !== void 0 ? _a : 0;
}
function isCIMTextSymbol(symbol) {
  return symbol.type === "CIMTextSymbol";
}
function isMVCompatible(symbol) {
  if (isCIMTextSymbol(symbol.data.symbol)) {
    return false;
  }
  const { symbolLayers } = symbol.data.symbol;
  if (symbolLayers.length === 1) {
    const [first] = symbolLayers;
    if (first.type !== "CIMVectorMarker" || first.colorLocked) {
      return false;
    }
    const { markerGraphics } = first;
    return (markerGraphics.length === 1 &&
      !isCIMTextSymbol(markerGraphics[0].symbol) &&
      hasUnlockedFillAndStroke(markerGraphics[0].symbol.symbolLayers));
  }
  if (symbolLayers.length === 2) {
    const [first, second] = symbolLayers;
    if (first.type !== "CIMVectorMarker" ||
      second.type !== "CIMVectorMarker" ||
      first.colorLocked ||
      first.size > second.size) {
      return false;
    }
    const firstMarkerGraphics = first.markerGraphics;
    const secondMarkerGraphics = second.markerGraphics;
    if (firstMarkerGraphics.length !== 1 || secondMarkerGraphics.length !== 1) {
      return false;
    }
    const [{ symbol: firstMarkerGraphicSymbol }] = firstMarkerGraphics;
    const [{ symbol: secondMarkerGraphicSymbol }] = secondMarkerGraphics;
    return (firstMarkerGraphicSymbol &&
      secondMarkerGraphicSymbol &&
      !isCIMTextSymbol(firstMarkerGraphicSymbol) &&
      !isCIMTextSymbol(secondMarkerGraphicSymbol) &&
      hasUnlockedFillAndStroke(firstMarkerGraphicSymbol.symbolLayers) &&
      hasFillAndStroke(secondMarkerGraphicSymbol.symbolLayers));
  }
  return false;
}
function isFillOnlyCIM(symbol) {
  return !!_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolColor(symbol);
}
function hasUnlockedFillAndStroke(symbolLayers) {
  return hasUnlockedFill(symbolLayers) && hasStroke(symbolLayers);
}
function hasFillAndStroke(symbolLayers) {
  return hasFill(symbolLayers) && hasStroke(symbolLayers);
}
function hasFill(symbolLayers) {
  return !!(symbolLayers === null || symbolLayers === void 0 ? void 0 : symbolLayers.find(({ type }) => type === "CIMSolidFill"));
}
function hasUnlockedFill(symbolLayers) {
  return !!getUnlockedFill(symbolLayers);
}
function getUnlockedFill(symbolLayers) {
  return symbolLayers === null || symbolLayers === void 0 ? void 0 : symbolLayers.find(({ type, colorLocked }) => type === "CIMSolidFill" && !colorLocked);
}
function hasStroke(symbolLayers) {
  return !!getStroke(symbolLayers);
}
function getStroke(symbolLayers) {
  return symbolLayers === null || symbolLayers === void 0 ? void 0 : symbolLayers.find(({ type }) => type === "CIMSolidStroke");
}
function supportsOutlineWidth(symbol) {
  var _a;
  // CIM must have a stroke
  const hasStroke = (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.find(({ type }) => ["CIMSolidStroke", "CIMPictureStroke"].indexOf(type) > -1);
  return !!hasStroke;
}
function getOutlineWidth(symbol) {
  var _a, _b;
  // just take first stroke
  const stroke = (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.find((symbolLayer) => ["CIMSolidStroke", "CIMPictureStroke"].indexOf(symbolLayer.type) > -1);
  return (_b = stroke.width) !== null && _b !== void 0 ? _b : 0;
}
function setOutlineWidth(symbol, width) {
  var _a;
  // don't use scaleCIMSymbolTo() because it also scales markers, separation, ... of the CIM
  // apply width to all strokes inside the CIM
  (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.forEach((symbolLayer) => {
    if (["CIMSolidStroke", "CIMPictureStroke"].indexOf(symbolLayer.type) > -1) {
      symbolLayer.width = width;
    }
  });
}
function isArrowMarker(marker) {
  return _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.s.includes(marker === null || marker === void 0 ? void 0 : marker.placement) && (marker === null || marker === void 0 ? void 0 : marker.style) === "arrow";
}
function toArrowPlacement(marker) {
  if (!marker) {
    return "none";
  }
  return isArrowMarker(marker) ? marker.placement : "none";
}
function toArrowMarker(placement) {
  if (placement === "none") {
    return undefined;
  }
  return {
    style: "arrow",
    placement
  };
}
function getStateColorRamps(section, strokeOrFillProps) {
  if (section && strokeOrFillProps && has2DColorRamp(section)) {
    const rotationsToMatch = getRotationsToMatchSelected(strokeOrFillProps.color, section.colorRamps);
    if (rotationsToMatch > 0) {
      return section.colorRamps.map((ramp) => {
        const rampClone = Object.assign({}, ramp);
        for (let i = 0; i < rotationsToMatch; i++) {
          rampClone.stops = (0,_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.f)(rampClone.stops, true);
        }
        return rampClone;
      });
    }
  }
  return section === null || section === void 0 ? void 0 : section.colorRamps;
}
function has2DColorRamp(section) {
  return (section === null || section === void 0 ? void 0 : section.type) === "color-ramp" && section.style === "2d";
}
function getRotationsToMatchSelected(selected, colorRamps) {
  const options = colorRamps.map((ramp) => ramp.stops);
  const maxRotations = 4;
  let selectedClone = selected.map((color) => color.clone());
  let totalRotationsOnSelected = 0;
  let matched = false;
  for (let i = 0; i < maxRotations; i++) {
    const match = options.some((option) => equal(selectedClone, option, true, false));
    if (match) {
      matched = true;
      break;
    }
    selectedClone = (0,_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.f)(selectedClone, true);
    totalRotationsOnSelected++;
  }
  return matched ? (maxRotations - totalRotationsOnSelected) % maxRotations : null;
}
function capitalize(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
}
function getSymbolLabel(symbol, strings) {
  if (!symbol) {
    return null;
  }
  if (symbol.type === "picture-marker" || symbol.type === "simple-marker") {
    return strings.basicPoint;
  }
  if (symbol.type === "simple-line") {
    return strings.basicLine;
  }
  if (symbol.type === "simple-fill") {
    return strings.basicPolygon;
  }
  if (symbol.data.symbol.type === "CIMPointSymbol") {
    return strings.vectorPoint;
  }
  if (symbol.data.symbol.type === "CIMLineSymbol") {
    return strings.vectorLine;
  }
  if (symbol.data.symbol.type === "CIMPolygonSymbol") {
    return strings.vectorPolygon;
  }
  throw new Error("unsupported symbol provided");
}

const SelectCSS = {
  base: "select-number",
  input: "select-number__input"
};
const stepperClickHandlerForProperFocus = (event) => {
  // workaround for calcite-label wrapped SelectNumber focus bug
  event.stopPropagation();
};
const SelectNumber = (props) => {
  const { disabled, flipLabels = false, min, max, step, unitsLabel, value, withSteppers = true, label } = props;
  return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: SelectCSS.base },
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: disabled, min: min, max: max, value: value, step: step, onCalciteSliderInput: (event) => applyValueOnChange(event.target, props) }),
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { class: SelectCSS.input, disabled: disabled, max: max, min: min, numberButtonType: withSteppers ? "vertical" : "none", prefixText: flipLabels ? unitsLabel : "", onCalciteInputInput: (event) => applyValueOnChange(event.target, props), onClick: stepperClickHandlerForProperFocus, scale: "s", step: "any", suffixText: flipLabels ? "" : unitsLabel, type: "number", value: value.toString(), label: label })));
};
const applyValueOnChange = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_3__.d)((node, props) => {
  debouncedApplyValueOnChange(node, props);
}, 800);
function debouncedApplyValueOnChange(node, props) {
  const value = Number(node.value);
  const clamped = Math.min(props.max, Math.max(props.min, value));
  if (value === props.value) {
    return;
  }
  node.value = `${clamped}`; // ensure value is within allowed range
  props.onValueChange(clamped);
}

const arcgisSymbolStylerCss = ".select-number{display:flex;align-items:center;justify-content:space-between;position:relative}.select-number calcite-slider{width:50%}.select-number__input{width:45%;font-size:var(--arcgis-app-font-size-0);font-family:var(--arcgis-app-font-family)}button{overflow:hidden;background-color:var(--arcgis-symbol-styler-inline-input-trigger-background-color);align-items:center;border:none;border-radius:0;box-sizing:border-box;cursor:pointer;display:flex;font-family:inherit;gap:8px;height:100%;justify-content:center;outline-color:transparent;outline-offset:0;padding:3px 0;padding-inline:3px 8px;position:relative;text-decoration:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;text-align:center;-webkit-appearance:none;width:100%}button:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:2px}button:hover{text-decoration:none}:host{min-width:240px;height:-moz-min-content;height:min-content;display:flex;flex:1 1 auto;flex-flow:column nowrap;align-items:stretch}calcite-dropdown{width:100%}calcite-flow{height:100%}.color-locked-info{display:flex;gap:4px;margin:8px 0;align-items:center}.color-locked-info calcite-icon{color:var(--calcite-ui-text-3)}.icon-dropdown{padding:0.25rem 0 0 0;width:100%;background-color:var(--arcgis-app-background);height:2.25rem;border:1px solid #a9a9a9;box-shadow:inset 0 1px 2px rgba(0, 0, 0, 0.075)}.icon-dropdown--selected{cursor:pointer;margin-left:12px;height:3px;width:100%}.icon-dropdown .icon-dropdown-item-content,.icon-dropdown--selected{background-position:center;background-clip:content-box;background-origin:content-box;padding-left:0;padding-right:0}.icon-dropdown .icon-dropdown-item-content{height:30px;width:200px}.arcgis--rtl .icon-dropdown--selected{margin-right:12px}.style-dropdown [slot=trigger]{width:100%;display:flex;justify-content:space-between;align-items:center}.style-dropdown [slot=trigger] calcite-icon{margin:8px;background-color:#fff}.style-dropdown [slot=trigger],.style-dropdown .icon-dropdown-item-content{background-repeat:repeat-x}.arrow-dropdown [slot=trigger]{width:100%;display:flex;justify-content:space-between;align-items:center}.arrow-dropdown [slot=trigger] .icon-dropdown--selected{height:30px;background-size:100% 119px}.arrow-dropdown [slot=trigger] calcite-icon{margin:8px;background-color:#fff}.arrow-dropdown [slot=trigger] .icon-dropdown--selected,.arrow-dropdown .icon-dropdown-item-content{background-repeat:no-repeat}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=none],.arrow-dropdown .icon-dropdown-item-content[data-arrow=none]{background-position:0 0}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=begin],.arrow-dropdown .icon-dropdown-item-content[data-arrow=begin]{background-position:0 -32px}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=end],.arrow-dropdown .icon-dropdown-item-content[data-arrow=end]{background-position:0 -61px}.arrow-dropdown [slot=trigger] .icon-dropdown--selected[data-arrow=begin-end],.arrow-dropdown .icon-dropdown-item-content[data-arrow=begin-end]{background-position:0 -91px}.content-group{display:flex;flex-direction:column}.content-group label{margin:8px 0 0 0}.color-ramp-selection{padding:4px}.section-toggle--disabled{pointer-events:none;opacity:0.5}.swatch-item{box-sizing:border-box;height:16px;width:16px;border-radius:2px;box-shadow:0 0 0 1px rgba(0, 0, 0, 0.33)}calcite-input[disabled] [data-adjustment]{pointer-events:none}arcgis-symbol-styler-section calcite-block{overflow:visible;margin:0 -12px}arcgis-symbol-styler-section calcite-block[open]:before{content:\"\";height:16px;display:flex;background-color:var(--calcite-ui-foreground-2)}arcgis-symbol-styler-section calcite-block:nth-of-type(n+1){border-bottom:1px solid #f0f0f0}arcgis-symbol-styler-section calcite-block:last-child{border-bottom:none}arcgis-symbol-styler-section calcite-block arcgis-symbol-styler-section:nth-of-type(2){margin-top:12px}calcite-panel{overflow:visible;margin-top:0}.input-color{flex-wrap:nowrap;gap:8px;align-items:center}calcite-tooltip{max-width:250px}calcite-tooltip:not([open]){visibility:hidden;pointer-events:none}.message{margin-top:8px}arcgis-symbol-styler-symbol-preview[slot=icon]{width:32px;height:32px;padding:2px;display:flex;align-items:center;justify-content:center}.container{display:flex;padding:8px 12px;align-items:center;justify-content:center;width:100%;gap:8px;flex-grow:1}.symbol{height:32px;display:flex;justify-content:center;align-items:center}.label{flex-grow:1;display:flex;justify-content:flex-start}.change-symbol-trigger{border:1px solid #949494}.symbol-selection-panel{min-height:min(100vh - 200px, 500px);display:flex;flex-direction:column}.symbol-selection-panel arcgis-item-palette .palette{gap:8px}.symbol-selection-panel calcite-notice:first-of-type{margin:auto 0 0 0}.symbol-selection-panel calcite-label{margin:16px 12px 0 12px}.symbol-selection-panel calcite-panel{overflow:visible}.section{display:flex;flex-direction:column;background-color:var(--arcgis-app-background)}";

const ArcGISSymbolStyler = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisSymbolStylerEdit = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerEdit", 7);
    this.arcgisSymbolStylerMarkerChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerMarkerChange", 7);
    this.arcgisSymbolStylerFillChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerFillChange", 7);
    this.arcgisSymbolStylerFillEnabledChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerFillEnabledChange", 7);
    this.arcgisSymbolStylerStrokeChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerStrokeChange", 7);
    this.arcgisSymbolStylerStrokeEnabledChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerStrokeEnabledChange", 7);
    this.arcgisSymbolStylerSourceIdChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolStylerSourceIdChange", 7);
    this.resizeObserver = new ResizeObserver((entries) => {
      const last = entries.pop();
      this.narrow = last.contentRect.width <= 275;
    });
    this.windowResizeObserver = new ResizeObserver(() => this.checkPopoverMaxHeight());
    this.autoOpenFirstBlock = false;
    this.autoCalcHeight = false;
    this.colorInputEl = [];
    this.updatePreviewSymbol = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_3__.c)(() => {
      const preview = this.symbol.clone();
      this.syncSymbolProps(preview, {
        symbolState: {
          marker: this.marker,
          fill: this.fill,
          stroke: this.stroke
        }
      });
      this.previewSymbol = preview;
    }, 150);
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.setRampInputRef = (el) => {
      this.rampInputEl = el;
    };
    this.setColorInputRef = (el) => {
      this.colorInputEl.push(el);
    };
    this.onColorRampFillTransparencyChange = (strokeTransparency) => {
      const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(strokeTransparency);
      const fill = this.fill;
      const mergedFill = {
        color: fill.color.map((color) => (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(Object.assign(Object.assign({}, color), { a: alpha })))
      };
      this.fill = mergedFill;
      this.arcgisSymbolStylerFillChange.emit(mergedFill);
      this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
    };
    this.onFillColorRampCategoryChange = (event) => {
      const select = event.target;
      const activeCategory = select.selectedOption.value;
      const section = this.sections.fill;
      this.sections = Object.assign(Object.assign({}, this.sections), { fill: Object.assign(Object.assign({}, section), { activeCategory }) });
      event.stopPropagation();
    };
    this.onColorFillTransparencyChange = (strokeTransparency) => {
      const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(strokeTransparency);
      const { fill } = this;
      const mergedFill = {
        color: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(Object.assign(Object.assign({}, fill.color), { a: alpha }))
      };
      this.fill = mergedFill;
      this.arcgisSymbolStylerFillChange.emit(mergedFill);
      this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
    };
    this.onStrokeColorRampCategoryChange = (event) => {
      const select = event.target;
      const activeCategory = select.selectedOption.value;
      const section = this.sections.stroke;
      this.sections = Object.assign(Object.assign({}, this.sections), { stroke: Object.assign(Object.assign({}, section), { activeCategory }) });
      event.stopPropagation();
    };
    this.onColorStrokeTransparencyChange = (strokeTransparency) => {
      const { stroke } = this;
      const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(strokeTransparency);
      const mergedStroke = Object.assign(Object.assign({}, stroke), { color: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(Object.assign(Object.assign({}, stroke.color), { a: alpha })) });
      this.stroke = mergedStroke;
      this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
      this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
    };
    this.onColorRampStrokeTransparencyChange = (strokeTransparency) => {
      const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(strokeTransparency);
      const stroke = this.stroke;
      const mergedStroke = Object.assign(Object.assign({}, stroke), { color: stroke.color.map((color) => (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(Object.assign(Object.assign({}, color), { a: alpha }))) });
      this.stroke = mergedStroke;
      this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
      this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
    };
    this.onStrokeStyleChange = (event) => {
      const dropdown = event.currentTarget;
      const style = dropdown.selectedItems[0].getAttribute("data-style");
      const { stroke } = this;
      const mergedStroke = Object.assign(Object.assign({}, stroke), { style });
      this.stroke = mergedStroke;
      this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
      this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
      event.stopPropagation();
    };
    this.onStrokeArrowChange = (event) => {
      const dropdown = event.currentTarget;
      const arrow = dropdown.selectedItems[0].getAttribute("data-arrow");
      const { stroke } = this;
      const mergedStroke = Object.assign(Object.assign({}, stroke), { marker: toArrowMarker(arrow) });
      this.stroke = mergedStroke;
      this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
      this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
      event.stopPropagation();
    };
    this.onStrokeWidthChange = (width) => this.setStrokeWidth(width);
    this.onAutoAdjustStrokeChange = (event) => {
      const node = event.currentTarget;
      const autoAdjusted = node.checked;
      const { stroke } = this;
      const mergedStroke = Object.assign(Object.assign({}, stroke), { autoAdjusted });
      this.stroke = mergedStroke;
      this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
      // we set to emit the auto-adjusted changes regardless of the symbol not changing
      this.emitEdit(this.symbol);
      event.stopPropagation();
    };
    this.syncSymbolProps = (symbol, options) => {
      const symbolState = (options === null || options === void 0 ? void 0 : options.symbolState) || {
        marker: this.marker,
        fill: this.fill,
        stroke: this.stroke
      };
      const cimChangeContext = options === null || options === void 0 ? void 0 : options.cimChangeContext;
      const type = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.h)(symbol);
      return type === "point"
        ? this.syncPointSymbolProps(symbol, symbolState, cimChangeContext)
        : type === "line"
          ? this.syncLineSymbolProps(symbol, symbolState, cimChangeContext)
          : this.syncPolygonSymbolProps(symbol, symbolState, cimChangeContext);
    };
    this.syncPointSymbolProps = (symbol, { fill, marker, stroke }, cimChangeContext) => {
      const { screenUtils } = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e;
      const { sections } = this;
      const size = normalizePt(screenUtils.px2pt(marker.size));
      if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol)) {
        const lineOnlySymbol = isLineOnlySymbol(symbol);
        if (!lineOnlySymbol) {
          if (this.isFillColorRamp()) {
            symbol.color = this.getSampleFillColorRampColor();
          }
          else {
            symbol.color = sections.fill.enabled ? fill.color : (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(null);
          }
        }
        if (symbol.outline) {
          if (this.isStrokeColorRamp()) {
            symbol.outline.color = this.getSampleStrokeColorRampColor();
          }
          else if (lineOnlySymbol && this.isFillColorRamp()) {
            symbol.outline.color = this.getSampleFillColorRampColor();
          }
          else {
            symbol.outline.color = sections.stroke.enabled
              ? stroke.color
              : (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(null);
          }
          symbol.outline.marker = stroke.marker;
          symbol.outline.style = stroke.style;
          symbol.outline.width = normalizePt(screenUtils.px2pt(stroke.size));
        }
        symbol.size = size;
      }
      else if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.f)(symbol)) {
        // keep aspect ratio
        symbol.height = Math.round((symbol.height / symbol.width) * size * 100) / 100;
        symbol.width = size;
      }
      const clockwiseAngle = Math.abs(marker.angle);
      if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
        // only top-level props are applied
        // when using the original symbol from a symbol set we want to keep these current settings
        if (["root", "original-root"].indexOf(cimChangeContext) > -1) {
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolRotation(symbol, clockwiseAngle, true);
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, size);
        }
        else {
          symbol.data.symbol.angle = clockwiseAngle;
        }
        if (this.isFillColorRamp()) {
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleFillColorRampColor(), {
            layersToColor: "fill"
          });
        }
        else if (this.isStrokeColorRamp()) {
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleStrokeColorRampColor(), { layersToColor: "outline" });
        }
      }
      else {
        symbol.angle = clockwiseAngle;
      }
      return symbol;
    };
    this.syncLineSymbolProps = (symbol, { stroke }, cimChangeContext) => {
      const { screenUtils } = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e;
      const { sections } = this;
      const width = normalizePt(screenUtils.px2pt(stroke.size));
      if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.c)(symbol)) {
        if (this.isStrokeColorRamp()) {
          symbol.color = this.getSampleStrokeColorRampColor();
        }
        else {
          symbol.color = sections.stroke.enabled ? stroke.color : (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(null);
        }
        // when using the original symbol from a symbol set we don't want to keep these settings
        if (cimChangeContext !== "original-root") {
          symbol.marker = stroke.marker;
          symbol.style = stroke.style;
          symbol.width = width;
        }
      }
      else if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
        // only top-level props are applied
        // when using the original symbol from a symbol set ("original-root") we don't want to keep these settings
        if (cimChangeContext === "root") {
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, width);
        }
        if (this.isStrokeColorRamp()) {
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleStrokeColorRampColor());
        }
      }
      return symbol;
    };
    this.syncPolygonSymbolProps = (symbol, { fill, stroke }, cimChangeContext) => {
      const { screenUtils } = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e;
      const { sections } = this;
      const width = normalizePt(screenUtils.px2pt(stroke.size));
      if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol)) {
        if (this.isFillColorRamp()) {
          symbol.color = this.getSampleFillColorRampColor();
        }
        else {
          symbol.color = sections.fill.enabled ? fill.color : (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(null);
        }
        if (this.isStrokeColorRamp()) {
          symbol.outline.color = this.getSampleStrokeColorRampColor();
        }
        else {
          symbol.outline.color = sections.stroke.enabled
            ? stroke.color
            : (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(null);
        }
        // when using the original symbol from a symbol set we don't want to keep these settings
        if (cimChangeContext !== "original-root") {
          symbol.outline.width = width;
          symbol.outline.style = stroke.style;
        }
      }
      else if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
        // only top-level props are applied
        if (this.isFillColorRamp()) {
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleFillColorRampColor(), {
            layersToColor: "fill"
          });
        }
        else if (this.isStrokeColorRamp()) {
          _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolColor(symbol, this.getSampleStrokeColorRampColor(), { layersToColor: "outline" });
        }
        // when using the original symbol from a symbol set ("original-root") we don't want to keep these settings
        if (cimChangeContext === "root") {
          if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.g)(symbol)) {
            // scaleCIMSymbolTo() also scales markers, separators, ...
            setOutlineWidth(symbol, width);
          }
          else {
            _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, width);
          }
        }
      }
      return symbol;
    };
    this.onStrokeEnabledChange = (enabled) => {
      const { sections } = this;
      const preventChange = isLineOnlySymbol(this.activeSymbol);
      this.sections = Object.assign(Object.assign({}, sections), { stroke: Object.assign(Object.assign({}, sections.stroke), { enabled: preventChange ? true : enabled }) });
      if (preventChange) {
        return;
      }
      this.arcgisSymbolStylerStrokeEnabledChange.emit({
        enabled,
        stroke: normalizeSizeProp(this.stroke)
      });
      this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
    };
    this.onFillEnabledChange = (enabled) => {
      const { fill, sections } = this;
      const preventChange = isLineOnlySymbol(this.activeSymbol);
      this.sections = Object.assign(Object.assign({}, sections), { fill: Object.assign(Object.assign({}, sections.fill), { enabled: preventChange ? false : enabled }) });
      if (preventChange) {
        return;
      }
      this.arcgisSymbolStylerFillEnabledChange.emit({
        enabled,
        fill
      });
      this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
    };
    this.onAutoAdjustSizeChange = (event) => {
      const node = event.currentTarget;
      const autoAdjusted = node.checked;
      const { marker } = this;
      const mergedMarker = Object.assign(Object.assign({}, marker), { autoAdjusted });
      this.marker = mergedMarker;
      this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker));
      // we set to emit the auto-adjusted changes regardless of the symbol not changing
      this.emitEdit(this.symbol);
      event.stopPropagation();
    };
    this.onSymbolSizeChange = (size) => this.setSymbolSize(size);
    this.onSymbolRotationChange = (angle) => {
      const { marker, fill, stroke } = this;
      const mergedMarker = Object.assign(Object.assign({}, marker), { angle, symbol: this.syncSymbolProps(this.symbol, {
          cimChangeContext: "root",
          symbolState: {
            marker: Object.assign(Object.assign({}, marker), { angle }),
            fill: fill,
            stroke: stroke
          }
        }) });
      this.marker = mergedMarker;
      this.setInternalSymbol(mergedMarker.symbol, true);
      this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker));
    };
    this.onSymbolSelect = (symbol) => {
      var _a;
      const { fill, marker, sections, stroke } = this;
      const changedFromPMSToSMS = ((_a = this.activeSymbol) === null || _a === void 0 ? void 0 : _a.type) === "picture-marker" && symbol.type === "simple-marker";
      const hadLineOnlySymbol = isLineOnlySymbol(this.activeSymbol);
      const selectedLineOnlySymbol = isLineOnlySymbol(symbol);
      const changedFromLineOnlySMSToNonLineOnlySMS = hadLineOnlySymbol && !selectedLineOnlySymbol;
      const changedFromNonLineOnlySMSToLineOnlySMS = !hadLineOnlySymbol && selectedLineOnlySymbol;
      this.autoOpenFirstBlock = true;
      const fillSupported = supportsFill(symbol);
      const strokeSupported = supportsStroke(symbol);
      const fillStrokeOverrides = {};
      const switchedFromCIMToNonCIM = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(this.activeSymbol) && !(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol);
      if (switchedFromCIMToNonCIM) {
        if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) || (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol)) {
          if (fillSupported && sections.fill.type === "color") {
            fillStrokeOverrides.fill = Object.assign(Object.assign({}, fill), { color: symbol.color.clone() });
          }
          if (strokeSupported && sections.stroke.type === "color") {
            const smsOrSfs = symbol;
            const color = smsOrSfs.outline.color.clone();
            if (changedFromNonLineOnlySMSToLineOnlySMS) {
              // ensure line color is visible
              color.a = 1;
            }
            fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color });
            if (_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.b) {
              // override with outline width of new symbol
              fillStrokeOverrides.stroke.size = symbol.outline.width;
              fillStrokeOverrides.stroke.style = symbol.outline.style;
            }
          }
        }
        else if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.c)(symbol)) {
          if (strokeSupported && sections.stroke.type === "color") {
            const sls = symbol;
            fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { size: sls.width, color: sls.color.clone() });
          }
        }
      }
      else if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
        const rootColor = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolColor(symbol);
        if (sections.fill.type === "color") {
          fillStrokeOverrides.fill = Object.assign(Object.assign({}, fill), { color: rootColor });
        }
        fillStrokeOverrides.stroke = Object.assign({}, stroke);
        if (this.editGeometry === "point") {
          fillStrokeOverrides.stroke.size = normalizePt(marker.size);
        }
        else if (this.editGeometry === "line") {
          fillStrokeOverrides.stroke.size = normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(symbol));
        }
        if (sections.stroke.type === "color") {
          fillStrokeOverrides.stroke.color = rootColor;
        }
        this.cimStrokeWidthBounds = getCIMStrokeWidthBounds();
      }
      else if (sections.fill.type === "color-ramp" && sections.stroke.type === "color") {
        if (selectedLineOnlySymbol) {
          // use fill ramp category and store selected ramp whenever switching to pure-line style
          this.tempStrokeColorRampStateActiveCategory = sections.fill.activeCategory;
          this.tempStrokeColorRampStateStops = fill.color;
          this.tempStrokePreviousColorBeforeColorRampSwitch = stroke.color;
          fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color: this.tempStrokeColorRampStateStops });
        }
        else if (changedFromLineOnlySMSToNonLineOnlySMS) {
          fillStrokeOverrides.fill = Object.assign(Object.assign({}, fill), { color: this.tempStrokeColorRampStateStops });
          fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color: this.tempStrokePreviousColorBeforeColorRampSwitch });
          this.tempStrokeColorRampStateActiveCategory = null;
          this.tempStrokeColorRampStateStops = null;
        }
      }
      else if (sections.fill.type === "color" && sections.stroke.type === "color-ramp") {
        if (changedFromNonLineOnlySMSToLineOnlySMS) {
          const ramp = stroke.color.map((color) => {
            // ensure line color is visible
            color.a = 1;
            return color;
          });
          fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color: ramp });
        }
      }
      else if (sections.fill.type === "color" && sections.stroke.type === "color") {
        if (changedFromNonLineOnlySMSToLineOnlySMS) {
          const color = stroke.color.clone();
          if (changedFromNonLineOnlySMSToLineOnlySMS) {
            // ensure line color is visible
            color.a = 1;
          }
          fillStrokeOverrides.stroke = Object.assign(Object.assign({}, stroke), { color });
        }
      }
      this.sections = Object.assign(Object.assign({}, sections), { fill: Object.assign(Object.assign({}, sections.fill), { open: !selectedLineOnlySymbol && sections.fill.open, enabled: fillSupported &&
            (!selectedLineOnlySymbol ||
              (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) ||
              changedFromLineOnlySMSToNonLineOnlySMS ||
              changedFromPMSToSMS ||
              sections.fill.enabled) }), stroke: Object.assign(Object.assign({}, sections.stroke), { enabled: strokeSupported &&
            ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) ||
              changedFromNonLineOnlySMSToLineOnlySMS ||
              (switchedFromCIMToNonCIM && !selectedLineOnlySymbol) ||
              changedFromPMSToSMS ||
              sections.stroke.enabled) }) });
      const finalFill = (fillStrokeOverrides.fill || fill);
      const finalStroke = (fillStrokeOverrides.stroke || stroke);
      const mergedMarker = Object.assign(Object.assign({}, marker), { symbol: this.syncSymbolProps(symbol, {
          cimChangeContext: "original-root",
          symbolState: {
            marker,
            fill: finalFill,
            stroke: finalStroke
          }
        }) });
      this.fill = finalFill;
      this.stroke = finalStroke;
      this.marker = mergedMarker;
      this.activeSymbol = symbol;
      this.setInternalSymbol(mergedMarker.symbol, true);
      this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker));
    };
    this.emitEdit = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_3__.d)(async (symbol) => {
      const clone = symbol.clone();
      const info = {};
      const { editGeometry } = this;
      const addMarker = editGeometry === "point";
      const addFill = (!isLineOnlySymbol(symbol) && editGeometry === "point") || editGeometry === "polygon";
      if (addMarker) {
        info.marker = Object.assign(Object.assign({}, normalizeSizeProp(this.marker)), { symbol: clone });
      }
      if (addFill) {
        info.fill = Object.assign({}, this.fill);
      }
      // stroke applies to all geometry types
      info.stroke = Object.assign({}, normalizeSizeProp(this.stroke));
      this.arcgisSymbolStylerEdit.emit({
        symbol: clone,
        info
      });
    }, 300);
    this.flipFillColorRamps = () => {
      const section = this.sections.fill;
      const fill = this.fill;
      const is2d = section.style === "2d";
      const mergedFill = {
        color: (0,_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.f)(fill.color, is2d)
      };
      this.sections = Object.assign(Object.assign({}, this.sections), { fill: Object.assign(Object.assign({}, section), { colorRamps: section.colorRamps.map(({ stops, tags, name }) => ({
            stops: (0,_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.f)(stops, is2d),
            tags,
            name
          })) }) });
      this.fill = mergedFill;
      this.arcgisSymbolStylerFillChange.emit(mergedFill);
      // we set to emit the auto-adjusted changes regardless of the symbol not changing
      this.emitEdit(this.symbol);
    };
    this.renderBlock = (props) => {
      var _a;
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { collapsible: true, disabled: (_a = props.disabled) !== null && _a !== void 0 ? _a : false, heading: props.heading, key: props.key, onCalciteBlockToggle: this.onBlockToggle }, props.icon, props.content));
    };
    this.onBlockToggle = (event) => {
      var _a;
      // close all color picker popovers
      (_a = this.rampInputEl) === null || _a === void 0 ? void 0 : _a.close();
      this.colorInputEl.forEach((el) => el.close());
    };
    this.renderSection = ({ disabled, embedded = false, key, sectionContent }) => {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { disabled: disabled, key: key, embedded: embedded }, sectionContent.map(({ content }) => content)));
    };
    this.flipStrokeColorRamps = () => {
      const section = this.sections.stroke;
      const stroke = this.stroke;
      const is2d = section.style === "2d";
      const mergedStroke = Object.assign(Object.assign({}, stroke), { color: (0,_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.f)(stroke.color, is2d) });
      this.sections = Object.assign(Object.assign({}, this.sections), { stroke: Object.assign(Object.assign({}, section), { colorRamps: section.colorRamps.map(({ stops, tags, name }) => ({
            stops: (0,_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.f)(stops, is2d),
            tags: tags.slice(),
            name
          })) }) });
      this.stroke = mergedStroke;
      this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
      // we set to emit the auto-adjusted changes regardless of the symbol not changing
      this.emitEdit(this.symbol);
    };
    this.popoverProps = undefined;
    this.initialSourceId = undefined;
    this.portal = undefined;
    this.stringOverrides = undefined;
    this.cimStrokeWidthBounds = undefined;
    this.config = undefined;
    this.editGeometry = undefined;
    this.fill = undefined;
    this.marker = undefined;
    this.narrow = false;
    this.preppingEdit = true;
    this.previewSymbol = undefined;
    this.sections = undefined;
    this.builtInStrings = undefined;
    this.mergedStrings = undefined;
    this.stroke = undefined;
    this.symbol = undefined;
    this.tempStrokeColorRampStateActiveCategory = "all";
    this.activeSymbol = undefined;
    this.activeSymbolItem = undefined;
    this.activeSourceId = undefined;
    this.state = "editing";
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.resizeObserver.observe(this.el);
    this.windowResizeObserver.observe(document.body);
  }
  disconnectedCallback() {
    this.resizeObserver.unobserve(this.el);
    this.windowResizeObserver.unobserve(document.body);
  }
  async componentWillLoad() {
    const [, [strings]] = await Promise.all([
      _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.load(),
      (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_4__.g)(this.el)
    ]);
    this.currentLanguage = (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_4__.a)(this.el);
    this.dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el);
    const percentFormatter = new Intl.NumberFormat(this.currentLanguage, { style: "percent" });
    const percentFormatSample = percentFormatter.format(0);
    this.percentLabelFlip =
      this.dir === "rtl" ? percentFormatSample.endsWith("%") : percentFormatSample.startsWith("%");
    this.builtInStrings = strings;
  }
  componentShouldUpdate(newVal, _oldVal, propName) {
    if (propName === "preppingEdit") {
      return !newVal;
    }
  }
  componentDidRender() {
    if (this.autoOpenFirstBlock && !this.preppingEdit) {
      const firstBlock = this.el.shadowRoot.querySelector("calcite-block");
      if (firstBlock) {
        this.autoOpenFirstBlock = false;
        firstBlock.open = true;
      }
    }
  }
  // multiple watches trigger false negative for this rule
  // eslint-disable-next-line @stencil/no-unused-watch
  handleStringChanges() {
    this.mergedStrings = Object.assign(Object.assign({}, this.builtInStrings), this.stringOverrides);
  }
  onPanelBack(event) {
    event.stopPropagation();
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  async edit(symbol, config) {
    var _a, _b, _c, _d, _e, _f, _g;
    const errorMessage = validateEditable(symbol);
    if (errorMessage) {
      throw new Error(`[arcgis-symbol-styler] ${errorMessage}`);
    }
    symbol = await this.checkLineOnlySymbol(symbol, config);
    this.portalOrInterceptor = config.portal || this.portal || _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.Portal.getDefault();
    this.preppingEdit = true;
    this.autoOpenFirstBlock = true;
    const { marker: markerSection, fill: fillSection, stroke: strokeSection } = config.sections;
    this.symbolFilter =
      config.symbolFilter ||
        ((markerSection === null || markerSection === void 0 ? void 0 : markerSection.markerType) === "all" ? undefined : markerSection === null || markerSection === void 0 ? void 0 : markerSection.markerType);
    this.editGeometry = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.h)(symbol);
    symbol = symbol.clone();
    const fillSupported = supportsFill(symbol);
    const strokeSupported = supportsStroke(symbol);
    if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.a)(symbol) || (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.b)(symbol)) {
      if (!symbol.outline) {
        symbol.outline = { type: "simple-line", color: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(null) };
      }
      else if (!symbol.outline.color) {
        symbol.outline.color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(null);
      }
    }
    const stroke = Object.assign(Object.assign({ autoAdjusted: false }, config.stroke), { size: parseSize((_a = config.stroke) === null || _a === void 0 ? void 0 : _a.size, 2), style: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.b.includes((_b = config.stroke) === null || _b === void 0 ? void 0 : _b.style) ? config.stroke.style : "solid" });
    if ((_c = config.stroke) === null || _c === void 0 ? void 0 : _c.marker) {
      stroke.marker = config.stroke.marker;
    }
    this.sections = {
      marker: {
        backgroundStyle: "light",
        optional: false /* placeholder */,
        enabled: false /* placeholder */,
        open: (markerSection === null || markerSection === void 0 ? void 0 : markerSection.open) || false,
        symbolsOpen: (markerSection && (!("symbolsOpen" in markerSection) || markerSection.symbolsOpen)) ||
          false,
        sizeOpen: (markerSection && (!("sizeOpen" in markerSection) || markerSection.sizeOpen)) || false,
        rotationOpen: (markerSection && (!("rotationOpen" in markerSection) || markerSection.rotationOpen)) ||
          false,
        keepChoice: (markerSection === null || markerSection === void 0 ? void 0 : markerSection.keepChoice) || false,
        parts: Object.assign(Object.assign({}, _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.d), markerSection === null || markerSection === void 0 ? void 0 : markerSection.parts)
      },
      fill: {
        activeCategory: "all",
        open: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.open) || false,
        optional: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.optional) || false,
        enabled: fillSupported &&
          ((_d = config.fillEnabled) !== null && _d !== void 0 ? _d : true) &&
          !(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) &&
          (fillSection === null || fillSection === void 0 ? void 0 : fillSection.type) === "color" &&
          !!this.toColorPickerValue(config.fill.color),
        type: fillSection === null || fillSection === void 0 ? void 0 : fillSection.type,
        style: fillSection === null || fillSection === void 0 ? void 0 : fillSection.style,
        suggestedColorsOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.suggestedColorsOpen) || false,
        customColorOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.customColorOpen) || false,
        colorRampsOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.colorRampsOpen) || false,
        colorRamps: getStateColorRamps(fillSection, config.fill),
        transparencyOpen: (fillSection === null || fillSection === void 0 ? void 0 : fillSection.transparencyOpen) || false,
        parts: Object.assign(Object.assign(Object.assign({}, _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.c), _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.e), fillSection === null || fillSection === void 0 ? void 0 : fillSection.parts)
      },
      stroke: {
        activeCategory: "all",
        optional: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.optional) || false,
        open: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.open) || false,
        enabled: strokeSupported &&
          ((_e = config.strokeEnabled) !== null && _e !== void 0 ? _e : true) &&
          !(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) &&
          (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.type) === "color" &&
          !!this.toColorPickerValue(config.stroke.color),
        type: strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.type,
        style: strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.style,
        suggestedColorsOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.suggestedColorsOpen) || false,
        customColorOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.customColorOpen) || false,
        colorRampsOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.colorRampsOpen) || false,
        colorRamps: getStateColorRamps(strokeSection, config.stroke),
        transparencyOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.transparencyOpen) || false,
        extraOpen: (strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.extraOpen) || false,
        extraParts: Object.assign(Object.assign({}, _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.g), strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.extraParts),
        parts: Object.assign(Object.assign(Object.assign(Object.assign({}, _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.c), _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.e), _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.h), strokeSection === null || strokeSection === void 0 ? void 0 : strokeSection.parts)
      }
    };
    this.marker = Object.assign(Object.assign({}, config.marker), { size: parseSize((_f = config.marker) === null || _f === void 0 ? void 0 : _f.size, 0), angle: getSymbolRotation(symbol), autoAdjusted: ((_g = config.marker) === null || _g === void 0 ? void 0 : _g.autoAdjusted) || false, symbol });
    this.fill = Object.assign({}, config.fill);
    this.stroke = stroke;
    this.activeSymbol = symbol;
    this.activeSourceId = ((markerSection === null || markerSection === void 0 ? void 0 : markerSection.keepChoice) && this.activeSourceId) || null;
    this.activeSymbolItem = ((markerSection === null || markerSection === void 0 ? void 0 : markerSection.keepChoice) && this.activeSymbolItem) || null;
    this.config = config;
    if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol) && (this.isFillColorRamp() || this.isStrokeColorRamp())) {
      this.syncSymbolProps(symbol, {
        cimChangeContext: "root"
      });
    }
    if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol)) {
      this.cimStrokeWidthBounds = getCIMStrokeWidthBounds();
    }
    this.setInternalSymbol(symbol, false);
    this.preppingEdit = false;
  }
  async checkLineOnlySymbol(symbol, config) {
    // we no longer support plus and X markers in the styler
    var _a, _b, _c, _d, _e, _f, _g;
    if (isLineOnlySymbol(symbol)) {
      //"fill":{"color":Color},
      //"fill":{"color":[Color,Color,Color,Color,Color]}
      //"marker":{"size":13.5,"autoAdjusted":false},
      //"stroke":{"color":Color,"size":0.75}
      const [SimpleMarkerSymbol] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_6__.l)(["esri/symbols/SimpleMarkerSymbol"]);
      symbol = new SimpleMarkerSymbol();
      // make sure config fits to new symbol
      if ((_a = config.fill) === null || _a === void 0 ? void 0 : _a.color) {
        if (Array.isArray(config.fill.color)) {
          // "color-ramp"
          symbol.color = config.fill.color[config.fill.color.length - 1];
        }
        else {
          // "color"
          symbol.color = config.fill.color;
        }
      }
      if ((_b = config.stroke) === null || _b === void 0 ? void 0 : _b.color) {
        config.stroke.color = symbol.outline.color.clone();
      }
      if (((_c = config.stroke) === null || _c === void 0 ? void 0 : _c.size) || ((_d = config.stroke) === null || _d === void 0 ? void 0 : _d.size) === 0) {
        config.stroke.size = symbol.outline.width;
      }
      if ((_e = config.marker) === null || _e === void 0 ? void 0 : _e.size) {
        symbol.size = config.marker.size;
      }
      this.marker = Object.assign(Object.assign({}, config.marker), { size: parseSize((_f = config.marker) === null || _f === void 0 ? void 0 : _f.size, 0), angle: getSymbolRotation(symbol), autoAdjusted: ((_g = config.marker) === null || _g === void 0 ? void 0 : _g.autoAdjusted) || false, symbol });
      this.emitEdit(symbol);
      return Promise.resolve(symbol);
    }
    return Promise.resolve(symbol);
  }
  async setSize(type, size) {
    const { screenUtils } = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e;
    if (type === "stroke") {
      this.setStrokeWidth(normalizePx(screenUtils.pt2px(size)), false);
    }
    if (type === "marker") {
      this.setSymbolSize(normalizePx(screenUtils.pt2px(size)), false);
    }
  }
  getLinePatternStyle(style) {
    return {
      backgroundImage: `url(${(0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/line-patterns/${style}.png`)})`
    };
  }
  getSelectedArrowPatternStyle() {
    return {
      backgroundImage: `url(${(0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/arrow-pattern-spritesheet.png`)})`
    };
  }
  getArrowPatternOptionStyle() {
    return {
      backgroundImage: `url(${(0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/arrow-pattern-options-spritesheet.png`)})`
    };
  }
  hasActiveLineOnlySimpleMarkerSymbol() {
    const { marker, symbol } = this;
    return marker && isLineOnlySymbol(symbol);
  }
  hasActivePictureMarkerSymbol() {
    var _a;
    return ((_a = this.symbol) === null || _a === void 0 ? void 0 : _a.type) === "picture-marker" || this.activeSymbol.type === "picture-marker";
  }
  setStrokeWidth(width, emit = true) {
    const { stroke } = this;
    const size = width < 0 ? 0 : normalizePx(width);
    const mergedStroke = Object.assign(Object.assign({}, stroke), { size });
    this.stroke = mergedStroke;
    if (emit) {
      this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke, width));
    }
    this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), emit);
  }
  isFillColorRamp() {
    var _a;
    return ((_a = this.config.sections.fill) === null || _a === void 0 ? void 0 : _a.type) === "color-ramp";
  }
  isStrokeColorRamp() {
    var _a;
    return ((_a = this.config.sections.stroke) === null || _a === void 0 ? void 0 : _a.type) === "color-ramp";
  }
  getSampleFillColorRampColor() {
    const section = this.sections.fill;
    const fill = this.fill;
    return this.getSampleColorRampColor(section, fill.color);
  }
  getSampleStrokeColorRampColor() {
    const section = this.sections.stroke;
    const stroke = this.stroke;
    return this.getSampleColorRampColor(section, stroke.color);
  }
  getSampleColorRampColor(section, rampColors) {
    const totalColors = rampColors.length;
    if (section.style === "2d" || section.style === "discrete") {
      return rampColors[totalColors - 1];
    }
    return rampColors[Math.floor(totalColors / 2)];
  }
  setSymbolSize(size, emit = true) {
    const { marker, fill, stroke, symbol } = this;
    const mergedMarker = Object.assign(Object.assign({}, marker), { symbol: this.syncSymbolProps(symbol, {
        cimChangeContext: "root",
        symbolState: {
          marker: Object.assign(Object.assign({}, marker), { size }),
          fill: fill,
          stroke: stroke
        }
      }), size });
    this.marker = mergedMarker;
    this.setInternalSymbol(mergedMarker.symbol, emit);
    if (emit) {
      this.arcgisSymbolStylerMarkerChange.emit(normalizeSizeProp(mergedMarker, size));
    }
  }
  render() {
    var _a, _b, _c, _d, _e, _f;
    if (this.preppingEdit) {
      return;
    }
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el);
    const { sections } = this.config;
    const editingCIM = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(this.activeSymbol);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { ref: (el) => {
        this.flowEl = el;
        // we're here after componentDidLoad
        this.checkPopoverMaxHeight();
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { class: {
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: dir === "rtl"
      }, dir: dir,
      // omitting `heading` intentionally to allow embedding into existing panels
      //heightScale={this.heightScale}
      key: "main" }, [
      ((_b = (_a = sections.marker) === null || _a === void 0 ? void 0 : _a.parts) === null || _b === void 0 ? void 0 : _b.rotation) === false &&
        ((_d = (_c = sections.marker) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.preview) === false &&
        ((_f = (_e = sections.marker) === null || _e === void 0 ? void 0 : _e.parts) === null || _f === void 0 ? void 0 : _f.size) === false
        ? null
        : this.renderSymbolBlock(),
      !editingCIM && sections.fill ? this.renderFillBlock() : null,
      !editingCIM && sections.stroke ? this.renderStrokeBlock() : null
    ]), this.state === "choosing-symbol" ? this.renderSymbolSelectionPanel() : null)));
  }
  renderSymbolBlock() {
    const { marker: section, stroke: strokeSection } = this.sections;
    const { parts: parts } = section;
    const { editGeometry, symbol } = this;
    const isCIM = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(symbol);
    const content = [];
    if (parts.preview) {
      content.push({
        content: this.renderSymbolsSelection()
      });
    }
    if (isCIM) {
      if (this.isFillColorRamp()) {
        content.push({
          content: this.renderColorRampFillBlock(true)
        });
      }
      else if (this.isStrokeColorRamp()) {
        content.push({
          content: this.renderColorRampStrokeBlock(true)
        });
      }
    }
    if (editGeometry === "point") {
      if (parts.size) {
        content.push({
          content: isCIM ? this.renderRootCIMSymbolSizeContent() : this.renderSymbolSizeContent()
        });
      }
      if (parts.rotation) {
        content.push({
          content: this.renderSymbolRotationContent()
        });
      }
    }
    else if (isCIM && strokeSection.extraParts.width) {
      // check if the specific CIM supports an outline width
      if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.g)(symbol) || ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.g)(symbol) && supportsOutlineWidth(symbol))) {
        content.push({
          content: this.renderRootCIMSymbolWidthContent()
        });
      }
    }
    if (isCIM) {
      content.push({
        content: this.renderRootCIMSymbolContent(symbol)
      });
    }
    return this.renderSection({
      key: "marker-symbols",
      sectionContent: content
    });
  }
  renderRootCIMSymbolContent(symbol) {
    const layerPanels = this.renderCIMSymbolLayersContent(symbol.data.symbol, "root-symbol");
    if (layerPanels.length > _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.i) {
      return [
        ...layerPanels.slice(0, _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.i),
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.message }, this.mergedStrings.additionalSymbolLayersNotShown.replace("${count}", _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.i.toString()))
      ];
    }
    return layerPanels;
  }
  renderCIMSymbolLayersContent({ symbolLayers }, key, contentOnly = false, parentSymbolLayer) {
    return symbolLayers
      .filter(({ type }) => this.isSupportedSymbolLayerType(type))
      .map((symbolLayer, index) => {
      const contentKey = `${key}__symbol-layers__symbol-layer-${index.toString()}`;
      if (symbolLayer.type === "CIMVectorMarker") {
        return this.renderCIMVectorMarkerSymbolLayerBlocks(symbolLayer, contentKey);
      }
      if (symbolLayer.type === "CIMPictureMarker") {
        return this.renderCIMPictureMarkerSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
      }
      if (symbolLayer.type === "CIMSolidStroke") {
        return this.renderCIMSolidStrokeSymbolLayerBlock(symbolLayer, contentKey, contentOnly, parentSymbolLayer);
      }
      if (symbolLayer.type === "CIMPictureStroke") {
        return this.renderCIMPictureStrokeSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
      }
      if (symbolLayer.type === "CIMSolidFill") {
        return this.renderCIMSolidFillSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
      }
      if (symbolLayer.type === "CIMHatchFill") {
        return this.renderCIMHatchFillSymbolLayerBlocks(symbolLayer, contentKey);
      }
      if (symbolLayer.type === "CIMPictureFill") {
        return this.renderCIMPictureFillSymbolLayerBlock(symbolLayer, contentKey, contentOnly);
      }
    })
      .filter(Boolean)
      .flat();
  }
  renderSymbolsSelection() {
    var _a, _b;
    const activeSymbol = this.previewSymbol;
    const contrastingBackgroundTheme = activeSymbol
      ? _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.previewSymbol2D.getContrastingBackgroundTheme(activeSymbol, 245)
      : "light";
    const isRtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el) === "rtl";
    const singleSourceAndItemAvailable = ((_a = this.filteredSources) === null || _a === void 0 ? void 0 : _a.length) === 1 && ((_b = this.activeSymbolItems) === null || _b === void 0 ? void 0 : _b.length) === 1;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { style: {
        "--arcgis-symbol-styler-inline-input-trigger-background-color": contrastingBackgroundTheme === "dark" ? "#f3f3f3" : ""
      } }, this.mergedStrings.currentSymbol, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.changeSymbolTrigger, disabled: singleSourceAndItemAvailable, onClick: () => {
        this.state = "choosing-symbol";
      }, type: "button" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.container, tabIndex: 0 }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.symbol }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { symbol: activeSymbol, options: this.editGeometry === "point" ? _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.p : null })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.label }, getSymbolLabel(activeSymbol, this.mergedStrings))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: singleSourceAndItemAvailable ? null : `chevron-${isRtl ? "left" : "right"}`, scale: "s" }))));
  }
  renderSymbolSelectionPanel() {
    const { dir, mergedStrings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow-item", { class: {
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.C.rtl]: dir === "rtl",
        "symbol-selection-panel": true
      }, dir: dir, heading: mergedStrings.changeSymbol,
      //heightScale={this.heightScale}
      key: "symbol-selection", beforeBack: async () => {
        this.state = "editing";
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-picker", { lang: this.currentLanguage, onArcgisActiveSymbolChange: (event) => {
        const { detail: symbol } = event;
        this.onSymbolSelect(symbol);
        event.stopPropagation();
      }, onArcgisActiveSourceIdChange: ({ detail: activeSourceId }) => {
        this.activeSourceId = activeSourceId;
        this.arcgisSymbolStylerSourceIdChange.emit(activeSourceId);
      }, onArcgisActiveSymbolItemChange: ({ detail: activeSymbolItem }) => {
        this.activeSymbolItem = activeSymbolItem;
      }, onArcgisSymbolSourcesChange: ({ detail: filteredSources }) => (this.filteredSources = filteredSources), onArcgisActiveSourceItemsChange: ({ detail: activeSourceItems }) => (this.activeSymbolItems = activeSourceItems), activeSymbolItem: this.activeSymbolItem, activeSourceId: this.activeSourceId || this.initialSourceId, portal: this.portalOrInterceptor, style: {
        "--scroller-max-height": "var(--symbol-scroller-max-height)"
      }, symbolFilter: this.symbolFilter, symbol: this.activeSymbol }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { width: "full", slot: "footer", onClick: () => this.flowEl.back() }, mergedStrings.done)));
  }
  setInternalSymbol(symbol, emit) {
    this.symbol = symbol;
    this.updatePreviewSymbol();
    if (emit) {
      this.emitEdit(symbol);
    }
  }
  renderRootCIMSymbolSizeContent() {
    const { sections: { marker: { parts: { size } } }, marker } = this;
    const max = 150;
    const min = 1;
    const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
    const largestSize = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(this.symbol);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted, min: min, max: max, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(largestSize)), onValueChange: this.onSymbolSizeChange, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })), autoSizeAdjust
      ? this.renderAutoAdjust((0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el), this.marker.autoAdjusted, this.mergedStrings.autoAdjustSize, this.onAutoAdjustSizeChange)
      : null));
  }
  renderRootCIMSymbolWidthContent() {
    var _a;
    // for polygon CIMs it only comes here for an outline
    const symbol = this.symbol;
    const { sections: { stroke: { extraParts: { autoStrokeAdjust } } }, stroke } = this;
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el);
    const width = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.g)(symbol)
      ? getOutlineWidth(symbol)
      : _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(this.symbol);
    let label = this.getStrokeString("width");
    let min = this.cimStrokeWidthBounds.min;
    let max = this.cimStrokeWidthBounds.max;
    if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.j)(symbol)) {
      // if it has markers we should treat it as size, not width
      const hasMarker = (_a = symbol.data.symbol.symbolLayers) === null || _a === void 0 ? void 0 : _a.some((symbolLayer) => ["CIMVectorMarker", "CIMPictureMarker"].indexOf(symbolLayer.type) > -1);
      if (hasMarker) {
        label = this.mergedStrings.symbolSize;
        min = _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.n;
        max = _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.q;
      }
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir }, label, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoStrokeAdjust && autoStrokeAdjust !== "editable" && stroke.autoAdjusted, min: min, max: max, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(width)), onValueChange: this.onStrokeWidthChange, withSteppers: !this.narrow, label: label })), autoStrokeAdjust
      ? this.renderAutoAdjust(dir, this.stroke.autoAdjusted, this.mergedStrings.autoAdjustStroke, this.onAutoAdjustStrokeChange)
      : null));
  }
  renderSymbolSizeContent() {
    const { sections: { marker: { parts: { size } } }, marker } = this;
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el);
    const max = 150;
    const min = 1;
    const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted, min: min, max: max, step: 1, unitsLabel: this.mergedStrings.px, value: marker.size, onValueChange: this.onSymbolSizeChange, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })), autoSizeAdjust
      ? this.renderAutoAdjust(dir, marker.autoAdjusted, this.mergedStrings.autoAdjustSize, this.onAutoAdjustSizeChange)
      : null));
  }
  renderAutoAdjust(dir, adjusted, label, changeHandler) {
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.autoAdjustLabel, dir: dir, layout: "inline", key: "auto-adjust" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: adjusted, class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.autoAdjustCheckbox, onCalciteCheckboxChange: changeHandler }), label));
  }
  renderSymbolRotationContent() {
    const { marker, mergedStrings } = this;
    const max = 360;
    const min = 0;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.rotation, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: min, max: max, step: 1, unitsLabel: "\u00BA", flipLabels: this.dir === "rtl", value: marker.angle, onValueChange: this.onSymbolRotationChange, withSteppers: !this.narrow, label: mergedStrings.rotation })));
  }
  renderFillBlock() {
    const { fill } = this.config.sections;
    if (fill.type === "color") {
      return this.renderColorFillBlock();
    }
    return this.renderColorRampFillBlock();
  }
  renderColorFillBlock() {
    const section = this.sections.fill;
    const { parts } = section;
    const content = [];
    if (parts.suggestedColors || parts.customColor) {
      content.push({
        content: this.renderFillColorContent()
      });
    }
    if (parts.transparency) {
      content.push({
        content: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: !section.enabled }, this.renderColorFillTransparencyContent(this.mergedStrings.fillTransparency, !section.enabled)))
      });
    }
    return this.renderSection({
      key: "color-fill",
      disabled: section.optional === "non-editable" ||
        this.hasActivePictureMarkerSymbol() ||
        this.hasActiveLineOnlySimpleMarkerSymbol(),
      sectionContent: content
    });
  }
  toColorPickerValue(color) {
    if (!color || (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color)) {
      return null;
    }
    return color.toHex();
  }
  renderFillColorContent() {
    const section = this.sections.fill;
    const color = section.enabled ? this.toColorPickerValue(this.fill.color) : null;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: color,
      //compact={this.narrow}
      clearable: section.optional !== false, onArcgisColorInputChange: (event) => {
        const selectedColor = event.currentTarget.color;
        if (!selectedColor) {
          this.onFillEnabledChange(false);
          // no updates to color needed
          return;
        }
        if (!section.enabled) {
          this.onFillEnabledChange(true);
        }
        const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(selectedColor);
        const { color: currentColor } = this.fill;
        const mergedColor = adjustTransparencyIfNeeded(currentColor, Object.assign(Object.assign(Object.assign({}, currentColor), color), { a: currentColor.a }));
        const mergedFill = {
          color: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(mergedColor)
        };
        this.fill = mergedFill;
        this.arcgisSymbolStylerFillChange.emit(mergedFill);
        this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
        event.stopPropagation();
      }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef })));
  }
  getStrokeString(prop) {
    return this.mergedStrings[this.editGeometry === "line" ? prop : `stroke${capitalize(prop)}`];
  }
  isSupportedSymbolLayerType(type) {
    return (type === "CIMVectorMarker" ||
      type === "CIMSolidFill" ||
      type === "CIMSolidStroke" ||
      type === "CIMHatchFill" ||
      type === "CIMPictureFill" ||
      type === "CIMPictureStroke" ||
      type === "CIMPictureMarker");
  }
  getSymbolLayerPreviewSymbol(symbolLayer, geometryType) {
    var _a;
    const symbolProps = {
      data: {
        type: "CIMSymbolReference",
        symbol: {
          type: geometryType === "point"
            ? "CIMPointSymbol"
            : geometryType === "line"
              ? "CIMLineSymbol"
              : "CIMPolygonSymbol",
          symbolLayers: [symbolLayer]
        }
      }
    };
    if (symbolLayer.type === "CIMVectorMarker") {
      symbolProps.data.symbol.angle = (_a = symbolLayer.rotation) !== null && _a !== void 0 ? _a : 0;
    }
    return new _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.CIMSymbol(symbolProps);
  }
  renderCIMVectorMarkerSymbolLayerBlocks(symbolLayer, key) {
    const { sections: { marker: { parts: { size } }, stroke: { extraParts: { autoStrokeAdjust } } }, marker, mergedStrings } = this;
    const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
    const updateTargetSymbol = this.getSymbolLayerPreviewSymbol(symbolLayer, "point");
    const symbolSize = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolSize(updateTargetSymbol);
    const symbolRotation = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.getCIMSymbolRotation(updateTargetSymbol, true);
    const colorContext = getChildSymbolLayerColorContext(symbolLayer);
    const fillAndStrokeSections = [];
    if (colorContext.includes("fill") && (!this.isFillColorRamp() || symbolLayer.colorLocked)) {
      const fillColor = getVectorMarkerColor(symbolLayer, "fill");
      const fillContent = [
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "fill-color" }, colorContext.length === 1 ? mergedStrings.color : mergedStrings.fillColor, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(fillColor),
          //compact={this.narrow}
          clearable: true, onArcgisColorInputChange: (event) => {
            const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(event.currentTarget.color);
            if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color) && !(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(fillColor)) {
              color.a = fillColor.a;
            }
            updateSymbolLayerColor(symbolLayer, color, "fill");
            this.setInternalSymbol(this.symbol, true);
            event.stopPropagation();
          }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))),
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "fill-transparency" }, colorContext.length === 1 ? mergedStrings.transparency : mergedStrings.fillTransparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", flipLabels: this.percentLabelFlip, value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(fillColor.a), onValueChange: (transparency) => {
            const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(transparency);
            const color = fillColor.clone();
            color.a = alpha;
            updateSymbolLayerColor(symbolLayer, color, "fill");
            this.setInternalSymbol(this.symbol, true);
          }, withSteppers: !this.narrow, label: colorContext.length === 1
            ? mergedStrings.transparency
            : mergedStrings.fillTransparency }))
      ];
      fillAndStrokeSections.push(fillContent);
    }
    if (colorContext.includes("stroke")) {
      const strokeColor = getVectorMarkerColor(symbolLayer, "stroke");
      const strokeWidth = getVectorMarkerSize(symbolLayer, "stroke");
      const strokeContent = [
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-color" }, colorContext.length === 1 ? mergedStrings.color : mergedStrings.strokeColor, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(strokeColor),
          //compact={this.narrow}
          clearable: true, onArcgisColorInputChange: (event) => {
            const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(event.currentTarget.color);
            if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color) && !(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(strokeColor)) {
              color.a = strokeColor.a;
            }
            updateSymbolLayerColor(symbolLayer, color, "stroke");
            this.setInternalSymbol(this.symbol, true);
            event.stopPropagation();
          }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))),
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-transparency" }, colorContext.length === 1
          ? mergedStrings.transparency
          : mergedStrings.strokeTransparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", flipLabels: this.percentLabelFlip, value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(strokeColor.a), onValueChange: (transparency) => {
            const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(transparency);
            const color = strokeColor.clone();
            color.a = alpha;
            updateSymbolLayerColor(symbolLayer, color, "stroke");
            this.setInternalSymbol(this.symbol, true);
          }, withSteppers: !this.narrow, label: colorContext.length === 1
            ? mergedStrings.transparency
            : mergedStrings.strokeTransparency })),
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-width" }, colorContext.length === 1 ? mergedStrings.width : mergedStrings.strokeWidth, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoStrokeAdjust && autoStrokeAdjust !== "editable" && this.stroke.autoAdjusted, min: this.cimStrokeWidthBounds.min, max: this.cimStrokeWidthBounds.max, step: 1, unitsLabel: mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(strokeWidth)), onValueChange: (width) => {
            updateSymbolLayerSize(symbolLayer, normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(width)), "stroke");
            this.setInternalSymbol(this.symbol, true);
          }, withSteppers: !this.narrow, label: colorContext.length === 1 ? mergedStrings.width : mergedStrings.strokeWidth }))
      ];
      fillAndStrokeSections.push(strokeContent);
    }
    const content = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup, key: `${key}__vector-marker-symbol-layer` }, [...fillAndStrokeSections], (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.symbolSize, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolSize)), onValueChange: (size) => {
        this.setMarkerSymbolLayerSize(updateTargetSymbol, size);
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: mergedStrings.symbolSize })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.rotation, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.r, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.l, step: 1, unitsLabel: "\u00BA", flipLabels: this.dir === "rtl", value: normalizePxOrPt(symbolRotation), onValueChange: (rotation) => {
        _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.applyCIMSymbolRotation(updateTargetSymbol, normalizePxOrPt(rotation), true);
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: mergedStrings.rotation })), this.renderCIMMarkerPlacementSection(symbolLayer)));
    const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(this.sanitizePointPreviewSymbolLayer(symbolLayer), "point");
    return this.renderBlock({
      icon: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__symbol-layer-preview`, symbol: symbolLayerPreview, options: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.p, slot: "icon" })),
      key: `${key}__symbol-layer`,
      heading: mergedStrings.vectorMarker,
      content
    });
  }
  setMarkerSymbolLayerSize(symbol, size) {
    if ((0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.m)(this.activeSymbol)) {
      symbol.data.symbol.symbolLayers[0].size = normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(size));
    }
    else {
      _color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.cimSymbolUtils.scaleCIMSymbolTo(symbol, normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(size)));
    }
  }
  renderCIMSolidFillSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
    const fillColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(symbolLayer.color, true);
    const noFillColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(fillColor);
    let colorContent = null;
    let transparencyContent = null;
    if (!this.isFillColorRamp() || symbolLayer.colorLocked) {
      colorContent = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(fillColor),
        //compact={this.narrow}
        clearable: true, onArcgisColorInputChange: (event) => {
          const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(event.currentTarget.color);
          if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color) && !noFillColor) {
            color.a = fillColor.a;
          }
          symbolLayer.color = color.toJSON();
          this.setInternalSymbol(this.symbol, true);
          event.stopPropagation();
        }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))));
      transparencyContent = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(fillColor.a), disabled: noFillColor, onValueChange: (transparency) => {
          const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(transparency);
          const color = fillColor.clone();
          color.a = alpha;
          symbolLayer.color = color.toJSON();
          this.setInternalSymbol(this.symbol, true);
        }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })));
    }
    const content = colorContent || transparencyContent ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__solid-fill-symbol-layer-content` }, colorContent, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noFillColor }, transparencyContent))) : ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.emptySymbolLayerMsg));
    if (contentOnly) {
      return content;
    }
    const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(symbolLayer, "polygon");
    return this.renderBlock({
      icon: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__solid-fill-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
      heading: this.mergedStrings.solidFill,
      key: `${key}__solid-fill-symbol-layer`,
      content
    });
  }
  renderCIMSolidStrokeSymbolLayerBlock(symbolLayer, key, contentOnly = false, parentSymbolLayer) {
    const strokeColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(symbolLayer.color, true);
    const withinHatchFillSymbolLayer = (parentSymbolLayer === null || parentSymbolLayer === void 0 ? void 0 : parentSymbolLayer.type) === "CIMHatchFill";
    const overriddenByColorRamp = withinHatchFillSymbolLayer && this.isFillColorRamp();
    const autoStrokeAdjust = this.sections.stroke.extraParts.autoStrokeAdjust;
    const noStrokeColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(strokeColor);
    let colorContent = null;
    let transparencyContent = null;
    if (!this.isStrokeColorRamp() || symbolLayer.colorLocked) {
      colorContent = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-color" }, contentOnly ? this.mergedStrings.strokeColor : this.mergedStrings.color, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(strokeColor),
        //compact={this.narrow}
        clearable: true, onArcgisColorInputChange: (event) => {
          const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(event.currentTarget.color);
          if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color) && !noStrokeColor) {
            color.a = strokeColor.a;
          }
          symbolLayer.color = color.toJSON();
          this.setInternalSymbol(this.symbol, true);
          event.stopPropagation();
        }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))));
      transparencyContent = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { key: "stroke-transparency" }, contentOnly ? this.mergedStrings.strokeTransparency : this.mergedStrings.transparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(strokeColor.a), disabled: noStrokeColor, onValueChange: (transparency) => {
          const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(transparency);
          const color = strokeColor.clone();
          color.a = alpha;
          symbolLayer.color = color.toJSON();
          this.setInternalSymbol(this.symbol, true);
        }, withSteppers: !this.narrow, label: contentOnly ? this.mergedStrings.strokeTransparency : this.mergedStrings.transparency })));
    }
    const content = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__solid-stroke-symbol-layer-content` }, overriddenByColorRamp ? null : colorContent, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noStrokeColor }, overriddenByColorRamp ? null : transparencyContent, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, contentOnly ? this.mergedStrings.strokeWidth : this.mergedStrings.width, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noStrokeColor ||
        (autoStrokeAdjust && autoStrokeAdjust !== "editable" && this.stroke.autoAdjusted), min: this.cimStrokeWidthBounds.min, max: this.cimStrokeWidthBounds.max, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.width)), onValueChange: (width) => {
        symbolLayer.width = normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(width));
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: contentOnly ? this.mergedStrings.strokeWidth : this.mergedStrings.width }))), withinHatchFillSymbolLayer
      ? this.renderCIMHatchFillPatternSection(parentSymbolLayer)
      : null));
    if (contentOnly) {
      return content;
    }
    const symbolLayerPreview = withinHatchFillSymbolLayer
      ? this.getSymbolLayerPreviewSymbol(Object.assign(Object.assign({}, parentSymbolLayer), { lineSymbol: {
          type: "CIMLineSymbol",
          symbolLayers: [symbolLayer]
        } }), "polygon")
      : this.getSymbolLayerPreviewSymbol(symbolLayer, "line");
    return this.renderBlock({
      icon: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__solid-stroke-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
      heading: withinHatchFillSymbolLayer
        ? this.mergedStrings.hatchFill
        : this.mergedStrings.solidStroke,
      key: `${key}__solid-stroke-symbol-layer`,
      content
    });
  }
  renderCIMHatchFillSymbolLayerBlocks(symbolLayer, key) {
    return this.renderCIMSymbolLayersContent(symbolLayer.lineSymbol, `${key}__hatch-symbol-fill-symbol-layers`, false, symbolLayer).flat();
  }
  renderCIMHatchFillPatternSection(symbolLayer) {
    var _a, _b, _c;
    const { mergedStrings } = this;
    const fillOffset = (_a = symbolLayer.offsetX) !== null && _a !== void 0 ? _a : 0; // we apply offset uniformly, so we use take X
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { key: "hatch-fill-pattern", text: mergedStrings.pattern }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.rotation, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.dir === "rtl", max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.l, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.r, onValueChange: (rotation) => {
        symbolLayer.rotation = Math.abs(rotation);
        this.setInternalSymbol(this.symbol, true);
      }, step: 1, unitsLabel: "\u00BA", value: (_b = symbolLayer.rotation) !== null && _b !== void 0 ? _b : 0, withSteppers: !this.narrow, label: mergedStrings.rotation })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.separation, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.dir === "rtl", max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.v, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.w, onValueChange: (separation) => {
        symbolLayer.separation = separation;
        this.setInternalSymbol(this.symbol, true);
      }, step: 1, value: (_c = symbolLayer.separation) !== null && _c !== void 0 ? _c : 0, unitsLabel: mergedStrings.px, withSteppers: !this.narrow, label: mergedStrings.separation })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.offset, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.dir === "rtl", max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.t, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.u, onValueChange: (offset) => {
        symbolLayer.offsetX = offset;
        symbolLayer.offsetY = offset;
        this.setInternalSymbol(this.symbol, true);
      }, step: 1, value: fillOffset, unitsLabel: mergedStrings.px, withSteppers: !this.narrow, label: mergedStrings.offset }))));
  }
  renderCIMPictureMarkerSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
    const tintColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(symbolLayer.tintColor, true);
    const { sections: { marker: { parts: { size } } }, marker } = this;
    const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
    const updateTargetSymbol = this.getSymbolLayerPreviewSymbol(symbolLayer, "point");
    const noTintColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(tintColor);
    const content = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { key: `${key}__picture-marker-symbol-layer` }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__picture-marker-symbol-layer-content` }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(tintColor),
      //compact={this.narrow}
      clearable: true, onArcgisColorInputChange: (event) => {
        const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(event.currentTarget.color);
        if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color) && !noTintColor) {
          color.a = tintColor.a;
        }
        symbolLayer.tintColor = color.toJSON();
        this.setInternalSymbol(this.symbol, true);
        event.stopPropagation();
      }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noTintColor }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(tintColor.a), disabled: noTintColor, onValueChange: (transparency) => {
        const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(transparency);
        const color = tintColor.clone();
        color.a = alpha;
        symbolLayer.tintColor = color.toJSON();
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noTintColor ||
        (autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted), min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.size)), onValueChange: (size) => {
        this.setMarkerSymbolLayerSize(updateTargetSymbol, size);
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })))), this.renderCIMMarkerPlacementSection(symbolLayer), this.renderCIMPictureMarkerAnimationSection(symbolLayer)));
    if (contentOnly) {
      return content;
    }
    const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(this.sanitizePointPreviewSymbolLayer(symbolLayer), "point");
    return this.renderBlock({
      icon: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__solid-fill-symbol-layer-preview`, symbol: symbolLayerPreview, options: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.p, slot: "icon" })),
      heading: this.mergedStrings.pictureMarker,
      key: `${key}__picture-marker-symbol-layer`,
      content
    });
  }
  sanitizePointPreviewSymbolLayer(symbolLayer) {
    return Object.assign(Object.assign({}, symbolLayer), {
      // ensure markerPlacement is not set on CIM point symbols symbol layer for proper preview
      markerPlacement: undefined
    });
  }
  renderCIMPictureStrokeSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
    const tintColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(symbolLayer.tintColor, true);
    const { sections: { marker: { parts: { size } } }, marker } = this;
    const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
    const noTintColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(tintColor);
    const content = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__picture-stroke-symbol-layer-content` }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(tintColor),
      //compact={this.narrow}
      clearable: true, onArcgisColorInputChange: (event) => {
        const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(event.currentTarget.color);
        if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color) && !noTintColor) {
          color.a = tintColor.a;
        }
        symbolLayer.tintColor = color.toJSON();
        this.setInternalSymbol(this.symbol, true);
        event.stopPropagation();
      }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noTintColor }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(tintColor.a), disabled: noTintColor, onValueChange: (transparency) => {
        const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(transparency);
        const color = tintColor.clone();
        color.a = alpha;
        symbolLayer.tintColor = color.toJSON();
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noTintColor ||
        (autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted), min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.width)), onValueChange: (width) => {
        symbolLayer.width = normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(width));
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })))));
    if (contentOnly) {
      return content;
    }
    const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(symbolLayer, "line");
    return this.renderBlock({
      icon: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__picture-stroke-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
      heading: this.mergedStrings.pictureStroke,
      key: `${key}__picture-stroke-symbol-layer`,
      content
    });
  }
  renderCIMPictureFillSymbolLayerBlock(symbolLayer, key, contentOnly = false) {
    const tintColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(symbolLayer.tintColor, true);
    const { sections: { marker: { parts: { size } } }, marker } = this;
    const autoSizeAdjust = typeof size === "object" && (size === null || size === void 0 ? void 0 : size.autoSizeAdjust);
    const noTintColor = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(tintColor);
    const content = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, key: `${key}__picture-fill-symbol-layer-content` }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillColor, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "input-color" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: this.toColorPickerValue(tintColor),
      //compact={this.narrow}
      clearable: true, onArcgisColorInputChange: (event) => {
        const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(event.currentTarget.color);
        if (!(0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.k)(color) && !noTintColor) {
          color.a = tintColor.a;
        }
        symbolLayer.tintColor = color.toJSON();
        this.setInternalSymbol(this.symbol, true);
        event.stopPropagation();
      }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef }))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: noTintColor }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.o, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.k, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(tintColor.a), disabled: noTintColor, onValueChange: (transparency) => {
        const alpha = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.t)(transparency);
        const color = tintColor.clone();
        color.a = alpha;
        symbolLayer.tintColor = color.toJSON();
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.symbolSize, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: noTintColor ||
        (autoSizeAdjust && autoSizeAdjust !== "editable" && marker.autoAdjusted), min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.n, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.q, step: 1, unitsLabel: this.mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(symbolLayer.height)), onValueChange: (height) => {
        symbolLayer.height = normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(height));
        this.setInternalSymbol(this.symbol, true);
      }, withSteppers: !this.narrow, label: this.mergedStrings.symbolSize })))));
    if (contentOnly) {
      return content;
    }
    const symbolLayerPreview = this.getSymbolLayerPreviewSymbol(symbolLayer, "polygon");
    return this.renderBlock({
      icon: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-symbol-preview", { contrast: true, key: `${key}__picture-fill-symbol-layer-preview`, symbol: symbolLayerPreview, slot: "icon" })),
      heading: this.mergedStrings.pictureFill,
      key: `${key}__picture-fill-symbol-layer`,
      content
    });
  }
  renderCIMPictureMarkerAnimationSection(symbolLayer) {
    var _a, _b, _c;
    const { dir, mergedStrings } = this;
    const { animatedSymbolProperties } = symbolLayer;
    if (animatedSymbolProperties) {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { key: "picture-marker-animation", text: mergedStrings.animation }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, layout: "inline" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: animatedSymbolProperties.playAnimation, onCalciteCheckboxChange: (event) => {
          const { checked } = event.currentTarget;
          animatedSymbolProperties.playAnimation = checked;
          this.setInternalSymbol(this.symbol, true);
        } }), mergedStrings.playAnimation), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, layout: "inline" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: animatedSymbolProperties.reverseAnimation, onCalciteCheckboxChange: (event) => {
          const { checked } = event.currentTarget;
          animatedSymbolProperties.reverseAnimation = checked;
          this.setInternalSymbol(this.symbol, true);
        } }), mergedStrings.reverseAnimation), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.startTimeOffset, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { onCalciteSegmentedControlChange: (event) => {
          const value = event.currentTarget.value;
          animatedSymbolProperties.randomizeStartTime = value === "random";
          this.setInternalSymbol(this.symbol, true);
        } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "random", checked: animatedSymbolProperties.randomizeStartTime }, mergedStrings.randomized), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "manual", checked: !animatedSymbolProperties.randomizeStartTime }, mergedStrings.manualOffset))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.manualOffset, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: animatedSymbolProperties.randomizeStartTime, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.x, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.y, onValueChange: (offset) => {
          animatedSymbolProperties.startTimeOffset = offset;
          this.setInternalSymbol(this.symbol, true);
        }, step: 1, value: (_a = animatedSymbolProperties.startTimeOffset) !== null && _a !== void 0 ? _a : 0, withSteppers: !this.narrow, label: mergedStrings.manualOffset })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.duration, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.x, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.y, onValueChange: (duration) => {
          animatedSymbolProperties.duration = duration;
          this.setInternalSymbol(this.symbol, true);
        }, step: 1, value: (_b = animatedSymbolProperties.duration) !== null && _b !== void 0 ? _b : 0, withSteppers: !this.narrow, label: mergedStrings.duration })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.repeatType, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { onCalciteSegmentedControlChange: (event) => {
          const type = event.currentTarget
            .value;
          animatedSymbolProperties.repeatType = type;
          this.setInternalSymbol(this.symbol, true);
        } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "None", checked: animatedSymbolProperties.repeatType === "None" }, mergedStrings.none), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Loop", checked: animatedSymbolProperties.repeatType === "Loop" }, mergedStrings.loop), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Oscillate", checked: animatedSymbolProperties.repeatType === "Oscillate" }, mergedStrings.oscillate))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.repeatDelay, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.x, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.y, onValueChange: (delay) => {
          animatedSymbolProperties.repeatDelay = delay;
          this.setInternalSymbol(this.symbol, true);
        }, step: 1, value: (_c = animatedSymbolProperties.repeatDelay) !== null && _c !== void 0 ? _c : 0, withSteppers: !this.narrow, label: mergedStrings.repeatDelay }))));
    }
    else {
      return null;
    }
  }
  renderCIMMarkerPlacementSection(symbolLayer) {
    const { dir, mergedStrings } = this;
    const { markerPlacement } = symbolLayer;
    if ((markerPlacement === null || markerPlacement === void 0 ? void 0 : markerPlacement.type) === "CIMMarkerPlacementInsidePolygon" &&
      ((markerPlacement === null || markerPlacement === void 0 ? void 0 : markerPlacement.gridType) === "Random" || (markerPlacement === null || markerPlacement === void 0 ? void 0 : markerPlacement.gridType) === "Fixed")) {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block-section", { key: "marker-placement", text: mergedStrings.markerPlacement }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.gridType, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { onCalciteSegmentedControlChange: (event) => {
          const value = event.currentTarget
            .value;
          markerPlacement.gridType = value;
          this.setInternalSymbol(this.symbol, true);
        } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Fixed", checked: markerPlacement.gridType === "Fixed" }, mergedStrings.fixed), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "Random", checked: markerPlacement.gridType === "Random" }, mergedStrings.random))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.randomness, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: markerPlacement.gridType === "Fixed", flipLabels: this.percentLabelFlip, max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.B, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.D, onValueChange: (randomness) => {
          markerPlacement.randomness = randomness;
          this.setInternalSymbol(this.symbol, true);
        }, step: 1, value: markerPlacement.randomness, unitsLabel: "%", withSteppers: !this.narrow, label: mergedStrings.randomness })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.stepX, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.z, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.A, onValueChange: (step) => {
          markerPlacement.stepX = normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(step));
          this.setInternalSymbol(this.symbol, true);
        }, step: 1, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(markerPlacement.stepX)), unitsLabel: mergedStrings.px, withSteppers: !this.narrow, label: mergedStrings.stepX })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mergedStrings.stepY, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { max: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.z, min: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.A, onValueChange: (step) => {
          markerPlacement.stepY = normalizePt(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.px2pt(step));
          this.setInternalSymbol(this.symbol, true);
        }, step: 1, unitsLabel: mergedStrings.px, value: normalizePx(_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.e.screenUtils.pt2px(markerPlacement.stepY)), withSteppers: !this.narrow, label: mergedStrings.stepY })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, layout: "inline" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: markerPlacement.shiftOddRows && markerPlacement.gridType === "Fixed", disabled: markerPlacement.gridType === "Random", onCalciteCheckboxChange: (event) => {
          const { checked } = event.currentTarget;
          markerPlacement.shiftOddRows = checked;
          this.setInternalSymbol(this.symbol, true);
        } }), mergedStrings.shiftOddRows)));
    }
    else {
      return null;
    }
  }
  renderColorFillTransparencyContent(label, disabled) {
    var _a;
    const { fill } = this;
    const max = 100;
    const min = 0;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, label, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)((_a = fill.color) === null || _a === void 0 ? void 0 : _a.a), onValueChange: this.onColorFillTransparencyChange, withSteppers: !this.narrow, disabled: disabled, label: label })));
  }
  renderColorRampFillBlock(embedded = false) {
    const section = this.sections.fill;
    const { parts } = section;
    const shouldHide = this.hasActivePictureMarkerSymbol() || this.hasActiveLineOnlySimpleMarkerSymbol();
    if (shouldHide) {
      return null;
    }
    const content = [];
    if (parts.colorRamps) {
      content.push({
        content: this.renderFillColorRampsContent()
      });
    }
    if (parts.transparency) {
      content.push({
        content: this.renderColorRampFillTransparencyContent()
      });
    }
    return this.renderSection({
      key: "color-ramp-fill",
      disabled: section.optional === "non-editable",
      embedded,
      sectionContent: content
    });
  }
  renderFillColorRampsContent() {
    const { style } = this.config.sections.fill;
    const { activeCategory, colorRamps } = this.sections.fill;
    return this.renderRampsContent({
      style,
      activeCategory,
      colorRampStops: this.fill.color,
      colorRamps,
      heading: this.mergedStrings.fillColor,
      onCategoryChange: this.onFillColorRampCategoryChange,
      isSelected: (colorRamp) => {
        const currentColorRamp = this.fill.color;
        return equal(currentColorRamp, colorRamp.stops, style === "2d");
      },
      onSelect: (event) => {
        const { detail: colorRamp } = event;
        const color = colorRamp.stops.slice();
        const { fill } = this;
        const mergedFill = Object.assign(Object.assign({}, fill), { color });
        this.fill = mergedFill;
        this.tempStrokeColorRampStateStops = color;
        this.arcgisSymbolStylerFillChange.emit(mergedFill);
        this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
        event.stopPropagation();
      },
      onFlip: this.flipFillColorRamps
    });
  }
  renderRampsContent(options) {
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, options.heading, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-color-ramp-input", { options: options, strings: this.mergedStrings, popoverProps: this.popoverProps, style: {
        "--scroller-max-height": "var(--ramp-scroller-max-height)"
      }, ref: this.setRampInputRef })));
  }
  renderColorRampFillTransparencyContent() {
    const { fill } = this;
    const max = 100;
    const min = 0;
    const color = fill.color[0];
    // for CIM symbols this might be a rgba array
    const alpha = color.length === 4 ? color[3] / 255 : color.a;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.mergedStrings.fillTransparency, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(alpha), onValueChange: this.onColorRampFillTransparencyChange, withSteppers: !this.narrow, label: this.mergedStrings.fillTransparency })));
  }
  renderStrokeBlock() {
    const { stroke } = this.config.sections;
    if (stroke.type === "color") {
      return this.renderColorStrokeBlock();
    }
    return this.renderColorRampStrokeBlock();
  }
  renderColorStrokeBlock() {
    const sections = this.sections;
    const section = sections.stroke;
    const { parts } = section;
    const content = [];
    if (parts.suggestedColors || parts.customColor) {
      content.push({
        content: this.renderStrokeColorsContent()
      });
    }
    if (parts.transparency || parts.extra) {
      const innerContent = [];
      if (parts.transparency) {
        innerContent.push(this.showingRampOptionsInStroke()
          ? this.renderColorRampStrokeTransparencyContent(!section.enabled)
          : this.renderColorStrokeTransparencyContent(!section.enabled));
      }
      if (parts.extra) {
        innerContent.push(this.renderStrokeExtraContent(!section.enabled));
      }
      content.push({
        content: ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-section", { embedded: true, disabled: !section.enabled }, innerContent))
      });
    }
    return this.renderSection({
      key: "color-stroke",
      disabled: section.optional === "non-editable" || this.hasActivePictureMarkerSymbol(),
      sectionContent: content
    });
  }
  renderStrokeColorRampsContent() {
    const { style } = this.config.sections.stroke;
    const { activeCategory, colorRamps } = this.sections.stroke;
    return this.renderRampsContent({
      style,
      activeCategory,
      colorRampStops: this.stroke.color,
      colorRamps,
      heading: this.getStrokeString("color"),
      onCategoryChange: this.onStrokeColorRampCategoryChange,
      isSelected: (colorRamp) => {
        const currentColorRamp = this.stroke.color;
        return equal(currentColorRamp, colorRamp.stops);
      },
      onSelect: (event) => {
        const { detail: colorRamp } = event;
        const color = colorRamp.stops.slice();
        const { stroke } = this;
        const mergedStroke = Object.assign(Object.assign({}, stroke), { color });
        this.stroke = mergedStroke;
        this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
        this.setInternalSymbol(this.syncSymbolProps(this.symbol, { cimChangeContext: "root" }), true);
        event.stopPropagation();
      },
      onFlip: this.flipStrokeColorRamps
    });
  }
  showingRampOptionsInStroke() {
    const strokeSectionConfig = this.config.sections.stroke;
    const shouldShowFillColorsForOutline = isLineOnlySymbol(this.activeSymbol);
    const fillType = this.sections.fill.type;
    return (shouldShowFillColorsForOutline &&
      fillType === "color-ramp" &&
      strokeSectionConfig.type === "color");
  }
  renderStrokeColorsContent() {
    const strokeSection = this.sections.stroke;
    if (this.showingRampOptionsInStroke()) {
      const activeCategory = this.tempStrokeColorRampStateActiveCategory;
      const { style } = this.config.sections.fill;
      const { colorRamps } = this.sections.fill;
      return this.renderRampsContent({
        style,
        activeCategory,
        colorRampStops: this.tempStrokeColorRampStateStops,
        colorRamps,
        heading: this.getStrokeString("color"),
        onCategoryChange: (event) => {
          const dropdown = event.currentTarget;
          const activeCategory = dropdown.selectedItems[0].getAttribute("data-value");
          this.tempStrokeColorRampStateActiveCategory = activeCategory;
          event.stopPropagation();
        },
        isSelected: (colorRamp) => {
          const currentColorRampStops = this.tempStrokeColorRampStateStops;
          return equal(currentColorRampStops, colorRamp.stops);
        },
        onSelect: (event) => {
          const { detail: colorRamp } = event;
          const color = colorRamp.stops.slice();
          const { stroke } = this;
          const mergedStroke = Object.assign(Object.assign({}, stroke), { color });
          this.stroke = mergedStroke;
          this.tempStrokeColorRampStateStops = color;
          this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
          this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
          event.stopPropagation();
        },
        onFlip: this.flipFillColorRamps
      });
    }
    const color = strokeSection.enabled
      ? this.toColorPickerValue(this.stroke.color)
      : null;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.getStrokeString("color"), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-color-input", { color: color,
      //compact={this.narrow}
      clearable: strokeSection.optional !== false, onArcgisColorInputChange: (event) => {
        const selectedColor = event.currentTarget.color;
        if (!selectedColor) {
          this.onStrokeEnabledChange(false);
          // no updates to color needed
          return;
        }
        if (!strokeSection.enabled) {
          this.onStrokeEnabledChange(true);
        }
        const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(selectedColor);
        const currentColor = this.stroke.color;
        const { stroke } = this;
        const mergedStroke = Object.assign(Object.assign({}, stroke), { color: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.d)(adjustTransparencyIfNeeded(currentColor, Object.assign(Object.assign(Object.assign({}, currentColor), color), { a: currentColor.a }))) });
        this.stroke = mergedStroke;
        this.arcgisSymbolStylerStrokeChange.emit(normalizeSizeProp(mergedStroke));
        this.setInternalSymbol(this.syncSymbolProps(this.symbol), true);
        event.stopPropagation();
      }, popoverProps: this.popoverProps, storageId: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.j, ref: this.setColorInputRef })));
  }
  renderColorStrokeTransparencyContent(disabled) {
    const { stroke } = this;
    const max = 100;
    const min = 0;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.getStrokeString("transparency"), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(stroke.color.a), onValueChange: this.onColorStrokeTransparencyChange, withSteppers: !this.narrow, disabled: disabled, label: this.getStrokeString("transparency") })));
  }
  renderStrokeExtraContent(disabled) {
    var _a, _b;
    const { sections: { stroke: { extraParts: { arrow, autoStrokeAdjust, style, width } } }, stroke } = this;
    const maxWidthInPx = 18;
    const editingLine = this.editGeometry === "line";
    const editingPolygon = this.editGeometry === "polygon";
    const minWidthInPx = editingLine ? 0.1 : 0;
    const isCim = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.i)(this.symbol);
    const canUpdateStyle = !isCim && style && (editingLine || editingPolygon);
    const canUpdateArrows = !isCim && arrow && editingLine;
    const canUpdateWidth = !isCim && width;
    const canUpdateAutoAdjust = !isCim && autoStrokeAdjust;
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__.g)(this.el);
    const currentPlacement = toArrowPlacement(stroke.marker);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.contentGroup }, canUpdateWidth ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, key: "width-options" }, this.getStrokeString("width"), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { disabled: disabled ||
        (autoStrokeAdjust && autoStrokeAdjust !== "editable" && stroke.autoAdjusted), min: minWidthInPx, max: maxWidthInPx, step: 1, unitsLabel: this.mergedStrings.px, value: stroke.size, onValueChange: this.onStrokeWidthChange, withSteppers: !this.narrow, label: this.getStrokeString("width") }))) : null, canUpdateAutoAdjust
      ? this.renderAutoAdjust(dir, stroke.autoAdjusted, this.mergedStrings.autoAdjustStroke, this.onAutoAdjustStrokeChange)
      : null, canUpdateArrows ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, key: "arrow-options" }, this.mergedStrings.arrow, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown", { class: {
        [_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdown]: true,
        [_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.arrowDropdown]: true
      }, onCalciteDropdownSelect: this.onStrokeArrowChange, width: "l", placement: "top-end", "overlay-positioning": (_a = this.popoverProps) === null || _a === void 0 ? void 0 : _a.overlayPositioning, scale: "s" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { role: "button", slot: "trigger", tabIndex: 0 }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { "data-arrow": currentPlacement, class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownSelected, style: this.getSelectedArrowPatternStyle() }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "chevron-down", scale: "s" })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-group", null, _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.s.map((arrow) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: arrow === currentPlacement, "data-arrow": arrow }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownItemContent, "data-arrow": arrow, style: this.getArrowPatternOptionStyle() })))))))) : null, canUpdateStyle ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { dir: dir, key: "pattern-options" }, this.mergedStrings.pattern, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown", { class: {
        [_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdown]: true,
        [_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.styleDropdown]: true
      }, onCalciteDropdownSelect: this.onStrokeStyleChange, width: "l", placement: "top-end", "overlay-positioning": (_b = this.popoverProps) === null || _b === void 0 ? void 0 : _b.overlayPositioning, scale: "s" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { role: "button", slot: "trigger", tabIndex: 0 }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownSelected, style: this.getLinePatternStyle(stroke.style) }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "chevron-down", scale: "s" })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-group", null, _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.b.map((style) => {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-dropdown-item", { selected: style === stroke.style, "data-style": style }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { style: this.getLinePatternStyle(style), class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_1__.C.iconDropdownItemContent })));
    }))))) : null));
  }
  renderColorRampStrokeBlock(embedded = false) {
    const section = this.sections.stroke;
    const parts = section.parts;
    const content = [];
    if (parts.colorRamps) {
      content.push({
        content: this.renderStrokeColorRampsContent()
      });
    }
    if (parts.transparency) {
      content.push({
        content: this.renderColorRampStrokeTransparencyContent(section.optional === "non-editable" || this.hasActivePictureMarkerSymbol())
      });
    }
    if (parts.extra) {
      content.push({
        content: this.renderStrokeExtraContent(section.optional === "non-editable" || this.hasActivePictureMarkerSymbol())
      });
    }
    return this.renderSection({
      key: "color-ramp-stroke",
      disabled: section.optional === "non-editable" || this.hasActivePictureMarkerSymbol(),
      embedded,
      sectionContent: content
    });
  }
  renderColorRampStrokeTransparencyContent(disabled) {
    const { stroke } = this;
    const max = 100;
    const min = 0;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.getStrokeString("transparency"), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { flipLabels: this.percentLabelFlip, min: min, max: max, step: 1, unitsLabel: "%", value: (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_2__.l)(stroke.color[0].a), onValueChange: this.onColorRampStrokeTransparencyChange, withSteppers: !this.narrow, disabled: disabled, label: this.getStrokeString("transparency") })));
  }
  checkPopoverMaxHeight() {
    var _a, _b, _c;
    // if not set by caller then calculate the max height for any popover openend by the styler
    if (this.flowEl && this.popoverProps && (!this.popoverProps.maxHeight || this.autoCalcHeight)) {
      this.autoCalcHeight = true;
      const panelRect = this.flowEl.getBoundingClientRect();
      const windowHeight = window.innerHeight ||
        ((_a = document.documentElement) === null || _a === void 0 ? void 0 : _a.clientHeight) ||
        ((_b = document.body) === null || _b === void 0 ? void 0 : _b.clientHeight) ||
        0;
      const spaceToBottom = windowHeight && (panelRect === null || panelRect === void 0 ? void 0 : panelRect.top) ? windowHeight - panelRect.top - 30 : 0;
      this.popoverProps.maxHeight = `${Math.max(spaceToBottom || panelRect.height, 250) -
        ((_c = this.popoverProps.offsetDistance) !== null && _c !== void 0 ? _c : 0) -
        5}px`;
    }
  }
  static get assetsDirs() { return ["assets"]; }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "builtInStrings": ["handleStringChanges"],
    "stringOverrides": ["handleStringChanges"]
  }; }
};
ArcGISSymbolStyler.style = arcgisSymbolStylerCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorRampUtils-7e6d2ad8.js":
/*!********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorRampUtils-7e6d2ad8.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ markerPlacementStepMin),
/* harmony export */   B: () => (/* binding */ markerPlacementRandomnessMax),
/* harmony export */   C: () => (/* binding */ CSS),
/* harmony export */   D: () => (/* binding */ markerPlacementRandomnessMin),
/* harmony export */   E: () => (/* binding */ expand2D),
/* harmony export */   F: () => (/* binding */ categoriesToTags),
/* harmony export */   a: () => (/* binding */ maxWidthInPx),
/* harmony export */   b: () => (/* binding */ supportedStyles),
/* harmony export */   c: () => (/* binding */ defaultVisibleColorSectionParts),
/* harmony export */   d: () => (/* binding */ defaultVisibleMarkerSectionParts),
/* harmony export */   e: () => (/* binding */ defaultVisibleColorRampSectionParts),
/* harmony export */   f: () => (/* binding */ flipColorRampStops),
/* harmony export */   g: () => (/* binding */ defaultVisibleExtraStrokeSectionParts),
/* harmony export */   h: () => (/* binding */ defaultVisibleStrokeSectionParts),
/* harmony export */   i: () => (/* binding */ maxDisplayedSymbolLayers),
/* harmony export */   j: () => (/* binding */ colorStorageId),
/* harmony export */   k: () => (/* binding */ opacityMax),
/* harmony export */   l: () => (/* binding */ rotationMax),
/* harmony export */   m: () => (/* binding */ minWidthInPx),
/* harmony export */   n: () => (/* binding */ sizeMin),
/* harmony export */   o: () => (/* binding */ opacityMin),
/* harmony export */   p: () => (/* binding */ pointPreviewOptions),
/* harmony export */   q: () => (/* binding */ sizeMax),
/* harmony export */   r: () => (/* binding */ rotationMin),
/* harmony export */   s: () => (/* binding */ supportedArrows),
/* harmony export */   t: () => (/* binding */ hatchFillOffsetMax),
/* harmony export */   u: () => (/* binding */ hatchFillOffsetMin),
/* harmony export */   v: () => (/* binding */ hatchFillSeparationMax),
/* harmony export */   w: () => (/* binding */ hatchFillSeparationMin),
/* harmony export */   x: () => (/* binding */ animationDurationMax),
/* harmony export */   y: () => (/* binding */ animationDurationMin),
/* harmony export */   z: () => (/* binding */ markerPlacementStepMax)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
const CSS = {
  customSymbolContent: "custom-symbol-content",
  autoAdjustLabel: "auto-adjust-label",
  styleDropdown: "style-dropdown",
  arrowDropdown: "arrow-dropdown",
  iconDropdown: "icon-dropdown",
  iconDropdownSelected: "icon-dropdown--selected",
  iconDropdownItemContent: "icon-dropdown-item-content",
  colorRampFlipper: "color-ramp-flipper",
  scroller: "scroller",
  colorRampSelection: "color-ramp-selection",
  sectionToggleDisabled: "section-toggle--disabled",
  autoAdjustCheckbox: "auto-adjust-checkbox",
  contentGroup: "content-group",
  colorLockedInfo: "color-locked-info",
  message: "message",
  // symbol button
  container: "container",
  label: "label",
  openIcon: "open-icon",
  symbol: "symbol",
  changeSymbolTrigger: "change-symbol-trigger"
};
const categoriesToTags = {
  all: ["*"],
  light: ["light"],
  dark: ["dark"],
  redsAndYellows: ["oranges", "reds", "yellows"],
  greens: ["greens"],
  blues: ["blues"],
  purplesAndPinks: ["purples", "pinks"],
  browns: ["browns"],
  grays: ["grays"],
  bright: ["bright"],
  subdued: ["subdued"],
  colorblindFriendly: ["colorblind-friendly"]
};
const supportedArrows = ["none", "begin", "end", "begin-end"];
const supportedStyles = [
  "solid",
  "dash",
  "dot",
  "dash-dot",
  "long-dash-dot-dot",
  "short-dash",
  "short-dot",
  "short-dash-dot",
  "short-dash-dot-dot",
  "long-dash",
  "long-dash-dot"
];
const defaultVisibleMarkerSectionParts = {
  size: true,
  preview: true,
  rotation: true
};
const defaultVisibleExtraStrokeSectionParts = {
  style: true,
  arrow: true,
  width: true,
  autoStrokeAdjust: false
};
const defaultVisibleColorSectionParts = {
  suggestedColors: true,
  customColor: true,
  transparency: true
};
const defaultVisibleColorRampSectionParts = {
  colorRamps: true,
  transparency: true
};
const defaultVisibleStrokeSectionParts = {
  extra: true
};
const colorStorageId = "arcgis-symbol-styler-storage-colors";
const pointPreviewOptions = {
  size: 24,
  maxSize: 24
};
const opacityMax = 100;
const opacityMin = 0;
const maxWidthInPx = 18;
const minWidthInPx = 0;
const rotationMax = 360;
const rotationMin = 0;
const sizeMax = 150;
const sizeMin = 1;
const markerPlacementStepMax = 200;
const markerPlacementStepMin = 0;
const markerPlacementRandomnessMax = 100;
const markerPlacementRandomnessMin = 0;
const maxDisplayedSymbolLayers = 10;
const hatchFillSeparationMax = 200;
const hatchFillSeparationMin = 0;
const hatchFillOffsetMax = 100;
const hatchFillOffsetMin = 0;
const animationDurationMax = 120;
const animationDurationMin = 0;

function flipColorRampStops(stops, is2d = false) {
  return is2d ? flipFlattened2DRamp(stops) : stops.slice().reverse();
}
function flipFlattened2DRamp(flat2dStops) {
  const numClasses = Math.sqrt(flat2dStops.length);
  const ramp2d = expand2D(flat2dStops);
  const oldRamp = ramp2d.reverse();
  const flippedRamp = [];
  // Flip 2D matrix of colors by 90 degrees in clockwise direction.
  for (let i = 0; i < numClasses; i++) {
    const newRow = [];
    oldRamp.forEach((oldRow) => newRow.push(oldRow[i]));
    flippedRamp.push(newRow);
  }
  return flatten2D(flippedRamp).reverse();
}
function expand2D(stops, focus) {
  let expandedArray = [];
  const numClasses = Math.sqrt(stops.length);
  // Focus decides whether we reverse the outer/inner arrays or not.
  const codes = (focus || "HH").split("");
  const startRowCode = codes[0];
  const startColCode = codes[1];
  const reverseEachRow = startColCode !== "H";
  for (let i = 0; i < numClasses; i++) {
    let row = [];
    for (let j = 0; j < numClasses; j++) {
      const index = i * numClasses + j;
      row.push(stops[index]);
    }
    if (reverseEachRow) {
      row.reverse();
    }
    expandedArray.push(row);
  }
  if (startRowCode === "L") {
    expandedArray.reverse();
  }
  return expandedArray;
}
function flatten2D(array2d, focus) {
  // Returns a flattened array from the given 2d array.
  // array2d is assumed to have the layout structure outlined at:
  // renderers/utils:getClassValuesForRelationship.
  // Order of elements in the output array is determined by "focus".
  // "focus" can be: HH, HL, LH or LL. Default is "HH".
  let flatArray = [];
  // clone to avoid modifying source data
  array2d = array2d.slice().map((colors) => colors.slice());
  // Focus decides whether we reverse the outer/inner arrays or not.
  const codes = (focus || "HH").split(""), startRowCode = codes[0], startColCode = codes[1];
  if (startRowCode === "L") {
    array2d.reverse();
  }
  const reverseEachRow = startColCode === "H";
  array2d.forEach((row) => {
    if (reverseEachRow) {
      row.slice().reverse();
    }
    flatArray = flatArray.concat(row);
  });
  return flatArray;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWQ5OTQ5Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNnSTtBQUMrckI7QUFDMWdCO0FBQzdPO0FBQ2dDO0FBQ3RCO0FBQ3JCO0FBQ2xDOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyxpREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVpMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtc3ltYm9sLXN0eWxlci5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9jb2xvclJhbXBVdGlscy03ZTZkMmFkOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGgsIHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgYSBhcyBnZXRBc3NldFBhdGgsIEggYXMgSG9zdCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5pbXBvcnQgeyBtIGFzIG1pbldpZHRoSW5QeCwgYSBhcyBtYXhXaWR0aEluUHgsIGYgYXMgZmxpcENvbG9yUmFtcFN0b3BzLCBzIGFzIHN1cHBvcnRlZEFycm93cywgYiBhcyBzdXBwb3J0ZWRTdHlsZXMsIGQgYXMgZGVmYXVsdFZpc2libGVNYXJrZXJTZWN0aW9uUGFydHMsIGMgYXMgZGVmYXVsdFZpc2libGVDb2xvclNlY3Rpb25QYXJ0cywgZSBhcyBkZWZhdWx0VmlzaWJsZUNvbG9yUmFtcFNlY3Rpb25QYXJ0cywgZyBhcyBkZWZhdWx0VmlzaWJsZUV4dHJhU3Ryb2tlU2VjdGlvblBhcnRzLCBoIGFzIGRlZmF1bHRWaXNpYmxlU3Ryb2tlU2VjdGlvblBhcnRzLCBpIGFzIG1heERpc3BsYXllZFN5bWJvbExheWVycywgQyBhcyBDU1MsIHAgYXMgcG9pbnRQcmV2aWV3T3B0aW9ucywgaiBhcyBjb2xvclN0b3JhZ2VJZCwgbyBhcyBvcGFjaXR5TWluLCBrIGFzIG9wYWNpdHlNYXgsIHIgYXMgcm90YXRpb25NaW4sIGwgYXMgcm90YXRpb25NYXgsIG4gYXMgc2l6ZU1pbiwgcSBhcyBzaXplTWF4LCB0IGFzIGhhdGNoRmlsbE9mZnNldE1heCwgdSBhcyBoYXRjaEZpbGxPZmZzZXRNaW4sIHYgYXMgaGF0Y2hGaWxsU2VwYXJhdGlvbk1heCwgdyBhcyBoYXRjaEZpbGxTZXBhcmF0aW9uTWluLCB4IGFzIGFuaW1hdGlvbkR1cmF0aW9uTWF4LCB5IGFzIGFuaW1hdGlvbkR1cmF0aW9uTWluLCB6IGFzIG1hcmtlclBsYWNlbWVudFN0ZXBNYXgsIEEgYXMgbWFya2VyUGxhY2VtZW50U3RlcE1pbiwgQiBhcyBtYXJrZXJQbGFjZW1lbnRSYW5kb21uZXNzTWF4LCBEIGFzIG1hcmtlclBsYWNlbWVudFJhbmRvbW5lc3NNaW4gfSBmcm9tICcuL2NvbG9yUmFtcFV0aWxzLTdlNmQyYWQ4LmpzJztcbmltcG9ydCB7IGUgYXMgZXNyaU1vZHVsZXMsIGkgYXMgaXNDSU1TeW1ib2wsIGEgYXMgaXNTTVNTeW1ib2wsIGIgYXMgaXNTRlNTeW1ib2wsIGMgYXMgaXNTTFNTeW1ib2wsIHQgYXMgdHJhbnNwYXJlbmN5VG9BbHBoYSwgZCBhcyBjcmVhdGUsIGYgYXMgaXNQTVNTeW1ib2wsIGcgYXMgaXNQb2x5Z29uQ0lNLCBoIGFzIGdlb21ldHJ5VHlwZSwgaiBhcyBpc0xpbmVDSU0sIGsgYXMgaXNOdWxsRXF1aXZhbGVudENvbG9yLCBsIGFzIGFscGhhVG9UcmFuc3BhcmVuY3ksIG0gYXMgaXNQb2ludENJTSB9IGZyb20gJy4vY29sb3ItNzc2Njg5ZTkuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWJvdW5jZSwgYyBhcyB0aHJvdHRsZSB9IGZyb20gJy4vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MsIGEgYXMgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIH0gZnJvbSAnLi9sb2NhbGUtMTNlMDBhNzUuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyLCBDIGFzIENTU19VVElMSVRZIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYWFmMzBiZDYuanMnO1xuaW1wb3J0ICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5cbmZ1bmN0aW9uIGVxdWFsKHJhbXBTdG9wczEsIHJhbXBTdG9wczIsIG1hdGNoQWxwaGEgPSBmYWxzZSwgcmV2ZXJzZSA9IHRydWUpIHtcbiAgaWYgKCFyYW1wU3RvcHMxIHx8ICFyYW1wU3RvcHMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVxdWFsTWF0Y2ggPSByYW1wU3RvcHMxLmV2ZXJ5KChjb2xvcjEsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgY29sb3IyID0gcmFtcFN0b3BzMltpbmRleF07XG4gICAgcmV0dXJuIChjb2xvcjEuciA9PT0gY29sb3IyLnIgJiYgY29sb3IxLmcgPT09IGNvbG9yMi5nICYmIGNvbG9yMS5iID09PSBjb2xvcjIuYiAmJiAoIW1hdGNoQWxwaGEgfHwgY29sb3IxLmEgPT09IGNvbG9yMi5hKSk7XG4gIH0pO1xuICBpZiAoIXJldmVyc2UpIHtcbiAgICByZXR1cm4gZXF1YWxNYXRjaDtcbiAgfVxuICByZXR1cm4gZXF1YWxNYXRjaCB8fCBlcXVhbChyYW1wU3RvcHMxLnNsaWNlKCkucmV2ZXJzZSgpLCByYW1wU3RvcHMyLCBtYXRjaEFscGhhLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGNpbVN5bWJvbFdhbGtlcihzeW1ib2wsIG9uVmlzaXQpIHtcbiAgcmV0dXJuIHZpc2l0KHN5bWJvbCwgb25WaXNpdCk7XG59XG5mdW5jdGlvbiB2aXNpdChub2RlLCBvblZpc2l0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBjb25zdCByZXN1bHQgPSB2aXNpdChjaGlsZCwgb25WaXNpdCk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG9uVmlzaXQobm9kZSk7XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJjaW1cIikge1xuICAgIHJldHVybiB2aXNpdChub2RlLmRhdGEuc3ltYm9sLCBvblZpc2l0KTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIkNJTVN5bWJvbFJlZmVyZW5jZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1NYXJrZXJHcmFwaGljXCIpIHtcbiAgICByZXR1cm4gdmlzaXQobm9kZS5zeW1ib2wsIG9uVmlzaXQpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNUG9pbnRTeW1ib2xcIiB8fCBub2RlLnR5cGUgPT09IFwiQ0lNUG9seWdvblN5bWJvbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1MaW5lU3ltYm9sXCIpIHtcbiAgICByZXR1cm4gdmlzaXQobm9kZS5zeW1ib2xMYXllcnMsIG9uVmlzaXQpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNSGF0Y2hGaWxsXCIpIHtcbiAgICByZXR1cm4gdmlzaXQobm9kZS5saW5lU3ltYm9sLCBvblZpc2l0KTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIkNJTVZlY3Rvck1hcmtlclwiKSB7XG4gICAgcmV0dXJuIHZpc2l0KG5vZGUubWFya2VyR3JhcGhpY3MsIG9uVmlzaXQpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNUGljdHVyZU1hcmtlclwiIHx8XG4gICAgbm9kZS50eXBlID09PSBcIkNJTVRleHRTeW1ib2xcIiB8fFxuICAgIG5vZGUudHlwZSA9PT0gXCJDSU1HcmFkaWVudEZpbGxcIiB8fFxuICAgIG5vZGUudHlwZSA9PT0gXCJDSU1HcmFkaWVudFN0cm9rZVwiIHx8XG4gICAgbm9kZS50eXBlID09PSBcIkNJTU9iamVjdE1hcmtlcjNEXCIgfHxcbiAgICBub2RlLnR5cGUgPT09IFwiQ0lNQ2hhcmFjdGVyTWFya2VyXCIgfHxcbiAgICBub2RlLnR5cGUgPT09IFwiQ0lNTWF0ZXJpYWxTeW1ib2xMYXllclwiIHx8XG4gICAgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVTdHJva2VcIiB8fFxuICAgIG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlRmlsbFwiIHx8XG4gICAgbm9kZS50eXBlID09PSBcIkNJTVNvbGlkRmlsbFwiIHx8XG4gICAgbm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpIHtcbiAgICAvKiBlbmQgb2YgdGhlIGxpbmUg4oCTIGludGVudGlvbmFsIG5vLW9wICovXG4gICAgcmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVTeW1ib2xMYXllckNvbG9yKHN5bWJvbExheWVyLCBjb2xvciwgY29udGV4dCkge1xuICBjb25zdCBjb2xvckpTT04gPSBjb2xvci50b0pTT04oKTtcbiAgY2ltU3ltYm9sV2Fsa2VyKHN5bWJvbExheWVyLCAobm9kZSkgPT4ge1xuICAgIGlmIChjb250ZXh0ID09PSBcImZpbGxcIikge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1Tb2xpZEZpbGxcIikge1xuICAgICAgICBub2RlLmNvbG9yID0gY29sb3JKU09OO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlRmlsbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlTWFya2VyXCIpIHtcbiAgICAgICAgbm9kZS50aW50Q29sb3IgPSBjb2xvckpTT047XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpIHtcbiAgICAgICAgbm9kZS5jb2xvciA9IGNvbG9ySlNPTjtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNUGljdHVyZVN0cm9rZVwiKSB7XG4gICAgICAgIG5vZGUudGludENvbG9yID0gY29sb3JKU09OO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGlsZFN5bWJvbExheWVyQ29sb3JDb250ZXh0KHN5bWJvbExheWVyKSB7XG4gIGNvbnN0IG9ic2VydmVkVHlwZXMgPSBuZXcgU2V0KCk7XG4gIG9ic2VydmVkVHlwZXMuYWRkKGNpbVN5bWJvbFdhbGtlcihzeW1ib2xMYXllciwgKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkRmlsbFwiIHx8XG4gICAgICBub2RlLnR5cGUgPT09IFwiQ0lNSGF0Y2hGaWxsXCIgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlRmlsbFwiIHx8XG4gICAgICBub2RlLnR5cGUgPT09IFwiQ0lNUGljdHVyZU1hcmtlclwiKSB7XG4gICAgICByZXR1cm4gXCJmaWxsXCI7XG4gICAgfVxuICB9KSk7XG4gIG9ic2VydmVkVHlwZXMuYWRkKGNpbVN5bWJvbFdhbGtlcihzeW1ib2xMYXllciwgKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVTdHJva2VcIikge1xuICAgICAgcmV0dXJuIFwic3Ryb2tlXCI7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiBBcnJheS5mcm9tKG9ic2VydmVkVHlwZXMpLmZpbHRlcihCb29sZWFuKTtcbn1cbmZ1bmN0aW9uIGdldFZlY3Rvck1hcmtlckNvbG9yKHZlY3Rvck1hcmtlclN5bWJvbExheWVyLCBjb250ZXh0KSB7XG4gIGNvbnN0IGNvbG9ySlNPTiA9IGNpbVN5bWJvbFdhbGtlcih2ZWN0b3JNYXJrZXJTeW1ib2xMYXllciwgKG5vZGUpID0+IHtcbiAgICBpZiAoY29udGV4dCA9PT0gXCJmaWxsXCIpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNU29saWRGaWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29sb3I7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVGaWxsXCIgfHwgbm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVNYXJrZXJcIikge1xuICAgICAgICByZXR1cm4gbm9kZS50aW50Q29sb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSBcInN0cm9rZVwiKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29sb3I7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVBpY3R1cmVTdHJva2VcIikge1xuICAgICAgICByZXR1cm4gbm9kZS50aW50Q29sb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVzcmlNb2R1bGVzLkNvbG9yLmZyb21KU09OKGNvbG9ySlNPTik7XG59XG5mdW5jdGlvbiBnZXRWZWN0b3JNYXJrZXJTaXplKHZlY3Rvck1hcmtlclN5bWJvbExheWVyLCBjb250ZXh0KSB7XG4gIGxldCBzaXplID0gMDtcbiAgY2ltU3ltYm9sV2Fsa2VyKHZlY3Rvck1hcmtlclN5bWJvbExheWVyLCAobm9kZSkgPT4ge1xuICAgIGlmIChjb250ZXh0ID09PSBcImZpbGxcIikge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1WZWN0b3JNYXJrZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiQ0lNUGljdHVyZU1hcmtlclwiKSB7XG4gICAgICAgIGlmIChub2RlLnNpemUgPiBzaXplKSB7XG4gICAgICAgICAgc2l6ZSA9IG5vZGUuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gXCJzdHJva2VcIikge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDSU1Tb2xpZFN0cm9rZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlU3Ryb2tlXCIpIHtcbiAgICAgICAgaWYgKG5vZGUud2lkdGggPiBzaXplKSB7XG4gICAgICAgICAgc2l6ZSA9IG5vZGUud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN5bWJvbExheWVyU2l6ZShzeW1ib2xMYXllciwgc2l6ZSwgY29udGV4dCkge1xuICBjaW1TeW1ib2xXYWxrZXIoc3ltYm9sTGF5ZXIsIChub2RlKSA9PiB7XG4gICAgaWYgKGNvbnRleHQgPT09IFwiZmlsbFwiKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkNJTVZlY3Rvck1hcmtlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJDSU1QaWN0dXJlTWFya2VyXCIpIHtcbiAgICAgICAgbm9kZS5zaXplID0gc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT09IFwic3Ryb2tlXCIpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ0lNU29saWRTdHJva2VcIiB8fCBub2RlLnR5cGUgPT09IFwiQ0lNUGljdHVyZVN0cm9rZVwiKSB7XG4gICAgICAgIG5vZGUud2lkdGggPSBzaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDSU1TdHJva2VXaWR0aEJvdW5kcygpIHtcbiAgLy8gd2lkdGggc2hvdWxkIGFsd2F5cyB1c2UgbWluV2lkdGhJblB4L21heFdpZHRoSW5QeFxuICAvLyBleGNlcHQgZm9yIENJTVBpY3R1cmVTdHJva2UgdGhlcmUgd2UgdHJlYXQgdGhlbSBhcyBtYXJrZXIgc2l6ZXMgd2l0aCBzaXplTWluL3NpemVNYXhcbiAgcmV0dXJuIHsgbWluOiBtaW5XaWR0aEluUHgsIG1heDogbWF4V2lkdGhJblB4IH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUVkaXRhYmxlKHN5bWJvbCkge1xuICBpZiAoIXN5bWJvbCkge1xuICAgIHJldHVybiBcIm1pc3Npbmcgc3ltYm9sIHRvIGVkaXRcIjtcbiAgfVxuICBpZiAoc3ltYm9sLnR5cGUgPT09IFwidGV4dFwiIHx8IHN5bWJvbC50eXBlID09PSBcInBpY3R1cmUtZmlsbFwiKSB7XG4gICAgcmV0dXJuIGBlZGl0aW5nIHN5bWJvbCBvZiB0eXBlICR7c3ltYm9sLnR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgO1xuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RUcmFuc3BhcmVuY3lJZk5lZWRlZChwcmV2aW91cywgbmV4dCkge1xuICBpZiAocHJldmlvdXMuYSA9PT0gMCkge1xuICAgIG5leHQuYSA9IDE7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0ZpbGwoc3ltYm9sKSB7XG4gIHJldHVybiAoKGlzQ0lNU3ltYm9sKHN5bWJvbCkgJiYgKGlzTVZDb21wYXRpYmxlKHN5bWJvbCkgfHwgaXNGaWxsT25seUNJTShzeW1ib2wpKSkgfHxcbiAgICAoaXNTTVNTeW1ib2woc3ltYm9sKSAmJiAhaXNMaW5lT25seVN5bWJvbChzeW1ib2wpKSB8fFxuICAgIGlzU0ZTU3ltYm9sKHN5bWJvbCkpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNTdHJva2Uoc3ltYm9sKSB7XG4gIHJldHVybiAoKGlzQ0lNU3ltYm9sKHN5bWJvbCkgJiYgaXNNVkNvbXBhdGlibGUoc3ltYm9sKSkgfHwgaXNTTVNTeW1ib2woc3ltYm9sKSB8fCBpc1NMU1N5bWJvbChzeW1ib2wpIHx8IGlzU0ZTU3ltYm9sKHN5bWJvbCkpO1xufVxuZnVuY3Rpb24gaXNMaW5lT25seVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuICEhKChzeW1ib2wgPT09IG51bGwgfHwgc3ltYm9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2wudHlwZSkgPT09IFwic2ltcGxlLW1hcmtlclwiICYmIChzeW1ib2wuc3R5bGUgPT09IFwieFwiIHx8IHN5bWJvbC5zdHlsZSA9PT0gXCJjcm9zc1wiKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTaXplUHJvcChwYXlsb2FkV2l0aFNpemVQcm9wLCBuZXdTaXplID0gcGF5bG9hZFdpdGhTaXplUHJvcC5zaXplKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWRXaXRoU2l6ZVByb3ApLCB7IHNpemU6IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KG5ld1NpemUpKSB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB4T3JQdChweE9yUHQpIHtcbiAgY29uc3QgZnJhY3Rpb25EaWdpdHMgPSBOdW1iZXIuaXNJbnRlZ2VyKHB4T3JQdCkgPyAwIDogMjtcbiAgcmV0dXJuIE51bWJlcihweE9yUHQudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHgocHhPclB0KSB7XG4gIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gTnVtYmVyLmlzSW50ZWdlcihweE9yUHQpID8gMCA6IDI7XG4gIHJldHVybiBOdW1iZXIocHhPclB0LnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB0KHB4T3JQdCkge1xuICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IE51bWJlci5pc0ludGVnZXIocHhPclB0KSA/IDAgOiAzO1xuICByZXR1cm4gTnVtYmVyKHB4T3JQdC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG59XG5mdW5jdGlvbiBwYXJzZVNpemUoc2l6ZSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuICFpc05hTihzaXplKSA/IG5vcm1hbGl6ZVB4T3JQdChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweChzaXplKSkgOiBmYWxsYmFjaztcbn1cbmZ1bmN0aW9uIGdldFN5bWJvbFJvdGF0aW9uKHN5bWJvbCkge1xuICB2YXIgX2E7XG4gIGlmICghc3ltYm9sIHx8IHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIgfHwgc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWZpbGxcIikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBpc0NJTVN5bWJvbChzeW1ib2wpID8gZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuZ2V0Q0lNU3ltYm9sUm90YXRpb24oc3ltYm9sLCB0cnVlKSA6IChfYSA9IHN5bWJvbC5hbmdsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbn1cbmZ1bmN0aW9uIGlzQ0lNVGV4dFN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbC50eXBlID09PSBcIkNJTVRleHRTeW1ib2xcIjtcbn1cbmZ1bmN0aW9uIGlzTVZDb21wYXRpYmxlKHN5bWJvbCkge1xuICBpZiAoaXNDSU1UZXh0U3ltYm9sKHN5bWJvbC5kYXRhLnN5bWJvbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBzeW1ib2xMYXllcnMgfSA9IHN5bWJvbC5kYXRhLnN5bWJvbDtcbiAgaWYgKHN5bWJvbExheWVycy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBbZmlyc3RdID0gc3ltYm9sTGF5ZXJzO1xuICAgIGlmIChmaXJzdC50eXBlICE9PSBcIkNJTVZlY3Rvck1hcmtlclwiIHx8IGZpcnN0LmNvbG9yTG9ja2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgbWFya2VyR3JhcGhpY3MgfSA9IGZpcnN0O1xuICAgIHJldHVybiAobWFya2VyR3JhcGhpY3MubGVuZ3RoID09PSAxICYmXG4gICAgICAhaXNDSU1UZXh0U3ltYm9sKG1hcmtlckdyYXBoaWNzWzBdLnN5bWJvbCkgJiZcbiAgICAgIGhhc1VubG9ja2VkRmlsbEFuZFN0cm9rZShtYXJrZXJHcmFwaGljc1swXS5zeW1ib2wuc3ltYm9sTGF5ZXJzKSk7XG4gIH1cbiAgaWYgKHN5bWJvbExheWVycy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBbZmlyc3QsIHNlY29uZF0gPSBzeW1ib2xMYXllcnM7XG4gICAgaWYgKGZpcnN0LnR5cGUgIT09IFwiQ0lNVmVjdG9yTWFya2VyXCIgfHxcbiAgICAgIHNlY29uZC50eXBlICE9PSBcIkNJTVZlY3Rvck1hcmtlclwiIHx8XG4gICAgICBmaXJzdC5jb2xvckxvY2tlZCB8fFxuICAgICAgZmlyc3Quc2l6ZSA+IHNlY29uZC5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0TWFya2VyR3JhcGhpY3MgPSBmaXJzdC5tYXJrZXJHcmFwaGljcztcbiAgICBjb25zdCBzZWNvbmRNYXJrZXJHcmFwaGljcyA9IHNlY29uZC5tYXJrZXJHcmFwaGljcztcbiAgICBpZiAoZmlyc3RNYXJrZXJHcmFwaGljcy5sZW5ndGggIT09IDEgfHwgc2Vjb25kTWFya2VyR3JhcGhpY3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IFt7IHN5bWJvbDogZmlyc3RNYXJrZXJHcmFwaGljU3ltYm9sIH1dID0gZmlyc3RNYXJrZXJHcmFwaGljcztcbiAgICBjb25zdCBbeyBzeW1ib2w6IHNlY29uZE1hcmtlckdyYXBoaWNTeW1ib2wgfV0gPSBzZWNvbmRNYXJrZXJHcmFwaGljcztcbiAgICByZXR1cm4gKGZpcnN0TWFya2VyR3JhcGhpY1N5bWJvbCAmJlxuICAgICAgc2Vjb25kTWFya2VyR3JhcGhpY1N5bWJvbCAmJlxuICAgICAgIWlzQ0lNVGV4dFN5bWJvbChmaXJzdE1hcmtlckdyYXBoaWNTeW1ib2wpICYmXG4gICAgICAhaXNDSU1UZXh0U3ltYm9sKHNlY29uZE1hcmtlckdyYXBoaWNTeW1ib2wpICYmXG4gICAgICBoYXNVbmxvY2tlZEZpbGxBbmRTdHJva2UoZmlyc3RNYXJrZXJHcmFwaGljU3ltYm9sLnN5bWJvbExheWVycykgJiZcbiAgICAgIGhhc0ZpbGxBbmRTdHJva2Uoc2Vjb25kTWFya2VyR3JhcGhpY1N5bWJvbC5zeW1ib2xMYXllcnMpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0ZpbGxPbmx5Q0lNKHN5bWJvbCkge1xuICByZXR1cm4gISFlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5nZXRDSU1TeW1ib2xDb2xvcihzeW1ib2wpO1xufVxuZnVuY3Rpb24gaGFzVW5sb2NrZWRGaWxsQW5kU3Ryb2tlKHN5bWJvbExheWVycykge1xuICByZXR1cm4gaGFzVW5sb2NrZWRGaWxsKHN5bWJvbExheWVycykgJiYgaGFzU3Ryb2tlKHN5bWJvbExheWVycyk7XG59XG5mdW5jdGlvbiBoYXNGaWxsQW5kU3Ryb2tlKHN5bWJvbExheWVycykge1xuICByZXR1cm4gaGFzRmlsbChzeW1ib2xMYXllcnMpICYmIGhhc1N0cm9rZShzeW1ib2xMYXllcnMpO1xufVxuZnVuY3Rpb24gaGFzRmlsbChzeW1ib2xMYXllcnMpIHtcbiAgcmV0dXJuICEhKHN5bWJvbExheWVycyA9PT0gbnVsbCB8fCBzeW1ib2xMYXllcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbExheWVycy5maW5kKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gXCJDSU1Tb2xpZEZpbGxcIikpO1xufVxuZnVuY3Rpb24gaGFzVW5sb2NrZWRGaWxsKHN5bWJvbExheWVycykge1xuICByZXR1cm4gISFnZXRVbmxvY2tlZEZpbGwoc3ltYm9sTGF5ZXJzKTtcbn1cbmZ1bmN0aW9uIGdldFVubG9ja2VkRmlsbChzeW1ib2xMYXllcnMpIHtcbiAgcmV0dXJuIHN5bWJvbExheWVycyA9PT0gbnVsbCB8fCBzeW1ib2xMYXllcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbExheWVycy5maW5kKCh7IHR5cGUsIGNvbG9yTG9ja2VkIH0pID0+IHR5cGUgPT09IFwiQ0lNU29saWRGaWxsXCIgJiYgIWNvbG9yTG9ja2VkKTtcbn1cbmZ1bmN0aW9uIGhhc1N0cm9rZShzeW1ib2xMYXllcnMpIHtcbiAgcmV0dXJuICEhZ2V0U3Ryb2tlKHN5bWJvbExheWVycyk7XG59XG5mdW5jdGlvbiBnZXRTdHJva2Uoc3ltYm9sTGF5ZXJzKSB7XG4gIHJldHVybiBzeW1ib2xMYXllcnMgPT09IG51bGwgfHwgc3ltYm9sTGF5ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2xMYXllcnMuZmluZCgoeyB0eXBlIH0pID0+IHR5cGUgPT09IFwiQ0lNU29saWRTdHJva2VcIik7XG59XG5mdW5jdGlvbiBzdXBwb3J0c091dGxpbmVXaWR0aChzeW1ib2wpIHtcbiAgdmFyIF9hO1xuICAvLyBDSU0gbXVzdCBoYXZlIGEgc3Ryb2tlXG4gIGNvbnN0IGhhc1N0cm9rZSA9IChfYSA9IHN5bWJvbC5kYXRhLnN5bWJvbC5zeW1ib2xMYXllcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKCh7IHR5cGUgfSkgPT4gW1wiQ0lNU29saWRTdHJva2VcIiwgXCJDSU1QaWN0dXJlU3Ryb2tlXCJdLmluZGV4T2YodHlwZSkgPiAtMSk7XG4gIHJldHVybiAhIWhhc1N0cm9rZTtcbn1cbmZ1bmN0aW9uIGdldE91dGxpbmVXaWR0aChzeW1ib2wpIHtcbiAgdmFyIF9hLCBfYjtcbiAgLy8ganVzdCB0YWtlIGZpcnN0IHN0cm9rZVxuICBjb25zdCBzdHJva2UgPSAoX2EgPSBzeW1ib2wuZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoc3ltYm9sTGF5ZXIpID0+IFtcIkNJTVNvbGlkU3Ryb2tlXCIsIFwiQ0lNUGljdHVyZVN0cm9rZVwiXS5pbmRleE9mKHN5bWJvbExheWVyLnR5cGUpID4gLTEpO1xuICByZXR1cm4gKF9iID0gc3Ryb2tlLndpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xufVxuZnVuY3Rpb24gc2V0T3V0bGluZVdpZHRoKHN5bWJvbCwgd2lkdGgpIHtcbiAgdmFyIF9hO1xuICAvLyBkb24ndCB1c2Ugc2NhbGVDSU1TeW1ib2xUbygpIGJlY2F1c2UgaXQgYWxzbyBzY2FsZXMgbWFya2Vycywgc2VwYXJhdGlvbiwgLi4uIG9mIHRoZSBDSU1cbiAgLy8gYXBwbHkgd2lkdGggdG8gYWxsIHN0cm9rZXMgaW5zaWRlIHRoZSBDSU1cbiAgKF9hID0gc3ltYm9sLmRhdGEuc3ltYm9sLnN5bWJvbExheWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHN5bWJvbExheWVyKSA9PiB7XG4gICAgaWYgKFtcIkNJTVNvbGlkU3Ryb2tlXCIsIFwiQ0lNUGljdHVyZVN0cm9rZVwiXS5pbmRleE9mKHN5bWJvbExheWVyLnR5cGUpID4gLTEpIHtcbiAgICAgIHN5bWJvbExheWVyLndpZHRoID0gd2lkdGg7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQXJyb3dNYXJrZXIobWFya2VyKSB7XG4gIHJldHVybiBzdXBwb3J0ZWRBcnJvd3MuaW5jbHVkZXMobWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLnBsYWNlbWVudCkgJiYgKG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5zdHlsZSkgPT09IFwiYXJyb3dcIjtcbn1cbmZ1bmN0aW9uIHRvQXJyb3dQbGFjZW1lbnQobWFya2VyKSB7XG4gIGlmICghbWFya2VyKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIHJldHVybiBpc0Fycm93TWFya2VyKG1hcmtlcikgPyBtYXJrZXIucGxhY2VtZW50IDogXCJub25lXCI7XG59XG5mdW5jdGlvbiB0b0Fycm93TWFya2VyKHBsYWNlbWVudCkge1xuICBpZiAocGxhY2VtZW50ID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogXCJhcnJvd1wiLFxuICAgIHBsYWNlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVDb2xvclJhbXBzKHNlY3Rpb24sIHN0cm9rZU9yRmlsbFByb3BzKSB7XG4gIGlmIChzZWN0aW9uICYmIHN0cm9rZU9yRmlsbFByb3BzICYmIGhhczJEQ29sb3JSYW1wKHNlY3Rpb24pKSB7XG4gICAgY29uc3Qgcm90YXRpb25zVG9NYXRjaCA9IGdldFJvdGF0aW9uc1RvTWF0Y2hTZWxlY3RlZChzdHJva2VPckZpbGxQcm9wcy5jb2xvciwgc2VjdGlvbi5jb2xvclJhbXBzKTtcbiAgICBpZiAocm90YXRpb25zVG9NYXRjaCA+IDApIHtcbiAgICAgIHJldHVybiBzZWN0aW9uLmNvbG9yUmFtcHMubWFwKChyYW1wKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbXBDbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIHJhbXApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdGF0aW9uc1RvTWF0Y2g7IGkrKykge1xuICAgICAgICAgIHJhbXBDbG9uZS5zdG9wcyA9IGZsaXBDb2xvclJhbXBTdG9wcyhyYW1wQ2xvbmUuc3RvcHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW1wQ2xvbmU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlY3Rpb24gPT09IG51bGwgfHwgc2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VjdGlvbi5jb2xvclJhbXBzO1xufVxuZnVuY3Rpb24gaGFzMkRDb2xvclJhbXAoc2VjdGlvbikge1xuICByZXR1cm4gKHNlY3Rpb24gPT09IG51bGwgfHwgc2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VjdGlvbi50eXBlKSA9PT0gXCJjb2xvci1yYW1wXCIgJiYgc2VjdGlvbi5zdHlsZSA9PT0gXCIyZFwiO1xufVxuZnVuY3Rpb24gZ2V0Um90YXRpb25zVG9NYXRjaFNlbGVjdGVkKHNlbGVjdGVkLCBjb2xvclJhbXBzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb2xvclJhbXBzLm1hcCgocmFtcCkgPT4gcmFtcC5zdG9wcyk7XG4gIGNvbnN0IG1heFJvdGF0aW9ucyA9IDQ7XG4gIGxldCBzZWxlY3RlZENsb25lID0gc2VsZWN0ZWQubWFwKChjb2xvcikgPT4gY29sb3IuY2xvbmUoKSk7XG4gIGxldCB0b3RhbFJvdGF0aW9uc09uU2VsZWN0ZWQgPSAwO1xuICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFJvdGF0aW9uczsgaSsrKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBvcHRpb25zLnNvbWUoKG9wdGlvbikgPT4gZXF1YWwoc2VsZWN0ZWRDbG9uZSwgb3B0aW9uLCB0cnVlLCBmYWxzZSkpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VsZWN0ZWRDbG9uZSA9IGZsaXBDb2xvclJhbXBTdG9wcyhzZWxlY3RlZENsb25lLCB0cnVlKTtcbiAgICB0b3RhbFJvdGF0aW9uc09uU2VsZWN0ZWQrKztcbiAgfVxuICByZXR1cm4gbWF0Y2hlZCA/IChtYXhSb3RhdGlvbnMgLSB0b3RhbFJvdGF0aW9uc09uU2VsZWN0ZWQpICUgbWF4Um90YXRpb25zIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcGl0YWxpemUodGV4dCkge1xuICByZXR1cm4gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBnZXRTeW1ib2xMYWJlbChzeW1ib2wsIHN0cmluZ3MpIHtcbiAgaWYgKCFzeW1ib2wpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiB8fCBzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICByZXR1cm4gc3RyaW5ncy5iYXNpY1BvaW50O1xuICB9XG4gIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiKSB7XG4gICAgcmV0dXJuIHN0cmluZ3MuYmFzaWNMaW5lO1xuICB9XG4gIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgcmV0dXJuIHN0cmluZ3MuYmFzaWNQb2x5Z29uO1xuICB9XG4gIGlmIChzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2ludFN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIHN0cmluZ3MudmVjdG9yUG9pbnQ7XG4gIH1cbiAgaWYgKHN5bWJvbC5kYXRhLnN5bWJvbC50eXBlID09PSBcIkNJTUxpbmVTeW1ib2xcIikge1xuICAgIHJldHVybiBzdHJpbmdzLnZlY3RvckxpbmU7XG4gIH1cbiAgaWYgKHN5bWJvbC5kYXRhLnN5bWJvbC50eXBlID09PSBcIkNJTVBvbHlnb25TeW1ib2xcIikge1xuICAgIHJldHVybiBzdHJpbmdzLnZlY3RvclBvbHlnb247XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc3ltYm9sIHByb3ZpZGVkXCIpO1xufVxuXG5jb25zdCBTZWxlY3RDU1MgPSB7XG4gIGJhc2U6IFwic2VsZWN0LW51bWJlclwiLFxuICBpbnB1dDogXCJzZWxlY3QtbnVtYmVyX19pbnB1dFwiXG59O1xuY29uc3Qgc3RlcHBlckNsaWNrSGFuZGxlckZvclByb3BlckZvY3VzID0gKGV2ZW50KSA9PiB7XG4gIC8vIHdvcmthcm91bmQgZm9yIGNhbGNpdGUtbGFiZWwgd3JhcHBlZCBTZWxlY3ROdW1iZXIgZm9jdXMgYnVnXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcbmNvbnN0IFNlbGVjdE51bWJlciA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGRpc2FibGVkLCBmbGlwTGFiZWxzID0gZmFsc2UsIG1pbiwgbWF4LCBzdGVwLCB1bml0c0xhYmVsLCB2YWx1ZSwgd2l0aFN0ZXBwZXJzID0gdHJ1ZSwgbGFiZWwgfSA9IHByb3BzO1xuICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogU2VsZWN0Q1NTLmJhc2UgfSxcbiAgICBoKFwiY2FsY2l0ZS1zbGlkZXJcIiwgeyBkaXNhYmxlZDogZGlzYWJsZWQsIG1pbjogbWluLCBtYXg6IG1heCwgdmFsdWU6IHZhbHVlLCBzdGVwOiBzdGVwLCBvbkNhbGNpdGVTbGlkZXJJbnB1dDogKGV2ZW50KSA9PiBhcHBseVZhbHVlT25DaGFuZ2UoZXZlbnQudGFyZ2V0LCBwcm9wcykgfSksXG4gICAgaChcImNhbGNpdGUtaW5wdXRcIiwgeyBjbGFzczogU2VsZWN0Q1NTLmlucHV0LCBkaXNhYmxlZDogZGlzYWJsZWQsIG1heDogbWF4LCBtaW46IG1pbiwgbnVtYmVyQnV0dG9uVHlwZTogd2l0aFN0ZXBwZXJzID8gXCJ2ZXJ0aWNhbFwiIDogXCJub25lXCIsIHByZWZpeFRleHQ6IGZsaXBMYWJlbHMgPyB1bml0c0xhYmVsIDogXCJcIiwgb25DYWxjaXRlSW5wdXRJbnB1dDogKGV2ZW50KSA9PiBhcHBseVZhbHVlT25DaGFuZ2UoZXZlbnQudGFyZ2V0LCBwcm9wcyksIG9uQ2xpY2s6IHN0ZXBwZXJDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cywgc2NhbGU6IFwic1wiLCBzdGVwOiBcImFueVwiLCBzdWZmaXhUZXh0OiBmbGlwTGFiZWxzID8gXCJcIiA6IHVuaXRzTGFiZWwsIHR5cGU6IFwibnVtYmVyXCIsIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLCBsYWJlbDogbGFiZWwgfSkpKTtcbn07XG5jb25zdCBhcHBseVZhbHVlT25DaGFuZ2UgPSBkZWJvdW5jZSgobm9kZSwgcHJvcHMpID0+IHtcbiAgZGVib3VuY2VkQXBwbHlWYWx1ZU9uQ2hhbmdlKG5vZGUsIHByb3BzKTtcbn0sIDgwMCk7XG5mdW5jdGlvbiBkZWJvdW5jZWRBcHBseVZhbHVlT25DaGFuZ2Uobm9kZSwgcHJvcHMpIHtcbiAgY29uc3QgdmFsdWUgPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1pbihwcm9wcy5tYXgsIE1hdGgubWF4KHByb3BzLm1pbiwgdmFsdWUpKTtcbiAgaWYgKHZhbHVlID09PSBwcm9wcy52YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBub2RlLnZhbHVlID0gYCR7Y2xhbXBlZH1gOyAvLyBlbnN1cmUgdmFsdWUgaXMgd2l0aGluIGFsbG93ZWQgcmFuZ2VcbiAgcHJvcHMub25WYWx1ZUNoYW5nZShjbGFtcGVkKTtcbn1cblxuY29uc3QgYXJjZ2lzU3ltYm9sU3R5bGVyQ3NzID0gXCIuc2VsZWN0LW51bWJlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3Bvc2l0aW9uOnJlbGF0aXZlfS5zZWxlY3QtbnVtYmVyIGNhbGNpdGUtc2xpZGVye3dpZHRoOjUwJX0uc2VsZWN0LW51bWJlcl9faW5wdXR7d2lkdGg6NDUlO2ZvbnQtc2l6ZTp2YXIoLS1hcmNnaXMtYXBwLWZvbnQtc2l6ZS0wKTtmb250LWZhbWlseTp2YXIoLS1hcmNnaXMtYXBwLWZvbnQtZmFtaWx5KX1idXR0b257b3ZlcmZsb3c6aGlkZGVuO2JhY2tncm91bmQtY29sb3I6dmFyKC0tYXJjZ2lzLXN5bWJvbC1zdHlsZXItaW5saW5lLWlucHV0LXRyaWdnZXItYmFja2dyb3VuZC1jb2xvcik7YWxpZ24taXRlbXM6Y2VudGVyO2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6MDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTpmbGV4O2ZvbnQtZmFtaWx5OmluaGVyaXQ7Z2FwOjhweDtoZWlnaHQ6MTAwJTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7b3V0bGluZS1vZmZzZXQ6MDtwYWRkaW5nOjNweCAwO3BhZGRpbmctaW5saW5lOjNweCA4cHg7cG9zaXRpb246cmVsYXRpdmU7dGV4dC1kZWNvcmF0aW9uOm5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3RleHQtYWxpZ246Y2VudGVyOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO3dpZHRoOjEwMCV9YnV0dG9uOmZvY3Vze291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO291dGxpbmUtb2Zmc2V0OjJweH1idXR0b246aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9Omhvc3R7bWluLXdpZHRoOjI0MHB4O2hlaWdodDotbW96LW1pbi1jb250ZW50O2hlaWdodDptaW4tY29udGVudDtkaXNwbGF5OmZsZXg7ZmxleDoxIDEgYXV0bztmbGV4LWZsb3c6Y29sdW1uIG5vd3JhcDthbGlnbi1pdGVtczpzdHJldGNofWNhbGNpdGUtZHJvcGRvd257d2lkdGg6MTAwJX1jYWxjaXRlLWZsb3d7aGVpZ2h0OjEwMCV9LmNvbG9yLWxvY2tlZC1pbmZve2Rpc3BsYXk6ZmxleDtnYXA6NHB4O21hcmdpbjo4cHggMDthbGlnbi1pdGVtczpjZW50ZXJ9LmNvbG9yLWxvY2tlZC1pbmZvIGNhbGNpdGUtaWNvbntjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMyl9Lmljb24tZHJvcGRvd257cGFkZGluZzowLjI1cmVtIDAgMCAwO3dpZHRoOjEwMCU7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hcmNnaXMtYXBwLWJhY2tncm91bmQpO2hlaWdodDoyLjI1cmVtO2JvcmRlcjoxcHggc29saWQgI2E5YTlhOTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMDc1KX0uaWNvbi1kcm9wZG93bi0tc2VsZWN0ZWR7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWxlZnQ6MTJweDtoZWlnaHQ6M3B4O3dpZHRoOjEwMCV9Lmljb24tZHJvcGRvd24gLmljb24tZHJvcGRvd24taXRlbS1jb250ZW50LC5pY29uLWRyb3Bkb3duLS1zZWxlY3RlZHtiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlcjtiYWNrZ3JvdW5kLWNsaXA6Y29udGVudC1ib3g7YmFja2dyb3VuZC1vcmlnaW46Y29udGVudC1ib3g7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowfS5pY29uLWRyb3Bkb3duIC5pY29uLWRyb3Bkb3duLWl0ZW0tY29udGVudHtoZWlnaHQ6MzBweDt3aWR0aDoyMDBweH0uYXJjZ2lzLS1ydGwgLmljb24tZHJvcGRvd24tLXNlbGVjdGVke21hcmdpbi1yaWdodDoxMnB4fS5zdHlsZS1kcm9wZG93biBbc2xvdD10cmlnZ2VyXXt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXJ9LnN0eWxlLWRyb3Bkb3duIFtzbG90PXRyaWdnZXJdIGNhbGNpdGUtaWNvbnttYXJnaW46OHB4O2JhY2tncm91bmQtY29sb3I6I2ZmZn0uc3R5bGUtZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl0sLnN0eWxlLWRyb3Bkb3duIC5pY29uLWRyb3Bkb3duLWl0ZW0tY29udGVudHtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteH0uYXJyb3ctZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl17d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47YWxpZ24taXRlbXM6Y2VudGVyfS5hcnJvdy1kcm9wZG93biBbc2xvdD10cmlnZ2VyXSAuaWNvbi1kcm9wZG93bi0tc2VsZWN0ZWR7aGVpZ2h0OjMwcHg7YmFja2dyb3VuZC1zaXplOjEwMCUgMTE5cHh9LmFycm93LWRyb3Bkb3duIFtzbG90PXRyaWdnZXJdIGNhbGNpdGUtaWNvbnttYXJnaW46OHB4O2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYXJyb3ctZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl0gLmljb24tZHJvcGRvd24tLXNlbGVjdGVkLC5hcnJvdy1kcm9wZG93biAuaWNvbi1kcm9wZG93bi1pdGVtLWNvbnRlbnR7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0fS5hcnJvdy1kcm9wZG93biBbc2xvdD10cmlnZ2VyXSAuaWNvbi1kcm9wZG93bi0tc2VsZWN0ZWRbZGF0YS1hcnJvdz1ub25lXSwuYXJyb3ctZHJvcGRvd24gLmljb24tZHJvcGRvd24taXRlbS1jb250ZW50W2RhdGEtYXJyb3c9bm9uZV17YmFja2dyb3VuZC1wb3NpdGlvbjowIDB9LmFycm93LWRyb3Bkb3duIFtzbG90PXRyaWdnZXJdIC5pY29uLWRyb3Bkb3duLS1zZWxlY3RlZFtkYXRhLWFycm93PWJlZ2luXSwuYXJyb3ctZHJvcGRvd24gLmljb24tZHJvcGRvd24taXRlbS1jb250ZW50W2RhdGEtYXJyb3c9YmVnaW5de2JhY2tncm91bmQtcG9zaXRpb246MCAtMzJweH0uYXJyb3ctZHJvcGRvd24gW3Nsb3Q9dHJpZ2dlcl0gLmljb24tZHJvcGRvd24tLXNlbGVjdGVkW2RhdGEtYXJyb3c9ZW5kXSwuYXJyb3ctZHJvcGRvd24gLmljb24tZHJvcGRvd24taXRlbS1jb250ZW50W2RhdGEtYXJyb3c9ZW5kXXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTYxcHh9LmFycm93LWRyb3Bkb3duIFtzbG90PXRyaWdnZXJdIC5pY29uLWRyb3Bkb3duLS1zZWxlY3RlZFtkYXRhLWFycm93PWJlZ2luLWVuZF0sLmFycm93LWRyb3Bkb3duIC5pY29uLWRyb3Bkb3duLWl0ZW0tY29udGVudFtkYXRhLWFycm93PWJlZ2luLWVuZF17YmFja2dyb3VuZC1wb3NpdGlvbjowIC05MXB4fS5jb250ZW50LWdyb3Vwe2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmNvbnRlbnQtZ3JvdXAgbGFiZWx7bWFyZ2luOjhweCAwIDAgMH0uY29sb3ItcmFtcC1zZWxlY3Rpb257cGFkZGluZzo0cHh9LnNlY3Rpb24tdG9nZ2xlLS1kaXNhYmxlZHtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MC41fS5zd2F0Y2gtaXRlbXtib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjE2cHg7d2lkdGg6MTZweDtib3JkZXItcmFkaXVzOjJweDtib3gtc2hhZG93OjAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMzMpfWNhbGNpdGUtaW5wdXRbZGlzYWJsZWRdIFtkYXRhLWFkanVzdG1lbnRde3BvaW50ZXItZXZlbnRzOm5vbmV9YXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvbiBjYWxjaXRlLWJsb2Nre292ZXJmbG93OnZpc2libGU7bWFyZ2luOjAgLTEycHh9YXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvbiBjYWxjaXRlLWJsb2NrW29wZW5dOmJlZm9yZXtjb250ZW50OlxcXCJcXFwiO2hlaWdodDoxNnB4O2Rpc3BsYXk6ZmxleDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0yKX1hcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uIGNhbGNpdGUtYmxvY2s6bnRoLW9mLXR5cGUobisxKXtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZjBmMGYwfWFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb24gY2FsY2l0ZS1ibG9jazpsYXN0LWNoaWxke2JvcmRlci1ib3R0b206bm9uZX1hcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uIGNhbGNpdGUtYmxvY2sgYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvbjpudGgtb2YtdHlwZSgyKXttYXJnaW4tdG9wOjEycHh9Y2FsY2l0ZS1wYW5lbHtvdmVyZmxvdzp2aXNpYmxlO21hcmdpbi10b3A6MH0uaW5wdXQtY29sb3J7ZmxleC13cmFwOm5vd3JhcDtnYXA6OHB4O2FsaWduLWl0ZW1zOmNlbnRlcn1jYWxjaXRlLXRvb2x0aXB7bWF4LXdpZHRoOjI1MHB4fWNhbGNpdGUtdG9vbHRpcDpub3QoW29wZW5dKXt2aXNpYmlsaXR5OmhpZGRlbjtwb2ludGVyLWV2ZW50czpub25lfS5tZXNzYWdle21hcmdpbi10b3A6OHB4fWFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3W3Nsb3Q9aWNvbl17d2lkdGg6MzJweDtoZWlnaHQ6MzJweDtwYWRkaW5nOjJweDtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmNvbnRhaW5lcntkaXNwbGF5OmZsZXg7cGFkZGluZzo4cHggMTJweDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoxMDAlO2dhcDo4cHg7ZmxleC1ncm93OjF9LnN5bWJvbHtoZWlnaHQ6MzJweDtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LmxhYmVse2ZsZXgtZ3JvdzoxO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH0uY2hhbmdlLXN5bWJvbC10cmlnZ2Vye2JvcmRlcjoxcHggc29saWQgIzk0OTQ5NH0uc3ltYm9sLXNlbGVjdGlvbi1wYW5lbHttaW4taGVpZ2h0Om1pbigxMDB2aCAtIDIwMHB4LCA1MDBweCk7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uc3ltYm9sLXNlbGVjdGlvbi1wYW5lbCBhcmNnaXMtaXRlbS1wYWxldHRlIC5wYWxldHRle2dhcDo4cHh9LnN5bWJvbC1zZWxlY3Rpb24tcGFuZWwgY2FsY2l0ZS1ub3RpY2U6Zmlyc3Qtb2YtdHlwZXttYXJnaW46YXV0byAwIDAgMH0uc3ltYm9sLXNlbGVjdGlvbi1wYW5lbCBjYWxjaXRlLWxhYmVse21hcmdpbjoxNnB4IDEycHggMCAxMnB4fS5zeW1ib2wtc2VsZWN0aW9uLXBhbmVsIGNhbGNpdGUtcGFuZWx7b3ZlcmZsb3c6dmlzaWJsZX0uc2VjdGlvbntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2JhY2tncm91bmQtY29sb3I6dmFyKC0tYXJjZ2lzLWFwcC1iYWNrZ3JvdW5kKX1cIjtcblxuY29uc3QgQXJjR0lTU3ltYm9sU3R5bGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlckVkaXQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJNYXJrZXJDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1N5bWJvbFN0eWxlck1hcmtlckNoYW5nZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlckZpbGxDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1N5bWJvbFN0eWxlckZpbGxDaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsRW5hYmxlZENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbEVuYWJsZWRDaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUVuYWJsZWRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUVuYWJsZWRDaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTb3VyY2VJZENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU3ltYm9sU3R5bGVyU291cmNlSWRDaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgY29uc3QgbGFzdCA9IGVudHJpZXMucG9wKCk7XG4gICAgICB0aGlzLm5hcnJvdyA9IGxhc3QuY29udGVudFJlY3Qud2lkdGggPD0gMjc1O1xuICAgIH0pO1xuICAgIHRoaXMud2luZG93UmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5jaGVja1BvcG92ZXJNYXhIZWlnaHQoKSk7XG4gICAgdGhpcy5hdXRvT3BlbkZpcnN0QmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLmF1dG9DYWxjSGVpZ2h0ID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvcklucHV0RWwgPSBbXTtcbiAgICB0aGlzLnVwZGF0ZVByZXZpZXdTeW1ib2wgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgICBjb25zdCBwcmV2aWV3ID0gdGhpcy5zeW1ib2wuY2xvbmUoKTtcbiAgICAgIHRoaXMuc3luY1N5bWJvbFByb3BzKHByZXZpZXcsIHtcbiAgICAgICAgc3ltYm9sU3RhdGU6IHtcbiAgICAgICAgICBtYXJrZXI6IHRoaXMubWFya2VyLFxuICAgICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcbiAgICAgICAgICBzdHJva2U6IHRoaXMuc3Ryb2tlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcmV2aWV3U3ltYm9sID0gcHJldmlldztcbiAgICB9LCAxNTApO1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLnNldFJhbXBJbnB1dFJlZiA9IChlbCkgPT4ge1xuICAgICAgdGhpcy5yYW1wSW5wdXRFbCA9IGVsO1xuICAgIH07XG4gICAgdGhpcy5zZXRDb2xvcklucHV0UmVmID0gKGVsKSA9PiB7XG4gICAgICB0aGlzLmNvbG9ySW5wdXRFbC5wdXNoKGVsKTtcbiAgICB9O1xuICAgIHRoaXMub25Db2xvclJhbXBGaWxsVHJhbnNwYXJlbmN5Q2hhbmdlID0gKHN0cm9rZVRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgY29uc3QgYWxwaGEgPSB0cmFuc3BhcmVuY3lUb0FscGhhKHN0cm9rZVRyYW5zcGFyZW5jeSk7XG4gICAgICBjb25zdCBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgY29uc3QgbWVyZ2VkRmlsbCA9IHtcbiAgICAgICAgY29sb3I6IGZpbGwuY29sb3IubWFwKChjb2xvcikgPT4gY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29sb3IpLCB7IGE6IGFscGhhIH0pKSlcbiAgICAgIH07XG4gICAgICB0aGlzLmZpbGwgPSBtZXJnZWRGaWxsO1xuICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsQ2hhbmdlLmVtaXQobWVyZ2VkRmlsbCk7XG4gICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sLCB7IGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiIH0pLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMub25GaWxsQ29sb3JSYW1wQ2F0ZWdvcnlDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGNvbnN0IGFjdGl2ZUNhdGVnb3J5ID0gc2VsZWN0LnNlbGVjdGVkT3B0aW9uLnZhbHVlO1xuICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbnMuZmlsbDtcbiAgICAgIHRoaXMuc2VjdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2VjdGlvbnMpLCB7IGZpbGw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbiksIHsgYWN0aXZlQ2F0ZWdvcnkgfSkgfSk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIHRoaXMub25Db2xvckZpbGxUcmFuc3BhcmVuY3lDaGFuZ2UgPSAoc3Ryb2tlVHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEoc3Ryb2tlVHJhbnNwYXJlbmN5KTtcbiAgICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG1lcmdlZEZpbGwgPSB7XG4gICAgICAgIGNvbG9yOiBjcmVhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWxsLmNvbG9yKSwgeyBhOiBhbHBoYSB9KSlcbiAgICAgIH07XG4gICAgICB0aGlzLmZpbGwgPSBtZXJnZWRGaWxsO1xuICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsQ2hhbmdlLmVtaXQobWVyZ2VkRmlsbCk7XG4gICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uU3Ryb2tlQ29sb3JSYW1wQ2F0ZWdvcnlDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGNvbnN0IGFjdGl2ZUNhdGVnb3J5ID0gc2VsZWN0LnNlbGVjdGVkT3B0aW9uLnZhbHVlO1xuICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbnMuc3Ryb2tlO1xuICAgICAgdGhpcy5zZWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZWN0aW9ucyksIHsgc3Ryb2tlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlY3Rpb24pLCB7IGFjdGl2ZUNhdGVnb3J5IH0pIH0pO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLm9uQ29sb3JTdHJva2VUcmFuc3BhcmVuY3lDaGFuZ2UgPSAoc3Ryb2tlVHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGFscGhhID0gdHJhbnNwYXJlbmN5VG9BbHBoYShzdHJva2VUcmFuc3BhcmVuY3kpO1xuICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBjcmVhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UuY29sb3IpLCB7IGE6IGFscGhhIH0pKSB9KTtcbiAgICAgIHRoaXMuc3Ryb2tlID0gbWVyZ2VkU3Ryb2tlO1xuICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UpKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW5jU3ltYm9sUHJvcHModGhpcy5zeW1ib2wpLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMub25Db2xvclJhbXBTdHJva2VUcmFuc3BhcmVuY3lDaGFuZ2UgPSAoc3Ryb2tlVHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEoc3Ryb2tlVHJhbnNwYXJlbmN5KTtcbiAgICAgIGNvbnN0IHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBzdHJva2UuY29sb3IubWFwKChjb2xvcikgPT4gY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29sb3IpLCB7IGE6IGFscGhhIH0pKSkgfSk7XG4gICAgICB0aGlzLnN0cm9rZSA9IG1lcmdlZFN0cm9rZTtcbiAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlQ2hhbmdlLmVtaXQobm9ybWFsaXplU2l6ZVByb3AobWVyZ2VkU3Ryb2tlKSk7XG4gICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sLCB7IGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiIH0pLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMub25TdHJva2VTdHlsZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgZHJvcGRvd24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3Qgc3R5bGUgPSBkcm9wZG93bi5zZWxlY3RlZEl0ZW1zWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVcIik7XG4gICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG1lcmdlZFN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBzdHlsZSB9KTtcbiAgICAgIHRoaXMuc3Ryb2tlID0gbWVyZ2VkU3Ryb2tlO1xuICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UpKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW5jU3ltYm9sUHJvcHModGhpcy5zeW1ib2wpLCB0cnVlKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5vblN0cm9rZUFycm93Q2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkcm9wZG93biA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBhcnJvdyA9IGRyb3Bkb3duLnNlbGVjdGVkSXRlbXNbMF0uZ2V0QXR0cmlidXRlKFwiZGF0YS1hcnJvd1wiKTtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlIH0gPSB0aGlzO1xuICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IG1hcmtlcjogdG9BcnJvd01hcmtlcihhcnJvdykgfSk7XG4gICAgICB0aGlzLnN0cm9rZSA9IG1lcmdlZFN0cm9rZTtcbiAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlQ2hhbmdlLmVtaXQobm9ybWFsaXplU2l6ZVByb3AobWVyZ2VkU3Ryb2tlKSk7XG4gICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIHRoaXMub25TdHJva2VXaWR0aENoYW5nZSA9ICh3aWR0aCkgPT4gdGhpcy5zZXRTdHJva2VXaWR0aCh3aWR0aCk7XG4gICAgdGhpcy5vbkF1dG9BZGp1c3RTdHJva2VDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3QgYXV0b0FkanVzdGVkID0gbm9kZS5jaGVja2VkO1xuICAgICAgY29uc3QgeyBzdHJva2UgfSA9IHRoaXM7XG4gICAgICBjb25zdCBtZXJnZWRTdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgYXV0b0FkanVzdGVkIH0pO1xuICAgICAgdGhpcy5zdHJva2UgPSBtZXJnZWRTdHJva2U7XG4gICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZFN0cm9rZSkpO1xuICAgICAgLy8gd2Ugc2V0IHRvIGVtaXQgdGhlIGF1dG8tYWRqdXN0ZWQgY2hhbmdlcyByZWdhcmRsZXNzIG9mIHRoZSBzeW1ib2wgbm90IGNoYW5naW5nXG4gICAgICB0aGlzLmVtaXRFZGl0KHRoaXMuc3ltYm9sKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5zeW5jU3ltYm9sUHJvcHMgPSAoc3ltYm9sLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBzeW1ib2xTdGF0ZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3ltYm9sU3RhdGUpIHx8IHtcbiAgICAgICAgbWFya2VyOiB0aGlzLm1hcmtlcixcbiAgICAgICAgZmlsbDogdGhpcy5maWxsLFxuICAgICAgICBzdHJva2U6IHRoaXMuc3Ryb2tlXG4gICAgICB9O1xuICAgICAgY29uc3QgY2ltQ2hhbmdlQ29udGV4dCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaW1DaGFuZ2VDb250ZXh0O1xuICAgICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5VHlwZShzeW1ib2wpO1xuICAgICAgcmV0dXJuIHR5cGUgPT09IFwicG9pbnRcIlxuICAgICAgICA/IHRoaXMuc3luY1BvaW50U3ltYm9sUHJvcHMoc3ltYm9sLCBzeW1ib2xTdGF0ZSwgY2ltQ2hhbmdlQ29udGV4dClcbiAgICAgICAgOiB0eXBlID09PSBcImxpbmVcIlxuICAgICAgICAgID8gdGhpcy5zeW5jTGluZVN5bWJvbFByb3BzKHN5bWJvbCwgc3ltYm9sU3RhdGUsIGNpbUNoYW5nZUNvbnRleHQpXG4gICAgICAgICAgOiB0aGlzLnN5bmNQb2x5Z29uU3ltYm9sUHJvcHMoc3ltYm9sLCBzeW1ib2xTdGF0ZSwgY2ltQ2hhbmdlQ29udGV4dCk7XG4gICAgfTtcbiAgICB0aGlzLnN5bmNQb2ludFN5bWJvbFByb3BzID0gKHN5bWJvbCwgeyBmaWxsLCBtYXJrZXIsIHN0cm9rZSB9LCBjaW1DaGFuZ2VDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCB7IHNjcmVlblV0aWxzIH0gPSBlc3JpTW9kdWxlcztcbiAgICAgIGNvbnN0IHsgc2VjdGlvbnMgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzaXplID0gbm9ybWFsaXplUHQoc2NyZWVuVXRpbHMucHgycHQobWFya2VyLnNpemUpKTtcbiAgICAgIGlmIChpc1NNU1N5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgIGNvbnN0IGxpbmVPbmx5U3ltYm9sID0gaXNMaW5lT25seVN5bWJvbChzeW1ib2wpO1xuICAgICAgICBpZiAoIWxpbmVPbmx5U3ltYm9sKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNGaWxsQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbC5jb2xvciA9IHRoaXMuZ2V0U2FtcGxlRmlsbENvbG9yUmFtcENvbG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ltYm9sLmNvbG9yID0gc2VjdGlvbnMuZmlsbC5lbmFibGVkID8gZmlsbC5jb2xvciA6IGNyZWF0ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bWJvbC5vdXRsaW5lKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNTdHJva2VDb2xvclJhbXAoKSkge1xuICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUuY29sb3IgPSB0aGlzLmdldFNhbXBsZVN0cm9rZUNvbG9yUmFtcENvbG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGxpbmVPbmx5U3ltYm9sICYmIHRoaXMuaXNGaWxsQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLmNvbG9yID0gdGhpcy5nZXRTYW1wbGVGaWxsQ29sb3JSYW1wQ29sb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzeW1ib2wub3V0bGluZS5jb2xvciA9IHNlY3Rpb25zLnN0cm9rZS5lbmFibGVkXG4gICAgICAgICAgICAgID8gc3Ryb2tlLmNvbG9yXG4gICAgICAgICAgICAgIDogY3JlYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzeW1ib2wub3V0bGluZS5tYXJrZXIgPSBzdHJva2UubWFya2VyO1xuICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLnN0eWxlID0gc3Ryb2tlLnN0eWxlO1xuICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLndpZHRoID0gbm9ybWFsaXplUHQoc2NyZWVuVXRpbHMucHgycHQoc3Ryb2tlLnNpemUpKTtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2wuc2l6ZSA9IHNpemU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1BNU1N5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgIC8vIGtlZXAgYXNwZWN0IHJhdGlvXG4gICAgICAgIHN5bWJvbC5oZWlnaHQgPSBNYXRoLnJvdW5kKChzeW1ib2wuaGVpZ2h0IC8gc3ltYm9sLndpZHRoKSAqIHNpemUgKiAxMDApIC8gMTAwO1xuICAgICAgICBzeW1ib2wud2lkdGggPSBzaXplO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xvY2t3aXNlQW5nbGUgPSBNYXRoLmFicyhtYXJrZXIuYW5nbGUpO1xuICAgICAgaWYgKGlzQ0lNU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgLy8gb25seSB0b3AtbGV2ZWwgcHJvcHMgYXJlIGFwcGxpZWRcbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgb3JpZ2luYWwgc3ltYm9sIGZyb20gYSBzeW1ib2wgc2V0IHdlIHdhbnQgdG8ga2VlcCB0aGVzZSBjdXJyZW50IHNldHRpbmdzXG4gICAgICAgIGlmIChbXCJyb290XCIsIFwib3JpZ2luYWwtcm9vdFwiXS5pbmRleE9mKGNpbUNoYW5nZUNvbnRleHQpID4gLTEpIHtcbiAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5hcHBseUNJTVN5bWJvbFJvdGF0aW9uKHN5bWJvbCwgY2xvY2t3aXNlQW5nbGUsIHRydWUpO1xuICAgICAgICAgIGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLnNjYWxlQ0lNU3ltYm9sVG8oc3ltYm9sLCBzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzeW1ib2wuZGF0YS5zeW1ib2wuYW5nbGUgPSBjbG9ja3dpc2VBbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0ZpbGxDb2xvclJhbXAoKSkge1xuICAgICAgICAgIGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmFwcGx5Q0lNU3ltYm9sQ29sb3Ioc3ltYm9sLCB0aGlzLmdldFNhbXBsZUZpbGxDb2xvclJhbXBDb2xvcigpLCB7XG4gICAgICAgICAgICBsYXllcnNUb0NvbG9yOiBcImZpbGxcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdHJva2VDb2xvclJhbXAoKSkge1xuICAgICAgICAgIGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmFwcGx5Q0lNU3ltYm9sQ29sb3Ioc3ltYm9sLCB0aGlzLmdldFNhbXBsZVN0cm9rZUNvbG9yUmFtcENvbG9yKCksIHsgbGF5ZXJzVG9Db2xvcjogXCJvdXRsaW5lXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzeW1ib2wuYW5nbGUgPSBjbG9ja3dpc2VBbmdsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfTtcbiAgICB0aGlzLnN5bmNMaW5lU3ltYm9sUHJvcHMgPSAoc3ltYm9sLCB7IHN0cm9rZSB9LCBjaW1DaGFuZ2VDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCB7IHNjcmVlblV0aWxzIH0gPSBlc3JpTW9kdWxlcztcbiAgICAgIGNvbnN0IHsgc2VjdGlvbnMgfSA9IHRoaXM7XG4gICAgICBjb25zdCB3aWR0aCA9IG5vcm1hbGl6ZVB0KHNjcmVlblV0aWxzLnB4MnB0KHN0cm9rZS5zaXplKSk7XG4gICAgICBpZiAoaXNTTFNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICBpZiAodGhpcy5pc1N0cm9rZUNvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgc3ltYm9sLmNvbG9yID0gdGhpcy5nZXRTYW1wbGVTdHJva2VDb2xvclJhbXBDb2xvcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN5bWJvbC5jb2xvciA9IHNlY3Rpb25zLnN0cm9rZS5lbmFibGVkID8gc3Ryb2tlLmNvbG9yIDogY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIG9yaWdpbmFsIHN5bWJvbCBmcm9tIGEgc3ltYm9sIHNldCB3ZSBkb24ndCB3YW50IHRvIGtlZXAgdGhlc2Ugc2V0dGluZ3NcbiAgICAgICAgaWYgKGNpbUNoYW5nZUNvbnRleHQgIT09IFwib3JpZ2luYWwtcm9vdFwiKSB7XG4gICAgICAgICAgc3ltYm9sLm1hcmtlciA9IHN0cm9rZS5tYXJrZXI7XG4gICAgICAgICAgc3ltYm9sLnN0eWxlID0gc3Ryb2tlLnN0eWxlO1xuICAgICAgICAgIHN5bWJvbC53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0NJTVN5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgIC8vIG9ubHkgdG9wLWxldmVsIHByb3BzIGFyZSBhcHBsaWVkXG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIG9yaWdpbmFsIHN5bWJvbCBmcm9tIGEgc3ltYm9sIHNldCAoXCJvcmlnaW5hbC1yb290XCIpIHdlIGRvbid0IHdhbnQgdG8ga2VlcCB0aGVzZSBzZXR0aW5nc1xuICAgICAgICBpZiAoY2ltQ2hhbmdlQ29udGV4dCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5zY2FsZUNJTVN5bWJvbFRvKHN5bWJvbCwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3Ryb2tlQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICBlc3JpTW9kdWxlcy5jaW1TeW1ib2xVdGlscy5hcHBseUNJTVN5bWJvbENvbG9yKHN5bWJvbCwgdGhpcy5nZXRTYW1wbGVTdHJva2VDb2xvclJhbXBDb2xvcigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIHRoaXMuc3luY1BvbHlnb25TeW1ib2xQcm9wcyA9IChzeW1ib2wsIHsgZmlsbCwgc3Ryb2tlIH0sIGNpbUNoYW5nZUNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHsgc2NyZWVuVXRpbHMgfSA9IGVzcmlNb2R1bGVzO1xuICAgICAgY29uc3QgeyBzZWN0aW9ucyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHdpZHRoID0gbm9ybWFsaXplUHQoc2NyZWVuVXRpbHMucHgycHQoc3Ryb2tlLnNpemUpKTtcbiAgICAgIGlmIChpc1NGU1N5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmlsbENvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgc3ltYm9sLmNvbG9yID0gdGhpcy5nZXRTYW1wbGVGaWxsQ29sb3JSYW1wQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzeW1ib2wuY29sb3IgPSBzZWN0aW9ucy5maWxsLmVuYWJsZWQgPyBmaWxsLmNvbG9yIDogY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3Ryb2tlQ29sb3JSYW1wKCkpIHtcbiAgICAgICAgICBzeW1ib2wub3V0bGluZS5jb2xvciA9IHRoaXMuZ2V0U2FtcGxlU3Ryb2tlQ29sb3JSYW1wQ29sb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzeW1ib2wub3V0bGluZS5jb2xvciA9IHNlY3Rpb25zLnN0cm9rZS5lbmFibGVkXG4gICAgICAgICAgICA/IHN0cm9rZS5jb2xvclxuICAgICAgICAgICAgOiBjcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiB1c2luZyB0aGUgb3JpZ2luYWwgc3ltYm9sIGZyb20gYSBzeW1ib2wgc2V0IHdlIGRvbid0IHdhbnQgdG8ga2VlcCB0aGVzZSBzZXR0aW5nc1xuICAgICAgICBpZiAoY2ltQ2hhbmdlQ29udGV4dCAhPT0gXCJvcmlnaW5hbC1yb290XCIpIHtcbiAgICAgICAgICBzeW1ib2wub3V0bGluZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLnN0eWxlID0gc3Ryb2tlLnN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0NJTVN5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgIC8vIG9ubHkgdG9wLWxldmVsIHByb3BzIGFyZSBhcHBsaWVkXG4gICAgICAgIGlmICh0aGlzLmlzRmlsbENvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuYXBwbHlDSU1TeW1ib2xDb2xvcihzeW1ib2wsIHRoaXMuZ2V0U2FtcGxlRmlsbENvbG9yUmFtcENvbG9yKCksIHtcbiAgICAgICAgICAgIGxheWVyc1RvQ29sb3I6IFwiZmlsbFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0cm9rZUNvbG9yUmFtcCgpKSB7XG4gICAgICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuYXBwbHlDSU1TeW1ib2xDb2xvcihzeW1ib2wsIHRoaXMuZ2V0U2FtcGxlU3Ryb2tlQ29sb3JSYW1wQ29sb3IoKSwgeyBsYXllcnNUb0NvbG9yOiBcIm91dGxpbmVcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHVzaW5nIHRoZSBvcmlnaW5hbCBzeW1ib2wgZnJvbSBhIHN5bWJvbCBzZXQgKFwib3JpZ2luYWwtcm9vdFwiKSB3ZSBkb24ndCB3YW50IHRvIGtlZXAgdGhlc2Ugc2V0dGluZ3NcbiAgICAgICAgaWYgKGNpbUNoYW5nZUNvbnRleHQgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgaWYgKGlzUG9seWdvbkNJTShzeW1ib2wpKSB7XG4gICAgICAgICAgICAvLyBzY2FsZUNJTVN5bWJvbFRvKCkgYWxzbyBzY2FsZXMgbWFya2Vycywgc2VwYXJhdG9ycywgLi4uXG4gICAgICAgICAgICBzZXRPdXRsaW5lV2lkdGgoc3ltYm9sLCB3aWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuc2NhbGVDSU1TeW1ib2xUbyhzeW1ib2wsIHdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfTtcbiAgICB0aGlzLm9uU3Ryb2tlRW5hYmxlZENoYW5nZSA9IChlbmFibGVkKSA9PiB7XG4gICAgICBjb25zdCB7IHNlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgY29uc3QgcHJldmVudENoYW5nZSA9IGlzTGluZU9ubHlTeW1ib2wodGhpcy5hY3RpdmVTeW1ib2wpO1xuICAgICAgdGhpcy5zZWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbnMpLCB7IHN0cm9rZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWN0aW9ucy5zdHJva2UpLCB7IGVuYWJsZWQ6IHByZXZlbnRDaGFuZ2UgPyB0cnVlIDogZW5hYmxlZCB9KSB9KTtcbiAgICAgIGlmIChwcmV2ZW50Q2hhbmdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU3Ryb2tlRW5hYmxlZENoYW5nZS5lbWl0KHtcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgc3Ryb2tlOiBub3JtYWxpemVTaXplUHJvcCh0aGlzLnN0cm9rZSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCksIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5vbkZpbGxFbmFibGVkQ2hhbmdlID0gKGVuYWJsZWQpID0+IHtcbiAgICAgIGNvbnN0IHsgZmlsbCwgc2VjdGlvbnMgfSA9IHRoaXM7XG4gICAgICBjb25zdCBwcmV2ZW50Q2hhbmdlID0gaXNMaW5lT25seVN5bWJvbCh0aGlzLmFjdGl2ZVN5bWJvbCk7XG4gICAgICB0aGlzLnNlY3Rpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWN0aW9ucyksIHsgZmlsbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWN0aW9ucy5maWxsKSwgeyBlbmFibGVkOiBwcmV2ZW50Q2hhbmdlID8gZmFsc2UgOiBlbmFibGVkIH0pIH0pO1xuICAgICAgaWYgKHByZXZlbnRDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsRW5hYmxlZENoYW5nZS5lbWl0KHtcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgZmlsbFxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uQXV0b0FkanVzdFNpemVDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3QgYXV0b0FkanVzdGVkID0gbm9kZS5jaGVja2VkO1xuICAgICAgY29uc3QgeyBtYXJrZXIgfSA9IHRoaXM7XG4gICAgICBjb25zdCBtZXJnZWRNYXJrZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1hcmtlciksIHsgYXV0b0FkanVzdGVkIH0pO1xuICAgICAgdGhpcy5tYXJrZXIgPSBtZXJnZWRNYXJrZXI7XG4gICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlck1hcmtlckNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZE1hcmtlcikpO1xuICAgICAgLy8gd2Ugc2V0IHRvIGVtaXQgdGhlIGF1dG8tYWRqdXN0ZWQgY2hhbmdlcyByZWdhcmRsZXNzIG9mIHRoZSBzeW1ib2wgbm90IGNoYW5naW5nXG4gICAgICB0aGlzLmVtaXRFZGl0KHRoaXMuc3ltYm9sKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5vblN5bWJvbFNpemVDaGFuZ2UgPSAoc2l6ZSkgPT4gdGhpcy5zZXRTeW1ib2xTaXplKHNpemUpO1xuICAgIHRoaXMub25TeW1ib2xSb3RhdGlvbkNoYW5nZSA9IChhbmdsZSkgPT4ge1xuICAgICAgY29uc3QgeyBtYXJrZXIsIGZpbGwsIHN0cm9rZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG1lcmdlZE1hcmtlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFya2VyKSwgeyBhbmdsZSwgc3ltYm9sOiB0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCwge1xuICAgICAgICAgIGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiLFxuICAgICAgICAgIHN5bWJvbFN0YXRlOiB7XG4gICAgICAgICAgICBtYXJrZXI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFya2VyKSwgeyBhbmdsZSB9KSxcbiAgICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IHN0cm9rZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgfSk7XG4gICAgICB0aGlzLm1hcmtlciA9IG1lcmdlZE1hcmtlcjtcbiAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wobWVyZ2VkTWFya2VyLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlck1hcmtlckNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZE1hcmtlcikpO1xuICAgIH07XG4gICAgdGhpcy5vblN5bWJvbFNlbGVjdCA9IChzeW1ib2wpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHsgZmlsbCwgbWFya2VyLCBzZWN0aW9ucywgc3Ryb2tlIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY2hhbmdlZEZyb21QTVNUb1NNUyA9ICgoX2EgPSB0aGlzLmFjdGl2ZVN5bWJvbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcInBpY3R1cmUtbWFya2VyXCIgJiYgc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLW1hcmtlclwiO1xuICAgICAgY29uc3QgaGFkTGluZU9ubHlTeW1ib2wgPSBpc0xpbmVPbmx5U3ltYm9sKHRoaXMuYWN0aXZlU3ltYm9sKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTGluZU9ubHlTeW1ib2wgPSBpc0xpbmVPbmx5U3ltYm9sKHN5bWJvbCk7XG4gICAgICBjb25zdCBjaGFuZ2VkRnJvbUxpbmVPbmx5U01TVG9Ob25MaW5lT25seVNNUyA9IGhhZExpbmVPbmx5U3ltYm9sICYmICFzZWxlY3RlZExpbmVPbmx5U3ltYm9sO1xuICAgICAgY29uc3QgY2hhbmdlZEZyb21Ob25MaW5lT25seVNNU1RvTGluZU9ubHlTTVMgPSAhaGFkTGluZU9ubHlTeW1ib2wgJiYgc2VsZWN0ZWRMaW5lT25seVN5bWJvbDtcbiAgICAgIHRoaXMuYXV0b09wZW5GaXJzdEJsb2NrID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGZpbGxTdXBwb3J0ZWQgPSBzdXBwb3J0c0ZpbGwoc3ltYm9sKTtcbiAgICAgIGNvbnN0IHN0cm9rZVN1cHBvcnRlZCA9IHN1cHBvcnRzU3Ryb2tlKHN5bWJvbCk7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlT3ZlcnJpZGVzID0ge307XG4gICAgICBjb25zdCBzd2l0Y2hlZEZyb21DSU1Ub05vbkNJTSA9IGlzQ0lNU3ltYm9sKHRoaXMuYWN0aXZlU3ltYm9sKSAmJiAhaXNDSU1TeW1ib2woc3ltYm9sKTtcbiAgICAgIGlmIChzd2l0Y2hlZEZyb21DSU1Ub05vbkNJTSkge1xuICAgICAgICBpZiAoaXNTTVNTeW1ib2woc3ltYm9sKSB8fCBpc1NGU1N5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgICAgaWYgKGZpbGxTdXBwb3J0ZWQgJiYgc2VjdGlvbnMuZmlsbC50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuZmlsbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsbCksIHsgY29sb3I6IHN5bWJvbC5jb2xvci5jbG9uZSgpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3Ryb2tlU3VwcG9ydGVkICYmIHNlY3Rpb25zLnN0cm9rZS50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNtc09yU2ZzID0gc3ltYm9sO1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBzbXNPclNmcy5vdXRsaW5lLmNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZEZyb21Ob25MaW5lT25seVNNU1RvTGluZU9ubHlTTVMpIHtcbiAgICAgICAgICAgICAgLy8gZW5zdXJlIGxpbmUgY29sb3IgaXMgdmlzaWJsZVxuICAgICAgICAgICAgICBjb2xvci5hID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yIH0pO1xuICAgICAgICAgICAgaWYgKGlzU0ZTU3ltYm9sKSB7XG4gICAgICAgICAgICAgIC8vIG92ZXJyaWRlIHdpdGggb3V0bGluZSB3aWR0aCBvZiBuZXcgc3ltYm9sXG4gICAgICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlLnNpemUgPSBzeW1ib2wub3V0bGluZS53aWR0aDtcbiAgICAgICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2Uuc3R5bGUgPSBzeW1ib2wub3V0bGluZS5zdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTTFNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgIGlmIChzdHJva2VTdXBwb3J0ZWQgJiYgc2VjdGlvbnMuc3Ryb2tlLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgICAgICAgICAgY29uc3Qgc2xzID0gc3ltYm9sO1xuICAgICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgc2l6ZTogc2xzLndpZHRoLCBjb2xvcjogc2xzLmNvbG9yLmNsb25lKCkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0NJTVN5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgIGNvbnN0IHJvb3RDb2xvciA9IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbENvbG9yKHN5bWJvbCk7XG4gICAgICAgIGlmIChzZWN0aW9ucy5maWxsLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuZmlsbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsbCksIHsgY29sb3I6IHJvb3RDb2xvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsU3Ryb2tlT3ZlcnJpZGVzLnN0cm9rZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRHZW9tZXRyeSA9PT0gXCJwb2ludFwiKSB7XG4gICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2Uuc2l6ZSA9IG5vcm1hbGl6ZVB0KG1hcmtlci5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmVkaXRHZW9tZXRyeSA9PT0gXCJsaW5lXCIpIHtcbiAgICAgICAgICBmaWxsU3Ryb2tlT3ZlcnJpZGVzLnN0cm9rZS5zaXplID0gbm9ybWFsaXplUHQoZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuZ2V0Q0lNU3ltYm9sU2l6ZShzeW1ib2wpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbnMuc3Ryb2tlLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlLmNvbG9yID0gcm9vdENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2ltU3Ryb2tlV2lkdGhCb3VuZHMgPSBnZXRDSU1TdHJva2VXaWR0aEJvdW5kcygpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VjdGlvbnMuZmlsbC50eXBlID09PSBcImNvbG9yLXJhbXBcIiAmJiBzZWN0aW9ucy5zdHJva2UudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZExpbmVPbmx5U3ltYm9sKSB7XG4gICAgICAgICAgLy8gdXNlIGZpbGwgcmFtcCBjYXRlZ29yeSBhbmQgc3RvcmUgc2VsZWN0ZWQgcmFtcCB3aGVuZXZlciBzd2l0Y2hpbmcgdG8gcHVyZS1saW5lIHN0eWxlXG4gICAgICAgICAgdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVBY3RpdmVDYXRlZ29yeSA9IHNlY3Rpb25zLmZpbGwuYWN0aXZlQ2F0ZWdvcnk7XG4gICAgICAgICAgdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVTdG9wcyA9IGZpbGwuY29sb3I7XG4gICAgICAgICAgdGhpcy50ZW1wU3Ryb2tlUHJldmlvdXNDb2xvckJlZm9yZUNvbG9yUmFtcFN3aXRjaCA9IHN0cm9rZS5jb2xvcjtcbiAgICAgICAgICBmaWxsU3Ryb2tlT3ZlcnJpZGVzLnN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3Ryb2tlKSwgeyBjb2xvcjogdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVTdG9wcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2VkRnJvbUxpbmVPbmx5U01TVG9Ob25MaW5lT25seVNNUykge1xuICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuZmlsbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsbCksIHsgY29sb3I6IHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHMgfSk7XG4gICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3I6IHRoaXMudGVtcFN0cm9rZVByZXZpb3VzQ29sb3JCZWZvcmVDb2xvclJhbXBTd2l0Y2ggfSk7XG4gICAgICAgICAgdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVBY3RpdmVDYXRlZ29yeSA9IG51bGw7XG4gICAgICAgICAgdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVTdG9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlY3Rpb25zLmZpbGwudHlwZSA9PT0gXCJjb2xvclwiICYmIHNlY3Rpb25zLnN0cm9rZS50eXBlID09PSBcImNvbG9yLXJhbXBcIikge1xuICAgICAgICBpZiAoY2hhbmdlZEZyb21Ob25MaW5lT25seVNNU1RvTGluZU9ubHlTTVMpIHtcbiAgICAgICAgICBjb25zdCByYW1wID0gc3Ryb2tlLmNvbG9yLm1hcCgoY29sb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBsaW5lIGNvbG9yIGlzIHZpc2libGVcbiAgICAgICAgICAgIGNvbG9yLmEgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZpbGxTdHJva2VPdmVycmlkZXMuc3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiByYW1wIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWN0aW9ucy5maWxsLnR5cGUgPT09IFwiY29sb3JcIiAmJiBzZWN0aW9ucy5zdHJva2UudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIGlmIChjaGFuZ2VkRnJvbU5vbkxpbmVPbmx5U01TVG9MaW5lT25seVNNUykge1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gc3Ryb2tlLmNvbG9yLmNsb25lKCk7XG4gICAgICAgICAgaWYgKGNoYW5nZWRGcm9tTm9uTGluZU9ubHlTTVNUb0xpbmVPbmx5U01TKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgbGluZSBjb2xvciBpcyB2aXNpYmxlXG4gICAgICAgICAgICBjb2xvci5hID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VjdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlY3Rpb25zKSwgeyBmaWxsOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlY3Rpb25zLmZpbGwpLCB7IG9wZW46ICFzZWxlY3RlZExpbmVPbmx5U3ltYm9sICYmIHNlY3Rpb25zLmZpbGwub3BlbiwgZW5hYmxlZDogZmlsbFN1cHBvcnRlZCAmJlxuICAgICAgICAgICAgKCFzZWxlY3RlZExpbmVPbmx5U3ltYm9sIHx8XG4gICAgICAgICAgICAgIGlzQ0lNU3ltYm9sKHN5bWJvbCkgfHxcbiAgICAgICAgICAgICAgY2hhbmdlZEZyb21MaW5lT25seVNNU1RvTm9uTGluZU9ubHlTTVMgfHxcbiAgICAgICAgICAgICAgY2hhbmdlZEZyb21QTVNUb1NNUyB8fFxuICAgICAgICAgICAgICBzZWN0aW9ucy5maWxsLmVuYWJsZWQpIH0pLCBzdHJva2U6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VjdGlvbnMuc3Ryb2tlKSwgeyBlbmFibGVkOiBzdHJva2VTdXBwb3J0ZWQgJiZcbiAgICAgICAgICAgIChpc0NJTVN5bWJvbChzeW1ib2wpIHx8XG4gICAgICAgICAgICAgIGNoYW5nZWRGcm9tTm9uTGluZU9ubHlTTVNUb0xpbmVPbmx5U01TIHx8XG4gICAgICAgICAgICAgIChzd2l0Y2hlZEZyb21DSU1Ub05vbkNJTSAmJiAhc2VsZWN0ZWRMaW5lT25seVN5bWJvbCkgfHxcbiAgICAgICAgICAgICAgY2hhbmdlZEZyb21QTVNUb1NNUyB8fFxuICAgICAgICAgICAgICBzZWN0aW9ucy5zdHJva2UuZW5hYmxlZCkgfSkgfSk7XG4gICAgICBjb25zdCBmaW5hbEZpbGwgPSAoZmlsbFN0cm9rZU92ZXJyaWRlcy5maWxsIHx8IGZpbGwpO1xuICAgICAgY29uc3QgZmluYWxTdHJva2UgPSAoZmlsbFN0cm9rZU92ZXJyaWRlcy5zdHJva2UgfHwgc3Ryb2tlKTtcbiAgICAgIGNvbnN0IG1lcmdlZE1hcmtlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFya2VyKSwgeyBzeW1ib2w6IHRoaXMuc3luY1N5bWJvbFByb3BzKHN5bWJvbCwge1xuICAgICAgICAgIGNpbUNoYW5nZUNvbnRleHQ6IFwib3JpZ2luYWwtcm9vdFwiLFxuICAgICAgICAgIHN5bWJvbFN0YXRlOiB7XG4gICAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgICBmaWxsOiBmaW5hbEZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IGZpbmFsU3Ryb2tlXG4gICAgICAgICAgfVxuICAgICAgICB9KSB9KTtcbiAgICAgIHRoaXMuZmlsbCA9IGZpbmFsRmlsbDtcbiAgICAgIHRoaXMuc3Ryb2tlID0gZmluYWxTdHJva2U7XG4gICAgICB0aGlzLm1hcmtlciA9IG1lcmdlZE1hcmtlcjtcbiAgICAgIHRoaXMuYWN0aXZlU3ltYm9sID0gc3ltYm9sO1xuICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbChtZXJnZWRNYXJrZXIuc3ltYm9sLCB0cnVlKTtcbiAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyTWFya2VyQ2hhbmdlLmVtaXQobm9ybWFsaXplU2l6ZVByb3AobWVyZ2VkTWFya2VyKSk7XG4gICAgfTtcbiAgICB0aGlzLmVtaXRFZGl0ID0gZGVib3VuY2UoYXN5bmMgKHN5bWJvbCkgPT4ge1xuICAgICAgY29uc3QgY2xvbmUgPSBzeW1ib2wuY2xvbmUoKTtcbiAgICAgIGNvbnN0IGluZm8gPSB7fTtcbiAgICAgIGNvbnN0IHsgZWRpdEdlb21ldHJ5IH0gPSB0aGlzO1xuICAgICAgY29uc3QgYWRkTWFya2VyID0gZWRpdEdlb21ldHJ5ID09PSBcInBvaW50XCI7XG4gICAgICBjb25zdCBhZGRGaWxsID0gKCFpc0xpbmVPbmx5U3ltYm9sKHN5bWJvbCkgJiYgZWRpdEdlb21ldHJ5ID09PSBcInBvaW50XCIpIHx8IGVkaXRHZW9tZXRyeSA9PT0gXCJwb2x5Z29uXCI7XG4gICAgICBpZiAoYWRkTWFya2VyKSB7XG4gICAgICAgIGluZm8ubWFya2VyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub3JtYWxpemVTaXplUHJvcCh0aGlzLm1hcmtlcikpLCB7IHN5bWJvbDogY2xvbmUgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkRmlsbCkge1xuICAgICAgICBpbmZvLmZpbGwgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZpbGwpO1xuICAgICAgfVxuICAgICAgLy8gc3Ryb2tlIGFwcGxpZXMgdG8gYWxsIGdlb21ldHJ5IHR5cGVzXG4gICAgICBpbmZvLnN0cm9rZSA9IE9iamVjdC5hc3NpZ24oe30sIG5vcm1hbGl6ZVNpemVQcm9wKHRoaXMuc3Ryb2tlKSk7XG4gICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlckVkaXQuZW1pdCh7XG4gICAgICAgIHN5bWJvbDogY2xvbmUsXG4gICAgICAgIGluZm9cbiAgICAgIH0pO1xuICAgIH0sIDMwMCk7XG4gICAgdGhpcy5mbGlwRmlsbENvbG9yUmFtcHMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5maWxsO1xuICAgICAgY29uc3QgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgIGNvbnN0IGlzMmQgPSBzZWN0aW9uLnN0eWxlID09PSBcIjJkXCI7XG4gICAgICBjb25zdCBtZXJnZWRGaWxsID0ge1xuICAgICAgICBjb2xvcjogZmxpcENvbG9yUmFtcFN0b3BzKGZpbGwuY29sb3IsIGlzMmQpXG4gICAgICB9O1xuICAgICAgdGhpcy5zZWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZWN0aW9ucyksIHsgZmlsbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWN0aW9uKSwgeyBjb2xvclJhbXBzOiBzZWN0aW9uLmNvbG9yUmFtcHMubWFwKCh7IHN0b3BzLCB0YWdzLCBuYW1lIH0pID0+ICh7XG4gICAgICAgICAgICBzdG9wczogZmxpcENvbG9yUmFtcFN0b3BzKHN0b3BzLCBpczJkKSxcbiAgICAgICAgICAgIHRhZ3MsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfSkpIH0pIH0pO1xuICAgICAgdGhpcy5maWxsID0gbWVyZ2VkRmlsbDtcbiAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbENoYW5nZS5lbWl0KG1lcmdlZEZpbGwpO1xuICAgICAgLy8gd2Ugc2V0IHRvIGVtaXQgdGhlIGF1dG8tYWRqdXN0ZWQgY2hhbmdlcyByZWdhcmRsZXNzIG9mIHRoZSBzeW1ib2wgbm90IGNoYW5naW5nXG4gICAgICB0aGlzLmVtaXRFZGl0KHRoaXMuc3ltYm9sKTtcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyQmxvY2sgPSAocHJvcHMpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYmxvY2tcIiwgeyBjb2xsYXBzaWJsZTogdHJ1ZSwgZGlzYWJsZWQ6IChfYSA9IHByb3BzLmRpc2FibGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSwgaGVhZGluZzogcHJvcHMuaGVhZGluZywga2V5OiBwcm9wcy5rZXksIG9uQ2FsY2l0ZUJsb2NrVG9nZ2xlOiB0aGlzLm9uQmxvY2tUb2dnbGUgfSwgcHJvcHMuaWNvbiwgcHJvcHMuY29udGVudCkpO1xuICAgIH07XG4gICAgdGhpcy5vbkJsb2NrVG9nZ2xlID0gKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAvLyBjbG9zZSBhbGwgY29sb3IgcGlja2VyIHBvcG92ZXJzXG4gICAgICAoX2EgPSB0aGlzLnJhbXBJbnB1dEVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgIHRoaXMuY29sb3JJbnB1dEVsLmZvckVhY2goKGVsKSA9PiBlbC5jbG9zZSgpKTtcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyU2VjdGlvbiA9ICh7IGRpc2FibGVkLCBlbWJlZGRlZCA9IGZhbHNlLCBrZXksIHNlY3Rpb25Db250ZW50IH0pID0+IHtcbiAgICAgIHJldHVybiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBkaXNhYmxlZDogZGlzYWJsZWQsIGtleToga2V5LCBlbWJlZGRlZDogZW1iZWRkZWQgfSwgc2VjdGlvbkNvbnRlbnQubWFwKCh7IGNvbnRlbnQgfSkgPT4gY29udGVudCkpKTtcbiAgICB9O1xuICAgIHRoaXMuZmxpcFN0cm9rZUNvbG9yUmFtcHMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5zdHJva2U7XG4gICAgICBjb25zdCBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgIGNvbnN0IGlzMmQgPSBzZWN0aW9uLnN0eWxlID09PSBcIjJkXCI7XG4gICAgICBjb25zdCBtZXJnZWRTdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3I6IGZsaXBDb2xvclJhbXBTdG9wcyhzdHJva2UuY29sb3IsIGlzMmQpIH0pO1xuICAgICAgdGhpcy5zZWN0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZWN0aW9ucyksIHsgc3Ryb2tlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlY3Rpb24pLCB7IGNvbG9yUmFtcHM6IHNlY3Rpb24uY29sb3JSYW1wcy5tYXAoKHsgc3RvcHMsIHRhZ3MsIG5hbWUgfSkgPT4gKHtcbiAgICAgICAgICAgIHN0b3BzOiBmbGlwQ29sb3JSYW1wU3RvcHMoc3RvcHMsIGlzMmQpLFxuICAgICAgICAgICAgdGFnczogdGFncy5zbGljZSgpLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH0pKSB9KSB9KTtcbiAgICAgIHRoaXMuc3Ryb2tlID0gbWVyZ2VkU3Ryb2tlO1xuICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UpKTtcbiAgICAgIC8vIHdlIHNldCB0byBlbWl0IHRoZSBhdXRvLWFkanVzdGVkIGNoYW5nZXMgcmVnYXJkbGVzcyBvZiB0aGUgc3ltYm9sIG5vdCBjaGFuZ2luZ1xuICAgICAgdGhpcy5lbWl0RWRpdCh0aGlzLnN5bWJvbCk7XG4gICAgfTtcbiAgICB0aGlzLnBvcG92ZXJQcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluaXRpYWxTb3VyY2VJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvcnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0cmluZ092ZXJyaWRlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNpbVN0cm9rZVdpZHRoQm91bmRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29uZmlnID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZWRpdEdlb21ldHJ5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZmlsbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hcmtlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5hcnJvdyA9IGZhbHNlO1xuICAgIHRoaXMucHJlcHBpbmdFZGl0ID0gdHJ1ZTtcbiAgICB0aGlzLnByZXZpZXdTeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWN0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJ1aWx0SW5TdHJpbmdzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVyZ2VkU3RyaW5ncyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0cm9rZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRlbXBTdHJva2VDb2xvclJhbXBTdGF0ZUFjdGl2ZUNhdGVnb3J5ID0gXCJhbGxcIjtcbiAgICB0aGlzLmFjdGl2ZVN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGl2ZVN5bWJvbEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3RpdmVTb3VyY2VJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXRlID0gXCJlZGl0aW5nXCI7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwpO1xuICAgIHRoaXMud2luZG93UmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5KTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLmVsKTtcbiAgICB0aGlzLndpbmRvd1Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShkb2N1bWVudC5ib2R5KTtcbiAgfVxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBjb25zdCBbLCBbc3RyaW5nc11dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgZXNyaU1vZHVsZXMubG9hZCgpLFxuICAgICAgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmVsKVxuICAgIF0pO1xuICAgIHRoaXMuY3VycmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKHRoaXMuZWwpO1xuICAgIHRoaXMuZGlyID0gZ2V0RWxlbWVudERpcih0aGlzLmVsKTtcbiAgICBjb25zdCBwZXJjZW50Rm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMuY3VycmVudExhbmd1YWdlLCB7IHN0eWxlOiBcInBlcmNlbnRcIiB9KTtcbiAgICBjb25zdCBwZXJjZW50Rm9ybWF0U2FtcGxlID0gcGVyY2VudEZvcm1hdHRlci5mb3JtYXQoMCk7XG4gICAgdGhpcy5wZXJjZW50TGFiZWxGbGlwID1cbiAgICAgIHRoaXMuZGlyID09PSBcInJ0bFwiID8gcGVyY2VudEZvcm1hdFNhbXBsZS5lbmRzV2l0aChcIiVcIikgOiBwZXJjZW50Rm9ybWF0U2FtcGxlLnN0YXJ0c1dpdGgoXCIlXCIpO1xuICAgIHRoaXMuYnVpbHRJblN0cmluZ3MgPSBzdHJpbmdzO1xuICB9XG4gIGNvbXBvbmVudFNob3VsZFVwZGF0ZShuZXdWYWwsIF9vbGRWYWwsIHByb3BOYW1lKSB7XG4gICAgaWYgKHByb3BOYW1lID09PSBcInByZXBwaW5nRWRpdFwiKSB7XG4gICAgICByZXR1cm4gIW5ld1ZhbDtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkUmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmF1dG9PcGVuRmlyc3RCbG9jayAmJiAhdGhpcy5wcmVwcGluZ0VkaXQpIHtcbiAgICAgIGNvbnN0IGZpcnN0QmxvY2sgPSB0aGlzLmVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtYmxvY2tcIik7XG4gICAgICBpZiAoZmlyc3RCbG9jaykge1xuICAgICAgICB0aGlzLmF1dG9PcGVuRmlyc3RCbG9jayA9IGZhbHNlO1xuICAgICAgICBmaXJzdEJsb2NrLm9wZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBtdWx0aXBsZSB3YXRjaGVzIHRyaWdnZXIgZmFsc2UgbmVnYXRpdmUgZm9yIHRoaXMgcnVsZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHN0ZW5jaWwvbm8tdW51c2VkLXdhdGNoXG4gIGhhbmRsZVN0cmluZ0NoYW5nZXMoKSB7XG4gICAgdGhpcy5tZXJnZWRTdHJpbmdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJ1aWx0SW5TdHJpbmdzKSwgdGhpcy5zdHJpbmdPdmVycmlkZXMpO1xuICB9XG4gIG9uUGFuZWxCYWNrKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHVibGljIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBlZGl0KHN5bWJvbCwgY29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHZhbGlkYXRlRWRpdGFibGUoc3ltYm9sKTtcbiAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFthcmNnaXMtc3ltYm9sLXN0eWxlcl0gJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHN5bWJvbCA9IGF3YWl0IHRoaXMuY2hlY2tMaW5lT25seVN5bWJvbChzeW1ib2wsIGNvbmZpZyk7XG4gICAgdGhpcy5wb3J0YWxPckludGVyY2VwdG9yID0gY29uZmlnLnBvcnRhbCB8fCB0aGlzLnBvcnRhbCB8fCBlc3JpTW9kdWxlcy5Qb3J0YWwuZ2V0RGVmYXVsdCgpO1xuICAgIHRoaXMucHJlcHBpbmdFZGl0ID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9PcGVuRmlyc3RCbG9jayA9IHRydWU7XG4gICAgY29uc3QgeyBtYXJrZXI6IG1hcmtlclNlY3Rpb24sIGZpbGw6IGZpbGxTZWN0aW9uLCBzdHJva2U6IHN0cm9rZVNlY3Rpb24gfSA9IGNvbmZpZy5zZWN0aW9ucztcbiAgICB0aGlzLnN5bWJvbEZpbHRlciA9XG4gICAgICBjb25maWcuc3ltYm9sRmlsdGVyIHx8XG4gICAgICAgICgobWFya2VyU2VjdGlvbiA9PT0gbnVsbCB8fCBtYXJrZXJTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJTZWN0aW9uLm1hcmtlclR5cGUpID09PSBcImFsbFwiID8gdW5kZWZpbmVkIDogbWFya2VyU2VjdGlvbiA9PT0gbnVsbCB8fCBtYXJrZXJTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJTZWN0aW9uLm1hcmtlclR5cGUpO1xuICAgIHRoaXMuZWRpdEdlb21ldHJ5ID0gZ2VvbWV0cnlUeXBlKHN5bWJvbCk7XG4gICAgc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7XG4gICAgY29uc3QgZmlsbFN1cHBvcnRlZCA9IHN1cHBvcnRzRmlsbChzeW1ib2wpO1xuICAgIGNvbnN0IHN0cm9rZVN1cHBvcnRlZCA9IHN1cHBvcnRzU3Ryb2tlKHN5bWJvbCk7XG4gICAgaWYgKGlzU01TU3ltYm9sKHN5bWJvbCkgfHwgaXNTRlNTeW1ib2woc3ltYm9sKSkge1xuICAgICAgaWYgKCFzeW1ib2wub3V0bGluZSkge1xuICAgICAgICBzeW1ib2wub3V0bGluZSA9IHsgdHlwZTogXCJzaW1wbGUtbGluZVwiLCBjb2xvcjogY3JlYXRlKG51bGwpIH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghc3ltYm9sLm91dGxpbmUuY29sb3IpIHtcbiAgICAgICAgc3ltYm9sLm91dGxpbmUuY29sb3IgPSBjcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0cm9rZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGF1dG9BZGp1c3RlZDogZmFsc2UgfSwgY29uZmlnLnN0cm9rZSksIHsgc2l6ZTogcGFyc2VTaXplKChfYSA9IGNvbmZpZy5zdHJva2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplLCAyKSwgc3R5bGU6IHN1cHBvcnRlZFN0eWxlcy5pbmNsdWRlcygoX2IgPSBjb25maWcuc3Ryb2tlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3R5bGUpID8gY29uZmlnLnN0cm9rZS5zdHlsZSA6IFwic29saWRcIiB9KTtcbiAgICBpZiAoKF9jID0gY29uZmlnLnN0cm9rZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcmtlcikge1xuICAgICAgc3Ryb2tlLm1hcmtlciA9IGNvbmZpZy5zdHJva2UubWFya2VyO1xuICAgIH1cbiAgICB0aGlzLnNlY3Rpb25zID0ge1xuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGJhY2tncm91bmRTdHlsZTogXCJsaWdodFwiLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UgLyogcGxhY2Vob2xkZXIgKi8sXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlIC8qIHBsYWNlaG9sZGVyICovLFxuICAgICAgICBvcGVuOiAobWFya2VyU2VjdGlvbiA9PT0gbnVsbCB8fCBtYXJrZXJTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJTZWN0aW9uLm9wZW4pIHx8IGZhbHNlLFxuICAgICAgICBzeW1ib2xzT3BlbjogKG1hcmtlclNlY3Rpb24gJiYgKCEoXCJzeW1ib2xzT3BlblwiIGluIG1hcmtlclNlY3Rpb24pIHx8IG1hcmtlclNlY3Rpb24uc3ltYm9sc09wZW4pKSB8fFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICBzaXplT3BlbjogKG1hcmtlclNlY3Rpb24gJiYgKCEoXCJzaXplT3BlblwiIGluIG1hcmtlclNlY3Rpb24pIHx8IG1hcmtlclNlY3Rpb24uc2l6ZU9wZW4pKSB8fCBmYWxzZSxcbiAgICAgICAgcm90YXRpb25PcGVuOiAobWFya2VyU2VjdGlvbiAmJiAoIShcInJvdGF0aW9uT3BlblwiIGluIG1hcmtlclNlY3Rpb24pIHx8IG1hcmtlclNlY3Rpb24ucm90YXRpb25PcGVuKSkgfHxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAga2VlcENob2ljZTogKG1hcmtlclNlY3Rpb24gPT09IG51bGwgfHwgbWFya2VyU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyU2VjdGlvbi5rZWVwQ2hvaWNlKSB8fCBmYWxzZSxcbiAgICAgICAgcGFydHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZpc2libGVNYXJrZXJTZWN0aW9uUGFydHMpLCBtYXJrZXJTZWN0aW9uID09PSBudWxsIHx8IG1hcmtlclNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlclNlY3Rpb24ucGFydHMpXG4gICAgICB9LFxuICAgICAgZmlsbDoge1xuICAgICAgICBhY3RpdmVDYXRlZ29yeTogXCJhbGxcIixcbiAgICAgICAgb3BlbjogKGZpbGxTZWN0aW9uID09PSBudWxsIHx8IGZpbGxTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2VjdGlvbi5vcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IChmaWxsU2VjdGlvbiA9PT0gbnVsbCB8fCBmaWxsU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsbFNlY3Rpb24ub3B0aW9uYWwpIHx8IGZhbHNlLFxuICAgICAgICBlbmFibGVkOiBmaWxsU3VwcG9ydGVkICYmXG4gICAgICAgICAgKChfZCA9IGNvbmZpZy5maWxsRW5hYmxlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZSkgJiZcbiAgICAgICAgICAhaXNDSU1TeW1ib2woc3ltYm9sKSAmJlxuICAgICAgICAgIChmaWxsU2VjdGlvbiA9PT0gbnVsbCB8fCBmaWxsU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsbFNlY3Rpb24udHlwZSkgPT09IFwiY29sb3JcIiAmJlxuICAgICAgICAgICEhdGhpcy50b0NvbG9yUGlja2VyVmFsdWUoY29uZmlnLmZpbGwuY29sb3IpLFxuICAgICAgICB0eXBlOiBmaWxsU2VjdGlvbiA9PT0gbnVsbCB8fCBmaWxsU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsbFNlY3Rpb24udHlwZSxcbiAgICAgICAgc3R5bGU6IGZpbGxTZWN0aW9uID09PSBudWxsIHx8IGZpbGxTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2VjdGlvbi5zdHlsZSxcbiAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogKGZpbGxTZWN0aW9uID09PSBudWxsIHx8IGZpbGxTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxsU2VjdGlvbi5zdWdnZXN0ZWRDb2xvcnNPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgY3VzdG9tQ29sb3JPcGVuOiAoZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLmN1c3RvbUNvbG9yT3BlbikgfHwgZmFsc2UsXG4gICAgICAgIGNvbG9yUmFtcHNPcGVuOiAoZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLmNvbG9yUmFtcHNPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgY29sb3JSYW1wczogZ2V0U3RhdGVDb2xvclJhbXBzKGZpbGxTZWN0aW9uLCBjb25maWcuZmlsbCksXG4gICAgICAgIHRyYW5zcGFyZW5jeU9wZW46IChmaWxsU2VjdGlvbiA9PT0gbnVsbCB8fCBmaWxsU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsbFNlY3Rpb24udHJhbnNwYXJlbmN5T3BlbikgfHwgZmFsc2UsXG4gICAgICAgIHBhcnRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZpc2libGVDb2xvclNlY3Rpb25QYXJ0cyksIGRlZmF1bHRWaXNpYmxlQ29sb3JSYW1wU2VjdGlvblBhcnRzKSwgZmlsbFNlY3Rpb24gPT09IG51bGwgfHwgZmlsbFNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGxTZWN0aW9uLnBhcnRzKVxuICAgICAgfSxcbiAgICAgIHN0cm9rZToge1xuICAgICAgICBhY3RpdmVDYXRlZ29yeTogXCJhbGxcIixcbiAgICAgICAgb3B0aW9uYWw6IChzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24ub3B0aW9uYWwpIHx8IGZhbHNlLFxuICAgICAgICBvcGVuOiAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLm9wZW4pIHx8IGZhbHNlLFxuICAgICAgICBlbmFibGVkOiBzdHJva2VTdXBwb3J0ZWQgJiZcbiAgICAgICAgICAoKF9lID0gY29uZmlnLnN0cm9rZUVuYWJsZWQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRydWUpICYmXG4gICAgICAgICAgIWlzQ0lNU3ltYm9sKHN5bWJvbCkgJiZcbiAgICAgICAgICAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLnR5cGUpID09PSBcImNvbG9yXCIgJiZcbiAgICAgICAgICAhIXRoaXMudG9Db2xvclBpY2tlclZhbHVlKGNvbmZpZy5zdHJva2UuY29sb3IpLFxuICAgICAgICB0eXBlOiBzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24udHlwZSxcbiAgICAgICAgc3R5bGU6IHN0cm9rZVNlY3Rpb24gPT09IG51bGwgfHwgc3Ryb2tlU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlU2VjdGlvbi5zdHlsZSxcbiAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogKHN0cm9rZVNlY3Rpb24gPT09IG51bGwgfHwgc3Ryb2tlU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlU2VjdGlvbi5zdWdnZXN0ZWRDb2xvcnNPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgY3VzdG9tQ29sb3JPcGVuOiAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLmN1c3RvbUNvbG9yT3BlbikgfHwgZmFsc2UsXG4gICAgICAgIGNvbG9yUmFtcHNPcGVuOiAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLmNvbG9yUmFtcHNPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgY29sb3JSYW1wczogZ2V0U3RhdGVDb2xvclJhbXBzKHN0cm9rZVNlY3Rpb24sIGNvbmZpZy5zdHJva2UpLFxuICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiAoc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLnRyYW5zcGFyZW5jeU9wZW4pIHx8IGZhbHNlLFxuICAgICAgICBleHRyYU9wZW46IChzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24uZXh0cmFPcGVuKSB8fCBmYWxzZSxcbiAgICAgICAgZXh0cmFQYXJ0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VmlzaWJsZUV4dHJhU3Ryb2tlU2VjdGlvblBhcnRzKSwgc3Ryb2tlU2VjdGlvbiA9PT0gbnVsbCB8fCBzdHJva2VTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2VTZWN0aW9uLmV4dHJhUGFydHMpLFxuICAgICAgICBwYXJ0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFZpc2libGVDb2xvclNlY3Rpb25QYXJ0cyksIGRlZmF1bHRWaXNpYmxlQ29sb3JSYW1wU2VjdGlvblBhcnRzKSwgZGVmYXVsdFZpc2libGVTdHJva2VTZWN0aW9uUGFydHMpLCBzdHJva2VTZWN0aW9uID09PSBudWxsIHx8IHN0cm9rZVNlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZVNlY3Rpb24ucGFydHMpXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1hcmtlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLm1hcmtlciksIHsgc2l6ZTogcGFyc2VTaXplKChfZiA9IGNvbmZpZy5tYXJrZXIpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zaXplLCAwKSwgYW5nbGU6IGdldFN5bWJvbFJvdGF0aW9uKHN5bWJvbCksIGF1dG9BZGp1c3RlZDogKChfZyA9IGNvbmZpZy5tYXJrZXIpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hdXRvQWRqdXN0ZWQpIHx8IGZhbHNlLCBzeW1ib2wgfSk7XG4gICAgdGhpcy5maWxsID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLmZpbGwpO1xuICAgIHRoaXMuc3Ryb2tlID0gc3Ryb2tlO1xuICAgIHRoaXMuYWN0aXZlU3ltYm9sID0gc3ltYm9sO1xuICAgIHRoaXMuYWN0aXZlU291cmNlSWQgPSAoKG1hcmtlclNlY3Rpb24gPT09IG51bGwgfHwgbWFya2VyU2VjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyU2VjdGlvbi5rZWVwQ2hvaWNlKSAmJiB0aGlzLmFjdGl2ZVNvdXJjZUlkKSB8fCBudWxsO1xuICAgIHRoaXMuYWN0aXZlU3ltYm9sSXRlbSA9ICgobWFya2VyU2VjdGlvbiA9PT0gbnVsbCB8fCBtYXJrZXJTZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJTZWN0aW9uLmtlZXBDaG9pY2UpICYmIHRoaXMuYWN0aXZlU3ltYm9sSXRlbSkgfHwgbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICBpZiAoaXNDSU1TeW1ib2woc3ltYm9sKSAmJiAodGhpcy5pc0ZpbGxDb2xvclJhbXAoKSB8fCB0aGlzLmlzU3Ryb2tlQ29sb3JSYW1wKCkpKSB7XG4gICAgICB0aGlzLnN5bmNTeW1ib2xQcm9wcyhzeW1ib2wsIHtcbiAgICAgICAgY2ltQ2hhbmdlQ29udGV4dDogXCJyb290XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNDSU1TeW1ib2woc3ltYm9sKSkge1xuICAgICAgdGhpcy5jaW1TdHJva2VXaWR0aEJvdW5kcyA9IGdldENJTVN0cm9rZVdpZHRoQm91bmRzKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2woc3ltYm9sLCBmYWxzZSk7XG4gICAgdGhpcy5wcmVwcGluZ0VkaXQgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBjaGVja0xpbmVPbmx5U3ltYm9sKHN5bWJvbCwgY29uZmlnKSB7XG4gICAgLy8gd2Ugbm8gbG9uZ2VyIHN1cHBvcnQgcGx1cyBhbmQgWCBtYXJrZXJzIGluIHRoZSBzdHlsZXJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgaWYgKGlzTGluZU9ubHlTeW1ib2woc3ltYm9sKSkge1xuICAgICAgLy9cImZpbGxcIjp7XCJjb2xvclwiOkNvbG9yfSxcbiAgICAgIC8vXCJmaWxsXCI6e1wiY29sb3JcIjpbQ29sb3IsQ29sb3IsQ29sb3IsQ29sb3IsQ29sb3JdfVxuICAgICAgLy9cIm1hcmtlclwiOntcInNpemVcIjoxMy41LFwiYXV0b0FkanVzdGVkXCI6ZmFsc2V9LFxuICAgICAgLy9cInN0cm9rZVwiOntcImNvbG9yXCI6Q29sb3IsXCJzaXplXCI6MC43NX1cbiAgICAgIGNvbnN0IFtTaW1wbGVNYXJrZXJTeW1ib2xdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9zeW1ib2xzL1NpbXBsZU1hcmtlclN5bWJvbFwiXSk7XG4gICAgICBzeW1ib2wgPSBuZXcgU2ltcGxlTWFya2VyU3ltYm9sKCk7XG4gICAgICAvLyBtYWtlIHN1cmUgY29uZmlnIGZpdHMgdG8gbmV3IHN5bWJvbFxuICAgICAgaWYgKChfYSA9IGNvbmZpZy5maWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3IpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmZpbGwuY29sb3IpKSB7XG4gICAgICAgICAgLy8gXCJjb2xvci1yYW1wXCJcbiAgICAgICAgICBzeW1ib2wuY29sb3IgPSBjb25maWcuZmlsbC5jb2xvcltjb25maWcuZmlsbC5jb2xvci5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBcImNvbG9yXCJcbiAgICAgICAgICBzeW1ib2wuY29sb3IgPSBjb25maWcuZmlsbC5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChfYiA9IGNvbmZpZy5zdHJva2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2xvcikge1xuICAgICAgICBjb25maWcuc3Ryb2tlLmNvbG9yID0gc3ltYm9sLm91dGxpbmUuY29sb3IuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9jID0gY29uZmlnLnN0cm9rZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNpemUpIHx8ICgoX2QgPSBjb25maWcuc3Ryb2tlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2l6ZSkgPT09IDApIHtcbiAgICAgICAgY29uZmlnLnN0cm9rZS5zaXplID0gc3ltYm9sLm91dGxpbmUud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKF9lID0gY29uZmlnLm1hcmtlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnNpemUpIHtcbiAgICAgICAgc3ltYm9sLnNpemUgPSBjb25maWcubWFya2VyLnNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcmtlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLm1hcmtlciksIHsgc2l6ZTogcGFyc2VTaXplKChfZiA9IGNvbmZpZy5tYXJrZXIpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zaXplLCAwKSwgYW5nbGU6IGdldFN5bWJvbFJvdGF0aW9uKHN5bWJvbCksIGF1dG9BZGp1c3RlZDogKChfZyA9IGNvbmZpZy5tYXJrZXIpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5hdXRvQWRqdXN0ZWQpIHx8IGZhbHNlLCBzeW1ib2wgfSk7XG4gICAgICB0aGlzLmVtaXRFZGl0KHN5bWJvbCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN5bWJvbCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3ltYm9sKTtcbiAgfVxuICBhc3luYyBzZXRTaXplKHR5cGUsIHNpemUpIHtcbiAgICBjb25zdCB7IHNjcmVlblV0aWxzIH0gPSBlc3JpTW9kdWxlcztcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJva2VcIikge1xuICAgICAgdGhpcy5zZXRTdHJva2VXaWR0aChub3JtYWxpemVQeChzY3JlZW5VdGlscy5wdDJweChzaXplKSksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibWFya2VyXCIpIHtcbiAgICAgIHRoaXMuc2V0U3ltYm9sU2l6ZShub3JtYWxpemVQeChzY3JlZW5VdGlscy5wdDJweChzaXplKSksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVBhdHRlcm5TdHlsZShzdHlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHtnZXRBc3NldFBhdGgoYC4vYXNzZXRzL2xpbmUtcGF0dGVybnMvJHtzdHlsZX0ucG5nYCl9KWBcbiAgICB9O1xuICB9XG4gIGdldFNlbGVjdGVkQXJyb3dQYXR0ZXJuU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke2dldEFzc2V0UGF0aChgLi9hc3NldHMvYXJyb3ctcGF0dGVybi1zcHJpdGVzaGVldC5wbmdgKX0pYFxuICAgIH07XG4gIH1cbiAgZ2V0QXJyb3dQYXR0ZXJuT3B0aW9uU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke2dldEFzc2V0UGF0aChgLi9hc3NldHMvYXJyb3ctcGF0dGVybi1vcHRpb25zLXNwcml0ZXNoZWV0LnBuZ2ApfSlgXG4gICAgfTtcbiAgfVxuICBoYXNBY3RpdmVMaW5lT25seVNpbXBsZU1hcmtlclN5bWJvbCgpIHtcbiAgICBjb25zdCB7IG1hcmtlciwgc3ltYm9sIH0gPSB0aGlzO1xuICAgIHJldHVybiBtYXJrZXIgJiYgaXNMaW5lT25seVN5bWJvbChzeW1ib2wpO1xuICB9XG4gIGhhc0FjdGl2ZVBpY3R1cmVNYXJrZXJTeW1ib2woKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdGhpcy5zeW1ib2wpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiIHx8IHRoaXMuYWN0aXZlU3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIjtcbiAgfVxuICBzZXRTdHJva2VXaWR0aCh3aWR0aCwgZW1pdCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICBjb25zdCBzaXplID0gd2lkdGggPCAwID8gMCA6IG5vcm1hbGl6ZVB4KHdpZHRoKTtcbiAgICBjb25zdCBtZXJnZWRTdHJva2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgc2l6ZSB9KTtcbiAgICB0aGlzLnN0cm9rZSA9IG1lcmdlZFN0cm9rZTtcbiAgICBpZiAoZW1pdCkge1xuICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UsIHdpZHRoKSk7XG4gICAgfVxuICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW5jU3ltYm9sUHJvcHModGhpcy5zeW1ib2wsIHsgY2ltQ2hhbmdlQ29udGV4dDogXCJyb290XCIgfSksIGVtaXQpO1xuICB9XG4gIGlzRmlsbENvbG9yUmFtcCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLmNvbmZpZy5zZWN0aW9ucy5maWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiY29sb3ItcmFtcFwiO1xuICB9XG4gIGlzU3Ryb2tlQ29sb3JSYW1wKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHRoaXMuY29uZmlnLnNlY3Rpb25zLnN0cm9rZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcImNvbG9yLXJhbXBcIjtcbiAgfVxuICBnZXRTYW1wbGVGaWxsQ29sb3JSYW1wQ29sb3IoKSB7XG4gICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbnMuZmlsbDtcbiAgICBjb25zdCBmaWxsID0gdGhpcy5maWxsO1xuICAgIHJldHVybiB0aGlzLmdldFNhbXBsZUNvbG9yUmFtcENvbG9yKHNlY3Rpb24sIGZpbGwuY29sb3IpO1xuICB9XG4gIGdldFNhbXBsZVN0cm9rZUNvbG9yUmFtcENvbG9yKCkge1xuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zLnN0cm9rZTtcbiAgICBjb25zdCBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICByZXR1cm4gdGhpcy5nZXRTYW1wbGVDb2xvclJhbXBDb2xvcihzZWN0aW9uLCBzdHJva2UuY29sb3IpO1xuICB9XG4gIGdldFNhbXBsZUNvbG9yUmFtcENvbG9yKHNlY3Rpb24sIHJhbXBDb2xvcnMpIHtcbiAgICBjb25zdCB0b3RhbENvbG9ycyA9IHJhbXBDb2xvcnMubGVuZ3RoO1xuICAgIGlmIChzZWN0aW9uLnN0eWxlID09PSBcIjJkXCIgfHwgc2VjdGlvbi5zdHlsZSA9PT0gXCJkaXNjcmV0ZVwiKSB7XG4gICAgICByZXR1cm4gcmFtcENvbG9yc1t0b3RhbENvbG9ycyAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gcmFtcENvbG9yc1tNYXRoLmZsb29yKHRvdGFsQ29sb3JzIC8gMildO1xuICB9XG4gIHNldFN5bWJvbFNpemUoc2l6ZSwgZW1pdCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hcmtlciwgZmlsbCwgc3Ryb2tlLCBzeW1ib2wgfSA9IHRoaXM7XG4gICAgY29uc3QgbWVyZ2VkTWFya2VyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXJrZXIpLCB7IHN5bWJvbDogdGhpcy5zeW5jU3ltYm9sUHJvcHMoc3ltYm9sLCB7XG4gICAgICAgIGNpbUNoYW5nZUNvbnRleHQ6IFwicm9vdFwiLFxuICAgICAgICBzeW1ib2xTdGF0ZToge1xuICAgICAgICAgIG1hcmtlcjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYXJrZXIpLCB7IHNpemUgfSksXG4gICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZVxuICAgICAgICB9XG4gICAgICB9KSwgc2l6ZSB9KTtcbiAgICB0aGlzLm1hcmtlciA9IG1lcmdlZE1hcmtlcjtcbiAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKG1lcmdlZE1hcmtlci5zeW1ib2wsIGVtaXQpO1xuICAgIGlmIChlbWl0KSB7XG4gICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlck1hcmtlckNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZE1hcmtlciwgc2l6ZSkpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgaWYgKHRoaXMucHJlcHBpbmdFZGl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5lbCk7XG4gICAgY29uc3QgeyBzZWN0aW9ucyB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgZWRpdGluZ0NJTSA9IGlzQ0lNU3ltYm9sKHRoaXMuYWN0aXZlU3ltYm9sKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtZmxvd1wiLCB7IHJlZjogKGVsKSA9PiB7XG4gICAgICAgIHRoaXMuZmxvd0VsID0gZWw7XG4gICAgICAgIC8vIHdlJ3JlIGhlcmUgYWZ0ZXIgY29tcG9uZW50RGlkTG9hZFxuICAgICAgICB0aGlzLmNoZWNrUG9wb3Zlck1heEhlaWdodCgpO1xuICAgICAgfSB9LCBoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBjbGFzczoge1xuICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogZGlyID09PSBcInJ0bFwiXG4gICAgICB9LCBkaXI6IGRpcixcbiAgICAgIC8vIG9taXR0aW5nIGBoZWFkaW5nYCBpbnRlbnRpb25hbGx5IHRvIGFsbG93IGVtYmVkZGluZyBpbnRvIGV4aXN0aW5nIHBhbmVsc1xuICAgICAgLy9oZWlnaHRTY2FsZT17dGhpcy5oZWlnaHRTY2FsZX1cbiAgICAgIGtleTogXCJtYWluXCIgfSwgW1xuICAgICAgKChfYiA9IChfYSA9IHNlY3Rpb25zLm1hcmtlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcnRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iucm90YXRpb24pID09PSBmYWxzZSAmJlxuICAgICAgICAoKF9kID0gKF9jID0gc2VjdGlvbnMubWFya2VyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wcmV2aWV3KSA9PT0gZmFsc2UgJiZcbiAgICAgICAgKChfZiA9IChfZSA9IHNlY3Rpb25zLm1hcmtlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnBhcnRzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2l6ZSkgPT09IGZhbHNlXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHRoaXMucmVuZGVyU3ltYm9sQmxvY2soKSxcbiAgICAgICFlZGl0aW5nQ0lNICYmIHNlY3Rpb25zLmZpbGwgPyB0aGlzLnJlbmRlckZpbGxCbG9jaygpIDogbnVsbCxcbiAgICAgICFlZGl0aW5nQ0lNICYmIHNlY3Rpb25zLnN0cm9rZSA/IHRoaXMucmVuZGVyU3Ryb2tlQmxvY2soKSA6IG51bGxcbiAgICBdKSwgdGhpcy5zdGF0ZSA9PT0gXCJjaG9vc2luZy1zeW1ib2xcIiA/IHRoaXMucmVuZGVyU3ltYm9sU2VsZWN0aW9uUGFuZWwoKSA6IG51bGwpKSk7XG4gIH1cbiAgcmVuZGVyU3ltYm9sQmxvY2soKSB7XG4gICAgY29uc3QgeyBtYXJrZXI6IHNlY3Rpb24sIHN0cm9rZTogc3Ryb2tlU2VjdGlvbiB9ID0gdGhpcy5zZWN0aW9ucztcbiAgICBjb25zdCB7IHBhcnRzOiBwYXJ0cyB9ID0gc2VjdGlvbjtcbiAgICBjb25zdCB7IGVkaXRHZW9tZXRyeSwgc3ltYm9sIH0gPSB0aGlzO1xuICAgIGNvbnN0IGlzQ0lNID0gaXNDSU1TeW1ib2woc3ltYm9sKTtcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgaWYgKHBhcnRzLnByZXZpZXcpIHtcbiAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyU3ltYm9sc1NlbGVjdGlvbigpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzQ0lNKSB7XG4gICAgICBpZiAodGhpcy5pc0ZpbGxDb2xvclJhbXAoKSkge1xuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyQ29sb3JSYW1wRmlsbEJsb2NrKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5pc1N0cm9rZUNvbG9yUmFtcCgpKSB7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJDb2xvclJhbXBTdHJva2VCbG9jayh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVkaXRHZW9tZXRyeSA9PT0gXCJwb2ludFwiKSB7XG4gICAgICBpZiAocGFydHMuc2l6ZSkge1xuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIGNvbnRlbnQ6IGlzQ0lNID8gdGhpcy5yZW5kZXJSb290Q0lNU3ltYm9sU2l6ZUNvbnRlbnQoKSA6IHRoaXMucmVuZGVyU3ltYm9sU2l6ZUNvbnRlbnQoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0cy5yb3RhdGlvbikge1xuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyU3ltYm9sUm90YXRpb25Db250ZW50KClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ0lNICYmIHN0cm9rZVNlY3Rpb24uZXh0cmFQYXJ0cy53aWR0aCkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHNwZWNpZmljIENJTSBzdXBwb3J0cyBhbiBvdXRsaW5lIHdpZHRoXG4gICAgICBpZiAoIWlzUG9seWdvbkNJTShzeW1ib2wpIHx8IChpc1BvbHlnb25DSU0oc3ltYm9sKSAmJiBzdXBwb3J0c091dGxpbmVXaWR0aChzeW1ib2wpKSkge1xuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyUm9vdENJTVN5bWJvbFdpZHRoQ29udGVudCgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDSU0pIHtcbiAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyUm9vdENJTVN5bWJvbENvbnRlbnQoc3ltYm9sKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3Rpb24oe1xuICAgICAga2V5OiBcIm1hcmtlci1zeW1ib2xzXCIsXG4gICAgICBzZWN0aW9uQ29udGVudDogY29udGVudFxuICAgIH0pO1xuICB9XG4gIHJlbmRlclJvb3RDSU1TeW1ib2xDb250ZW50KHN5bWJvbCkge1xuICAgIGNvbnN0IGxheWVyUGFuZWxzID0gdGhpcy5yZW5kZXJDSU1TeW1ib2xMYXllcnNDb250ZW50KHN5bWJvbC5kYXRhLnN5bWJvbCwgXCJyb290LXN5bWJvbFwiKTtcbiAgICBpZiAobGF5ZXJQYW5lbHMubGVuZ3RoID4gbWF4RGlzcGxheWVkU3ltYm9sTGF5ZXJzKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5sYXllclBhbmVscy5zbGljZSgwLCBtYXhEaXNwbGF5ZWRTeW1ib2xMYXllcnMpLFxuICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5tZXNzYWdlIH0sIHRoaXMubWVyZ2VkU3RyaW5ncy5hZGRpdGlvbmFsU3ltYm9sTGF5ZXJzTm90U2hvd24ucmVwbGFjZShcIiR7Y291bnR9XCIsIG1heERpc3BsYXllZFN5bWJvbExheWVycy50b1N0cmluZygpKSlcbiAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBsYXllclBhbmVscztcbiAgfVxuICByZW5kZXJDSU1TeW1ib2xMYXllcnNDb250ZW50KHsgc3ltYm9sTGF5ZXJzIH0sIGtleSwgY29udGVudE9ubHkgPSBmYWxzZSwgcGFyZW50U3ltYm9sTGF5ZXIpIHtcbiAgICByZXR1cm4gc3ltYm9sTGF5ZXJzXG4gICAgICAuZmlsdGVyKCh7IHR5cGUgfSkgPT4gdGhpcy5pc1N1cHBvcnRlZFN5bWJvbExheWVyVHlwZSh0eXBlKSlcbiAgICAgIC5tYXAoKHN5bWJvbExheWVyLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY29udGVudEtleSA9IGAke2tleX1fX3N5bWJvbC1sYXllcnNfX3N5bWJvbC1sYXllci0ke2luZGV4LnRvU3RyaW5nKCl9YDtcbiAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTVZlY3Rvck1hcmtlclwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNJTVZlY3Rvck1hcmtlclN5bWJvbExheWVyQmxvY2tzKHN5bWJvbExheWVyLCBjb250ZW50S2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTVBpY3R1cmVNYXJrZXJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDSU1QaWN0dXJlTWFya2VyU3ltYm9sTGF5ZXJCbG9jayhzeW1ib2xMYXllciwgY29udGVudEtleSwgY29udGVudE9ubHkpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bWJvbExheWVyLnR5cGUgPT09IFwiQ0lNU29saWRTdHJva2VcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDSU1Tb2xpZFN0cm9rZVN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGNvbnRlbnRLZXksIGNvbnRlbnRPbmx5LCBwYXJlbnRTeW1ib2xMYXllcik7XG4gICAgICB9XG4gICAgICBpZiAoc3ltYm9sTGF5ZXIudHlwZSA9PT0gXCJDSU1QaWN0dXJlU3Ryb2tlXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ0lNUGljdHVyZVN0cm9rZVN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGNvbnRlbnRLZXksIGNvbnRlbnRPbmx5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTVNvbGlkRmlsbFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNJTVNvbGlkRmlsbFN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGNvbnRlbnRLZXksIGNvbnRlbnRPbmx5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTUhhdGNoRmlsbFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckNJTUhhdGNoRmlsbFN5bWJvbExheWVyQmxvY2tzKHN5bWJvbExheWVyLCBjb250ZW50S2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1ib2xMYXllci50eXBlID09PSBcIkNJTVBpY3R1cmVGaWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ0lNUGljdHVyZUZpbGxTeW1ib2xMYXllckJsb2NrKHN5bWJvbExheWVyLCBjb250ZW50S2V5LCBjb250ZW50T25seSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5mbGF0KCk7XG4gIH1cbiAgcmVuZGVyU3ltYm9sc1NlbGVjdGlvbigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGFjdGl2ZVN5bWJvbCA9IHRoaXMucHJldmlld1N5bWJvbDtcbiAgICBjb25zdCBjb250cmFzdGluZ0JhY2tncm91bmRUaGVtZSA9IGFjdGl2ZVN5bWJvbFxuICAgICAgPyBlc3JpTW9kdWxlcy5wcmV2aWV3U3ltYm9sMkQuZ2V0Q29udHJhc3RpbmdCYWNrZ3JvdW5kVGhlbWUoYWN0aXZlU3ltYm9sLCAyNDUpXG4gICAgICA6IFwibGlnaHRcIjtcbiAgICBjb25zdCBpc1J0bCA9IGdldEVsZW1lbnREaXIodGhpcy5lbCkgPT09IFwicnRsXCI7XG4gICAgY29uc3Qgc2luZ2xlU291cmNlQW5kSXRlbUF2YWlsYWJsZSA9ICgoX2EgPSB0aGlzLmZpbHRlcmVkU291cmNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPT09IDEgJiYgKChfYiA9IHRoaXMuYWN0aXZlU3ltYm9sSXRlbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID09PSAxO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzdHlsZToge1xuICAgICAgICBcIi0tYXJjZ2lzLXN5bWJvbC1zdHlsZXItaW5saW5lLWlucHV0LXRyaWdnZXItYmFja2dyb3VuZC1jb2xvclwiOiBjb250cmFzdGluZ0JhY2tncm91bmRUaGVtZSA9PT0gXCJkYXJrXCIgPyBcIiNmM2YzZjNcIiA6IFwiXCJcbiAgICAgIH0gfSwgdGhpcy5tZXJnZWRTdHJpbmdzLmN1cnJlbnRTeW1ib2wsIGgoXCJidXR0b25cIiwgeyBjbGFzczogQ1NTLmNoYW5nZVN5bWJvbFRyaWdnZXIsIGRpc2FibGVkOiBzaW5nbGVTb3VyY2VBbmRJdGVtQXZhaWxhYmxlLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImNob29zaW5nLXN5bWJvbFwiO1xuICAgICAgfSwgdHlwZTogXCJidXR0b25cIiB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250YWluZXIsIHRhYkluZGV4OiAwIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnN5bWJvbCB9LCBoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc3ltYm9sLXByZXZpZXdcIiwgeyBzeW1ib2w6IGFjdGl2ZVN5bWJvbCwgb3B0aW9uczogdGhpcy5lZGl0R2VvbWV0cnkgPT09IFwicG9pbnRcIiA/IHBvaW50UHJldmlld09wdGlvbnMgOiBudWxsIH0pKSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MubGFiZWwgfSwgZ2V0U3ltYm9sTGFiZWwoYWN0aXZlU3ltYm9sLCB0aGlzLm1lcmdlZFN0cmluZ3MpKSksIGgoXCJjYWxjaXRlLWljb25cIiwgeyBpY29uOiBzaW5nbGVTb3VyY2VBbmRJdGVtQXZhaWxhYmxlID8gbnVsbCA6IGBjaGV2cm9uLSR7aXNSdGwgPyBcImxlZnRcIiA6IFwicmlnaHRcIn1gLCBzY2FsZTogXCJzXCIgfSkpKSk7XG4gIH1cbiAgcmVuZGVyU3ltYm9sU2VsZWN0aW9uUGFuZWwoKSB7XG4gICAgY29uc3QgeyBkaXIsIG1lcmdlZFN0cmluZ3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1mbG93LWl0ZW1cIiwgeyBjbGFzczoge1xuICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogZGlyID09PSBcInJ0bFwiLFxuICAgICAgICBcInN5bWJvbC1zZWxlY3Rpb24tcGFuZWxcIjogdHJ1ZVxuICAgICAgfSwgZGlyOiBkaXIsIGhlYWRpbmc6IG1lcmdlZFN0cmluZ3MuY2hhbmdlU3ltYm9sLFxuICAgICAgLy9oZWlnaHRTY2FsZT17dGhpcy5oZWlnaHRTY2FsZX1cbiAgICAgIGtleTogXCJzeW1ib2wtc2VsZWN0aW9uXCIsIGJlZm9yZUJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZWRpdGluZ1wiO1xuICAgICAgfSB9LCBoKFwiYXJjZ2lzLXN5bWJvbC1waWNrZXJcIiwgeyBsYW5nOiB0aGlzLmN1cnJlbnRMYW5ndWFnZSwgb25BcmNnaXNBY3RpdmVTeW1ib2xDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRldGFpbDogc3ltYm9sIH0gPSBldmVudDtcbiAgICAgICAgdGhpcy5vblN5bWJvbFNlbGVjdChzeW1ib2wpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sIG9uQXJjZ2lzQWN0aXZlU291cmNlSWRDaGFuZ2U6ICh7IGRldGFpbDogYWN0aXZlU291cmNlSWQgfSkgPT4ge1xuICAgICAgICB0aGlzLmFjdGl2ZVNvdXJjZUlkID0gYWN0aXZlU291cmNlSWQ7XG4gICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sU3R5bGVyU291cmNlSWRDaGFuZ2UuZW1pdChhY3RpdmVTb3VyY2VJZCk7XG4gICAgICB9LCBvbkFyY2dpc0FjdGl2ZVN5bWJvbEl0ZW1DaGFuZ2U6ICh7IGRldGFpbDogYWN0aXZlU3ltYm9sSXRlbSB9KSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZlU3ltYm9sSXRlbSA9IGFjdGl2ZVN5bWJvbEl0ZW07XG4gICAgICB9LCBvbkFyY2dpc1N5bWJvbFNvdXJjZXNDaGFuZ2U6ICh7IGRldGFpbDogZmlsdGVyZWRTb3VyY2VzIH0pID0+ICh0aGlzLmZpbHRlcmVkU291cmNlcyA9IGZpbHRlcmVkU291cmNlcyksIG9uQXJjZ2lzQWN0aXZlU291cmNlSXRlbXNDaGFuZ2U6ICh7IGRldGFpbDogYWN0aXZlU291cmNlSXRlbXMgfSkgPT4gKHRoaXMuYWN0aXZlU3ltYm9sSXRlbXMgPSBhY3RpdmVTb3VyY2VJdGVtcyksIGFjdGl2ZVN5bWJvbEl0ZW06IHRoaXMuYWN0aXZlU3ltYm9sSXRlbSwgYWN0aXZlU291cmNlSWQ6IHRoaXMuYWN0aXZlU291cmNlSWQgfHwgdGhpcy5pbml0aWFsU291cmNlSWQsIHBvcnRhbDogdGhpcy5wb3J0YWxPckludGVyY2VwdG9yLCBzdHlsZToge1xuICAgICAgICBcIi0tc2Nyb2xsZXItbWF4LWhlaWdodFwiOiBcInZhcigtLXN5bWJvbC1zY3JvbGxlci1tYXgtaGVpZ2h0KVwiXG4gICAgICB9LCBzeW1ib2xGaWx0ZXI6IHRoaXMuc3ltYm9sRmlsdGVyLCBzeW1ib2w6IHRoaXMuYWN0aXZlU3ltYm9sIH0pLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyB3aWR0aDogXCJmdWxsXCIsIHNsb3Q6IFwiZm9vdGVyXCIsIG9uQ2xpY2s6ICgpID0+IHRoaXMuZmxvd0VsLmJhY2soKSB9LCBtZXJnZWRTdHJpbmdzLmRvbmUpKSk7XG4gIH1cbiAgc2V0SW50ZXJuYWxTeW1ib2woc3ltYm9sLCBlbWl0KSB7XG4gICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgdGhpcy51cGRhdGVQcmV2aWV3U3ltYm9sKCk7XG4gICAgaWYgKGVtaXQpIHtcbiAgICAgIHRoaXMuZW1pdEVkaXQoc3ltYm9sKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyUm9vdENJTVN5bWJvbFNpemVDb250ZW50KCkge1xuICAgIGNvbnN0IHsgc2VjdGlvbnM6IHsgbWFya2VyOiB7IHBhcnRzOiB7IHNpemUgfSB9IH0sIG1hcmtlciB9ID0gdGhpcztcbiAgICBjb25zdCBtYXggPSAxNTA7XG4gICAgY29uc3QgbWluID0gMTtcbiAgICBjb25zdCBhdXRvU2l6ZUFkanVzdCA9IHR5cGVvZiBzaXplID09PSBcIm9iamVjdFwiICYmIChzaXplID09PSBudWxsIHx8IHNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpemUuYXV0b1NpemVBZGp1c3QpO1xuICAgIGNvbnN0IGxhcmdlc3RTaXplID0gZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuZ2V0Q0lNU3ltYm9sU2l6ZSh0aGlzLnN5bWJvbCk7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50R3JvdXAgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUsIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBhdXRvU2l6ZUFkanVzdCAmJiBhdXRvU2l6ZUFkanVzdCAhPT0gXCJlZGl0YWJsZVwiICYmIG1hcmtlci5hdXRvQWRqdXN0ZWQsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnB4LCB2YWx1ZTogbm9ybWFsaXplUHgoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHQycHgobGFyZ2VzdFNpemUpKSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblN5bWJvbFNpemVDaGFuZ2UsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUgfSkpLCBhdXRvU2l6ZUFkanVzdFxuICAgICAgPyB0aGlzLnJlbmRlckF1dG9BZGp1c3QoZ2V0RWxlbWVudERpcih0aGlzLmVsKSwgdGhpcy5tYXJrZXIuYXV0b0FkanVzdGVkLCB0aGlzLm1lcmdlZFN0cmluZ3MuYXV0b0FkanVzdFNpemUsIHRoaXMub25BdXRvQWRqdXN0U2l6ZUNoYW5nZSlcbiAgICAgIDogbnVsbCkpO1xuICB9XG4gIHJlbmRlclJvb3RDSU1TeW1ib2xXaWR0aENvbnRlbnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGZvciBwb2x5Z29uIENJTXMgaXQgb25seSBjb21lcyBoZXJlIGZvciBhbiBvdXRsaW5lXG4gICAgY29uc3Qgc3ltYm9sID0gdGhpcy5zeW1ib2w7XG4gICAgY29uc3QgeyBzZWN0aW9uczogeyBzdHJva2U6IHsgZXh0cmFQYXJ0czogeyBhdXRvU3Ryb2tlQWRqdXN0IH0gfSB9LCBzdHJva2UgfSA9IHRoaXM7XG4gICAgY29uc3QgZGlyID0gZ2V0RWxlbWVudERpcih0aGlzLmVsKTtcbiAgICBjb25zdCB3aWR0aCA9IGlzUG9seWdvbkNJTShzeW1ib2wpXG4gICAgICA/IGdldE91dGxpbmVXaWR0aChzeW1ib2wpXG4gICAgICA6IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbFNpemUodGhpcy5zeW1ib2wpO1xuICAgIGxldCBsYWJlbCA9IHRoaXMuZ2V0U3Ryb2tlU3RyaW5nKFwid2lkdGhcIik7XG4gICAgbGV0IG1pbiA9IHRoaXMuY2ltU3Ryb2tlV2lkdGhCb3VuZHMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLmNpbVN0cm9rZVdpZHRoQm91bmRzLm1heDtcbiAgICBpZiAoaXNMaW5lQ0lNKHN5bWJvbCkpIHtcbiAgICAgIC8vIGlmIGl0IGhhcyBtYXJrZXJzIHdlIHNob3VsZCB0cmVhdCBpdCBhcyBzaXplLCBub3Qgd2lkdGhcbiAgICAgIGNvbnN0IGhhc01hcmtlciA9IChfYSA9IHN5bWJvbC5kYXRhLnN5bWJvbC5zeW1ib2xMYXllcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChzeW1ib2xMYXllcikgPT4gW1wiQ0lNVmVjdG9yTWFya2VyXCIsIFwiQ0lNUGljdHVyZU1hcmtlclwiXS5pbmRleE9mKHN5bWJvbExheWVyLnR5cGUpID4gLTEpO1xuICAgICAgaWYgKGhhc01hcmtlcikge1xuICAgICAgICBsYWJlbCA9IHRoaXMubWVyZ2VkU3RyaW5ncy5zeW1ib2xTaXplO1xuICAgICAgICBtaW4gPSBzaXplTWluO1xuICAgICAgICBtYXggPSBzaXplTWF4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnRHcm91cCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGRpcjogZGlyIH0sIGxhYmVsLCBoKFNlbGVjdE51bWJlciwgeyBkaXNhYmxlZDogYXV0b1N0cm9rZUFkanVzdCAmJiBhdXRvU3Ryb2tlQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgc3Ryb2tlLmF1dG9BZGp1c3RlZCwgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBub3JtYWxpemVQeChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweCh3aWR0aCkpLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uU3Ryb2tlV2lkdGhDaGFuZ2UsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbGFiZWwgfSkpLCBhdXRvU3Ryb2tlQWRqdXN0XG4gICAgICA/IHRoaXMucmVuZGVyQXV0b0FkanVzdChkaXIsIHRoaXMuc3Ryb2tlLmF1dG9BZGp1c3RlZCwgdGhpcy5tZXJnZWRTdHJpbmdzLmF1dG9BZGp1c3RTdHJva2UsIHRoaXMub25BdXRvQWRqdXN0U3Ryb2tlQ2hhbmdlKVxuICAgICAgOiBudWxsKSk7XG4gIH1cbiAgcmVuZGVyU3ltYm9sU2l6ZUNvbnRlbnQoKSB7XG4gICAgY29uc3QgeyBzZWN0aW9uczogeyBtYXJrZXI6IHsgcGFydHM6IHsgc2l6ZSB9IH0gfSwgbWFya2VyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5lbCk7XG4gICAgY29uc3QgbWF4ID0gMTUwO1xuICAgIGNvbnN0IG1pbiA9IDE7XG4gICAgY29uc3QgYXV0b1NpemVBZGp1c3QgPSB0eXBlb2Ygc2l6ZSA9PT0gXCJvYmplY3RcIiAmJiAoc2l6ZSA9PT0gbnVsbCB8fCBzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaXplLmF1dG9TaXplQWRqdXN0KTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnRHcm91cCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IGF1dG9TaXplQWRqdXN0ICYmIGF1dG9TaXplQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgbWFya2VyLmF1dG9BZGp1c3RlZCwgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBtYXJrZXIuc2l6ZSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblN5bWJvbFNpemVDaGFuZ2UsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUgfSkpLCBhdXRvU2l6ZUFkanVzdFxuICAgICAgPyB0aGlzLnJlbmRlckF1dG9BZGp1c3QoZGlyLCBtYXJrZXIuYXV0b0FkanVzdGVkLCB0aGlzLm1lcmdlZFN0cmluZ3MuYXV0b0FkanVzdFNpemUsIHRoaXMub25BdXRvQWRqdXN0U2l6ZUNoYW5nZSlcbiAgICAgIDogbnVsbCkpO1xuICB9XG4gIHJlbmRlckF1dG9BZGp1c3QoZGlyLCBhZGp1c3RlZCwgbGFiZWwsIGNoYW5nZUhhbmRsZXIpIHtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgY2xhc3M6IENTUy5hdXRvQWRqdXN0TGFiZWwsIGRpcjogZGlyLCBsYXlvdXQ6IFwiaW5saW5lXCIsIGtleTogXCJhdXRvLWFkanVzdFwiIH0sIGgoXCJjYWxjaXRlLWNoZWNrYm94XCIsIHsgY2hlY2tlZDogYWRqdXN0ZWQsIGNsYXNzOiBDU1MuYXV0b0FkanVzdENoZWNrYm94LCBvbkNhbGNpdGVDaGVja2JveENoYW5nZTogY2hhbmdlSGFuZGxlciB9KSwgbGFiZWwpKTtcbiAgfVxuICByZW5kZXJTeW1ib2xSb3RhdGlvbkNvbnRlbnQoKSB7XG4gICAgY29uc3QgeyBtYXJrZXIsIG1lcmdlZFN0cmluZ3MgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4ID0gMzYwO1xuICAgIGNvbnN0IG1pbiA9IDA7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLnJvdGF0aW9uLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiXFx1MDBCQVwiLCBmbGlwTGFiZWxzOiB0aGlzLmRpciA9PT0gXCJydGxcIiwgdmFsdWU6IG1hcmtlci5hbmdsZSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblN5bWJvbFJvdGF0aW9uQ2hhbmdlLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3Mucm90YXRpb24gfSkpKTtcbiAgfVxuICByZW5kZXJGaWxsQmxvY2soKSB7XG4gICAgY29uc3QgeyBmaWxsIH0gPSB0aGlzLmNvbmZpZy5zZWN0aW9ucztcbiAgICBpZiAoZmlsbC50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckNvbG9yRmlsbEJsb2NrKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlckNvbG9yUmFtcEZpbGxCbG9jaygpO1xuICB9XG4gIHJlbmRlckNvbG9yRmlsbEJsb2NrKCkge1xuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zLmZpbGw7XG4gICAgY29uc3QgeyBwYXJ0cyB9ID0gc2VjdGlvbjtcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgaWYgKHBhcnRzLnN1Z2dlc3RlZENvbG9ycyB8fCBwYXJ0cy5jdXN0b21Db2xvcikge1xuICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJGaWxsQ29sb3JDb250ZW50KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFydHMudHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICBjb250ZW50OiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwgZGlzYWJsZWQ6ICFzZWN0aW9uLmVuYWJsZWQgfSwgdGhpcy5yZW5kZXJDb2xvckZpbGxUcmFuc3BhcmVuY3lDb250ZW50KHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5LCAhc2VjdGlvbi5lbmFibGVkKSkpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyU2VjdGlvbih7XG4gICAgICBrZXk6IFwiY29sb3ItZmlsbFwiLFxuICAgICAgZGlzYWJsZWQ6IHNlY3Rpb24ub3B0aW9uYWwgPT09IFwibm9uLWVkaXRhYmxlXCIgfHxcbiAgICAgICAgdGhpcy5oYXNBY3RpdmVQaWN0dXJlTWFya2VyU3ltYm9sKCkgfHxcbiAgICAgICAgdGhpcy5oYXNBY3RpdmVMaW5lT25seVNpbXBsZU1hcmtlclN5bWJvbCgpLFxuICAgICAgc2VjdGlvbkNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICB0b0NvbG9yUGlja2VyVmFsdWUoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yIHx8IGlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3IudG9IZXgoKTtcbiAgfVxuICByZW5kZXJGaWxsQ29sb3JDb250ZW50KCkge1xuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25zLmZpbGw7XG4gICAgY29uc3QgY29sb3IgPSBzZWN0aW9uLmVuYWJsZWQgPyB0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZSh0aGlzLmZpbGwuY29sb3IpIDogbnVsbDtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsQ29sb3IsIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogY29sb3IsXG4gICAgICAvL2NvbXBhY3Q9e3RoaXMubmFycm93fVxuICAgICAgY2xlYXJhYmxlOiBzZWN0aW9uLm9wdGlvbmFsICE9PSBmYWxzZSwgb25BcmNnaXNDb2xvcklucHV0Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb2xvciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuY29sb3I7XG4gICAgICAgIGlmICghc2VsZWN0ZWRDb2xvcikge1xuICAgICAgICAgIHRoaXMub25GaWxsRW5hYmxlZENoYW5nZShmYWxzZSk7XG4gICAgICAgICAgLy8gbm8gdXBkYXRlcyB0byBjb2xvciBuZWVkZWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWN0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLm9uRmlsbEVuYWJsZWRDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoc2VsZWN0ZWRDb2xvcik7XG4gICAgICAgIGNvbnN0IHsgY29sb3I6IGN1cnJlbnRDb2xvciB9ID0gdGhpcy5maWxsO1xuICAgICAgICBjb25zdCBtZXJnZWRDb2xvciA9IGFkanVzdFRyYW5zcGFyZW5jeUlmTmVlZGVkKGN1cnJlbnRDb2xvciwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRDb2xvciksIGNvbG9yKSwgeyBhOiBjdXJyZW50Q29sb3IuYSB9KSk7XG4gICAgICAgIGNvbnN0IG1lcmdlZEZpbGwgPSB7XG4gICAgICAgICAgY29sb3I6IGNyZWF0ZShtZXJnZWRDb2xvcilcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWxsID0gbWVyZ2VkRmlsbDtcbiAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJGaWxsQ2hhbmdlLmVtaXQobWVyZ2VkRmlsbCk7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW5jU3ltYm9sUHJvcHModGhpcy5zeW1ib2wpLCB0cnVlKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpO1xuICB9XG4gIGdldFN0cm9rZVN0cmluZyhwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2VkU3RyaW5nc1t0aGlzLmVkaXRHZW9tZXRyeSA9PT0gXCJsaW5lXCIgPyBwcm9wIDogYHN0cm9rZSR7Y2FwaXRhbGl6ZShwcm9wKX1gXTtcbiAgfVxuICBpc1N1cHBvcnRlZFN5bWJvbExheWVyVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSBcIkNJTVZlY3Rvck1hcmtlclwiIHx8XG4gICAgICB0eXBlID09PSBcIkNJTVNvbGlkRmlsbFwiIHx8XG4gICAgICB0eXBlID09PSBcIkNJTVNvbGlkU3Ryb2tlXCIgfHxcbiAgICAgIHR5cGUgPT09IFwiQ0lNSGF0Y2hGaWxsXCIgfHxcbiAgICAgIHR5cGUgPT09IFwiQ0lNUGljdHVyZUZpbGxcIiB8fFxuICAgICAgdHlwZSA9PT0gXCJDSU1QaWN0dXJlU3Ryb2tlXCIgfHxcbiAgICAgIHR5cGUgPT09IFwiQ0lNUGljdHVyZU1hcmtlclwiKTtcbiAgfVxuICBnZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2woc3ltYm9sTGF5ZXIsIGdlb21ldHJ5VHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzeW1ib2xQcm9wcyA9IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHlwZTogXCJDSU1TeW1ib2xSZWZlcmVuY2VcIixcbiAgICAgICAgc3ltYm9sOiB7XG4gICAgICAgICAgdHlwZTogZ2VvbWV0cnlUeXBlID09PSBcInBvaW50XCJcbiAgICAgICAgICAgID8gXCJDSU1Qb2ludFN5bWJvbFwiXG4gICAgICAgICAgICA6IGdlb21ldHJ5VHlwZSA9PT0gXCJsaW5lXCJcbiAgICAgICAgICAgICAgPyBcIkNJTUxpbmVTeW1ib2xcIlxuICAgICAgICAgICAgICA6IFwiQ0lNUG9seWdvblN5bWJvbFwiLFxuICAgICAgICAgIHN5bWJvbExheWVyczogW3N5bWJvbExheWVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoc3ltYm9sTGF5ZXIudHlwZSA9PT0gXCJDSU1WZWN0b3JNYXJrZXJcIikge1xuICAgICAgc3ltYm9sUHJvcHMuZGF0YS5zeW1ib2wuYW5nbGUgPSAoX2EgPSBzeW1ib2xMYXllci5yb3RhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBlc3JpTW9kdWxlcy5DSU1TeW1ib2woc3ltYm9sUHJvcHMpO1xuICB9XG4gIHJlbmRlckNJTVZlY3Rvck1hcmtlclN5bWJvbExheWVyQmxvY2tzKHN5bWJvbExheWVyLCBrZXkpIHtcbiAgICBjb25zdCB7IHNlY3Rpb25zOiB7IG1hcmtlcjogeyBwYXJ0czogeyBzaXplIH0gfSwgc3Ryb2tlOiB7IGV4dHJhUGFydHM6IHsgYXV0b1N0cm9rZUFkanVzdCB9IH0gfSwgbWFya2VyLCBtZXJnZWRTdHJpbmdzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGF1dG9TaXplQWRqdXN0ID0gdHlwZW9mIHNpemUgPT09IFwib2JqZWN0XCIgJiYgKHNpemUgPT09IG51bGwgfHwgc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2l6ZS5hdXRvU2l6ZUFkanVzdCk7XG4gICAgY29uc3QgdXBkYXRlVGFyZ2V0U3ltYm9sID0gdGhpcy5nZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2woc3ltYm9sTGF5ZXIsIFwicG9pbnRcIik7XG4gICAgY29uc3Qgc3ltYm9sU2l6ZSA9IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbFNpemUodXBkYXRlVGFyZ2V0U3ltYm9sKTtcbiAgICBjb25zdCBzeW1ib2xSb3RhdGlvbiA9IGVzcmlNb2R1bGVzLmNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbFJvdGF0aW9uKHVwZGF0ZVRhcmdldFN5bWJvbCwgdHJ1ZSk7XG4gICAgY29uc3QgY29sb3JDb250ZXh0ID0gZ2V0Q2hpbGRTeW1ib2xMYXllckNvbG9yQ29udGV4dChzeW1ib2xMYXllcik7XG4gICAgY29uc3QgZmlsbEFuZFN0cm9rZVNlY3Rpb25zID0gW107XG4gICAgaWYgKGNvbG9yQ29udGV4dC5pbmNsdWRlcyhcImZpbGxcIikgJiYgKCF0aGlzLmlzRmlsbENvbG9yUmFtcCgpIHx8IHN5bWJvbExheWVyLmNvbG9yTG9ja2VkKSkge1xuICAgICAgY29uc3QgZmlsbENvbG9yID0gZ2V0VmVjdG9yTWFya2VyQ29sb3Ioc3ltYm9sTGF5ZXIsIFwiZmlsbFwiKTtcbiAgICAgIGNvbnN0IGZpbGxDb250ZW50ID0gW1xuICAgICAgICBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGtleTogXCJmaWxsLWNvbG9yXCIgfSwgY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMSA/IG1lcmdlZFN0cmluZ3MuY29sb3IgOiBtZXJnZWRTdHJpbmdzLmZpbGxDb2xvciwgaChcImRpdlwiLCB7IGNsYXNzOiBcImlucHV0LWNvbG9yXCIgfSwgaChcImFyY2dpcy1jb2xvci1pbnB1dFwiLCB7IGNvbG9yOiB0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZShmaWxsQ29sb3IpLFxuICAgICAgICAgIC8vY29tcGFjdD17dGhpcy5uYXJyb3d9XG4gICAgICAgICAgY2xlYXJhYmxlOiB0cnVlLCBvbkFyY2dpc0NvbG9ySW5wdXRDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcik7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikgJiYgIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihmaWxsQ29sb3IpKSB7XG4gICAgICAgICAgICAgIGNvbG9yLmEgPSBmaWxsQ29sb3IuYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVN5bWJvbExheWVyQ29sb3Ioc3ltYm9sTGF5ZXIsIGNvbG9yLCBcImZpbGxcIik7XG4gICAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH0sIHBvcG92ZXJQcm9wczogdGhpcy5wb3BvdmVyUHJvcHMsIHN0b3JhZ2VJZDogY29sb3JTdG9yYWdlSWQsIHJlZjogdGhpcy5zZXRDb2xvcklucHV0UmVmIH0pKSksXG4gICAgICAgIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsga2V5OiBcImZpbGwtdHJhbnNwYXJlbmN5XCIgfSwgY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMSA/IG1lcmdlZFN0cmluZ3MudHJhbnNwYXJlbmN5IDogbWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5LCBoKFNlbGVjdE51bWJlciwgeyBtaW46IG9wYWNpdHlNaW4sIG1heDogb3BhY2l0eU1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3koZmlsbENvbG9yLmEpLCBvblZhbHVlQ2hhbmdlOiAodHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEodHJhbnNwYXJlbmN5KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZmlsbENvbG9yLmNsb25lKCk7XG4gICAgICAgICAgICBjb2xvci5hID0gYWxwaGE7XG4gICAgICAgICAgICB1cGRhdGVTeW1ib2xMYXllckNvbG9yKHN5bWJvbExheWVyLCBjb2xvciwgXCJmaWxsXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBjb2xvckNvbnRleHQubGVuZ3RoID09PSAxXG4gICAgICAgICAgICA/IG1lcmdlZFN0cmluZ3MudHJhbnNwYXJlbmN5XG4gICAgICAgICAgICA6IG1lcmdlZFN0cmluZ3MuZmlsbFRyYW5zcGFyZW5jeSB9KSlcbiAgICAgIF07XG4gICAgICBmaWxsQW5kU3Ryb2tlU2VjdGlvbnMucHVzaChmaWxsQ29udGVudCk7XG4gICAgfVxuICAgIGlmIChjb2xvckNvbnRleHQuaW5jbHVkZXMoXCJzdHJva2VcIikpIHtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gZ2V0VmVjdG9yTWFya2VyQ29sb3Ioc3ltYm9sTGF5ZXIsIFwic3Ryb2tlXCIpO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBnZXRWZWN0b3JNYXJrZXJTaXplKHN5bWJvbExheWVyLCBcInN0cm9rZVwiKTtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbnRlbnQgPSBbXG4gICAgICAgIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsga2V5OiBcInN0cm9rZS1jb2xvclwiIH0sIGNvbG9yQ29udGV4dC5sZW5ndGggPT09IDEgPyBtZXJnZWRTdHJpbmdzLmNvbG9yIDogbWVyZ2VkU3RyaW5ncy5zdHJva2VDb2xvciwgaChcImRpdlwiLCB7IGNsYXNzOiBcImlucHV0LWNvbG9yXCIgfSwgaChcImFyY2dpcy1jb2xvci1pbnB1dFwiLCB7IGNvbG9yOiB0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZShzdHJva2VDb2xvciksXG4gICAgICAgICAgLy9jb21wYWN0PXt0aGlzLm5hcnJvd31cbiAgICAgICAgICBjbGVhcmFibGU6IHRydWUsIG9uQXJjZ2lzQ29sb3JJbnB1dENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGNyZWF0ZShldmVudC5jdXJyZW50VGFyZ2V0LmNvbG9yKTtcbiAgICAgICAgICAgIGlmICghaXNOdWxsRXF1aXZhbGVudENvbG9yKGNvbG9yKSAmJiAhaXNOdWxsRXF1aXZhbGVudENvbG9yKHN0cm9rZUNvbG9yKSkge1xuICAgICAgICAgICAgICBjb2xvci5hID0gc3Ryb2tlQ29sb3IuYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVN5bWJvbExheWVyQ29sb3Ioc3ltYm9sTGF5ZXIsIGNvbG9yLCBcInN0cm9rZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfSwgcG9wb3ZlclByb3BzOiB0aGlzLnBvcG92ZXJQcm9wcywgc3RvcmFnZUlkOiBjb2xvclN0b3JhZ2VJZCwgcmVmOiB0aGlzLnNldENvbG9ySW5wdXRSZWYgfSkpKSxcbiAgICAgICAgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBrZXk6IFwic3Ryb2tlLXRyYW5zcGFyZW5jeVwiIH0sIGNvbG9yQ29udGV4dC5sZW5ndGggPT09IDFcbiAgICAgICAgICA/IG1lcmdlZFN0cmluZ3MudHJhbnNwYXJlbmN5XG4gICAgICAgICAgOiBtZXJnZWRTdHJpbmdzLnN0cm9rZVRyYW5zcGFyZW5jeSwgaChTZWxlY3ROdW1iZXIsIHsgbWluOiBvcGFjaXR5TWluLCBtYXg6IG9wYWNpdHlNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIHZhbHVlOiBhbHBoYVRvVHJhbnNwYXJlbmN5KHN0cm9rZUNvbG9yLmEpLCBvblZhbHVlQ2hhbmdlOiAodHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEodHJhbnNwYXJlbmN5KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gc3Ryb2tlQ29sb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbG9yLmEgPSBhbHBoYTtcbiAgICAgICAgICAgIHVwZGF0ZVN5bWJvbExheWVyQ29sb3Ioc3ltYm9sTGF5ZXIsIGNvbG9yLCBcInN0cm9rZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyBtZXJnZWRTdHJpbmdzLnRyYW5zcGFyZW5jeVxuICAgICAgICAgICAgOiBtZXJnZWRTdHJpbmdzLnN0cm9rZVRyYW5zcGFyZW5jeSB9KSksXG4gICAgICAgIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsga2V5OiBcInN0cm9rZS13aWR0aFwiIH0sIGNvbG9yQ29udGV4dC5sZW5ndGggPT09IDEgPyBtZXJnZWRTdHJpbmdzLndpZHRoIDogbWVyZ2VkU3RyaW5ncy5zdHJva2VXaWR0aCwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IGF1dG9TdHJva2VBZGp1c3QgJiYgYXV0b1N0cm9rZUFkanVzdCAhPT0gXCJlZGl0YWJsZVwiICYmIHRoaXMuc3Ryb2tlLmF1dG9BZGp1c3RlZCwgbWluOiB0aGlzLmNpbVN0cm9rZVdpZHRoQm91bmRzLm1pbiwgbWF4OiB0aGlzLmNpbVN0cm9rZVdpZHRoQm91bmRzLm1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogbWVyZ2VkU3RyaW5ncy5weCwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHN0cm9rZVdpZHRoKSksIG9uVmFsdWVDaGFuZ2U6ICh3aWR0aCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlU3ltYm9sTGF5ZXJTaXplKHN5bWJvbExheWVyLCBub3JtYWxpemVQdChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5weDJwdCh3aWR0aCkpLCBcInN0cm9rZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogY29sb3JDb250ZXh0Lmxlbmd0aCA9PT0gMSA/IG1lcmdlZFN0cmluZ3Mud2lkdGggOiBtZXJnZWRTdHJpbmdzLnN0cm9rZVdpZHRoIH0pKVxuICAgICAgXTtcbiAgICAgIGZpbGxBbmRTdHJva2VTZWN0aW9ucy5wdXNoKHN0cm9rZUNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnRHcm91cCwga2V5OiBgJHtrZXl9X192ZWN0b3ItbWFya2VyLXN5bWJvbC1sYXllcmAgfSwgWy4uLmZpbGxBbmRTdHJva2VTZWN0aW9uc10sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IGF1dG9TaXplQWRqdXN0ICYmIGF1dG9TaXplQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgbWFya2VyLmF1dG9BZGp1c3RlZCwgbWluOiBzaXplTWluLCBtYXg6IHNpemVNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IG1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBub3JtYWxpemVQeChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweChzeW1ib2xTaXplKSksIG9uVmFsdWVDaGFuZ2U6IChzaXplKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0TWFya2VyU3ltYm9sTGF5ZXJTaXplKHVwZGF0ZVRhcmdldFN5bWJvbCwgc2l6ZSk7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBtZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLnJvdGF0aW9uLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IHJvdGF0aW9uTWluLCBtYXg6IHJvdGF0aW9uTWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIlxcdTAwQkFcIiwgZmxpcExhYmVsczogdGhpcy5kaXIgPT09IFwicnRsXCIsIHZhbHVlOiBub3JtYWxpemVQeE9yUHQoc3ltYm9sUm90YXRpb24pLCBvblZhbHVlQ2hhbmdlOiAocm90YXRpb24pID0+IHtcbiAgICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuYXBwbHlDSU1TeW1ib2xSb3RhdGlvbih1cGRhdGVUYXJnZXRTeW1ib2wsIG5vcm1hbGl6ZVB4T3JQdChyb3RhdGlvbiksIHRydWUpO1xuICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbWVyZ2VkU3RyaW5ncy5yb3RhdGlvbiB9KSksIHRoaXMucmVuZGVyQ0lNTWFya2VyUGxhY2VtZW50U2VjdGlvbihzeW1ib2xMYXllcikpKTtcbiAgICBjb25zdCBzeW1ib2xMYXllclByZXZpZXcgPSB0aGlzLmdldFN5bWJvbExheWVyUHJldmlld1N5bWJvbCh0aGlzLnNhbml0aXplUG9pbnRQcmV2aWV3U3ltYm9sTGF5ZXIoc3ltYm9sTGF5ZXIpLCBcInBvaW50XCIpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlckJsb2NrKHtcbiAgICAgIGljb246IChoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc3ltYm9sLXByZXZpZXdcIiwgeyBjb250cmFzdDogdHJ1ZSwga2V5OiBgJHtrZXl9X19zeW1ib2wtbGF5ZXItcHJldmlld2AsIHN5bWJvbDogc3ltYm9sTGF5ZXJQcmV2aWV3LCBvcHRpb25zOiBwb2ludFByZXZpZXdPcHRpb25zLCBzbG90OiBcImljb25cIiB9KSksXG4gICAgICBrZXk6IGAke2tleX1fX3N5bWJvbC1sYXllcmAsXG4gICAgICBoZWFkaW5nOiBtZXJnZWRTdHJpbmdzLnZlY3Rvck1hcmtlcixcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICBzZXRNYXJrZXJTeW1ib2xMYXllclNpemUoc3ltYm9sLCBzaXplKSB7XG4gICAgaWYgKGlzUG9pbnRDSU0odGhpcy5hY3RpdmVTeW1ib2wpKSB7XG4gICAgICBzeW1ib2wuZGF0YS5zeW1ib2wuc3ltYm9sTGF5ZXJzWzBdLnNpemUgPSBub3JtYWxpemVQdChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5weDJwdChzaXplKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZXNyaU1vZHVsZXMuY2ltU3ltYm9sVXRpbHMuc2NhbGVDSU1TeW1ib2xUbyhzeW1ib2wsIG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KHNpemUpKSk7XG4gICAgfVxuICB9XG4gIHJlbmRlckNJTVNvbGlkRmlsbFN5bWJvbExheWVyQmxvY2soc3ltYm9sTGF5ZXIsIGtleSwgY29udGVudE9ubHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IGNyZWF0ZShzeW1ib2xMYXllci5jb2xvciwgdHJ1ZSk7XG4gICAgY29uc3Qgbm9GaWxsQ29sb3IgPSBpc051bGxFcXVpdmFsZW50Q29sb3IoZmlsbENvbG9yKTtcbiAgICBsZXQgY29sb3JDb250ZW50ID0gbnVsbDtcbiAgICBsZXQgdHJhbnNwYXJlbmN5Q29udGVudCA9IG51bGw7XG4gICAgaWYgKCF0aGlzLmlzRmlsbENvbG9yUmFtcCgpIHx8IHN5bWJvbExheWVyLmNvbG9yTG9ja2VkKSB7XG4gICAgICBjb2xvckNvbnRlbnQgPSAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxDb2xvciwgaChcImRpdlwiLCB7IGNsYXNzOiBcImlucHV0LWNvbG9yXCIgfSwgaChcImFyY2dpcy1jb2xvci1pbnB1dFwiLCB7IGNvbG9yOiB0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZShmaWxsQ29sb3IpLFxuICAgICAgICAvL2NvbXBhY3Q9e3RoaXMubmFycm93fVxuICAgICAgICBjbGVhcmFibGU6IHRydWUsIG9uQXJjZ2lzQ29sb3JJbnB1dENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcik7XG4gICAgICAgICAgaWYgKCFpc051bGxFcXVpdmFsZW50Q29sb3IoY29sb3IpICYmICFub0ZpbGxDb2xvcikge1xuICAgICAgICAgICAgY29sb3IuYSA9IGZpbGxDb2xvci5hO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzeW1ib2xMYXllci5jb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpKTtcbiAgICAgIHRyYW5zcGFyZW5jeUNvbnRlbnQgPSAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3ksIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWluOiBvcGFjaXR5TWluLCBtYXg6IG9wYWNpdHlNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCB2YWx1ZTogYWxwaGFUb1RyYW5zcGFyZW5jeShmaWxsQ29sb3IuYSksIGRpc2FibGVkOiBub0ZpbGxDb2xvciwgb25WYWx1ZUNoYW5nZTogKHRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFscGhhID0gdHJhbnNwYXJlbmN5VG9BbHBoYSh0cmFuc3BhcmVuY3kpO1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gZmlsbENvbG9yLmNsb25lKCk7XG4gICAgICAgICAgY29sb3IuYSA9IGFscGhhO1xuICAgICAgICAgIHN5bWJvbExheWVyLmNvbG9yID0gY29sb3IudG9KU09OKCk7XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3kgfSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IGNvbG9yQ29udGVudCB8fCB0cmFuc3BhcmVuY3lDb250ZW50ID8gKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGtleTogYCR7a2V5fV9fc29saWQtZmlsbC1zeW1ib2wtbGF5ZXItY29udGVudGAgfSwgY29sb3JDb250ZW50LCBoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGVtYmVkZGVkOiB0cnVlLCBkaXNhYmxlZDogbm9GaWxsQ29sb3IgfSwgdHJhbnNwYXJlbmN5Q29udGVudCkpKSA6IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3MuZW1wdHlTeW1ib2xMYXllck1zZykpO1xuICAgIGlmIChjb250ZW50T25seSkge1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbExheWVyUHJldmlldyA9IHRoaXMuZ2V0U3ltYm9sTGF5ZXJQcmV2aWV3U3ltYm9sKHN5bWJvbExheWVyLCBcInBvbHlnb25cIik7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyQmxvY2soe1xuICAgICAgaWNvbjogKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zeW1ib2wtcHJldmlld1wiLCB7IGNvbnRyYXN0OiB0cnVlLCBrZXk6IGAke2tleX1fX3NvbGlkLWZpbGwtc3ltYm9sLWxheWVyLXByZXZpZXdgLCBzeW1ib2w6IHN5bWJvbExheWVyUHJldmlldywgc2xvdDogXCJpY29uXCIgfSkpLFxuICAgICAgaGVhZGluZzogdGhpcy5tZXJnZWRTdHJpbmdzLnNvbGlkRmlsbCxcbiAgICAgIGtleTogYCR7a2V5fV9fc29saWQtZmlsbC1zeW1ib2wtbGF5ZXJgLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIHJlbmRlckNJTVNvbGlkU3Ryb2tlU3ltYm9sTGF5ZXJCbG9jayhzeW1ib2xMYXllciwga2V5LCBjb250ZW50T25seSA9IGZhbHNlLCBwYXJlbnRTeW1ib2xMYXllcikge1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gY3JlYXRlKHN5bWJvbExheWVyLmNvbG9yLCB0cnVlKTtcbiAgICBjb25zdCB3aXRoaW5IYXRjaEZpbGxTeW1ib2xMYXllciA9IChwYXJlbnRTeW1ib2xMYXllciA9PT0gbnVsbCB8fCBwYXJlbnRTeW1ib2xMYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50U3ltYm9sTGF5ZXIudHlwZSkgPT09IFwiQ0lNSGF0Y2hGaWxsXCI7XG4gICAgY29uc3Qgb3ZlcnJpZGRlbkJ5Q29sb3JSYW1wID0gd2l0aGluSGF0Y2hGaWxsU3ltYm9sTGF5ZXIgJiYgdGhpcy5pc0ZpbGxDb2xvclJhbXAoKTtcbiAgICBjb25zdCBhdXRvU3Ryb2tlQWRqdXN0ID0gdGhpcy5zZWN0aW9ucy5zdHJva2UuZXh0cmFQYXJ0cy5hdXRvU3Ryb2tlQWRqdXN0O1xuICAgIGNvbnN0IG5vU3Ryb2tlQ29sb3IgPSBpc051bGxFcXVpdmFsZW50Q29sb3Ioc3Ryb2tlQ29sb3IpO1xuICAgIGxldCBjb2xvckNvbnRlbnQgPSBudWxsO1xuICAgIGxldCB0cmFuc3BhcmVuY3lDb250ZW50ID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuaXNTdHJva2VDb2xvclJhbXAoKSB8fCBzeW1ib2xMYXllci5jb2xvckxvY2tlZCkge1xuICAgICAgY29sb3JDb250ZW50ID0gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsga2V5OiBcInN0cm9rZS1jb2xvclwiIH0sIGNvbnRlbnRPbmx5ID8gdGhpcy5tZXJnZWRTdHJpbmdzLnN0cm9rZUNvbG9yIDogdGhpcy5tZXJnZWRTdHJpbmdzLmNvbG9yLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5wdXQtY29sb3JcIiB9LCBoKFwiYXJjZ2lzLWNvbG9yLWlucHV0XCIsIHsgY29sb3I6IHRoaXMudG9Db2xvclBpY2tlclZhbHVlKHN0cm9rZUNvbG9yKSxcbiAgICAgICAgLy9jb21wYWN0PXt0aGlzLm5hcnJvd31cbiAgICAgICAgY2xlYXJhYmxlOiB0cnVlLCBvbkFyY2dpc0NvbG9ySW5wdXRDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gY3JlYXRlKGV2ZW50LmN1cnJlbnRUYXJnZXQuY29sb3IpO1xuICAgICAgICAgIGlmICghaXNOdWxsRXF1aXZhbGVudENvbG9yKGNvbG9yKSAmJiAhbm9TdHJva2VDb2xvcikge1xuICAgICAgICAgICAgY29sb3IuYSA9IHN0cm9rZUNvbG9yLmE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN5bWJvbExheWVyLmNvbG9yID0gY29sb3IudG9KU09OKCk7XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0sIHBvcG92ZXJQcm9wczogdGhpcy5wb3BvdmVyUHJvcHMsIHN0b3JhZ2VJZDogY29sb3JTdG9yYWdlSWQsIHJlZjogdGhpcy5zZXRDb2xvcklucHV0UmVmIH0pKSkpO1xuICAgICAgdHJhbnNwYXJlbmN5Q29udGVudCA9IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGtleTogXCJzdHJva2UtdHJhbnNwYXJlbmN5XCIgfSwgY29udGVudE9ubHkgPyB0aGlzLm1lcmdlZFN0cmluZ3Muc3Ryb2tlVHJhbnNwYXJlbmN5IDogdGhpcy5tZXJnZWRTdHJpbmdzLnRyYW5zcGFyZW5jeSwgaChTZWxlY3ROdW1iZXIsIHsgZmxpcExhYmVsczogdGhpcy5wZXJjZW50TGFiZWxGbGlwLCBtaW46IG9wYWNpdHlNaW4sIG1heDogb3BhY2l0eU1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIHZhbHVlOiBhbHBoYVRvVHJhbnNwYXJlbmN5KHN0cm9rZUNvbG9yLmEpLCBkaXNhYmxlZDogbm9TdHJva2VDb2xvciwgb25WYWx1ZUNoYW5nZTogKHRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFscGhhID0gdHJhbnNwYXJlbmN5VG9BbHBoYSh0cmFuc3BhcmVuY3kpO1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gc3Ryb2tlQ29sb3IuY2xvbmUoKTtcbiAgICAgICAgICBjb2xvci5hID0gYWxwaGE7XG4gICAgICAgICAgc3ltYm9sTGF5ZXIuY29sb3IgPSBjb2xvci50b0pTT04oKTtcbiAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBjb250ZW50T25seSA/IHRoaXMubWVyZ2VkU3RyaW5ncy5zdHJva2VUcmFuc3BhcmVuY3kgOiB0aGlzLm1lcmdlZFN0cmluZ3MudHJhbnNwYXJlbmN5IH0pKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwga2V5OiBgJHtrZXl9X19zb2xpZC1zdHJva2Utc3ltYm9sLWxheWVyLWNvbnRlbnRgIH0sIG92ZXJyaWRkZW5CeUNvbG9yUmFtcCA/IG51bGwgOiBjb2xvckNvbnRlbnQsIGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGRpc2FibGVkOiBub1N0cm9rZUNvbG9yIH0sIG92ZXJyaWRkZW5CeUNvbG9yUmFtcCA/IG51bGwgOiB0cmFuc3BhcmVuY3lDb250ZW50LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBjb250ZW50T25seSA/IHRoaXMubWVyZ2VkU3RyaW5ncy5zdHJva2VXaWR0aCA6IHRoaXMubWVyZ2VkU3RyaW5ncy53aWR0aCwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IG5vU3Ryb2tlQ29sb3IgfHxcbiAgICAgICAgKGF1dG9TdHJva2VBZGp1c3QgJiYgYXV0b1N0cm9rZUFkanVzdCAhPT0gXCJlZGl0YWJsZVwiICYmIHRoaXMuc3Ryb2tlLmF1dG9BZGp1c3RlZCksIG1pbjogdGhpcy5jaW1TdHJva2VXaWR0aEJvdW5kcy5taW4sIG1heDogdGhpcy5jaW1TdHJva2VXaWR0aEJvdW5kcy5tYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5weCwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHN5bWJvbExheWVyLndpZHRoKSksIG9uVmFsdWVDaGFuZ2U6ICh3aWR0aCkgPT4ge1xuICAgICAgICBzeW1ib2xMYXllci53aWR0aCA9IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KHdpZHRoKSk7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBjb250ZW50T25seSA/IHRoaXMubWVyZ2VkU3RyaW5ncy5zdHJva2VXaWR0aCA6IHRoaXMubWVyZ2VkU3RyaW5ncy53aWR0aCB9KSkpLCB3aXRoaW5IYXRjaEZpbGxTeW1ib2xMYXllclxuICAgICAgPyB0aGlzLnJlbmRlckNJTUhhdGNoRmlsbFBhdHRlcm5TZWN0aW9uKHBhcmVudFN5bWJvbExheWVyKVxuICAgICAgOiBudWxsKSk7XG4gICAgaWYgKGNvbnRlbnRPbmx5KSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sTGF5ZXJQcmV2aWV3ID0gd2l0aGluSGF0Y2hGaWxsU3ltYm9sTGF5ZXJcbiAgICAgID8gdGhpcy5nZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2woT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRTeW1ib2xMYXllciksIHsgbGluZVN5bWJvbDoge1xuICAgICAgICAgIHR5cGU6IFwiQ0lNTGluZVN5bWJvbFwiLFxuICAgICAgICAgIHN5bWJvbExheWVyczogW3N5bWJvbExheWVyXVxuICAgICAgICB9IH0pLCBcInBvbHlnb25cIilcbiAgICAgIDogdGhpcy5nZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2woc3ltYm9sTGF5ZXIsIFwibGluZVwiKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJCbG9jayh7XG4gICAgICBpY29uOiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3XCIsIHsgY29udHJhc3Q6IHRydWUsIGtleTogYCR7a2V5fV9fc29saWQtc3Ryb2tlLXN5bWJvbC1sYXllci1wcmV2aWV3YCwgc3ltYm9sOiBzeW1ib2xMYXllclByZXZpZXcsIHNsb3Q6IFwiaWNvblwiIH0pKSxcbiAgICAgIGhlYWRpbmc6IHdpdGhpbkhhdGNoRmlsbFN5bWJvbExheWVyXG4gICAgICAgID8gdGhpcy5tZXJnZWRTdHJpbmdzLmhhdGNoRmlsbFxuICAgICAgICA6IHRoaXMubWVyZ2VkU3RyaW5ncy5zb2xpZFN0cm9rZSxcbiAgICAgIGtleTogYCR7a2V5fV9fc29saWQtc3Ryb2tlLXN5bWJvbC1sYXllcmAsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQ0lNSGF0Y2hGaWxsU3ltYm9sTGF5ZXJCbG9ja3Moc3ltYm9sTGF5ZXIsIGtleSkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlckNJTVN5bWJvbExheWVyc0NvbnRlbnQoc3ltYm9sTGF5ZXIubGluZVN5bWJvbCwgYCR7a2V5fV9faGF0Y2gtc3ltYm9sLWZpbGwtc3ltYm9sLWxheWVyc2AsIGZhbHNlLCBzeW1ib2xMYXllcikuZmxhdCgpO1xuICB9XG4gIHJlbmRlckNJTUhhdGNoRmlsbFBhdHRlcm5TZWN0aW9uKHN5bWJvbExheWVyKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBtZXJnZWRTdHJpbmdzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZpbGxPZmZzZXQgPSAoX2EgPSBzeW1ib2xMYXllci5vZmZzZXRYKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwOyAvLyB3ZSBhcHBseSBvZmZzZXQgdW5pZm9ybWx5LCBzbyB3ZSB1c2UgdGFrZSBYXG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1ibG9jay1zZWN0aW9uXCIsIHsga2V5OiBcImhhdGNoLWZpbGwtcGF0dGVyblwiLCB0ZXh0OiBtZXJnZWRTdHJpbmdzLnBhdHRlcm4gfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5yb3RhdGlvbiwgaChTZWxlY3ROdW1iZXIsIHsgZmxpcExhYmVsczogdGhpcy5kaXIgPT09IFwicnRsXCIsIG1heDogcm90YXRpb25NYXgsIG1pbjogcm90YXRpb25NaW4sIG9uVmFsdWVDaGFuZ2U6IChyb3RhdGlvbikgPT4ge1xuICAgICAgICBzeW1ib2xMYXllci5yb3RhdGlvbiA9IE1hdGguYWJzKHJvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICB9LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIlxcdTAwQkFcIiwgdmFsdWU6IChfYiA9IHN5bWJvbExheWVyLnJvdGF0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3Mucm90YXRpb24gfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLnNlcGFyYXRpb24sIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMuZGlyID09PSBcInJ0bFwiLCBtYXg6IGhhdGNoRmlsbFNlcGFyYXRpb25NYXgsIG1pbjogaGF0Y2hGaWxsU2VwYXJhdGlvbk1pbiwgb25WYWx1ZUNoYW5nZTogKHNlcGFyYXRpb24pID0+IHtcbiAgICAgICAgc3ltYm9sTGF5ZXIuc2VwYXJhdGlvbiA9IHNlcGFyYXRpb247XG4gICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgfSwgc3RlcDogMSwgdmFsdWU6IChfYyA9IHN5bWJvbExheWVyLnNlcGFyYXRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAsIHVuaXRzTGFiZWw6IG1lcmdlZFN0cmluZ3MucHgsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbWVyZ2VkU3RyaW5ncy5zZXBhcmF0aW9uIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5vZmZzZXQsIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMuZGlyID09PSBcInJ0bFwiLCBtYXg6IGhhdGNoRmlsbE9mZnNldE1heCwgbWluOiBoYXRjaEZpbGxPZmZzZXRNaW4sIG9uVmFsdWVDaGFuZ2U6IChvZmZzZXQpID0+IHtcbiAgICAgICAgc3ltYm9sTGF5ZXIub2Zmc2V0WCA9IG9mZnNldDtcbiAgICAgICAgc3ltYm9sTGF5ZXIub2Zmc2V0WSA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICB9LCBzdGVwOiAxLCB2YWx1ZTogZmlsbE9mZnNldCwgdW5pdHNMYWJlbDogbWVyZ2VkU3RyaW5ncy5weCwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBtZXJnZWRTdHJpbmdzLm9mZnNldCB9KSkpKTtcbiAgfVxuICByZW5kZXJDSU1QaWN0dXJlTWFya2VyU3ltYm9sTGF5ZXJCbG9jayhzeW1ib2xMYXllciwga2V5LCBjb250ZW50T25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGludENvbG9yID0gY3JlYXRlKHN5bWJvbExheWVyLnRpbnRDb2xvciwgdHJ1ZSk7XG4gICAgY29uc3QgeyBzZWN0aW9uczogeyBtYXJrZXI6IHsgcGFydHM6IHsgc2l6ZSB9IH0gfSwgbWFya2VyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGF1dG9TaXplQWRqdXN0ID0gdHlwZW9mIHNpemUgPT09IFwib2JqZWN0XCIgJiYgKHNpemUgPT09IG51bGwgfHwgc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2l6ZS5hdXRvU2l6ZUFkanVzdCk7XG4gICAgY29uc3QgdXBkYXRlVGFyZ2V0U3ltYm9sID0gdGhpcy5nZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2woc3ltYm9sTGF5ZXIsIFwicG9pbnRcIik7XG4gICAgY29uc3Qgbm9UaW50Q29sb3IgPSBpc051bGxFcXVpdmFsZW50Q29sb3IodGludENvbG9yKTtcbiAgICBjb25zdCBjb250ZW50ID0gKGgoXCJkaXZcIiwgeyBrZXk6IGAke2tleX1fX3BpY3R1cmUtbWFya2VyLXN5bWJvbC1sYXllcmAgfSwgaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwga2V5OiBgJHtrZXl9X19waWN0dXJlLW1hcmtlci1zeW1ib2wtbGF5ZXItY29udGVudGAgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxDb2xvciwgaChcImRpdlwiLCB7IGNsYXNzOiBcImlucHV0LWNvbG9yXCIgfSwgaChcImFyY2dpcy1jb2xvci1pbnB1dFwiLCB7IGNvbG9yOiB0aGlzLnRvQ29sb3JQaWNrZXJWYWx1ZSh0aW50Q29sb3IpLFxuICAgICAgLy9jb21wYWN0PXt0aGlzLm5hcnJvd31cbiAgICAgIGNsZWFyYWJsZTogdHJ1ZSwgb25BcmNnaXNDb2xvcklucHV0Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcik7XG4gICAgICAgIGlmICghaXNOdWxsRXF1aXZhbGVudENvbG9yKGNvbG9yKSAmJiAhbm9UaW50Q29sb3IpIHtcbiAgICAgICAgICBjb2xvci5hID0gdGludENvbG9yLmE7XG4gICAgICAgIH1cbiAgICAgICAgc3ltYm9sTGF5ZXIudGludENvbG9yID0gY29sb3IudG9KU09OKCk7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sIHBvcG92ZXJQcm9wczogdGhpcy5wb3BvdmVyUHJvcHMsIHN0b3JhZ2VJZDogY29sb3JTdG9yYWdlSWQsIHJlZjogdGhpcy5zZXRDb2xvcklucHV0UmVmIH0pKSksIGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGRpc2FibGVkOiBub1RpbnRDb2xvciB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3MuZmlsbFRyYW5zcGFyZW5jeSwgaChTZWxlY3ROdW1iZXIsIHsgZmxpcExhYmVsczogdGhpcy5wZXJjZW50TGFiZWxGbGlwLCBtaW46IG9wYWNpdHlNaW4sIG1heDogb3BhY2l0eU1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIHZhbHVlOiBhbHBoYVRvVHJhbnNwYXJlbmN5KHRpbnRDb2xvci5hKSwgZGlzYWJsZWQ6IG5vVGludENvbG9yLCBvblZhbHVlQ2hhbmdlOiAodHJhbnNwYXJlbmN5KSA9PiB7XG4gICAgICAgIGNvbnN0IGFscGhhID0gdHJhbnNwYXJlbmN5VG9BbHBoYSh0cmFuc3BhcmVuY3kpO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRpbnRDb2xvci5jbG9uZSgpO1xuICAgICAgICBjb2xvci5hID0gYWxwaGE7XG4gICAgICAgIHN5bWJvbExheWVyLnRpbnRDb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3kgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCB0aGlzLm1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSwgaChTZWxlY3ROdW1iZXIsIHsgZGlzYWJsZWQ6IG5vVGludENvbG9yIHx8XG4gICAgICAgIChhdXRvU2l6ZUFkanVzdCAmJiBhdXRvU2l6ZUFkanVzdCAhPT0gXCJlZGl0YWJsZVwiICYmIG1hcmtlci5hdXRvQWRqdXN0ZWQpLCBtaW46IHNpemVNaW4sIG1heDogc2l6ZU1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnB4LCB2YWx1ZTogbm9ybWFsaXplUHgoZXNyaU1vZHVsZXMuc2NyZWVuVXRpbHMucHQycHgoc3ltYm9sTGF5ZXIuc2l6ZSkpLCBvblZhbHVlQ2hhbmdlOiAoc2l6ZSkgPT4ge1xuICAgICAgICB0aGlzLnNldE1hcmtlclN5bWJvbExheWVyU2l6ZSh1cGRhdGVUYXJnZXRTeW1ib2wsIHNpemUpO1xuICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUgfSkpKSksIHRoaXMucmVuZGVyQ0lNTWFya2VyUGxhY2VtZW50U2VjdGlvbihzeW1ib2xMYXllciksIHRoaXMucmVuZGVyQ0lNUGljdHVyZU1hcmtlckFuaW1hdGlvblNlY3Rpb24oc3ltYm9sTGF5ZXIpKSk7XG4gICAgaWYgKGNvbnRlbnRPbmx5KSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sTGF5ZXJQcmV2aWV3ID0gdGhpcy5nZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2wodGhpcy5zYW5pdGl6ZVBvaW50UHJldmlld1N5bWJvbExheWVyKHN5bWJvbExheWVyKSwgXCJwb2ludFwiKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJCbG9jayh7XG4gICAgICBpY29uOiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3XCIsIHsgY29udHJhc3Q6IHRydWUsIGtleTogYCR7a2V5fV9fc29saWQtZmlsbC1zeW1ib2wtbGF5ZXItcHJldmlld2AsIHN5bWJvbDogc3ltYm9sTGF5ZXJQcmV2aWV3LCBvcHRpb25zOiBwb2ludFByZXZpZXdPcHRpb25zLCBzbG90OiBcImljb25cIiB9KSksXG4gICAgICBoZWFkaW5nOiB0aGlzLm1lcmdlZFN0cmluZ3MucGljdHVyZU1hcmtlcixcbiAgICAgIGtleTogYCR7a2V5fV9fcGljdHVyZS1tYXJrZXItc3ltYm9sLWxheWVyYCxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICBzYW5pdGl6ZVBvaW50UHJldmlld1N5bWJvbExheWVyKHN5bWJvbExheWVyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3ltYm9sTGF5ZXIpLCB7XG4gICAgICAvLyBlbnN1cmUgbWFya2VyUGxhY2VtZW50IGlzIG5vdCBzZXQgb24gQ0lNIHBvaW50IHN5bWJvbHMgc3ltYm9sIGxheWVyIGZvciBwcm9wZXIgcHJldmlld1xuICAgICAgbWFya2VyUGxhY2VtZW50OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICByZW5kZXJDSU1QaWN0dXJlU3Ryb2tlU3ltYm9sTGF5ZXJCbG9jayhzeW1ib2xMYXllciwga2V5LCBjb250ZW50T25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGludENvbG9yID0gY3JlYXRlKHN5bWJvbExheWVyLnRpbnRDb2xvciwgdHJ1ZSk7XG4gICAgY29uc3QgeyBzZWN0aW9uczogeyBtYXJrZXI6IHsgcGFydHM6IHsgc2l6ZSB9IH0gfSwgbWFya2VyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGF1dG9TaXplQWRqdXN0ID0gdHlwZW9mIHNpemUgPT09IFwib2JqZWN0XCIgJiYgKHNpemUgPT09IG51bGwgfHwgc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2l6ZS5hdXRvU2l6ZUFkanVzdCk7XG4gICAgY29uc3Qgbm9UaW50Q29sb3IgPSBpc051bGxFcXVpdmFsZW50Q29sb3IodGludENvbG9yKTtcbiAgICBjb25zdCBjb250ZW50ID0gKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zZWN0aW9uXCIsIHsgZW1iZWRkZWQ6IHRydWUsIGtleTogYCR7a2V5fV9fcGljdHVyZS1zdHJva2Utc3ltYm9sLWxheWVyLWNvbnRlbnRgIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsQ29sb3IsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbnB1dC1jb2xvclwiIH0sIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogdGhpcy50b0NvbG9yUGlja2VyVmFsdWUodGludENvbG9yKSxcbiAgICAgIC8vY29tcGFjdD17dGhpcy5uYXJyb3d9XG4gICAgICBjbGVhcmFibGU6IHRydWUsIG9uQXJjZ2lzQ29sb3JJbnB1dENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY3JlYXRlKGV2ZW50LmN1cnJlbnRUYXJnZXQuY29sb3IpO1xuICAgICAgICBpZiAoIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikgJiYgIW5vVGludENvbG9yKSB7XG4gICAgICAgICAgY29sb3IuYSA9IHRpbnRDb2xvci5hO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbExheWVyLnRpbnRDb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpLCBoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGVtYmVkZGVkOiB0cnVlLCBkaXNhYmxlZDogbm9UaW50Q29sb3IgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3ksIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWluOiBvcGFjaXR5TWluLCBtYXg6IG9wYWNpdHlNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCB2YWx1ZTogYWxwaGFUb1RyYW5zcGFyZW5jeSh0aW50Q29sb3IuYSksIGRpc2FibGVkOiBub1RpbnRDb2xvciwgb25WYWx1ZUNoYW5nZTogKHRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEodHJhbnNwYXJlbmN5KTtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aW50Q29sb3IuY2xvbmUoKTtcbiAgICAgICAgY29sb3IuYSA9IGFscGhhO1xuICAgICAgICBzeW1ib2xMYXllci50aW50Q29sb3IgPSBjb2xvci50b0pTT04oKTtcbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICB9LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5IH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUsIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBub1RpbnRDb2xvciB8fFxuICAgICAgICAoYXV0b1NpemVBZGp1c3QgJiYgYXV0b1NpemVBZGp1c3QgIT09IFwiZWRpdGFibGVcIiAmJiBtYXJrZXIuYXV0b0FkanVzdGVkKSwgbWluOiBzaXplTWluLCBtYXg6IHNpemVNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5weCwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHN5bWJvbExheWVyLndpZHRoKSksIG9uVmFsdWVDaGFuZ2U6ICh3aWR0aCkgPT4ge1xuICAgICAgICBzeW1ib2xMYXllci53aWR0aCA9IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KHdpZHRoKSk7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgfSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3Muc3ltYm9sU2l6ZSB9KSkpKSk7XG4gICAgaWYgKGNvbnRlbnRPbmx5KSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sTGF5ZXJQcmV2aWV3ID0gdGhpcy5nZXRTeW1ib2xMYXllclByZXZpZXdTeW1ib2woc3ltYm9sTGF5ZXIsIFwibGluZVwiKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJCbG9jayh7XG4gICAgICBpY29uOiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN5bWJvbC1wcmV2aWV3XCIsIHsgY29udHJhc3Q6IHRydWUsIGtleTogYCR7a2V5fV9fcGljdHVyZS1zdHJva2Utc3ltYm9sLWxheWVyLXByZXZpZXdgLCBzeW1ib2w6IHN5bWJvbExheWVyUHJldmlldywgc2xvdDogXCJpY29uXCIgfSkpLFxuICAgICAgaGVhZGluZzogdGhpcy5tZXJnZWRTdHJpbmdzLnBpY3R1cmVTdHJva2UsXG4gICAgICBrZXk6IGAke2tleX1fX3BpY3R1cmUtc3Ryb2tlLXN5bWJvbC1sYXllcmAsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQ0lNUGljdHVyZUZpbGxTeW1ib2xMYXllckJsb2NrKHN5bWJvbExheWVyLCBrZXksIGNvbnRlbnRPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB0aW50Q29sb3IgPSBjcmVhdGUoc3ltYm9sTGF5ZXIudGludENvbG9yLCB0cnVlKTtcbiAgICBjb25zdCB7IHNlY3Rpb25zOiB7IG1hcmtlcjogeyBwYXJ0czogeyBzaXplIH0gfSB9LCBtYXJrZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgYXV0b1NpemVBZGp1c3QgPSB0eXBlb2Ygc2l6ZSA9PT0gXCJvYmplY3RcIiAmJiAoc2l6ZSA9PT0gbnVsbCB8fCBzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaXplLmF1dG9TaXplQWRqdXN0KTtcbiAgICBjb25zdCBub1RpbnRDb2xvciA9IGlzTnVsbEVxdWl2YWxlbnRDb2xvcih0aW50Q29sb3IpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwga2V5OiBgJHtrZXl9X19waWN0dXJlLWZpbGwtc3ltYm9sLWxheWVyLWNvbnRlbnRgIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsQ29sb3IsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbnB1dC1jb2xvclwiIH0sIGgoXCJhcmNnaXMtY29sb3ItaW5wdXRcIiwgeyBjb2xvcjogdGhpcy50b0NvbG9yUGlja2VyVmFsdWUodGludENvbG9yKSxcbiAgICAgIC8vY29tcGFjdD17dGhpcy5uYXJyb3d9XG4gICAgICBjbGVhcmFibGU6IHRydWUsIG9uQXJjZ2lzQ29sb3JJbnB1dENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY3JlYXRlKGV2ZW50LmN1cnJlbnRUYXJnZXQuY29sb3IpO1xuICAgICAgICBpZiAoIWlzTnVsbEVxdWl2YWxlbnRDb2xvcihjb2xvcikgJiYgIW5vVGludENvbG9yKSB7XG4gICAgICAgICAgY29sb3IuYSA9IHRpbnRDb2xvci5hO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbExheWVyLnRpbnRDb2xvciA9IGNvbG9yLnRvSlNPTigpO1xuICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCBzdG9yYWdlSWQ6IGNvbG9yU3RvcmFnZUlkLCByZWY6IHRoaXMuc2V0Q29sb3JJbnB1dFJlZiB9KSkpLCBoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc2VjdGlvblwiLCB7IGVtYmVkZGVkOiB0cnVlLCBkaXNhYmxlZDogbm9UaW50Q29sb3IgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3ksIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWluOiBvcGFjaXR5TWluLCBtYXg6IG9wYWNpdHlNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IFwiJVwiLCB2YWx1ZTogYWxwaGFUb1RyYW5zcGFyZW5jeSh0aW50Q29sb3IuYSksIGRpc2FibGVkOiBub1RpbnRDb2xvciwgb25WYWx1ZUNoYW5nZTogKHRyYW5zcGFyZW5jeSkgPT4ge1xuICAgICAgICBjb25zdCBhbHBoYSA9IHRyYW5zcGFyZW5jeVRvQWxwaGEodHJhbnNwYXJlbmN5KTtcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aW50Q29sb3IuY2xvbmUoKTtcbiAgICAgICAgY29sb3IuYSA9IGFscGhhO1xuICAgICAgICBzeW1ib2xMYXllci50aW50Q29sb3IgPSBjb2xvci50b0pTT04oKTtcbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICB9LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5maWxsVHJhbnNwYXJlbmN5IH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUsIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBub1RpbnRDb2xvciB8fFxuICAgICAgICAoYXV0b1NpemVBZGp1c3QgJiYgYXV0b1NpemVBZGp1c3QgIT09IFwiZWRpdGFibGVcIiAmJiBtYXJrZXIuYXV0b0FkanVzdGVkKSwgbWluOiBzaXplTWluLCBtYXg6IHNpemVNYXgsIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IHRoaXMubWVyZ2VkU3RyaW5ncy5weCwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KHN5bWJvbExheWVyLmhlaWdodCkpLCBvblZhbHVlQ2hhbmdlOiAoaGVpZ2h0KSA9PiB7XG4gICAgICAgIHN5bWJvbExheWVyLmhlaWdodCA9IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KGhlaWdodCkpO1xuICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgIH0sIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnN5bWJvbFNpemUgfSkpKSkpO1xuICAgIGlmIChjb250ZW50T25seSkge1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbExheWVyUHJldmlldyA9IHRoaXMuZ2V0U3ltYm9sTGF5ZXJQcmV2aWV3U3ltYm9sKHN5bWJvbExheWVyLCBcInBvbHlnb25cIik7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyQmxvY2soe1xuICAgICAgaWNvbjogKGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zeW1ib2wtcHJldmlld1wiLCB7IGNvbnRyYXN0OiB0cnVlLCBrZXk6IGAke2tleX1fX3BpY3R1cmUtZmlsbC1zeW1ib2wtbGF5ZXItcHJldmlld2AsIHN5bWJvbDogc3ltYm9sTGF5ZXJQcmV2aWV3LCBzbG90OiBcImljb25cIiB9KSksXG4gICAgICBoZWFkaW5nOiB0aGlzLm1lcmdlZFN0cmluZ3MucGljdHVyZUZpbGwsXG4gICAgICBrZXk6IGAke2tleX1fX3BpY3R1cmUtZmlsbC1zeW1ib2wtbGF5ZXJgLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIHJlbmRlckNJTVBpY3R1cmVNYXJrZXJBbmltYXRpb25TZWN0aW9uKHN5bWJvbExheWVyKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBkaXIsIG1lcmdlZFN0cmluZ3MgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMgfSA9IHN5bWJvbExheWVyO1xuICAgIGlmIChhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYmxvY2stc2VjdGlvblwiLCB7IGtleTogXCJwaWN0dXJlLW1hcmtlci1hbmltYXRpb25cIiwgdGV4dDogbWVyZ2VkU3RyaW5ncy5hbmltYXRpb24gfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBkaXI6IGRpciwgbGF5b3V0OiBcImlubGluZVwiIH0sIGgoXCJjYWxjaXRlLWNoZWNrYm94XCIsIHsgY2hlY2tlZDogYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnBsYXlBbmltYXRpb24sIG9uQ2FsY2l0ZUNoZWNrYm94Q2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnBsYXlBbmltYXRpb24gPSBjaGVja2VkO1xuICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICB9IH0pLCBtZXJnZWRTdHJpbmdzLnBsYXlBbmltYXRpb24pLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGRpcjogZGlyLCBsYXlvdXQ6IFwiaW5saW5lXCIgfSwgaChcImNhbGNpdGUtY2hlY2tib3hcIiwgeyBjaGVja2VkOiBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmV2ZXJzZUFuaW1hdGlvbiwgb25DYWxjaXRlQ2hlY2tib3hDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmV2ZXJzZUFuaW1hdGlvbiA9IGNoZWNrZWQ7XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIH0gfSksIG1lcmdlZFN0cmluZ3MucmV2ZXJzZUFuaW1hdGlvbiksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3Muc3RhcnRUaW1lT2Zmc2V0LCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbFwiLCB7IG9uQ2FsY2l0ZVNlZ21lbnRlZENvbnRyb2xDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICAgICAgICBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmFuZG9taXplU3RhcnRUaW1lID0gdmFsdWUgPT09IFwicmFuZG9tXCI7XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIH0gfSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2wtaXRlbVwiLCB7IHZhbHVlOiBcInJhbmRvbVwiLCBjaGVja2VkOiBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmFuZG9taXplU3RhcnRUaW1lIH0sIG1lcmdlZFN0cmluZ3MucmFuZG9taXplZCksIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sLWl0ZW1cIiwgeyB2YWx1ZTogXCJtYW51YWxcIiwgY2hlY2tlZDogIWFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5yYW5kb21pemVTdGFydFRpbWUgfSwgbWVyZ2VkU3RyaW5ncy5tYW51YWxPZmZzZXQpKSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3MubWFudWFsT2Zmc2V0LCBoKFNlbGVjdE51bWJlciwgeyBkaXNhYmxlZDogYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJhbmRvbWl6ZVN0YXJ0VGltZSwgbWF4OiBhbmltYXRpb25EdXJhdGlvbk1heCwgbWluOiBhbmltYXRpb25EdXJhdGlvbk1pbiwgb25WYWx1ZUNoYW5nZTogKG9mZnNldCkgPT4ge1xuICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5zdGFydFRpbWVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIH0sIHN0ZXA6IDEsIHZhbHVlOiAoX2EgPSBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMuc3RhcnRUaW1lT2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3MubWFudWFsT2Zmc2V0IH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5kdXJhdGlvbiwgaChTZWxlY3ROdW1iZXIsIHsgbWF4OiBhbmltYXRpb25EdXJhdGlvbk1heCwgbWluOiBhbmltYXRpb25EdXJhdGlvbk1pbiwgb25WYWx1ZUNoYW5nZTogKGR1cmF0aW9uKSA9PiB7XG4gICAgICAgICAgYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIH0sIHN0ZXA6IDEsIHZhbHVlOiAoX2IgPSBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMuZHVyYXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAsIHdpdGhTdGVwcGVyczogIXRoaXMubmFycm93LCBsYWJlbDogbWVyZ2VkU3RyaW5ncy5kdXJhdGlvbiB9KSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3MucmVwZWF0VHlwZSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2xcIiwgeyBvbkNhbGNpdGVTZWdtZW50ZWRDb250cm9sQ2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gZXZlbnQuY3VycmVudFRhcmdldFxuICAgICAgICAgICAgLnZhbHVlO1xuICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5yZXBlYXRUeXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgfSB9LCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbC1pdGVtXCIsIHsgdmFsdWU6IFwiTm9uZVwiLCBjaGVja2VkOiBhbmltYXRlZFN5bWJvbFByb3BlcnRpZXMucmVwZWF0VHlwZSA9PT0gXCJOb25lXCIgfSwgbWVyZ2VkU3RyaW5ncy5ub25lKSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2wtaXRlbVwiLCB7IHZhbHVlOiBcIkxvb3BcIiwgY2hlY2tlZDogYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJlcGVhdFR5cGUgPT09IFwiTG9vcFwiIH0sIG1lcmdlZFN0cmluZ3MubG9vcCksIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sLWl0ZW1cIiwgeyB2YWx1ZTogXCJPc2NpbGxhdGVcIiwgY2hlY2tlZDogYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJlcGVhdFR5cGUgPT09IFwiT3NjaWxsYXRlXCIgfSwgbWVyZ2VkU3RyaW5ncy5vc2NpbGxhdGUpKSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3MucmVwZWF0RGVsYXksIGgoU2VsZWN0TnVtYmVyLCB7IG1heDogYW5pbWF0aW9uRHVyYXRpb25NYXgsIG1pbjogYW5pbWF0aW9uRHVyYXRpb25NaW4sIG9uVmFsdWVDaGFuZ2U6IChkZWxheSkgPT4ge1xuICAgICAgICAgIGFuaW1hdGVkU3ltYm9sUHJvcGVydGllcy5yZXBlYXREZWxheSA9IGRlbGF5O1xuICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICB9LCBzdGVwOiAxLCB2YWx1ZTogKF9jID0gYW5pbWF0ZWRTeW1ib2xQcm9wZXJ0aWVzLnJlcGVhdERlbGF5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3MucmVwZWF0RGVsYXkgfSkpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJlbmRlckNJTU1hcmtlclBsYWNlbWVudFNlY3Rpb24oc3ltYm9sTGF5ZXIpIHtcbiAgICBjb25zdCB7IGRpciwgbWVyZ2VkU3RyaW5ncyB9ID0gdGhpcztcbiAgICBjb25zdCB7IG1hcmtlclBsYWNlbWVudCB9ID0gc3ltYm9sTGF5ZXI7XG4gICAgaWYgKChtYXJrZXJQbGFjZW1lbnQgPT09IG51bGwgfHwgbWFya2VyUGxhY2VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXJQbGFjZW1lbnQudHlwZSkgPT09IFwiQ0lNTWFya2VyUGxhY2VtZW50SW5zaWRlUG9seWdvblwiICYmXG4gICAgICAoKG1hcmtlclBsYWNlbWVudCA9PT0gbnVsbCB8fCBtYXJrZXJQbGFjZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlclBsYWNlbWVudC5ncmlkVHlwZSkgPT09IFwiUmFuZG9tXCIgfHwgKG1hcmtlclBsYWNlbWVudCA9PT0gbnVsbCB8fCBtYXJrZXJQbGFjZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlclBsYWNlbWVudC5ncmlkVHlwZSkgPT09IFwiRml4ZWRcIikpIHtcbiAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYmxvY2stc2VjdGlvblwiLCB7IGtleTogXCJtYXJrZXItcGxhY2VtZW50XCIsIHRleHQ6IG1lcmdlZFN0cmluZ3MubWFya2VyUGxhY2VtZW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3MuZ3JpZFR5cGUsIGgoXCJjYWxjaXRlLXNlZ21lbnRlZC1jb250cm9sXCIsIHsgb25DYWxjaXRlU2VnbWVudGVkQ29udHJvbENoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5jdXJyZW50VGFyZ2V0XG4gICAgICAgICAgICAudmFsdWU7XG4gICAgICAgICAgbWFya2VyUGxhY2VtZW50LmdyaWRUeXBlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIH0gfSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2wtaXRlbVwiLCB7IHZhbHVlOiBcIkZpeGVkXCIsIGNoZWNrZWQ6IG1hcmtlclBsYWNlbWVudC5ncmlkVHlwZSA9PT0gXCJGaXhlZFwiIH0sIG1lcmdlZFN0cmluZ3MuZml4ZWQpLCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbC1pdGVtXCIsIHsgdmFsdWU6IFwiUmFuZG9tXCIsIGNoZWNrZWQ6IG1hcmtlclBsYWNlbWVudC5ncmlkVHlwZSA9PT0gXCJSYW5kb21cIiB9LCBtZXJnZWRTdHJpbmdzLnJhbmRvbSkpKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbWVyZ2VkU3RyaW5ncy5yYW5kb21uZXNzLCBoKFNlbGVjdE51bWJlciwgeyBkaXNhYmxlZDogbWFya2VyUGxhY2VtZW50LmdyaWRUeXBlID09PSBcIkZpeGVkXCIsIGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWF4OiBtYXJrZXJQbGFjZW1lbnRSYW5kb21uZXNzTWF4LCBtaW46IG1hcmtlclBsYWNlbWVudFJhbmRvbW5lc3NNaW4sIG9uVmFsdWVDaGFuZ2U6IChyYW5kb21uZXNzKSA9PiB7XG4gICAgICAgICAgbWFya2VyUGxhY2VtZW50LnJhbmRvbW5lc3MgPSByYW5kb21uZXNzO1xuICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW1ib2wsIHRydWUpO1xuICAgICAgICB9LCBzdGVwOiAxLCB2YWx1ZTogbWFya2VyUGxhY2VtZW50LnJhbmRvbW5lc3MsIHVuaXRzTGFiZWw6IFwiJVwiLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3MucmFuZG9tbmVzcyB9KSksIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1lcmdlZFN0cmluZ3Muc3RlcFgsIGgoU2VsZWN0TnVtYmVyLCB7IG1heDogbWFya2VyUGxhY2VtZW50U3RlcE1heCwgbWluOiBtYXJrZXJQbGFjZW1lbnRTdGVwTWluLCBvblZhbHVlQ2hhbmdlOiAoc3RlcCkgPT4ge1xuICAgICAgICAgIG1hcmtlclBsYWNlbWVudC5zdGVwWCA9IG5vcm1hbGl6ZVB0KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB4MnB0KHN0ZXApKTtcbiAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgfSwgc3RlcDogMSwgdmFsdWU6IG5vcm1hbGl6ZVB4KGVzcmlNb2R1bGVzLnNjcmVlblV0aWxzLnB0MnB4KG1hcmtlclBsYWNlbWVudC5zdGVwWCkpLCB1bml0c0xhYmVsOiBtZXJnZWRTdHJpbmdzLnB4LCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgbGFiZWw6IG1lcmdlZFN0cmluZ3Muc3RlcFggfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBtZXJnZWRTdHJpbmdzLnN0ZXBZLCBoKFNlbGVjdE51bWJlciwgeyBtYXg6IG1hcmtlclBsYWNlbWVudFN0ZXBNYXgsIG1pbjogbWFya2VyUGxhY2VtZW50U3RlcE1pbiwgb25WYWx1ZUNoYW5nZTogKHN0ZXApID0+IHtcbiAgICAgICAgICBtYXJrZXJQbGFjZW1lbnQuc3RlcFkgPSBub3JtYWxpemVQdChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5weDJwdChzdGVwKSk7XG4gICAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIH0sIHN0ZXA6IDEsIHVuaXRzTGFiZWw6IG1lcmdlZFN0cmluZ3MucHgsIHZhbHVlOiBub3JtYWxpemVQeChlc3JpTW9kdWxlcy5zY3JlZW5VdGlscy5wdDJweChtYXJrZXJQbGFjZW1lbnQuc3RlcFkpKSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiBtZXJnZWRTdHJpbmdzLnN0ZXBZIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBkaXI6IGRpciwgbGF5b3V0OiBcImlubGluZVwiIH0sIGgoXCJjYWxjaXRlLWNoZWNrYm94XCIsIHsgY2hlY2tlZDogbWFya2VyUGxhY2VtZW50LnNoaWZ0T2RkUm93cyAmJiBtYXJrZXJQbGFjZW1lbnQuZ3JpZFR5cGUgPT09IFwiRml4ZWRcIiwgZGlzYWJsZWQ6IG1hcmtlclBsYWNlbWVudC5ncmlkVHlwZSA9PT0gXCJSYW5kb21cIiwgb25DYWxjaXRlQ2hlY2tib3hDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICBtYXJrZXJQbGFjZW1lbnQuc2hpZnRPZGRSb3dzID0gY2hlY2tlZDtcbiAgICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3ltYm9sLCB0cnVlKTtcbiAgICAgICAgfSB9KSwgbWVyZ2VkU3RyaW5ncy5zaGlmdE9kZFJvd3MpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJlbmRlckNvbG9yRmlsbFRyYW5zcGFyZW5jeUNvbnRlbnQobGFiZWwsIGRpc2FibGVkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcztcbiAgICBjb25zdCBtYXggPSAxMDA7XG4gICAgY29uc3QgbWluID0gMDtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIGxhYmVsLCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIHZhbHVlOiBhbHBoYVRvVHJhbnNwYXJlbmN5KChfYSA9IGZpbGwuY29sb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hKSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vbkNvbG9yRmlsbFRyYW5zcGFyZW5jeUNoYW5nZSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGRpc2FibGVkOiBkaXNhYmxlZCwgbGFiZWw6IGxhYmVsIH0pKSk7XG4gIH1cbiAgcmVuZGVyQ29sb3JSYW1wRmlsbEJsb2NrKGVtYmVkZGVkID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5maWxsO1xuICAgIGNvbnN0IHsgcGFydHMgfSA9IHNlY3Rpb247XG4gICAgY29uc3Qgc2hvdWxkSGlkZSA9IHRoaXMuaGFzQWN0aXZlUGljdHVyZU1hcmtlclN5bWJvbCgpIHx8IHRoaXMuaGFzQWN0aXZlTGluZU9ubHlTaW1wbGVNYXJrZXJTeW1ib2woKTtcbiAgICBpZiAoc2hvdWxkSGlkZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICBpZiAocGFydHMuY29sb3JSYW1wcykge1xuICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJGaWxsQ29sb3JSYW1wc0NvbnRlbnQoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJ0cy50cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyQ29sb3JSYW1wRmlsbFRyYW5zcGFyZW5jeUNvbnRlbnQoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlclNlY3Rpb24oe1xuICAgICAga2V5OiBcImNvbG9yLXJhbXAtZmlsbFwiLFxuICAgICAgZGlzYWJsZWQ6IHNlY3Rpb24ub3B0aW9uYWwgPT09IFwibm9uLWVkaXRhYmxlXCIsXG4gICAgICBlbWJlZGRlZCxcbiAgICAgIHNlY3Rpb25Db250ZW50OiBjb250ZW50XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyRmlsbENvbG9yUmFtcHNDb250ZW50KCkge1xuICAgIGNvbnN0IHsgc3R5bGUgfSA9IHRoaXMuY29uZmlnLnNlY3Rpb25zLmZpbGw7XG4gICAgY29uc3QgeyBhY3RpdmVDYXRlZ29yeSwgY29sb3JSYW1wcyB9ID0gdGhpcy5zZWN0aW9ucy5maWxsO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclJhbXBzQ29udGVudCh7XG4gICAgICBzdHlsZSxcbiAgICAgIGFjdGl2ZUNhdGVnb3J5LFxuICAgICAgY29sb3JSYW1wU3RvcHM6IHRoaXMuZmlsbC5jb2xvcixcbiAgICAgIGNvbG9yUmFtcHMsXG4gICAgICBoZWFkaW5nOiB0aGlzLm1lcmdlZFN0cmluZ3MuZmlsbENvbG9yLFxuICAgICAgb25DYXRlZ29yeUNoYW5nZTogdGhpcy5vbkZpbGxDb2xvclJhbXBDYXRlZ29yeUNoYW5nZSxcbiAgICAgIGlzU2VsZWN0ZWQ6IChjb2xvclJhbXApID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbG9yUmFtcCA9IHRoaXMuZmlsbC5jb2xvcjtcbiAgICAgICAgcmV0dXJuIGVxdWFsKGN1cnJlbnRDb2xvclJhbXAsIGNvbG9yUmFtcC5zdG9wcywgc3R5bGUgPT09IFwiMmRcIik7XG4gICAgICB9LFxuICAgICAgb25TZWxlY3Q6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRldGFpbDogY29sb3JSYW1wIH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvclJhbXAuc3RvcHMuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgeyBmaWxsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBtZXJnZWRGaWxsID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWxsKSwgeyBjb2xvciB9KTtcbiAgICAgICAgdGhpcy5maWxsID0gbWVyZ2VkRmlsbDtcbiAgICAgICAgdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVTdG9wcyA9IGNvbG9yO1xuICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlckZpbGxDaGFuZ2UuZW1pdChtZXJnZWRGaWxsKTtcbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCwgeyBjaW1DaGFuZ2VDb250ZXh0OiBcInJvb3RcIiB9KSwgdHJ1ZSk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcbiAgICAgIG9uRmxpcDogdGhpcy5mbGlwRmlsbENvbG9yUmFtcHNcbiAgICB9KTtcbiAgfVxuICByZW5kZXJSYW1wc0NvbnRlbnQob3B0aW9ucykge1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgb3B0aW9ucy5oZWFkaW5nLCBoKFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItY29sb3ItcmFtcC1pbnB1dFwiLCB7IG9wdGlvbnM6IG9wdGlvbnMsIHN0cmluZ3M6IHRoaXMubWVyZ2VkU3RyaW5ncywgcG9wb3ZlclByb3BzOiB0aGlzLnBvcG92ZXJQcm9wcywgc3R5bGU6IHtcbiAgICAgICAgXCItLXNjcm9sbGVyLW1heC1oZWlnaHRcIjogXCJ2YXIoLS1yYW1wLXNjcm9sbGVyLW1heC1oZWlnaHQpXCJcbiAgICAgIH0sIHJlZjogdGhpcy5zZXRSYW1wSW5wdXRSZWYgfSkpKTtcbiAgfVxuICByZW5kZXJDb2xvclJhbXBGaWxsVHJhbnNwYXJlbmN5Q29udGVudCgpIHtcbiAgICBjb25zdCB7IGZpbGwgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4ID0gMTAwO1xuICAgIGNvbnN0IG1pbiA9IDA7XG4gICAgY29uc3QgY29sb3IgPSBmaWxsLmNvbG9yWzBdO1xuICAgIC8vIGZvciBDSU0gc3ltYm9scyB0aGlzIG1pZ2h0IGJlIGEgcmdiYSBhcnJheVxuICAgIGNvbnN0IGFscGhhID0gY29sb3IubGVuZ3RoID09PSA0ID8gY29sb3JbM10gLyAyNTUgOiBjb2xvci5hO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5tZXJnZWRTdHJpbmdzLmZpbGxUcmFuc3BhcmVuY3ksIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIiVcIiwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3koYWxwaGEpLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uQ29sb3JSYW1wRmlsbFRyYW5zcGFyZW5jeUNoYW5nZSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiB0aGlzLm1lcmdlZFN0cmluZ3MuZmlsbFRyYW5zcGFyZW5jeSB9KSkpO1xuICB9XG4gIHJlbmRlclN0cm9rZUJsb2NrKCkge1xuICAgIGNvbnN0IHsgc3Ryb2tlIH0gPSB0aGlzLmNvbmZpZy5zZWN0aW9ucztcbiAgICBpZiAoc3Ryb2tlLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ29sb3JTdHJva2VCbG9jaygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJDb2xvclJhbXBTdHJva2VCbG9jaygpO1xuICB9XG4gIHJlbmRlckNvbG9yU3Ryb2tlQmxvY2soKSB7XG4gICAgY29uc3Qgc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zO1xuICAgIGNvbnN0IHNlY3Rpb24gPSBzZWN0aW9ucy5zdHJva2U7XG4gICAgY29uc3QgeyBwYXJ0cyB9ID0gc2VjdGlvbjtcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgaWYgKHBhcnRzLnN1Z2dlc3RlZENvbG9ycyB8fCBwYXJ0cy5jdXN0b21Db2xvcikge1xuICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTdHJva2VDb2xvcnNDb250ZW50KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFydHMudHJhbnNwYXJlbmN5IHx8IHBhcnRzLmV4dHJhKSB7XG4gICAgICBjb25zdCBpbm5lckNvbnRlbnQgPSBbXTtcbiAgICAgIGlmIChwYXJ0cy50cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgaW5uZXJDb250ZW50LnB1c2godGhpcy5zaG93aW5nUmFtcE9wdGlvbnNJblN0cm9rZSgpXG4gICAgICAgICAgPyB0aGlzLnJlbmRlckNvbG9yUmFtcFN0cm9rZVRyYW5zcGFyZW5jeUNvbnRlbnQoIXNlY3Rpb24uZW5hYmxlZClcbiAgICAgICAgICA6IHRoaXMucmVuZGVyQ29sb3JTdHJva2VUcmFuc3BhcmVuY3lDb250ZW50KCFzZWN0aW9uLmVuYWJsZWQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0cy5leHRyYSkge1xuICAgICAgICBpbm5lckNvbnRlbnQucHVzaCh0aGlzLnJlbmRlclN0cm9rZUV4dHJhQ29udGVudCghc2VjdGlvbi5lbmFibGVkKSk7XG4gICAgICB9XG4gICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICBjb250ZW50OiAoaChcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXNlY3Rpb25cIiwgeyBlbWJlZGRlZDogdHJ1ZSwgZGlzYWJsZWQ6ICFzZWN0aW9uLmVuYWJsZWQgfSwgaW5uZXJDb250ZW50KSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJTZWN0aW9uKHtcbiAgICAgIGtleTogXCJjb2xvci1zdHJva2VcIixcbiAgICAgIGRpc2FibGVkOiBzZWN0aW9uLm9wdGlvbmFsID09PSBcIm5vbi1lZGl0YWJsZVwiIHx8IHRoaXMuaGFzQWN0aXZlUGljdHVyZU1hcmtlclN5bWJvbCgpLFxuICAgICAgc2VjdGlvbkNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICByZW5kZXJTdHJva2VDb2xvclJhbXBzQ29udGVudCgpIHtcbiAgICBjb25zdCB7IHN0eWxlIH0gPSB0aGlzLmNvbmZpZy5zZWN0aW9ucy5zdHJva2U7XG4gICAgY29uc3QgeyBhY3RpdmVDYXRlZ29yeSwgY29sb3JSYW1wcyB9ID0gdGhpcy5zZWN0aW9ucy5zdHJva2U7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUmFtcHNDb250ZW50KHtcbiAgICAgIHN0eWxlLFxuICAgICAgYWN0aXZlQ2F0ZWdvcnksXG4gICAgICBjb2xvclJhbXBTdG9wczogdGhpcy5zdHJva2UuY29sb3IsXG4gICAgICBjb2xvclJhbXBzLFxuICAgICAgaGVhZGluZzogdGhpcy5nZXRTdHJva2VTdHJpbmcoXCJjb2xvclwiKSxcbiAgICAgIG9uQ2F0ZWdvcnlDaGFuZ2U6IHRoaXMub25TdHJva2VDb2xvclJhbXBDYXRlZ29yeUNoYW5nZSxcbiAgICAgIGlzU2VsZWN0ZWQ6IChjb2xvclJhbXApID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbG9yUmFtcCA9IHRoaXMuc3Ryb2tlLmNvbG9yO1xuICAgICAgICByZXR1cm4gZXF1YWwoY3VycmVudENvbG9yUmFtcCwgY29sb3JSYW1wLnN0b3BzKTtcbiAgICAgIH0sXG4gICAgICBvblNlbGVjdDogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGV0YWlsOiBjb2xvclJhbXAgfSA9IGV2ZW50O1xuICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yUmFtcC5zdG9wcy5zbGljZSgpO1xuICAgICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yIH0pO1xuICAgICAgICB0aGlzLnN0cm9rZSA9IG1lcmdlZFN0cm9rZTtcbiAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xTdHlsZXJTdHJva2VDaGFuZ2UuZW1pdChub3JtYWxpemVTaXplUHJvcChtZXJnZWRTdHJva2UpKTtcbiAgICAgICAgdGhpcy5zZXRJbnRlcm5hbFN5bWJvbCh0aGlzLnN5bmNTeW1ib2xQcm9wcyh0aGlzLnN5bWJvbCwgeyBjaW1DaGFuZ2VDb250ZXh0OiBcInJvb3RcIiB9KSwgdHJ1ZSk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcbiAgICAgIG9uRmxpcDogdGhpcy5mbGlwU3Ryb2tlQ29sb3JSYW1wc1xuICAgIH0pO1xuICB9XG4gIHNob3dpbmdSYW1wT3B0aW9uc0luU3Ryb2tlKCkge1xuICAgIGNvbnN0IHN0cm9rZVNlY3Rpb25Db25maWcgPSB0aGlzLmNvbmZpZy5zZWN0aW9ucy5zdHJva2U7XG4gICAgY29uc3Qgc2hvdWxkU2hvd0ZpbGxDb2xvcnNGb3JPdXRsaW5lID0gaXNMaW5lT25seVN5bWJvbCh0aGlzLmFjdGl2ZVN5bWJvbCk7XG4gICAgY29uc3QgZmlsbFR5cGUgPSB0aGlzLnNlY3Rpb25zLmZpbGwudHlwZTtcbiAgICByZXR1cm4gKHNob3VsZFNob3dGaWxsQ29sb3JzRm9yT3V0bGluZSAmJlxuICAgICAgZmlsbFR5cGUgPT09IFwiY29sb3ItcmFtcFwiICYmXG4gICAgICBzdHJva2VTZWN0aW9uQ29uZmlnLnR5cGUgPT09IFwiY29sb3JcIik7XG4gIH1cbiAgcmVuZGVyU3Ryb2tlQ29sb3JzQ29udGVudCgpIHtcbiAgICBjb25zdCBzdHJva2VTZWN0aW9uID0gdGhpcy5zZWN0aW9ucy5zdHJva2U7XG4gICAgaWYgKHRoaXMuc2hvd2luZ1JhbXBPcHRpb25zSW5TdHJva2UoKSkge1xuICAgICAgY29uc3QgYWN0aXZlQ2F0ZWdvcnkgPSB0aGlzLnRlbXBTdHJva2VDb2xvclJhbXBTdGF0ZUFjdGl2ZUNhdGVnb3J5O1xuICAgICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpcy5jb25maWcuc2VjdGlvbnMuZmlsbDtcbiAgICAgIGNvbnN0IHsgY29sb3JSYW1wcyB9ID0gdGhpcy5zZWN0aW9ucy5maWxsO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUmFtcHNDb250ZW50KHtcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIGFjdGl2ZUNhdGVnb3J5LFxuICAgICAgICBjb2xvclJhbXBTdG9wczogdGhpcy50ZW1wU3Ryb2tlQ29sb3JSYW1wU3RhdGVTdG9wcyxcbiAgICAgICAgY29sb3JSYW1wcyxcbiAgICAgICAgaGVhZGluZzogdGhpcy5nZXRTdHJva2VTdHJpbmcoXCJjb2xvclwiKSxcbiAgICAgICAgb25DYXRlZ29yeUNoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgZHJvcGRvd24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZUNhdGVnb3J5ID0gZHJvcGRvd24uc2VsZWN0ZWRJdGVtc1swXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpO1xuICAgICAgICAgIHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlQWN0aXZlQ2F0ZWdvcnkgPSBhY3RpdmVDYXRlZ29yeTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNTZWxlY3RlZDogKGNvbG9yUmFtcCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2xvclJhbXBTdG9wcyA9IHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHM7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsKGN1cnJlbnRDb2xvclJhbXBTdG9wcywgY29sb3JSYW1wLnN0b3BzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TZWxlY3Q6IChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZGV0YWlsOiBjb2xvclJhbXAgfSA9IGV2ZW50O1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JSYW1wLnN0b3BzLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgeyBzdHJva2UgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yIH0pO1xuICAgICAgICAgIHRoaXMuc3Ryb2tlID0gbWVyZ2VkU3Ryb2tlO1xuICAgICAgICAgIHRoaXMudGVtcFN0cm9rZUNvbG9yUmFtcFN0YXRlU3RvcHMgPSBjb2xvcjtcbiAgICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZFN0cm9rZSkpO1xuICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxTeW1ib2wodGhpcy5zeW5jU3ltYm9sUHJvcHModGhpcy5zeW1ib2wpLCB0cnVlKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25GbGlwOiB0aGlzLmZsaXBGaWxsQ29sb3JSYW1wc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gc3Ryb2tlU2VjdGlvbi5lbmFibGVkXG4gICAgICA/IHRoaXMudG9Db2xvclBpY2tlclZhbHVlKHRoaXMuc3Ryb2tlLmNvbG9yKVxuICAgICAgOiBudWxsO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5nZXRTdHJva2VTdHJpbmcoXCJjb2xvclwiKSwgaChcImFyY2dpcy1jb2xvci1pbnB1dFwiLCB7IGNvbG9yOiBjb2xvcixcbiAgICAgIC8vY29tcGFjdD17dGhpcy5uYXJyb3d9XG4gICAgICBjbGVhcmFibGU6IHN0cm9rZVNlY3Rpb24ub3B0aW9uYWwgIT09IGZhbHNlLCBvbkFyY2dpc0NvbG9ySW5wdXRDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RlZENvbG9yID0gZXZlbnQuY3VycmVudFRhcmdldC5jb2xvcjtcbiAgICAgICAgaWYgKCFzZWxlY3RlZENvbG9yKSB7XG4gICAgICAgICAgdGhpcy5vblN0cm9rZUVuYWJsZWRDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgIC8vIG5vIHVwZGF0ZXMgdG8gY29sb3IgbmVlZGVkXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3Ryb2tlU2VjdGlvbi5lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5vblN0cm9rZUVuYWJsZWRDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3IgPSBjcmVhdGUoc2VsZWN0ZWRDb2xvcik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xvciA9IHRoaXMuc3Ryb2tlLmNvbG9yO1xuICAgICAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbWVyZ2VkU3Ryb2tlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBjcmVhdGUoYWRqdXN0VHJhbnNwYXJlbmN5SWZOZWVkZWQoY3VycmVudENvbG9yLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudENvbG9yKSwgY29sb3IpLCB7IGE6IGN1cnJlbnRDb2xvci5hIH0pKSkgfSk7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gbWVyZ2VkU3Ryb2tlO1xuICAgICAgICB0aGlzLmFyY2dpc1N5bWJvbFN0eWxlclN0cm9rZUNoYW5nZS5lbWl0KG5vcm1hbGl6ZVNpemVQcm9wKG1lcmdlZFN0cm9rZSkpO1xuICAgICAgICB0aGlzLnNldEludGVybmFsU3ltYm9sKHRoaXMuc3luY1N5bWJvbFByb3BzKHRoaXMuc3ltYm9sKSwgdHJ1ZSk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSwgcG9wb3ZlclByb3BzOiB0aGlzLnBvcG92ZXJQcm9wcywgc3RvcmFnZUlkOiBjb2xvclN0b3JhZ2VJZCwgcmVmOiB0aGlzLnNldENvbG9ySW5wdXRSZWYgfSkpKTtcbiAgfVxuICByZW5kZXJDb2xvclN0cm9rZVRyYW5zcGFyZW5jeUNvbnRlbnQoZGlzYWJsZWQpIHtcbiAgICBjb25zdCB7IHN0cm9rZSB9ID0gdGhpcztcbiAgICBjb25zdCBtYXggPSAxMDA7XG4gICAgY29uc3QgbWluID0gMDtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMuZ2V0U3Ryb2tlU3RyaW5nKFwidHJhbnNwYXJlbmN5XCIpLCBoKFNlbGVjdE51bWJlciwgeyBmbGlwTGFiZWxzOiB0aGlzLnBlcmNlbnRMYWJlbEZsaXAsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogMSwgdW5pdHNMYWJlbDogXCIlXCIsIHZhbHVlOiBhbHBoYVRvVHJhbnNwYXJlbmN5KHN0cm9rZS5jb2xvci5hKSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vbkNvbG9yU3Ryb2tlVHJhbnNwYXJlbmN5Q2hhbmdlLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgZGlzYWJsZWQ6IGRpc2FibGVkLCBsYWJlbDogdGhpcy5nZXRTdHJva2VTdHJpbmcoXCJ0cmFuc3BhcmVuY3lcIikgfSkpKTtcbiAgfVxuICByZW5kZXJTdHJva2VFeHRyYUNvbnRlbnQoZGlzYWJsZWQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgc2VjdGlvbnM6IHsgc3Ryb2tlOiB7IGV4dHJhUGFydHM6IHsgYXJyb3csIGF1dG9TdHJva2VBZGp1c3QsIHN0eWxlLCB3aWR0aCB9IH0gfSwgc3Ryb2tlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1heFdpZHRoSW5QeCA9IDE4O1xuICAgIGNvbnN0IGVkaXRpbmdMaW5lID0gdGhpcy5lZGl0R2VvbWV0cnkgPT09IFwibGluZVwiO1xuICAgIGNvbnN0IGVkaXRpbmdQb2x5Z29uID0gdGhpcy5lZGl0R2VvbWV0cnkgPT09IFwicG9seWdvblwiO1xuICAgIGNvbnN0IG1pbldpZHRoSW5QeCA9IGVkaXRpbmdMaW5lID8gMC4xIDogMDtcbiAgICBjb25zdCBpc0NpbSA9IGlzQ0lNU3ltYm9sKHRoaXMuc3ltYm9sKTtcbiAgICBjb25zdCBjYW5VcGRhdGVTdHlsZSA9ICFpc0NpbSAmJiBzdHlsZSAmJiAoZWRpdGluZ0xpbmUgfHwgZWRpdGluZ1BvbHlnb24pO1xuICAgIGNvbnN0IGNhblVwZGF0ZUFycm93cyA9ICFpc0NpbSAmJiBhcnJvdyAmJiBlZGl0aW5nTGluZTtcbiAgICBjb25zdCBjYW5VcGRhdGVXaWR0aCA9ICFpc0NpbSAmJiB3aWR0aDtcbiAgICBjb25zdCBjYW5VcGRhdGVBdXRvQWRqdXN0ID0gIWlzQ2ltICYmIGF1dG9TdHJva2VBZGp1c3Q7XG4gICAgY29uc3QgZGlyID0gZ2V0RWxlbWVudERpcih0aGlzLmVsKTtcbiAgICBjb25zdCBjdXJyZW50UGxhY2VtZW50ID0gdG9BcnJvd1BsYWNlbWVudChzdHJva2UubWFya2VyKTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnRHcm91cCB9LCBjYW5VcGRhdGVXaWR0aCA/IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGRpcjogZGlyLCBrZXk6IFwid2lkdGgtb3B0aW9uc1wiIH0sIHRoaXMuZ2V0U3Ryb2tlU3RyaW5nKFwid2lkdGhcIiksIGgoU2VsZWN0TnVtYmVyLCB7IGRpc2FibGVkOiBkaXNhYmxlZCB8fFxuICAgICAgICAoYXV0b1N0cm9rZUFkanVzdCAmJiBhdXRvU3Ryb2tlQWRqdXN0ICE9PSBcImVkaXRhYmxlXCIgJiYgc3Ryb2tlLmF1dG9BZGp1c3RlZCksIG1pbjogbWluV2lkdGhJblB4LCBtYXg6IG1heFdpZHRoSW5QeCwgc3RlcDogMSwgdW5pdHNMYWJlbDogdGhpcy5tZXJnZWRTdHJpbmdzLnB4LCB2YWx1ZTogc3Ryb2tlLnNpemUsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25TdHJva2VXaWR0aENoYW5nZSwgd2l0aFN0ZXBwZXJzOiAhdGhpcy5uYXJyb3csIGxhYmVsOiB0aGlzLmdldFN0cm9rZVN0cmluZyhcIndpZHRoXCIpIH0pKSkgOiBudWxsLCBjYW5VcGRhdGVBdXRvQWRqdXN0XG4gICAgICA/IHRoaXMucmVuZGVyQXV0b0FkanVzdChkaXIsIHN0cm9rZS5hdXRvQWRqdXN0ZWQsIHRoaXMubWVyZ2VkU3RyaW5ncy5hdXRvQWRqdXN0U3Ryb2tlLCB0aGlzLm9uQXV0b0FkanVzdFN0cm9rZUNoYW5nZSlcbiAgICAgIDogbnVsbCwgY2FuVXBkYXRlQXJyb3dzID8gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgZGlyOiBkaXIsIGtleTogXCJhcnJvdy1vcHRpb25zXCIgfSwgdGhpcy5tZXJnZWRTdHJpbmdzLmFycm93LCBoKFwiY2FsY2l0ZS1kcm9wZG93blwiLCB7IGNsYXNzOiB7XG4gICAgICAgIFtDU1MuaWNvbkRyb3Bkb3duXTogdHJ1ZSxcbiAgICAgICAgW0NTUy5hcnJvd0Ryb3Bkb3duXTogdHJ1ZVxuICAgICAgfSwgb25DYWxjaXRlRHJvcGRvd25TZWxlY3Q6IHRoaXMub25TdHJva2VBcnJvd0NoYW5nZSwgd2lkdGg6IFwibFwiLCBwbGFjZW1lbnQ6IFwidG9wLWVuZFwiLCBcIm92ZXJsYXktcG9zaXRpb25pbmdcIjogKF9hID0gdGhpcy5wb3BvdmVyUHJvcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vdmVybGF5UG9zaXRpb25pbmcsIHNjYWxlOiBcInNcIiB9LCBoKFwiZGl2XCIsIHsgcm9sZTogXCJidXR0b25cIiwgc2xvdDogXCJ0cmlnZ2VyXCIsIHRhYkluZGV4OiAwIH0sIGgoXCJkaXZcIiwgeyBcImRhdGEtYXJyb3dcIjogY3VycmVudFBsYWNlbWVudCwgY2xhc3M6IENTUy5pY29uRHJvcGRvd25TZWxlY3RlZCwgc3R5bGU6IHRoaXMuZ2V0U2VsZWN0ZWRBcnJvd1BhdHRlcm5TdHlsZSgpIH0pLCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgaWNvbjogXCJjaGV2cm9uLWRvd25cIiwgc2NhbGU6IFwic1wiIH0pKSwgaChcImNhbGNpdGUtZHJvcGRvd24tZ3JvdXBcIiwgbnVsbCwgc3VwcG9ydGVkQXJyb3dzLm1hcCgoYXJyb3cpID0+IChoKFwiY2FsY2l0ZS1kcm9wZG93bi1pdGVtXCIsIHsgc2VsZWN0ZWQ6IGFycm93ID09PSBjdXJyZW50UGxhY2VtZW50LCBcImRhdGEtYXJyb3dcIjogYXJyb3cgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuaWNvbkRyb3Bkb3duSXRlbUNvbnRlbnQsIFwiZGF0YS1hcnJvd1wiOiBhcnJvdywgc3R5bGU6IHRoaXMuZ2V0QXJyb3dQYXR0ZXJuT3B0aW9uU3R5bGUoKSB9KSkpKSkpKSkgOiBudWxsLCBjYW5VcGRhdGVTdHlsZSA/IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGRpcjogZGlyLCBrZXk6IFwicGF0dGVybi1vcHRpb25zXCIgfSwgdGhpcy5tZXJnZWRTdHJpbmdzLnBhdHRlcm4sIGgoXCJjYWxjaXRlLWRyb3Bkb3duXCIsIHsgY2xhc3M6IHtcbiAgICAgICAgW0NTUy5pY29uRHJvcGRvd25dOiB0cnVlLFxuICAgICAgICBbQ1NTLnN0eWxlRHJvcGRvd25dOiB0cnVlXG4gICAgICB9LCBvbkNhbGNpdGVEcm9wZG93blNlbGVjdDogdGhpcy5vblN0cm9rZVN0eWxlQ2hhbmdlLCB3aWR0aDogXCJsXCIsIHBsYWNlbWVudDogXCJ0b3AtZW5kXCIsIFwib3ZlcmxheS1wb3NpdGlvbmluZ1wiOiAoX2IgPSB0aGlzLnBvcG92ZXJQcm9wcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm92ZXJsYXlQb3NpdGlvbmluZywgc2NhbGU6IFwic1wiIH0sIGgoXCJkaXZcIiwgeyByb2xlOiBcImJ1dHRvblwiLCBzbG90OiBcInRyaWdnZXJcIiwgdGFiSW5kZXg6IDAgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuaWNvbkRyb3Bkb3duU2VsZWN0ZWQsIHN0eWxlOiB0aGlzLmdldExpbmVQYXR0ZXJuU3R5bGUoc3Ryb2tlLnN0eWxlKSB9KSwgaChcImNhbGNpdGUtaWNvblwiLCB7IGljb246IFwiY2hldnJvbi1kb3duXCIsIHNjYWxlOiBcInNcIiB9KSksIGgoXCJjYWxjaXRlLWRyb3Bkb3duLWdyb3VwXCIsIG51bGwsIHN1cHBvcnRlZFN0eWxlcy5tYXAoKHN0eWxlKSA9PiB7XG4gICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWRyb3Bkb3duLWl0ZW1cIiwgeyBzZWxlY3RlZDogc3R5bGUgPT09IHN0cm9rZS5zdHlsZSwgXCJkYXRhLXN0eWxlXCI6IHN0eWxlIH0sIGgoXCJkaXZcIiwgeyBzdHlsZTogdGhpcy5nZXRMaW5lUGF0dGVyblN0eWxlKHN0eWxlKSwgY2xhc3M6IENTUy5pY29uRHJvcGRvd25JdGVtQ29udGVudCB9KSkpO1xuICAgIH0pKSkpKSA6IG51bGwpKTtcbiAgfVxuICByZW5kZXJDb2xvclJhbXBTdHJva2VCbG9jayhlbWJlZGRlZCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbnMuc3Ryb2tlO1xuICAgIGNvbnN0IHBhcnRzID0gc2VjdGlvbi5wYXJ0cztcbiAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgaWYgKHBhcnRzLmNvbG9yUmFtcHMpIHtcbiAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyU3Ryb2tlQ29sb3JSYW1wc0NvbnRlbnQoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJ0cy50cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyQ29sb3JSYW1wU3Ryb2tlVHJhbnNwYXJlbmN5Q29udGVudChzZWN0aW9uLm9wdGlvbmFsID09PSBcIm5vbi1lZGl0YWJsZVwiIHx8IHRoaXMuaGFzQWN0aXZlUGljdHVyZU1hcmtlclN5bWJvbCgpKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJ0cy5leHRyYSkge1xuICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTdHJva2VFeHRyYUNvbnRlbnQoc2VjdGlvbi5vcHRpb25hbCA9PT0gXCJub24tZWRpdGFibGVcIiB8fCB0aGlzLmhhc0FjdGl2ZVBpY3R1cmVNYXJrZXJTeW1ib2woKSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJTZWN0aW9uKHtcbiAgICAgIGtleTogXCJjb2xvci1yYW1wLXN0cm9rZVwiLFxuICAgICAgZGlzYWJsZWQ6IHNlY3Rpb24ub3B0aW9uYWwgPT09IFwibm9uLWVkaXRhYmxlXCIgfHwgdGhpcy5oYXNBY3RpdmVQaWN0dXJlTWFya2VyU3ltYm9sKCksXG4gICAgICBlbWJlZGRlZCxcbiAgICAgIHNlY3Rpb25Db250ZW50OiBjb250ZW50XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQ29sb3JSYW1wU3Ryb2tlVHJhbnNwYXJlbmN5Q29udGVudChkaXNhYmxlZCkge1xuICAgIGNvbnN0IHsgc3Ryb2tlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1heCA9IDEwMDtcbiAgICBjb25zdCBtaW4gPSAwO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5nZXRTdHJva2VTdHJpbmcoXCJ0cmFuc3BhcmVuY3lcIiksIGgoU2VsZWN0TnVtYmVyLCB7IGZsaXBMYWJlbHM6IHRoaXMucGVyY2VudExhYmVsRmxpcCwgbWluOiBtaW4sIG1heDogbWF4LCBzdGVwOiAxLCB1bml0c0xhYmVsOiBcIiVcIiwgdmFsdWU6IGFscGhhVG9UcmFuc3BhcmVuY3koc3Ryb2tlLmNvbG9yWzBdLmEpLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uQ29sb3JSYW1wU3Ryb2tlVHJhbnNwYXJlbmN5Q2hhbmdlLCB3aXRoU3RlcHBlcnM6ICF0aGlzLm5hcnJvdywgZGlzYWJsZWQ6IGRpc2FibGVkLCBsYWJlbDogdGhpcy5nZXRTdHJva2VTdHJpbmcoXCJ0cmFuc3BhcmVuY3lcIikgfSkpKTtcbiAgfVxuICBjaGVja1BvcG92ZXJNYXhIZWlnaHQoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLy8gaWYgbm90IHNldCBieSBjYWxsZXIgdGhlbiBjYWxjdWxhdGUgdGhlIG1heCBoZWlnaHQgZm9yIGFueSBwb3BvdmVyIG9wZW5lbmQgYnkgdGhlIHN0eWxlclxuICAgIGlmICh0aGlzLmZsb3dFbCAmJiB0aGlzLnBvcG92ZXJQcm9wcyAmJiAoIXRoaXMucG9wb3ZlclByb3BzLm1heEhlaWdodCB8fCB0aGlzLmF1dG9DYWxjSGVpZ2h0KSkge1xuICAgICAgdGhpcy5hdXRvQ2FsY0hlaWdodCA9IHRydWU7XG4gICAgICBjb25zdCBwYW5lbFJlY3QgPSB0aGlzLmZsb3dFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fFxuICAgICAgICAoKF9hID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpZW50SGVpZ2h0KSB8fFxuICAgICAgICAoKF9iID0gZG9jdW1lbnQuYm9keSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsaWVudEhlaWdodCkgfHxcbiAgICAgICAgMDtcbiAgICAgIGNvbnN0IHNwYWNlVG9Cb3R0b20gPSB3aW5kb3dIZWlnaHQgJiYgKHBhbmVsUmVjdCA9PT0gbnVsbCB8fCBwYW5lbFJlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhbmVsUmVjdC50b3ApID8gd2luZG93SGVpZ2h0IC0gcGFuZWxSZWN0LnRvcCAtIDMwIDogMDtcbiAgICAgIHRoaXMucG9wb3ZlclByb3BzLm1heEhlaWdodCA9IGAke01hdGgubWF4KHNwYWNlVG9Cb3R0b20gfHwgcGFuZWxSZWN0LmhlaWdodCwgMjUwKSAtXG4gICAgICAgICgoX2MgPSB0aGlzLnBvcG92ZXJQcm9wcy5vZmZzZXREaXN0YW5jZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgLVxuICAgICAgICA1fXB4YDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBhc3NldHNEaXJzKCkgeyByZXR1cm4gW1wiYXNzZXRzXCJdOyB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcImJ1aWx0SW5TdHJpbmdzXCI6IFtcImhhbmRsZVN0cmluZ0NoYW5nZXNcIl0sXG4gICAgXCJzdHJpbmdPdmVycmlkZXNcIjogW1wiaGFuZGxlU3RyaW5nQ2hhbmdlc1wiXVxuICB9OyB9XG59O1xuQXJjR0lTU3ltYm9sU3R5bGVyLnN0eWxlID0gYXJjZ2lzU3ltYm9sU3R5bGVyQ3NzO1xuXG5leHBvcnQgeyBBcmNHSVNTeW1ib2xTdHlsZXIgYXMgYXJjZ2lzX3N5bWJvbF9zdHlsZXIgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuY29uc3QgQ1NTID0ge1xuICBjdXN0b21TeW1ib2xDb250ZW50OiBcImN1c3RvbS1zeW1ib2wtY29udGVudFwiLFxuICBhdXRvQWRqdXN0TGFiZWw6IFwiYXV0by1hZGp1c3QtbGFiZWxcIixcbiAgc3R5bGVEcm9wZG93bjogXCJzdHlsZS1kcm9wZG93blwiLFxuICBhcnJvd0Ryb3Bkb3duOiBcImFycm93LWRyb3Bkb3duXCIsXG4gIGljb25Ecm9wZG93bjogXCJpY29uLWRyb3Bkb3duXCIsXG4gIGljb25Ecm9wZG93blNlbGVjdGVkOiBcImljb24tZHJvcGRvd24tLXNlbGVjdGVkXCIsXG4gIGljb25Ecm9wZG93bkl0ZW1Db250ZW50OiBcImljb24tZHJvcGRvd24taXRlbS1jb250ZW50XCIsXG4gIGNvbG9yUmFtcEZsaXBwZXI6IFwiY29sb3ItcmFtcC1mbGlwcGVyXCIsXG4gIHNjcm9sbGVyOiBcInNjcm9sbGVyXCIsXG4gIGNvbG9yUmFtcFNlbGVjdGlvbjogXCJjb2xvci1yYW1wLXNlbGVjdGlvblwiLFxuICBzZWN0aW9uVG9nZ2xlRGlzYWJsZWQ6IFwic2VjdGlvbi10b2dnbGUtLWRpc2FibGVkXCIsXG4gIGF1dG9BZGp1c3RDaGVja2JveDogXCJhdXRvLWFkanVzdC1jaGVja2JveFwiLFxuICBjb250ZW50R3JvdXA6IFwiY29udGVudC1ncm91cFwiLFxuICBjb2xvckxvY2tlZEluZm86IFwiY29sb3ItbG9ja2VkLWluZm9cIixcbiAgbWVzc2FnZTogXCJtZXNzYWdlXCIsXG4gIC8vIHN5bWJvbCBidXR0b25cbiAgY29udGFpbmVyOiBcImNvbnRhaW5lclwiLFxuICBsYWJlbDogXCJsYWJlbFwiLFxuICBvcGVuSWNvbjogXCJvcGVuLWljb25cIixcbiAgc3ltYm9sOiBcInN5bWJvbFwiLFxuICBjaGFuZ2VTeW1ib2xUcmlnZ2VyOiBcImNoYW5nZS1zeW1ib2wtdHJpZ2dlclwiXG59O1xuY29uc3QgY2F0ZWdvcmllc1RvVGFncyA9IHtcbiAgYWxsOiBbXCIqXCJdLFxuICBsaWdodDogW1wibGlnaHRcIl0sXG4gIGRhcms6IFtcImRhcmtcIl0sXG4gIHJlZHNBbmRZZWxsb3dzOiBbXCJvcmFuZ2VzXCIsIFwicmVkc1wiLCBcInllbGxvd3NcIl0sXG4gIGdyZWVuczogW1wiZ3JlZW5zXCJdLFxuICBibHVlczogW1wiYmx1ZXNcIl0sXG4gIHB1cnBsZXNBbmRQaW5rczogW1wicHVycGxlc1wiLCBcInBpbmtzXCJdLFxuICBicm93bnM6IFtcImJyb3duc1wiXSxcbiAgZ3JheXM6IFtcImdyYXlzXCJdLFxuICBicmlnaHQ6IFtcImJyaWdodFwiXSxcbiAgc3ViZHVlZDogW1wic3ViZHVlZFwiXSxcbiAgY29sb3JibGluZEZyaWVuZGx5OiBbXCJjb2xvcmJsaW5kLWZyaWVuZGx5XCJdXG59O1xuY29uc3Qgc3VwcG9ydGVkQXJyb3dzID0gW1wibm9uZVwiLCBcImJlZ2luXCIsIFwiZW5kXCIsIFwiYmVnaW4tZW5kXCJdO1xuY29uc3Qgc3VwcG9ydGVkU3R5bGVzID0gW1xuICBcInNvbGlkXCIsXG4gIFwiZGFzaFwiLFxuICBcImRvdFwiLFxuICBcImRhc2gtZG90XCIsXG4gIFwibG9uZy1kYXNoLWRvdC1kb3RcIixcbiAgXCJzaG9ydC1kYXNoXCIsXG4gIFwic2hvcnQtZG90XCIsXG4gIFwic2hvcnQtZGFzaC1kb3RcIixcbiAgXCJzaG9ydC1kYXNoLWRvdC1kb3RcIixcbiAgXCJsb25nLWRhc2hcIixcbiAgXCJsb25nLWRhc2gtZG90XCJcbl07XG5jb25zdCBkZWZhdWx0VmlzaWJsZU1hcmtlclNlY3Rpb25QYXJ0cyA9IHtcbiAgc2l6ZTogdHJ1ZSxcbiAgcHJldmlldzogdHJ1ZSxcbiAgcm90YXRpb246IHRydWVcbn07XG5jb25zdCBkZWZhdWx0VmlzaWJsZUV4dHJhU3Ryb2tlU2VjdGlvblBhcnRzID0ge1xuICBzdHlsZTogdHJ1ZSxcbiAgYXJyb3c6IHRydWUsXG4gIHdpZHRoOiB0cnVlLFxuICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZVxufTtcbmNvbnN0IGRlZmF1bHRWaXNpYmxlQ29sb3JTZWN0aW9uUGFydHMgPSB7XG4gIHN1Z2dlc3RlZENvbG9yczogdHJ1ZSxcbiAgY3VzdG9tQ29sb3I6IHRydWUsXG4gIHRyYW5zcGFyZW5jeTogdHJ1ZVxufTtcbmNvbnN0IGRlZmF1bHRWaXNpYmxlQ29sb3JSYW1wU2VjdGlvblBhcnRzID0ge1xuICBjb2xvclJhbXBzOiB0cnVlLFxuICB0cmFuc3BhcmVuY3k6IHRydWVcbn07XG5jb25zdCBkZWZhdWx0VmlzaWJsZVN0cm9rZVNlY3Rpb25QYXJ0cyA9IHtcbiAgZXh0cmE6IHRydWVcbn07XG5jb25zdCBjb2xvclN0b3JhZ2VJZCA9IFwiYXJjZ2lzLXN5bWJvbC1zdHlsZXItc3RvcmFnZS1jb2xvcnNcIjtcbmNvbnN0IHBvaW50UHJldmlld09wdGlvbnMgPSB7XG4gIHNpemU6IDI0LFxuICBtYXhTaXplOiAyNFxufTtcbmNvbnN0IG9wYWNpdHlNYXggPSAxMDA7XG5jb25zdCBvcGFjaXR5TWluID0gMDtcbmNvbnN0IG1heFdpZHRoSW5QeCA9IDE4O1xuY29uc3QgbWluV2lkdGhJblB4ID0gMDtcbmNvbnN0IHJvdGF0aW9uTWF4ID0gMzYwO1xuY29uc3Qgcm90YXRpb25NaW4gPSAwO1xuY29uc3Qgc2l6ZU1heCA9IDE1MDtcbmNvbnN0IHNpemVNaW4gPSAxO1xuY29uc3QgbWFya2VyUGxhY2VtZW50U3RlcE1heCA9IDIwMDtcbmNvbnN0IG1hcmtlclBsYWNlbWVudFN0ZXBNaW4gPSAwO1xuY29uc3QgbWFya2VyUGxhY2VtZW50UmFuZG9tbmVzc01heCA9IDEwMDtcbmNvbnN0IG1hcmtlclBsYWNlbWVudFJhbmRvbW5lc3NNaW4gPSAwO1xuY29uc3QgbWF4RGlzcGxheWVkU3ltYm9sTGF5ZXJzID0gMTA7XG5jb25zdCBoYXRjaEZpbGxTZXBhcmF0aW9uTWF4ID0gMjAwO1xuY29uc3QgaGF0Y2hGaWxsU2VwYXJhdGlvbk1pbiA9IDA7XG5jb25zdCBoYXRjaEZpbGxPZmZzZXRNYXggPSAxMDA7XG5jb25zdCBoYXRjaEZpbGxPZmZzZXRNaW4gPSAwO1xuY29uc3QgYW5pbWF0aW9uRHVyYXRpb25NYXggPSAxMjA7XG5jb25zdCBhbmltYXRpb25EdXJhdGlvbk1pbiA9IDA7XG5cbmZ1bmN0aW9uIGZsaXBDb2xvclJhbXBTdG9wcyhzdG9wcywgaXMyZCA9IGZhbHNlKSB7XG4gIHJldHVybiBpczJkID8gZmxpcEZsYXR0ZW5lZDJEUmFtcChzdG9wcykgOiBzdG9wcy5zbGljZSgpLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGZsaXBGbGF0dGVuZWQyRFJhbXAoZmxhdDJkU3RvcHMpIHtcbiAgY29uc3QgbnVtQ2xhc3NlcyA9IE1hdGguc3FydChmbGF0MmRTdG9wcy5sZW5ndGgpO1xuICBjb25zdCByYW1wMmQgPSBleHBhbmQyRChmbGF0MmRTdG9wcyk7XG4gIGNvbnN0IG9sZFJhbXAgPSByYW1wMmQucmV2ZXJzZSgpO1xuICBjb25zdCBmbGlwcGVkUmFtcCA9IFtdO1xuICAvLyBGbGlwIDJEIG1hdHJpeCBvZiBjb2xvcnMgYnkgOTAgZGVncmVlcyBpbiBjbG9ja3dpc2UgZGlyZWN0aW9uLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsYXNzZXM7IGkrKykge1xuICAgIGNvbnN0IG5ld1JvdyA9IFtdO1xuICAgIG9sZFJhbXAuZm9yRWFjaCgob2xkUm93KSA9PiBuZXdSb3cucHVzaChvbGRSb3dbaV0pKTtcbiAgICBmbGlwcGVkUmFtcC5wdXNoKG5ld1Jvdyk7XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW4yRChmbGlwcGVkUmFtcCkucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gZXhwYW5kMkQoc3RvcHMsIGZvY3VzKSB7XG4gIGxldCBleHBhbmRlZEFycmF5ID0gW107XG4gIGNvbnN0IG51bUNsYXNzZXMgPSBNYXRoLnNxcnQoc3RvcHMubGVuZ3RoKTtcbiAgLy8gRm9jdXMgZGVjaWRlcyB3aGV0aGVyIHdlIHJldmVyc2UgdGhlIG91dGVyL2lubmVyIGFycmF5cyBvciBub3QuXG4gIGNvbnN0IGNvZGVzID0gKGZvY3VzIHx8IFwiSEhcIikuc3BsaXQoXCJcIik7XG4gIGNvbnN0IHN0YXJ0Um93Q29kZSA9IGNvZGVzWzBdO1xuICBjb25zdCBzdGFydENvbENvZGUgPSBjb2Rlc1sxXTtcbiAgY29uc3QgcmV2ZXJzZUVhY2hSb3cgPSBzdGFydENvbENvZGUgIT09IFwiSFwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsYXNzZXM7IGkrKykge1xuICAgIGxldCByb3cgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNsYXNzZXM7IGorKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpICogbnVtQ2xhc3NlcyArIGo7XG4gICAgICByb3cucHVzaChzdG9wc1tpbmRleF0pO1xuICAgIH1cbiAgICBpZiAocmV2ZXJzZUVhY2hSb3cpIHtcbiAgICAgIHJvdy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGV4cGFuZGVkQXJyYXkucHVzaChyb3cpO1xuICB9XG4gIGlmIChzdGFydFJvd0NvZGUgPT09IFwiTFwiKSB7XG4gICAgZXhwYW5kZWRBcnJheS5yZXZlcnNlKCk7XG4gIH1cbiAgcmV0dXJuIGV4cGFuZGVkQXJyYXk7XG59XG5mdW5jdGlvbiBmbGF0dGVuMkQoYXJyYXkyZCwgZm9jdXMpIHtcbiAgLy8gUmV0dXJucyBhIGZsYXR0ZW5lZCBhcnJheSBmcm9tIHRoZSBnaXZlbiAyZCBhcnJheS5cbiAgLy8gYXJyYXkyZCBpcyBhc3N1bWVkIHRvIGhhdmUgdGhlIGxheW91dCBzdHJ1Y3R1cmUgb3V0bGluZWQgYXQ6XG4gIC8vIHJlbmRlcmVycy91dGlsczpnZXRDbGFzc1ZhbHVlc0ZvclJlbGF0aW9uc2hpcC5cbiAgLy8gT3JkZXIgb2YgZWxlbWVudHMgaW4gdGhlIG91dHB1dCBhcnJheSBpcyBkZXRlcm1pbmVkIGJ5IFwiZm9jdXNcIi5cbiAgLy8gXCJmb2N1c1wiIGNhbiBiZTogSEgsIEhMLCBMSCBvciBMTC4gRGVmYXVsdCBpcyBcIkhIXCIuXG4gIGxldCBmbGF0QXJyYXkgPSBbXTtcbiAgLy8gY2xvbmUgdG8gYXZvaWQgbW9kaWZ5aW5nIHNvdXJjZSBkYXRhXG4gIGFycmF5MmQgPSBhcnJheTJkLnNsaWNlKCkubWFwKChjb2xvcnMpID0+IGNvbG9ycy5zbGljZSgpKTtcbiAgLy8gRm9jdXMgZGVjaWRlcyB3aGV0aGVyIHdlIHJldmVyc2UgdGhlIG91dGVyL2lubmVyIGFycmF5cyBvciBub3QuXG4gIGNvbnN0IGNvZGVzID0gKGZvY3VzIHx8IFwiSEhcIikuc3BsaXQoXCJcIiksIHN0YXJ0Um93Q29kZSA9IGNvZGVzWzBdLCBzdGFydENvbENvZGUgPSBjb2Rlc1sxXTtcbiAgaWYgKHN0YXJ0Um93Q29kZSA9PT0gXCJMXCIpIHtcbiAgICBhcnJheTJkLnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCByZXZlcnNlRWFjaFJvdyA9IHN0YXJ0Q29sQ29kZSA9PT0gXCJIXCI7XG4gIGFycmF5MmQuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgaWYgKHJldmVyc2VFYWNoUm93KSB7XG4gICAgICByb3cuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGZsYXRBcnJheSA9IGZsYXRBcnJheS5jb25jYXQocm93KTtcbiAgfSk7XG4gIHJldHVybiBmbGF0QXJyYXk7XG59XG5cbmV4cG9ydCB7IG1hcmtlclBsYWNlbWVudFN0ZXBNaW4gYXMgQSwgbWFya2VyUGxhY2VtZW50UmFuZG9tbmVzc01heCBhcyBCLCBDU1MgYXMgQywgbWFya2VyUGxhY2VtZW50UmFuZG9tbmVzc01pbiBhcyBELCBleHBhbmQyRCBhcyBFLCBjYXRlZ29yaWVzVG9UYWdzIGFzIEYsIG1heFdpZHRoSW5QeCBhcyBhLCBzdXBwb3J0ZWRTdHlsZXMgYXMgYiwgZGVmYXVsdFZpc2libGVDb2xvclNlY3Rpb25QYXJ0cyBhcyBjLCBkZWZhdWx0VmlzaWJsZU1hcmtlclNlY3Rpb25QYXJ0cyBhcyBkLCBkZWZhdWx0VmlzaWJsZUNvbG9yUmFtcFNlY3Rpb25QYXJ0cyBhcyBlLCBmbGlwQ29sb3JSYW1wU3RvcHMgYXMgZiwgZGVmYXVsdFZpc2libGVFeHRyYVN0cm9rZVNlY3Rpb25QYXJ0cyBhcyBnLCBkZWZhdWx0VmlzaWJsZVN0cm9rZVNlY3Rpb25QYXJ0cyBhcyBoLCBtYXhEaXNwbGF5ZWRTeW1ib2xMYXllcnMgYXMgaSwgY29sb3JTdG9yYWdlSWQgYXMgaiwgb3BhY2l0eU1heCBhcyBrLCByb3RhdGlvbk1heCBhcyBsLCBtaW5XaWR0aEluUHggYXMgbSwgc2l6ZU1pbiBhcyBuLCBvcGFjaXR5TWluIGFzIG8sIHBvaW50UHJldmlld09wdGlvbnMgYXMgcCwgc2l6ZU1heCBhcyBxLCByb3RhdGlvbk1pbiBhcyByLCBzdXBwb3J0ZWRBcnJvd3MgYXMgcywgaGF0Y2hGaWxsT2Zmc2V0TWF4IGFzIHQsIGhhdGNoRmlsbE9mZnNldE1pbiBhcyB1LCBoYXRjaEZpbGxTZXBhcmF0aW9uTWF4IGFzIHYsIGhhdGNoRmlsbFNlcGFyYXRpb25NaW4gYXMgdywgYW5pbWF0aW9uRHVyYXRpb25NYXggYXMgeCwgYW5pbWF0aW9uRHVyYXRpb25NaW4gYXMgeSwgbWFya2VyUGxhY2VtZW50U3RlcE1heCBhcyB6IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=