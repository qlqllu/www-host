"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["node_modules_esri_calcite-components-react_node_modules_esri_calcite-components_dist_componen-dab0e4"],{

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/index3.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/index3.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   groupTimeZones: () => (/* binding */ groupTimeZones)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */
const supportedTimeZones = (() => {
    const platformTimeZones = Intl.supportedValuesOf('timeZone');
    // not all browsers include these time zones, so we add them to ensure consistent groups
    const etcTimeZones = [
        "Etc/GMT+1",
        "Etc/GMT+10",
        "Etc/GMT+11",
        "Etc/GMT+12",
        "Etc/GMT+2",
        "Etc/GMT+3",
        "Etc/GMT+4",
        "Etc/GMT+5",
        "Etc/GMT+6",
        "Etc/GMT+7",
        "Etc/GMT+8",
        "Etc/GMT+9",
        "Etc/GMT-1",
        "Etc/GMT-10",
        "Etc/GMT-11",
        "Etc/GMT-12",
        "Etc/GMT-13",
        "Etc/GMT-14",
        "Etc/GMT-2",
        "Etc/GMT-3",
        "Etc/GMT-4",
        "Etc/GMT-5",
        "Etc/GMT-6",
        "Etc/GMT-7",
        "Etc/GMT-8",
        "Etc/GMT-9"
    ];
    return [...new Set([...platformTimeZones, ...etcTimeZones])];
})();

const now = new Date();
const startDate = now.toISOString();
const daysInYear = 365;
const groupDateRange = daysInYear;
const defaultGroupingOptions = {
    startDate,
    groupDateRange,
    debug: false,
};

const continentAllowList = new Set([
    'Europe',
    'Asia',
    'America',
    'America/Argentina',
    'Africa',
    'Australia',
    'Pacific',
    'Atlantic',
    'Antarctica',
    'Arctic',
    'Indian',
]);
const _getDates = (startDate, numberDays, dateEngine) => {
    const dateArray = [];
    let date = dateEngine.create(startDate);
    for (let i = 0; i <= numberDays; i++) {
        date = dateEngine.increase(date);
        dateArray.push(dateEngine.formatToIsoDateString(date));
    }
    return dateArray;
};
const _extractContinent = (label) => {
    if (label.includes('Istanbul')) {
        return 'Europe';
    }
    const lastIndex = label.lastIndexOf('/');
    return lastIndex === -1 ? label : label.slice(0, lastIndex);
};
const _isRegularContinent = (continent) => continentAllowList.has(continent);
const generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine, debug = false) => {
    const processedDates = new Map();
    if (debug) {
        console.log(`Initializing data starting ${startDate} with ${numberDays} days in the future, comparing ${timeZoneItems.length} timezones`);
    }
    const theDates = _getDates(startDate, numberDays, dateEngine);
    return timeZoneItems.map((tzItem) => {
        const label = tzItem.label;
        const continent = _extractContinent(label);
        const dates = theDates.map((date) => {
            const key = `${date}-${label}`;
            let utc = processedDates.get(key);
            if (utc) {
                return utc;
            }
            utc = dateEngine.isoToTimeZone(date, label);
            processedDates.set(key, utc);
            return utc;
        });
        return {
            ...tzItem,
            continent,
            isRegularContinent: _isRegularContinent(continent),
            dates,
        };
    });
};
const compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&
    array1.every((value, index) => dateEngine.same(value, array2[index]));
const getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {
    const shrinkedTzs = rawTZs.filter(({ label }) => _isRegularContinent(_extractContinent(label)));
    if (shrinkedTzs.length === 0) {
        return [0];
    }
    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));
    return equallyDistributedSampling(validLabels, max);
};
function equallyDistributedSampling(items, maxItems = 5) {
    const totalItems = items.length;
    if (totalItems <= maxItems) {
        return items;
    }
    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);
    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);
    return [
        items[0],
        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),
        items[totalItems - 1],
    ];
}

async function groupTimeZones(options) {
    const { debug, groupDateRange, hooks, startDate, dateEngine } = {
        ...defaultGroupingOptions,
        ...options,
    };
    const grouping = [];
    if (!dateEngine) {
        throw new Error('dateEngine is required');
    }
    const timeZoneItems = supportedTimeZones.map((tz) => ({ label: tz }));
    hooks?.onBeforeTimeZoneMetadataCreate?.(timeZoneItems);
    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine, debug);
    hooks?.onTimeZoneMetadataCreate?.(timeZoneMetadata);
    // We traverse the mappedDB and see if we find matches by comparing each set
    // of transformed date for that specific TZ.
    for (const tzMetadatumI of timeZoneMetadata) {
        const { label, continent, dates } = tzMetadatumI;
        // ignore if we visited this element already
        if (tzMetadatumI.visited) {
            continue;
        }
        // Mark element as already visited
        tzMetadatumI.visited = true;
        // The grouped timezone that we want as a result
        const newGroup = {
            labelTzIndices: undefined,
            tzs: [{ label }],
        };
        hooks?.onGroupCreate?.(newGroup, tzMetadatumI);
        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {
            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;
            // We define a matching TZ by:
            // 1) if both continents match (avoid grouping Antarctica with anything else)
            // 2) if the transformed dates match in both TZs
            if ((continent === continentJ || !isRegularContinentJ) &&
                compareDateArrs(dates, datesJ, dateEngine)) {
                const tzItem = { label: labelJ };
                newGroup.tzs.push(tzItem);
                hooks?.onGroupTimeZoneAdd?.(newGroup, tzItem, tzMetadatumJ);
                // Mark element as already visited
                tzMetadatumJ.visited = true;
            }
        }
        grouping.push(newGroup);
        hooks?.onGroupAdd?.(newGroup);
    }
    // Now that we have a group, we want an easy way to find a fitting label for the group
    // which is defined as the list of the most-common 7 cities, shown in alphabetical order
    const finalGrouping = grouping
        .map((group) => {
        hooks?.onBeforeFinalGroupCreate?.(group);
        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));
        const finalGrouping = {
            labelTzIndices: getGroupLabelTimeZoneIndices(group.tzs, 7),
            tzs: group.tzs.map((_) => _.label),
        };
        hooks?.onFinalGroupCreate?.(finalGrouping, group);
        return finalGrouping;
    })
        .sort((a, b) => b.tzs.length - a.tzs.length);
    if (debug) {
        const missingTzs = supportedTimeZones
            .map((tz) => (finalGrouping.some((y) => y.tzs.includes(tz)) ? null : tz))
            .filter(Boolean);
        if (missingTzs.length > 0) {
            throw new Error(`There are ${missingTzs.length} missing timezones: ${missingTzs.toString()}`);
        }
    }
    return hooks?.onFinalGroupingCreate
        ? hooks.onFinalGroupingCreate(finalGrouping)
        : finalGrouping;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3Mvbm9kZV9tb2R1bGVzX2VzcmlfY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0X25vZGVfbW9kdWxlc19lc3JpX2NhbGNpdGUtY29tcG9uZW50c19kaXN0X2NvbXBvbmVuLWRhYjBlNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVyxPQUFPLFlBQVksZ0NBQWdDLHNCQUFzQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxHQUFHLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHNEQUFzRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdHQUFnRztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CLHFCQUFxQixzQkFBc0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2luZGV4My5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMTEuMFxuICovXG5jb25zdCBzdXBwb3J0ZWRUaW1lWm9uZXMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHBsYXRmb3JtVGltZVpvbmVzID0gSW50bC5zdXBwb3J0ZWRWYWx1ZXNPZigndGltZVpvbmUnKTtcbiAgICAvLyBub3QgYWxsIGJyb3dzZXJzIGluY2x1ZGUgdGhlc2UgdGltZSB6b25lcywgc28gd2UgYWRkIHRoZW0gdG8gZW5zdXJlIGNvbnNpc3RlbnQgZ3JvdXBzXG4gICAgY29uc3QgZXRjVGltZVpvbmVzID0gW1xuICAgICAgICBcIkV0Yy9HTVQrMVwiLFxuICAgICAgICBcIkV0Yy9HTVQrMTBcIixcbiAgICAgICAgXCJFdGMvR01UKzExXCIsXG4gICAgICAgIFwiRXRjL0dNVCsxMlwiLFxuICAgICAgICBcIkV0Yy9HTVQrMlwiLFxuICAgICAgICBcIkV0Yy9HTVQrM1wiLFxuICAgICAgICBcIkV0Yy9HTVQrNFwiLFxuICAgICAgICBcIkV0Yy9HTVQrNVwiLFxuICAgICAgICBcIkV0Yy9HTVQrNlwiLFxuICAgICAgICBcIkV0Yy9HTVQrN1wiLFxuICAgICAgICBcIkV0Yy9HTVQrOFwiLFxuICAgICAgICBcIkV0Yy9HTVQrOVwiLFxuICAgICAgICBcIkV0Yy9HTVQtMVwiLFxuICAgICAgICBcIkV0Yy9HTVQtMTBcIixcbiAgICAgICAgXCJFdGMvR01ULTExXCIsXG4gICAgICAgIFwiRXRjL0dNVC0xMlwiLFxuICAgICAgICBcIkV0Yy9HTVQtMTNcIixcbiAgICAgICAgXCJFdGMvR01ULTE0XCIsXG4gICAgICAgIFwiRXRjL0dNVC0yXCIsXG4gICAgICAgIFwiRXRjL0dNVC0zXCIsXG4gICAgICAgIFwiRXRjL0dNVC00XCIsXG4gICAgICAgIFwiRXRjL0dNVC01XCIsXG4gICAgICAgIFwiRXRjL0dNVC02XCIsXG4gICAgICAgIFwiRXRjL0dNVC03XCIsXG4gICAgICAgIFwiRXRjL0dNVC04XCIsXG4gICAgICAgIFwiRXRjL0dNVC05XCJcbiAgICBdO1xuICAgIHJldHVybiBbLi4ubmV3IFNldChbLi4ucGxhdGZvcm1UaW1lWm9uZXMsIC4uLmV0Y1RpbWVab25lc10pXTtcbn0pKCk7XG5cbmNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG5jb25zdCBzdGFydERhdGUgPSBub3cudG9JU09TdHJpbmcoKTtcbmNvbnN0IGRheXNJblllYXIgPSAzNjU7XG5jb25zdCBncm91cERhdGVSYW5nZSA9IGRheXNJblllYXI7XG5jb25zdCBkZWZhdWx0R3JvdXBpbmdPcHRpb25zID0ge1xuICAgIHN0YXJ0RGF0ZSxcbiAgICBncm91cERhdGVSYW5nZSxcbiAgICBkZWJ1ZzogZmFsc2UsXG59O1xuXG5jb25zdCBjb250aW5lbnRBbGxvd0xpc3QgPSBuZXcgU2V0KFtcbiAgICAnRXVyb3BlJyxcbiAgICAnQXNpYScsXG4gICAgJ0FtZXJpY2EnLFxuICAgICdBbWVyaWNhL0FyZ2VudGluYScsXG4gICAgJ0FmcmljYScsXG4gICAgJ0F1c3RyYWxpYScsXG4gICAgJ1BhY2lmaWMnLFxuICAgICdBdGxhbnRpYycsXG4gICAgJ0FudGFyY3RpY2EnLFxuICAgICdBcmN0aWMnLFxuICAgICdJbmRpYW4nLFxuXSk7XG5jb25zdCBfZ2V0RGF0ZXMgPSAoc3RhcnREYXRlLCBudW1iZXJEYXlzLCBkYXRlRW5naW5lKSA9PiB7XG4gICAgY29uc3QgZGF0ZUFycmF5ID0gW107XG4gICAgbGV0IGRhdGUgPSBkYXRlRW5naW5lLmNyZWF0ZShzdGFydERhdGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bWJlckRheXM7IGkrKykge1xuICAgICAgICBkYXRlID0gZGF0ZUVuZ2luZS5pbmNyZWFzZShkYXRlKTtcbiAgICAgICAgZGF0ZUFycmF5LnB1c2goZGF0ZUVuZ2luZS5mb3JtYXRUb0lzb0RhdGVTdHJpbmcoZGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUFycmF5O1xufTtcbmNvbnN0IF9leHRyYWN0Q29udGluZW50ID0gKGxhYmVsKSA9PiB7XG4gICAgaWYgKGxhYmVsLmluY2x1ZGVzKCdJc3RhbmJ1bCcpKSB7XG4gICAgICAgIHJldHVybiAnRXVyb3BlJztcbiAgICB9XG4gICAgY29uc3QgbGFzdEluZGV4ID0gbGFiZWwubGFzdEluZGV4T2YoJy8nKTtcbiAgICByZXR1cm4gbGFzdEluZGV4ID09PSAtMSA/IGxhYmVsIDogbGFiZWwuc2xpY2UoMCwgbGFzdEluZGV4KTtcbn07XG5jb25zdCBfaXNSZWd1bGFyQ29udGluZW50ID0gKGNvbnRpbmVudCkgPT4gY29udGluZW50QWxsb3dMaXN0Lmhhcyhjb250aW5lbnQpO1xuY29uc3QgZ2VuZXJhdGVUaW1lWm9uZU1ldGFkYXRhID0gKHRpbWVab25lSXRlbXMsIHN0YXJ0RGF0ZSwgbnVtYmVyRGF5cywgZGF0ZUVuZ2luZSwgZGVidWcgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHByb2Nlc3NlZERhdGVzID0gbmV3IE1hcCgpO1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhgSW5pdGlhbGl6aW5nIGRhdGEgc3RhcnRpbmcgJHtzdGFydERhdGV9IHdpdGggJHtudW1iZXJEYXlzfSBkYXlzIGluIHRoZSBmdXR1cmUsIGNvbXBhcmluZyAke3RpbWVab25lSXRlbXMubGVuZ3RofSB0aW1lem9uZXNgKTtcbiAgICB9XG4gICAgY29uc3QgdGhlRGF0ZXMgPSBfZ2V0RGF0ZXMoc3RhcnREYXRlLCBudW1iZXJEYXlzLCBkYXRlRW5naW5lKTtcbiAgICByZXR1cm4gdGltZVpvbmVJdGVtcy5tYXAoKHR6SXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHR6SXRlbS5sYWJlbDtcbiAgICAgICAgY29uc3QgY29udGluZW50ID0gX2V4dHJhY3RDb250aW5lbnQobGFiZWwpO1xuICAgICAgICBjb25zdCBkYXRlcyA9IHRoZURhdGVzLm1hcCgoZGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7ZGF0ZX0tJHtsYWJlbH1gO1xuICAgICAgICAgICAgbGV0IHV0YyA9IHByb2Nlc3NlZERhdGVzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGMgPSBkYXRlRW5naW5lLmlzb1RvVGltZVpvbmUoZGF0ZSwgbGFiZWwpO1xuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0ZXMuc2V0KGtleSwgdXRjKTtcbiAgICAgICAgICAgIHJldHVybiB1dGM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udHpJdGVtLFxuICAgICAgICAgICAgY29udGluZW50LFxuICAgICAgICAgICAgaXNSZWd1bGFyQ29udGluZW50OiBfaXNSZWd1bGFyQ29udGluZW50KGNvbnRpbmVudCksXG4gICAgICAgICAgICBkYXRlcyxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5jb25zdCBjb21wYXJlRGF0ZUFycnMgPSAoYXJyYXkxLCBhcnJheTIsIGRhdGVFbmdpbmUpID0+IGFycmF5MS5sZW5ndGggPT09IGFycmF5Mi5sZW5ndGggJiZcbiAgICBhcnJheTEuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gZGF0ZUVuZ2luZS5zYW1lKHZhbHVlLCBhcnJheTJbaW5kZXhdKSk7XG5jb25zdCBnZXRHcm91cExhYmVsVGltZVpvbmVJbmRpY2VzID0gKHJhd1RacywgbWF4ID0gNSkgPT4ge1xuICAgIGNvbnN0IHNocmlua2VkVHpzID0gcmF3VFpzLmZpbHRlcigoeyBsYWJlbCB9KSA9PiBfaXNSZWd1bGFyQ29udGluZW50KF9leHRyYWN0Q29udGluZW50KGxhYmVsKSkpO1xuICAgIGlmIChzaHJpbmtlZFR6cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFswXTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRMYWJlbHMgPSBzaHJpbmtlZFR6cy5tYXAoKHR6KSA9PiByYXdUWnMuaW5kZXhPZih0eikpO1xuICAgIHJldHVybiBlcXVhbGx5RGlzdHJpYnV0ZWRTYW1wbGluZyh2YWxpZExhYmVscywgbWF4KTtcbn07XG5mdW5jdGlvbiBlcXVhbGx5RGlzdHJpYnV0ZWRTYW1wbGluZyhpdGVtcywgbWF4SXRlbXMgPSA1KSB7XG4gICAgY29uc3QgdG90YWxJdGVtcyA9IGl0ZW1zLmxlbmd0aDtcbiAgICBpZiAodG90YWxJdGVtcyA8PSBtYXhJdGVtcykge1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlckl0ZW1zVG9TZWxlY3QgPSBNYXRoLm1pbih0b3RhbEl0ZW1zIC0gMiwgbWF4SXRlbXMgLSAyKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9ICh0b3RhbEl0ZW1zIC0gMSkgLyAobnVtYmVySXRlbXNUb1NlbGVjdCArIDEpO1xuICAgIHJldHVybiBbXG4gICAgICAgIGl0ZW1zWzBdLFxuICAgICAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiBudW1iZXJJdGVtc1RvU2VsZWN0IH0sIChfLCBpKSA9PiBpdGVtc1tNYXRoLnJvdW5kKChpICsgMSkgKiBzdGVwU2l6ZSldKSxcbiAgICAgICAgaXRlbXNbdG90YWxJdGVtcyAtIDFdLFxuICAgIF07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdyb3VwVGltZVpvbmVzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGRlYnVnLCBncm91cERhdGVSYW5nZSwgaG9va3MsIHN0YXJ0RGF0ZSwgZGF0ZUVuZ2luZSB9ID0ge1xuICAgICAgICAuLi5kZWZhdWx0R3JvdXBpbmdPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgY29uc3QgZ3JvdXBpbmcgPSBbXTtcbiAgICBpZiAoIWRhdGVFbmdpbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRlRW5naW5lIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVab25lSXRlbXMgPSBzdXBwb3J0ZWRUaW1lWm9uZXMubWFwKCh0eikgPT4gKHsgbGFiZWw6IHR6IH0pKTtcbiAgICBob29rcz8ub25CZWZvcmVUaW1lWm9uZU1ldGFkYXRhQ3JlYXRlPy4odGltZVpvbmVJdGVtcyk7XG4gICAgY29uc3QgdGltZVpvbmVNZXRhZGF0YSA9IGdlbmVyYXRlVGltZVpvbmVNZXRhZGF0YSh0aW1lWm9uZUl0ZW1zLCBzdGFydERhdGUsIGdyb3VwRGF0ZVJhbmdlLCBkYXRlRW5naW5lLCBkZWJ1Zyk7XG4gICAgaG9va3M/Lm9uVGltZVpvbmVNZXRhZGF0YUNyZWF0ZT8uKHRpbWVab25lTWV0YWRhdGEpO1xuICAgIC8vIFdlIHRyYXZlcnNlIHRoZSBtYXBwZWREQiBhbmQgc2VlIGlmIHdlIGZpbmQgbWF0Y2hlcyBieSBjb21wYXJpbmcgZWFjaCBzZXRcbiAgICAvLyBvZiB0cmFuc2Zvcm1lZCBkYXRlIGZvciB0aGF0IHNwZWNpZmljIFRaLlxuICAgIGZvciAoY29uc3QgdHpNZXRhZGF0dW1JIG9mIHRpbWVab25lTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBsYWJlbCwgY29udGluZW50LCBkYXRlcyB9ID0gdHpNZXRhZGF0dW1JO1xuICAgICAgICAvLyBpZ25vcmUgaWYgd2UgdmlzaXRlZCB0aGlzIGVsZW1lbnQgYWxyZWFkeVxuICAgICAgICBpZiAodHpNZXRhZGF0dW1JLnZpc2l0ZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgZWxlbWVudCBhcyBhbHJlYWR5IHZpc2l0ZWRcbiAgICAgICAgdHpNZXRhZGF0dW1JLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBUaGUgZ3JvdXBlZCB0aW1lem9uZSB0aGF0IHdlIHdhbnQgYXMgYSByZXN1bHRcbiAgICAgICAgY29uc3QgbmV3R3JvdXAgPSB7XG4gICAgICAgICAgICBsYWJlbFR6SW5kaWNlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHpzOiBbeyBsYWJlbCB9XSxcbiAgICAgICAgfTtcbiAgICAgICAgaG9va3M/Lm9uR3JvdXBDcmVhdGU/LihuZXdHcm91cCwgdHpNZXRhZGF0dW1JKTtcbiAgICAgICAgZm9yIChjb25zdCB0ek1ldGFkYXR1bUogb2YgdGltZVpvbmVNZXRhZGF0YS5maWx0ZXIoKF8pID0+ICFfLnZpc2l0ZWQpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsOiBsYWJlbEosIGNvbnRpbmVudDogY29udGluZW50SiwgaXNSZWd1bGFyQ29udGluZW50OiBpc1JlZ3VsYXJDb250aW5lbnRKLCBkYXRlczogZGF0ZXNKLCB9ID0gdHpNZXRhZGF0dW1KO1xuICAgICAgICAgICAgLy8gV2UgZGVmaW5lIGEgbWF0Y2hpbmcgVFogYnk6XG4gICAgICAgICAgICAvLyAxKSBpZiBib3RoIGNvbnRpbmVudHMgbWF0Y2ggKGF2b2lkIGdyb3VwaW5nIEFudGFyY3RpY2Egd2l0aCBhbnl0aGluZyBlbHNlKVxuICAgICAgICAgICAgLy8gMikgaWYgdGhlIHRyYW5zZm9ybWVkIGRhdGVzIG1hdGNoIGluIGJvdGggVFpzXG4gICAgICAgICAgICBpZiAoKGNvbnRpbmVudCA9PT0gY29udGluZW50SiB8fCAhaXNSZWd1bGFyQ29udGluZW50SikgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZUFycnMoZGF0ZXMsIGRhdGVzSiwgZGF0ZUVuZ2luZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ekl0ZW0gPSB7IGxhYmVsOiBsYWJlbEogfTtcbiAgICAgICAgICAgICAgICBuZXdHcm91cC50enMucHVzaCh0ekl0ZW0pO1xuICAgICAgICAgICAgICAgIGhvb2tzPy5vbkdyb3VwVGltZVpvbmVBZGQ/LihuZXdHcm91cCwgdHpJdGVtLCB0ek1ldGFkYXR1bUopO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgZWxlbWVudCBhcyBhbHJlYWR5IHZpc2l0ZWRcbiAgICAgICAgICAgICAgICB0ek1ldGFkYXR1bUoudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBpbmcucHVzaChuZXdHcm91cCk7XG4gICAgICAgIGhvb2tzPy5vbkdyb3VwQWRkPy4obmV3R3JvdXApO1xuICAgIH1cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGEgZ3JvdXAsIHdlIHdhbnQgYW4gZWFzeSB3YXkgdG8gZmluZCBhIGZpdHRpbmcgbGFiZWwgZm9yIHRoZSBncm91cFxuICAgIC8vIHdoaWNoIGlzIGRlZmluZWQgYXMgdGhlIGxpc3Qgb2YgdGhlIG1vc3QtY29tbW9uIDcgY2l0aWVzLCBzaG93biBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICBjb25zdCBmaW5hbEdyb3VwaW5nID0gZ3JvdXBpbmdcbiAgICAgICAgLm1hcCgoZ3JvdXApID0+IHtcbiAgICAgICAgaG9va3M/Lm9uQmVmb3JlRmluYWxHcm91cENyZWF0ZT8uKGdyb3VwKTtcbiAgICAgICAgZ3JvdXAudHpzID0gZ3JvdXAudHpzLnNvcnQoKGEsIGIpID0+IGEubGFiZWwubG9jYWxlQ29tcGFyZShiLmxhYmVsKSk7XG4gICAgICAgIGNvbnN0IGZpbmFsR3JvdXBpbmcgPSB7XG4gICAgICAgICAgICBsYWJlbFR6SW5kaWNlczogZ2V0R3JvdXBMYWJlbFRpbWVab25lSW5kaWNlcyhncm91cC50enMsIDcpLFxuICAgICAgICAgICAgdHpzOiBncm91cC50enMubWFwKChfKSA9PiBfLmxhYmVsKSxcbiAgICAgICAgfTtcbiAgICAgICAgaG9va3M/Lm9uRmluYWxHcm91cENyZWF0ZT8uKGZpbmFsR3JvdXBpbmcsIGdyb3VwKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsR3JvdXBpbmc7XG4gICAgfSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIudHpzLmxlbmd0aCAtIGEudHpzLmxlbmd0aCk7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdUenMgPSBzdXBwb3J0ZWRUaW1lWm9uZXNcbiAgICAgICAgICAgIC5tYXAoKHR6KSA9PiAoZmluYWxHcm91cGluZy5zb21lKCh5KSA9PiB5LnR6cy5pbmNsdWRlcyh0eikpID8gbnVsbCA6IHR6KSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIGlmIChtaXNzaW5nVHpzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgYXJlICR7bWlzc2luZ1R6cy5sZW5ndGh9IG1pc3NpbmcgdGltZXpvbmVzOiAke21pc3NpbmdUenMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaG9va3M/Lm9uRmluYWxHcm91cGluZ0NyZWF0ZVxuICAgICAgICA/IGhvb2tzLm9uRmluYWxHcm91cGluZ0NyZWF0ZShmaW5hbEdyb3VwaW5nKVxuICAgICAgICA6IGZpbmFsR3JvdXBpbmc7XG59XG5cbmV4cG9ydCB7IGdyb3VwVGltZVpvbmVzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=