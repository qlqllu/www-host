"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-47d5c2"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/api-f7934cd7.js":
/*!*********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/api-f7934cd7.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getAppSwitcherConfig),
/* harmony export */   b: () => (/* binding */ getMarketPlaceProvisionedListings),
/* harmony export */   c: () => (/* binding */ getUserProperties),
/* harmony export */   d: () => (/* binding */ getApprovedApps),
/* harmony export */   e: () => (/* binding */ getOrgCapabilities),
/* harmony export */   f: () => (/* binding */ getSigninSettings),
/* harmony export */   g: () => (/* binding */ getShowInAppLauncher),
/* harmony export */   h: () => (/* binding */ getBlockableApps),
/* harmony export */   i: () => (/* binding */ getServers),
/* harmony export */   j: () => (/* binding */ getPortalSettings),
/* harmony export */   k: () => (/* binding */ fetchAllResources),
/* harmony export */   q: () => (/* binding */ queryAppItemsForChanges),
/* harmony export */   u: () => (/* binding */ updateUserProperties)
/* harmony export */ });
/* harmony import */ var _portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./portal-79caaeff.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js");
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



const appSwitcherConfigItemQuery = `owner:"esri" AND title:"AppSwitcher Config" AND type: "Application Configuration"`;
async function getPortalSettings(portal) {
  const portalUrl = (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)(portal);
  if (!portalUrl) {
    return;
  }
  const url = `${portalUrl}portals/self/settings`;
  return (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.f)(() => request(url), "portalSettings", portalUrl);
}
async function getShowInAppLauncher() {
  var _a;
  const settings = await getPortalSettings();
  return ((_a = settings === null || settings === void 0 ? void 0 : settings.portalConfigProperties) === null || _a === void 0 ? void 0 : _a.showInAppLauncher) || [];
}
async function getAppSwitcherConfigItem() {
  const portalUrl = (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)();
  if (!portalUrl) {
    return;
  }
  const url = `${portalUrl}search`;
  return request(url, {
    num: 1,
    start: 0,
    sortField: "title",
    sortOrder: "asc",
    q: appSwitcherConfigItemQuery
  });
}
async function getConfigData(itemId) {
  const portalUrl = (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)();
  if (!portalUrl || !itemId) {
    return;
  }
  const url = `${portalUrl}content/items/${itemId}/data`;
  return request(url);
}
async function getAppSwitcherConfig() {
  var _a;
  const { portal, user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  if (!(portal === null || portal === void 0 ? void 0 : portal.id) || !user) {
    return;
  }
  const result = await getAppSwitcherConfigItem();
  const item = (_a = result === null || result === void 0 ? void 0 : result.results) === null || _a === void 0 ? void 0 : _a[0];
  if (!item) {
    return;
  }
  const itemId = item.id;
  const data = await getConfigData(itemId);
  return data;
}
async function getUserProperties() {
  const { user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}community/users/${user.username}/properties`;
  return request(url);
}
async function getApprovedApps() {
  const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}portals/${portal.id}/approvedApps`;
  return request(url, { returnAllApps: false });
}
async function fetchAllResources(url, content, resourceKey = "results") {
  const max = 100;
  let start = 1;
  let resources = [];
  let totalLeft;
  let numRequests;
  let promises;
  let i;
  content.start = start;
  if (!content.num) {
    content.num = max;
  }
  try {
    const result = await request(url, content);
    if (!(result === null || result === void 0 ? void 0 : result[resourceKey])) {
      return resources;
    }
    resources = [...resources, ...result[resourceKey]];
    // calculate whether further batches are needed
    start = result.nextStart;
    totalLeft = result.total - resources.length;
    numRequests = Math.ceil(totalLeft / max);
    promises = [];
    // request each necessary batch
    for (i = 0; i < numRequests; i++) {
      content.start = start + i * max;
      promises.push(request(url, content));
    }
    try {
      const results = await Promise.all(promises);
      results.forEach((r) => {
        resources = [...resources, ...r[resourceKey]];
      });
      return resources;
    }
    catch (_a) {
      return resources;
    }
  }
  catch (_b) {
    return resources;
  }
}
async function getMarketPlaceProvisionedListings() {
  const { user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}community/users/${user.username}/provisionedListings`;
  return fetchAllResources(url, { returnAppClientIds: true, returnAllProvisions: true }, "provisionedListings");
}
async function getOrgCapabilities() {
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}portals/self/subscriptionInfo`;
  try {
    const response = await request(url);
    return (response === null || response === void 0 ? void 0 : response.orgCapabilities) || [];
  }
  catch (_a) {
    return [];
  }
}
async function queryAppItemsForChanges(approvedApps, runQuery) {
  if (!runQuery || !(approvedApps === null || approvedApps === void 0 ? void 0 : approvedApps.length)) {
    return;
  }
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}search`;
  return request(url, {
    num: 100,
    q: `id:(${approvedApps.map((a) => `"${a.itemId}"`).join(" OR ")})`
  });
}
const blockedAppsConfigItemQuery = `owner:"esri" AND title:"BlockedApps Config" AND type: "Application Configuration"`;
async function getBlockableApps() {
  var _a, _b;
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}search`;
  try {
    const response = await request(url, {
      num: 10,
      start: 0,
      sortField: "title",
      sortOrder: "asc",
      q: blockedAppsConfigItemQuery
    });
    if (!response) {
      return [];
    }
    const itemId = ((_b = (_a = response.results) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.id) || "";
    const data = await getConfigData(itemId);
    return (data === null || data === void 0 ? void 0 : data.blockedApps) || [];
  }
  catch (_c) {
    return [];
  }
}
async function getServers() {
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}portals/self/servers`;
  const response = await request(url);
  return (response === null || response === void 0 ? void 0 : response.servers) || [];
}
async function getSigninSettings() {
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)()}portals/self/signinSettings`;
  const response = await request(url);
  return response;
}
function getUrl(path) {
  let portalUrl = (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.g)();
  if (portalUrl.slice(-1) !== "/") {
    portalUrl += "/";
  }
  return `${portalUrl}${path}`;
}
async function request(url, params) {
  if (!params) {
    params = {};
  }
  params.f = "json";
  const token = (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.h)();
  if (token) {
    params.token = token;
  }
  const urlObj = new URL(url);
  Object.keys(params).forEach((key) => urlObj.searchParams.append(key, params[key]));
  const response = await fetch(urlObj);
  const responseData = await response.json();
  return responseData;
}
async function postRequest(url, data) {
  data.append("f", "json");
  const token = (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_0__.h)();
  if (token) {
    data.append("token", token);
  }
  fetch(url, { method: "POST", body: data });
}
async function updateUserProperties(properties) {
  const { user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_1__.c;
  const url = getUrl(`community/users/${user.username}/setProperties`);
  const data = new FormData();
  data.append("properties", JSON.stringify(properties));
  return postRequest(url, data);
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-app-switcher_2.entry.js":
/*!************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-app-switcher_2.entry.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_app_switcher: () => (/* binding */ ArcgisAppSwitcher),
/* harmony export */   arcgis_app_switcher_link: () => (/* binding */ ArcgisAppLink)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/* harmony import */ var _api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api-f7934cd7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/api-f7934cd7.js");
/* harmony import */ var _portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./portal-79caaeff.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js");
/* harmony import */ var _storage_d7f5822e_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage-d7f5822e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-d7f5822e.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./privileges-ccd5f37d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */













/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var version = "1.15.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();

          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }

          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

function cookieForQueryingItemsExists() {
  const cookie = (0,_storage_d7f5822e_js__WEBPACK_IMPORTED_MODULE_5__.a)("APSW-query", true);
  if ((cookie === null || cookie === void 0 ? void 0 : cookie.expires) > new Date().setHours(new Date().getHours())) {
    return true;
  }
  // Query for approved app items every 5 hours
  const payload = { expires: new Date().setHours(new Date().getHours() + 5) };
  (0,_storage_d7f5822e_js__WEBPACK_IMPORTED_MODULE_5__.b)("APSW-query", payload, {
    path: "/",
    domain: document.domain,
    sameSite: "Strict"
  }, true);
  return false;
}

const licenses = {};
function hasLicense(clientId) {
  var _a;
  return ((_a = licenses[clientId.toLowerCase()]) === null || _a === void 0 ? void 0 : _a.valid) || false;
}
function isInPortalConfig(title, portal, showInAppLauncher) {
  return !portal.isPortal || showInAppLauncher.indexOf(title) > -1;
}
function hasAccessToOpenData(portal) {
  if ((portal === null || portal === void 0 ? void 0 : portal.portalProperties) && (!portal.portalProperties.openData || !portal.portalProperties.openData.enabled)) {
    return false;
  }
  return hasLicense("HubforArcGIS");
}
function hasAccessToVelocity(user) {
  const requiresOneOf = [
    "portal:publisher:publishFeeds",
    "portal:publisher:publishRealTimeAnalytics",
    "portal:publisher:publishBigDataAnalytics"
  ];
  const privileges = (user === null || user === void 0 ? void 0 : user.privileges) || [];
  const hasPrivilege = privileges.some((privilege) => requiresOneOf.indexOf(privilege) > -1);
  const hasCapability = hasLicense("velocity");
  return hasPrivilege && hasCapability;
}
function hasAccessToSites(portal, title, showInAppLauncher) {
  return isInPortalConfig(title, portal, showInAppLauncher) && hasLicense("HubforArcGIS");
}
function hasAccessToMapViewer(portal, newMapViewerEnabled) {
  var _a;
  const disabledInApp = portal.isPortal && ((_a = portal.portalProperties) === null || _a === void 0 ? void 0 : _a.newMapViewerEnabled) === false;
  return newMapViewerEnabled && !disabledInApp && hasLicense("arcgisWebApps");
}
function hasAccessToOrthoMaker(portal, showInAppLauncher) {
  var _a;
  return (!!((_a = portal.helperServices) === null || _a === void 0 ? void 0 : _a.rasterAnalytics) &&
    !!portal.helperServices.orthoMapping &&
    isInPortalConfig("Ortho Maker", portal, showInAppLauncher));
}
function hasAccessToNotebooks(title, portal, user, showInAppLauncher, notebookServerEnabled) {
  var _a;
  const notebookServerConfigured = notebookServerEnabled && (!portal.isPortal || portal.supportsHostedNotebooks);
  const canCreateNotebooks = !!((_a = user === null || user === void 0 ? void 0 : user.privileges) === null || _a === void 0 ? void 0 : _a.length) &&
    user.privileges.some((privilege) => privilege === "premium:publisher:createNotebooks");
  return notebookServerConfigured && canCreateNotebooks && isInPortalConfig(title, portal, showInAppLauncher);
}
function hasAccessToTrackViewer(portal, showInAppLauncher, trackViewerEnabled) {
  var _a;
  return (!!((_a = portal.helperServices) === null || _a === void 0 ? void 0 : _a.locationTracking) &&
    trackViewerEnabled &&
    isInPortalConfig("Track Viewer", portal, showInAppLauncher));
}

const arcgisAppSwitcherCss = ".apps-content-container{position:relative}.toggle-button{display:block;cursor:pointer;padding:0;margin:0;overflow:visible;border-width:0;-webkit-appearance:button;background-color:transparent;height:3.5rem;width:3.5rem}.toggle-button:not(.toggle-button--expanded):hover{box-shadow:inset 0 -3px 0 0 rgba(0, 121, 193, 0.5)}.toggle-button--expanded{box-shadow:inset 0 -3px 0 0 var(--calcite-ui-brand)}.toggle-button__icon{display:block;width:1.5rem;height:1.5rem}:host{position:relative;color:var(--calcite-ui-text-2)}.apps-content{display:none;position:absolute;right:0}.apps-content--rtl{left:0;right:auto}.apps-content--expanded{display:block}.apps-content ::-webkit-scrollbar{width:0.5rem}.apps-content ::-webkit-scrollbar-thumb{border-radius:var(--calcite-border-radius);background-color:rgba(0, 0, 0, 0.5);box-shadow:0 0 1px rgba(255, 255, 255, 0.5)}.dropdown-menu{overflow-x:hidden;overflow-y:auto;top:0;cursor:default;background-color:var(--calcite-ui-background);border-top:1px solid var(--calcite-ui-border-1);max-height:85vh;max-width:480px;min-width:475px}.intro-container{text-align:center;background-color:var(--calcite-ui-background)}.intro-text{font-size:0.875rem;margin:0;background-color:var(--calcite-ui-background);color:var(--calcite-ui-text-3);padding-top:1rem;padding-bottom:0.75rem;padding-left:4rem;padding-right:4rem}.apps-list{flex-direction:row;flex-wrap:wrap;list-style-type:none;overflow:hidden;text-align:left;padding-top:0.5rem;padding-bottom:0.5rem;padding-left:0.5rem;padding-right:0.5rem;margin-top:0;margin-bottom:0;background-color:var(--calcite-ui-background)}.apps-list .secondary-drag-text{display:none}.app-item{cursor:pointer;margin:0;box-sizing:border-box;display:inline-block;float:none;position:relative;text-align:left;vertical-align:top;word-wrap:break-word;overflow-wrap:break-word;font-size:0.875rem;height:110px;width:150px}@-moz-document url-prefix(){.app-item{width:146px}}.apps-content:not(.apps-content--dragging) .app-item:not(.app-item--missing):hover{color:var(--calcite-ui-text-1);outline:1px solid var(--calcite-ui-brand)}.app-item--dragging{outline-offset:-1px}.app-item--missing{padding-top:0.5rem}.show-more{display:flex;align-items:center;justify-content:center;width:100%;border-style:none;cursor:pointer;padding:0.25rem;background-color:var(--calcite-ui-foreground-3);color:var(--calcite-ui-text-3);font-size:0.875rem}.secondary-container{background-color:var(--calcite-ui-foreground-2);padding-top:0.25rem;padding-bottom:0.25rem;border-top:1px solid var(--calcite-ui-border-3)}.secondary-container--hidden{display:none}.secondary-target{text-align:center;overflow:hidden;margin-top:0.75rem;margin-bottom:0.75rem;margin-left:1.5rem;margin-right:1.5rem;font-size:0.875rem;padding-left:2rem;padding-right:2rem;border:2px dashed var(--calcite-ui-border-2);letter-spacing:normal;height:100px}.secondary-target--hover{border-color:var(--calcite-ui-brand)}.secondary-list{text-align:left;margin:0;padding-top:0.75rem;padding-bottom:0.75rem;padding-left:0.5rem;padding-right:0.5rem}";

const ArcgisAppSwitcher = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisAppSwitcherToggle = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisAppSwitcherToggle", 7);
    this.willQueryForItems = true;
    this.blockedApps = [];
    this.showInAppLauncher = [];
    this.servers = [];
    this.orgCapabilities = [];
    this.updateAppsProperties = async () => {
      const primaryIds = this.getIdsFromDOM(this.primaryContainer);
      const primaryApps = this.getAppsByIds(primaryIds);
      const primary = this.convertToAppData(primaryApps);
      const secondaryIds = this.getIdsFromDOM(this.secondaryContainer);
      const secondaryApps = this.getAppsByIds(secondaryIds);
      const secondary = this.convertToAppData(secondaryApps);
      const updatedProperties = Object.assign({}, this.userProperties);
      updatedProperties.appLauncher = { primary, secondary };
      await (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.u)(updatedProperties);
      this.userProperties = updatedProperties;
      const previousSecondaryCount = this.secondaryApps.length;
      this.primaryApps = primaryApps;
      this.secondaryApps = secondaryApps;
      if (previousSecondaryCount > 0 && !this.secondaryApps.length) {
        // if all apps are removed from secondary, show the drag box and text
        this.hoveringOverSecondary = false;
      }
    };
    this.handleToggle = () => {
      this.isExpanded = !this.isExpanded;
      this.arcgisAppSwitcherToggle.emit(this.isExpanded);
    };
    this.handleShowMore = () => {
      this.secondaryExpanded = true;
    };
    this.handleDismissIntro = () => {
      this.updateAppsProperties();
      this.displayIntro = false;
    };
    this.keydownHandler = (event) => {
      var _a;
      if (event.key === "Escape" && this.isExpanded) {
        this.handleToggle();
        (_a = this.toggleButton) === null || _a === void 0 ? void 0 : _a.focus();
      }
    };
    this.api = undefined;
    this.portal = undefined;
    this.user = undefined;
    this.newMapViewerEnabled = true;
    this.notebookServerEnabled = true;
    this.trackViewerEnabled = true;
    this.shouldExpand = false;
    this.displayIntro = false;
    this.primaryApps = [];
    this.secondaryApps = [];
    this.isExpanded = false;
    this.hoveringOverSecondary = false;
    this.secondaryExpanded = false;
    this.sorting = false;
    this.focusItemId = undefined;
    this.dragging = false;
  }
  handleLinkClick() {
    this.isExpanded = false;
    this.arcgisAppSwitcherToggle.emit(this.isExpanded);
  }
  handleLinkActivated() {
    this.secondaryExpanded = true;
  }
  async handleLinkMove(evt) {
    const { uid, keyCode, index } = evt.detail;
    this.focusItemId = uid;
    const primaryTotal = this.primaryApps.length;
    const secondaryTotal = this.secondaryApps.length;
    const isInPrimary = index < primaryTotal;
    let targetPrimary;
    if (isInPrimary) {
      const rowCount = Math.ceil(primaryTotal / 3);
      const lastRowFirstIndex = rowCount * 3 - 3;
      if (index < lastRowFirstIndex) {
        targetPrimary = true;
      }
      else if (keyCode === "ArrowLeft" || keyCode === "ArrowUp") {
        targetPrimary = true;
      }
      else if (keyCode === "ArrowRight" && index < primaryTotal - 1) {
        targetPrimary = true;
      }
      else {
        targetPrimary = false;
      }
    }
    else {
      if (index >= primaryTotal + 3) {
        targetPrimary = false;
      }
      else if (keyCode === "ArrowRight" || keyCode === "ArrowDown") {
        targetPrimary = false;
      }
      else if (keyCode === "ArrowLeft" && index > primaryTotal) {
        targetPrimary = false;
      }
      else {
        targetPrimary = true;
      }
    }
    let targetIndex = -1;
    const sameList = (isInPrimary && targetPrimary) || (!isInPrimary && !targetPrimary);
    if (sameList) {
      if (keyCode === "ArrowUp") {
        targetIndex = index - 3;
      }
      else if (keyCode === "ArrowRight") {
        targetIndex = index + 1;
      }
      else if (keyCode === "ArrowDown") {
        targetIndex = index + 3;
      }
      else if (keyCode === "ArrowLeft") {
        targetIndex = index - 1;
      }
    }
    else {
      if (isInPrimary) {
        if (keyCode === "ArrowRight") {
          targetIndex = primaryTotal;
        }
        else if (keyCode === "ArrowDown") {
          targetIndex = (index % 3) + primaryTotal;
        }
      }
      else {
        targetIndex = primaryTotal;
      }
    }
    let app;
    if (isInPrimary) {
      app = this.primaryApps.splice(index, 1)[0];
    }
    else {
      app = this.secondaryApps.splice(index - primaryTotal, 1)[0];
    }
    if (targetPrimary) {
      this.primaryApps.splice(targetIndex, 0, app);
    }
    else {
      const secondaryIndex = targetIndex - primaryTotal;
      this.secondaryApps.splice(secondaryIndex, 0, app);
    }
    const primary = this.convertToAppData(this.primaryApps);
    const secondary = this.convertToAppData(this.secondaryApps);
    const updatedProperties = Object.assign({}, this.userProperties);
    updatedProperties.appLauncher = { primary, secondary };
    await (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.u)(updatedProperties);
    this.userProperties = updatedProperties;
    if (secondaryTotal > 0 && !this.secondaryApps.length) {
      this.hoveringOverSecondary = false;
    }
    window.setTimeout(() => {
      // reset after setting focus
      this.focusItemId = "";
    }, 100);
  }
  async handleLinkRemove(evt) {
    const id = evt.detail;
    const updatedProperties = Object.assign({}, this.userProperties);
    let { primary, secondary } = updatedProperties.appLauncher;
    primary = primary.filter((app) => app.uid !== id);
    secondary = secondary.filter((app) => app.uid !== id);
    updatedProperties.appLauncher = { primary, secondary };
    await (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.u)(updatedProperties);
    this.userProperties = updatedProperties;
    this.primaryApps = this.primaryApps.filter((app) => {
      const appId = app.itemId || app.title;
      return appId !== id;
    });
    this.secondaryApps = this.secondaryApps.filter((app) => {
      const appId = app.itemId || app.title;
      return appId !== id;
    });
  }
  handleShouldExpandChange(newValue) {
    this.isExpanded = newValue;
  }
  componentDidLoad() {
    const mobileDevices = [/Android/i, /webOS/i, /iPhone/i, /iPad/i];
    const isMobile = mobileDevices.some((device) => navigator.userAgent.match(device));
    if (isMobile) {
      // currently sortableJS inside Shadow DOM is not working correctly on mobile, so avoiding this
      // this should also allow scrolling the apps list on mobile
      return;
    }
    Sortable.create(this.primaryContainer, {
      animation: 150,
      group: "apps",
      filter: ".secondary-drag-text",
      dragClass: "app-item--dragging",
      onUpdate: this.updateAppsProperties,
      onAdd: this.updateAppsProperties,
      onMove: (params) => {
        this.hoveringOverSecondary = params.to.className === "secondary-target";
      },
      onStart: () => {
        this.dragging = true;
      },
      onEnd: () => {
        this.dragging = false;
      }
    });
    Sortable.create(this.secondaryContainer, {
      animation: 150,
      group: "apps",
      filter: ".secondary-drag-text",
      dragClass: "app-item--dragging",
      onUpdate: this.updateAppsProperties,
      onAdd: this.updateAppsProperties
    });
  }
  componentDidRender() {
    if (this.primaryContainer.contains(this.secondaryDragText)) {
      this.secondaryContainer.appendChild(this.secondaryDragText);
    }
  }
  async componentWillLoad() {
    var _a, _b;
    const locale = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el);
    this.strings = locale[0];
    this.willQueryForItems = cookieForQueryingItemsExists();
    this.initializeConfig();
    if (!((_a = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.portal) === null || _a === void 0 ? void 0 : _a.id) || !_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.user) {
      return;
    }
    if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.portal.isPortal) {
      this.showInAppLauncher = await (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.g)();
    }
    const [config, marketplace, preferences, customOrgApps, orgCapabilities] = await Promise.all([
      (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.a)(),
      (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.b)(),
      (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.c)(),
      (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.d)(),
      (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.e)()
    ]);
    this.orgCapabilities = orgCapabilities;
    this.userProperties = (preferences === null || preferences === void 0 ? void 0 : preferences.properties) || {};
    this.userApps = config === null || config === void 0 ? void 0 : config.appSwitcher;
    if (!_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.portal.isPortal) {
      this.userApps.apps.unshift(this.getAgoApp());
    }
    this.approvedApps =
      ((_b = customOrgApps.approvedApps) === null || _b === void 0 ? void 0 : _b.filter((app) => !app.hideForNonPrivilegedMember)) || [];
    if (!this.userProperties.appLauncher) {
      this.willQueryForItems = false;
      this.displayIntro = true;
    }
    this.provisionedListings = marketplace || [];
    this.provisionedListings.forEach((listing) => {
      var _a;
      const clientId = (_a = listing.clientId) === null || _a === void 0 ? void 0 : _a.toLowerCase();
      if (clientId) {
        licenses[clientId] = {
          valid: true,
          itemId: listing.itemId,
          clientId: listing.clientId
        };
      }
    });
    orgCapabilities === null || orgCapabilities === void 0 ? void 0 : orgCapabilities.forEach((capability) => {
      var _a;
      const capabilityId = (_a = capability.id) === null || _a === void 0 ? void 0 : _a.toLowerCase();
      if (capabilityId) {
        licenses[capabilityId] = {
          valid: true,
          clientId: capability.id
        };
      }
    });
    await this.init();
    this.primaryApps.forEach((app) => {
      app.fontSize = this.calcFontSize(app);
    });
  }
  convertToAppData(apps) {
    return apps.map((app) => ({ label: app.label, uid: app.itemId || app.title }));
  }
  getAppsByIds(ids) {
    const apps = [...this.primaryApps, ...this.secondaryApps];
    return ids.map((id) => apps.find((app) => app.itemId === id || app.title === id));
  }
  getIdsFromDOM(container) {
    const ids = [];
    container.querySelectorAll(".app-item").forEach((el) => {
      ids.push(el.dataset.id);
    });
    return ids;
  }
  getTextWidth(text) {
    const canvas = document.createElement("canvas"), context = canvas.getContext("2d");
    context.font = "avenir";
    const metrics = context.measureText(text);
    return metrics.width;
  }
  calcFontSize(app) {
    if (!app.abbr) {
      return;
    }
    const abbreviationSizes = [0, 32, 24, 20, 18, 16, 14, 12, 10, 8, 6];
    let strWidth = Math.ceil(this.getTextWidth(app.abbr) / 5);
    if (strWidth > abbreviationSizes.length - 1) {
      strWidth = abbreviationSizes.length - 1;
    }
    return `${abbreviationSizes[strWidth]}px`;
  }
  async getBlockedApps() {
    const [signinSettings, blockableApps] = await Promise.all([
      (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.f)(),
      (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.h)()
    ]);
    const clientIds = (signinSettings === null || signinSettings === void 0 ? void 0 : signinSettings.blockedApps) || [];
    if ((!clientIds.length && !signinSettings.blockBetaApps) || !(blockableApps === null || blockableApps === void 0 ? void 0 : blockableApps.length)) {
      return [];
    }
    if (signinSettings.blockBetaApps) {
      blockableApps.forEach((app) => {
        if (app.isBeta && !clientIds.includes(app.clientid)) {
          clientIds.push(app.clientid);
        }
      });
    }
    clientIds.forEach((id) => {
      const match = blockableApps.find((app) => app.clientid === id);
      if (match) {
        this.blockedApps.push(match);
      }
    });
    return this.blockedApps;
  }
  filterBlockedApps(apps) {
    return apps.filter((app) => {
      var _a;
      const inBlockedList = (_a = this.blockedApps) === null || _a === void 0 ? void 0 : _a.some((ba) => {
        return (app.itemId && app.itemId === ba.itemid) || (app.title && app.title === ba.title);
      });
      return !inBlockedList;
    });
  }
  populateAppIdentifiers(prev, app) {
    const list = Object.keys(this.appDictionary).map((key) => this.appDictionary[key]);
    let populatedApp = list.filter((a) => a.itemId === app.uid || a.title === app.uid).shift();
    if (populatedApp && !this.appDictionary[app.uid]) {
      app.uid = populatedApp.itemId || populatedApp.title;
    }
    if (populatedApp === null || populatedApp === void 0 ? void 0 : populatedApp.hasBeenPopulated) {
      return prev;
    }
    if (!populatedApp) {
      // App Can't be Found
      populatedApp = app;
      populatedApp.canAccess = false;
      populatedApp.itemId = app.uid;
      this.appDictionary[app.uid] = populatedApp;
    }
    else {
      // -- Insert into Dictionary --
      if ((app.hasChanged ||
        populatedApp.hasChanged ||
        (!populatedApp.canAccess && !populatedApp.ignoreNoAccess)) &&
        this.isAdmin()) {
        this.appDictionary[app.uid].hasChanged = true;
        this.appDictionary[app.uid].ignoreNoAccess = app.ignoreNoAccess;
      }
      if (app.isNew) {
        this.appDictionary[app.uid].isNew = true;
      }
      delete this.newAppDictionary[app.uid];
    }
    // -- Prevent duplicates from any possible error states
    this.appDictionary[app.uid].hasBeenPopulated = true;
    prev.push(populatedApp);
    return prev;
  }
  isInPortalConfig(title) {
    const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    return isInPortalConfig(title, portal, this.showInAppLauncher);
  }
  getAppExceptions() {
    const { portal, user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    return {
      "Open Data": {
        hasAccess: () => hasAccessToOpenData(portal)
      },
      AppStudio: {
        hasAccess: () => hasLicense("arcgisWebApps")
      },
      "ArcGIS Velocity": {
        hasAccess: () => hasAccessToVelocity(user)
      },
      "ArcGIS Hub": {
        hasAccess: () => hasLicense("HubforArcGIS")
      },
      "ArcGIS Enterprise Sites": {
        hasAccess: (title) => hasAccessToSites(portal, title, this.showInAppLauncher)
      },
      "ArcGIS Experience Builder": {
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "ArcGIS StoryMaps": {
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "ArcGIS QuickCapture Web Designer": {
        hasAccess: (title) => this.isInPortalConfig(title) && hasLicense("arcgisWebApps")
      },
      "ArcGIS Collector": {
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "ArcGIS Field Maps": {
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "ArcGIS Dashboards": {
        hasAccess: (title) => this.isInPortalConfig(title) && hasLicense("dashboards")
      },
      "ArcGIS Solutions": {
        // For Portal
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "ArcGIS Workforce": {
        // For Portal
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "Deep Learning Studio": {
        // For Portal
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "Map Viewer": {
        hasAccess: () => hasAccessToMapViewer(portal, this.newMapViewerEnabled) &&
          this.isInPortalConfig("ArcGIS Map Viewer")
      },
      "Map Viewer Classic": {
        hasAccess: () => hasLicense("arcgisWebApps") && this.isInPortalConfig("ArcGIS Map Viewer Classic")
      },
      "Operations Dashboard for ArcGIS": {
        hasAccess: () => hasLicense("opsdashboard") && this.isInPortalConfig("ArcGIS Dashboards Classic")
      },
      "ArcGIS Dashboards Classic": {
        hasAccess: (title) => hasLicense("opsdashboard") && this.isInPortalConfig(title)
      },
      "Ortho Maker": {
        hasAccess: () => hasAccessToOrthoMaker(portal, this.showInAppLauncher)
      },
      Notebook: {
        hasAccess: (title) => hasAccessToNotebooks(title, portal, user, this.showInAppLauncher, this.notebookServerEnabled)
      },
      "Scene Viewer": {
        hasAccess: (title) => hasLicense("arcgisWebApps") && this.isInPortalConfig(title)
      },
      "Story Maps": {
        hasAccess: () => hasLicense("arcgisWebApps")
      },
      Survey123: {
        hasAccess: () => hasLicense("survey123")
      },
      "Track Viewer": {
        hasAccess: () => hasAccessToTrackViewer(portal, this.showInAppLauncher, this.trackViewerEnabled)
      },
      "Instant Apps": {
        // For Portal
        hasAccess: (title) => hasLicense("arcgisWebApps") && this.isInPortalConfig(title)
      },
      "Vector Tile Style Editor": {
        // For Portal
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "ArcGIS GeoBIM": {
        // For Portal
        hasAccess: (title) => this.isInPortalConfig(title)
      },
      "ArcGIS Maps for Adobe Creative Cloud": {
        hasAccess: () => {
          return hasLicense("arcgisWebApps") && !_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.portal.isPortal;
        }
      }
    };
  }
  getExcludedProvisionedListings() {
    let excluded = {
      opsdashboard: 1,
      arcgisWebApps: 1,
      Workforce: 1,
      geoplanner: 1,
      webappbuilder: 1,
      HubforArcGIS: 1,
      appstudio: 1,
      survey123: 1,
      storymaps: 1,
      mapsForOffice: 1,
      mapsForO365: 1,
      mapsForSharePoint: 1,
      mapsForCreativeCloud: 1
    };
    const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    if (portal.isPortal) {
      // exclude certain provisioned listings for Enterprise
      excluded = Object.assign(Object.assign({}, excluded), { arcgisonline: 1, arcgisUrban: 1, arcgisinstantapps: 1 });
    }
    return excluded;
  }
  getImagePath(app) {
    return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/${(app === null || app === void 0 ? void 0 : app.image) ? app.image : ""}`);
  }
  modifyWebAppForView(app) {
    var _a, _b;
    const img = ((_a = app.appSwitcher) === null || _a === void 0 ? void 0 : _a.image) || app.icon;
    if (img) {
      app.image = this.getWebMappingAppImgPath(app);
    }
    else {
      app.placeHolderIcon = `${this.getImagePath()}svg-app-circle.svg`;
    }
    app.abbr = ((_b = app.appSwitcher) === null || _b === void 0 ? void 0 : _b.abbr) || app.abbreviation;
    delete app.abbreviation;
    delete app.appSwitcher;
    delete app.approvedApp;
    delete app.webMappingApp;
    return app;
  }
  modifySystemAppForView(app, uniqueId) {
    var _a;
    const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    if (app.image) {
      app.image = this.getImagePath(app);
    }
    else {
      app.placeHolderIcon = `${this.getImagePath()}svg-app-icon.svg`;
    }
    // relative urls must be pointed at the org url (#25494)
    if (((_a = app.url) === null || _a === void 0 ? void 0 : _a.indexOf("../")) === 0) {
      const baseUrl = portal.urlKey
        ? `${portal.urlKey}.${portal.customBaseUrl}`
        : portal.portalHostname;
      app.url = `${location.protocol}//${baseUrl}${app.url.substring(2, app.url.length)}`;
    }
    delete app.isLicensed;
    delete app.privileges;
    app.itemId = uniqueId;
    return app;
  }
  getWebMappingAppImgPath(app) {
    const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    const token = (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_4__.h)(portal);
    if (!app.icon) {
      return `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_4__.g)()}content/items/${app.itemId}/resources/${app.appSwitcher.image}?token=${token}`;
    }
    return `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_4__.g)()}portals/self/resources/${app.icon}?token=${token}`;
  }
  modifyPartnerAppForView(app) {
    var _a, _b, _c;
    app.appSwitcher = (_a = app.properties) === null || _a === void 0 ? void 0 : _a.appSwitcher;
    const customIcon = ((_b = app.appSwitcher) === null || _b === void 0 ? void 0 : _b.image) || app.icon;
    return {
      abbr: ((_c = app.appSwitcher) === null || _c === void 0 ? void 0 : _c.abbr) || app.abbreviation,
      itemId: app.itemId,
      canAccess: true,
      webMappingApp: true,
      image: customIcon ? this.getWebMappingAppImgPath(app) : null,
      label: app.title || app.label,
      url: app.url,
      placeHolderIcon: app.placeHolderIcon || `${this.getImagePath()}svg-app-circle.svg`
    };
  }
  async getLicensedApps() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { portal, user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    const allAppUids = {};
    const appDictionary = {};
    const exceptions = this.getAppExceptions();
    const excludedProvisionedListings = this.getExcludedProvisionedListings();
    const legalApps = [];
    const appCount = this.userApps.apps.length;
    for (let i = 0; i < appCount; i++) {
      const app = this.userApps.apps[i];
      const uid = app.itemId || app.title;
      let isPrivileged = true;
      const inBlockedList = (_a = this.blockedApps) === null || _a === void 0 ? void 0 : _a.some((ba) => (app.itemId && app.itemId === ba.itemid) || (app.title && app.title === ba.title));
      allAppUids[uid] = 1;
      appDictionary[uid] = app;
      if (inBlockedList) {
        continue;
      }
      const portalDeploymentType = portal.portalDeploymentType || ((_b = portal.sourceJSON) === null || _b === void 0 ? void 0 : _b.portalDeploymentType);
      if (portalDeploymentType === "ArcGISEnterpriseOnKubernetes" &&
        app.supportsKubernetes === false) {
        continue;
      }
      if (exceptions[app.title] && !exceptions[app.title].hasAccess(app.title)) {
        continue;
      }
      const subscriptionInfo = portal.subscriptionInfo || ((_c = portal.sourceJSON) === null || _c === void 0 ? void 0 : _c.subscriptionInfo);
      if (app.subscriptionType) {
        if ((subscriptionInfo === null || subscriptionInfo === void 0 ? void 0 : subscriptionInfo.type) === app.subscriptionType) {
          appDictionary[uid].canAccess = true;
          legalApps.push(this.modifySystemAppForView(app, uid));
        }
        continue;
      }
      if (app.orgCapabilities) {
        if ((_d = this.orgCapabilities) === null || _d === void 0 ? void 0 : _d.length) {
          const hasCapability = this.orgCapabilities.some((capability) => app.orgCapabilities.includes(capability.id));
          if (hasCapability) {
            appDictionary[uid].canAccess = true;
            legalApps.push(this.modifySystemAppForView(app, uid));
          }
        }
        continue;
      }
      if (!((_e = app.privileges) === null || _e === void 0 ? void 0 : _e.length) && !app.isLicensed && !app.serverFunction) {
        appDictionary[uid].canAccess = true;
        legalApps.push(this.modifySystemAppForView(app, uid));
        continue;
      }
      const skipPrivCheck = ((_f = user === null || user === void 0 ? void 0 : user.userLicenseTypeId) === null || _f === void 0 ? void 0 : _f.toLowerCase()) === "storytellerut" &&
        ((_g = app.label) === null || _g === void 0 ? void 0 : _g.toLowerCase()) === "storymaps";
      if (skipPrivCheck) {
        appDictionary[uid].canAccess = true;
        legalApps.push(this.modifySystemAppForView(app, uid));
        continue;
      }
      if (((_h = app.privileges) === null || _h === void 0 ? void 0 : _h.length) > 0 && (user === null || user === void 0 ? void 0 : user.privileges)) {
        for (let j = 0; j < app.privileges.length; j++) {
          if (user.privileges.indexOf(app.privileges[j]) < 0) {
            isPrivileged = false;
            break;
          }
        }
        if (!app.isLicensed && isPrivileged) {
          appDictionary[uid].canAccess = true;
          legalApps.push(this.modifySystemAppForView(app, uid));
          continue;
        }
      }
      if (app.isLicensed && isPrivileged) {
        for (let k = 0; k < this.provisionedListings.length; k++) {
          if (uid === this.provisionedListings[k].itemId ||
            uid === this.provisionedListings[k].title) {
            appDictionary[uid].canAccess = true;
            legalApps.push(this.modifySystemAppForView(app, uid));
            break;
          }
        }
      }
      if (app.serverFunction && isPrivileged) {
        if (this.servers.some((server) => {
          var _a;
          const functions = ((_a = server.serverFunction) === null || _a === void 0 ? void 0 : _a.split(",")) || [];
          return functions.includes(app.serverFunction);
        })) {
          appDictionary[uid].canAccess = true;
          legalApps.push(this.modifySystemAppForView(app, uid));
          continue;
        }
      }
    }
    // - Web mapping apps from Markeplace
    this.provisionedListings.forEach((app) => {
      if (app.type === "Web Mapping Application" &&
        !excludedProvisionedListings[app.clientId] &&
        !allAppUids[app.itemId] &&
        app.url &&
        app.title &&
        !allAppUids[app.title] &&
        app.typeKeywords.indexOf("hideFromAppSwitcher") < 0) {
        const modifiedApp = this.modifyPartnerAppForView(app);
        appDictionary[app.itemId] = modifiedApp;
        legalApps.push(modifiedApp);
      }
    });
    const apps = [
      ...this.approvedApps.map((app) => {
        const appProperties = Object.assign(Object.assign({}, app.appProperties), { itemId: app.itemId, webMappingApp: true, approvedApp: true, canAccess: !this.willQueryForItems });
        appDictionary[app.itemId] = appProperties;
        return this.modifyWebAppForView(appProperties);
      }),
      ...legalApps
    ];
    return {
      apps,
      appDictionary
    };
  }
  isAdmin() {
    const { user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    if (!user) {
      return false;
    }
    return user.role === "org_admin" || user.role === "account_admin";
  }
  // Map the uid of existing user properties to match the new title
  mapAppTitles(apps) {
    const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    apps.forEach((app) => {
      if (app.uid === "Map Viewer Beta") {
        app.uid = "Map Viewer";
      }
      if (portal.isPortal) {
        if (app.uid === "Operations Dashboard for ArcGIS") {
          app.uid = "ArcGIS Dashboards Classic";
        }
        else if (app.uid === "Workforce for ArcGIS") {
          app.uid = "ArcGIS Workforce";
        }
      }
    });
  }
  async init() {
    var _a;
    if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.portal.isPortal) {
      this.servers = await (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.i)();
    }
    await this.getBlockedApps();
    const { apps, appDictionary } = await this.getLicensedApps();
    this.appDictionary = appDictionary;
    if (this.userProperties.appLauncher) {
      if (this.userProperties.appLauncher.primary) {
        this.mapAppTitles(this.userProperties.appLauncher.primary);
      }
      if (this.userProperties.appLauncher.secondary) {
        this.mapAppTitles(this.userProperties.appLauncher.secondary);
      }
    }
    if (!this.userProperties.appLauncher ||
      !this.userProperties.appLauncher.primary ||
      !this.userProperties.appLauncher.secondary) {
      this.primaryApps = apps.slice().sort((a, b) => (a.label < b.label ? -1 : 1));
      this.primaryApps = this.filterBlockedApps(this.primaryApps);
      this.secondaryApps = [];
      return;
    }
    else {
      const response = await (0,_api_f7934cd7_js__WEBPACK_IMPORTED_MODULE_3__.q)(this.approvedApps, this.willQueryForItems);
      if (((_a = response === null || response === void 0 ? void 0 : response.results) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        response.results.forEach((item) => {
          const app = this.appDictionary[item.id];
          app.canAccess = true;
          app.hasChanged = app.url !== item.url ? !!item.url : false;
        });
      }
      this.newAppDictionary = Object.assign({}, this.appDictionary);
      this.userProperties.appLauncher.primary.forEach((p) => {
        if (p.label === "Map Viewer") {
          p.uid = "Map Viewer";
        }
      });
      this.primaryApps =
        this.userProperties.appLauncher.primary.reduce(this.populateAppIdentifiers.bind(this), []) || [];
      this.secondaryApps =
        this.userProperties.appLauncher.secondary.reduce(this.populateAppIdentifiers.bind(this), []) || [];
      this.primaryApps = this.filterBlockedApps(this.primaryApps);
      this.secondaryApps = this.filterBlockedApps(this.secondaryApps);
      // :: Check for New App Icons ::
      for (const app in this.newAppDictionary) {
        if (this.newAppDictionary[app].canAccess) {
          this.newAppDictionary[app].isNew = true;
          this.appDictionary[app] = this.newAppDictionary[app];
          this.primaryApps.push(this.newAppDictionary[app]);
        }
      }
      return;
    }
  }
  getAgoApp() {
    const { portal, user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c;
    const baseUrl = `${location.protocol}//${portal.urlKey ? `${portal.urlKey}.${portal.customBaseUrl}` : portal.portalHostname}/home/`;
    const { landingPage } = this.userProperties;
    const url = `${baseUrl}${(landingPage === null || landingPage === void 0 ? void 0 : landingPage.url) ? landingPage.url : (user === null || user === void 0 ? void 0 : user.isOrgAdmin) ? "organization.html" : "index.html"}`;
    return {
      image: "arcgis-online.png",
      label: "ArcGIS Online",
      title: "ArcGIS Online",
      url
    };
  }
  initializeConfig() {
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.api = this.api;
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.user = this.user;
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_2__.c.portal = this.portal;
  }
  render() {
    const total = this.primaryApps.length + this.secondaryApps.length;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el) === "rtl";
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { onKeyDown: this.keydownHandler }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", kind: "neutral", class: { "toggle-button": true, "toggle-button--expanded": this.isExpanded }, "aria-label": this.strings.appLauncher, onClick: this.handleToggle, ref: (el) => (this.toggleButton = el), "aria-expanded": this.isExpanded }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { class: "toggle-button__icon", icon: "app-launcher", scale: "m" })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "apps-content-container" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
        "apps-content": true,
        "apps-content--rtl": rtl,
        "apps-content--expanded": this.isExpanded,
        "apps-content--dragging": this.dragging
      }, "aria-hidden": "false" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("nav", { class: "dropdown-menu dropdown-right", role: "menu" }, this.displayIntro && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "intro-container" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "drag-and-drop-intro intro-text" }, this.strings.dragDrop), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "outline-fill", kind: "neutral", onClick: this.handleDismissIntro }, this.strings.gotIt))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("ul", { class: "apps-list", ref: (el) => (this.primaryContainer = el) }, this.primaryApps.map((app, index) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("li", { "data-id": app.itemId || app.title, key: app.itemId, class: { "app-item": true, "app-item--missing": !app.canAccess } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-app-switcher-link", { app: app, index: index, total: total, focusItemId: this.focusItemId, openText: this.strings.openWindow }))))), !this.secondaryExpanded && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("button", { class: "show-more", onClick: this.handleShowMore }, this.strings.showMore, " ", (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: "chevron-down", scale: "s" }))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
        "secondary-container": true,
        "secondary-container--hidden": !this.secondaryExpanded
      }, "aria-expanded": "true" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("ul", { class: {
        "secondary-target": this.secondaryApps.length === 0,
        "secondary-list": this.secondaryApps.length !== 0,
        "secondary-target--hover": this.hoveringOverSecondary && this.secondaryApps.length === 0
      }, ref: (el) => (this.secondaryContainer = el) }, this.secondaryApps.length === 0 && !this.hoveringOverSecondary && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "secondary-drag-text", ref: (el) => (this.secondaryDragText = el) }, this.strings.dragSecondary)), this.secondaryApps.map((app, index) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("li", { "data-id": app.itemId, key: app.itemId, class: { "app-item": true, "app-item--missing": !app.canAccess } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-app-switcher-link", { app: app, index: this.primaryApps.length + index, total: total, focusItemId: this.focusItemId, openText: this.strings.openWindow })))))))))));
  }
  static get assetsDirs() { return ["assets"]; }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "shouldExpand": ["handleShouldExpandChange"]
  }; }
};
ArcgisAppSwitcher.style = arcgisAppSwitcherCss;

const AppSwitcherLinkArrows = ({ index, total, active }) => {
  const isFirst = index === 0;
  const isFirstRow = index <= 2;
  const isLast = index === total - 1;
  const rowCount = Math.ceil(total / 3);
  const lastRowFirstIndex = rowCount * 3 - 3;
  const isLastRow = index >= lastRowFirstIndex;
  return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: { "arrow--hidden": !active } },
    !isFirst && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "arrow arrow--left" }),
    !isLast && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "arrow arrow--right" }),
    !isFirstRow && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "arrow arrow--top" }),
    !isLastRow && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "arrow arrow--bottom" })));
};

const arcgisAppSwitcherLinkCss = ":host{display:block;height:93%}.app-link{display:block;padding-left:0.5rem;padding-right:0.5rem;padding-top:0.5rem;position:relative;height:100%;-webkit-user-select:text;-moz-user-select:text;user-select:text;text-decoration:none;color:inherit}.app-link:focus{outline:1px solid var(--calcite-ui-brand)}.arrow{position:absolute;height:0;width:0}.arrow--hidden{visibility:hidden}.arrow--left{border-right:5px solid var(--calcite-ui-brand);border-bottom:5px solid transparent;border-top:5px solid transparent;left:38px;top:27px}.arrow--right{border-left:5px solid var(--calcite-ui-brand);border-bottom:5px solid transparent;border-top:5px solid transparent;right:38px;top:27px}.arrow--top{border-bottom:5px solid var(--calcite-ui-brand);border-left:5px solid transparent;border-right:5px solid transparent;top:0;right:70px}.arrow--bottom{border-top:5px solid var(--calcite-ui-brand);border-left:5px solid transparent;border-right:5px solid transparent;top:59px;right:70px}.missing-icon .arrow--top{top:-4px}.icon-wrapper{display:block;text-align:center;background-repeat:no-repeat;background-size:contain;margin-top:0;margin-bottom:0;margin-left:auto;margin-right:auto;font-size:1.125rem;width:3rem;height:3rem;margin-bottom:0.5rem;color:var(--calcite-ui-text-2)}.icon-abbr{position:absolute;font-size:1.25rem;font-weight:700;width:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--calcite-ui-foreground-1);line-height:3rem;text-shadow:0 1px 8px var(--calcite-ui-text-3);transform:translateZ(0)}.icon-img{pointer-events:none;width:3rem;height:3rem}.indicator{position:absolute;box-sizing:border-box;clear:both;width:1rem;height:1rem;border-radius:50%;border:2px solid var(--calcite-ui-foreground-1);z-index:50}.indicator--new{background-color:var(--calcite-ui-success);top:4px;right:46px}.indicator--new-rtl{right:auto;left:46px}.indicator--remove{display:flex;align-items:center;justify-content:center;cursor:pointer;background-color:var(--calcite-ui-foreground-1);line-height:2px;padding:1px;right:42px;top:2px}.indicator--remove-rtl{right:auto;left:42px}.indicator--remove:hover,.indicator--remove:focus{outline:2px solid transparent;outline-offset:2px;border-color:var(--calcite-ui-danger);color:var(--calcite-ui-danger)}.missing-icon{text-align:center;cursor:pointer;display:block;margin-top:0;margin-bottom:0;margin-left:auto;margin-right:auto;background-color:var(--calcite-ui-foreground-3);height:3rem;width:3rem;margin-bottom:0.5rem;box-sizing:border-box;border:1px dashed var(--calcite-ui-inverse);border-radius:6px;outline-color:var(--calcite-ui-brand)}.label-text{margin-top:0;margin-bottom:0;margin-left:auto;margin-right:auto;text-align:center;display:block;line-height:17px;width:128px}.screen-readers{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}";

const ArcgisAppLink = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisAppSwitcherLinkActivated = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisAppSwitcherLinkActivated", 7);
    this.arcgisAppSwitcherLinkMove = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisAppSwitcherLinkMove", 7);
    this.arcgisAppSwitcherLinkRemove = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisAppSwitcherLinkRemove", 7);
    this.arcgisAppSwitcherLinkClick = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisAppSwitcherLinkClick", 7);
    this.isFirstRow = false;
    this.isLastRow = false;
    this.moveElement = (keyCode) => {
      this.arcgisAppSwitcherLinkMove.emit({
        uid: this.app.itemId || this.app.title,
        index: this.index,
        keyCode
      });
    };
    this.handleKey = (evt) => {
      let keyMatch = true;
      switch (evt.code) {
        case "Space":
          this.sortingActive = !this.sortingActive;
          this.arcgisAppSwitcherLinkActivated.emit();
          break;
        case "ArrowUp":
        case "ArrowRight":
        case "ArrowDown":
        case "ArrowLeft":
          if (this.sortingActive) {
            this.moveElement(evt.code);
          }
          break;
        default:
          keyMatch = false;
          break;
      }
      if (keyMatch) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    };
    this.handleBlur = () => {
      this.sortingActive = false;
    };
    this.handleRemove = () => {
      this.arcgisAppSwitcherLinkRemove.emit(this.app.itemId || this.app.title);
    };
    this.handleRemoveKeydown = (evt) => {
      switch (evt.code) {
        case "Space":
        case "Enter":
          this.handleRemove();
          evt.preventDefault();
          break;
      }
    };
    this.handleClick = () => {
      this.arcgisAppSwitcherLinkClick.emit();
    };
    this.app = undefined;
    this.index = undefined;
    this.total = undefined;
    this.focusItemId = undefined;
    this.openText = undefined;
    this.sortingActive = false;
  }
  componentDidRender() {
    var _a, _b;
    if (this.focusItemId &&
      (this.focusItemId === this.app.itemId || this.focusItemId === this.app.title)) {
      this.sortingActive = true;
      if (this.app.canAccess) {
        (_a = this.linkElement) === null || _a === void 0 ? void 0 : _a.focus();
      }
      else if (!this.app.canAccess) {
        (_b = this.missingElement) === null || _b === void 0 ? void 0 : _b.focus();
      }
    }
  }
  render() {
    var _a;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.el) === "rtl";
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, ((_a = this.app) === null || _a === void 0 ? void 0 : _a.canAccess) && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("a", { ref: (el) => (this.linkElement = el), href: this.app.url, class: "app-link", onKeyDown: this.handleKey, onBlur: this.handleBlur, onClick: this.handleClick, draggable: false, target: "_blank", role: "menuitem" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "icon-wrapper" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(AppSwitcherLinkArrows, { active: this.sortingActive, index: this.index, total: this.total }), !this.app.image && this.app.abbr && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { style: { fontSize: this.app.fontSize || "20px" }, class: "avenir icon-abbr" }, this.app.abbr)), !this.app.image && this.app.abbr && this.app.placeHolderIcon && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: this.app.placeHolderIcon, alt: "" })), this.app.image && (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { src: this.app.image, class: "icon-img", alt: "" })), this.app.isNew && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: { indicator: true, "indicator--new": true, "indicator--new-rtl": rtl } })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "label-text" }, this.app.label), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "screen-readers" }, this.openText))), this.app && !this.app.canAccess && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: { indicator: true, "indicator--remove": true, "indicator--remove-rtl": rtl }, tabIndex: 0, onClick: this.handleRemove, onKeyDown: this.handleRemoveKeydown }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: "x" })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: (el) => (this.missingElement = el), class: "missing-icon", tabIndex: 0, onKeyDown: this.handleKey, onBlur: this.handleBlur }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(AppSwitcherLinkArrows, { active: this.sortingActive, index: this.index, total: this.total })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "label-text" }, this.app.label)))));
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisAppLink.style = arcgisAppSwitcherLinkCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



const languageMap = new Map([
  ["ar", "ar"],
  ["bg", "bg"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["cs", "cs"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["es", "es"],
  ["et", "et"],
  ["fi", "fi"],
  ["fr", "fr"],
  ["he", "he"],
  ["hr", "hr"],
  ["hu", "hu"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "ja"],
  ["ko", "ko"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["nb", "nb"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["pt-br", "pt-BR"],
  ["pt-pt", "pt-PT"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sr", "sr"],
  ["sv", "sv"],
  ["th", "th"],
  ["tr", "tr"],
  ["uk", "uk"],
  ["vi", "vi"],
  ["zh-cn", "zh-CN"],
  ["zh-hk", "zh-HK"],
  ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
  return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
  const closestWithProp = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
  return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
  rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
  const { api, type, places } = options || {};
  if (api === 4) {
    const [intl] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
    const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
      places,
      style: type,
      digitSeparator: true
    });
    return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
  }
  const [dojoNumber] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
  return dojoNumber.format(number, {
    type,
    places,
    pattern: options === null || options === void 0 ? void 0 : options.pattern
  });
}
const cache = {};
function formatDate(date) {
  const lang = document.documentElement.lang;
  const dayShortMonthYear = {
    year: "numeric",
    month: "short",
    day: "numeric"
  };
  if (!cache[lang]) {
    cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
  }
  return cache[lang].format(date);
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-d7f5822e.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-d7f5822e.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getCookie),
/* harmony export */   b: () => (/* binding */ setCookie),
/* harmony export */   c: () => (/* binding */ setSessionStorageItem),
/* harmony export */   d: () => (/* binding */ getSessionStorageItem),
/* harmony export */   g: () => (/* binding */ getLocalStorageItem),
/* harmony export */   s: () => (/* binding */ setLocalStorageItem)
/* harmony export */ });
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


// import stringUtil from "./strings";
/**
 * Utility methods for dealing with storage of various forms (cookies, local storage, and session storage).
 */
function setCookie(name, cookie, properties, stringify) {
  writeCookie(name, stringify ? JSON.stringify(cookie) : cookie, properties);
}
function getCookie(name, parse) {
  const cookie = readCookie(name);
  return cookie && parse ? JSON.parse(cookie) : cookie;
}
function setLocalStorageItem(name, item, stringify) {
  window.localStorage.setItem(name, stringify ? JSON.stringify(item) : item);
}
function getLocalStorageItem(name, parse) {
  const item = window.localStorage.getItem(name);
  return item && parse ? JSON.parse(item) : item;
}
function setSessionStorageItem(name, item, stringify) {
  window.sessionStorage.setItem(name, stringify ? JSON.stringify(item) : item);
}
function getSessionStorageItem(name, parse) {
  const item = window.sessionStorage.getItem(name);
  return item && parse ? JSON.parse(item) : item;
}
function readCookie(name) {
  const cookie = document.cookie;
  const cookieNameRE = new RegExp(`(?:^|; )${(0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_0__.e)(name)}=([^;]*)`);
  const matchedCookies = cookie.match(cookieNameRE);
  return matchedCookies ? decodeURIComponent(matchedCookies[1]) : undefined;
}
function writeCookie(name, value, properties) {
  properties = properties || {};
  let expires = properties === null || properties === void 0 ? void 0 : properties.expires;
  if (typeof expires === "number") {
    const expirationDate = new Date();
    const daysFromTodayInMs = expires * 24 * 60 * 60 * 1000;
    expirationDate.setTime(Date.now() + daysFromTodayInMs);
    expires = properties.expires = expirationDate;
  }
  if (typeof expires !== "string" && (expires === null || expires === void 0 ? void 0 : expires.toUTCString)) {
    properties.expires = expires.toUTCString();
  }
  let cookie = `${name}=${encodeURIComponent(value)}`;
  let property;
  for (property in properties) {
    cookie += `; ${property}`;
    const propertyValue = properties[property];
    if (propertyValue !== true) {
      cookie += `=${propertyValue}`;
    }
  }
  document.cookie = cookie;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTQ3ZDVjMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRjtBQUNsQzs7QUFFeEQ7QUFDQTtBQUNBLG9CQUFvQixzREFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQixTQUFTLHNEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVLGdCQUFnQixPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlLEVBQUUsa0RBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU8sRUFBRSxrREFBVztBQUM5QixpQkFBaUIsc0RBQWMsR0FBRyxrQkFBa0IsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsRUFBRSxrREFBVztBQUNoQyxpQkFBaUIsc0RBQWMsR0FBRyxVQUFVLFVBQVU7QUFDdEQsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTUFBaU07O0FBRWpNO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSixrQ0FBa0M7QUFDbEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVE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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxHQUFHLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsU0FBUztBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRXNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXBpLWY3OTM0Y2Q3LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1hcHAtc3dpdGNoZXJfMi5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTEzZTAwYTc1LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3N0b3JhZ2UtZDdmNTgyMmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBnIGFzIGdldFJlc3RCYXNlVXJsLCBoIGFzIGdldFRva2VuLCBmIGFzIGZyb21DYWNoZSB9IGZyb20gJy4vcG9ydGFsLTc5Y2FhZWZmLmpzJztcbmltcG9ydCB7IGMgYXMgY29uZmlnU3RhdGUgfSBmcm9tICcuL2NvbmZpZy1lYjVmN2RjMi5qcyc7XG5cbmNvbnN0IGFwcFN3aXRjaGVyQ29uZmlnSXRlbVF1ZXJ5ID0gYG93bmVyOlwiZXNyaVwiIEFORCB0aXRsZTpcIkFwcFN3aXRjaGVyIENvbmZpZ1wiIEFORCB0eXBlOiBcIkFwcGxpY2F0aW9uIENvbmZpZ3VyYXRpb25cImA7XG5hc3luYyBmdW5jdGlvbiBnZXRQb3J0YWxTZXR0aW5ncyhwb3J0YWwpIHtcbiAgY29uc3QgcG9ydGFsVXJsID0gZ2V0UmVzdEJhc2VVcmwocG9ydGFsKTtcbiAgaWYgKCFwb3J0YWxVcmwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXJsID0gYCR7cG9ydGFsVXJsfXBvcnRhbHMvc2VsZi9zZXR0aW5nc2A7XG4gIHJldHVybiBmcm9tQ2FjaGUoKCkgPT4gcmVxdWVzdCh1cmwpLCBcInBvcnRhbFNldHRpbmdzXCIsIHBvcnRhbFVybCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTaG93SW5BcHBMYXVuY2hlcigpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IGdldFBvcnRhbFNldHRpbmdzKCk7XG4gIHJldHVybiAoKF9hID0gc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNldHRpbmdzLnBvcnRhbENvbmZpZ1Byb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93SW5BcHBMYXVuY2hlcikgfHwgW107XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBcHBTd2l0Y2hlckNvbmZpZ0l0ZW0oKSB7XG4gIGNvbnN0IHBvcnRhbFVybCA9IGdldFJlc3RCYXNlVXJsKCk7XG4gIGlmICghcG9ydGFsVXJsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVybCA9IGAke3BvcnRhbFVybH1zZWFyY2hgO1xuICByZXR1cm4gcmVxdWVzdCh1cmwsIHtcbiAgICBudW06IDEsXG4gICAgc3RhcnQ6IDAsXG4gICAgc29ydEZpZWxkOiBcInRpdGxlXCIsXG4gICAgc29ydE9yZGVyOiBcImFzY1wiLFxuICAgIHE6IGFwcFN3aXRjaGVyQ29uZmlnSXRlbVF1ZXJ5XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29uZmlnRGF0YShpdGVtSWQpIHtcbiAgY29uc3QgcG9ydGFsVXJsID0gZ2V0UmVzdEJhc2VVcmwoKTtcbiAgaWYgKCFwb3J0YWxVcmwgfHwgIWl0ZW1JZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cmwgPSBgJHtwb3J0YWxVcmx9Y29udGVudC9pdGVtcy8ke2l0ZW1JZH0vZGF0YWA7XG4gIHJldHVybiByZXF1ZXN0KHVybCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBcHBTd2l0Y2hlckNvbmZpZygpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHBvcnRhbCwgdXNlciB9ID0gY29uZmlnU3RhdGU7XG4gIGlmICghKHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5pZCkgfHwgIXVzZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXBwU3dpdGNoZXJDb25maWdJdGVtKCk7XG4gIGNvbnN0IGl0ZW0gPSAoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQucmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICBpZiAoIWl0ZW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaXRlbUlkID0gaXRlbS5pZDtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldENvbmZpZ0RhdGEoaXRlbUlkKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyUHJvcGVydGllcygpIHtcbiAgY29uc3QgeyB1c2VyIH0gPSBjb25maWdTdGF0ZTtcbiAgY29uc3QgdXJsID0gYCR7Z2V0UmVzdEJhc2VVcmwoKX1jb21tdW5pdHkvdXNlcnMvJHt1c2VyLnVzZXJuYW1lfS9wcm9wZXJ0aWVzYDtcbiAgcmV0dXJuIHJlcXVlc3QodXJsKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFwcHJvdmVkQXBwcygpIHtcbiAgY29uc3QgeyBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCB1cmwgPSBgJHtnZXRSZXN0QmFzZVVybCgpfXBvcnRhbHMvJHtwb3J0YWwuaWR9L2FwcHJvdmVkQXBwc2A7XG4gIHJldHVybiByZXF1ZXN0KHVybCwgeyByZXR1cm5BbGxBcHBzOiBmYWxzZSB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQWxsUmVzb3VyY2VzKHVybCwgY29udGVudCwgcmVzb3VyY2VLZXkgPSBcInJlc3VsdHNcIikge1xuICBjb25zdCBtYXggPSAxMDA7XG4gIGxldCBzdGFydCA9IDE7XG4gIGxldCByZXNvdXJjZXMgPSBbXTtcbiAgbGV0IHRvdGFsTGVmdDtcbiAgbGV0IG51bVJlcXVlc3RzO1xuICBsZXQgcHJvbWlzZXM7XG4gIGxldCBpO1xuICBjb250ZW50LnN0YXJ0ID0gc3RhcnQ7XG4gIGlmICghY29udGVudC5udW0pIHtcbiAgICBjb250ZW50Lm51bSA9IG1heDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QodXJsLCBjb250ZW50KTtcbiAgICBpZiAoIShyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHRbcmVzb3VyY2VLZXldKSkge1xuICAgICAgcmV0dXJuIHJlc291cmNlcztcbiAgICB9XG4gICAgcmVzb3VyY2VzID0gWy4uLnJlc291cmNlcywgLi4ucmVzdWx0W3Jlc291cmNlS2V5XV07XG4gICAgLy8gY2FsY3VsYXRlIHdoZXRoZXIgZnVydGhlciBiYXRjaGVzIGFyZSBuZWVkZWRcbiAgICBzdGFydCA9IHJlc3VsdC5uZXh0U3RhcnQ7XG4gICAgdG90YWxMZWZ0ID0gcmVzdWx0LnRvdGFsIC0gcmVzb3VyY2VzLmxlbmd0aDtcbiAgICBudW1SZXF1ZXN0cyA9IE1hdGguY2VpbCh0b3RhbExlZnQgLyBtYXgpO1xuICAgIHByb21pc2VzID0gW107XG4gICAgLy8gcmVxdWVzdCBlYWNoIG5lY2Vzc2FyeSBiYXRjaFxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1SZXF1ZXN0czsgaSsrKSB7XG4gICAgICBjb250ZW50LnN0YXJ0ID0gc3RhcnQgKyBpICogbWF4O1xuICAgICAgcHJvbWlzZXMucHVzaChyZXF1ZXN0KHVybCwgY29udGVudCkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICByZXNvdXJjZXMgPSBbLi4ucmVzb3VyY2VzLCAuLi5yW3Jlc291cmNlS2V5XV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNvdXJjZXM7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgcmV0dXJuIHJlc291cmNlcztcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKF9iKSB7XG4gICAgcmV0dXJuIHJlc291cmNlcztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0TWFya2V0UGxhY2VQcm92aXNpb25lZExpc3RpbmdzKCkge1xuICBjb25zdCB7IHVzZXIgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCB1cmwgPSBgJHtnZXRSZXN0QmFzZVVybCgpfWNvbW11bml0eS91c2Vycy8ke3VzZXIudXNlcm5hbWV9L3Byb3Zpc2lvbmVkTGlzdGluZ3NgO1xuICByZXR1cm4gZmV0Y2hBbGxSZXNvdXJjZXModXJsLCB7IHJldHVybkFwcENsaWVudElkczogdHJ1ZSwgcmV0dXJuQWxsUHJvdmlzaW9uczogdHJ1ZSB9LCBcInByb3Zpc2lvbmVkTGlzdGluZ3NcIik7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRPcmdDYXBhYmlsaXRpZXMoKSB7XG4gIGNvbnN0IHVybCA9IGAke2dldFJlc3RCYXNlVXJsKCl9cG9ydGFscy9zZWxmL3N1YnNjcmlwdGlvbkluZm9gO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdCh1cmwpO1xuICAgIHJldHVybiAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm9yZ0NhcGFiaWxpdGllcykgfHwgW107XG4gIH1cbiAgY2F0Y2ggKF9hKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBxdWVyeUFwcEl0ZW1zRm9yQ2hhbmdlcyhhcHByb3ZlZEFwcHMsIHJ1blF1ZXJ5KSB7XG4gIGlmICghcnVuUXVlcnkgfHwgIShhcHByb3ZlZEFwcHMgPT09IG51bGwgfHwgYXBwcm92ZWRBcHBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHByb3ZlZEFwcHMubGVuZ3RoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cmwgPSBgJHtnZXRSZXN0QmFzZVVybCgpfXNlYXJjaGA7XG4gIHJldHVybiByZXF1ZXN0KHVybCwge1xuICAgIG51bTogMTAwLFxuICAgIHE6IGBpZDooJHthcHByb3ZlZEFwcHMubWFwKChhKSA9PiBgXCIke2EuaXRlbUlkfVwiYCkuam9pbihcIiBPUiBcIil9KWBcbiAgfSk7XG59XG5jb25zdCBibG9ja2VkQXBwc0NvbmZpZ0l0ZW1RdWVyeSA9IGBvd25lcjpcImVzcmlcIiBBTkQgdGl0bGU6XCJCbG9ja2VkQXBwcyBDb25maWdcIiBBTkQgdHlwZTogXCJBcHBsaWNhdGlvbiBDb25maWd1cmF0aW9uXCJgO1xuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvY2thYmxlQXBwcygpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdXJsID0gYCR7Z2V0UmVzdEJhc2VVcmwoKX1zZWFyY2hgO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdCh1cmwsIHtcbiAgICAgIG51bTogMTAsXG4gICAgICBzdGFydDogMCxcbiAgICAgIHNvcnRGaWVsZDogXCJ0aXRsZVwiLFxuICAgICAgc29ydE9yZGVyOiBcImFzY1wiLFxuICAgICAgcTogYmxvY2tlZEFwcHNDb25maWdJdGVtUXVlcnlcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1JZCA9ICgoX2IgPSAoX2EgPSByZXNwb25zZS5yZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZCkgfHwgXCJcIjtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0Q29uZmlnRGF0YShpdGVtSWQpO1xuICAgIHJldHVybiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmJsb2NrZWRBcHBzKSB8fCBbXTtcbiAgfVxuICBjYXRjaCAoX2MpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFNlcnZlcnMoKSB7XG4gIGNvbnN0IHVybCA9IGAke2dldFJlc3RCYXNlVXJsKCl9cG9ydGFscy9zZWxmL3NlcnZlcnNgO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QodXJsKTtcbiAgcmV0dXJuIChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc2VydmVycykgfHwgW107XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTaWduaW5TZXR0aW5ncygpIHtcbiAgY29uc3QgdXJsID0gYCR7Z2V0UmVzdEJhc2VVcmwoKX1wb3J0YWxzL3NlbGYvc2lnbmluU2V0dGluZ3NgO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QodXJsKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gZ2V0VXJsKHBhdGgpIHtcbiAgbGV0IHBvcnRhbFVybCA9IGdldFJlc3RCYXNlVXJsKCk7XG4gIGlmIChwb3J0YWxVcmwuc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgIHBvcnRhbFVybCArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gYCR7cG9ydGFsVXJsfSR7cGF0aH1gO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIHBhcmFtcykge1xuICBpZiAoIXBhcmFtcykge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIHBhcmFtcy5mID0gXCJqc29uXCI7XG4gIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcbiAgaWYgKHRva2VuKSB7XG4gICAgcGFyYW1zLnRva2VuID0gdG9rZW47XG4gIH1cbiAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4gdXJsT2JqLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbXNba2V5XSkpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybE9iaik7XG4gIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgcmV0dXJuIHJlc3BvbnNlRGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBvc3RSZXF1ZXN0KHVybCwgZGF0YSkge1xuICBkYXRhLmFwcGVuZChcImZcIiwgXCJqc29uXCIpO1xuICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XG4gIGlmICh0b2tlbikge1xuICAgIGRhdGEuYXBwZW5kKFwidG9rZW5cIiwgdG9rZW4pO1xuICB9XG4gIGZldGNoKHVybCwgeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5OiBkYXRhIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlclByb3BlcnRpZXMocHJvcGVydGllcykge1xuICBjb25zdCB7IHVzZXIgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCB1cmwgPSBnZXRVcmwoYGNvbW11bml0eS91c2Vycy8ke3VzZXIudXNlcm5hbWV9L3NldFByb3BlcnRpZXNgKTtcbiAgY29uc3QgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBkYXRhLmFwcGVuZChcInByb3BlcnRpZXNcIiwgSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcykpO1xuICByZXR1cm4gcG9zdFJlcXVlc3QodXJsLCBkYXRhKTtcbn1cblxuZXhwb3J0IHsgZ2V0QXBwU3dpdGNoZXJDb25maWcgYXMgYSwgZ2V0TWFya2V0UGxhY2VQcm92aXNpb25lZExpc3RpbmdzIGFzIGIsIGdldFVzZXJQcm9wZXJ0aWVzIGFzIGMsIGdldEFwcHJvdmVkQXBwcyBhcyBkLCBnZXRPcmdDYXBhYmlsaXRpZXMgYXMgZSwgZ2V0U2lnbmluU2V0dGluZ3MgYXMgZiwgZ2V0U2hvd0luQXBwTGF1bmNoZXIgYXMgZywgZ2V0QmxvY2thYmxlQXBwcyBhcyBoLCBnZXRTZXJ2ZXJzIGFzIGksIGdldFBvcnRhbFNldHRpbmdzIGFzIGosIGZldGNoQWxsUmVzb3VyY2VzIGFzIGssIHF1ZXJ5QXBwSXRlbXNGb3JDaGFuZ2VzIGFzIHEsIHVwZGF0ZVVzZXJQcm9wZXJ0aWVzIGFzIHUgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBhIGFzIGdldEFzc2V0UGF0aCwgaCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQsIEYgYXMgRnJhZ21lbnQgfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyB9IGZyb20gJy4vbG9jYWxlLTEzZTAwYTc1LmpzJztcbmltcG9ydCB7IGMgYXMgY29uZmlnU3RhdGUgfSBmcm9tICcuL2NvbmZpZy1lYjVmN2RjMi5qcyc7XG5pbXBvcnQgeyB1IGFzIHVwZGF0ZVVzZXJQcm9wZXJ0aWVzLCBnIGFzIGdldFNob3dJbkFwcExhdW5jaGVyLCBhIGFzIGdldEFwcFN3aXRjaGVyQ29uZmlnLCBiIGFzIGdldE1hcmtldFBsYWNlUHJvdmlzaW9uZWRMaXN0aW5ncywgYyBhcyBnZXRVc2VyUHJvcGVydGllcywgZCBhcyBnZXRBcHByb3ZlZEFwcHMsIGUgYXMgZ2V0T3JnQ2FwYWJpbGl0aWVzLCBmIGFzIGdldFNpZ25pblNldHRpbmdzLCBoIGFzIGdldEJsb2NrYWJsZUFwcHMsIGkgYXMgZ2V0U2VydmVycywgcSBhcyBxdWVyeUFwcEl0ZW1zRm9yQ2hhbmdlcyB9IGZyb20gJy4vYXBpLWY3OTM0Y2Q3LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0UmVzdEJhc2VVcmwsIGggYXMgZ2V0VG9rZW4gfSBmcm9tICcuL3BvcnRhbC03OWNhYWVmZi5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldENvb2tpZSwgYiBhcyBzZXRDb29raWUgfSBmcm9tICcuL3N0b3JhZ2UtZDdmNTgyMmUuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0ICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5pbXBvcnQgJy4vaW5kZXgtODFkNTQ4YjcuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCAnLi9wcml2aWxlZ2VzLWNjZDVmMzdkLmpzJztcbmltcG9ydCAnLi9mdW5jdGlvbmFsLWM4MmY1YWI5LmpzJztcblxuLyoqIVxuICogU29ydGFibGUgMS4xNS4wXG4gKiBAYXV0aG9yXHRSdWJhWGEgICA8dHJhc2hAcnViYXhhLm9yZz5cbiAqIEBhdXRob3JcdG93ZW5tICAgIDxvd2VuMjMzNTVAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIxLjE1LjBcIjtcblxuZnVuY3Rpb24gdXNlckFnZW50KHBhdHRlcm4pIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gISEgLypAX19QVVJFX18qL25hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gocGF0dGVybik7XG4gIH1cbn1cblxudmFyIElFMTFPckxlc3MgPSB1c2VyQWdlbnQoLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcLnxtc2llfGllbW9iaWxlfFdpbmRvd3MgUGhvbmUpL2kpO1xudmFyIEVkZ2UgPSB1c2VyQWdlbnQoL0VkZ2UvaSk7XG52YXIgRmlyZUZveCA9IHVzZXJBZ2VudCgvZmlyZWZveC9pKTtcbnZhciBTYWZhcmkgPSB1c2VyQWdlbnQoL3NhZmFyaS9pKSAmJiAhdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgIXVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcbnZhciBJT1MgPSB1c2VyQWdlbnQoL2lQKGFkfG9kfGhvbmUpL2kpO1xudmFyIENocm9tZUZvckFuZHJvaWQgPSB1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiB1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG5cbnZhciBjYXB0dXJlTW9kZSA9IHtcbiAgY2FwdHVyZTogZmFsc2UsXG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcikge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm47XG4gIHNlbGVjdG9yWzBdID09PSAnPicgJiYgKHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcblxuICBpZiAoZWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGVsLm1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50T3JIb3N0KGVsKSB7XG4gIHJldHVybiBlbC5ob3N0ICYmIGVsICE9PSBkb2N1bWVudCAmJiBlbC5ob3N0Lm5vZGVUeXBlID8gZWwuaG9zdCA6IGVsLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3QoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcixcbi8qKkhUTUxFbGVtZW50Ki9cbmN0eCwgaW5jbHVkZUNUWCkge1xuICBpZiAoZWwpIHtcbiAgICBjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiAoc2VsZWN0b3JbMF0gPT09ICc+JyA/IGVsLnBhcmVudE5vZGUgPT09IGN0eCAmJiBtYXRjaGVzKGVsLCBzZWxlY3RvcikgOiBtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHx8IGluY2x1ZGVDVFggJiYgZWwgPT09IGN0eCkge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbCA9PT0gY3R4KSBicmVhaztcbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB9IHdoaWxlIChlbCA9IGdldFBhcmVudE9ySG9zdChlbCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSX1NQQUNFID0gL1xccysvZztcblxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIHN0YXRlKSB7XG4gIGlmIChlbCAmJiBuYW1lKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0W3N0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKFJfU1BBQ0UsICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuICAgICAgZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3NzKGVsLCBwcm9wLCB2YWwpIHtcbiAgdmFyIHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICB2YWwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWwgPSBlbC5jdXJyZW50U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wID09PSB2b2lkIDAgPyB2YWwgOiB2YWxbcHJvcF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHByb3AgaW4gc3R5bGUpICYmIHByb3AuaW5kZXhPZignd2Via2l0JykgPT09IC0xKSB7XG4gICAgICAgIHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRyaXgoZWwsIHNlbGZPbmx5KSB7XG4gIHZhciBhcHBsaWVkVHJhbnNmb3JtcyA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBwbGllZFRyYW5zZm9ybXMgPSBlbDtcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY3NzKGVsLCAndHJhbnNmb3JtJyk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgYXBwbGllZFRyYW5zZm9ybXMgPSB0cmFuc2Zvcm0gKyAnICcgKyBhcHBsaWVkVHJhbnNmb3JtcztcbiAgICAgIH1cbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgIH0gd2hpbGUgKCFzZWxmT25seSAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cblxuICB2YXIgbWF0cml4Rm4gPSB3aW5kb3cuRE9NTWF0cml4IHx8IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggfHwgd2luZG93LkNTU01hdHJpeCB8fCB3aW5kb3cuTVNDU1NNYXRyaXg7XG4gIC8qanNoaW50IC1XMDU2ICovXG5cbiAgcmV0dXJuIG1hdHJpeEZuICYmIG5ldyBtYXRyaXhGbihhcHBsaWVkVHJhbnNmb3Jtcyk7XG59XG5cbmZ1bmN0aW9uIGZpbmQoY3R4LCB0YWdOYW1lLCBpdGVyYXRvcikge1xuICBpZiAoY3R4KSB7XG4gICAgdmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gbGlzdC5sZW5ndGg7XG5cbiAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGxpc3RbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkge1xuICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG5cbiAgaWYgKHNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFwiYm91bmRpbmcgY2xpZW50IHJlY3RcIiBvZiBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbGVtZW50IHdob3NlIGJvdW5kaW5nQ2xpZW50UmVjdCBpcyB3YW50ZWRcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcgYmxvY2sgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmUgcGFyZW50IG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWllbnJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gdW5kb1NjYWxlICAgICAgICAgICAgICAgICAgV2hldGhlciB0aGUgY29udGFpbmVyJ3Mgc2NhbGUoKSBzaG91bGQgYmUgdW5kb25lXG4gKiBAcGFyYW0gIHtbSFRNTEVsZW1lbnRdfSBjb250YWluZXIgICAgICAgICAgICAgIFRoZSBwYXJlbnQgdGhlIGVsZW1lbnQgd2lsbCBiZSBwbGFjZWQgaW5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJvdW5kaW5nQ2xpZW50UmVjdCBvZiBlbCwgd2l0aCBzcGVjaWZpZWQgYWRqdXN0bWVudHNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlY3QoZWwsIHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2ssIHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQsIHVuZG9TY2FsZSwgY29udGFpbmVyKSB7XG4gIGlmICghZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsICE9PSB3aW5kb3cpIHJldHVybjtcbiAgdmFyIGVsUmVjdCwgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBoZWlnaHQsIHdpZHRoO1xuXG4gIGlmIChlbCAhPT0gd2luZG93ICYmIGVsLnBhcmVudE5vZGUgJiYgZWwgIT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRvcCA9IGVsUmVjdC50b3A7XG4gICAgbGVmdCA9IGVsUmVjdC5sZWZ0O1xuICAgIGJvdHRvbSA9IGVsUmVjdC5ib3R0b207XG4gICAgcmlnaHQgPSBlbFJlY3QucmlnaHQ7XG4gICAgaGVpZ2h0ID0gZWxSZWN0LmhlaWdodDtcbiAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAwO1xuICAgIGxlZnQgPSAwO1xuICAgIGJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB9XG5cbiAgaWYgKChyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQpICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHRyYW5zbGF0ZSgpXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsLnBhcmVudE5vZGU7IC8vIHNvbHZlcyAjMTEyMyAoc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc5NTM4MDYvNjA4ODMxMilcbiAgICAvLyBOb3QgbmVlZGVkIG9uIDw9IElFMTFcblxuICAgIGlmICghSUUxMU9yTGVzcykge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKGNzcyhjb250YWluZXIsICd0cmFuc2Zvcm0nKSAhPT0gJ25vbmUnIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgJiYgY3NzKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnKSkge1xuICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBTZXQgcmVsYXRpdmUgdG8gZWRnZXMgb2YgcGFkZGluZyBib3ggb2YgY29udGFpbmVyXG5cbiAgICAgICAgICB0b3AgLT0gY29udGFpbmVyUmVjdC50b3AgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLXRvcC13aWR0aCcpKTtcbiAgICAgICAgICBsZWZ0IC09IGNvbnRhaW5lclJlY3QubGVmdCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItbGVmdC13aWR0aCcpKTtcbiAgICAgICAgICBib3R0b20gPSB0b3AgKyBlbFJlY3QuaGVpZ2h0O1xuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIGVsUmVjdC53aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICAgIH0gd2hpbGUgKGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5kb1NjYWxlICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHNjYWxlKClcbiAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoY29udGFpbmVyIHx8IGVsKSxcbiAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZDtcblxuICAgIGlmIChlbE1hdHJpeCkge1xuICAgICAgdG9wIC89IHNjYWxlWTtcbiAgICAgIGxlZnQgLz0gc2NhbGVYO1xuICAgICAgd2lkdGggLz0gc2NhbGVYO1xuICAgICAgaGVpZ2h0IC89IHNjYWxlWTtcbiAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICByaWdodDogcmlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHNpZGUgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCBwYXN0IGEgc2lkZSBvZiBpdHMgcGFyZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbCAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvJ3Mgc2lkZSBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyBpcyBpbiBxdWVzdGlvblxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBlbFNpZGUgICAgICAgU2lkZSBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHBhcmVudFNpZGUgICBTaWRlIG9mIHRoZSBwYXJlbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgICAgICAgVGhlIHBhcmVudCBzY3JvbGwgZWxlbWVudCB0aGF0IHRoZSBlbCdzIHNpZGUgaXMgc2Nyb2xsZWQgcGFzdCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRQYXN0KGVsLCBlbFNpZGUsIHBhcmVudFNpZGUpIHtcbiAgdmFyIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCB0cnVlKSxcbiAgICAgIGVsU2lkZVZhbCA9IGdldFJlY3QoZWwpW2VsU2lkZV07XG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgdmFyIHBhcmVudFNpZGVWYWwgPSBnZXRSZWN0KHBhcmVudClbcGFyZW50U2lkZV0sXG4gICAgICAgIHZpc2libGUgPSB2b2lkIDA7XG5cbiAgICBpZiAocGFyZW50U2lkZSA9PT0gJ3RvcCcgfHwgcGFyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsID49IHBhcmVudFNpZGVWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPD0gcGFyZW50U2lkZVZhbDtcbiAgICB9XG5cbiAgICBpZiAoIXZpc2libGUpIHJldHVybiBwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSBicmVhaztcbiAgICBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChwYXJlbnQsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogR2V0cyBudGggY2hpbGQgb2YgZWwsIGlnbm9yaW5nIGhpZGRlbiBjaGlsZHJlbiwgc29ydGFibGUncyBlbGVtZW50cyAoZG9lcyBub3QgaWdub3JlIGNsb25lIGlmIGl0J3MgdmlzaWJsZSlcbiAqIGFuZCBub24tZHJhZ2dhYmxlIGVsZW1lbnRzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgVGhlIHBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNoaWxkTnVtICAgICAgVGhlIGluZGV4IG9mIHRoZSBjaGlsZFxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICAgICAgIFBhcmVudCBTb3J0YWJsZSdzIG9wdGlvbnNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgY2hpbGQgYXQgaW5kZXggY2hpbGROdW0sIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDaGlsZChlbCwgY2hpbGROdW0sIG9wdGlvbnMsIGluY2x1ZGVEcmFnRWwpIHtcbiAgdmFyIGN1cnJlbnRDaGlsZCA9IDAsXG4gICAgICBpID0gMCxcbiAgICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG5cbiAgd2hpbGUgKGkgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBpZiAoY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmIGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5naG9zdCAmJiAoaW5jbHVkZURyYWdFbCB8fCBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZHJhZ2dlZCkgJiYgY2xvc2VzdChjaGlsZHJlbltpXSwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgIGlmIChjdXJyZW50Q2hpbGQgPT09IGNoaWxkTnVtKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudENoaWxkKys7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdldHMgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIGVsLCBpZ25vcmluZyBnaG9zdEVsIG9yIGludmlzaWJsZSBlbGVtZW50cyAoY2xvbmVzKVxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgICAgIFBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3IgICAgQW55IG90aGVyIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgbGFzdCBjaGlsZCwgaWdub3JpbmcgZ2hvc3RFbFxuICovXG5cblxuZnVuY3Rpb24gbGFzdENoaWxkKGVsLCBzZWxlY3Rvcikge1xuICB2YXIgbGFzdCA9IGVsLmxhc3RFbGVtZW50Q2hpbGQ7XG5cbiAgd2hpbGUgKGxhc3QgJiYgKGxhc3QgPT09IFNvcnRhYmxlLmdob3N0IHx8IGNzcyhsYXN0LCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2VsZWN0b3IgJiYgIW1hdGNoZXMobGFzdCwgc2VsZWN0b3IpKSkge1xuICAgIGxhc3QgPSBsYXN0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbGFzdCB8fCBudWxsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50IGZvciBhIHNlbGVjdGVkIHNldCBvZlxuICogZWxlbWVudHNcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBpbmRleChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGluZGV4ID0gMDtcblxuICBpZiAoIWVsIHx8ICFlbC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuXG4gIHdoaWxlIChlbCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBpZiAoZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1RFTVBMQVRFJyAmJiBlbCAhPT0gU29ydGFibGUuY2xvbmUgJiYgKCFzZWxlY3RvciB8fCBtYXRjaGVzKGVsLCBzZWxlY3RvcikpKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCwgYWRkZWQgd2l0aCBhbGwgdGhlIHNjcm9sbCBvZmZzZXRzIG9mIHBhcmVudCBlbGVtZW50cy5cbiAqIFRoZSB2YWx1ZSBpcyByZXR1cm5lZCBpbiByZWFsIHBpeGVscy5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgIE9mZnNldHMgaW4gdGhlIGZvcm1hdCBvZiBbbGVmdCwgdG9wXVxuICovXG5cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZWwpIHtcbiAgdmFyIG9mZnNldExlZnQgPSAwLFxuICAgICAgb2Zmc2V0VG9wID0gMCxcbiAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuXG4gIGlmIChlbCkge1xuICAgIGRvIHtcbiAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeChlbCksXG4gICAgICAgICAgc2NhbGVYID0gZWxNYXRyaXguYSxcbiAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeC5kO1xuICAgICAgb2Zmc2V0TGVmdCArPSBlbC5zY3JvbGxMZWZ0ICogc2NhbGVYO1xuICAgICAgb2Zmc2V0VG9wICs9IGVsLnNjcm9sbFRvcCAqIHNjYWxlWTtcbiAgICB9IHdoaWxlIChlbCAhPT0gd2luU2Nyb2xsZXIgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG5cbiAgcmV0dXJuIFtvZmZzZXRMZWZ0LCBvZmZzZXRUb3BdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IHdpdGhpbiB0aGUgZ2l2ZW4gYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIgICBBcnJheSB0aGF0IG1heSBvciBtYXkgbm90IGhvbGQgdGhlIG9iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogIEFuIG9iamVjdCB0aGF0IGhhcyBhIGtleS12YWx1ZSBwYWlyIHVuaXF1ZSB0byBhbmQgaWRlbnRpY2FsIHRvIGEga2V5LXZhbHVlIHBhaXIgaW4gdGhlIG9iamVjdCB5b3Ugd2FudCB0byBmaW5kXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgVGhlIGluZGV4IG9mIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5LCBvciAtMVxuICovXG5cblxuZnVuY3Rpb24gaW5kZXhPZk9iamVjdChhcnIsIG9iaikge1xuICBmb3IgKHZhciBpIGluIGFycikge1xuICAgIGlmICghYXJyLmhhc093blByb3BlcnR5KGkpKSBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmpba2V5XSA9PT0gYXJyW2ldW2tleV0pIHJldHVybiBOdW1iZXIoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbCwgaW5jbHVkZVNlbGYpIHtcbiAgLy8gc2tpcCB0byB3aW5kb3dcbiAgaWYgKCFlbCB8fCAhZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB2YXIgZWxlbSA9IGVsO1xuICB2YXIgZ290U2VsZiA9IGZhbHNlO1xuXG4gIGRvIHtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGdldCBlbGVtIGNzcyBpZiBpdCBpc24ndCBldmVuIG92ZXJmbG93aW5nIGluIHRoZSBmaXJzdCBwbGFjZSAocGVyZm9ybWFuY2UpXG4gICAgaWYgKGVsZW0uY2xpZW50V2lkdGggPCBlbGVtLnNjcm9sbFdpZHRoIHx8IGVsZW0uY2xpZW50SGVpZ2h0IDwgZWxlbS5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIHZhciBlbGVtQ1NTID0gY3NzKGVsZW0pO1xuXG4gICAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggJiYgKGVsZW1DU1Mub3ZlcmZsb3dYID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WCA9PSAnc2Nyb2xsJykgfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCAmJiAoZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dZID09ICdzY3JvbGwnKSkge1xuICAgICAgICBpZiAoIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHx8IGVsZW0gPT09IGRvY3VtZW50LmJvZHkpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIGlmIChnb3RTZWxmIHx8IGluY2x1ZGVTZWxmKSByZXR1cm4gZWxlbTtcbiAgICAgICAgZ290U2VsZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICB9IHdoaWxlIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKTtcblxuICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoZHN0LCBzcmMpIHtcbiAgaWYgKGRzdCAmJiBzcmMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG5mdW5jdGlvbiBpc1JlY3RFcXVhbChyZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQocmVjdDEudG9wKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi50b3ApICYmIE1hdGgucm91bmQocmVjdDEubGVmdCkgPT09IE1hdGgucm91bmQocmVjdDIubGVmdCkgJiYgTWF0aC5yb3VuZChyZWN0MS5oZWlnaHQpID09PSBNYXRoLnJvdW5kKHJlY3QyLmhlaWdodCkgJiYgTWF0aC5yb3VuZChyZWN0MS53aWR0aCkgPT09IE1hdGgucm91bmQocmVjdDIud2lkdGgpO1xufVxuXG52YXIgX3Rocm90dGxlVGltZW91dDtcblxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2ssIG1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfdGhyb3R0bGVUaW1lb3V0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgX3Rocm90dGxlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xuICAgICAgfSwgbXMpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsVGhyb3R0bGUoKSB7XG4gIGNsZWFyVGltZW91dChfdGhyb3R0bGVUaW1lb3V0KTtcbiAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsQnkoZWwsIHgsIHkpIHtcbiAgZWwuc2Nyb2xsTGVmdCArPSB4O1xuICBlbC5zY3JvbGxUb3AgKz0geTtcbn1cblxuZnVuY3Rpb24gY2xvbmUoZWwpIHtcbiAgdmFyIFBvbHltZXIgPSB3aW5kb3cuUG9seW1lcjtcbiAgdmFyICQgPSB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0bztcblxuICBpZiAoUG9seW1lciAmJiBQb2x5bWVyLmRvbSkge1xuICAgIHJldHVybiBQb2x5bWVyLmRvbShlbCkuY2xvbmVOb2RlKHRydWUpO1xuICB9IGVsc2UgaWYgKCQpIHtcbiAgICByZXR1cm4gJChlbCkuY2xvbmUodHJ1ZSlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsLmNsb25lTm9kZSh0cnVlKTtcbiAgfVxufVxuXG52YXIgZXhwYW5kbyA9ICdTb3J0YWJsZScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkge1xuICB2YXIgYW5pbWF0aW9uU3RhdGVzID0gW10sXG4gICAgICBhbmltYXRpb25DYWxsYmFja0lkO1xuICByZXR1cm4ge1xuICAgIGNhcHR1cmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gY2FwdHVyZUFuaW1hdGlvblN0YXRlKCkge1xuICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHJldHVybjtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbC5jaGlsZHJlbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY3NzKGNoaWxkLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgY2hpbGQgPT09IFNvcnRhYmxlLmdob3N0KSByZXR1cm47XG4gICAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHtcbiAgICAgICAgICB0YXJnZXQ6IGNoaWxkLFxuICAgICAgICAgIHJlY3Q6IGdldFJlY3QoY2hpbGQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmcm9tUmVjdCA9IF9vYmplY3RTcHJlYWQyKHt9LCBhbmltYXRpb25TdGF0ZXNbYW5pbWF0aW9uU3RhdGVzLmxlbmd0aCAtIDFdLnJlY3QpOyAvLyBJZiBhbmltYXRpbmc6IGNvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAoY2hpbGQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTWF0cml4ID0gbWF0cml4KGNoaWxkLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjaGlsZE1hdHJpeCkge1xuICAgICAgICAgICAgZnJvbVJlY3QudG9wIC09IGNoaWxkTWF0cml4LmY7XG4gICAgICAgICAgICBmcm9tUmVjdC5sZWZ0IC09IGNoaWxkTWF0cml4LmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQuZnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWRkQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGFkZEFuaW1hdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgfSxcbiAgICByZW1vdmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gcmVtb3ZlQW5pbWF0aW9uU3RhdGUodGFyZ2V0KSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuc3BsaWNlKGluZGV4T2ZPYmplY3QoYW5pbWF0aW9uU3RhdGVzLCB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KSwgMSk7XG4gICAgfSxcbiAgICBhbmltYXRlQWxsOiBmdW5jdGlvbiBhbmltYXRlQWxsKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmltYXRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gMDtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgICAgICBmcm9tUmVjdCA9IHRhcmdldC5mcm9tUmVjdCxcbiAgICAgICAgICAgIHRvUmVjdCA9IGdldFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICAgIHByZXZGcm9tUmVjdCA9IHRhcmdldC5wcmV2RnJvbVJlY3QsXG4gICAgICAgICAgICBwcmV2VG9SZWN0ID0gdGFyZ2V0LnByZXZUb1JlY3QsXG4gICAgICAgICAgICBhbmltYXRpbmdSZWN0ID0gc3RhdGUucmVjdCxcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeCA9IG1hdHJpeCh0YXJnZXQsIHRydWUpO1xuXG4gICAgICAgIGlmICh0YXJnZXRNYXRyaXgpIHtcbiAgICAgICAgICAvLyBDb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICAgIHRvUmVjdC50b3AgLT0gdGFyZ2V0TWF0cml4LmY7XG4gICAgICAgICAgdG9SZWN0LmxlZnQgLT0gdGFyZ2V0TWF0cml4LmU7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQudG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgIGlmICh0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gQ291bGQgYWxzbyBjaGVjayBpZiBhbmltYXRpbmdSZWN0IGlzIGJldHdlZW4gZnJvbVJlY3QgYW5kIHRvUmVjdFxuICAgICAgICAgIGlmIChpc1JlY3RFcXVhbChwcmV2RnJvbVJlY3QsIHRvUmVjdCkgJiYgIWlzUmVjdEVxdWFsKGZyb21SZWN0LCB0b1JlY3QpICYmIC8vIE1ha2Ugc3VyZSBhbmltYXRpbmdSZWN0IGlzIG9uIGxpbmUgYmV0d2VlbiB0b1JlY3QgJiBmcm9tUmVjdFxuICAgICAgICAgIChhbmltYXRpbmdSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGFuaW1hdGluZ1JlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSA9PT0gKGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkpIHtcbiAgICAgICAgICAgIC8vIElmIHJldHVybmluZyB0byBzYW1lIHBsYWNlIGFzIHN0YXJ0ZWQgZnJvbSBhbmltYXRpb24gYW5kIG9uIHNhbWUgYXhpc1xuICAgICAgICAgICAgdGltZSA9IGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIHByZXZGcm9tUmVjdCwgcHJldlRvUmVjdCwgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIGZyb21SZWN0ICE9IHRvUmVjdDogYW5pbWF0ZVxuXG5cbiAgICAgICAgaWYgKCFpc1JlY3RFcXVhbCh0b1JlY3QsIGZyb21SZWN0KSkge1xuICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgdGltZSA9IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmFuaW1hdGUodGFyZ2V0LCBhbmltYXRpbmdSZWN0LCB0b1JlY3QsIHRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICBhbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSBNYXRoLm1heChhbmltYXRpb25UaW1lLCB0aW1lKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5mcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG5cbiAgICAgIGlmICghYW5pbWF0aW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFja0lkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgYW5pbWF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSh0YXJnZXQsIGN1cnJlbnRSZWN0LCB0b1JlY3QsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeCh0aGlzLmVsKSxcbiAgICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IChjdXJyZW50UmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSAoY3VycmVudFJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoc2NhbGVZIHx8IDEpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9ICEhdHJhbnNsYXRlWDtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSAhIXRyYW5zbGF0ZVk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoJyArIHRyYW5zbGF0ZVggKyAncHgsJyArIHRyYW5zbGF0ZVkgKyAncHgsMCknKTtcbiAgICAgICAgdGhpcy5mb3JSZXBhaW50RHVtbXkgPSByZXBhaW50KHRhcmdldCk7IC8vIHJlcGFpbnRcblxuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJ21zJyArICh0aGlzLm9wdGlvbnMuZWFzaW5nID8gJyAnICsgdGhpcy5vcHRpb25zLmVhc2luZyA6ICcnKSk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgICAgIHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInICYmIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0ZWQpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSBmYWxzZTtcbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwYWludCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5vZmZzZXRXaWR0aDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIGFuaW1hdGluZ1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSBhbmltYXRpbmdSZWN0LmxlZnQsIDIpKSAvIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCwgMikpICogb3B0aW9ucy5hbmltYXRpb247XG59XG5cbnZhciBwbHVnaW5zID0gW107XG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbn07XG52YXIgUGx1Z2luTWFuYWdlciA9IHtcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KHBsdWdpbikge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKG9wdGlvbiBpbiBwbHVnaW4pKSB7XG4gICAgICAgIHBsdWdpbltvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwLnBsdWdpbk5hbWUgPT09IHBsdWdpbi5wbHVnaW5OYW1lKSB7XG4gICAgICAgIHRocm93IFwiU29ydGFibGU6IENhbm5vdCBtb3VudCBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbi5wbHVnaW5OYW1lLCBcIiBtb3JlIHRoYW4gb25jZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgfSxcbiAgcGx1Z2luRXZlbnQ6IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUsIGV2dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmV2ZW50Q2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIGV2dC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ldmVudENhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50TmFtZUdsb2JhbCA9IGV2ZW50TmFtZSArICdHbG9iYWwnO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBGaXJlIGdsb2JhbCBldmVudHMgaWYgaXQgZXhpc3RzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9IC8vIE9ubHkgZmlyZSBwbHVnaW4gZXZlbnQgaWYgcGx1Z2luIGlzIGVuYWJsZWQgaW4gdGhpcyBzb3J0YWJsZSxcbiAgICAgIC8vIGFuZCBwbHVnaW4gaGFzIGV2ZW50IGRlZmluZWRcblxuXG4gICAgICBpZiAoc29ydGFibGUub3B0aW9uc1twbHVnaW4ucGx1Z2luTmFtZV0gJiYgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZV0oX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgaW5pdGlhbGl6ZVBsdWdpbnM6IGZ1bmN0aW9uIGluaXRpYWxpemVQbHVnaW5zKHNvcnRhYmxlLCBlbCwgZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZTtcbiAgICAgIGlmICghc29ydGFibGUub3B0aW9uc1twbHVnaW5OYW1lXSAmJiAhcGx1Z2luLmluaXRpYWxpemVCeURlZmF1bHQpIHJldHVybjtcbiAgICAgIHZhciBpbml0aWFsaXplZCA9IG5ldyBwbHVnaW4oc29ydGFibGUsIGVsLCBzb3J0YWJsZS5vcHRpb25zKTtcbiAgICAgIGluaXRpYWxpemVkLnNvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICBpbml0aWFsaXplZC5vcHRpb25zID0gc29ydGFibGUub3B0aW9ucztcbiAgICAgIHNvcnRhYmxlW3BsdWdpbk5hbWVdID0gaW5pdGlhbGl6ZWQ7IC8vIEFkZCBkZWZhdWx0IG9wdGlvbnMgZnJvbSBwbHVnaW5cblxuICAgICAgX2V4dGVuZHMoZGVmYXVsdHMsIGluaXRpYWxpemVkLmRlZmF1bHRzKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIG9wdGlvbiBpbiBzb3J0YWJsZS5vcHRpb25zKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkgY29udGludWU7XG4gICAgICB2YXIgbW9kaWZpZWQgPSB0aGlzLm1vZGlmeU9wdGlvbihzb3J0YWJsZSwgb3B0aW9uLCBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0pO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0gPSBtb2RpZmllZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdldEV2ZW50UHJvcGVydGllczogZnVuY3Rpb24gZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSB7XG4gICAgdmFyIGV2ZW50UHJvcGVydGllcyA9IHt9O1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbi5ldmVudFByb3BlcnRpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgX2V4dGVuZHMoZXZlbnRQcm9wZXJ0aWVzLCBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50UHJvcGVydGllcztcbiAgfSxcbiAgbW9kaWZ5T3B0aW9uOiBmdW5jdGlvbiBtb2RpZnlPcHRpb24oc29ydGFibGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG1vZGlmaWVkVmFsdWU7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIC8vIFBsdWdpbiBtdXN0IGV4aXN0IG9uIHRoZSBTb3J0YWJsZVxuICAgICAgaWYgKCFzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0pIHJldHVybjsgLy8gSWYgc3RhdGljIG9wdGlvbiBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgb3B0aW9uLCBjYWxsIGluIHRoZSBjb250ZXh0IG9mIHRoZSBTb3J0YWJsZSdzIGluc3RhbmNlIG9mIHRoaXMgcGx1Z2luXG5cbiAgICAgIGlmIChwbHVnaW4ub3B0aW9uTGlzdGVuZXJzICYmIHR5cGVvZiBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1vZGlmaWVkVmFsdWUgPSBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkVmFsdWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoX3JlZikge1xuICB2YXIgc29ydGFibGUgPSBfcmVmLnNvcnRhYmxlLFxuICAgICAgcm9vdEVsID0gX3JlZi5yb290RWwsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgdGFyZ2V0RWwgPSBfcmVmLnRhcmdldEVsLFxuICAgICAgY2xvbmVFbCA9IF9yZWYuY2xvbmVFbCxcbiAgICAgIHRvRWwgPSBfcmVmLnRvRWwsXG4gICAgICBmcm9tRWwgPSBfcmVmLmZyb21FbCxcbiAgICAgIG9sZEluZGV4ID0gX3JlZi5vbGRJbmRleCxcbiAgICAgIG5ld0luZGV4ID0gX3JlZi5uZXdJbmRleCxcbiAgICAgIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZi5vbGREcmFnZ2FibGVJbmRleCxcbiAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gX3JlZi5uZXdEcmFnZ2FibGVJbmRleCxcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBleHRyYUV2ZW50UHJvcGVydGllcyA9IF9yZWYuZXh0cmFFdmVudFByb3BlcnRpZXM7XG4gIHNvcnRhYmxlID0gc29ydGFibGUgfHwgcm9vdEVsICYmIHJvb3RFbFtleHBhbmRvXTtcbiAgaWYgKCFzb3J0YWJsZSkgcmV0dXJuO1xuICB2YXIgZXZ0LFxuICAgICAgb3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnMsXG4gICAgICBvbk5hbWUgPSAnb24nICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICB9XG5cbiAgZXZ0LnRvID0gdG9FbCB8fCByb290RWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcbiAgZXZ0Lml0ZW0gPSB0YXJnZXRFbCB8fCByb290RWw7XG4gIGV2dC5jbG9uZSA9IGNsb25lRWw7XG4gIGV2dC5vbGRJbmRleCA9IG9sZEluZGV4O1xuICBldnQubmV3SW5kZXggPSBuZXdJbmRleDtcbiAgZXZ0Lm9sZERyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIGV2dC5uZXdEcmFnZ2FibGVJbmRleCA9IG5ld0RyYWdnYWJsZUluZGV4O1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGV2dC5wdWxsTW9kZSA9IHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUubGFzdFB1dE1vZGUgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGFsbEV2ZW50UHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYUV2ZW50UHJvcGVydGllcyksIFBsdWdpbk1hbmFnZXIuZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSk7XG5cbiAgZm9yICh2YXIgb3B0aW9uIGluIGFsbEV2ZW50UHJvcGVydGllcykge1xuICAgIGV2dFtvcHRpb25dID0gYWxsRXZlbnRQcm9wZXJ0aWVzW29wdGlvbl07XG4gIH1cblxuICBpZiAocm9vdEVsKSB7XG4gICAgcm9vdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zW29uTmFtZV0pIHtcbiAgICBvcHRpb25zW29uTmFtZV0uY2FsbChzb3J0YWJsZSwgZXZ0KTtcbiAgfVxufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiZXZ0XCJdO1xuXG52YXIgcGx1Z2luRXZlbnQgPSBmdW5jdGlvbiBwbHVnaW5FdmVudChldmVudE5hbWUsIHNvcnRhYmxlKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgIG9yaWdpbmFsRXZlbnQgPSBfcmVmLmV2dCxcbiAgICAgIGRhdGEgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcblxuICBQbHVnaW5NYW5hZ2VyLnBsdWdpbkV2ZW50LmJpbmQoU29ydGFibGUpKGV2ZW50TmFtZSwgc29ydGFibGUsIF9vYmplY3RTcHJlYWQyKHtcbiAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICBwYXJlbnRFbDogcGFyZW50RWwsXG4gICAgZ2hvc3RFbDogZ2hvc3RFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBuZXh0RWw6IG5leHRFbCxcbiAgICBsYXN0RG93bkVsOiBsYXN0RG93bkVsLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW46IGNsb25lSGlkZGVuLFxuICAgIGRyYWdTdGFydGVkOiBtb3ZlZCxcbiAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgYWN0aXZlU29ydGFibGU6IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleCxcbiAgICBoaWRlR2hvc3RGb3JUYXJnZXQ6IF9oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgdW5oaWRlR2hvc3RGb3JUYXJnZXQ6IF91bmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICBjbG9uZU5vd0hpZGRlbjogZnVuY3Rpb24gY2xvbmVOb3dIaWRkZW4oKSB7XG4gICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgfSxcbiAgICBjbG9uZU5vd1Nob3duOiBmdW5jdGlvbiBjbG9uZU5vd1Nob3duKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICB9LFxuICAgIGRpc3BhdGNoU29ydGFibGVFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KG5hbWUpIHtcbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGRhdGEpKTtcbn07XG5cbmZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KGluZm8pIHtcbiAgZGlzcGF0Y2hFdmVudChfb2JqZWN0U3ByZWFkMih7XG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgdGFyZ2V0RWw6IGRyYWdFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXhcbiAgfSwgaW5mbykpO1xufVxuXG52YXIgZHJhZ0VsLFxuICAgIHBhcmVudEVsLFxuICAgIGdob3N0RWwsXG4gICAgcm9vdEVsLFxuICAgIG5leHRFbCxcbiAgICBsYXN0RG93bkVsLFxuICAgIGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW4sXG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgYWN0aXZlR3JvdXAsXG4gICAgcHV0U29ydGFibGUsXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlLFxuICAgIHNvcnRhYmxlcyA9IFtdLFxuICAgIHRhcEV2dCxcbiAgICB0b3VjaEV2dCxcbiAgICBsYXN0RHgsXG4gICAgbGFzdER5LFxuICAgIHRhcERpc3RhbmNlTGVmdCxcbiAgICB0YXBEaXN0YW5jZVRvcCxcbiAgICBtb3ZlZCxcbiAgICBsYXN0VGFyZ2V0LFxuICAgIGxhc3REaXJlY3Rpb24sXG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2UsXG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlLFxuICAgIHRhcmdldE1vdmVEaXN0YW5jZSxcbiAgICAvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxuZ2hvc3RSZWxhdGl2ZVBhcmVudCxcbiAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IFtdLFxuICAgIC8vIChsZWZ0LCB0b3ApXG5fc2lsZW50ID0gZmFsc2UsXG4gICAgc2F2ZWRJbnB1dENoZWNrZWQgPSBbXTtcbi8qKiBAY29uc3QgKi9cblxudmFyIGRvY3VtZW50RXhpc3RzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA9IElPUyxcbiAgICBDU1NGbG9hdFByb3BlcnR5ID0gRWRnZSB8fCBJRTExT3JMZXNzID8gJ2Nzc0Zsb2F0JyA6ICdmbG9hdCcsXG4gICAgLy8gVGhpcyB3aWxsIG5vdCBwYXNzIGZvciBJRTksIGJlY2F1c2UgSUU5IERuRCBvbmx5IHdvcmtzIG9uIGFuY2hvcnNcbnN1cHBvcnREcmFnZ2FibGUgPSBkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCAmJiAhSU9TICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWRvY3VtZW50RXhpc3RzKSByZXR1cm47IC8vIGZhbHNlIHdoZW4gPD0gSUUxMVxuXG4gIGlmIChJRTExT3JMZXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xuICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xuICByZXR1cm4gZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xufSgpLFxuICAgIF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCBvcHRpb25zKSB7XG4gIHZhciBlbENTUyA9IGNzcyhlbCksXG4gICAgICBlbFdpZHRoID0gcGFyc2VJbnQoZWxDU1Mud2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ1JpZ2h0KSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlckxlZnRXaWR0aCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICAgIGNoaWxkMSA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zKSxcbiAgICAgIGNoaWxkMiA9IGdldENoaWxkKGVsLCAxLCBvcHRpb25zKSxcbiAgICAgIGZpcnN0Q2hpbGRDU1MgPSBjaGlsZDEgJiYgY3NzKGNoaWxkMSksXG4gICAgICBzZWNvbmRDaGlsZENTUyA9IGNoaWxkMiAmJiBjc3MoY2hpbGQyKSxcbiAgICAgIGZpcnN0Q2hpbGRXaWR0aCA9IGZpcnN0Q2hpbGRDU1MgJiYgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDEpLndpZHRoLFxuICAgICAgc2Vjb25kQ2hpbGRXaWR0aCA9IHNlY29uZENoaWxkQ1NTICYmIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDIpLndpZHRoO1xuXG4gIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICByZXR1cm4gZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbicgfHwgZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2dyaWQnKSB7XG4gICAgcmV0dXJuIGVsQ1NTLmdyaWRUZW1wbGF0ZUNvbHVtbnMuc3BsaXQoJyAnKS5sZW5ndGggPD0gMSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoY2hpbGQxICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gIT09ICdub25lJykge1xuICAgIHZhciB0b3VjaGluZ1NpZGVDaGlsZDIgPSBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgcmV0dXJuIGNoaWxkMiAmJiAoc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09ICdib3RoJyB8fCBzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gdG91Y2hpbmdTaWRlQ2hpbGQyKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICByZXR1cm4gY2hpbGQxICYmIChmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZmxleCcgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAndGFibGUnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8IGZpcnN0Q2hpbGRXaWR0aCA+PSBlbFdpZHRoICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgfHwgY2hpbGQyICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgJiYgZmlyc3RDaGlsZFdpZHRoICsgc2Vjb25kQ2hpbGRXaWR0aCA+IGVsV2lkdGgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbn0sXG4gICAgX2RyYWdFbEluUm93Q29sdW1uID0gZnVuY3Rpb24gX2RyYWdFbEluUm93Q29sdW1uKGRyYWdSZWN0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCkge1xuICB2YXIgZHJhZ0VsUzFPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LmxlZnQgOiBkcmFnUmVjdC50b3AsXG4gICAgICBkcmFnRWxTMk9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QucmlnaHQgOiBkcmFnUmVjdC5ib3R0b20sXG4gICAgICBkcmFnRWxPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LndpZHRoIDogZHJhZ1JlY3QuaGVpZ2h0LFxuICAgICAgdGFyZ2V0UzFPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxuICAgICAgdGFyZ2V0UzJPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHRhcmdldE9wcExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xuICByZXR1cm4gZHJhZ0VsUzFPcHAgPT09IHRhcmdldFMxT3BwIHx8IGRyYWdFbFMyT3BwID09PSB0YXJnZXRTMk9wcCB8fCBkcmFnRWxTMU9wcCArIGRyYWdFbE9wcExlbmd0aCAvIDIgPT09IHRhcmdldFMxT3BwICsgdGFyZ2V0T3BwTGVuZ3RoIC8gMjtcbn0sXG5cbi8qKlxyXG4gKiBEZXRlY3RzIGZpcnN0IG5lYXJlc3QgZW1wdHkgc29ydGFibGUgdG8gWCBhbmQgWSBwb3NpdGlvbiB1c2luZyBlbXB0eUluc2VydFRocmVzaG9sZC5cclxuICogQHBhcmFtICB7TnVtYmVyfSB4ICAgICAgWCBwb3NpdGlvblxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgICBZIHBvc2l0aW9uXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgIEVsZW1lbnQgb2YgdGhlIGZpcnN0IGZvdW5kIG5lYXJlc3QgU29ydGFibGVcclxuICovXG5fZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUgPSBmdW5jdGlvbiBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoeCwgeSkge1xuICB2YXIgcmV0O1xuICBzb3J0YWJsZXMuc29tZShmdW5jdGlvbiAoc29ydGFibGUpIHtcbiAgICB2YXIgdGhyZXNob2xkID0gc29ydGFibGVbZXhwYW5kb10ub3B0aW9ucy5lbXB0eUluc2VydFRocmVzaG9sZDtcbiAgICBpZiAoIXRocmVzaG9sZCB8fCBsYXN0Q2hpbGQoc29ydGFibGUpKSByZXR1cm47XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KHNvcnRhYmxlKSxcbiAgICAgICAgaW5zaWRlSG9yaXpvbnRhbGx5ID0geCA+PSByZWN0LmxlZnQgLSB0aHJlc2hvbGQgJiYgeCA8PSByZWN0LnJpZ2h0ICsgdGhyZXNob2xkLFxuICAgICAgICBpbnNpZGVWZXJ0aWNhbGx5ID0geSA+PSByZWN0LnRvcCAtIHRocmVzaG9sZCAmJiB5IDw9IHJlY3QuYm90dG9tICsgdGhyZXNob2xkO1xuXG4gICAgaWYgKGluc2lkZUhvcml6b250YWxseSAmJiBpbnNpZGVWZXJ0aWNhbGx5KSB7XG4gICAgICByZXR1cm4gcmV0ID0gc29ydGFibGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJldDtcbn0sXG4gICAgX3ByZXBhcmVHcm91cCA9IGZ1bmN0aW9uIF9wcmVwYXJlR3JvdXAob3B0aW9ucykge1xuICBmdW5jdGlvbiB0b0ZuKHZhbHVlLCBwdWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgZHJhZ0VsLCBldnQpIHtcbiAgICAgIHZhciBzYW1lR3JvdXAgPSB0by5vcHRpb25zLmdyb3VwLm5hbWUgJiYgZnJvbS5vcHRpb25zLmdyb3VwLm5hbWUgJiYgdG8ub3B0aW9ucy5ncm91cC5uYW1lID09PSBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHB1bGwgfHwgc2FtZUdyb3VwKSkge1xuICAgICAgICAvLyBEZWZhdWx0IHB1bGwgdmFsdWVcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIGFuZCBwdXQgdmFsdWUgaWYgc2FtZSBncm91cFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwdWxsICYmIHZhbHVlID09PSAnY2xvbmUnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0b0ZuKHZhbHVlKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCksIHB1bGwpKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3RoZXJHcm91cCA9IChwdWxsID8gdG8gOiBmcm9tKS5vcHRpb25zLmdyb3VwLm5hbWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBvdGhlckdyb3VwIHx8IHZhbHVlLmpvaW4gJiYgdmFsdWUuaW5kZXhPZihvdGhlckdyb3VwKSA+IC0xO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgZ3JvdXAgPSB7fTtcbiAgdmFyIG9yaWdpbmFsR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuXG4gIGlmICghb3JpZ2luYWxHcm91cCB8fCBfdHlwZW9mKG9yaWdpbmFsR3JvdXApICE9ICdvYmplY3QnKSB7XG4gICAgb3JpZ2luYWxHcm91cCA9IHtcbiAgICAgIG5hbWU6IG9yaWdpbmFsR3JvdXBcbiAgICB9O1xuICB9XG5cbiAgZ3JvdXAubmFtZSA9IG9yaWdpbmFsR3JvdXAubmFtZTtcbiAgZ3JvdXAuY2hlY2tQdWxsID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1bGwsIHRydWUpO1xuICBncm91cC5jaGVja1B1dCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdXQpO1xuICBncm91cC5yZXZlcnRDbG9uZSA9IG9yaWdpbmFsR3JvdXAucmV2ZXJ0Q2xvbmU7XG4gIG9wdGlvbnMuZ3JvdXAgPSBncm91cDtcbn0sXG4gICAgX2hpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF9oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgIGNzcyhnaG9zdEVsLCAnZGlzcGxheScsICdub25lJyk7XG4gIH1cbn0sXG4gICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnJyk7XG4gIH1cbn07IC8vICMxMTg0IGZpeCAtIFByZXZlbnQgY2xpY2sgZXZlbnQgb24gZmFsbGJhY2sgaWYgZHJhZ2dlZCBidXQgaXRlbSBub3QgY2hhbmdlZCBwb3NpdGlvblxuXG5cbmlmIChkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoaWdub3JlTmV4dENsaWNrKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuXG52YXIgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQgPSBmdW5jdGlvbiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpIHtcbiAgaWYgKGRyYWdFbCkge1xuICAgIGV2dCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQ7XG5cbiAgICB2YXIgbmVhcmVzdCA9IF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZShldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgaWYgKG5lYXJlc3QpIHtcbiAgICAgIC8vIENyZWF0ZSBpbWl0YXRpb24gZXZlbnRcbiAgICAgIHZhciBldmVudCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIGV2dCkge1xuICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgZXZlbnRbaV0gPSBldnRbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQucm9vdEVsID0gbmVhcmVzdDtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gdm9pZCAwO1xuXG4gICAgICBuZWFyZXN0W2V4cGFuZG9dLl9vbkRyYWdPdmVyKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwgPSBmdW5jdGlvbiBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBkcmFnRWwucGFyZW50Tm9kZVtleHBhbmRvXS5faXNPdXRzaWRlVGhpc0VsKGV2dC50YXJnZXQpO1xuICB9XG59O1xuLyoqXHJcbiAqIEBjbGFzcyAgU29ydGFibGVcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIFtvcHRpb25zXVxyXG4gKi9cblxuXG5mdW5jdGlvbiBTb3J0YWJsZShlbCwgb3B0aW9ucykge1xuICBpZiAoIShlbCAmJiBlbC5ub2RlVHlwZSAmJiBlbC5ub2RlVHlwZSA9PT0gMSkpIHtcbiAgICB0aHJvdyBcIlNvcnRhYmxlOiBgZWxgIG11c3QgYmUgYW4gSFRNTEVsZW1lbnQsIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChlbCkpO1xuICB9XG5cbiAgdGhpcy5lbCA9IGVsOyAvLyByb290IGVsZW1lbnRcblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpOyAvLyBFeHBvcnQgaW5zdGFuY2VcblxuICBlbFtleHBhbmRvXSA9IHRoaXM7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBncm91cDogbnVsbCxcbiAgICBzb3J0OiB0cnVlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBzdG9yZTogbnVsbCxcbiAgICBoYW5kbGU6IG51bGwsXG4gICAgZHJhZ2dhYmxlOiAvXlt1b11sJC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJz5saScgOiAnPionLFxuICAgIHN3YXBUaHJlc2hvbGQ6IDEsXG4gICAgLy8gcGVyY2VudGFnZTsgMCA8PSB4IDw9IDFcbiAgICBpbnZlcnRTd2FwOiBmYWxzZSxcbiAgICAvLyBpbnZlcnQgYWx3YXlzXG4gICAgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkOiBudWxsLFxuICAgIC8vIHdpbGwgYmUgc2V0IHRvIHNhbWUgYXMgc3dhcFRocmVzaG9sZCBpZiBkZWZhdWx0XG4gICAgcmVtb3ZlQ2xvbmVPbkhpZGU6IHRydWUsXG4gICAgZGlyZWN0aW9uOiBmdW5jdGlvbiBkaXJlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2RldGVjdERpcmVjdGlvbihlbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICAgIGdob3N0Q2xhc3M6ICdzb3J0YWJsZS1naG9zdCcsXG4gICAgY2hvc2VuQ2xhc3M6ICdzb3J0YWJsZS1jaG9zZW4nLFxuICAgIGRyYWdDbGFzczogJ3NvcnRhYmxlLWRyYWcnLFxuICAgIGlnbm9yZTogJ2EsIGltZycsXG4gICAgZmlsdGVyOiBudWxsLFxuICAgIHByZXZlbnRPbkZpbHRlcjogdHJ1ZSxcbiAgICBhbmltYXRpb246IDAsXG4gICAgZWFzaW5nOiBudWxsLFxuICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKCdUZXh0JywgZHJhZ0VsLnRleHRDb250ZW50KTtcbiAgICB9LFxuICAgIGRyb3BCdWJibGU6IGZhbHNlLFxuICAgIGRyYWdvdmVyQnViYmxlOiBmYWxzZSxcbiAgICBkYXRhSWRBdHRyOiAnZGF0YS1pZCcsXG4gICAgZGVsYXk6IDAsXG4gICAgZGVsYXlPblRvdWNoT25seTogZmFsc2UsXG4gICAgdG91Y2hTdGFydFRocmVzaG9sZDogKE51bWJlci5wYXJzZUludCA/IE51bWJlciA6IHdpbmRvdykucGFyc2VJbnQod2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEwKSB8fCAxLFxuICAgIGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxuICAgIGZhbGxiYWNrQ2xhc3M6ICdzb3J0YWJsZS1mYWxsYmFjaycsXG4gICAgZmFsbGJhY2tPbkJvZHk6IGZhbHNlLFxuICAgIGZhbGxiYWNrVG9sZXJhbmNlOiAwLFxuICAgIGZhbGxiYWNrT2Zmc2V0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgc3VwcG9ydFBvaW50ZXI6IFNvcnRhYmxlLnN1cHBvcnRQb2ludGVyICE9PSBmYWxzZSAmJiAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3cgJiYgIVNhZmFyaSxcbiAgICBlbXB0eUluc2VydFRocmVzaG9sZDogNVxuICB9O1xuICBQbHVnaW5NYW5hZ2VyLmluaXRpYWxpemVQbHVnaW5zKHRoaXMsIGVsLCBkZWZhdWx0cyk7IC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgIShuYW1lIGluIG9wdGlvbnMpICYmIChvcHRpb25zW25hbWVdID0gZGVmYXVsdHNbbmFtZV0pO1xuICB9XG5cbiAgX3ByZXBhcmVHcm91cChvcHRpb25zKTsgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG5cblxuICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfSAvLyBTZXR1cCBkcmFnIG1vZGVcblxuXG4gIHRoaXMubmF0aXZlRHJhZ2dhYmxlID0gb3B0aW9ucy5mb3JjZUZhbGxiYWNrID8gZmFsc2UgOiBzdXBwb3J0RHJhZ2dhYmxlO1xuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIC8vIFRvdWNoIHN0YXJ0IHRocmVzaG9sZCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBuYXRpdmUgZHJhZ3N0YXJ0IHRocmVzaG9sZFxuICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gMTtcbiAgfSAvLyBCaW5kIGV2ZW50c1xuXG5cbiAgaWYgKG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICBvbihlbCwgJ3BvaW50ZXJkb3duJywgdGhpcy5fb25UYXBTdGFydCk7XG4gIH0gZWxzZSB7XG4gICAgb24oZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfVxuXG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIG9uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICBvbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICB9XG5cbiAgc29ydGFibGVzLnB1c2godGhpcy5lbCk7IC8vIFJlc3RvcmUgc29ydGluZ1xuXG4gIG9wdGlvbnMuc3RvcmUgJiYgb3B0aW9ucy5zdG9yZS5nZXQgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpIHx8IFtdKTsgLy8gQWRkIGFuaW1hdGlvbiBzdGF0ZSBtYW5hZ2VyXG5cbiAgX2V4dGVuZHModGhpcywgQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkpO1xufVxuXG5Tb3J0YWJsZS5wcm90b3R5cGUgPVxuLyoqIEBsZW5kcyBTb3J0YWJsZS5wcm90b3R5cGUgKi9cbntcbiAgY29uc3RydWN0b3I6IFNvcnRhYmxlLFxuICBfaXNPdXRzaWRlVGhpc0VsOiBmdW5jdGlvbiBfaXNPdXRzaWRlVGhpc0VsKHRhcmdldCkge1xuICAgIGlmICghdGhpcy5lbC5jb250YWlucyh0YXJnZXQpICYmIHRhcmdldCAhPT0gdGhpcy5lbCkge1xuICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9LFxuICBfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RGlyZWN0aW9uKGV2dCwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcHRpb25zLmRpcmVjdGlvbi5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCBkcmFnRWwpIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcbiAgfSxcbiAgX29uVGFwU3RhcnQ6IGZ1bmN0aW9uIF9vblRhcFN0YXJ0KFxuICAvKiogRXZlbnR8VG91Y2hFdmVudCAqL1xuICBldnQpIHtcbiAgICBpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm47XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBlbCA9IHRoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHByZXZlbnRPbkZpbHRlciA9IG9wdGlvbnMucHJldmVudE9uRmlsdGVyLFxuICAgICAgICB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICAgIHRvdWNoID0gZXZ0LnRvdWNoZXMgJiYgZXZ0LnRvdWNoZXNbMF0gfHwgZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyAmJiBldnQsXG4gICAgICAgIHRhcmdldCA9ICh0b3VjaCB8fCBldnQpLnRhcmdldCxcbiAgICAgICAgb3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKGV2dC5wYXRoICYmIGV2dC5wYXRoWzBdIHx8IGV2dC5jb21wb3NlZFBhdGggJiYgZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCB0YXJnZXQsXG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXG4gICAgX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShlbCk7IC8vIERvbid0IHRyaWdnZXIgc3RhcnQgZXZlbnQgd2hlbiBhbiBlbGVtZW50IGlzIGJlZW4gZHJhZ2dlZCwgb3RoZXJ3aXNlIHRoZSBldnQub2xkaW5kZXggYWx3YXlzIHdyb25nIHdoZW4gc2V0IG9wdGlvbi5ncm91cC5cblxuXG4gICAgaWYgKGRyYWdFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgvbW91c2Vkb3dufHBvaW50ZXJkb3duLy50ZXN0KHR5cGUpICYmIGV2dC5idXR0b24gIT09IDAgfHwgb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIGFuZCBlbmFibGVkXG4gICAgfSAvLyBjYW5jZWwgZG5kIGlmIG9yaWdpbmFsIHRhcmdldCBpcyBjb250ZW50IGVkaXRhYmxlXG5cblxuICAgIGlmIChvcmlnaW5hbFRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU2FmYXJpIGlnbm9yZXMgZnVydGhlciBldmVudCBoYW5kbGluZyBhZnRlciBtb3VzZWRvd25cblxuXG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiBTYWZhcmkgJiYgdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTRUxFQ1QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpO1xuXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGFzdERvd25FbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyBJZ25vcmluZyBkdXBsaWNhdGUgYGRvd25gXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblxuXG4gICAgb2xkSW5kZXggPSBpbmRleCh0YXJnZXQpO1xuICAgIG9sZERyYWdnYWJsZUluZGV4ID0gaW5kZXgodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSk7IC8vIENoZWNrIGZpbHRlclxuXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzLCBldnQsIHRhcmdldCwgdGhpcykpIHtcbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICByb290RWw6IG9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgdG9FbDogZWwsXG4gICAgICAgICAgZnJvbUVsOiBlbFxuICAgICAgICB9KTtcblxuICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgZmlsdGVyID0gZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgY3JpdGVyaWEgPSBjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGNyaXRlcmlhKSB7XG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgICAgcm9vdEVsOiBjcml0ZXJpYSxcbiAgICAgICAgICAgIG5hbWU6ICdmaWx0ZXInLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICB0b0VsOiBlbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcGx1Z2luRXZlbnQoJ2ZpbHRlcicsIF90aGlzLCB7XG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZSAmJiAhY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgb3B0aW9ucy5oYW5kbGUsIGVsLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFByZXBhcmUgYGRyYWdzdGFydGBcblxuXG4gICAgdGhpcy5fcHJlcGFyZURyYWdTdGFydChldnQsIHRvdWNoLCB0YXJnZXQpO1xuICB9LFxuICBfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gX3ByZXBhcmVEcmFnU3RhcnQoXG4gIC8qKiBFdmVudCAqL1xuICBldnQsXG4gIC8qKiBUb3VjaCAqL1xuICB0b3VjaCxcbiAgLyoqIEhUTUxFbGVtZW50ICovXG4gIHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGVsID0gX3RoaXMuZWwsXG4gICAgICAgIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICBvd25lckRvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgZHJhZ1N0YXJ0Rm47XG5cbiAgICBpZiAodGFyZ2V0ICYmICFkcmFnRWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICByb290RWwgPSBlbDtcbiAgICAgIGRyYWdFbCA9IHRhcmdldDtcbiAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7XG4gICAgICBuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XG4gICAgICBsYXN0RG93bkVsID0gdGFyZ2V0O1xuICAgICAgYWN0aXZlR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuICAgICAgU29ydGFibGUuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgICAgIHRhcEV2dCA9IHtcbiAgICAgICAgdGFyZ2V0OiBkcmFnRWwsXG4gICAgICAgIGNsaWVudFg6ICh0b3VjaCB8fCBldnQpLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6ICh0b3VjaCB8fCBldnQpLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB0YXBEaXN0YW5jZUxlZnQgPSB0YXBFdnQuY2xpZW50WCAtIGRyYWdSZWN0LmxlZnQ7XG4gICAgICB0YXBEaXN0YW5jZVRvcCA9IHRhcEV2dC5jbGllbnRZIC0gZHJhZ1JlY3QudG9wO1xuICAgICAgdGhpcy5fbGFzdFggPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRZO1xuICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XG5cbiAgICAgIGRyYWdTdGFydEZuID0gZnVuY3Rpb24gZHJhZ1N0YXJ0Rm4oKSB7XG4gICAgICAgIHBsdWdpbkV2ZW50KCdkZWxheUVuZGVkJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIF90aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBEZWxheWVkIGRyYWcgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAgIC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxuXG5cbiAgICAgICAgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgICAgIGlmICghRmlyZUZveCAmJiBfdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG5cblxuICAgICAgICBfdGhpcy5fdHJpZ2dlckRyYWdTdGFydChldnQsIHRvdWNoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICBuYW1lOiAnY2hvb3NlJyxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7IC8vIENob3NlbiBpdGVtXG5cblxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuY2hvc2VuQ2xhc3MsIHRydWUpO1xuICAgICAgfTsgLy8gRGlzYWJsZSBcImRyYWdnYWJsZVwiXG5cblxuICAgICAgb3B0aW9ucy5pZ25vcmUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICBmaW5kKGRyYWdFbCwgY3JpdGVyaWEudHJpbSgpLCBfZGlzYWJsZURyYWdnYWJsZSk7XG4gICAgICB9KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7IC8vIE1ha2UgZHJhZ0VsIGRyYWdnYWJsZSAobXVzdCBiZSBiZWZvcmUgZGVsYXkgZm9yIEZpcmVGb3gpXG5cbiAgICAgIGlmIChGaXJlRm94ICYmIHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gNDtcbiAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbkV2ZW50KCdkZWxheVN0YXJ0JywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7IC8vIERlbGF5IGlzIGltcG9zc2libGUgZm9yIG5hdGl2ZSBEbkQgaW4gRWRnZSBvciBJRVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAmJiAoIW9wdGlvbnMuZGVsYXlPblRvdWNoT25seSB8fCB0b3VjaCkgJiYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCAhKEVkZ2UgfHwgSUUxMU9yTGVzcykpKSB7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgb3IgbGV0IGdvIHRoZSBjbGljayBvciB0b3VjaFxuICAgICAgICAvLyBiZWZvcmUgdGhlIGRlbGF5IGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xuXG5cbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgb3B0aW9ucy5zdXBwb3J0UG9pbnRlciAmJiBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgX3RoaXMuX2RyYWdTdGFydFRpbWVyID0gc2V0VGltZW91dChkcmFnU3RhcnRGbiwgb3B0aW9ucy5kZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnU3RhcnRGbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcjogZnVuY3Rpb24gX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcihcbiAgLyoqIFRvdWNoRXZlbnR8UG9pbnRlckV2ZW50ICoqL1xuICBlKSB7XG4gICAgdmFyIHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcblxuICAgIGlmIChNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA+PSBNYXRoLmZsb29yKHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkIC8gKHRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSkge1xuICAgICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKCk7XG4gICAgfVxuICB9LFxuICBfZGlzYWJsZURlbGF5ZWREcmFnOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnKCkge1xuICAgIGRyYWdFbCAmJiBfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50czogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gIH0sXG4gIF90cmlnZ2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfdHJpZ2dlckRyYWdTdGFydChcbiAgLyoqIEV2ZW50ICovXG4gIGV2dCxcbiAgLyoqIFRvdWNoICovXG4gIHRvdWNoKSB7XG4gICAgdG91Y2ggPSB0b3VjaCB8fCBldnQucG9pbnRlclR5cGUgPT0gJ3RvdWNoJyAmJiBldnQ7XG5cbiAgICBpZiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8IHRvdWNoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN1cHBvcnRQb2ludGVyKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRvdWNoKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcbiAgICAgIG9uKHJvb3RFbCwgJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgICAgICAvLyBUaW1lb3V0IG5lY2Nlc3NhcnkgZm9yIElFOVxuICAgICAgICBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0sXG4gIF9kcmFnU3RhcnRlZDogZnVuY3Rpb24gX2RyYWdTdGFydGVkKGZhbGxiYWNrLCBldnQpIHtcblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb290RWwgJiYgZHJhZ0VsKSB7XG4gICAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0ZWQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnZHJhZ292ZXInLCBfY2hlY2tPdXRzaWRlVGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gQXBwbHkgZWZmZWN0XG5cbiAgICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCBmYWxzZSk7XG4gICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgdHJ1ZSk7XG4gICAgICBTb3J0YWJsZS5hY3RpdmUgPSB0aGlzO1xuICAgICAgZmFsbGJhY2sgJiYgdGhpcy5fYXBwZW5kR2hvc3QoKTsgLy8gRHJhZyBzdGFydCBldmVudFxuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICBuYW1lOiAnc3RhcnQnLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9udWxsaW5nKCk7XG4gICAgfVxuICB9LFxuICBfZW11bGF0ZURyYWdPdmVyOiBmdW5jdGlvbiBfZW11bGF0ZURyYWdPdmVyKCkge1xuICAgIGlmICh0b3VjaEV2dCkge1xuICAgICAgdGhpcy5fbGFzdFggPSB0b3VjaEV2dC5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSB0b3VjaEV2dC5jbGllbnRZO1xuXG4gICAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG5cbiAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgdmFyIHBhcmVudCA9IHRhcmdldDtcblxuICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQuc2hhZG93Um9vdCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHRvdWNoRXZ0LmNsaWVudFgsIHRvdWNoRXZ0LmNsaWVudFkpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBwYXJlbnQpIGJyZWFrO1xuICAgICAgICBwYXJlbnQgPSB0YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwodGFyZ2V0KTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHBhcmVudFtleHBhbmRvXSkge1xuICAgICAgICAgICAgdmFyIGluc2VydGVkID0gdm9pZCAwO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBwYXJlbnRbZXhwYW5kb10uX29uRHJhZ092ZXIoe1xuICAgICAgICAgICAgICBjbGllbnRYOiB0b3VjaEV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaEV2dC5jbGllbnRZLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgcm9vdEVsOiBwYXJlbnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaW5zZXJ0ZWQgJiYgIXRoaXMub3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQ7IC8vIHN0b3JlIGxhc3QgZWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gICAgfVxuICB9LFxuICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIF9vblRvdWNoTW92ZShcbiAgLyoqVG91Y2hFdmVudCovXG4gIGV2dCkge1xuICAgIGlmICh0YXBFdnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGZhbGxiYWNrVG9sZXJhbmNlID0gb3B0aW9ucy5mYWxsYmFja1RvbGVyYW5jZSxcbiAgICAgICAgICBmYWxsYmFja09mZnNldCA9IG9wdGlvbnMuZmFsbGJhY2tPZmZzZXQsXG4gICAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0LFxuICAgICAgICAgIGdob3N0TWF0cml4ID0gZ2hvc3RFbCAmJiBtYXRyaXgoZ2hvc3RFbCwgdHJ1ZSksXG4gICAgICAgICAgc2NhbGVYID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguZCxcbiAgICAgICAgICByZWxhdGl2ZVNjcm9sbE9mZnNldCA9IFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgJiYgZ2V0UmVsYXRpdmVTY3JvbGxPZmZzZXQoZ2hvc3RSZWxhdGl2ZVBhcmVudCksXG4gICAgICAgICAgZHggPSAodG91Y2guY2xpZW50WCAtIHRhcEV2dC5jbGllbnRYICsgZmFsbGJhY2tPZmZzZXQueCkgLyAoc2NhbGVYIHx8IDEpICsgKHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID8gcmVsYXRpdmVTY3JvbGxPZmZzZXRbMF0gLSBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbFswXSA6IDApIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICBkeSA9ICh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkgKyBmYWxsYmFja09mZnNldC55KSAvIChzY2FsZVkgfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFsxXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzFdIDogMCkgLyAoc2NhbGVZIHx8IDEpOyAvLyBvbmx5IHNldCB0aGUgc3RhdHVzIHRvIGRyYWdnaW5nLCB3aGVuIHdlIGFyZSBhY3R1YWxseSBkcmFnZ2luZ1xuXG4gICAgICBpZiAoIVNvcnRhYmxlLmFjdGl2ZSAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICBpZiAoZmFsbGJhY2tUb2xlcmFuY2UgJiYgTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPCBmYWxsYmFja1RvbGVyYW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uRHJhZ1N0YXJ0KGV2dCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnaG9zdEVsKSB7XG4gICAgICAgIGlmIChnaG9zdE1hdHJpeCkge1xuICAgICAgICAgIGdob3N0TWF0cml4LmUgKz0gZHggLSAobGFzdER4IHx8IDApO1xuICAgICAgICAgIGdob3N0TWF0cml4LmYgKz0gZHkgLSAobGFzdER5IHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0TWF0cml4ID0ge1xuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgZDogMSxcbiAgICAgICAgICAgIGU6IGR4LFxuICAgICAgICAgICAgZjogZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzc01hdHJpeCA9IFwibWF0cml4KFwiLmNvbmNhdChnaG9zdE1hdHJpeC5hLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmIsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYywgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5kLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmUsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZiwgXCIpXCIpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3dlYmtpdFRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbW96VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtc1RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgbGFzdER4ID0gZHg7XG4gICAgICAgIGxhc3REeSA9IGR5O1xuICAgICAgICB0b3VjaEV2dCA9IHRvdWNoO1xuICAgICAgfVxuXG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG4gIF9hcHBlbmRHaG9zdDogZnVuY3Rpb24gX2FwcGVuZEdob3N0KCkge1xuICAgIC8vIEJ1ZyBpZiB1c2luZyBzY2FsZSgpOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3MDU4XG4gICAgLy8gTm90IGJlaW5nIGFkanVzdGVkIGZvclxuICAgIGlmICghZ2hvc3RFbCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5mYWxsYmFja09uQm9keSA/IGRvY3VtZW50LmJvZHkgOiByb290RWwsXG4gICAgICAgICAgcmVjdCA9IGdldFJlY3QoZHJhZ0VsLCB0cnVlLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSwgdHJ1ZSwgY29udGFpbmVyKSxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBQb3NpdGlvbiBhYnNvbHV0ZWx5XG5cbiAgICAgIGlmIChQb3NpdGlvbkdob3N0QWJzb2x1dGVseSkge1xuICAgICAgICAvLyBHZXQgcmVsYXRpdmVseSBwb3NpdGlvbmVkIHBhcmVudFxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gY29udGFpbmVyO1xuXG4gICAgICAgIHdoaWxlIChjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnICYmIGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAndHJhbnNmb3JtJykgPT09ICdub25lJyAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnaG9zdFJlbGF0aXZlUGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZ2hvc3RSZWxhdGl2ZVBhcmVudCA9PT0gZG9jdW1lbnQpIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgICAgcmVjdC50b3AgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgcmVjdC5sZWZ0ICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwgPSBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgZ2hvc3RFbCA9IGRyYWdFbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnYm94LXNpemluZycsICdib3JkZXItYm94Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ21hcmdpbicsIDApO1xuICAgICAgY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICAgICAgY3NzKGdob3N0RWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICAgICAgY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ29wYWNpdHknLCAnMC44Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3Bvc2l0aW9uJywgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3pJbmRleCcsICcxMDAwMDAnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAncG9pbnRlckV2ZW50cycsICdub25lJyk7XG4gICAgICBTb3J0YWJsZS5naG9zdCA9IGdob3N0RWw7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2hvc3RFbCk7IC8vIFNldCB0cmFuc2Zvcm0tb3JpZ2luXG5cbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtLW9yaWdpbicsIHRhcERpc3RhbmNlTGVmdCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUud2lkdGgpICogMTAwICsgJyUgJyArIHRhcERpc3RhbmNlVG9wIC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS5oZWlnaHQpICogMTAwICsgJyUnKTtcbiAgICB9XG4gIH0sXG4gIF9vbkRyYWdTdGFydDogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KFxuICAvKipFdmVudCovXG4gIGV2dCxcbiAgLyoqYm9vbGVhbiovXG4gIGZhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldnQuZGF0YVRyYW5zZmVyO1xuICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0JywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcblxuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsdWdpbkV2ZW50KCdzZXR1cENsb25lJywgdGhpcyk7XG5cbiAgICBpZiAoIVNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIGNsb25lRWwgPSBjbG9uZShkcmFnRWwpO1xuICAgICAgY2xvbmVFbC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgIGNsb25lRWwuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICBjbG9uZUVsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG5cbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICB0b2dnbGVDbGFzcyhjbG9uZUVsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIFNvcnRhYmxlLmNsb25lID0gY2xvbmVFbDtcbiAgICB9IC8vICMxMTQzOiBJRnJhbWUgc3VwcG9ydCB3b3JrYXJvdW5kXG5cblxuICAgIF90aGlzLmNsb25lSWQgPSBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2Nsb25lJywgX3RoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcblxuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2Nsb25lJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpOyAvLyBTZXQgcHJvcGVyIGRyb3AgZXZlbnRzXG5cbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIGlnbm9yZU5leHRDbGljayA9IHRydWU7XG4gICAgICBfdGhpcy5fbG9vcElkID0gc2V0SW50ZXJ2YWwoX3RoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHdoYXQgd2FzIHNldCBpbiBfcHJlcGFyZURyYWdTdGFydCBiZWZvcmUgZHJhZyBzdGFydGVkXG4gICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcblxuICAgICAgaWYgKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcbiAgICAgICAgb3B0aW9ucy5zZXREYXRhICYmIG9wdGlvbnMuc2V0RGF0YS5jYWxsKF90aGlzLCBkYXRhVHJhbnNmZXIsIGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIG9uKGRvY3VtZW50LCAnZHJvcCcsIF90aGlzKTsgLy8gIzEyNzYgZml4OlxuXG4gICAgICBjc3MoZHJhZ0VsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVooMCknKTtcbiAgICB9XG5cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICBfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkLmJpbmQoX3RoaXMsIGZhbGxiYWNrLCBldnQpKTtcbiAgICBvbihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgX3RoaXMpO1xuICAgIG1vdmVkID0gdHJ1ZTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJucyB0cnVlIC0gaWYgbm8gZnVydGhlciBhY3Rpb24gaXMgbmVlZGVkIChlaXRoZXIgaW5zZXJ0ZWQgb3IgYW5vdGhlciBjb25kaXRpb24pXG4gIF9vbkRyYWdPdmVyOiBmdW5jdGlvbiBfb25EcmFnT3ZlcihcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgcmV2ZXJ0LFxuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBncm91cCA9IG9wdGlvbnMuZ3JvdXAsXG4gICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gU29ydGFibGUuYWN0aXZlLFxuICAgICAgICBpc093bmVyID0gYWN0aXZlR3JvdXAgPT09IGdyb3VwLFxuICAgICAgICBjYW5Tb3J0ID0gb3B0aW9ucy5zb3J0LFxuICAgICAgICBmcm9tU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCBhY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgdmVydGljYWwsXG4gICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgY29tcGxldGVkRmlyZWQgPSBmYWxzZTtcblxuICAgIGlmIChfc2lsZW50KSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBkcmFnT3ZlckV2ZW50KG5hbWUsIGV4dHJhKSB7XG4gICAgICBwbHVnaW5FdmVudChuYW1lLCBfdGhpcywgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgaXNPd25lcjogaXNPd25lcixcbiAgICAgICAgYXhpczogdmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICByZXZlcnQ6IHJldmVydCxcbiAgICAgICAgZHJhZ1JlY3Q6IGRyYWdSZWN0LFxuICAgICAgICB0YXJnZXRSZWN0OiB0YXJnZXRSZWN0LFxuICAgICAgICBjYW5Tb3J0OiBjYW5Tb3J0LFxuICAgICAgICBmcm9tU29ydGFibGU6IGZyb21Tb3J0YWJsZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZSh0YXJnZXQsIGFmdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCBnZXRSZWN0KHRhcmdldCksIGV2dCwgYWZ0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjaGFuZ2VkOiBjaGFuZ2VkXG4gICAgICB9LCBleHRyYSkpO1xuICAgIH0gLy8gQ2FwdHVyZSBhbmltYXRpb24gc3RhdGVcblxuXG4gICAgZnVuY3Rpb24gY2FwdHVyZSgpIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZScpO1xuXG4gICAgICBfdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgZnJvbVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJuIGludm9jYXRpb24gd2hlbiBkcmFnRWwgaXMgaW5zZXJ0ZWQgKG9yIGNvbXBsZXRlZClcblxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKGluc2VydGlvbikge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJDb21wbGV0ZWQnLCB7XG4gICAgICAgIGluc2VydGlvbjogaW5zZXJ0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKF90aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgLy8gU2V0IGdob3N0IGNsYXNzIHRvIG5ldyBzb3J0YWJsZSdzIGdob3N0IGNsYXNzXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwdXRTb3J0YWJsZSAhPT0gX3RoaXMgJiYgX3RoaXMgIT09IFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3RoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMgPT09IFNvcnRhYmxlLmFjdGl2ZSAmJiBwdXRTb3J0YWJsZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gbnVsbDtcbiAgICAgICAgfSAvLyBBbmltYXRpb25cblxuXG4gICAgICAgIGlmIChmcm9tU29ydGFibGUgPT09IF90aGlzKSB7XG4gICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZScpO1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBmcm9tU29ydGFibGUuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBOdWxsIGxhc3RUYXJnZXQgaWYgaXQgaXMgbm90IGluc2lkZSBhIHByZXZpb3VzbHkgc3dhcHBlZCBlbGVtZW50XG5cblxuICAgICAgaWYgKHRhcmdldCA9PT0gZHJhZ0VsICYmICFkcmFnRWwuYW5pbWF0ZWQgfHwgdGFyZ2V0ID09PSBlbCAmJiAhdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgICAgfSAvLyBubyBidWJibGluZyBhbmQgbm90IGZhbGxiYWNrXG5cblxuICAgICAgaWYgKCFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmICFldnQucm9vdEVsICYmIHRhcmdldCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTsgLy8gRG8gbm90IGRldGVjdCBmb3IgZW1wdHkgaW5zZXJ0IGlmIGFscmVhZHkgaW5zZXJ0ZWRcblxuXG4gICAgICAgICFpbnNlcnRpb24gJiYgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KTtcbiAgICAgIH1cblxuICAgICAgIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gY29tcGxldGVkRmlyZWQgPSB0cnVlO1xuICAgIH0gLy8gQ2FsbCB3aGVuIGRyYWdFbCBoYXMgYmVlbiBpbnNlcnRlZFxuXG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VkKCkge1xuICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjaGFuZ2UnLFxuICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCB0cnVlKTtcbiAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlcicpO1xuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICBpZiAoZHJhZ0VsLmNvbnRhaW5zKGV2dC50YXJnZXQpIHx8IHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQuYW5pbWF0aW5nWCAmJiB0YXJnZXQuYW5pbWF0aW5nWSB8fCBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aXZlU29ydGFibGUgJiYgIW9wdGlvbnMuZGlzYWJsZWQgJiYgKGlzT3duZXIgPyBjYW5Tb3J0IHx8IChyZXZlcnQgPSBwYXJlbnRFbCAhPT0gcm9vdEVsKSAvLyBSZXZlcnRpbmcgaXRlbSBpbnRvIHRoZSBvcmlnaW5hbCBsaXN0XG4gICAgOiBwdXRTb3J0YWJsZSA9PT0gdGhpcyB8fCAodGhpcy5sYXN0UHV0TW9kZSA9IGFjdGl2ZUdyb3VwLmNoZWNrUHVsbCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSAmJiBncm91cC5jaGVja1B1dCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSkge1xuICAgICAgdmVydGljYWwgPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpID09PSAndmVydGljYWwnO1xuICAgICAgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCk7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlclZhbGlkJyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuXG4gICAgICBpZiAocmV2ZXJ0KSB7XG4gICAgICAgIHBhcmVudEVsID0gcm9vdEVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgY2FwdHVyZSgpO1xuXG4gICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuXG4gICAgICAgIGRyYWdPdmVyRXZlbnQoJ3JldmVydCcpO1xuXG4gICAgICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgICAgIGlmIChuZXh0RWwpIHtcbiAgICAgICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0RWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxMYXN0Q2hpbGQgPSBsYXN0Q2hpbGQoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgaWYgKCFlbExhc3RDaGlsZCB8fCBfZ2hvc3RJc0xhc3QoZXZ0LCB2ZXJ0aWNhbCwgdGhpcykgJiYgIWVsTGFzdENoaWxkLmFuaW1hdGVkKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBlbmQgb2YgbGlzdFxuICAgICAgICAvLyBJZiBhbHJlYWR5IGF0IGVuZCBvZiBsaXN0OiBEbyBub3QgaW5zZXJ0XG4gICAgICAgIGlmIChlbExhc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH0gLy8gaWYgdGhlcmUgaXMgYSBsYXN0IGVsZW1lbnQsIGl0IGlzIHRoZSB0YXJnZXRcblxuXG4gICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbCA9PT0gZXZ0LnRhcmdldCkge1xuICAgICAgICAgIHRhcmdldCA9IGVsTGFzdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX29uTW92ZShyb290RWwsIGVsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXQsIHRhcmdldFJlY3QsIGV2dCwgISF0YXJnZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgIGlmIChlbExhc3RDaGlsZCAmJiBlbExhc3RDaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgLy8gdGhlIGxhc3QgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IHRoZSBsYXN0IG5vZGVcbiAgICAgICAgICAgIGVsLmluc2VydEJlZm9yZShkcmFnRWwsIGVsTGFzdENoaWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbExhc3RDaGlsZCAmJiBfZ2hvc3RJc0ZpcnN0KGV2dCwgdmVydGljYWwsIHRoaXMpKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBzdGFydCBvZiBsaXN0XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGlmIChmaXJzdENoaWxkID09PSBkcmFnRWwpIHtcbiAgICAgICAgICByZXR1cm4gY29tcGxldGVkKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG5cbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsIGZhbHNlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgZmlyc3RDaGlsZCk7XG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAwLFxuICAgICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwLFxuICAgICAgICAgICAgZGlmZmVyZW50TGV2ZWwgPSBkcmFnRWwucGFyZW50Tm9kZSAhPT0gZWwsXG4gICAgICAgICAgICBkaWZmZXJlbnRSb3dDb2wgPSAhX2RyYWdFbEluUm93Q29sdW1uKGRyYWdFbC5hbmltYXRlZCAmJiBkcmFnRWwudG9SZWN0IHx8IGRyYWdSZWN0LCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LnRvUmVjdCB8fCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCksXG4gICAgICAgICAgICBzaWRlMSA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgICBzY3JvbGxlZFBhc3RUb3AgPSBpc1Njcm9sbGVkUGFzdCh0YXJnZXQsICd0b3AnLCAndG9wJykgfHwgaXNTY3JvbGxlZFBhc3QoZHJhZ0VsLCAndG9wJywgJ3RvcCcpLFxuICAgICAgICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsZWRQYXN0VG9wID8gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCA6IHZvaWQgMDtcblxuICAgICAgICBpZiAobGFzdFRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwID0gdGFyZ2V0UmVjdFtzaWRlMV07XG4gICAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgICAgICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9ICFkaWZmZXJlbnRSb3dDb2wgJiYgb3B0aW9ucy5pbnZlcnRTd2FwIHx8IGRpZmZlcmVudExldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlyZWN0aW9uID0gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBkaWZmZXJlbnRSb3dDb2wgPyAxIDogb3B0aW9ucy5zd2FwVGhyZXNob2xkLCBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCA9PSBudWxsID8gb3B0aW9ucy5zd2FwVGhyZXNob2xkIDogb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQsIGxhc3RUYXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgIHZhciBzaWJsaW5nO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYmVzaWRlIGRyYWdFbCBpbiByZXNwZWN0aXZlIGRpcmVjdGlvbiAoaWdub3JpbmcgaGlkZGVuIGVsZW1lbnRzKVxuICAgICAgICAgIHZhciBkcmFnSW5kZXggPSBpbmRleChkcmFnRWwpO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZHJhZ0luZGV4IC09IGRpcmVjdGlvbjtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnRFbC5jaGlsZHJlbltkcmFnSW5kZXhdO1xuICAgICAgICAgIH0gd2hpbGUgKHNpYmxpbmcgJiYgKGNzcyhzaWJsaW5nLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2libGluZyA9PT0gZ2hvc3RFbCkpO1xuICAgICAgICB9IC8vIElmIGRyYWdFbCBpcyBhbHJlYWR5IGJlc2lkZSB0YXJnZXQ6IERvIG5vdCBpbnNlcnRcblxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDAgfHwgc2libGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBsYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgYWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgYWZ0ZXIgPSBkaXJlY3Rpb24gPT09IDE7XG5cbiAgICAgICAgdmFyIG1vdmVWZWN0b3IgPSBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBhZnRlcik7XG5cbiAgICAgICAgaWYgKG1vdmVWZWN0b3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG1vdmVWZWN0b3IgPT09IDEgfHwgbW92ZVZlY3RvciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGFmdGVyID0gbW92ZVZlY3RvciA9PT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KF91bnNpbGVudCwgMzApO1xuICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgIGlmIChhZnRlciAmJiAhbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xuICAgICAgICAgIH0gLy8gVW5kbyBjaHJvbWUncyBzY3JvbGwgYWRqdXN0bWVudCAoaGFzIG5vIGVmZmVjdCBvbiBvdGhlciBicm93c2VycylcblxuXG4gICAgICAgICAgaWYgKHNjcm9sbGVkUGFzdFRvcCkge1xuICAgICAgICAgICAgc2Nyb2xsQnkoc2Nyb2xsZWRQYXN0VG9wLCAwLCBzY3JvbGxCZWZvcmUgLSBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlOyAvLyBhY3R1YWxpemF0aW9uXG4gICAgICAgICAgLy8gbXVzdCBiZSBkb25lIGJlZm9yZSBhbmltYXRpb25cblxuICAgICAgICAgIGlmICh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgIT09IHVuZGVmaW5lZCAmJiAhaXNDaXJjdW1zdGFudGlhbEludmVydCkge1xuICAgICAgICAgICAgdGFyZ2V0TW92ZURpc3RhbmNlID0gTWF0aC5hYnModGFyZ2V0QmVmb3JlRmlyc3RTd2FwIC0gZ2V0UmVjdCh0YXJnZXQpW3NpZGUxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVsLmNvbnRhaW5zKGRyYWdFbCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBfaWdub3JlV2hpbGVBbmltYXRpbmc6IG51bGwsXG4gIF9vZmZNb3ZlRXZlbnRzOiBmdW5jdGlvbiBfb2ZmTW92ZUV2ZW50cygpIHtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gIH0sXG4gIF9vZmZVcEV2ZW50czogZnVuY3Rpb24gX29mZlVwRXZlbnRzKCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH0sXG4gIF9vbkRyb3A6IGZ1bmN0aW9uIF9vbkRyb3AoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBwbHVnaW5FdmVudCgnZHJvcCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG4gICAgcGFyZW50RWwgPSBkcmFnRWwgJiYgZHJhZ0VsLnBhcmVudE5vZGU7IC8vIEdldCBhZ2FpbiBhZnRlciBwbHVnaW4gZXZlbnRcblxuICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2U7XG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9sb29wSWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5jbG9uZUlkKTtcblxuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7IC8vIFVuYmluZCBldmVudHNcblxuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb2ZmTW92ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5fb2ZmVXBFdmVudHMoKTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnJyk7XG4gICAgfVxuXG4gICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICcnKTtcblxuICAgIGlmIChldnQpIHtcbiAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgIW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGdob3N0RWwgJiYgZ2hvc3RFbC5wYXJlbnROb2RlICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcblxuICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNsb25lKHMpXG4gICAgICAgIGNsb25lRWwgJiYgY2xvbmVFbC5wYXJlbnROb2RlICYmIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcblxuICAgICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJzsgLy8gUmVtb3ZlIGNsYXNzZXNcbiAgICAgICAgLy8gZ2hvc3RDbGFzcyBpcyBhZGRlZCBpbiBkcmFnU3RhcnRlZFxuXG4gICAgICAgIGlmIChtb3ZlZCAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTsgLy8gRHJhZyBzdG9wIGV2ZW50XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgIG5hbWU6ICd1bmNob29zZScsXG4gICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgbmV3SW5kZXg6IG51bGwsXG4gICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG51bGwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyb290RWwgIT09IHBhcmVudEVsKSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIEFkZCBldmVudFxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnYWRkJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBSZW1vdmUgZXZlbnRcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLnNhdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggIT09IG9sZEluZGV4KSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAvLyBkcmFnICYgZHJvcCB3aXRoaW4gdGhlIHNhbWUgbGlzdFxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICAvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICBpZiAobmV3SW5kZXggPT0gbnVsbCB8fCBuZXdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gb2xkSW5kZXg7XG4gICAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBTYXZlIHNvcnRpbmdcblxuXG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9udWxsaW5nKCk7XG4gIH0sXG4gIF9udWxsaW5nOiBmdW5jdGlvbiBfbnVsbGluZygpIHtcbiAgICBwbHVnaW5FdmVudCgnbnVsbGluZycsIHRoaXMpO1xuICAgIHJvb3RFbCA9IGRyYWdFbCA9IHBhcmVudEVsID0gZ2hvc3RFbCA9IG5leHRFbCA9IGNsb25lRWwgPSBsYXN0RG93bkVsID0gY2xvbmVIaWRkZW4gPSB0YXBFdnQgPSB0b3VjaEV2dCA9IG1vdmVkID0gbmV3SW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXggPSBsYXN0VGFyZ2V0ID0gbGFzdERpcmVjdGlvbiA9IHB1dFNvcnRhYmxlID0gYWN0aXZlR3JvdXAgPSBTb3J0YWJsZS5kcmFnZ2VkID0gU29ydGFibGUuZ2hvc3QgPSBTb3J0YWJsZS5jbG9uZSA9IFNvcnRhYmxlLmFjdGl2ZSA9IG51bGw7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IGxhc3REeCA9IGxhc3REeSA9IDA7XG4gIH0sXG4gIGhhbmRsZUV2ZW50OiBmdW5jdGlvbiBoYW5kbGVFdmVudChcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICBjYXNlICdkcm9wJzpcbiAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICB0aGlzLl9vbkRyb3AoZXZ0KTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZHJhZ2VudGVyJzpcbiAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICAgIHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcblxuICAgICAgICAgIF9nbG9iYWxEcmFnT3ZlcihldnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBTZXJpYWxpemVzIHRoZSBpdGVtIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICAgKi9cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgb3JkZXIgPSBbXSxcbiAgICAgICAgZWwsXG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgZWwgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSkpIHtcbiAgICAgICAgb3JkZXIucHVzaChlbC5nZXRBdHRyaWJ1dGUob3B0aW9ucy5kYXRhSWRBdHRyKSB8fCBfZ2VuZXJhdGVJZChlbCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmRlcjtcbiAgfSxcblxuICAvKipcclxuICAgKiBTb3J0cyB0aGUgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcnJheS5cclxuICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gIG9yZGVyICBvcmRlciBvZiB0aGUgaXRlbXNcclxuICAgKi9cbiAgc29ydDogZnVuY3Rpb24gc29ydChvcmRlciwgdXNlQW5pbWF0aW9uKSB7XG4gICAgdmFyIGl0ZW1zID0ge30sXG4gICAgICAgIHJvb3RFbCA9IHRoaXMuZWw7XG4gICAgdGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHZhciBlbCA9IHJvb3RFbC5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHJvb3RFbCwgZmFsc2UpKSB7XG4gICAgICAgIGl0ZW1zW2lkXSA9IGVsO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHVzZUFuaW1hdGlvbiAmJiB0aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VBbmltYXRpb24gJiYgdGhpcy5hbmltYXRlQWxsKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2F2ZSB0aGUgY3VycmVudCBzb3J0aW5nXHJcbiAgICovXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5vcHRpb25zLnN0b3JlO1xuICAgIHN0b3JlICYmIHN0b3JlLnNldCAmJiBzdG9yZS5zZXQodGhpcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxyXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXHJcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxyXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAqL1xuICBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0JDEoZWwsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QoZWwsIHNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuZWwsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQvZ2V0IG9wdGlvblxyXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0gICB7Kn0gICAgICBbdmFsdWVdXHJcbiAgICogQHJldHVybnMgeyp9XHJcbiAgICovXG4gIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gUGx1Z2luTWFuYWdlci5tb2RpZnlPcHRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSBtb2RpZmllZFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBEZXN0cm95XHJcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgcGx1Z2luRXZlbnQoJ2Rlc3Ryb3knLCB0aGlzKTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICBvZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcblxuICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgb2ZmKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICAgIG9mZihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICAgIH0gLy8gUmVtb3ZlIGRyYWdnYWJsZSBhdHRyaWJ1dGVzXG5cblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwucXVlcnlTZWxlY3RvckFsbCgnW2RyYWdnYWJsZV0nKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnYWJsZScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb25Ecm9wKCk7XG5cbiAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMoKTtcblxuICAgIHNvcnRhYmxlcy5zcGxpY2Uoc29ydGFibGVzLmluZGV4T2YodGhpcy5lbCksIDEpO1xuICAgIHRoaXMuZWwgPSBlbCA9IG51bGw7XG4gIH0sXG4gIF9oaWRlQ2xvbmU6IGZ1bmN0aW9uIF9oaWRlQ2xvbmUoKSB7XG4gICAgaWYgKCFjbG9uZUhpZGRlbikge1xuICAgICAgcGx1Z2luRXZlbnQoJ2hpZGVDbG9uZScsIHRoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgX3Nob3dDbG9uZTogZnVuY3Rpb24gX3Nob3dDbG9uZShwdXRTb3J0YWJsZSkge1xuICAgIGlmIChwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSAhPT0gJ2Nsb25lJykge1xuICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdzaG93Q2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47IC8vIHNob3cgY2xvbmUgYXQgZHJhZ0VsIG9yIG9yaWdpbmFsIHBvc2l0aW9uXG5cbiAgICAgIGlmIChkcmFnRWwucGFyZW50Tm9kZSA9PSByb290RWwgJiYgIXRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9IGVsc2UgaWYgKG5leHRFbCkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIG5leHRFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlKGRyYWdFbCwgY2xvbmVFbCk7XG4gICAgICB9XG5cbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfZ2xvYmFsRHJhZ092ZXIoXG4vKipFdmVudCovXG5ldnQpIHtcbiAgaWYgKGV2dC5kYXRhVHJhbnNmZXIpIHtcbiAgICBldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gIH1cblxuICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gX29uTW92ZShmcm9tRWwsIHRvRWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldEVsLCB0YXJnZXRSZWN0LCBvcmlnaW5hbEV2ZW50LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcbiAgdmFyIGV2dCxcbiAgICAgIHNvcnRhYmxlID0gZnJvbUVsW2V4cGFuZG9dLFxuICAgICAgb25Nb3ZlRm4gPSBzb3J0YWJsZS5vcHRpb25zLm9uTW92ZSxcbiAgICAgIHJldFZhbDsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCdtb3ZlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldnQuaW5pdEV2ZW50KCdtb3ZlJywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBldnQudG8gPSB0b0VsO1xuICBldnQuZnJvbSA9IGZyb21FbDtcbiAgZXZ0LmRyYWdnZWQgPSBkcmFnRWw7XG4gIGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xuICBldnQucmVsYXRlZCA9IHRhcmdldEVsIHx8IHRvRWw7XG4gIGV2dC5yZWxhdGVkUmVjdCA9IHRhcmdldFJlY3QgfHwgZ2V0UmVjdCh0b0VsKTtcbiAgZXZ0LndpbGxJbnNlcnRBZnRlciA9IHdpbGxJbnNlcnRBZnRlcjtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gIGlmIChvbk1vdmVGbikge1xuICAgIHJldFZhbCA9IG9uTW92ZUZuLmNhbGwoc29ydGFibGUsIGV2dCwgb3JpZ2luYWxFdmVudCk7XG4gIH1cblxuICByZXR1cm4gcmV0VmFsO1xufVxuXG5mdW5jdGlvbiBfZGlzYWJsZURyYWdnYWJsZShlbCkge1xuICBlbC5kcmFnZ2FibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Vuc2lsZW50KCkge1xuICBfc2lsZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9naG9zdElzRmlyc3QoZXZ0LCB2ZXJ0aWNhbCwgc29ydGFibGUpIHtcbiAgdmFyIHJlY3QgPSBnZXRSZWN0KGdldENoaWxkKHNvcnRhYmxlLmVsLCAwLCBzb3J0YWJsZS5vcHRpb25zLCB0cnVlKSk7XG4gIHZhciBzcGFjZXIgPSAxMDtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPCByZWN0LmxlZnQgLSBzcGFjZXIgfHwgZXZ0LmNsaWVudFkgPCByZWN0LnRvcCAmJiBldnQuY2xpZW50WCA8IHJlY3QucmlnaHQgOiBldnQuY2xpZW50WSA8IHJlY3QudG9wIC0gc3BhY2VyIHx8IGV2dC5jbGllbnRZIDwgcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPCByZWN0LmxlZnQ7XG59XG5cbmZ1bmN0aW9uIF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICB2YXIgcmVjdCA9IGdldFJlY3QobGFzdENoaWxkKHNvcnRhYmxlLmVsLCBzb3J0YWJsZS5vcHRpb25zLmRyYWdnYWJsZSkpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYID4gcmVjdC5yaWdodCArIHNwYWNlciB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPj0gcmVjdC5sZWZ0IDogZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC50b3AgfHwgZXZ0LmNsaWVudFggPD0gcmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IHJlY3QuYm90dG9tICsgc3BhY2VyO1xufVxuXG5mdW5jdGlvbiBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIHN3YXBUaHJlc2hvbGQsIGludmVydGVkU3dhcFRocmVzaG9sZCwgaW52ZXJ0U3dhcCwgaXNMYXN0VGFyZ2V0KSB7XG4gIHZhciBtb3VzZU9uQXhpcyA9IHZlcnRpY2FsID8gZXZ0LmNsaWVudFkgOiBldnQuY2xpZW50WCxcbiAgICAgIHRhcmdldExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5oZWlnaHQgOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgICAgdGFyZ2V0UzEgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QudG9wIDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgICAgdGFyZ2V0UzIgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuYm90dG9tIDogdGFyZ2V0UmVjdC5yaWdodCxcbiAgICAgIGludmVydCA9IGZhbHNlO1xuXG4gIGlmICghaW52ZXJ0U3dhcCkge1xuICAgIC8vIE5ldmVyIGludmVydCBvciBjcmVhdGUgZHJhZ0VsIHNoYWRvdyB3aGVuIHRhcmdldCBtb3ZlbWVuZXQgY2F1c2VzIG1vdXNlIHRvIG1vdmUgcGFzdCB0aGUgZW5kIG9mIHJlZ3VsYXIgc3dhcFRocmVzaG9sZFxuICAgIGlmIChpc0xhc3RUYXJnZXQgJiYgdGFyZ2V0TW92ZURpc3RhbmNlIDwgdGFyZ2V0TGVuZ3RoICogc3dhcFRocmVzaG9sZCkge1xuICAgICAgLy8gbXVsdGlwbGllZCBvbmx5IGJ5IHN3YXBUaHJlc2hvbGQgYmVjYXVzZSBtb3VzZSB3aWxsIGFscmVhZHkgYmUgaW5zaWRlIHRhcmdldCBieSAoMSAtIHRocmVzaG9sZCkgKiB0YXJnZXRMZW5ndGggLyAyXG4gICAgICAvLyBjaGVjayBpZiBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQgb24gc2lkZSBvcHBvc2l0ZSBvZiBsYXN0RGlyZWN0aW9uXG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCAmJiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIDogbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpKSB7XG4gICAgICAgIC8vIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCwgZG8gbm90IHJlc3RyaWN0IGludmVydGVkIHRocmVzaG9sZCB0byBkcmFnRWwgc2hhZG93XG4gICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoKSB7XG4gICAgICAgIC8vIGRyYWdFbCBzaGFkb3cgKHRhcmdldCBtb3ZlIGRpc3RhbmNlIHNoYWRvdylcbiAgICAgICAgaWYgKGxhc3REaXJlY3Rpb24gPT09IDEgPyBtb3VzZU9uQXhpcyA8IHRhcmdldFMxICsgdGFyZ2V0TW92ZURpc3RhbmNlIC8vIG92ZXIgZHJhZ0VsIHNoYWRvd1xuICAgICAgICA6IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRNb3ZlRGlzdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gLWxhc3REaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmVydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ3VsYXJcbiAgICAgIGlmIChtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIgJiYgbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW52ZXJ0ID0gaW52ZXJ0IHx8IGludmVydFN3YXA7XG5cbiAgaWYgKGludmVydCkge1xuICAgIC8vIEludmVydCBvZiByZWd1bGFyXG4gICAgaWYgKG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIHx8IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSB7XG4gICAgICByZXR1cm4gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAvIDIgPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG4vKipcclxuICogR2V0cyB0aGUgZGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWQgcmVsYXRpdmUgdG8gdGFyZ2V0IGluIG9yZGVyIHRvIG1ha2UgaXRcclxuICogc2VlbSB0aGF0IGRyYWdFbCBoYXMgYmVlbiBcImluc2VydGVkXCIgaW50byB0aGF0IGVsZW1lbnQncyBwb3NpdGlvblxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgICAgIFRoZSB0YXJnZXQgd2hvc2UgcG9zaXRpb24gZHJhZ0VsIGlzIGJlaW5nIGluc2VydGVkIGF0XHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcclxuICovXG5cblxuZnVuY3Rpb24gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpIHtcbiAgaWYgKGluZGV4KGRyYWdFbCkgPCBpbmRleCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4vKipcclxuICogR2VuZXJhdGUgaWRcclxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xuICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICAgIGkgPSBzdHIubGVuZ3RoLFxuICAgICAgc3VtID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3VtICs9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIHN1bS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xuICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSAwO1xuICB2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgdmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeC0tKSB7XG4gICAgdmFyIGVsID0gaW5wdXRzW2lkeF07XG4gICAgZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbmV4dFRpY2soZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG59IC8vIEZpeGVkICM5NzM6XG5cblxuaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmICgoU29ydGFibGUuYWN0aXZlIHx8IGF3YWl0aW5nRHJhZ1N0YXJ0ZWQpICYmIGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufSAvLyBFeHBvcnQgdXRpbHNcblxuXG5Tb3J0YWJsZS51dGlscyA9IHtcbiAgb246IG9uLFxuICBvZmY6IG9mZixcbiAgY3NzOiBjc3MsXG4gIGZpbmQ6IGZpbmQsXG4gIGlzOiBmdW5jdGlvbiBpcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gISFjbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwsIGZhbHNlKTtcbiAgfSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgY2xvc2VzdDogY2xvc2VzdCxcbiAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICBjbG9uZTogY2xvbmUsXG4gIGluZGV4OiBpbmRleCxcbiAgbmV4dFRpY2s6IF9uZXh0VGljayxcbiAgY2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGljayxcbiAgZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxuICBnZXRDaGlsZDogZ2V0Q2hpbGRcbn07XG4vKipcclxuICogR2V0IHRoZSBTb3J0YWJsZSBpbnN0YW5jZSBvZiBhbiBlbGVtZW50XHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge1NvcnRhYmxlfHVuZGVmaW5lZH0gICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU29ydGFibGVcclxuICovXG5cblNvcnRhYmxlLmdldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50W2V4cGFuZG9dO1xufTtcbi8qKlxyXG4gKiBNb3VudCBhIHBsdWdpbiB0byBTb3J0YWJsZVxyXG4gKiBAcGFyYW0gIHsuLi5Tb3J0YWJsZVBsdWdpbnxTb3J0YWJsZVBsdWdpbltdfSBwbHVnaW5zICAgICAgIFBsdWdpbnMgYmVpbmcgbW91bnRlZFxyXG4gKi9cblxuXG5Tb3J0YWJsZS5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChwbHVnaW5zWzBdLmNvbnN0cnVjdG9yID09PSBBcnJheSkgcGx1Z2lucyA9IHBsdWdpbnNbMF07XG4gIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgaWYgKCFwbHVnaW4ucHJvdG90eXBlIHx8ICFwbHVnaW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBcIlNvcnRhYmxlOiBNb3VudGVkIHBsdWdpbiBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChwbHVnaW4pKTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luLnV0aWxzKSBTb3J0YWJsZS51dGlscyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBTb3J0YWJsZS51dGlscyksIHBsdWdpbi51dGlscyk7XG4gICAgUGx1Z2luTWFuYWdlci5tb3VudChwbHVnaW4pO1xuICB9KTtcbn07XG4vKipcclxuICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxyXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cclxuICovXG5cblxuU29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xufTsgLy8gRXhwb3J0XG5cblxuU29ydGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5cbnZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICAgIHNjcm9sbEVsLFxuICAgIHNjcm9sbFJvb3RFbCxcbiAgICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgICBsYXN0QXV0b1Njcm9sbFgsXG4gICAgbGFzdEF1dG9TY3JvbGxZLFxuICAgIHRvdWNoRXZ0JDEsXG4gICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvcmNlQXV0b1Njcm9sbEZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgIH07IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAvLyBGb3Igd2hlbiBidWJibGluZyBpcyBjYW5jZWxlZCBhbmQgdXNpbmcgZmFsbGJhY2sgKGZhbGxiYWNrICd0b3VjaG1vdmUnIGFsd2F5cyByZWFjaGVkKVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ092ZXJCdWJibGUgJiYgIW9yaWdpbmFsRXZlbnQucm9vdEVsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwob3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICB0b3VjaEV2dCQxID0gZXZ0OyAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG5cbiAgICAgIGlmIChmYWxsYmFjayB8fCB0aGlzLm9wdGlvbnMuZm9yY2VBdXRvU2Nyb2xsRmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBlbGVtLCBmYWxsYmFjayk7IC8vIExpc3RlbmVyIGZvciBwb2ludGVyIGVsZW1lbnQgY2hhbmdlXG5cbiAgICAgICAgdmFyIG9nRWxlbVNjcm9sbGVyID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGluZyAmJiAoIXBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIHx8IHggIT09IGxhc3RBdXRvU2Nyb2xsWCB8fCB5ICE9PSBsYXN0QXV0b1Njcm9sbFkpKSB7XG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgJiYgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpOyAvLyBEZXRlY3QgZm9yIHBvaW50ZXIgZWxlbSBjaGFuZ2UsIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuXG4gICAgICAgICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3RWxlbSA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSksIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAobmV3RWxlbSAhPT0gb2dFbGVtU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgb2dFbGVtU2Nyb2xsZXIgPSBuZXdFbGVtO1xuICAgICAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCBfdGhpcy5vcHRpb25zLCBuZXdFbGVtLCBmYWxsYmFjayk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWCA9IHg7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxZID0geTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgRG5EIGlzIGVuYWJsZWQgKGFuZCBicm93c2VyIGhhcyBnb29kIGF1dG9zY3JvbGxpbmcpLCBmaXJzdCBhdXRvc2Nyb2xsIHdpbGwgYWxyZWFkeSBzY3JvbGwsIHNvIGdldCBwYXJlbnQgYXV0b3Njcm9sbCBvZiBmaXJzdCBhdXRvc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1YmJsZVNjcm9sbCB8fCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIGZhbHNlKSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKEF1dG9TY3JvbGwsIHtcbiAgICBwbHVnaW5OYW1lOiAnc2Nyb2xsJyxcbiAgICBpbml0aWFsaXplQnlEZWZhdWx0OiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhckF1dG9TY3JvbGxzKCkge1xuICBhdXRvU2Nyb2xscy5mb3JFYWNoKGZ1bmN0aW9uIChhdXRvU2Nyb2xsKSB7XG4gICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG4gIH0pO1xuICBhdXRvU2Nyb2xscyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCkge1xuICBjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcbn1cblxudmFyIGF1dG9TY3JvbGwgPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZ0LCBvcHRpb25zLCByb290RWwsIGlzRmFsbGJhY2spIHtcbiAgLy8gQnVnOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MDU1MjFcbiAgaWYgKCFvcHRpb25zLnNjcm9sbCkgcmV0dXJuO1xuICB2YXIgeCA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRYLFxuICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgc2VucyA9IG9wdGlvbnMuc2Nyb2xsU2Vuc2l0aXZpdHksXG4gICAgICBzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG4gICAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIHNjcm9sbFRoaXNJbnN0YW5jZSA9IGZhbHNlLFxuICAgICAgc2Nyb2xsQ3VzdG9tRm47IC8vIE5ldyBzY3JvbGwgcm9vdCwgc2V0IHNjcm9sbEVsXG5cbiAgaWYgKHNjcm9sbFJvb3RFbCAhPT0gcm9vdEVsKSB7XG4gICAgc2Nyb2xsUm9vdEVsID0gcm9vdEVsO1xuICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICBzY3JvbGxFbCA9IG9wdGlvbnMuc2Nyb2xsO1xuICAgIHNjcm9sbEN1c3RvbUZuID0gb3B0aW9ucy5zY3JvbGxGbjtcblxuICAgIGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xuICAgICAgc2Nyb2xsRWwgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChyb290RWwsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXllcnNPdXQgPSAwO1xuICB2YXIgY3VycmVudFBhcmVudCA9IHNjcm9sbEVsO1xuXG4gIGRvIHtcbiAgICB2YXIgZWwgPSBjdXJyZW50UGFyZW50LFxuICAgICAgICByZWN0ID0gZ2V0UmVjdChlbCksXG4gICAgICAgIHRvcCA9IHJlY3QudG9wLFxuICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0LFxuICAgICAgICBjYW5TY3JvbGxYID0gdm9pZCAwLFxuICAgICAgICBjYW5TY3JvbGxZID0gdm9pZCAwLFxuICAgICAgICBzY3JvbGxXaWR0aCA9IGVsLnNjcm9sbFdpZHRoLFxuICAgICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQsXG4gICAgICAgIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgICAgc2Nyb2xsUG9zWCA9IGVsLnNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFBvc1kgPSBlbC5zY3JvbGxUb3A7XG5cbiAgICBpZiAoZWwgPT09IHdpblNjcm9sbGVyKSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyk7XG4gICAgfVxuXG4gICAgdmFyIHZ4ID0gY2FuU2Nyb2xsWCAmJiAoTWF0aC5hYnMocmlnaHQgLSB4KSA8PSBzZW5zICYmIHNjcm9sbFBvc1ggKyB3aWR0aCA8IHNjcm9sbFdpZHRoKSAtIChNYXRoLmFicyhsZWZ0IC0geCkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1gpO1xuICAgIHZhciB2eSA9IGNhblNjcm9sbFkgJiYgKE1hdGguYWJzKGJvdHRvbSAtIHkpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWSArIGhlaWdodCA8IHNjcm9sbEhlaWdodCkgLSAoTWF0aC5hYnModG9wIC0geSkgPD0gc2VucyAmJiAhIXNjcm9sbFBvc1kpO1xuXG4gICAgaWYgKCFhdXRvU2Nyb2xsc1tsYXllcnNPdXRdKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsYXllcnNPdXQ7IGkrKykge1xuICAgICAgICBpZiAoIWF1dG9TY3JvbGxzW2ldKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbHNbaV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ICE9IHZ4IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgIT0gdnkgfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCAhPT0gZWwpIHtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgPSBlbDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgPSB2eTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQpO1xuXG4gICAgICBpZiAodnggIT0gMCB8fCB2eSAhPSAwKSB7XG4gICAgICAgIHNjcm9sbFRoaXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzp0cnVlICovXG5cbiAgICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZW11bGF0ZSBkcmFnIG92ZXIgZHVyaW5nIGF1dG9zY3JvbGwgKGZhbGxiYWNrKSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG4gICAgICAgICAgaWYgKGlzRmFsbGJhY2sgJiYgdGhpcy5sYXllciA9PT0gMCkge1xuICAgICAgICAgICAgU29ydGFibGUuYWN0aXZlLl9vblRvdWNoTW92ZSh0b3VjaEV2dCQxKTsgLy8gVG8gbW92ZSBnaG9zdCBpZiBpdCBpcyBwb3NpdGlvbmVkIGFic29sdXRlbHlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRZID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSAqIHNwZWVkIDogMDtcbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WCA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggKiBzcGVlZCA6IDA7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbEN1c3RvbUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsQ3VzdG9tRm4uY2FsbChTb3J0YWJsZS5kcmFnZ2VkLnBhcmVudE5vZGVbZXhwYW5kb10sIHNjcm9sbE9mZnNldFgsIHNjcm9sbE9mZnNldFksIGV2dCwgdG91Y2hFdnQkMSwgYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0uZWwpICE9PSAnY29udGludWUnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxCeShhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSk7XG4gICAgICAgIH0uYmluZCh7XG4gICAgICAgICAgbGF5ZXI6IGxheWVyc091dFxuICAgICAgICB9KSwgMjQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxheWVyc091dCsrO1xuICB9IHdoaWxlIChvcHRpb25zLmJ1YmJsZVNjcm9sbCAmJiBjdXJyZW50UGFyZW50ICE9PSB3aW5TY3JvbGxlciAmJiAoY3VycmVudFBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGN1cnJlbnRQYXJlbnQsIGZhbHNlKSkpO1xuXG4gIHNjcm9sbGluZyA9IHNjcm9sbFRoaXNJbnN0YW5jZTsgLy8gaW4gY2FzZSBhbm90aGVyIGZ1bmN0aW9uIGNhdGNoZXMgc2Nyb2xsaW5nIGFzIGZhbHNlIGluIGJldHdlZW4gd2hlbiBpdCBpcyBub3Rcbn0sIDMwKTtcblxudmFyIGRyb3AgPSBmdW5jdGlvbiBkcm9wKF9yZWYpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQsXG4gICAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgICBkcmFnRWwgPSBfcmVmLmRyYWdFbCxcbiAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgICB1bmhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYudW5oaWRlR2hvc3RGb3JUYXJnZXQ7XG4gIGlmICghb3JpZ2luYWxFdmVudCkgcmV0dXJuO1xuICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlO1xuICBoaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgdmFyIHRvdWNoID0gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBvcmlnaW5hbEV2ZW50O1xuICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICBpZiAodG9Tb3J0YWJsZSAmJiAhdG9Tb3J0YWJsZS5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzcGlsbCcpO1xuICAgIHRoaXMub25TcGlsbCh7XG4gICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZXZlcnQoKSB7fVxuXG5SZXZlcnQucHJvdG90eXBlID0ge1xuICBzdGFydEluZGV4OiBudWxsLFxuICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmMikge1xuICAgIHZhciBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYyLm9sZERyYWdnYWJsZUluZGV4O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICB9LFxuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWYzKSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWYzLmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZTtcbiAgICB0aGlzLnNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKHB1dFNvcnRhYmxlKSB7XG4gICAgICBwdXRTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRDaGlsZCh0aGlzLnNvcnRhYmxlLmVsLCB0aGlzLnN0YXJ0SW5kZXgsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3J0YWJsZS5hbmltYXRlQWxsKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICB9XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJldmVydCwge1xuICBwbHVnaW5OYW1lOiAncmV2ZXJ0T25TcGlsbCdcbn0pO1xuXG5mdW5jdGlvbiBSZW1vdmUoKSB7fVxuXG5SZW1vdmUucHJvdG90eXBlID0ge1xuICBvblNwaWxsOiBmdW5jdGlvbiBvblNwaWxsKF9yZWY0KSB7XG4gICAgdmFyIGRyYWdFbCA9IF9yZWY0LmRyYWdFbCxcbiAgICAgICAgcHV0U29ydGFibGUgPSBfcmVmNC5wdXRTb3J0YWJsZTtcbiAgICB2YXIgcGFyZW50U29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgIHBhcmVudFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgcGFyZW50U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICB9LFxuICBkcm9wOiBkcm9wXG59O1xuXG5fZXh0ZW5kcyhSZW1vdmUsIHtcbiAgcGx1Z2luTmFtZTogJ3JlbW92ZU9uU3BpbGwnXG59KTtcblxuU29ydGFibGUubW91bnQobmV3IEF1dG9TY3JvbGxQbHVnaW4oKSk7XG5Tb3J0YWJsZS5tb3VudChSZW1vdmUsIFJldmVydCk7XG5cbmZ1bmN0aW9uIGNvb2tpZUZvclF1ZXJ5aW5nSXRlbXNFeGlzdHMoKSB7XG4gIGNvbnN0IGNvb2tpZSA9IGdldENvb2tpZShcIkFQU1ctcXVlcnlcIiwgdHJ1ZSk7XG4gIGlmICgoY29va2llID09PSBudWxsIHx8IGNvb2tpZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29va2llLmV4cGlyZXMpID4gbmV3IERhdGUoKS5zZXRIb3VycyhuZXcgRGF0ZSgpLmdldEhvdXJzKCkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gUXVlcnkgZm9yIGFwcHJvdmVkIGFwcCBpdGVtcyBldmVyeSA1IGhvdXJzXG4gIGNvbnN0IHBheWxvYWQgPSB7IGV4cGlyZXM6IG5ldyBEYXRlKCkuc2V0SG91cnMobmV3IERhdGUoKS5nZXRIb3VycygpICsgNSkgfTtcbiAgc2V0Q29va2llKFwiQVBTVy1xdWVyeVwiLCBwYXlsb2FkLCB7XG4gICAgcGF0aDogXCIvXCIsXG4gICAgZG9tYWluOiBkb2N1bWVudC5kb21haW4sXG4gICAgc2FtZVNpdGU6IFwiU3RyaWN0XCJcbiAgfSwgdHJ1ZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgbGljZW5zZXMgPSB7fTtcbmZ1bmN0aW9uIGhhc0xpY2Vuc2UoY2xpZW50SWQpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IGxpY2Vuc2VzW2NsaWVudElkLnRvTG93ZXJDYXNlKCldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsaWQpIHx8IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJblBvcnRhbENvbmZpZyh0aXRsZSwgcG9ydGFsLCBzaG93SW5BcHBMYXVuY2hlcikge1xuICByZXR1cm4gIXBvcnRhbC5pc1BvcnRhbCB8fCBzaG93SW5BcHBMYXVuY2hlci5pbmRleE9mKHRpdGxlKSA+IC0xO1xufVxuZnVuY3Rpb24gaGFzQWNjZXNzVG9PcGVuRGF0YShwb3J0YWwpIHtcbiAgaWYgKChwb3J0YWwgPT09IG51bGwgfHwgcG9ydGFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3J0YWwucG9ydGFsUHJvcGVydGllcykgJiYgKCFwb3J0YWwucG9ydGFsUHJvcGVydGllcy5vcGVuRGF0YSB8fCAhcG9ydGFsLnBvcnRhbFByb3BlcnRpZXMub3BlbkRhdGEuZW5hYmxlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGhhc0xpY2Vuc2UoXCJIdWJmb3JBcmNHSVNcIik7XG59XG5mdW5jdGlvbiBoYXNBY2Nlc3NUb1ZlbG9jaXR5KHVzZXIpIHtcbiAgY29uc3QgcmVxdWlyZXNPbmVPZiA9IFtcbiAgICBcInBvcnRhbDpwdWJsaXNoZXI6cHVibGlzaEZlZWRzXCIsXG4gICAgXCJwb3J0YWw6cHVibGlzaGVyOnB1Ymxpc2hSZWFsVGltZUFuYWx5dGljc1wiLFxuICAgIFwicG9ydGFsOnB1Ymxpc2hlcjpwdWJsaXNoQmlnRGF0YUFuYWx5dGljc1wiXG4gIF07XG4gIGNvbnN0IHByaXZpbGVnZXMgPSAodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdO1xuICBjb25zdCBoYXNQcml2aWxlZ2UgPSBwcml2aWxlZ2VzLnNvbWUoKHByaXZpbGVnZSkgPT4gcmVxdWlyZXNPbmVPZi5pbmRleE9mKHByaXZpbGVnZSkgPiAtMSk7XG4gIGNvbnN0IGhhc0NhcGFiaWxpdHkgPSBoYXNMaWNlbnNlKFwidmVsb2NpdHlcIik7XG4gIHJldHVybiBoYXNQcml2aWxlZ2UgJiYgaGFzQ2FwYWJpbGl0eTtcbn1cbmZ1bmN0aW9uIGhhc0FjY2Vzc1RvU2l0ZXMocG9ydGFsLCB0aXRsZSwgc2hvd0luQXBwTGF1bmNoZXIpIHtcbiAgcmV0dXJuIGlzSW5Qb3J0YWxDb25maWcodGl0bGUsIHBvcnRhbCwgc2hvd0luQXBwTGF1bmNoZXIpICYmIGhhc0xpY2Vuc2UoXCJIdWJmb3JBcmNHSVNcIik7XG59XG5mdW5jdGlvbiBoYXNBY2Nlc3NUb01hcFZpZXdlcihwb3J0YWwsIG5ld01hcFZpZXdlckVuYWJsZWQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBkaXNhYmxlZEluQXBwID0gcG9ydGFsLmlzUG9ydGFsICYmICgoX2EgPSBwb3J0YWwucG9ydGFsUHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5ld01hcFZpZXdlckVuYWJsZWQpID09PSBmYWxzZTtcbiAgcmV0dXJuIG5ld01hcFZpZXdlckVuYWJsZWQgJiYgIWRpc2FibGVkSW5BcHAgJiYgaGFzTGljZW5zZShcImFyY2dpc1dlYkFwcHNcIik7XG59XG5mdW5jdGlvbiBoYXNBY2Nlc3NUb09ydGhvTWFrZXIocG9ydGFsLCBzaG93SW5BcHBMYXVuY2hlcikge1xuICB2YXIgX2E7XG4gIHJldHVybiAoISEoKF9hID0gcG9ydGFsLmhlbHBlclNlcnZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmFzdGVyQW5hbHl0aWNzKSAmJlxuICAgICEhcG9ydGFsLmhlbHBlclNlcnZpY2VzLm9ydGhvTWFwcGluZyAmJlxuICAgIGlzSW5Qb3J0YWxDb25maWcoXCJPcnRobyBNYWtlclwiLCBwb3J0YWwsIHNob3dJbkFwcExhdW5jaGVyKSk7XG59XG5mdW5jdGlvbiBoYXNBY2Nlc3NUb05vdGVib29rcyh0aXRsZSwgcG9ydGFsLCB1c2VyLCBzaG93SW5BcHBMYXVuY2hlciwgbm90ZWJvb2tTZXJ2ZXJFbmFibGVkKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgbm90ZWJvb2tTZXJ2ZXJDb25maWd1cmVkID0gbm90ZWJvb2tTZXJ2ZXJFbmFibGVkICYmICghcG9ydGFsLmlzUG9ydGFsIHx8IHBvcnRhbC5zdXBwb3J0c0hvc3RlZE5vdGVib29rcyk7XG4gIGNvbnN0IGNhbkNyZWF0ZU5vdGVib29rcyA9ICEhKChfYSA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAmJlxuICAgIHVzZXIucHJpdmlsZWdlcy5zb21lKChwcml2aWxlZ2UpID0+IHByaXZpbGVnZSA9PT0gXCJwcmVtaXVtOnB1Ymxpc2hlcjpjcmVhdGVOb3RlYm9va3NcIik7XG4gIHJldHVybiBub3RlYm9va1NlcnZlckNvbmZpZ3VyZWQgJiYgY2FuQ3JlYXRlTm90ZWJvb2tzICYmIGlzSW5Qb3J0YWxDb25maWcodGl0bGUsIHBvcnRhbCwgc2hvd0luQXBwTGF1bmNoZXIpO1xufVxuZnVuY3Rpb24gaGFzQWNjZXNzVG9UcmFja1ZpZXdlcihwb3J0YWwsIHNob3dJbkFwcExhdW5jaGVyLCB0cmFja1ZpZXdlckVuYWJsZWQpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKCEhKChfYSA9IHBvcnRhbC5oZWxwZXJTZXJ2aWNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2F0aW9uVHJhY2tpbmcpICYmXG4gICAgdHJhY2tWaWV3ZXJFbmFibGVkICYmXG4gICAgaXNJblBvcnRhbENvbmZpZyhcIlRyYWNrIFZpZXdlclwiLCBwb3J0YWwsIHNob3dJbkFwcExhdW5jaGVyKSk7XG59XG5cbmNvbnN0IGFyY2dpc0FwcFN3aXRjaGVyQ3NzID0gXCIuYXBwcy1jb250ZW50LWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX0udG9nZ2xlLWJ1dHRvbntkaXNwbGF5OmJsb2NrO2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6MDttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO2JvcmRlci13aWR0aDowOy13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtoZWlnaHQ6My41cmVtO3dpZHRoOjMuNXJlbX0udG9nZ2xlLWJ1dHRvbjpub3QoLnRvZ2dsZS1idXR0b24tLWV4cGFuZGVkKTpob3Zlcntib3gtc2hhZG93Omluc2V0IDAgLTNweCAwIDAgcmdiYSgwLCAxMjEsIDE5MywgMC41KX0udG9nZ2xlLWJ1dHRvbi0tZXhwYW5kZWR7Ym94LXNoYWRvdzppbnNldCAwIC0zcHggMCAwIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpfS50b2dnbGUtYnV0dG9uX19pY29ue2Rpc3BsYXk6YmxvY2s7d2lkdGg6MS41cmVtO2hlaWdodDoxLjVyZW19Omhvc3R7cG9zaXRpb246cmVsYXRpdmU7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTIpfS5hcHBzLWNvbnRlbnR7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmFwcHMtY29udGVudC0tcnRse2xlZnQ6MDtyaWdodDphdXRvfS5hcHBzLWNvbnRlbnQtLWV4cGFuZGVke2Rpc3BsYXk6YmxvY2t9LmFwcHMtY29udGVudCA6Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjAuNXJlbX0uYXBwcy1jb250ZW50IDo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7Ym9yZGVyLXJhZGl1czp2YXIoLS1jYWxjaXRlLWJvcmRlci1yYWRpdXMpO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLCAwLCAwLCAwLjUpO2JveC1zaGFkb3c6MCAwIDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSl9LmRyb3Bkb3duLW1lbnV7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvO3RvcDowO2N1cnNvcjpkZWZhdWx0O2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1iYWNrZ3JvdW5kKTtib3JkZXItdG9wOjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0xKTttYXgtaGVpZ2h0Ojg1dmg7bWF4LXdpZHRoOjQ4MHB4O21pbi13aWR0aDo0NzVweH0uaW50cm8tY29udGFpbmVye3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1iYWNrZ3JvdW5kKX0uaW50cm8tdGV4dHtmb250LXNpemU6MC44NzVyZW07bWFyZ2luOjA7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJhY2tncm91bmQpO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0zKTtwYWRkaW5nLXRvcDoxcmVtO3BhZGRpbmctYm90dG9tOjAuNzVyZW07cGFkZGluZy1sZWZ0OjRyZW07cGFkZGluZy1yaWdodDo0cmVtfS5hcHBzLWxpc3R7ZmxleC1kaXJlY3Rpb246cm93O2ZsZXgtd3JhcDp3cmFwO2xpc3Qtc3R5bGUtdHlwZTpub25lO292ZXJmbG93OmhpZGRlbjt0ZXh0LWFsaWduOmxlZnQ7cGFkZGluZy10b3A6MC41cmVtO3BhZGRpbmctYm90dG9tOjAuNXJlbTtwYWRkaW5nLWxlZnQ6MC41cmVtO3BhZGRpbmctcmlnaHQ6MC41cmVtO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJhY2tncm91bmQpfS5hcHBzLWxpc3QgLnNlY29uZGFyeS1kcmFnLXRleHR7ZGlzcGxheTpub25lfS5hcHAtaXRlbXtjdXJzb3I6cG9pbnRlcjttYXJnaW46MDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTppbmxpbmUtYmxvY2s7ZmxvYXQ6bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWFsaWduOmxlZnQ7dmVydGljYWwtYWxpZ246dG9wO3dvcmQtd3JhcDpicmVhay13b3JkO292ZXJmbG93LXdyYXA6YnJlYWstd29yZDtmb250LXNpemU6MC44NzVyZW07aGVpZ2h0OjExMHB4O3dpZHRoOjE1MHB4fUAtbW96LWRvY3VtZW50IHVybC1wcmVmaXgoKXsuYXBwLWl0ZW17d2lkdGg6MTQ2cHh9fS5hcHBzLWNvbnRlbnQ6bm90KC5hcHBzLWNvbnRlbnQtLWRyYWdnaW5nKSAuYXBwLWl0ZW06bm90KC5hcHAtaXRlbS0tbWlzc2luZyk6aG92ZXJ7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO291dGxpbmU6MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpfS5hcHAtaXRlbS0tZHJhZ2dpbmd7b3V0bGluZS1vZmZzZXQ6LTFweH0uYXBwLWl0ZW0tLW1pc3Npbmd7cGFkZGluZy10b3A6MC41cmVtfS5zaG93LW1vcmV7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCU7Ym9yZGVyLXN0eWxlOm5vbmU7Y3Vyc29yOnBvaW50ZXI7cGFkZGluZzowLjI1cmVtO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTMpO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0zKTtmb250LXNpemU6MC44NzVyZW19LnNlY29uZGFyeS1jb250YWluZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMik7cGFkZGluZy10b3A6MC4yNXJlbTtwYWRkaW5nLWJvdHRvbTowLjI1cmVtO2JvcmRlci10b3A6MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYm9yZGVyLTMpfS5zZWNvbmRhcnktY29udGFpbmVyLS1oaWRkZW57ZGlzcGxheTpub25lfS5zZWNvbmRhcnktdGFyZ2V0e3RleHQtYWxpZ246Y2VudGVyO292ZXJmbG93OmhpZGRlbjttYXJnaW4tdG9wOjAuNzVyZW07bWFyZ2luLWJvdHRvbTowLjc1cmVtO21hcmdpbi1sZWZ0OjEuNXJlbTttYXJnaW4tcmlnaHQ6MS41cmVtO2ZvbnQtc2l6ZTowLjg3NXJlbTtwYWRkaW5nLWxlZnQ6MnJlbTtwYWRkaW5nLXJpZ2h0OjJyZW07Ym9yZGVyOjJweCBkYXNoZWQgdmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMik7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO2hlaWdodDoxMDBweH0uc2Vjb25kYXJ5LXRhcmdldC0taG92ZXJ7Ym9yZGVyLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktYnJhbmQpfS5zZWNvbmRhcnktbGlzdHt0ZXh0LWFsaWduOmxlZnQ7bWFyZ2luOjA7cGFkZGluZy10b3A6MC43NXJlbTtwYWRkaW5nLWJvdHRvbTowLjc1cmVtO3BhZGRpbmctbGVmdDowLjVyZW07cGFkZGluZy1yaWdodDowLjVyZW19XCI7XG5cbmNvbnN0IEFyY2dpc0FwcFN3aXRjaGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFyY2dpc0FwcFN3aXRjaGVyVG9nZ2xlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNBcHBTd2l0Y2hlclRvZ2dsZVwiLCA3KTtcbiAgICB0aGlzLndpbGxRdWVyeUZvckl0ZW1zID0gdHJ1ZTtcbiAgICB0aGlzLmJsb2NrZWRBcHBzID0gW107XG4gICAgdGhpcy5zaG93SW5BcHBMYXVuY2hlciA9IFtdO1xuICAgIHRoaXMuc2VydmVycyA9IFtdO1xuICAgIHRoaXMub3JnQ2FwYWJpbGl0aWVzID0gW107XG4gICAgdGhpcy51cGRhdGVBcHBzUHJvcGVydGllcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByaW1hcnlJZHMgPSB0aGlzLmdldElkc0Zyb21ET00odGhpcy5wcmltYXJ5Q29udGFpbmVyKTtcbiAgICAgIGNvbnN0IHByaW1hcnlBcHBzID0gdGhpcy5nZXRBcHBzQnlJZHMocHJpbWFyeUlkcyk7XG4gICAgICBjb25zdCBwcmltYXJ5ID0gdGhpcy5jb252ZXJ0VG9BcHBEYXRhKHByaW1hcnlBcHBzKTtcbiAgICAgIGNvbnN0IHNlY29uZGFyeUlkcyA9IHRoaXMuZ2V0SWRzRnJvbURPTSh0aGlzLnNlY29uZGFyeUNvbnRhaW5lcik7XG4gICAgICBjb25zdCBzZWNvbmRhcnlBcHBzID0gdGhpcy5nZXRBcHBzQnlJZHMoc2Vjb25kYXJ5SWRzKTtcbiAgICAgIGNvbnN0IHNlY29uZGFyeSA9IHRoaXMuY29udmVydFRvQXBwRGF0YShzZWNvbmRhcnlBcHBzKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRQcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy51c2VyUHJvcGVydGllcyk7XG4gICAgICB1cGRhdGVkUHJvcGVydGllcy5hcHBMYXVuY2hlciA9IHsgcHJpbWFyeSwgc2Vjb25kYXJ5IH07XG4gICAgICBhd2FpdCB1cGRhdGVVc2VyUHJvcGVydGllcyh1cGRhdGVkUHJvcGVydGllcyk7XG4gICAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzID0gdXBkYXRlZFByb3BlcnRpZXM7XG4gICAgICBjb25zdCBwcmV2aW91c1NlY29uZGFyeUNvdW50ID0gdGhpcy5zZWNvbmRhcnlBcHBzLmxlbmd0aDtcbiAgICAgIHRoaXMucHJpbWFyeUFwcHMgPSBwcmltYXJ5QXBwcztcbiAgICAgIHRoaXMuc2Vjb25kYXJ5QXBwcyA9IHNlY29uZGFyeUFwcHM7XG4gICAgICBpZiAocHJldmlvdXNTZWNvbmRhcnlDb3VudCA+IDAgJiYgIXRoaXMuc2Vjb25kYXJ5QXBwcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gaWYgYWxsIGFwcHMgYXJlIHJlbW92ZWQgZnJvbSBzZWNvbmRhcnksIHNob3cgdGhlIGRyYWcgYm94IGFuZCB0ZXh0XG4gICAgICAgIHRoaXMuaG92ZXJpbmdPdmVyU2Vjb25kYXJ5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVRvZ2dsZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXNFeHBhbmRlZCA9ICF0aGlzLmlzRXhwYW5kZWQ7XG4gICAgICB0aGlzLmFyY2dpc0FwcFN3aXRjaGVyVG9nZ2xlLmVtaXQodGhpcy5pc0V4cGFuZGVkKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU2hvd01vcmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNlY29uZGFyeUV4cGFuZGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGlzbWlzc0ludHJvID0gKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVBcHBzUHJvcGVydGllcygpO1xuICAgICAgdGhpcy5kaXNwbGF5SW50cm8gPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMua2V5ZG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy5pc0V4cGFuZGVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlVG9nZ2xlKCk7XG4gICAgICAgIChfYSA9IHRoaXMudG9nZ2xlQnV0dG9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXBpID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9ydGFsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudXNlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5ld01hcFZpZXdlckVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMubm90ZWJvb2tTZXJ2ZXJFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyYWNrVmlld2VyRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zaG91bGRFeHBhbmQgPSBmYWxzZTtcbiAgICB0aGlzLmRpc3BsYXlJbnRybyA9IGZhbHNlO1xuICAgIHRoaXMucHJpbWFyeUFwcHMgPSBbXTtcbiAgICB0aGlzLnNlY29uZGFyeUFwcHMgPSBbXTtcbiAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvdmVyaW5nT3ZlclNlY29uZGFyeSA9IGZhbHNlO1xuICAgIHRoaXMuc2Vjb25kYXJ5RXhwYW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNvcnRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmZvY3VzSXRlbUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVMaW5rQ2xpY2soKSB7XG4gICAgdGhpcy5pc0V4cGFuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5hcmNnaXNBcHBTd2l0Y2hlclRvZ2dsZS5lbWl0KHRoaXMuaXNFeHBhbmRlZCk7XG4gIH1cbiAgaGFuZGxlTGlua0FjdGl2YXRlZCgpIHtcbiAgICB0aGlzLnNlY29uZGFyeUV4cGFuZGVkID0gdHJ1ZTtcbiAgfVxuICBhc3luYyBoYW5kbGVMaW5rTW92ZShldnQpIHtcbiAgICBjb25zdCB7IHVpZCwga2V5Q29kZSwgaW5kZXggfSA9IGV2dC5kZXRhaWw7XG4gICAgdGhpcy5mb2N1c0l0ZW1JZCA9IHVpZDtcbiAgICBjb25zdCBwcmltYXJ5VG90YWwgPSB0aGlzLnByaW1hcnlBcHBzLmxlbmd0aDtcbiAgICBjb25zdCBzZWNvbmRhcnlUb3RhbCA9IHRoaXMuc2Vjb25kYXJ5QXBwcy5sZW5ndGg7XG4gICAgY29uc3QgaXNJblByaW1hcnkgPSBpbmRleCA8IHByaW1hcnlUb3RhbDtcbiAgICBsZXQgdGFyZ2V0UHJpbWFyeTtcbiAgICBpZiAoaXNJblByaW1hcnkpIHtcbiAgICAgIGNvbnN0IHJvd0NvdW50ID0gTWF0aC5jZWlsKHByaW1hcnlUb3RhbCAvIDMpO1xuICAgICAgY29uc3QgbGFzdFJvd0ZpcnN0SW5kZXggPSByb3dDb3VudCAqIDMgLSAzO1xuICAgICAgaWYgKGluZGV4IDwgbGFzdFJvd0ZpcnN0SW5kZXgpIHtcbiAgICAgICAgdGFyZ2V0UHJpbWFyeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXlDb2RlID09PSBcIkFycm93TGVmdFwiIHx8IGtleUNvZGUgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgIHRhcmdldFByaW1hcnkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gXCJBcnJvd1JpZ2h0XCIgJiYgaW5kZXggPCBwcmltYXJ5VG90YWwgLSAxKSB7XG4gICAgICAgIHRhcmdldFByaW1hcnkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFByaW1hcnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaW5kZXggPj0gcHJpbWFyeVRvdGFsICsgMykge1xuICAgICAgICB0YXJnZXRQcmltYXJ5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXlDb2RlID09PSBcIkFycm93UmlnaHRcIiB8fCBrZXlDb2RlID09PSBcIkFycm93RG93blwiKSB7XG4gICAgICAgIHRhcmdldFByaW1hcnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IFwiQXJyb3dMZWZ0XCIgJiYgaW5kZXggPiBwcmltYXJ5VG90YWwpIHtcbiAgICAgICAgdGFyZ2V0UHJpbWFyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFByaW1hcnkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGFyZ2V0SW5kZXggPSAtMTtcbiAgICBjb25zdCBzYW1lTGlzdCA9IChpc0luUHJpbWFyeSAmJiB0YXJnZXRQcmltYXJ5KSB8fCAoIWlzSW5QcmltYXJ5ICYmICF0YXJnZXRQcmltYXJ5KTtcbiAgICBpZiAoc2FtZUxpc3QpIHtcbiAgICAgIGlmIChrZXlDb2RlID09PSBcIkFycm93VXBcIikge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGluZGV4IC0gMztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IFwiQXJyb3dSaWdodFwiKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PT0gXCJBcnJvd0Rvd25cIikge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGluZGV4ICsgMztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBpbmRleCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGlzSW5QcmltYXJ5KSB7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICAgIHRhcmdldEluZGV4ID0gcHJpbWFyeVRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleUNvZGUgPT09IFwiQXJyb3dEb3duXCIpIHtcbiAgICAgICAgICB0YXJnZXRJbmRleCA9IChpbmRleCAlIDMpICsgcHJpbWFyeVRvdGFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBwcmltYXJ5VG90YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBhcHA7XG4gICAgaWYgKGlzSW5QcmltYXJ5KSB7XG4gICAgICBhcHAgPSB0aGlzLnByaW1hcnlBcHBzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXBwID0gdGhpcy5zZWNvbmRhcnlBcHBzLnNwbGljZShpbmRleCAtIHByaW1hcnlUb3RhbCwgMSlbMF07XG4gICAgfVxuICAgIGlmICh0YXJnZXRQcmltYXJ5KSB7XG4gICAgICB0aGlzLnByaW1hcnlBcHBzLnNwbGljZSh0YXJnZXRJbmRleCwgMCwgYXBwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBzZWNvbmRhcnlJbmRleCA9IHRhcmdldEluZGV4IC0gcHJpbWFyeVRvdGFsO1xuICAgICAgdGhpcy5zZWNvbmRhcnlBcHBzLnNwbGljZShzZWNvbmRhcnlJbmRleCwgMCwgYXBwKTtcbiAgICB9XG4gICAgY29uc3QgcHJpbWFyeSA9IHRoaXMuY29udmVydFRvQXBwRGF0YSh0aGlzLnByaW1hcnlBcHBzKTtcbiAgICBjb25zdCBzZWNvbmRhcnkgPSB0aGlzLmNvbnZlcnRUb0FwcERhdGEodGhpcy5zZWNvbmRhcnlBcHBzKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudXNlclByb3BlcnRpZXMpO1xuICAgIHVwZGF0ZWRQcm9wZXJ0aWVzLmFwcExhdW5jaGVyID0geyBwcmltYXJ5LCBzZWNvbmRhcnkgfTtcbiAgICBhd2FpdCB1cGRhdGVVc2VyUHJvcGVydGllcyh1cGRhdGVkUHJvcGVydGllcyk7XG4gICAgdGhpcy51c2VyUHJvcGVydGllcyA9IHVwZGF0ZWRQcm9wZXJ0aWVzO1xuICAgIGlmIChzZWNvbmRhcnlUb3RhbCA+IDAgJiYgIXRoaXMuc2Vjb25kYXJ5QXBwcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaG92ZXJpbmdPdmVyU2Vjb25kYXJ5ID0gZmFsc2U7XG4gICAgfVxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIHJlc2V0IGFmdGVyIHNldHRpbmcgZm9jdXNcbiAgICAgIHRoaXMuZm9jdXNJdGVtSWQgPSBcIlwiO1xuICAgIH0sIDEwMCk7XG4gIH1cbiAgYXN5bmMgaGFuZGxlTGlua1JlbW92ZShldnQpIHtcbiAgICBjb25zdCBpZCA9IGV2dC5kZXRhaWw7XG4gICAgY29uc3QgdXBkYXRlZFByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnVzZXJQcm9wZXJ0aWVzKTtcbiAgICBsZXQgeyBwcmltYXJ5LCBzZWNvbmRhcnkgfSA9IHVwZGF0ZWRQcm9wZXJ0aWVzLmFwcExhdW5jaGVyO1xuICAgIHByaW1hcnkgPSBwcmltYXJ5LmZpbHRlcigoYXBwKSA9PiBhcHAudWlkICE9PSBpZCk7XG4gICAgc2Vjb25kYXJ5ID0gc2Vjb25kYXJ5LmZpbHRlcigoYXBwKSA9PiBhcHAudWlkICE9PSBpZCk7XG4gICAgdXBkYXRlZFByb3BlcnRpZXMuYXBwTGF1bmNoZXIgPSB7IHByaW1hcnksIHNlY29uZGFyeSB9O1xuICAgIGF3YWl0IHVwZGF0ZVVzZXJQcm9wZXJ0aWVzKHVwZGF0ZWRQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzID0gdXBkYXRlZFByb3BlcnRpZXM7XG4gICAgdGhpcy5wcmltYXJ5QXBwcyA9IHRoaXMucHJpbWFyeUFwcHMuZmlsdGVyKChhcHApID0+IHtcbiAgICAgIGNvbnN0IGFwcElkID0gYXBwLml0ZW1JZCB8fCBhcHAudGl0bGU7XG4gICAgICByZXR1cm4gYXBwSWQgIT09IGlkO1xuICAgIH0pO1xuICAgIHRoaXMuc2Vjb25kYXJ5QXBwcyA9IHRoaXMuc2Vjb25kYXJ5QXBwcy5maWx0ZXIoKGFwcCkgPT4ge1xuICAgICAgY29uc3QgYXBwSWQgPSBhcHAuaXRlbUlkIHx8IGFwcC50aXRsZTtcbiAgICAgIHJldHVybiBhcHBJZCAhPT0gaWQ7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2hvdWxkRXhwYW5kQ2hhbmdlKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5pc0V4cGFuZGVkID0gbmV3VmFsdWU7XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICBjb25zdCBtb2JpbGVEZXZpY2VzID0gWy9BbmRyb2lkL2ksIC93ZWJPUy9pLCAvaVBob25lL2ksIC9pUGFkL2ldO1xuICAgIGNvbnN0IGlzTW9iaWxlID0gbW9iaWxlRGV2aWNlcy5zb21lKChkZXZpY2UpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goZGV2aWNlKSk7XG4gICAgaWYgKGlzTW9iaWxlKSB7XG4gICAgICAvLyBjdXJyZW50bHkgc29ydGFibGVKUyBpbnNpZGUgU2hhZG93IERPTSBpcyBub3Qgd29ya2luZyBjb3JyZWN0bHkgb24gbW9iaWxlLCBzbyBhdm9pZGluZyB0aGlzXG4gICAgICAvLyB0aGlzIHNob3VsZCBhbHNvIGFsbG93IHNjcm9sbGluZyB0aGUgYXBwcyBsaXN0IG9uIG1vYmlsZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBTb3J0YWJsZS5jcmVhdGUodGhpcy5wcmltYXJ5Q29udGFpbmVyLCB7XG4gICAgICBhbmltYXRpb246IDE1MCxcbiAgICAgIGdyb3VwOiBcImFwcHNcIixcbiAgICAgIGZpbHRlcjogXCIuc2Vjb25kYXJ5LWRyYWctdGV4dFwiLFxuICAgICAgZHJhZ0NsYXNzOiBcImFwcC1pdGVtLS1kcmFnZ2luZ1wiLFxuICAgICAgb25VcGRhdGU6IHRoaXMudXBkYXRlQXBwc1Byb3BlcnRpZXMsXG4gICAgICBvbkFkZDogdGhpcy51cGRhdGVBcHBzUHJvcGVydGllcyxcbiAgICAgIG9uTW92ZTogKHBhcmFtcykgPT4ge1xuICAgICAgICB0aGlzLmhvdmVyaW5nT3ZlclNlY29uZGFyeSA9IHBhcmFtcy50by5jbGFzc05hbWUgPT09IFwic2Vjb25kYXJ5LXRhcmdldFwiO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB9LFxuICAgICAgb25FbmQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFNvcnRhYmxlLmNyZWF0ZSh0aGlzLnNlY29uZGFyeUNvbnRhaW5lciwge1xuICAgICAgYW5pbWF0aW9uOiAxNTAsXG4gICAgICBncm91cDogXCJhcHBzXCIsXG4gICAgICBmaWx0ZXI6IFwiLnNlY29uZGFyeS1kcmFnLXRleHRcIixcbiAgICAgIGRyYWdDbGFzczogXCJhcHAtaXRlbS0tZHJhZ2dpbmdcIixcbiAgICAgIG9uVXBkYXRlOiB0aGlzLnVwZGF0ZUFwcHNQcm9wZXJ0aWVzLFxuICAgICAgb25BZGQ6IHRoaXMudXBkYXRlQXBwc1Byb3BlcnRpZXNcbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRSZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMucHJpbWFyeUNvbnRhaW5lci5jb250YWlucyh0aGlzLnNlY29uZGFyeURyYWdUZXh0KSkge1xuICAgICAgdGhpcy5zZWNvbmRhcnlDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWNvbmRhcnlEcmFnVGV4dCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbG9jYWxlID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmVsKTtcbiAgICB0aGlzLnN0cmluZ3MgPSBsb2NhbGVbMF07XG4gICAgdGhpcy53aWxsUXVlcnlGb3JJdGVtcyA9IGNvb2tpZUZvclF1ZXJ5aW5nSXRlbXNFeGlzdHMoKTtcbiAgICB0aGlzLmluaXRpYWxpemVDb25maWcoKTtcbiAgICBpZiAoISgoX2EgPSBjb25maWdTdGF0ZS5wb3J0YWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgfHwgIWNvbmZpZ1N0YXRlLnVzZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ1N0YXRlLnBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgdGhpcy5zaG93SW5BcHBMYXVuY2hlciA9IGF3YWl0IGdldFNob3dJbkFwcExhdW5jaGVyKCk7XG4gICAgfVxuICAgIGNvbnN0IFtjb25maWcsIG1hcmtldHBsYWNlLCBwcmVmZXJlbmNlcywgY3VzdG9tT3JnQXBwcywgb3JnQ2FwYWJpbGl0aWVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGdldEFwcFN3aXRjaGVyQ29uZmlnKCksXG4gICAgICBnZXRNYXJrZXRQbGFjZVByb3Zpc2lvbmVkTGlzdGluZ3MoKSxcbiAgICAgIGdldFVzZXJQcm9wZXJ0aWVzKCksXG4gICAgICBnZXRBcHByb3ZlZEFwcHMoKSxcbiAgICAgIGdldE9yZ0NhcGFiaWxpdGllcygpXG4gICAgXSk7XG4gICAgdGhpcy5vcmdDYXBhYmlsaXRpZXMgPSBvcmdDYXBhYmlsaXRpZXM7XG4gICAgdGhpcy51c2VyUHJvcGVydGllcyA9IChwcmVmZXJlbmNlcyA9PT0gbnVsbCB8fCBwcmVmZXJlbmNlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlZmVyZW5jZXMucHJvcGVydGllcykgfHwge307XG4gICAgdGhpcy51c2VyQXBwcyA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hcHBTd2l0Y2hlcjtcbiAgICBpZiAoIWNvbmZpZ1N0YXRlLnBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgdGhpcy51c2VyQXBwcy5hcHBzLnVuc2hpZnQodGhpcy5nZXRBZ29BcHAoKSk7XG4gICAgfVxuICAgIHRoaXMuYXBwcm92ZWRBcHBzID1cbiAgICAgICgoX2IgPSBjdXN0b21PcmdBcHBzLmFwcHJvdmVkQXBwcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcigoYXBwKSA9PiAhYXBwLmhpZGVGb3JOb25Qcml2aWxlZ2VkTWVtYmVyKSkgfHwgW107XG4gICAgaWYgKCF0aGlzLnVzZXJQcm9wZXJ0aWVzLmFwcExhdW5jaGVyKSB7XG4gICAgICB0aGlzLndpbGxRdWVyeUZvckl0ZW1zID0gZmFsc2U7XG4gICAgICB0aGlzLmRpc3BsYXlJbnRybyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucHJvdmlzaW9uZWRMaXN0aW5ncyA9IG1hcmtldHBsYWNlIHx8IFtdO1xuICAgIHRoaXMucHJvdmlzaW9uZWRMaXN0aW5ncy5mb3JFYWNoKChsaXN0aW5nKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjbGllbnRJZCA9IChfYSA9IGxpc3RpbmcuY2xpZW50SWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGNsaWVudElkKSB7XG4gICAgICAgIGxpY2Vuc2VzW2NsaWVudElkXSA9IHtcbiAgICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgICBpdGVtSWQ6IGxpc3RpbmcuaXRlbUlkLFxuICAgICAgICAgIGNsaWVudElkOiBsaXN0aW5nLmNsaWVudElkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgb3JnQ2FwYWJpbGl0aWVzID09PSBudWxsIHx8IG9yZ0NhcGFiaWxpdGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JnQ2FwYWJpbGl0aWVzLmZvckVhY2goKGNhcGFiaWxpdHkpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGNhcGFiaWxpdHlJZCA9IChfYSA9IGNhcGFiaWxpdHkuaWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGNhcGFiaWxpdHlJZCkge1xuICAgICAgICBsaWNlbnNlc1tjYXBhYmlsaXR5SWRdID0ge1xuICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgIGNsaWVudElkOiBjYXBhYmlsaXR5LmlkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgdGhpcy5wcmltYXJ5QXBwcy5mb3JFYWNoKChhcHApID0+IHtcbiAgICAgIGFwcC5mb250U2l6ZSA9IHRoaXMuY2FsY0ZvbnRTaXplKGFwcCk7XG4gICAgfSk7XG4gIH1cbiAgY29udmVydFRvQXBwRGF0YShhcHBzKSB7XG4gICAgcmV0dXJuIGFwcHMubWFwKChhcHApID0+ICh7IGxhYmVsOiBhcHAubGFiZWwsIHVpZDogYXBwLml0ZW1JZCB8fCBhcHAudGl0bGUgfSkpO1xuICB9XG4gIGdldEFwcHNCeUlkcyhpZHMpIHtcbiAgICBjb25zdCBhcHBzID0gWy4uLnRoaXMucHJpbWFyeUFwcHMsIC4uLnRoaXMuc2Vjb25kYXJ5QXBwc107XG4gICAgcmV0dXJuIGlkcy5tYXAoKGlkKSA9PiBhcHBzLmZpbmQoKGFwcCkgPT4gYXBwLml0ZW1JZCA9PT0gaWQgfHwgYXBwLnRpdGxlID09PSBpZCkpO1xuICB9XG4gIGdldElkc0Zyb21ET00oY29udGFpbmVyKSB7XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBwLWl0ZW1cIikuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGlkcy5wdXNoKGVsLmRhdGFzZXQuaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBpZHM7XG4gIH1cbiAgZ2V0VGV4dFdpZHRoKHRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb250ZXh0LmZvbnQgPSBcImF2ZW5pclwiO1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIHJldHVybiBtZXRyaWNzLndpZHRoO1xuICB9XG4gIGNhbGNGb250U2l6ZShhcHApIHtcbiAgICBpZiAoIWFwcC5hYmJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFiYnJldmlhdGlvblNpemVzID0gWzAsIDMyLCAyNCwgMjAsIDE4LCAxNiwgMTQsIDEyLCAxMCwgOCwgNl07XG4gICAgbGV0IHN0cldpZHRoID0gTWF0aC5jZWlsKHRoaXMuZ2V0VGV4dFdpZHRoKGFwcC5hYmJyKSAvIDUpO1xuICAgIGlmIChzdHJXaWR0aCA+IGFiYnJldmlhdGlvblNpemVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHN0cldpZHRoID0gYWJicmV2aWF0aW9uU2l6ZXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGAke2FiYnJldmlhdGlvblNpemVzW3N0cldpZHRoXX1weGA7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tlZEFwcHMoKSB7XG4gICAgY29uc3QgW3NpZ25pblNldHRpbmdzLCBibG9ja2FibGVBcHBzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGdldFNpZ25pblNldHRpbmdzKCksXG4gICAgICBnZXRCbG9ja2FibGVBcHBzKClcbiAgICBdKTtcbiAgICBjb25zdCBjbGllbnRJZHMgPSAoc2lnbmluU2V0dGluZ3MgPT09IG51bGwgfHwgc2lnbmluU2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25pblNldHRpbmdzLmJsb2NrZWRBcHBzKSB8fCBbXTtcbiAgICBpZiAoKCFjbGllbnRJZHMubGVuZ3RoICYmICFzaWduaW5TZXR0aW5ncy5ibG9ja0JldGFBcHBzKSB8fCAhKGJsb2NrYWJsZUFwcHMgPT09IG51bGwgfHwgYmxvY2thYmxlQXBwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2thYmxlQXBwcy5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChzaWduaW5TZXR0aW5ncy5ibG9ja0JldGFBcHBzKSB7XG4gICAgICBibG9ja2FibGVBcHBzLmZvckVhY2goKGFwcCkgPT4ge1xuICAgICAgICBpZiAoYXBwLmlzQmV0YSAmJiAhY2xpZW50SWRzLmluY2x1ZGVzKGFwcC5jbGllbnRpZCkpIHtcbiAgICAgICAgICBjbGllbnRJZHMucHVzaChhcHAuY2xpZW50aWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2xpZW50SWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGJsb2NrYWJsZUFwcHMuZmluZCgoYXBwKSA9PiBhcHAuY2xpZW50aWQgPT09IGlkKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLmJsb2NrZWRBcHBzLnB1c2gobWF0Y2gpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmJsb2NrZWRBcHBzO1xuICB9XG4gIGZpbHRlckJsb2NrZWRBcHBzKGFwcHMpIHtcbiAgICByZXR1cm4gYXBwcy5maWx0ZXIoKGFwcCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgaW5CbG9ja2VkTGlzdCA9IChfYSA9IHRoaXMuYmxvY2tlZEFwcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChiYSkgPT4ge1xuICAgICAgICByZXR1cm4gKGFwcC5pdGVtSWQgJiYgYXBwLml0ZW1JZCA9PT0gYmEuaXRlbWlkKSB8fCAoYXBwLnRpdGxlICYmIGFwcC50aXRsZSA9PT0gYmEudGl0bGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIWluQmxvY2tlZExpc3Q7XG4gICAgfSk7XG4gIH1cbiAgcG9wdWxhdGVBcHBJZGVudGlmaWVycyhwcmV2LCBhcHApIHtcbiAgICBjb25zdCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy5hcHBEaWN0aW9uYXJ5KS5tYXAoKGtleSkgPT4gdGhpcy5hcHBEaWN0aW9uYXJ5W2tleV0pO1xuICAgIGxldCBwb3B1bGF0ZWRBcHAgPSBsaXN0LmZpbHRlcigoYSkgPT4gYS5pdGVtSWQgPT09IGFwcC51aWQgfHwgYS50aXRsZSA9PT0gYXBwLnVpZCkuc2hpZnQoKTtcbiAgICBpZiAocG9wdWxhdGVkQXBwICYmICF0aGlzLmFwcERpY3Rpb25hcnlbYXBwLnVpZF0pIHtcbiAgICAgIGFwcC51aWQgPSBwb3B1bGF0ZWRBcHAuaXRlbUlkIHx8IHBvcHVsYXRlZEFwcC50aXRsZTtcbiAgICB9XG4gICAgaWYgKHBvcHVsYXRlZEFwcCA9PT0gbnVsbCB8fCBwb3B1bGF0ZWRBcHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcHVsYXRlZEFwcC5oYXNCZWVuUG9wdWxhdGVkKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG4gICAgaWYgKCFwb3B1bGF0ZWRBcHApIHtcbiAgICAgIC8vIEFwcCBDYW4ndCBiZSBGb3VuZFxuICAgICAgcG9wdWxhdGVkQXBwID0gYXBwO1xuICAgICAgcG9wdWxhdGVkQXBwLmNhbkFjY2VzcyA9IGZhbHNlO1xuICAgICAgcG9wdWxhdGVkQXBwLml0ZW1JZCA9IGFwcC51aWQ7XG4gICAgICB0aGlzLmFwcERpY3Rpb25hcnlbYXBwLnVpZF0gPSBwb3B1bGF0ZWRBcHA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gLS0gSW5zZXJ0IGludG8gRGljdGlvbmFyeSAtLVxuICAgICAgaWYgKChhcHAuaGFzQ2hhbmdlZCB8fFxuICAgICAgICBwb3B1bGF0ZWRBcHAuaGFzQ2hhbmdlZCB8fFxuICAgICAgICAoIXBvcHVsYXRlZEFwcC5jYW5BY2Nlc3MgJiYgIXBvcHVsYXRlZEFwcC5pZ25vcmVOb0FjY2VzcykpICYmXG4gICAgICAgIHRoaXMuaXNBZG1pbigpKSB7XG4gICAgICAgIHRoaXMuYXBwRGljdGlvbmFyeVthcHAudWlkXS5oYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBEaWN0aW9uYXJ5W2FwcC51aWRdLmlnbm9yZU5vQWNjZXNzID0gYXBwLmlnbm9yZU5vQWNjZXNzO1xuICAgICAgfVxuICAgICAgaWYgKGFwcC5pc05ldykge1xuICAgICAgICB0aGlzLmFwcERpY3Rpb25hcnlbYXBwLnVpZF0uaXNOZXcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMubmV3QXBwRGljdGlvbmFyeVthcHAudWlkXTtcbiAgICB9XG4gICAgLy8gLS0gUHJldmVudCBkdXBsaWNhdGVzIGZyb20gYW55IHBvc3NpYmxlIGVycm9yIHN0YXRlc1xuICAgIHRoaXMuYXBwRGljdGlvbmFyeVthcHAudWlkXS5oYXNCZWVuUG9wdWxhdGVkID0gdHJ1ZTtcbiAgICBwcmV2LnB1c2gocG9wdWxhdGVkQXBwKTtcbiAgICByZXR1cm4gcHJldjtcbiAgfVxuICBpc0luUG9ydGFsQ29uZmlnKHRpdGxlKSB7XG4gICAgY29uc3QgeyBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIHJldHVybiBpc0luUG9ydGFsQ29uZmlnKHRpdGxlLCBwb3J0YWwsIHRoaXMuc2hvd0luQXBwTGF1bmNoZXIpO1xuICB9XG4gIGdldEFwcEV4Y2VwdGlvbnMoKSB7XG4gICAgY29uc3QgeyBwb3J0YWwsIHVzZXIgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIHJldHVybiB7XG4gICAgICBcIk9wZW4gRGF0YVwiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKCkgPT4gaGFzQWNjZXNzVG9PcGVuRGF0YShwb3J0YWwpXG4gICAgICB9LFxuICAgICAgQXBwU3R1ZGlvOiB7XG4gICAgICAgIGhhc0FjY2VzczogKCkgPT4gaGFzTGljZW5zZShcImFyY2dpc1dlYkFwcHNcIilcbiAgICAgIH0sXG4gICAgICBcIkFyY0dJUyBWZWxvY2l0eVwiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKCkgPT4gaGFzQWNjZXNzVG9WZWxvY2l0eSh1c2VyKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIEh1YlwiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKCkgPT4gaGFzTGljZW5zZShcIkh1YmZvckFyY0dJU1wiKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIEVudGVycHJpc2UgU2l0ZXNcIjoge1xuICAgICAgICBoYXNBY2Nlc3M6ICh0aXRsZSkgPT4gaGFzQWNjZXNzVG9TaXRlcyhwb3J0YWwsIHRpdGxlLCB0aGlzLnNob3dJbkFwcExhdW5jaGVyKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIEV4cGVyaWVuY2UgQnVpbGRlclwiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKHRpdGxlKSA9PiB0aGlzLmlzSW5Qb3J0YWxDb25maWcodGl0bGUpXG4gICAgICB9LFxuICAgICAgXCJBcmNHSVMgU3RvcnlNYXBzXCI6IHtcbiAgICAgICAgaGFzQWNjZXNzOiAodGl0bGUpID0+IHRoaXMuaXNJblBvcnRhbENvbmZpZyh0aXRsZSlcbiAgICAgIH0sXG4gICAgICBcIkFyY0dJUyBRdWlja0NhcHR1cmUgV2ViIERlc2lnbmVyXCI6IHtcbiAgICAgICAgaGFzQWNjZXNzOiAodGl0bGUpID0+IHRoaXMuaXNJblBvcnRhbENvbmZpZyh0aXRsZSkgJiYgaGFzTGljZW5zZShcImFyY2dpc1dlYkFwcHNcIilcbiAgICAgIH0sXG4gICAgICBcIkFyY0dJUyBDb2xsZWN0b3JcIjoge1xuICAgICAgICBoYXNBY2Nlc3M6ICh0aXRsZSkgPT4gdGhpcy5pc0luUG9ydGFsQ29uZmlnKHRpdGxlKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIEZpZWxkIE1hcHNcIjoge1xuICAgICAgICBoYXNBY2Nlc3M6ICh0aXRsZSkgPT4gdGhpcy5pc0luUG9ydGFsQ29uZmlnKHRpdGxlKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIERhc2hib2FyZHNcIjoge1xuICAgICAgICBoYXNBY2Nlc3M6ICh0aXRsZSkgPT4gdGhpcy5pc0luUG9ydGFsQ29uZmlnKHRpdGxlKSAmJiBoYXNMaWNlbnNlKFwiZGFzaGJvYXJkc1wiKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIFNvbHV0aW9uc1wiOiB7XG4gICAgICAgIC8vIEZvciBQb3J0YWxcbiAgICAgICAgaGFzQWNjZXNzOiAodGl0bGUpID0+IHRoaXMuaXNJblBvcnRhbENvbmZpZyh0aXRsZSlcbiAgICAgIH0sXG4gICAgICBcIkFyY0dJUyBXb3JrZm9yY2VcIjoge1xuICAgICAgICAvLyBGb3IgUG9ydGFsXG4gICAgICAgIGhhc0FjY2VzczogKHRpdGxlKSA9PiB0aGlzLmlzSW5Qb3J0YWxDb25maWcodGl0bGUpXG4gICAgICB9LFxuICAgICAgXCJEZWVwIExlYXJuaW5nIFN0dWRpb1wiOiB7XG4gICAgICAgIC8vIEZvciBQb3J0YWxcbiAgICAgICAgaGFzQWNjZXNzOiAodGl0bGUpID0+IHRoaXMuaXNJblBvcnRhbENvbmZpZyh0aXRsZSlcbiAgICAgIH0sXG4gICAgICBcIk1hcCBWaWV3ZXJcIjoge1xuICAgICAgICBoYXNBY2Nlc3M6ICgpID0+IGhhc0FjY2Vzc1RvTWFwVmlld2VyKHBvcnRhbCwgdGhpcy5uZXdNYXBWaWV3ZXJFbmFibGVkKSAmJlxuICAgICAgICAgIHRoaXMuaXNJblBvcnRhbENvbmZpZyhcIkFyY0dJUyBNYXAgVmlld2VyXCIpXG4gICAgICB9LFxuICAgICAgXCJNYXAgVmlld2VyIENsYXNzaWNcIjoge1xuICAgICAgICBoYXNBY2Nlc3M6ICgpID0+IGhhc0xpY2Vuc2UoXCJhcmNnaXNXZWJBcHBzXCIpICYmIHRoaXMuaXNJblBvcnRhbENvbmZpZyhcIkFyY0dJUyBNYXAgVmlld2VyIENsYXNzaWNcIilcbiAgICAgIH0sXG4gICAgICBcIk9wZXJhdGlvbnMgRGFzaGJvYXJkIGZvciBBcmNHSVNcIjoge1xuICAgICAgICBoYXNBY2Nlc3M6ICgpID0+IGhhc0xpY2Vuc2UoXCJvcHNkYXNoYm9hcmRcIikgJiYgdGhpcy5pc0luUG9ydGFsQ29uZmlnKFwiQXJjR0lTIERhc2hib2FyZHMgQ2xhc3NpY1wiKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIERhc2hib2FyZHMgQ2xhc3NpY1wiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKHRpdGxlKSA9PiBoYXNMaWNlbnNlKFwib3BzZGFzaGJvYXJkXCIpICYmIHRoaXMuaXNJblBvcnRhbENvbmZpZyh0aXRsZSlcbiAgICAgIH0sXG4gICAgICBcIk9ydGhvIE1ha2VyXCI6IHtcbiAgICAgICAgaGFzQWNjZXNzOiAoKSA9PiBoYXNBY2Nlc3NUb09ydGhvTWFrZXIocG9ydGFsLCB0aGlzLnNob3dJbkFwcExhdW5jaGVyKVxuICAgICAgfSxcbiAgICAgIE5vdGVib29rOiB7XG4gICAgICAgIGhhc0FjY2VzczogKHRpdGxlKSA9PiBoYXNBY2Nlc3NUb05vdGVib29rcyh0aXRsZSwgcG9ydGFsLCB1c2VyLCB0aGlzLnNob3dJbkFwcExhdW5jaGVyLCB0aGlzLm5vdGVib29rU2VydmVyRW5hYmxlZClcbiAgICAgIH0sXG4gICAgICBcIlNjZW5lIFZpZXdlclwiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKHRpdGxlKSA9PiBoYXNMaWNlbnNlKFwiYXJjZ2lzV2ViQXBwc1wiKSAmJiB0aGlzLmlzSW5Qb3J0YWxDb25maWcodGl0bGUpXG4gICAgICB9LFxuICAgICAgXCJTdG9yeSBNYXBzXCI6IHtcbiAgICAgICAgaGFzQWNjZXNzOiAoKSA9PiBoYXNMaWNlbnNlKFwiYXJjZ2lzV2ViQXBwc1wiKVxuICAgICAgfSxcbiAgICAgIFN1cnZleTEyMzoge1xuICAgICAgICBoYXNBY2Nlc3M6ICgpID0+IGhhc0xpY2Vuc2UoXCJzdXJ2ZXkxMjNcIilcbiAgICAgIH0sXG4gICAgICBcIlRyYWNrIFZpZXdlclwiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKCkgPT4gaGFzQWNjZXNzVG9UcmFja1ZpZXdlcihwb3J0YWwsIHRoaXMuc2hvd0luQXBwTGF1bmNoZXIsIHRoaXMudHJhY2tWaWV3ZXJFbmFibGVkKVxuICAgICAgfSxcbiAgICAgIFwiSW5zdGFudCBBcHBzXCI6IHtcbiAgICAgICAgLy8gRm9yIFBvcnRhbFxuICAgICAgICBoYXNBY2Nlc3M6ICh0aXRsZSkgPT4gaGFzTGljZW5zZShcImFyY2dpc1dlYkFwcHNcIikgJiYgdGhpcy5pc0luUG9ydGFsQ29uZmlnKHRpdGxlKVxuICAgICAgfSxcbiAgICAgIFwiVmVjdG9yIFRpbGUgU3R5bGUgRWRpdG9yXCI6IHtcbiAgICAgICAgLy8gRm9yIFBvcnRhbFxuICAgICAgICBoYXNBY2Nlc3M6ICh0aXRsZSkgPT4gdGhpcy5pc0luUG9ydGFsQ29uZmlnKHRpdGxlKVxuICAgICAgfSxcbiAgICAgIFwiQXJjR0lTIEdlb0JJTVwiOiB7XG4gICAgICAgIC8vIEZvciBQb3J0YWxcbiAgICAgICAgaGFzQWNjZXNzOiAodGl0bGUpID0+IHRoaXMuaXNJblBvcnRhbENvbmZpZyh0aXRsZSlcbiAgICAgIH0sXG4gICAgICBcIkFyY0dJUyBNYXBzIGZvciBBZG9iZSBDcmVhdGl2ZSBDbG91ZFwiOiB7XG4gICAgICAgIGhhc0FjY2VzczogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBoYXNMaWNlbnNlKFwiYXJjZ2lzV2ViQXBwc1wiKSAmJiAhY29uZmlnU3RhdGUucG9ydGFsLmlzUG9ydGFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRFeGNsdWRlZFByb3Zpc2lvbmVkTGlzdGluZ3MoKSB7XG4gICAgbGV0IGV4Y2x1ZGVkID0ge1xuICAgICAgb3BzZGFzaGJvYXJkOiAxLFxuICAgICAgYXJjZ2lzV2ViQXBwczogMSxcbiAgICAgIFdvcmtmb3JjZTogMSxcbiAgICAgIGdlb3BsYW5uZXI6IDEsXG4gICAgICB3ZWJhcHBidWlsZGVyOiAxLFxuICAgICAgSHViZm9yQXJjR0lTOiAxLFxuICAgICAgYXBwc3R1ZGlvOiAxLFxuICAgICAgc3VydmV5MTIzOiAxLFxuICAgICAgc3RvcnltYXBzOiAxLFxuICAgICAgbWFwc0Zvck9mZmljZTogMSxcbiAgICAgIG1hcHNGb3JPMzY1OiAxLFxuICAgICAgbWFwc0ZvclNoYXJlUG9pbnQ6IDEsXG4gICAgICBtYXBzRm9yQ3JlYXRpdmVDbG91ZDogMVxuICAgIH07XG4gICAgY29uc3QgeyBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIGlmIChwb3J0YWwuaXNQb3J0YWwpIHtcbiAgICAgIC8vIGV4Y2x1ZGUgY2VydGFpbiBwcm92aXNpb25lZCBsaXN0aW5ncyBmb3IgRW50ZXJwcmlzZVxuICAgICAgZXhjbHVkZWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4Y2x1ZGVkKSwgeyBhcmNnaXNvbmxpbmU6IDEsIGFyY2dpc1VyYmFuOiAxLCBhcmNnaXNpbnN0YW50YXBwczogMSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4Y2x1ZGVkO1xuICB9XG4gIGdldEltYWdlUGF0aChhcHApIHtcbiAgICByZXR1cm4gZ2V0QXNzZXRQYXRoKGAuL2Fzc2V0cy8keyhhcHAgPT09IG51bGwgfHwgYXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHAuaW1hZ2UpID8gYXBwLmltYWdlIDogXCJcIn1gKTtcbiAgfVxuICBtb2RpZnlXZWJBcHBGb3JWaWV3KGFwcCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgaW1nID0gKChfYSA9IGFwcC5hcHBTd2l0Y2hlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmltYWdlKSB8fCBhcHAuaWNvbjtcbiAgICBpZiAoaW1nKSB7XG4gICAgICBhcHAuaW1hZ2UgPSB0aGlzLmdldFdlYk1hcHBpbmdBcHBJbWdQYXRoKGFwcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYXBwLnBsYWNlSG9sZGVySWNvbiA9IGAke3RoaXMuZ2V0SW1hZ2VQYXRoKCl9c3ZnLWFwcC1jaXJjbGUuc3ZnYDtcbiAgICB9XG4gICAgYXBwLmFiYnIgPSAoKF9iID0gYXBwLmFwcFN3aXRjaGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJicikgfHwgYXBwLmFiYnJldmlhdGlvbjtcbiAgICBkZWxldGUgYXBwLmFiYnJldmlhdGlvbjtcbiAgICBkZWxldGUgYXBwLmFwcFN3aXRjaGVyO1xuICAgIGRlbGV0ZSBhcHAuYXBwcm92ZWRBcHA7XG4gICAgZGVsZXRlIGFwcC53ZWJNYXBwaW5nQXBwO1xuICAgIHJldHVybiBhcHA7XG4gIH1cbiAgbW9kaWZ5U3lzdGVtQXBwRm9yVmlldyhhcHAsIHVuaXF1ZUlkKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgICBpZiAoYXBwLmltYWdlKSB7XG4gICAgICBhcHAuaW1hZ2UgPSB0aGlzLmdldEltYWdlUGF0aChhcHApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFwcC5wbGFjZUhvbGRlckljb24gPSBgJHt0aGlzLmdldEltYWdlUGF0aCgpfXN2Zy1hcHAtaWNvbi5zdmdgO1xuICAgIH1cbiAgICAvLyByZWxhdGl2ZSB1cmxzIG11c3QgYmUgcG9pbnRlZCBhdCB0aGUgb3JnIHVybCAoIzI1NDk0KVxuICAgIGlmICgoKF9hID0gYXBwLnVybCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGV4T2YoXCIuLi9cIikpID09PSAwKSB7XG4gICAgICBjb25zdCBiYXNlVXJsID0gcG9ydGFsLnVybEtleVxuICAgICAgICA/IGAke3BvcnRhbC51cmxLZXl9LiR7cG9ydGFsLmN1c3RvbUJhc2VVcmx9YFxuICAgICAgICA6IHBvcnRhbC5wb3J0YWxIb3N0bmFtZTtcbiAgICAgIGFwcC51cmwgPSBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7YmFzZVVybH0ke2FwcC51cmwuc3Vic3RyaW5nKDIsIGFwcC51cmwubGVuZ3RoKX1gO1xuICAgIH1cbiAgICBkZWxldGUgYXBwLmlzTGljZW5zZWQ7XG4gICAgZGVsZXRlIGFwcC5wcml2aWxlZ2VzO1xuICAgIGFwcC5pdGVtSWQgPSB1bmlxdWVJZDtcbiAgICByZXR1cm4gYXBwO1xuICB9XG4gIGdldFdlYk1hcHBpbmdBcHBJbWdQYXRoKGFwcCkge1xuICAgIGNvbnN0IHsgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKHBvcnRhbCk7XG4gICAgaWYgKCFhcHAuaWNvbikge1xuICAgICAgcmV0dXJuIGAke2dldFJlc3RCYXNlVXJsKCl9Y29udGVudC9pdGVtcy8ke2FwcC5pdGVtSWR9L3Jlc291cmNlcy8ke2FwcC5hcHBTd2l0Y2hlci5pbWFnZX0/dG9rZW49JHt0b2tlbn1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7Z2V0UmVzdEJhc2VVcmwoKX1wb3J0YWxzL3NlbGYvcmVzb3VyY2VzLyR7YXBwLmljb259P3Rva2VuPSR7dG9rZW59YDtcbiAgfVxuICBtb2RpZnlQYXJ0bmVyQXBwRm9yVmlldyhhcHApIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBhcHAuYXBwU3dpdGNoZXIgPSAoX2EgPSBhcHAucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcFN3aXRjaGVyO1xuICAgIGNvbnN0IGN1c3RvbUljb24gPSAoKF9iID0gYXBwLmFwcFN3aXRjaGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW1hZ2UpIHx8IGFwcC5pY29uO1xuICAgIHJldHVybiB7XG4gICAgICBhYmJyOiAoKF9jID0gYXBwLmFwcFN3aXRjaGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWJicikgfHwgYXBwLmFiYnJldmlhdGlvbixcbiAgICAgIGl0ZW1JZDogYXBwLml0ZW1JZCxcbiAgICAgIGNhbkFjY2VzczogdHJ1ZSxcbiAgICAgIHdlYk1hcHBpbmdBcHA6IHRydWUsXG4gICAgICBpbWFnZTogY3VzdG9tSWNvbiA/IHRoaXMuZ2V0V2ViTWFwcGluZ0FwcEltZ1BhdGgoYXBwKSA6IG51bGwsXG4gICAgICBsYWJlbDogYXBwLnRpdGxlIHx8IGFwcC5sYWJlbCxcbiAgICAgIHVybDogYXBwLnVybCxcbiAgICAgIHBsYWNlSG9sZGVySWNvbjogYXBwLnBsYWNlSG9sZGVySWNvbiB8fCBgJHt0aGlzLmdldEltYWdlUGF0aCgpfXN2Zy1hcHAtY2lyY2xlLnN2Z2BcbiAgICB9O1xuICB9XG4gIGFzeW5jIGdldExpY2Vuc2VkQXBwcygpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIGNvbnN0IHsgcG9ydGFsLCB1c2VyIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCBhbGxBcHBVaWRzID0ge307XG4gICAgY29uc3QgYXBwRGljdGlvbmFyeSA9IHt9O1xuICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSB0aGlzLmdldEFwcEV4Y2VwdGlvbnMoKTtcbiAgICBjb25zdCBleGNsdWRlZFByb3Zpc2lvbmVkTGlzdGluZ3MgPSB0aGlzLmdldEV4Y2x1ZGVkUHJvdmlzaW9uZWRMaXN0aW5ncygpO1xuICAgIGNvbnN0IGxlZ2FsQXBwcyA9IFtdO1xuICAgIGNvbnN0IGFwcENvdW50ID0gdGhpcy51c2VyQXBwcy5hcHBzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFwcENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFwcCA9IHRoaXMudXNlckFwcHMuYXBwc1tpXTtcbiAgICAgIGNvbnN0IHVpZCA9IGFwcC5pdGVtSWQgfHwgYXBwLnRpdGxlO1xuICAgICAgbGV0IGlzUHJpdmlsZWdlZCA9IHRydWU7XG4gICAgICBjb25zdCBpbkJsb2NrZWRMaXN0ID0gKF9hID0gdGhpcy5ibG9ja2VkQXBwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKGJhKSA9PiAoYXBwLml0ZW1JZCAmJiBhcHAuaXRlbUlkID09PSBiYS5pdGVtaWQpIHx8IChhcHAudGl0bGUgJiYgYXBwLnRpdGxlID09PSBiYS50aXRsZSkpO1xuICAgICAgYWxsQXBwVWlkc1t1aWRdID0gMTtcbiAgICAgIGFwcERpY3Rpb25hcnlbdWlkXSA9IGFwcDtcbiAgICAgIGlmIChpbkJsb2NrZWRMaXN0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9ydGFsRGVwbG95bWVudFR5cGUgPSBwb3J0YWwucG9ydGFsRGVwbG95bWVudFR5cGUgfHwgKChfYiA9IHBvcnRhbC5zb3VyY2VKU09OKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucG9ydGFsRGVwbG95bWVudFR5cGUpO1xuICAgICAgaWYgKHBvcnRhbERlcGxveW1lbnRUeXBlID09PSBcIkFyY0dJU0VudGVycHJpc2VPbkt1YmVybmV0ZXNcIiAmJlxuICAgICAgICBhcHAuc3VwcG9ydHNLdWJlcm5ldGVzID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRpb25zW2FwcC50aXRsZV0gJiYgIWV4Y2VwdGlvbnNbYXBwLnRpdGxlXS5oYXNBY2Nlc3MoYXBwLnRpdGxlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbkluZm8gPSBwb3J0YWwuc3Vic2NyaXB0aW9uSW5mbyB8fCAoKF9jID0gcG9ydGFsLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdWJzY3JpcHRpb25JbmZvKTtcbiAgICAgIGlmIChhcHAuc3Vic2NyaXB0aW9uVHlwZSkge1xuICAgICAgICBpZiAoKHN1YnNjcmlwdGlvbkluZm8gPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uSW5mby50eXBlKSA9PT0gYXBwLnN1YnNjcmlwdGlvblR5cGUpIHtcbiAgICAgICAgICBhcHBEaWN0aW9uYXJ5W3VpZF0uY2FuQWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICBsZWdhbEFwcHMucHVzaCh0aGlzLm1vZGlmeVN5c3RlbUFwcEZvclZpZXcoYXBwLCB1aWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhcHAub3JnQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgIGlmICgoX2QgPSB0aGlzLm9yZ0NhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGhhc0NhcGFiaWxpdHkgPSB0aGlzLm9yZ0NhcGFiaWxpdGllcy5zb21lKChjYXBhYmlsaXR5KSA9PiBhcHAub3JnQ2FwYWJpbGl0aWVzLmluY2x1ZGVzKGNhcGFiaWxpdHkuaWQpKTtcbiAgICAgICAgICBpZiAoaGFzQ2FwYWJpbGl0eSkge1xuICAgICAgICAgICAgYXBwRGljdGlvbmFyeVt1aWRdLmNhbkFjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICBsZWdhbEFwcHMucHVzaCh0aGlzLm1vZGlmeVN5c3RlbUFwcEZvclZpZXcoYXBwLCB1aWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoISgoX2UgPSBhcHAucHJpdmlsZWdlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgJiYgIWFwcC5pc0xpY2Vuc2VkICYmICFhcHAuc2VydmVyRnVuY3Rpb24pIHtcbiAgICAgICAgYXBwRGljdGlvbmFyeVt1aWRdLmNhbkFjY2VzcyA9IHRydWU7XG4gICAgICAgIGxlZ2FsQXBwcy5wdXNoKHRoaXMubW9kaWZ5U3lzdGVtQXBwRm9yVmlldyhhcHAsIHVpZCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNraXBQcml2Q2hlY2sgPSAoKF9mID0gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnVzZXJMaWNlbnNlVHlwZUlkKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudG9Mb3dlckNhc2UoKSkgPT09IFwic3Rvcnl0ZWxsZXJ1dFwiICYmXG4gICAgICAgICgoX2cgPSBhcHAubGFiZWwpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy50b0xvd2VyQ2FzZSgpKSA9PT0gXCJzdG9yeW1hcHNcIjtcbiAgICAgIGlmIChza2lwUHJpdkNoZWNrKSB7XG4gICAgICAgIGFwcERpY3Rpb25hcnlbdWlkXS5jYW5BY2Nlc3MgPSB0cnVlO1xuICAgICAgICBsZWdhbEFwcHMucHVzaCh0aGlzLm1vZGlmeVN5c3RlbUFwcEZvclZpZXcoYXBwLCB1aWQpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKChfaCA9IGFwcC5wcml2aWxlZ2VzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gubGVuZ3RoKSA+IDAgJiYgKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFwcC5wcml2aWxlZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHVzZXIucHJpdmlsZWdlcy5pbmRleE9mKGFwcC5wcml2aWxlZ2VzW2pdKSA8IDApIHtcbiAgICAgICAgICAgIGlzUHJpdmlsZWdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXBwLmlzTGljZW5zZWQgJiYgaXNQcml2aWxlZ2VkKSB7XG4gICAgICAgICAgYXBwRGljdGlvbmFyeVt1aWRdLmNhbkFjY2VzcyA9IHRydWU7XG4gICAgICAgICAgbGVnYWxBcHBzLnB1c2godGhpcy5tb2RpZnlTeXN0ZW1BcHBGb3JWaWV3KGFwcCwgdWlkKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcHAuaXNMaWNlbnNlZCAmJiBpc1ByaXZpbGVnZWQpIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnByb3Zpc2lvbmVkTGlzdGluZ3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAodWlkID09PSB0aGlzLnByb3Zpc2lvbmVkTGlzdGluZ3Nba10uaXRlbUlkIHx8XG4gICAgICAgICAgICB1aWQgPT09IHRoaXMucHJvdmlzaW9uZWRMaXN0aW5nc1trXS50aXRsZSkge1xuICAgICAgICAgICAgYXBwRGljdGlvbmFyeVt1aWRdLmNhbkFjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICBsZWdhbEFwcHMucHVzaCh0aGlzLm1vZGlmeVN5c3RlbUFwcEZvclZpZXcoYXBwLCB1aWQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFwcC5zZXJ2ZXJGdW5jdGlvbiAmJiBpc1ByaXZpbGVnZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVycy5zb21lKChzZXJ2ZXIpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gKChfYSA9IHNlcnZlci5zZXJ2ZXJGdW5jdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiLFwiKSkgfHwgW107XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucy5pbmNsdWRlcyhhcHAuc2VydmVyRnVuY3Rpb24pO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGFwcERpY3Rpb25hcnlbdWlkXS5jYW5BY2Nlc3MgPSB0cnVlO1xuICAgICAgICAgIGxlZ2FsQXBwcy5wdXNoKHRoaXMubW9kaWZ5U3lzdGVtQXBwRm9yVmlldyhhcHAsIHVpZCkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIC0gV2ViIG1hcHBpbmcgYXBwcyBmcm9tIE1hcmtlcGxhY2VcbiAgICB0aGlzLnByb3Zpc2lvbmVkTGlzdGluZ3MuZm9yRWFjaCgoYXBwKSA9PiB7XG4gICAgICBpZiAoYXBwLnR5cGUgPT09IFwiV2ViIE1hcHBpbmcgQXBwbGljYXRpb25cIiAmJlxuICAgICAgICAhZXhjbHVkZWRQcm92aXNpb25lZExpc3RpbmdzW2FwcC5jbGllbnRJZF0gJiZcbiAgICAgICAgIWFsbEFwcFVpZHNbYXBwLml0ZW1JZF0gJiZcbiAgICAgICAgYXBwLnVybCAmJlxuICAgICAgICBhcHAudGl0bGUgJiZcbiAgICAgICAgIWFsbEFwcFVpZHNbYXBwLnRpdGxlXSAmJlxuICAgICAgICBhcHAudHlwZUtleXdvcmRzLmluZGV4T2YoXCJoaWRlRnJvbUFwcFN3aXRjaGVyXCIpIDwgMCkge1xuICAgICAgICBjb25zdCBtb2RpZmllZEFwcCA9IHRoaXMubW9kaWZ5UGFydG5lckFwcEZvclZpZXcoYXBwKTtcbiAgICAgICAgYXBwRGljdGlvbmFyeVthcHAuaXRlbUlkXSA9IG1vZGlmaWVkQXBwO1xuICAgICAgICBsZWdhbEFwcHMucHVzaChtb2RpZmllZEFwcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYXBwcyA9IFtcbiAgICAgIC4uLnRoaXMuYXBwcm92ZWRBcHBzLm1hcCgoYXBwKSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcFByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFwcC5hcHBQcm9wZXJ0aWVzKSwgeyBpdGVtSWQ6IGFwcC5pdGVtSWQsIHdlYk1hcHBpbmdBcHA6IHRydWUsIGFwcHJvdmVkQXBwOiB0cnVlLCBjYW5BY2Nlc3M6ICF0aGlzLndpbGxRdWVyeUZvckl0ZW1zIH0pO1xuICAgICAgICBhcHBEaWN0aW9uYXJ5W2FwcC5pdGVtSWRdID0gYXBwUHJvcGVydGllcztcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5V2ViQXBwRm9yVmlldyhhcHBQcm9wZXJ0aWVzKTtcbiAgICAgIH0pLFxuICAgICAgLi4ubGVnYWxBcHBzXG4gICAgXTtcbiAgICByZXR1cm4ge1xuICAgICAgYXBwcyxcbiAgICAgIGFwcERpY3Rpb25hcnlcbiAgICB9O1xuICB9XG4gIGlzQWRtaW4oKSB7XG4gICAgY29uc3QgeyB1c2VyIH0gPSBjb25maWdTdGF0ZTtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZXIucm9sZSA9PT0gXCJvcmdfYWRtaW5cIiB8fCB1c2VyLnJvbGUgPT09IFwiYWNjb3VudF9hZG1pblwiO1xuICB9XG4gIC8vIE1hcCB0aGUgdWlkIG9mIGV4aXN0aW5nIHVzZXIgcHJvcGVydGllcyB0byBtYXRjaCB0aGUgbmV3IHRpdGxlXG4gIG1hcEFwcFRpdGxlcyhhcHBzKSB7XG4gICAgY29uc3QgeyBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIGFwcHMuZm9yRWFjaCgoYXBwKSA9PiB7XG4gICAgICBpZiAoYXBwLnVpZCA9PT0gXCJNYXAgVmlld2VyIEJldGFcIikge1xuICAgICAgICBhcHAudWlkID0gXCJNYXAgVmlld2VyXCI7XG4gICAgICB9XG4gICAgICBpZiAocG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgICAgIGlmIChhcHAudWlkID09PSBcIk9wZXJhdGlvbnMgRGFzaGJvYXJkIGZvciBBcmNHSVNcIikge1xuICAgICAgICAgIGFwcC51aWQgPSBcIkFyY0dJUyBEYXNoYm9hcmRzIENsYXNzaWNcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcHAudWlkID09PSBcIldvcmtmb3JjZSBmb3IgQXJjR0lTXCIpIHtcbiAgICAgICAgICBhcHAudWlkID0gXCJBcmNHSVMgV29ya2ZvcmNlXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY29uZmlnU3RhdGUucG9ydGFsLmlzUG9ydGFsKSB7XG4gICAgICB0aGlzLnNlcnZlcnMgPSBhd2FpdCBnZXRTZXJ2ZXJzKCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZ2V0QmxvY2tlZEFwcHMoKTtcbiAgICBjb25zdCB7IGFwcHMsIGFwcERpY3Rpb25hcnkgfSA9IGF3YWl0IHRoaXMuZ2V0TGljZW5zZWRBcHBzKCk7XG4gICAgdGhpcy5hcHBEaWN0aW9uYXJ5ID0gYXBwRGljdGlvbmFyeTtcbiAgICBpZiAodGhpcy51c2VyUHJvcGVydGllcy5hcHBMYXVuY2hlcikge1xuICAgICAgaWYgKHRoaXMudXNlclByb3BlcnRpZXMuYXBwTGF1bmNoZXIucHJpbWFyeSkge1xuICAgICAgICB0aGlzLm1hcEFwcFRpdGxlcyh0aGlzLnVzZXJQcm9wZXJ0aWVzLmFwcExhdW5jaGVyLnByaW1hcnkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudXNlclByb3BlcnRpZXMuYXBwTGF1bmNoZXIuc2Vjb25kYXJ5KSB7XG4gICAgICAgIHRoaXMubWFwQXBwVGl0bGVzKHRoaXMudXNlclByb3BlcnRpZXMuYXBwTGF1bmNoZXIuc2Vjb25kYXJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnVzZXJQcm9wZXJ0aWVzLmFwcExhdW5jaGVyIHx8XG4gICAgICAhdGhpcy51c2VyUHJvcGVydGllcy5hcHBMYXVuY2hlci5wcmltYXJ5IHx8XG4gICAgICAhdGhpcy51c2VyUHJvcGVydGllcy5hcHBMYXVuY2hlci5zZWNvbmRhcnkpIHtcbiAgICAgIHRoaXMucHJpbWFyeUFwcHMgPSBhcHBzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gKGEubGFiZWwgPCBiLmxhYmVsID8gLTEgOiAxKSk7XG4gICAgICB0aGlzLnByaW1hcnlBcHBzID0gdGhpcy5maWx0ZXJCbG9ja2VkQXBwcyh0aGlzLnByaW1hcnlBcHBzKTtcbiAgICAgIHRoaXMuc2Vjb25kYXJ5QXBwcyA9IFtdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcXVlcnlBcHBJdGVtc0ZvckNoYW5nZXModGhpcy5hcHByb3ZlZEFwcHMsIHRoaXMud2lsbFF1ZXJ5Rm9ySXRlbXMpO1xuICAgICAgaWYgKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UucmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgIHJlc3BvbnNlLnJlc3VsdHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuYXBwRGljdGlvbmFyeVtpdGVtLmlkXTtcbiAgICAgICAgICBhcHAuY2FuQWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICBhcHAuaGFzQ2hhbmdlZCA9IGFwcC51cmwgIT09IGl0ZW0udXJsID8gISFpdGVtLnVybCA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV3QXBwRGljdGlvbmFyeSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYXBwRGljdGlvbmFyeSk7XG4gICAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzLmFwcExhdW5jaGVyLnByaW1hcnkuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBpZiAocC5sYWJlbCA9PT0gXCJNYXAgVmlld2VyXCIpIHtcbiAgICAgICAgICBwLnVpZCA9IFwiTWFwIFZpZXdlclwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJpbWFyeUFwcHMgPVxuICAgICAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzLmFwcExhdW5jaGVyLnByaW1hcnkucmVkdWNlKHRoaXMucG9wdWxhdGVBcHBJZGVudGlmaWVycy5iaW5kKHRoaXMpLCBbXSkgfHwgW107XG4gICAgICB0aGlzLnNlY29uZGFyeUFwcHMgPVxuICAgICAgICB0aGlzLnVzZXJQcm9wZXJ0aWVzLmFwcExhdW5jaGVyLnNlY29uZGFyeS5yZWR1Y2UodGhpcy5wb3B1bGF0ZUFwcElkZW50aWZpZXJzLmJpbmQodGhpcyksIFtdKSB8fCBbXTtcbiAgICAgIHRoaXMucHJpbWFyeUFwcHMgPSB0aGlzLmZpbHRlckJsb2NrZWRBcHBzKHRoaXMucHJpbWFyeUFwcHMpO1xuICAgICAgdGhpcy5zZWNvbmRhcnlBcHBzID0gdGhpcy5maWx0ZXJCbG9ja2VkQXBwcyh0aGlzLnNlY29uZGFyeUFwcHMpO1xuICAgICAgLy8gOjogQ2hlY2sgZm9yIE5ldyBBcHAgSWNvbnMgOjpcbiAgICAgIGZvciAoY29uc3QgYXBwIGluIHRoaXMubmV3QXBwRGljdGlvbmFyeSkge1xuICAgICAgICBpZiAodGhpcy5uZXdBcHBEaWN0aW9uYXJ5W2FwcF0uY2FuQWNjZXNzKSB7XG4gICAgICAgICAgdGhpcy5uZXdBcHBEaWN0aW9uYXJ5W2FwcF0uaXNOZXcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYXBwRGljdGlvbmFyeVthcHBdID0gdGhpcy5uZXdBcHBEaWN0aW9uYXJ5W2FwcF07XG4gICAgICAgICAgdGhpcy5wcmltYXJ5QXBwcy5wdXNoKHRoaXMubmV3QXBwRGljdGlvbmFyeVthcHBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBnZXRBZ29BcHAoKSB7XG4gICAgY29uc3QgeyBwb3J0YWwsIHVzZXIgfSA9IGNvbmZpZ1N0YXRlO1xuICAgIGNvbnN0IGJhc2VVcmwgPSBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7cG9ydGFsLnVybEtleSA/IGAke3BvcnRhbC51cmxLZXl9LiR7cG9ydGFsLmN1c3RvbUJhc2VVcmx9YCA6IHBvcnRhbC5wb3J0YWxIb3N0bmFtZX0vaG9tZS9gO1xuICAgIGNvbnN0IHsgbGFuZGluZ1BhZ2UgfSA9IHRoaXMudXNlclByb3BlcnRpZXM7XG4gICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0keyhsYW5kaW5nUGFnZSA9PT0gbnVsbCB8fCBsYW5kaW5nUGFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZGluZ1BhZ2UudXJsKSA/IGxhbmRpbmdQYWdlLnVybCA6ICh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuaXNPcmdBZG1pbikgPyBcIm9yZ2FuaXphdGlvbi5odG1sXCIgOiBcImluZGV4Lmh0bWxcIn1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbWFnZTogXCJhcmNnaXMtb25saW5lLnBuZ1wiLFxuICAgICAgbGFiZWw6IFwiQXJjR0lTIE9ubGluZVwiLFxuICAgICAgdGl0bGU6IFwiQXJjR0lTIE9ubGluZVwiLFxuICAgICAgdXJsXG4gICAgfTtcbiAgfVxuICBpbml0aWFsaXplQ29uZmlnKCkge1xuICAgIGNvbmZpZ1N0YXRlLmFwaSA9IHRoaXMuYXBpO1xuICAgIGNvbmZpZ1N0YXRlLnVzZXIgPSB0aGlzLnVzZXI7XG4gICAgY29uZmlnU3RhdGUucG9ydGFsID0gdGhpcy5wb3J0YWw7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5wcmltYXJ5QXBwcy5sZW5ndGggKyB0aGlzLnNlY29uZGFyeUFwcHMubGVuZ3RoO1xuICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5lbCkgPT09IFwicnRsXCI7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgb25LZXlEb3duOiB0aGlzLmtleWRvd25IYW5kbGVyIH0sIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwga2luZDogXCJuZXV0cmFsXCIsIGNsYXNzOiB7IFwidG9nZ2xlLWJ1dHRvblwiOiB0cnVlLCBcInRvZ2dsZS1idXR0b24tLWV4cGFuZGVkXCI6IHRoaXMuaXNFeHBhbmRlZCB9LCBcImFyaWEtbGFiZWxcIjogdGhpcy5zdHJpbmdzLmFwcExhdW5jaGVyLCBvbkNsaWNrOiB0aGlzLmhhbmRsZVRvZ2dsZSwgcmVmOiAoZWwpID0+ICh0aGlzLnRvZ2dsZUJ1dHRvbiA9IGVsKSwgXCJhcmlhLWV4cGFuZGVkXCI6IHRoaXMuaXNFeHBhbmRlZCB9LCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgY2xhc3M6IFwidG9nZ2xlLWJ1dHRvbl9faWNvblwiLCBpY29uOiBcImFwcC1sYXVuY2hlclwiLCBzY2FsZTogXCJtXCIgfSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiYXBwcy1jb250ZW50LWNvbnRhaW5lclwiIH0sIGgoXCJkaXZcIiwgeyBjbGFzczoge1xuICAgICAgICBcImFwcHMtY29udGVudFwiOiB0cnVlLFxuICAgICAgICBcImFwcHMtY29udGVudC0tcnRsXCI6IHJ0bCxcbiAgICAgICAgXCJhcHBzLWNvbnRlbnQtLWV4cGFuZGVkXCI6IHRoaXMuaXNFeHBhbmRlZCxcbiAgICAgICAgXCJhcHBzLWNvbnRlbnQtLWRyYWdnaW5nXCI6IHRoaXMuZHJhZ2dpbmdcbiAgICAgIH0sIFwiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwiIH0sIGgoXCJuYXZcIiwgeyBjbGFzczogXCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLXJpZ2h0XCIsIHJvbGU6IFwibWVudVwiIH0sIHRoaXMuZGlzcGxheUludHJvICYmIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW50cm8tY29udGFpbmVyXCIgfSwgaChcInBcIiwgeyBjbGFzczogXCJkcmFnLWFuZC1kcm9wLWludHJvIGludHJvLXRleHRcIiB9LCB0aGlzLnN0cmluZ3MuZHJhZ0Ryb3ApLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcIm91dGxpbmUtZmlsbFwiLCBraW5kOiBcIm5ldXRyYWxcIiwgb25DbGljazogdGhpcy5oYW5kbGVEaXNtaXNzSW50cm8gfSwgdGhpcy5zdHJpbmdzLmdvdEl0KSkpLCBoKFwidWxcIiwgeyBjbGFzczogXCJhcHBzLWxpc3RcIiwgcmVmOiAoZWwpID0+ICh0aGlzLnByaW1hcnlDb250YWluZXIgPSBlbCkgfSwgdGhpcy5wcmltYXJ5QXBwcy5tYXAoKGFwcCwgaW5kZXgpID0+IChoKFwibGlcIiwgeyBcImRhdGEtaWRcIjogYXBwLml0ZW1JZCB8fCBhcHAudGl0bGUsIGtleTogYXBwLml0ZW1JZCwgY2xhc3M6IHsgXCJhcHAtaXRlbVwiOiB0cnVlLCBcImFwcC1pdGVtLS1taXNzaW5nXCI6ICFhcHAuY2FuQWNjZXNzIH0gfSwgaChcImFyY2dpcy1hcHAtc3dpdGNoZXItbGlua1wiLCB7IGFwcDogYXBwLCBpbmRleDogaW5kZXgsIHRvdGFsOiB0b3RhbCwgZm9jdXNJdGVtSWQ6IHRoaXMuZm9jdXNJdGVtSWQsIG9wZW5UZXh0OiB0aGlzLnN0cmluZ3Mub3BlbldpbmRvdyB9KSkpKSksICF0aGlzLnNlY29uZGFyeUV4cGFuZGVkICYmIChoKFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwic2hvdy1tb3JlXCIsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlU2hvd01vcmUgfSwgdGhpcy5zdHJpbmdzLnNob3dNb3JlLCBcIiBcIiwgaChcImNhbGNpdGUtaWNvblwiLCB7IGljb246IFwiY2hldnJvbi1kb3duXCIsIHNjYWxlOiBcInNcIiB9KSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IHtcbiAgICAgICAgXCJzZWNvbmRhcnktY29udGFpbmVyXCI6IHRydWUsXG4gICAgICAgIFwic2Vjb25kYXJ5LWNvbnRhaW5lci0taGlkZGVuXCI6ICF0aGlzLnNlY29uZGFyeUV4cGFuZGVkXG4gICAgICB9LCBcImFyaWEtZXhwYW5kZWRcIjogXCJ0cnVlXCIgfSwgaChcInVsXCIsIHsgY2xhc3M6IHtcbiAgICAgICAgXCJzZWNvbmRhcnktdGFyZ2V0XCI6IHRoaXMuc2Vjb25kYXJ5QXBwcy5sZW5ndGggPT09IDAsXG4gICAgICAgIFwic2Vjb25kYXJ5LWxpc3RcIjogdGhpcy5zZWNvbmRhcnlBcHBzLmxlbmd0aCAhPT0gMCxcbiAgICAgICAgXCJzZWNvbmRhcnktdGFyZ2V0LS1ob3ZlclwiOiB0aGlzLmhvdmVyaW5nT3ZlclNlY29uZGFyeSAmJiB0aGlzLnNlY29uZGFyeUFwcHMubGVuZ3RoID09PSAwXG4gICAgICB9LCByZWY6IChlbCkgPT4gKHRoaXMuc2Vjb25kYXJ5Q29udGFpbmVyID0gZWwpIH0sIHRoaXMuc2Vjb25kYXJ5QXBwcy5sZW5ndGggPT09IDAgJiYgIXRoaXMuaG92ZXJpbmdPdmVyU2Vjb25kYXJ5ICYmIChoKFwicFwiLCB7IGNsYXNzOiBcInNlY29uZGFyeS1kcmFnLXRleHRcIiwgcmVmOiAoZWwpID0+ICh0aGlzLnNlY29uZGFyeURyYWdUZXh0ID0gZWwpIH0sIHRoaXMuc3RyaW5ncy5kcmFnU2Vjb25kYXJ5KSksIHRoaXMuc2Vjb25kYXJ5QXBwcy5tYXAoKGFwcCwgaW5kZXgpID0+IChoKFwibGlcIiwgeyBcImRhdGEtaWRcIjogYXBwLml0ZW1JZCwga2V5OiBhcHAuaXRlbUlkLCBjbGFzczogeyBcImFwcC1pdGVtXCI6IHRydWUsIFwiYXBwLWl0ZW0tLW1pc3NpbmdcIjogIWFwcC5jYW5BY2Nlc3MgfSB9LCBoKFwiYXJjZ2lzLWFwcC1zd2l0Y2hlci1saW5rXCIsIHsgYXBwOiBhcHAsIGluZGV4OiB0aGlzLnByaW1hcnlBcHBzLmxlbmd0aCArIGluZGV4LCB0b3RhbDogdG90YWwsIGZvY3VzSXRlbUlkOiB0aGlzLmZvY3VzSXRlbUlkLCBvcGVuVGV4dDogdGhpcy5zdHJpbmdzLm9wZW5XaW5kb3cgfSkpKSkpKSkpKSkpO1xuICB9XG4gIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcImFzc2V0c1wiXTsgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJzaG91bGRFeHBhbmRcIjogW1wiaGFuZGxlU2hvdWxkRXhwYW5kQ2hhbmdlXCJdXG4gIH07IH1cbn07XG5BcmNnaXNBcHBTd2l0Y2hlci5zdHlsZSA9IGFyY2dpc0FwcFN3aXRjaGVyQ3NzO1xuXG5jb25zdCBBcHBTd2l0Y2hlckxpbmtBcnJvd3MgPSAoeyBpbmRleCwgdG90YWwsIGFjdGl2ZSB9KSA9PiB7XG4gIGNvbnN0IGlzRmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgY29uc3QgaXNGaXJzdFJvdyA9IGluZGV4IDw9IDI7XG4gIGNvbnN0IGlzTGFzdCA9IGluZGV4ID09PSB0b3RhbCAtIDE7XG4gIGNvbnN0IHJvd0NvdW50ID0gTWF0aC5jZWlsKHRvdGFsIC8gMyk7XG4gIGNvbnN0IGxhc3RSb3dGaXJzdEluZGV4ID0gcm93Q291bnQgKiAzIC0gMztcbiAgY29uc3QgaXNMYXN0Um93ID0gaW5kZXggPj0gbGFzdFJvd0ZpcnN0SW5kZXg7XG4gIHJldHVybiAoaChcInNwYW5cIiwgeyBjbGFzczogeyBcImFycm93LS1oaWRkZW5cIjogIWFjdGl2ZSB9IH0sXG4gICAgIWlzRmlyc3QgJiYgaChcImRpdlwiLCB7IGNsYXNzOiBcImFycm93IGFycm93LS1sZWZ0XCIgfSksXG4gICAgIWlzTGFzdCAmJiBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiYXJyb3cgYXJyb3ctLXJpZ2h0XCIgfSksXG4gICAgIWlzRmlyc3RSb3cgJiYgaChcImRpdlwiLCB7IGNsYXNzOiBcImFycm93IGFycm93LS10b3BcIiB9KSxcbiAgICAhaXNMYXN0Um93ICYmIGgoXCJkaXZcIiwgeyBjbGFzczogXCJhcnJvdyBhcnJvdy0tYm90dG9tXCIgfSkpKTtcbn07XG5cbmNvbnN0IGFyY2dpc0FwcFN3aXRjaGVyTGlua0NzcyA9IFwiOmhvc3R7ZGlzcGxheTpibG9jaztoZWlnaHQ6OTMlfS5hcHAtbGlua3tkaXNwbGF5OmJsb2NrO3BhZGRpbmctbGVmdDowLjVyZW07cGFkZGluZy1yaWdodDowLjVyZW07cGFkZGluZy10b3A6MC41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlOy13ZWJraXQtdXNlci1zZWxlY3Q6dGV4dDstbW96LXVzZXItc2VsZWN0OnRleHQ7dXNlci1zZWxlY3Q6dGV4dDt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjppbmhlcml0fS5hcHAtbGluazpmb2N1c3tvdXRsaW5lOjFweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKX0uYXJyb3d7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjA7d2lkdGg6MH0uYXJyb3ctLWhpZGRlbnt2aXNpYmlsaXR5OmhpZGRlbn0uYXJyb3ctLWxlZnR7Ym9yZGVyLXJpZ2h0OjVweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKTtib3JkZXItYm90dG9tOjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItdG9wOjVweCBzb2xpZCB0cmFuc3BhcmVudDtsZWZ0OjM4cHg7dG9wOjI3cHh9LmFycm93LS1yaWdodHtib3JkZXItbGVmdDo1cHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7Ym9yZGVyLWJvdHRvbTo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcDo1cHggc29saWQgdHJhbnNwYXJlbnQ7cmlnaHQ6MzhweDt0b3A6MjdweH0uYXJyb3ctLXRvcHtib3JkZXItYm90dG9tOjVweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKTtib3JkZXItbGVmdDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjVweCBzb2xpZCB0cmFuc3BhcmVudDt0b3A6MDtyaWdodDo3MHB4fS5hcnJvdy0tYm90dG9te2JvcmRlci10b3A6NXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O3RvcDo1OXB4O3JpZ2h0OjcwcHh9Lm1pc3NpbmctaWNvbiAuYXJyb3ctLXRvcHt0b3A6LTRweH0uaWNvbi13cmFwcGVye2Rpc3BsYXk6YmxvY2s7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtc2l6ZTpjb250YWluO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0bztmb250LXNpemU6MS4xMjVyZW07d2lkdGg6M3JlbTtoZWlnaHQ6M3JlbTttYXJnaW4tYm90dG9tOjAuNXJlbTtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMil9Lmljb24tYWJicntwb3NpdGlvbjphYnNvbHV0ZTtmb250LXNpemU6MS4yNXJlbTtmb250LXdlaWdodDo3MDA7d2lkdGg6M3JlbTtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpO2xpbmUtaGVpZ2h0OjNyZW07dGV4dC1zaGFkb3c6MCAxcHggOHB4IHZhcigtLWNhbGNpdGUtdWktdGV4dC0zKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX0uaWNvbi1pbWd7cG9pbnRlci1ldmVudHM6bm9uZTt3aWR0aDozcmVtO2hlaWdodDozcmVtfS5pbmRpY2F0b3J7cG9zaXRpb246YWJzb2x1dGU7Ym94LXNpemluZzpib3JkZXItYm94O2NsZWFyOmJvdGg7d2lkdGg6MXJlbTtoZWlnaHQ6MXJlbTtib3JkZXItcmFkaXVzOjUwJTtib3JkZXI6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKTt6LWluZGV4OjUwfS5pbmRpY2F0b3ItLW5ld3tiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktc3VjY2Vzcyk7dG9wOjRweDtyaWdodDo0NnB4fS5pbmRpY2F0b3ItLW5ldy1ydGx7cmlnaHQ6YXV0bztsZWZ0OjQ2cHh9LmluZGljYXRvci0tcmVtb3Zle2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKTtsaW5lLWhlaWdodDoycHg7cGFkZGluZzoxcHg7cmlnaHQ6NDJweDt0b3A6MnB4fS5pbmRpY2F0b3ItLXJlbW92ZS1ydGx7cmlnaHQ6YXV0bztsZWZ0OjQycHh9LmluZGljYXRvci0tcmVtb3ZlOmhvdmVyLC5pbmRpY2F0b3ItLXJlbW92ZTpmb2N1c3tvdXRsaW5lOjJweCBzb2xpZCB0cmFuc3BhcmVudDtvdXRsaW5lLW9mZnNldDoycHg7Ym9yZGVyLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZGFuZ2VyKTtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWRhbmdlcil9Lm1pc3NpbmctaWNvbnt0ZXh0LWFsaWduOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOjA7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0bztiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0zKTtoZWlnaHQ6M3JlbTt3aWR0aDozcmVtO21hcmdpbi1ib3R0b206MC41cmVtO2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXI6MXB4IGRhc2hlZCB2YXIoLS1jYWxjaXRlLXVpLWludmVyc2UpO2JvcmRlci1yYWRpdXM6NnB4O291dGxpbmUtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1icmFuZCl9LmxhYmVsLXRleHR7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvO3RleHQtYWxpZ246Y2VudGVyO2Rpc3BsYXk6YmxvY2s7bGluZS1oZWlnaHQ6MTdweDt3aWR0aDoxMjhweH0uc2NyZWVuLXJlYWRlcnN7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MXB4O2hlaWdodDoxcHg7cGFkZGluZzowO21hcmdpbjotMXB4O292ZXJmbG93OmhpZGRlbjtjbGlwOnJlY3QoMCwgMCwgMCwgMCk7d2hpdGUtc3BhY2U6bm93cmFwO2JvcmRlci13aWR0aDowfVwiO1xuXG5jb25zdCBBcmNnaXNBcHBMaW5rID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFyY2dpc0FwcFN3aXRjaGVyTGlua0FjdGl2YXRlZCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzQXBwU3dpdGNoZXJMaW5rQWN0aXZhdGVkXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzQXBwU3dpdGNoZXJMaW5rTW92ZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzQXBwU3dpdGNoZXJMaW5rTW92ZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc0FwcFN3aXRjaGVyTGlua1JlbW92ZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzQXBwU3dpdGNoZXJMaW5rUmVtb3ZlXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzQXBwU3dpdGNoZXJMaW5rQ2xpY2sgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0FwcFN3aXRjaGVyTGlua0NsaWNrXCIsIDcpO1xuICAgIHRoaXMuaXNGaXJzdFJvdyA9IGZhbHNlO1xuICAgIHRoaXMuaXNMYXN0Um93ID0gZmFsc2U7XG4gICAgdGhpcy5tb3ZlRWxlbWVudCA9IChrZXlDb2RlKSA9PiB7XG4gICAgICB0aGlzLmFyY2dpc0FwcFN3aXRjaGVyTGlua01vdmUuZW1pdCh7XG4gICAgICAgIHVpZDogdGhpcy5hcHAuaXRlbUlkIHx8IHRoaXMuYXBwLnRpdGxlLFxuICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAga2V5Q29kZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUtleSA9IChldnQpID0+IHtcbiAgICAgIGxldCBrZXlNYXRjaCA9IHRydWU7XG4gICAgICBzd2l0Y2ggKGV2dC5jb2RlKSB7XG4gICAgICAgIGNhc2UgXCJTcGFjZVwiOlxuICAgICAgICAgIHRoaXMuc29ydGluZ0FjdGl2ZSA9ICF0aGlzLnNvcnRpbmdBY3RpdmU7XG4gICAgICAgICAgdGhpcy5hcmNnaXNBcHBTd2l0Y2hlckxpbmtBY3RpdmF0ZWQuZW1pdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICBpZiAodGhpcy5zb3J0aW5nQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVFbGVtZW50KGV2dC5jb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAga2V5TWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5zb3J0aW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVJlbW92ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXJjZ2lzQXBwU3dpdGNoZXJMaW5rUmVtb3ZlLmVtaXQodGhpcy5hcHAuaXRlbUlkIHx8IHRoaXMuYXBwLnRpdGxlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlUmVtb3ZlS2V5ZG93biA9IChldnQpID0+IHtcbiAgICAgIHN3aXRjaCAoZXZ0LmNvZGUpIHtcbiAgICAgICAgY2FzZSBcIlNwYWNlXCI6XG4gICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgIHRoaXMuaGFuZGxlUmVtb3ZlKCk7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5hcmNnaXNBcHBTd2l0Y2hlckxpbmtDbGljay5lbWl0KCk7XG4gICAgfTtcbiAgICB0aGlzLmFwcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZGV4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG90YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb2N1c0l0ZW1JZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9wZW5UZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc29ydGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGNvbXBvbmVudERpZFJlbmRlcigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICh0aGlzLmZvY3VzSXRlbUlkICYmXG4gICAgICAodGhpcy5mb2N1c0l0ZW1JZCA9PT0gdGhpcy5hcHAuaXRlbUlkIHx8IHRoaXMuZm9jdXNJdGVtSWQgPT09IHRoaXMuYXBwLnRpdGxlKSkge1xuICAgICAgdGhpcy5zb3J0aW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmFwcC5jYW5BY2Nlc3MpIHtcbiAgICAgICAgKF9hID0gdGhpcy5saW5rRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghdGhpcy5hcHAuY2FuQWNjZXNzKSB7XG4gICAgICAgIChfYiA9IHRoaXMubWlzc2luZ0VsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5lbCkgPT09IFwicnRsXCI7XG4gICAgcmV0dXJuIChoKEhvc3QsIG51bGwsICgoX2EgPSB0aGlzLmFwcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbkFjY2VzcykgJiYgKGgoXCJhXCIsIHsgcmVmOiAoZWwpID0+ICh0aGlzLmxpbmtFbGVtZW50ID0gZWwpLCBocmVmOiB0aGlzLmFwcC51cmwsIGNsYXNzOiBcImFwcC1saW5rXCIsIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXksIG9uQmx1cjogdGhpcy5oYW5kbGVCbHVyLCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCBkcmFnZ2FibGU6IGZhbHNlLCB0YXJnZXQ6IFwiX2JsYW5rXCIsIHJvbGU6IFwibWVudWl0ZW1cIiB9LCBoKFwic3BhblwiLCB7IGNsYXNzOiBcImljb24td3JhcHBlclwiIH0sIGgoQXBwU3dpdGNoZXJMaW5rQXJyb3dzLCB7IGFjdGl2ZTogdGhpcy5zb3J0aW5nQWN0aXZlLCBpbmRleDogdGhpcy5pbmRleCwgdG90YWw6IHRoaXMudG90YWwgfSksICF0aGlzLmFwcC5pbWFnZSAmJiB0aGlzLmFwcC5hYmJyICYmIChoKFwic3BhblwiLCB7IHN0eWxlOiB7IGZvbnRTaXplOiB0aGlzLmFwcC5mb250U2l6ZSB8fCBcIjIwcHhcIiB9LCBjbGFzczogXCJhdmVuaXIgaWNvbi1hYmJyXCIgfSwgdGhpcy5hcHAuYWJicikpLCAhdGhpcy5hcHAuaW1hZ2UgJiYgdGhpcy5hcHAuYWJiciAmJiB0aGlzLmFwcC5wbGFjZUhvbGRlckljb24gJiYgKGgoXCJpbWdcIiwgeyBzcmM6IHRoaXMuYXBwLnBsYWNlSG9sZGVySWNvbiwgYWx0OiBcIlwiIH0pKSwgdGhpcy5hcHAuaW1hZ2UgJiYgaChcImltZ1wiLCB7IHNyYzogdGhpcy5hcHAuaW1hZ2UsIGNsYXNzOiBcImljb24taW1nXCIsIGFsdDogXCJcIiB9KSksIHRoaXMuYXBwLmlzTmV3ICYmIChoKFwic3BhblwiLCB7IGNsYXNzOiB7IGluZGljYXRvcjogdHJ1ZSwgXCJpbmRpY2F0b3ItLW5ld1wiOiB0cnVlLCBcImluZGljYXRvci0tbmV3LXJ0bFwiOiBydGwgfSB9KSksIGgoXCJzcGFuXCIsIHsgY2xhc3M6IFwibGFiZWwtdGV4dFwiIH0sIHRoaXMuYXBwLmxhYmVsKSwgaChcInNwYW5cIiwgeyBjbGFzczogXCJzY3JlZW4tcmVhZGVyc1wiIH0sIHRoaXMub3BlblRleHQpKSksIHRoaXMuYXBwICYmICF0aGlzLmFwcC5jYW5BY2Nlc3MgJiYgKGgoRnJhZ21lbnQsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogeyBpbmRpY2F0b3I6IHRydWUsIFwiaW5kaWNhdG9yLS1yZW1vdmVcIjogdHJ1ZSwgXCJpbmRpY2F0b3ItLXJlbW92ZS1ydGxcIjogcnRsIH0sIHRhYkluZGV4OiAwLCBvbkNsaWNrOiB0aGlzLmhhbmRsZVJlbW92ZSwgb25LZXlEb3duOiB0aGlzLmhhbmRsZVJlbW92ZUtleWRvd24gfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IHNjYWxlOiBcInNcIiwgaWNvbjogXCJ4XCIgfSkpLCBoKFwiZGl2XCIsIHsgcmVmOiAoZWwpID0+ICh0aGlzLm1pc3NpbmdFbGVtZW50ID0gZWwpLCBjbGFzczogXCJtaXNzaW5nLWljb25cIiwgdGFiSW5kZXg6IDAsIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXksIG9uQmx1cjogdGhpcy5oYW5kbGVCbHVyIH0sIGgoQXBwU3dpdGNoZXJMaW5rQXJyb3dzLCB7IGFjdGl2ZTogdGhpcy5zb3J0aW5nQWN0aXZlLCBpbmRleDogdGhpcy5pbmRleCwgdG90YWw6IHRoaXMudG90YWwgfSkpLCBoKFwicFwiLCB7IGNsYXNzOiBcImxhYmVsLXRleHRcIiB9LCB0aGlzLmFwcC5sYWJlbCkpKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNBcHBMaW5rLnN0eWxlID0gYXJjZ2lzQXBwU3dpdGNoZXJMaW5rQ3NzO1xuXG5leHBvcnQgeyBBcmNnaXNBcHBTd2l0Y2hlciBhcyBhcmNnaXNfYXBwX3N3aXRjaGVyLCBBcmNnaXNBcHBMaW5rIGFzIGFyY2dpc19hcHBfc3dpdGNoZXJfbGluayB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1hYWYzMGJkNi5qcyc7XG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTEzZjViMDBjLmpzJztcblxuY29uc3QgbGFuZ3VhZ2VNYXAgPSBuZXcgTWFwKFtcbiAgW1wiYXJcIiwgXCJhclwiXSxcbiAgW1wiYmdcIiwgXCJiZ1wiXSxcbiAgW1wiYnNcIiwgXCJic1wiXSxcbiAgW1wiY2FcIiwgXCJjYVwiXSxcbiAgW1wiY3NcIiwgXCJjc1wiXSxcbiAgW1wiZGFcIiwgXCJkYVwiXSxcbiAgW1wiZGVcIiwgXCJkZVwiXSxcbiAgW1wiZWxcIiwgXCJlbFwiXSxcbiAgW1wiZW5cIiwgXCJlblwiXSxcbiAgW1wiZXNcIiwgXCJlc1wiXSxcbiAgW1wiZXRcIiwgXCJldFwiXSxcbiAgW1wiZmlcIiwgXCJmaVwiXSxcbiAgW1wiZnJcIiwgXCJmclwiXSxcbiAgW1wiaGVcIiwgXCJoZVwiXSxcbiAgW1wiaHJcIiwgXCJoclwiXSxcbiAgW1wiaHVcIiwgXCJodVwiXSxcbiAgW1wiaWRcIiwgXCJpZFwiXSxcbiAgW1wiaXRcIiwgXCJpdFwiXSxcbiAgW1wiamFcIiwgXCJqYVwiXSxcbiAgW1wia29cIiwgXCJrb1wiXSxcbiAgW1wibHRcIiwgXCJsdFwiXSxcbiAgW1wibHZcIiwgXCJsdlwiXSxcbiAgW1wibmJcIiwgXCJuYlwiXSxcbiAgW1wibmxcIiwgXCJubFwiXSxcbiAgW1wicGxcIiwgXCJwbFwiXSxcbiAgW1wicHQtYnJcIiwgXCJwdC1CUlwiXSxcbiAgW1wicHQtcHRcIiwgXCJwdC1QVFwiXSxcbiAgW1wicm9cIiwgXCJyb1wiXSxcbiAgW1wicnVcIiwgXCJydVwiXSxcbiAgW1wic2tcIiwgXCJza1wiXSxcbiAgW1wic2xcIiwgXCJzbFwiXSxcbiAgW1wic3JcIiwgXCJzclwiXSxcbiAgW1wic3ZcIiwgXCJzdlwiXSxcbiAgW1widGhcIiwgXCJ0aFwiXSxcbiAgW1widHJcIiwgXCJ0clwiXSxcbiAgW1widWtcIiwgXCJ1a1wiXSxcbiAgW1widmlcIiwgXCJ2aVwiXSxcbiAgW1wiemgtY25cIiwgXCJ6aC1DTlwiXSxcbiAgW1wiemgtaGtcIiwgXCJ6aC1IS1wiXSxcbiAgW1wiemgtdHdcIiwgXCJ6aC1UV1wiXVxuXSk7XG4vLyBydGxcbmZ1bmN0aW9uIGdldEVsZW1lbnREaXIoZWwpIHtcbiAgcmV0dXJuIGdldEVsZW1lbnRQcm9wKGVsLCBcImRpclwiLCBcImx0clwiKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRQcm9wKGVsLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBjbG9zZXN0V2l0aFByb3AgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGBbJHtwcm9wfV1gKTtcbiAgcmV0dXJuIGNsb3Nlc3RXaXRoUHJvcCA/IGNsb3Nlc3RXaXRoUHJvcC5nZXRBdHRyaWJ1dGUocHJvcCkgOiB2YWx1ZTtcbn1cbi8vIGNzc1xuY29uc3QgQ1NTX1VUSUxJVFkgPSB7XG4gIHJ0bDogXCJhcmNnaXMtLXJ0bFwiXG59O1xuYXN5bmMgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlciwgb3B0aW9ucykge1xuICBjb25zdCB7IGFwaSwgdHlwZSwgcGxhY2VzIH0gPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoYXBpID09PSA0KSB7XG4gICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICBjb25zdCBudW1iZXJGb3JtYXRJbnRsT3B0aW9ucyA9IGludGwuY29udmVydE51bWJlckZvcm1hdFRvSW50bE9wdGlvbnMoe1xuICAgICAgcGxhY2VzLFxuICAgICAgc3R5bGU6IHR5cGUsXG4gICAgICBkaWdpdFNlcGFyYXRvcjogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBpbnRsLmZvcm1hdE51bWJlcihudW1iZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMpLCB7IHN0eWxlOiB0eXBlIH0pKTtcbiAgfVxuICBjb25zdCBbZG9qb051bWJlcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJkb2pvL251bWJlclwiXSk7XG4gIHJldHVybiBkb2pvTnVtYmVyLmZvcm1hdChudW1iZXIsIHtcbiAgICB0eXBlLFxuICAgIHBsYWNlcyxcbiAgICBwYXR0ZXJuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGF0dGVyblxuICB9KTtcbn1cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgY29uc3QgbGFuZyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nO1xuICBjb25zdCBkYXlTaG9ydE1vbnRoWWVhciA9IHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJzaG9ydFwiLFxuICAgIGRheTogXCJudW1lcmljXCJcbiAgfTtcbiAgaWYgKCFjYWNoZVtsYW5nXSkge1xuICAgIGNhY2hlW2xhbmddID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcsIGRheVNob3J0TW9udGhZZWFyKTtcbiAgfVxuICByZXR1cm4gY2FjaGVbbGFuZ10uZm9ybWF0KGRhdGUpO1xufVxuXG5leHBvcnQgeyBDU1NfVVRJTElUWSBhcyBDLCBmb3JtYXREYXRlIGFzIGEsIGZvcm1hdE51bWJlciBhcyBmLCBnZXRFbGVtZW50RGlyIGFzIGcsIGxhbmd1YWdlTWFwIGFzIGwgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIFwicnUtUlVcIiBtYXBzIHRvIFwicnVcIiB1c2UgY2FzZVxuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZy5zbGljZSgwLCAyKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgLy8gaXQncyBPSyBpZiB3ZSBkb24ndCBoYXZlIHRoZSA0IGxldHRlciBsYW5ndWFnZSBmaWxlIGZvciBpdFxuICAvLyA0IGxldHRlciBsYW5ndWFnZSBjb2RlIG5lZWRlZCBmb3IgZm9ybWF0dGluZyBudW1iZXJzXG4gIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgIHJldHVybiBsYW5nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBcImVuXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2goZ2V0QXNzZXRQYXRoKGAuLi9hcmNnaXMtYXBwLWFzc2V0cy9pMThuLyR7Y29tcG9uZW50TmFtZX0uaTE4bi4ke2xvY2FsZX0uanNvbmApKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQub2spXG4gICAgICAgIHJlc29sdmUocmVzdWx0Lmpzb24oKSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlamVjdCgpO1xuICAgIH0sICgpID0+IHJlamVjdCgpKTtcbiAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICBjb25zdCBpZCA9IGAke2NvbXBvbmVudE5hbWV9JHtsb2NhbGV9YDtcbiAgaWYgKCFzdHJpbmdDYWNoZVtpZF0pIHtcbiAgICBzdHJpbmdDYWNoZVtpZF0gPSBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBjb21wb25lbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KTtcbiAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgbGV0IHN0cmluZ3M7XG4gIHRyeSB7XG4gICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBjb21wb25lbnRMYW5ndWFnZSk7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oYG5vIGxvY2FsZSBmb3IgJHtjb21wb25lbnROYW1lfSAoJHtjb21wb25lbnRMYW5ndWFnZX0pIGxvYWRpbmcgZGVmYXVsdCBsb2NhbGUgZW4uYCk7XG4gICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBcImVuXCIpO1xuICB9XG4gIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgZSBhcyBlc2NhcGVSZWdFeHAgfSBmcm9tICcuL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMnO1xuXG4vLyBpbXBvcnQgc3RyaW5nVXRpbCBmcm9tIFwiLi9zdHJpbmdzXCI7XG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kcyBmb3IgZGVhbGluZyB3aXRoIHN0b3JhZ2Ugb2YgdmFyaW91cyBmb3JtcyAoY29va2llcywgbG9jYWwgc3RvcmFnZSwgYW5kIHNlc3Npb24gc3RvcmFnZSkuXG4gKi9cbmZ1bmN0aW9uIHNldENvb2tpZShuYW1lLCBjb29raWUsIHByb3BlcnRpZXMsIHN0cmluZ2lmeSkge1xuICB3cml0ZUNvb2tpZShuYW1lLCBzdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShjb29raWUpIDogY29va2llLCBwcm9wZXJ0aWVzKTtcbn1cbmZ1bmN0aW9uIGdldENvb2tpZShuYW1lLCBwYXJzZSkge1xuICBjb25zdCBjb29raWUgPSByZWFkQ29va2llKG5hbWUpO1xuICByZXR1cm4gY29va2llICYmIHBhcnNlID8gSlNPTi5wYXJzZShjb29raWUpIDogY29va2llO1xufVxuZnVuY3Rpb24gc2V0TG9jYWxTdG9yYWdlSXRlbShuYW1lLCBpdGVtLCBzdHJpbmdpZnkpIHtcbiAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHN0cmluZ2lmeSA/IEpTT04uc3RyaW5naWZ5KGl0ZW0pIDogaXRlbSk7XG59XG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VJdGVtKG5hbWUsIHBhcnNlKSB7XG4gIGNvbnN0IGl0ZW0gPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gIHJldHVybiBpdGVtICYmIHBhcnNlID8gSlNPTi5wYXJzZShpdGVtKSA6IGl0ZW07XG59XG5mdW5jdGlvbiBzZXRTZXNzaW9uU3RvcmFnZUl0ZW0obmFtZSwgaXRlbSwgc3RyaW5naWZ5KSB7XG4gIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHN0cmluZ2lmeSA/IEpTT04uc3RyaW5naWZ5KGl0ZW0pIDogaXRlbSk7XG59XG5mdW5jdGlvbiBnZXRTZXNzaW9uU3RvcmFnZUl0ZW0obmFtZSwgcGFyc2UpIHtcbiAgY29uc3QgaXRlbSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICByZXR1cm4gaXRlbSAmJiBwYXJzZSA/IEpTT04ucGFyc2UoaXRlbSkgOiBpdGVtO1xufVxuZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lKSB7XG4gIGNvbnN0IGNvb2tpZSA9IGRvY3VtZW50LmNvb2tpZTtcbiAgY29uc3QgY29va2llTmFtZVJFID0gbmV3IFJlZ0V4cChgKD86Xnw7ICkke2VzY2FwZVJlZ0V4cChuYW1lKX09KFteO10qKWApO1xuICBjb25zdCBtYXRjaGVkQ29va2llcyA9IGNvb2tpZS5tYXRjaChjb29raWVOYW1lUkUpO1xuICByZXR1cm4gbWF0Y2hlZENvb2tpZXMgPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hlZENvb2tpZXNbMV0pIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gd3JpdGVDb29raWUobmFtZSwgdmFsdWUsIHByb3BlcnRpZXMpIHtcbiAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gIGxldCBleHBpcmVzID0gcHJvcGVydGllcyA9PT0gbnVsbCB8fCBwcm9wZXJ0aWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wZXJ0aWVzLmV4cGlyZXM7XG4gIGlmICh0eXBlb2YgZXhwaXJlcyA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvbnN0IGV4cGlyYXRpb25EYXRlID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBkYXlzRnJvbVRvZGF5SW5NcyA9IGV4cGlyZXMgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgIGV4cGlyYXRpb25EYXRlLnNldFRpbWUoRGF0ZS5ub3coKSArIGRheXNGcm9tVG9kYXlJbk1zKTtcbiAgICBleHBpcmVzID0gcHJvcGVydGllcy5leHBpcmVzID0gZXhwaXJhdGlvbkRhdGU7XG4gIH1cbiAgaWYgKHR5cGVvZiBleHBpcmVzICE9PSBcInN0cmluZ1wiICYmIChleHBpcmVzID09PSBudWxsIHx8IGV4cGlyZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cGlyZXMudG9VVENTdHJpbmcpKSB7XG4gICAgcHJvcGVydGllcy5leHBpcmVzID0gZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICB9XG4gIGxldCBjb29raWUgPSBgJHtuYW1lfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbiAgbGV0IHByb3BlcnR5O1xuICBmb3IgKHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICBjb29raWUgKz0gYDsgJHtwcm9wZXJ0eX1gO1xuICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICBpZiAocHJvcGVydHlWYWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgY29va2llICs9IGA9JHtwcm9wZXJ0eVZhbHVlfWA7XG4gICAgfVxuICB9XG4gIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29va2llIGFzIGEsIHNldENvb2tpZSBhcyBiLCBzZXRTZXNzaW9uU3RvcmFnZUl0ZW0gYXMgYywgZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtIGFzIGQsIGdldExvY2FsU3RvcmFnZUl0ZW0gYXMgZywgc2V0TG9jYWxTdG9yYWdlSXRlbSBhcyBzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=