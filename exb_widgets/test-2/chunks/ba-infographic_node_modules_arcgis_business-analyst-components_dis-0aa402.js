"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-0aa402"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/infographics-step-9e7ffb8d.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/infographics-step-9e7ffb8d.js ***!
  \***********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ updateMessages),
/* harmony export */   B: () => (/* binding */ BufferTypesValues),
/* harmony export */   C: () => (/* binding */ BufferUnitsValues),
/* harmony export */   D: () => (/* binding */ BuffersStep),
/* harmony export */   E: () => (/* binding */ SearchStep),
/* harmony export */   H: () => (/* binding */ H),
/* harmony export */   I: () => (/* binding */ InfographicsStep),
/* harmony export */   S: () => (/* binding */ StepValues),
/* harmony export */   a: () => (/* binding */ connectLocalized),
/* harmony export */   b: () => (/* binding */ setComponentLoaded),
/* harmony export */   c: () => (/* binding */ createEvent),
/* harmony export */   d: () => (/* binding */ defineCustomElement$8),
/* harmony export */   e: () => (/* binding */ disconnectLocalized),
/* harmony export */   f: () => (/* binding */ focusElementInGroup),
/* harmony export */   g: () => (/* binding */ getElementProp),
/* harmony export */   h: () => (/* binding */ h),
/* harmony export */   i: () => (/* binding */ Host),
/* harmony export */   j: () => (/* binding */ componentLoaded),
/* harmony export */   k: () => (/* binding */ defineCustomElement$7),
/* harmony export */   l: () => (/* binding */ createObserver),
/* harmony export */   m: () => (/* binding */ submitForm),
/* harmony export */   n: () => (/* binding */ numberStringFormatter),
/* harmony export */   o: () => (/* binding */ connectMessages),
/* harmony export */   p: () => (/* binding */ proxyCustomElement),
/* harmony export */   q: () => (/* binding */ connectLabel),
/* harmony export */   r: () => (/* binding */ resetForm),
/* harmony export */   s: () => (/* binding */ setUpLoadableComponent),
/* harmony export */   t: () => (/* binding */ toAriaBoolean),
/* harmony export */   u: () => (/* binding */ updateHostInteraction),
/* harmony export */   v: () => (/* binding */ closestElementCrossShadowBoundary),
/* harmony export */   w: () => (/* binding */ disconnectLabel),
/* harmony export */   x: () => (/* binding */ disconnectMessages),
/* harmony export */   y: () => (/* binding */ setUpMessages),
/* harmony export */   z: () => (/* binding */ getLabelText)
/* harmony export */ });
/* harmony import */ var _index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-4e647411.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-4e647411.js");
/* harmony import */ var _base_util_b7db69f0_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base-util-b7db69f0.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/base-util-b7db69f0.js");
/* harmony import */ var _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ElementIds-a2c40592.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/ElementIds-a2c40592.js");






var MaxBuffers;
(function (MaxBuffers) {
  MaxBuffers[MaxBuffers["Rings"] = 1000] = "Rings";
  MaxBuffers[MaxBuffers["DriveMinutes"] = 300] = "DriveMinutes";
  MaxBuffers[MaxBuffers["DriveMile"] = 300] = "DriveMile";
  MaxBuffers[MaxBuffers["DriveKm"] = 482.8] = "DriveKm";
  MaxBuffers[MaxBuffers["WalkMinutes"] = 300] = "WalkMinutes";
  MaxBuffers[MaxBuffers["WalkMile"] = 27] = "WalkMile";
  MaxBuffers[MaxBuffers["WalkKm"] = 43.45] = "WalkKm";
})(MaxBuffers || (MaxBuffers = {}));
var MinBuffers;
(function (MinBuffers) {
  MinBuffers[MinBuffers["Rings"] = 0.1] = "Rings";
  MinBuffers[MinBuffers["Drive"] = 1] = "Drive";
  MinBuffers[MinBuffers["Walk"] = 1] = "Walk";
})(MinBuffers || (MinBuffers = {}));
const BufferTypesValues = {
  ring: 'ring',
  drivetime: 'drivetime',
  walktime: 'walktime',
};
const BufferUnitsValues = {
  minutes: 'minutes',
  kilometers: 'kilometers',
  miles: 'miles',
};
const StepValues = {
  search: 'Search',
  buffers: 'Buffers',
  infographics: 'Infographics',
};

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */
let scopeId;
let hostTagName;
let isSvgMode = false;
let queuePending = false;
const getAssetPath = (path) => {
    const assetUrl = new URL(path, plt.$resourcesUrl$);
    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
const createTime = (fnName, tagName = '') => {
    {
        return () => {
            return;
        };
    }
};
const uniqueTime = (key, measureText) => {
    {
        return () => {
            return;
        };
    }
};
const XLINK_NS = 'http://www.w3.org/1999/xlink';
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
/**
 * Namespaces
 */
const SVG_NS = 'http://www.w3.org/2000/svg';
const HTML_NS = 'http://www.w3.org/1999/xhtml';
const isDef = (v) => v != null;
const isComplexType = (o) => {
    // https://jsperf.com/typeof-fn-object/5
    o = typeof o;
    return o === 'object' || o === 'function';
};
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// const stack: any[] = [];
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (nodeName, vnodeData, ...children) => {
    let child = null;
    let key = null;
    let simple = false;
    let lastSimple = false;
    const vNodeChildren = [];
    const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
            child = c[i];
            if (Array.isArray(child)) {
                walk(child);
            }
            else if (child != null && typeof child !== 'boolean') {
                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
                    child = String(child);
                }
                if (simple && lastSimple) {
                    // If the previous child was simple (string), we merge both
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                }
                else {
                    // Append a new vNode, if it's text, we create a text vNode
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        // normalize class / classname attributes
        if (vnodeData.key) {
            key = vnodeData.key;
        }
        {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class =
                    typeof classData !== 'object'
                        ? classData
                        : Object.keys(classData)
                            .filter((k) => classData[k])
                            .join(' ');
            }
        }
    }
    if (typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    {
        vnode.$key$ = key;
    }
    return vnode;
};
const newVNode = (tag, text) => {
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null,
    };
    {
        vnode.$attrs$ = null;
    }
    {
        vnode.$key$ = null;
    }
    return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
const vdomFnUtils = {
    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
};
const convertToPublic = (node) => ({
    vattrs: node.$attrs$,
    vchildren: node.$children$,
    vkey: node.$key$,
    vname: node.$name$,
    vtag: node.$tag$,
    vtext: node.$text$,
});
const convertToPrivate = (node) => {
    if (typeof node.vtag === 'function') {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...(node.vchildren || []));
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */
const parsePropertyValue = (propValue, propType) => {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
        if (propType & 4 /* MEMBER_FLAGS.Boolean */) {
            // per the HTML spec, any string value means it is a boolean true value
            // but we'll cheat here and say that the string "false" is the boolean false
            return propValue === 'false' ? false : propValue === '' || !!propValue;
        }
        if (propType & 2 /* MEMBER_FLAGS.Number */) {
            // force it to be a number
            return parseFloat(propValue);
        }
        if (propType & 1 /* MEMBER_FLAGS.String */) {
            // could have been passed as a number or boolean
            // but we still want it as a string
            return String(propValue);
        }
        // redundant return here for better minification
        return propValue;
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
};
const getElement = (ref) => (getHostRef(ref).$hostElement$ );
const createEvent = (ref, name, flags) => {
    const elm = getElement(ref);
    return {
        emit: (detail) => {
            return emitEvent(elm, name, {
                bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),
                composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),
                cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),
                detail,
            });
        },
    };
};
/**
 * Helper function to create & dispatch a custom Event on a provided target
 * @param elm the target of the Event
 * @param name the name to give the custom Event
 * @param opts options for configuring a custom Event
 * @returns the custom Event
 */
const emitEvent = (elm, name, opts) => {
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
const rootAppliedStyles = /*@__PURE__*/ new WeakMap();
const registerStyle = (scopeId, cssText, allowCS) => {
    let style = styles.get(scopeId);
    if (supportsConstructableStylesheets && allowCS) {
        style = (style || new CSSStyleSheet());
        if (typeof style === 'string') {
            style = cssText;
        }
        else {
            style.replaceSync(cssText);
        }
    }
    else {
        style = cssText;
    }
    styles.set(scopeId, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
    let scopeId = getScopeId(cmpMeta);
    const style = styles.get(scopeId);
    // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases
    styleContainerNode = styleContainerNode.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? styleContainerNode : doc;
    if (style) {
        if (typeof style === 'string') {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));
            }
            if (!appliedStyles.has(scopeId)) {
                {
                    {
                        styleElm = doc.createElement('style');
                        styleElm.innerHTML = style;
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId);
                }
            }
        }
        else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
    }
    return scopeId;
};
const attachStyles = (hostRef) => {
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    const scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
    if (flags & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
    }
    endAttachStyles();
};
const getScopeId = (cmp, mode) => 'sc-' + (cmp.$tagName$);
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (memberName === 'class') {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
        }
        else if (memberName === 'style') {
            // update style attribute, css properties and values
            {
                for (const prop in oldValue) {
                    if (!newValue || newValue[prop] == null) {
                        if (prop.includes('-')) {
                            elm.style.removeProperty(prop);
                        }
                        else {
                            elm.style[prop] = '';
                        }
                    }
                }
            }
            for (const prop in newValue) {
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (prop.includes('-')) {
                        elm.style.setProperty(prop, newValue[prop]);
                    }
                    else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        }
        else if (memberName === 'key')
            ;
        else if (memberName === 'ref') {
            // minifier will clean this up
            if (newValue) {
                newValue(elm);
            }
        }
        else if ((!isProp ) &&
            memberName[0] === 'o' &&
            memberName[1] === 'n') {
            // Event Handlers
            // so if the member name starts with "on" and the 3rd characters is
            // a capital letter, and it's not already a member on the element,
            // then we're assuming it's an event listener
            if (memberName[2] === '-') {
                // on- prefixed events
                // allows to be explicit about the dom event to listen without any magic
                // under the hood:
                // <my-cmp on-click> // listens for "click"
                // <my-cmp on-Click> // listens for "Click"
                // <my-cmp on-ionChange> // listens for "ionChange"
                // <my-cmp on-EVENTS> // listens for "EVENTS"
                memberName = memberName.slice(3);
            }
            else if (isMemberInElement(win, ln)) {
                // standard event
                // the JSX attribute could have been "onMouseOver" and the
                // member name "onmouseover" is on the window's prototype
                // so let's add the listener "mouseover", which is all lowercased
                memberName = ln.slice(2);
            }
            else {
                // custom event
                // the JSX attribute could have been "onMyCustomEvent"
                // so let's trim off the "on" prefix and lowercase the first character
                // and add the listener "myCustomEvent"
                // except for the first character, we keep the event name case
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        }
        else {
            // Set property if it exists and it's not a SVG
            const isComplex = isComplexType(newValue);
            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
                try {
                    if (!elm.tagName.includes('-')) {
                        const n = newValue == null ? '' : newValue;
                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                        if (memberName === 'list') {
                            isProp = false;
                        }
                        else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    }
                    else {
                        elm[memberName] = newValue;
                    }
                }
                catch (e) { }
            }
            /**
             * Need to manually update attribute if:
             * - memberName is not an attribute
             * - if we are rendering the host element in order to reflect attribute
             * - if it's a SVG, since properties might not work in <svg>
             * - if the newValue is null/undefined or 'false'.
             */
            let xlink = false;
            {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === '') {
                    if (xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    }
                    else {
                        elm.removeAttribute(memberName);
                    }
                }
            }
            else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {
                newValue = newValue === true ? '' : newValue;
                if (xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                }
                else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host
        ? newVnode.$elm$.host
        : newVnode.$elm$;
    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    {
        // remove attributes no longer present on the vnode by setting them to undefined
        for (memberName in oldVnodeAttrs) {
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
            }
        }
    }
    // add new & update changed attributes
    for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
};
/**
 * Create a DOM Node corresponding to one of the children of a given VNode.
 *
 * @param oldParentVNode the parent VNode from the previous render
 * @param newParentVNode the parent VNode from the current render
 * @param childIndex the index of the VNode, in the _new_ parent node's
 * children, for which we will create a new DOM node
 * @param parentElm the parent DOM node which our new node will be a child of
 * @returns the newly created node
 */
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
    // tslint:disable-next-line: prefer-const
    const newVNode = newParentVNode.$children$[childIndex];
    let i = 0;
    let elm;
    let childNode;
    if (newVNode.$text$ !== null) {
        // create text node
        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    }
    else {
        if (!isSvgMode) {
            isSvgMode = newVNode.$tag$ === 'svg';
        }
        // create element
        elm = newVNode.$elm$ = (doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode.$tag$)
            );
        if (isSvgMode && newVNode.$tag$ === 'foreignObject') {
            isSvgMode = false;
        }
        // add css classes, attrs, props, listeners, etc.
        {
            updateElement(null, newVNode, isSvgMode);
        }
        if (isDef(scopeId) && elm['s-si'] !== scopeId) {
            // if there is a scopeId and this is the initial render
            // then let's add the scopeId as a css class
            elm.classList.add((elm['s-si'] = scopeId));
        }
        if (newVNode.$children$) {
            for (i = 0; i < newVNode.$children$.length; ++i) {
                // create the node
                childNode = createElm(oldParentVNode, newVNode, i);
                // return node could have been null
                if (childNode) {
                    // append our new node
                    elm.appendChild(childNode);
                }
            }
        }
        {
            if (newVNode.$tag$ === 'svg') {
                // Only reset the SVG context when we're exiting <svg> element
                isSvgMode = false;
            }
            else if (elm.tagName === 'foreignObject') {
                // Reenter SVG context when we're exiting <foreignObject> element
                isSvgMode = true;
            }
        }
    }
    return elm;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
    let containerElm = (parentElm);
    let childNode;
    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, before);
            }
        }
    }
};
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
    for (; startIdx <= endIdx; ++startIdx) {
        if ((vnode = vnodes[startIdx])) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            // remove the vnode's element from the dom
            elm.remove();
        }
    }
};
/**
 * Reconcile the children of a new VNode with the children of an old VNode by
 * traversing the two collections of children, identifying nodes that are
 * conserved or changed, calling out to `patch` to make any necessary
 * updates to the DOM, and rearranging DOM nodes as needed.
 *
 * The algorithm for reconciling children works by analyzing two 'windows' onto
 * the two arrays of children (`oldCh` and `newCh`). We keep track of the
 * 'windows' by storing start and end indices and references to the
 * corresponding array entries. Initially the two 'windows' are basically equal
 * to the entire array, but we progressively narrow the windows until there are
 * no children left to update by doing the following:
 *
 * 1. Skip any `null` entries at the beginning or end of the two arrays, so
 *    that if we have an initial array like the following we'll end up dealing
 *    only with a window bounded by the highlighted elements:
 *
 *    [null, null, VNode1 , ... , VNode2, null, null]
 *                 ^^^^^^         ^^^^^^
 *
 * 2. Check to see if the elements at the head and tail positions are equal
 *    across the windows. This will basically detect elements which haven't
 *    been added, removed, or changed position, i.e. if you had the following
 *    VNode elements (represented as HTML):
 *
 *    oldVNode: `<div><p><span>HEY</span></p></div>`
 *    newVNode: `<div><p><span>THERE</span></p></div>`
 *
 *    Then when comparing the children of the `<div>` tag we check the equality
 *    of the VNodes corresponding to the `<p>` tags and, since they are the
 *    same tag in the same position, we'd be able to avoid completely
 *    re-rendering the subtree under them with a new DOM element and would just
 *    call out to `patch` to handle reconciling their children and so on.
 *
 * 3. Check, for both windows, to see if the element at the beginning of the
 *    window corresponds to the element at the end of the other window. This is
 *    a heuristic which will let us identify _some_ situations in which
 *    elements have changed position, for instance it _should_ detect that the
 *    children nodes themselves have not changed but merely moved in the
 *    following example:
 *
 *    oldVNode: `<div><element-one /><element-two /></div>`
 *    newVNode: `<div><element-two /><element-one /></div>`
 *
 *    If we find cases like this then we also need to move the concrete DOM
 *    elements corresponding to the moved children to write the re-order to the
 *    DOM.
 *
 * 4. Finally, if VNodes have the `key` attribute set on them we check for any
 *    nodes in the old children which have the same key as the first element in
 *    our window on the new children. If we find such a node we handle calling
 *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
 *    what we find.
 *
 * Finally, once we've narrowed our 'windows' to the point that either of them
 * collapse (i.e. they have length 0) we then handle any remaining VNode
 * insertion or deletion that needs to happen to get a DOM state that correctly
 * reflects the new child VNodes. If, for instance, after our window on the old
 * children has collapsed we still have more nodes on the new children that
 * we haven't dealt with yet then we need to add them, or if the new children
 * collapse but we still have unhandled _old_ children then we need to make
 * sure the corresponding DOM nodes are removed.
 *
 * @param parentElm the node into which the parent VNode is rendered
 * @param oldCh the old children of the parent node
 * @param newVNode the new VNode which will replace the parent
 * @param newCh the new children of the parent node
 */
const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
            // VNode might have been moved left
            oldStartVnode = oldCh[++oldStartIdx];
        }
        else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        }
        else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        }
        else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newStartVnode)) {
            // if the start nodes are the same then we should patch the new VNode
            // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
            // indices to reflect that. We don't need to move any DOM Nodes around
            // since things are matched up in order.
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else if (isSameVnode(oldEndVnode, newEndVnode)) {
            // likewise, if the end nodes are the same we patch new onto old and
            // decrement our end indices, and also likewise in this case we don't
            // need to move any DOM Nodes.
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newEndVnode)) {
            patch(oldStartVnode, newEndVnode);
            // We need to move the element for `oldStartVnode` into a position which
            // will be appropriate for `newEndVnode`. For this we can use
            // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
            // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
            // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
            //
            // <old-start-node />
            // <some-intervening-node />
            // <old-end-node />
            // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
            // <next-sibling />
            //
            // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
            // the node for `oldStartVnode` at the end of the children of
            // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
            // aren't any siblings, and passing `null` to `Node.insertBefore` will
            // append it to the children of the parent element.
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldEndVnode, newStartVnode)) {
            patch(oldEndVnode, newStartVnode);
            // We've already checked above if `oldStartVnode` and `newStartVnode` are
            // the same node, so since we're here we know that they are not. Thus we
            // can move the element for `oldEndVnode` _before_ the element for
            // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
            // future.
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else {
            // Here we do some checks to match up old and new nodes based on the
            // `$key$` attribute, which is set by putting a `key="my-key"` attribute
            // in the JSX for a DOM element in the implementation of a Stencil
            // component.
            //
            // First we check to see if there are any nodes in the array of old
            // children which have the same key as the first node in the new
            // children.
            idxInOld = -1;
            {
                for (i = oldStartIdx; i <= oldEndIdx; ++i) {
                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                        idxInOld = i;
                        break;
                    }
                }
            }
            if (idxInOld >= 0) {
                // We found a node in the old children which matches up with the first
                // node in the new children! So let's deal with that
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    // the tag doesn't match so we'll need a new DOM element
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld);
                }
                else {
                    patch(elmToMove, newStartVnode);
                    // invalidate the matching old node so that we won't try to update it
                    // again later on
                    oldCh[idxInOld] = undefined;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                // We either didn't find an element in the old children that matches
                // the key of the first new child OR the build is not using `key`
                // attributes at all. In either case we need to create a new element
                // for the new node.
                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                // if we created a new node then handle inserting it to the DOM
                {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        // we have some more new nodes to add which don't match up with old nodes
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    }
    else if (newStartIdx > newEndIdx) {
        // there are nodes in the `oldCh` array which no longer correspond to nodes
        // in the new array, so lets remove them (which entails cleaning up the
        // relevant DOM nodes)
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
/**
 * Compare two VNodes to determine if they are the same
 *
 * **NB**: This function is an equality _heuristic_ based on the available
 * information set on the two VNodes and can be misleading under certain
 * circumstances. In particular, if the two nodes do not have `key` attrs
 * (available under `$key$` on VNodes) then the function falls back on merely
 * checking that they have the same tag.
 *
 * So, in other words, if `key` attrs are not set on VNodes which may be
 * changing order within a `children` array or something along those lines then
 * we could obtain a false positive and then have to do needless re-rendering.
 *
 * @param leftVNode the first VNode to check
 * @param rightVNode the second VNode to check
 * @returns whether they're equal or not
 */
const isSameVnode = (leftVNode, rightVNode) => {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (leftVNode.$tag$ === rightVNode.$tag$) {
        // this will be set if components in the build have `key` attrs set on them
        {
            return leftVNode.$key$ === rightVNode.$key$;
        }
    }
    return false;
};
/**
 * Handle reconciling an outdated VNode with a new one which corresponds to
 * it. This function handles flushing updates to the DOM and reconciling the
 * children of the two nodes (if any).
 *
 * @param oldVNode an old VNode whose DOM element and children we want to update
 * @param newVNode a new VNode representing an updated version of the old one
 */
const patch = (oldVNode, newVNode) => {
    const elm = (newVNode.$elm$ = oldVNode.$elm$);
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode.$children$;
    const tag = newVNode.$tag$;
    const text = newVNode.$text$;
    if (text === null) {
        {
            // test if we're rendering an svg element, or still rendering nodes inside of one
            // only add this to the when the compiler sees we're using an svg somewhere
            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
        }
        {
            if (tag === 'slot')
                ;
            else {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(oldVNode, newVNode, isSvgMode);
            }
        }
        if (oldChildren !== null && newChildren !== null) {
            // looks like there's child vnodes for both the old and new vnodes
            // so we need to call `updateChildren` to reconcile them
            updateChildren(elm, oldChildren, newVNode, newChildren);
        }
        else if (newChildren !== null) {
            // no old child vnodes, but there are new child vnodes to add
            if (oldVNode.$text$ !== null) {
                // the old vnode was text, so be sure to clear it out
                elm.textContent = '';
            }
            // add the new vnode children
            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
        }
        else if (oldChildren !== null) {
            // no new child vnodes, but there are old child vnodes to remove
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (isSvgMode && tag === 'svg') {
            isSvgMode = false;
        }
    }
    else if (oldVNode.$text$ !== text) {
        // update the text content for the text only vnode
        // and also only if the text is different than before
        elm.data = text;
    }
};
const callNodeRefs = (vNode) => {
    {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
const renderVdom = (hostRef, renderFnResults) => {
    const hostElm = hostRef.$hostElement$;
    const cmpMeta = hostRef.$cmpMeta$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    if (cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));
    }
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm.shadowRoot || hostElm );
    {
        scopeId = hostElm['s-sc'];
    }
    // synchronous patch
    patch(oldVNode, rootVnode);
};
const attachToAncestor = (hostRef, ancestorComponent) => {
    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
    }
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
    {
        hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
    }
    if (hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
        hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    // there is no ancestor component or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update
    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
    return writeTask(dispatch) ;
};
const dispatchHooks = (hostRef, isInitialLoad) => {
    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    const instance = hostRef.$lazyInstance$ ;
    let promise;
    if (isInitialLoad) {
        {
            hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;
            if (hostRef.$queuedListeners$) {
                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
                hostRef.$queuedListeners$ = null;
            }
        }
        {
            promise = safeCall(instance, 'componentWillLoad');
        }
    }
    {
        promise = then(promise, () => safeCall(instance, 'componentWillRender'));
    }
    endSchedule();
    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
    // updateComponent
    const elm = hostRef.$hostElement$;
    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    const rc = elm['s-rc'];
    if (isInitialLoad) {
        // DOM WRITE!
        attachStyles(hostRef);
    }
    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    {
        callRender(hostRef, instance);
    }
    if (rc) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        rc.map((cb) => cb());
        elm['s-rc'] = undefined;
    }
    endRender();
    endUpdate();
    {
        const childrenPromises = elm['s-p'];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
            postUpdate();
        }
        else {
            Promise.all(childrenPromises).then(postUpdate);
            hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
            childrenPromises.length = 0;
        }
    }
};
const callRender = (hostRef, instance, elm) => {
    try {
        instance = instance.render() ;
        {
            hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
        }
        {
            hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;
        }
        {
            {
                // looks like we've got child nodes to render into this host element
                // or we need to update the css class/attrs on the host element
                // DOM WRITE!
                {
                    renderVdom(hostRef, instance);
                }
            }
        }
    }
    catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    return null;
};
const postUpdateComponent = (hostRef) => {
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime('postUpdate', tagName);
    const instance = hostRef.$lazyInstance$ ;
    const ancestorComponent = hostRef.$ancestorComponent$;
    {
        safeCall(instance, 'componentDidRender');
    }
    if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
        hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
        {
            // DOM WRITE!
            addHydratedFlag(elm);
        }
        {
            safeCall(instance, 'componentDidLoad');
        }
        endPostUpdate();
        {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad();
            }
        }
    }
    else {
        {
            safeCall(instance, 'componentDidUpdate');
        }
        endPostUpdate();
    }
    {
        hostRef.$onInstanceResolve$(elm);
    }
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = undefined;
        }
        if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {
            nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);
    }
    // ( •_•)
    // ( •_•)>⌐■-■
    // (⌐■_■)
};
const forceUpdate = (ref) => {
    {
        const hostRef = getHostRef(ref);
        const isConnected = hostRef.$hostElement$.isConnected;
        if (isConnected &&
            (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
            scheduleUpdate(hostRef, false);
        }
        // Returns "true" when the forced update was successfully scheduled
        return isConnected;
    }
};
const appDidLoad = (who) => {
    // on appload
    // we have finish the first big initial render
    {
        addHydratedFlag(doc.documentElement);
    }
    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: _index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.N } }));
};
const safeCall = (instance, method, arg) => {
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        }
        catch (e) {
            consoleError(e);
        }
    }
    return undefined;
};
const then = (promise, thenFn) => {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
const addHydratedFlag = (elm) => elm.classList.add('hydrated')
    ;
const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
    // check our new property value against our internal value
    const hostRef = getHostRef(ref);
    const elm = hostRef.$hostElement$ ;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = hostRef.$lazyInstance$ ;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    // explicitly check for NaN on both sides, as `NaN === NaN` is always false
    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
    const didValueChange = newVal !== oldVal && !areBothNaN;
    if ((!(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        hostRef.$instanceValues$.set(propName, newVal);
        if (instance) {
            // get an array of method names of watch functions to call
            if (cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    // this instance is watching for when this property changed
                    watchMethods.map((watchMethodName) => {
                        try {
                            // fire off each of the watch methods that are watching this property
                            instance[watchMethodName](newVal, oldVal, propName);
                        }
                        catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if ((flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
                if (instance.componentShouldUpdate) {
                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                        return;
                    }
                }
                // looks like this value actually changed, so we've got work to do!
                // but only if we've already rendered, otherwise just chill out
                // queue that we need to do an update, but don't worry about queuing
                // up millions cuz this function ensures it only runs once
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
/**
 * Attach a series of runtime constructs to a compiled Stencil component
 * constructor, including getters and setters for the `@Prop` and `@State`
 * decorators, callbacks for when attributes change, and so on.
 *
 * @param Cstr the constructor for a component that we need to process
 * @param cmpMeta metadata collected previously about the component
 * @param flags a number used to store a series of bit flags
 * @returns a reference to the same constructor passed in (but now mutated)
 */
const proxyComponent = (Cstr, cmpMeta, flags) => {
    if (cmpMeta.$members$) {
        if (Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        // It's better to have a const than two Object.entries()
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
            if ((memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||
                    ((flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {
                // proxyComponent - prop
                Object.defineProperty(prototype, memberName, {
                    get() {
                        // proxyComponent, get value
                        return getValue(this, memberName);
                    },
                    set(newValue) {
                        // proxyComponent, set value
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true,
                });
            }
            else if (flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&
                memberFlags & 64 /* MEMBER_FLAGS.Method */) {
                // proxyComponent - method
                Object.defineProperty(prototype, memberName, {
                    value(...args) {
                        const ref = getHostRef(this);
                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
                    },
                });
            }
        });
        if ((flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {
            const attrNameToPropName = new Map();
            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
                plt.jmp(() => {
                    const propName = attrNameToPropName.get(attrName);
                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
                    //  in the case where an attribute was set inline.
                    //  ```html
                    //    <my-component some-attribute="some-value"></my-component>
                    //  ```
                    //
                    //  There is an edge case where a developer sets the attribute inline on a custom element and then
                    //  programmatically changes it before it has been upgraded as shown below:
                    //
                    //  ```html
                    //    <!-- this component has _not_ been upgraded yet -->
                    //    <my-component id="test" some-attribute="some-value"></my-component>
                    //    <script>
                    //      // grab non-upgraded component
                    //      el = document.querySelector("#test");
                    //      el.someAttribute = "another-value";
                    //      // upgrade component
                    //      customElements.define('my-component', MyComponent);
                    //    </script>
                    //  ```
                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
                    //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
                    //  to the value that was set inline i.e. "some-value" from above example. When
                    //  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"
                    //
                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
                    //  by connectedCallback as this attributeChangedCallback will not fire.
                    //
                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
                    //
                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
                    //  properties here given that this goes against best practices outlined here
                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
                    if (this.hasOwnProperty(propName)) {
                        newValue = this[propName];
                        delete this[propName];
                    }
                    else if (prototype.hasOwnProperty(propName) &&
                        typeof this[propName] === 'number' &&
                        this[propName] == newValue) {
                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
                        return;
                    }
                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
                });
            };
            // create an array of attributes to observe
            // and also create a map of html attribute name to js property name
            Cstr.observedAttributes = members
                .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */) // filter to only keep props that should match attributes
                .map(([propName, m]) => {
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (m[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {
                    cmpMeta.$attrsToReflect$.push([propName, attrName]);
                }
                return attrName;
            });
        }
    }
    return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
    // initializeComponent
    if ((hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
        {
            // we haven't initialized this element yet
            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
            // lazy loaded components
            // request the component's implementation to be
            // wired up with the host element
            Cstr = loadModule(cmpMeta);
            if (Cstr.then) {
                // Await creates a micro-task avoid if possible
                const endLoad = uniqueTime();
                Cstr = await Cstr;
                endLoad();
            }
            if (!Cstr.isProxied) {
                // we've never proxied this Constructor before
                // let's add the getters/setters to its prototype before
                // the first time we create an instance of the implementation
                {
                    cmpMeta.$watchers$ = Cstr.watchers;
                }
                proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);
                Cstr.isProxied = true;
            }
            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
            // ok, time to construct the instance
            // but let's keep track of when we start and stop
            // so that the getters/setters don't incorrectly step on data
            {
                hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;
            }
            // construct the lazy-loaded component implementation
            // passing the hostRef is very important during
            // construction in order to directly wire together the
            // host element and the lazy-loaded instance
            try {
                new Cstr(hostRef);
            }
            catch (e) {
                consoleError(e);
            }
            {
                hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;
            }
            {
                hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;
            }
            endNewInstance();
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        if (Cstr.style) {
            // this component has styles but we haven't registered them yet
            let style = Cstr.style;
            const scopeId = getScopeId(cmpMeta);
            if (!styles.has(scopeId)) {
                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
                endRegisterStyles();
            }
        }
    }
    // we've successfully created a lazy instance
    const ancestorComponent = hostRef.$ancestorComponent$;
    const schedule = () => scheduleUpdate(hostRef, true);
    if (ancestorComponent && ancestorComponent['s-rc']) {
        // this is the initial load and this component it has an ancestor component
        // but the ancestor component has NOT fired its will update lifecycle yet
        // so let's just cool our jets and wait for the ancestor to continue first
        // this will get fired off when the ancestor component
        // finally gets around to rendering its lazy self
        // fire off the initial update
        ancestorComponent['s-rc'].push(schedule);
    }
    else {
        schedule();
    }
};
const fireConnectedCallback = (instance) => {
    {
        safeCall(instance, 'connectedCallback');
    }
};
const connectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
        if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {
            // first time this component has connected
            hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;
            {
                // find the first ancestor component (if there is one) and register
                // this component as one of the actively loading child components for its ancestor
                let ancestorComponent = elm;
                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
                    // climb up the ancestors looking for the first
                    // component that hasn't finished its lifecycle update yet
                    if (ancestorComponent['s-p']) {
                        // we found this components first ancestor component
                        // keep a reference to this component's ancestor component
                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
                        break;
                    }
                }
            }
            // Lazy properties
            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
            if (cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                    if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        }
        else {
            // not the first time this has connected
            // reattach any event listeners to the host
            // since they would have been removed when disconnected
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
            // fire off connectedCallback() on component instance
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        endConnected();
    }
};
const disconnectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const instance = hostRef.$lazyInstance$ ;
        {
            if (hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map((rmListener) => rmListener());
                hostRef.$rmListeners$ = undefined;
            }
        }
        {
            safeCall(instance, 'disconnectedCallback');
        }
    }
};
const proxyCustomElement = (Cstr, compactMeta) => {
    const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1],
    };
    {
        cmpMeta.$members$ = compactMeta[2];
    }
    {
        cmpMeta.$listeners$ = compactMeta[3];
    }
    {
        cmpMeta.$watchers$ = Cstr.$watchers$;
    }
    {
        cmpMeta.$attrsToReflect$ = [];
    }
    const originalConnectedCallback = Cstr.prototype.connectedCallback;
    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
    Object.assign(Cstr.prototype, {
        __registerHost() {
            registerHost(this, cmpMeta);
        },
        connectedCallback() {
            connectedCallback(this);
            if (originalConnectedCallback) {
                originalConnectedCallback.call(this);
            }
        },
        disconnectedCallback() {
            disconnectedCallback(this);
            if (originalDisconnectedCallback) {
                originalDisconnectedCallback.call(this);
            }
        },
        __attachShadow() {
            {
                {
                    this.attachShadow({
                        mode: 'open',
                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),
                    });
                }
            }
        },
    });
    Cstr.is = cmpMeta.$tagName$;
    return proxyComponent(Cstr, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */ | 2 /* PROXY_FLAGS.proxyState */);
};
const Fragment = (_, children) => children;
const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
    if (listeners) {
        listeners.map(([flags, name, method]) => {
            const target = getHostListenerTarget(elm, flags) ;
            const handler = hostListenerProxy(hostRef, method);
            const opts = hostListenerOpts(flags);
            plt.ael(target, name, handler, opts);
            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
        });
    }
};
const hostListenerProxy = (hostRef, methodName) => (ev) => {
    try {
        {
            if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {
                // instance is ready, let's call it's member method for this event
                hostRef.$lazyInstance$[methodName](ev);
            }
            else {
                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
            }
        }
    }
    catch (e) {
        consoleError(e);
    }
};
const getHostListenerTarget = (elm, flags) => {
    if (flags & 4 /* LISTENER_FLAGS.TargetDocument */)
        return doc;
    if (flags & 8 /* LISTENER_FLAGS.TargetWindow */)
        return win;
    if (flags & 16 /* LISTENER_FLAGS.TargetBody */)
        return doc.body;
    return elm;
};
// prettier-ignore
const hostListenerOpts = (flags) => (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;
const hostRefs = /*@__PURE__*/ new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerHost = (elm, cmpMeta) => {
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: new Map(),
    };
    {
        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));
    }
    {
        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
        elm['s-p'] = [];
        elm['s-rc'] = [];
    }
    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
    return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e, el) => (0, console.error)(e, el);
const cmpModules = /*@__PURE__*/ new Map();
const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
    // loadModuleImport
    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    const bundleId = cmpMeta.$lazyBundleId$;
    const module = cmpModules.get(bundleId) ;
    if (module) {
        return module[exportName];
    }
    /*!__STENCIL_STATIC_IMPORT_SWITCH__*/
    return __webpack_require__("./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm lazy recursive ^\\.\\/.*\\.entry\\.js$ include: \\.entry\\.js$ exclude: \\.system\\.entry\\.js$")(`./${bundleId}.entry.js`).then((importedModule) => {
        {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
const styles = /*@__PURE__*/ new Map();
const win = typeof window !== 'undefined' ? window : {};
const doc = win.document || { head: {} };
const H = (win.HTMLElement || class {
});
const plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (h) => h(),
    raf: (h) => requestAnimationFrame(h),
    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts) => new CustomEvent(eventName, opts),
};
const promiseResolve = (v) => Promise.resolve(v);
const supportsConstructableStylesheets = /*@__PURE__*/ (() => {
        try {
            new CSSStyleSheet();
            return typeof new CSSStyleSheet().replaceSync === 'function';
        }
        catch (e) { }
        return false;
    })()
    ;
const queueDomReads = [];
const queueDomWrites = [];
const queueTask = (queue, write) => (cb) => {
    queue.push(cb);
    if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {
            nextTick(flush);
        }
        else {
            plt.raf(flush);
        }
    }
};
const consume = (queue) => {
    for (let i = 0; i < queue.length; i++) {
        try {
            queue[i](performance.now());
        }
        catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
const flush = () => {
    // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!
    consume(queueDomReads);
    // DOM WRITES!!!
    {
        consume(queueDomWrites);
        if ((queuePending = queueDomReads.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
    }
};
const nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);
const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function gen(counts) {
  return counts
    .map((count) => {
    let out = "";
    for (let i = 0; i < count; i++) {
      out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    return out;
  })
    .join("-");
}
const guid = () => gen([2, 1, 1, 1, 3]);

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const autoMode = "calcite-mode-auto";
const darkMode = "calcite-mode-dark";
const lightMode = "calcite-mode-light";
const CSS_UTILITY = {
  autoMode,
  darkMode,
  lightMode,
  rtl: "calcite--rtl"
};
function nodeListToArray(nodeList) {
  return Array.isArray(nodeList) ? nodeList : Array.from(nodeList);
}
function getElementDir(el) {
  const prop = "dir";
  const selector = `[${prop}]`;
  const closest = closestElementCrossShadowBoundary(el, selector);
  return closest ? closest.getAttribute(prop) : "ltr";
}
function getElementProp(el, prop, fallbackValue) {
  const selector = `[${prop}]`;
  const closest = el.closest(selector);
  return closest ? closest.getAttribute(prop) : fallbackValue;
}
function getRootNode(el) {
  return el.getRootNode();
}
function getHost(root) {
  return root.host || null;
}
/**
 * This helper queries an element's rootNode and any ancestor rootNodes.
 *
 * If both an 'id' and 'selector' are supplied, 'id' will take precedence over 'selector'.
 *
 * @param element
 * @param root0
 * @param root0.selector
 * @param root0.id
 * @returns {Element} The element.
 */
function queryElementRoots(element, { selector, id }) {
  // Gets the rootNode and any ancestor rootNodes (shadowRoot or document) of an element and queries them for a selector.
  // Based on: https://stackoverflow.com/q/54520554/194216
  function queryFrom(el) {
    if (!el) {
      return null;
    }
    if (el.assignedSlot) {
      el = el.assignedSlot;
    }
    const rootNode = getRootNode(el);
    const found = id
      ? "getElementById" in rootNode
        ? /*
          Check to make sure 'getElementById' exists in cases where element is no longer connected to the DOM and getRootNode() returns the element.
          https://github.com/Esri/calcite-components/pull/4280
           */
          rootNode.getElementById(id)
        : null
      : selector
        ? rootNode.querySelector(selector)
        : null;
    const host = getHost(rootNode);
    return found ? found : host ? queryFrom(host) : null;
  }
  return queryFrom(element);
}
function closestElementCrossShadowBoundary(element, selector) {
  // based on https://stackoverflow.com/q/54520554/194216
  function closestFrom(el) {
    return el ? el.closest(selector) || closestFrom(getHost(getRootNode(el))) : null;
  }
  return closestFrom(element);
}
/**
 * This utility helps invoke a callback as it traverses a node and its ancestors until reaching the root document.
 *
 * Returning early or undefined in `onVisit` will continue traversing up the DOM tree. Otherwise, traversal will halt with the returned value as the result of the function
 *
 * @param element
 * @param onVisit
 */
function walkUpAncestry(element, onVisit) {
  return visit(element, onVisit);
}
function visit(node, onVisit) {
  if (!node) {
    return;
  }
  const result = onVisit(node);
  if (result !== undefined) {
    return result;
  }
  const { parentNode } = node;
  return visit(parentNode instanceof ShadowRoot ? parentNode.host : parentNode, onVisit);
}
function containsCrossShadowBoundary(element, maybeDescendant) {
  return !!walkUpAncestry(maybeDescendant, (node) => (node === element ? true : undefined));
}
function isCalciteFocusable(el) {
  return typeof el?.setFocus === "function";
}
async function focusElement(el) {
  if (!el) {
    return;
  }
  return isCalciteFocusable(el) ? el.setFocus() : el.focus();
}
const defaultSlotSelector = ":not([slot])";
function getSlotted(element, slotName, options) {
  if (slotName && !Array.isArray(slotName) && typeof slotName !== "string") {
    options = slotName;
    slotName = null;
  }
  const slotSelector = slotName
    ? Array.isArray(slotName)
      ? slotName.map((name) => `[slot="${name}"]`).join(",")
      : `[slot="${slotName}"]`
    : defaultSlotSelector;
  if (options?.all) {
    return queryMultiple(element, slotSelector, options);
  }
  return querySingle(element, slotSelector, options);
}
function getDirectChildren(el, selector) {
  return el ? Array.from(el.children || []).filter((child) => child?.matches(selector)) : [];
}
function queryMultiple(element, slotSelector, options) {
  let matches = slotSelector === defaultSlotSelector
    ? getDirectChildren(element, defaultSlotSelector)
    : Array.from(element.querySelectorAll(slotSelector));
  matches = options && options.direct === false ? matches : matches.filter((el) => el.parentElement === element);
  matches = options?.matches ? matches.filter((el) => el?.matches(options.matches)) : matches;
  const selector = options?.selector;
  return selector
    ? matches
      .map((item) => Array.from(item.querySelectorAll(selector)))
      .reduce((previousValue, currentValue) => [...previousValue, ...currentValue], [])
      .filter((match) => !!match)
    : matches;
}
function querySingle(element, slotSelector, options) {
  let match = slotSelector === defaultSlotSelector
    ? getDirectChildren(element, defaultSlotSelector)[0] || null
    : element.querySelector(slotSelector);
  match = options && options.direct === false ? match : match?.parentElement === element ? match : null;
  match = options?.matches ? (match?.matches(options.matches) ? match : null) : match;
  const selector = options?.selector;
  return selector ? match?.querySelector(selector) : match;
}
function filterDirectChildren(el, selector) {
  return Array.from(el.children).filter((child) => child.matches(selector));
}
// set a default icon from a defined set or allow an override with an icon name string
function setRequestedIcon(iconObject, iconValue, matchedValue) {
  if (typeof iconValue === "string" && iconValue !== "") {
    return iconValue;
  }
  else if (iconValue === "") {
    return iconObject[matchedValue];
  }
}
/**
 * This helper makes sure that boolean aria attributes are properly converted to a string.
 *
 * It should only be used for aria attributes that require a string value of "true" or "false".
 *
 * @param value
 * @returns {string} The string conversion of a boolean value ("true" | "false").
 */
function toAriaBoolean(value) {
  return Boolean(value).toString();
}
/**
 * This helper returns true if the pointer event fired from the primary button of the device.
 *
 * See https://www.w3.org/TR/pointerevents/#the-button-property.
 *
 * @param event
 * @returns {boolean}
 */
function isPrimaryPointerButton(event) {
  return !!(event.isPrimary && event.button === 0);
}
const focusElementInGroup = (elements, currentElement, destination) => {
  const currentIndex = elements.indexOf(currentElement);
  const isFirstItem = currentIndex === 0;
  const isLastItem = currentIndex === elements.length - 1;
  destination =
    destination === "previous" && isFirstItem ? "last" : destination === "next" && isLastItem ? "first" : destination;
  let focusTarget;
  switch (destination) {
    case "first":
      focusTarget = elements[0];
      break;
    case "last":
      focusTarget = elements[elements.length - 1];
      break;
    case "next":
      focusTarget = elements[currentIndex + 1] || elements[0];
      break;
    case "previous":
      focusTarget = elements[currentIndex - 1] || elements[elements.length - 1];
      break;
  }
  focusElement(focusTarget);
  return focusTarget;
};

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function noopClick() {
  /** noop */
}
/**
 * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.
 *
 * This should be used in the `componentDidRender` lifecycle hook.
 *
 * **Notes**
 *
 * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.
 * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error
 *
 * @param component
 * @param hostIsTabbable
 */
function updateHostInteraction(component, hostIsTabbable = false) {
  if (component.disabled) {
    component.el.setAttribute("tabindex", "-1");
    component.el.setAttribute("aria-disabled", "true");
    if (component.el.contains(document.activeElement)) {
      document.activeElement.blur();
    }
    component.el.click = noopClick;
    return;
  }
  component.el.click = HTMLElement.prototype.click;
  if (typeof hostIsTabbable === "function") {
    component.el.setAttribute("tabindex", hostIsTabbable.call(component) ? "0" : "-1");
  }
  else if (hostIsTabbable === true) {
    component.el.setAttribute("tabindex", "0");
  }
  else if (hostIsTabbable === false) {
    component.el.removeAttribute("tabindex");
  }
  else ;
  component.el.removeAttribute("aria-disabled");
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const resolveMap = new WeakMap();
const promiseMap = new WeakMap();
/**
 * This helper util sets up the component for the ability to know when the component has been loaded.
 *
 * This should be used in the `componentWillLoad` lifecycle hook.
 *
 * ```
 * componentWillLoad(): void {
 *   setUpLoadableComponent(this);
 * }
 * ```
 *
 * @param component
 */
function setUpLoadableComponent(component) {
  promiseMap.set(component, new Promise((resolve) => resolveMap.set(component, resolve)));
}
/**
 * This helper util lets the loadable component know that it is now loaded.
 *
 * This should be used in the `componentDidLoad` lifecycle hook.
 *
 * ```
 * componentDidLoad(): void {
 *   setComponentLoaded(this);
 * }
 * ```
 *
 * @param component
 */
function setComponentLoaded(component) {
  resolveMap.get(component)();
}
/**
 * This helper util can be used to ensure a component has been loaded (The "componentDidLoad" stencil lifecycle method has been called).
 *
 * Requires "setUpLoadableComponent" and "setComponentLoaded" to be called first.
 *
 * A component developer can await this method before proceeding with any logic that requires a component to be loaded first.
 *
 * ```
 * async setFocus(): Promise<void> {
 *   await componentLoaded(this);
 * }
 * ```
 *
 * @param component
 * @returns Promise<void>
 */
function componentLoaded(component) {
  return promiseMap.get(component);
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const numberKeys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

/**
 * This utility ensures observers are created only for browser contexts.
 *
 * @param type - the type of observer to create
 * @param callback - the observer callback
 * @param options - the observer options
 */
function createObserver(type, callback, options) {
  const Observer = getObserver(type);
  return new Observer(callback, options);
}
function getObserver(type) {
  // based on https://github.com/whatwg/dom/issues/126#issuecomment-1049814948
  class ExtendedMutationObserver extends window.MutationObserver {
    constructor(callback) {
      super(callback);
      this.observedEntry = [];
      this.callback = callback;
    }
    observe(target, options) {
      this.observedEntry.push({ target, options });
      return super.observe(target, options);
    }
    unobserve(target) {
      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);
      this.observedEntry = [];
      this.callback(super.takeRecords(), this);
      this.disconnect();
      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));
    }
  }
  return (function () {
    return (type === "intersection"
      ? window.IntersectionObserver
      : type === "mutation"
        ? ExtendedMutationObserver
        : window.ResizeObserver);
  })();
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const defaultMinusSignRegex = new RegExp("-", "g");
const unnecessaryDecimalRegex = new RegExp("\\.?0+$");
// adopted from https://stackoverflow.com/a/66939244
class BigDecimal {
  constructor(input) {
    this.add = (num) => BigDecimal.fromBigInt(this.value + new BigDecimal(num).value);
    this.subtract = (num) => BigDecimal.fromBigInt(this.value - new BigDecimal(num).value);
    this.multiply = (num) => BigDecimal._divRound(this.value * new BigDecimal(num).value, BigDecimal.SHIFT);
    this.divide = (num) => BigDecimal._divRound(this.value * BigDecimal.SHIFT, new BigDecimal(num).value);
    if (input instanceof BigDecimal) {
      return input;
    }
    const [integers, decimals] = String(input).split(".").concat("");
    this.value =
      BigInt(integers + decimals.padEnd(BigDecimal.DECIMALS, "0").slice(0, BigDecimal.DECIMALS)) +
        BigInt(BigDecimal.ROUNDED && decimals[BigDecimal.DECIMALS] >= "5");
    this.isNegative = input.charAt(0) === "-";
  }
  getIntegersAndDecimals() {
    const s = this.value
      .toString()
      .replace(defaultMinusSignRegex, "")
      .padStart(BigDecimal.DECIMALS + 1, "0");
    const integers = s.slice(0, -BigDecimal.DECIMALS);
    const decimals = s.slice(-BigDecimal.DECIMALS).replace(unnecessaryDecimalRegex, "");
    return { integers, decimals };
  }
  toString() {
    const { integers, decimals } = this.getIntegersAndDecimals();
    return `${this.isNegative ? "-" : ""}${integers}${decimals.length ? "." + decimals : ""}`;
  }
  formatToParts(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const parts = formatter.numberFormatter.formatToParts(BigInt(integers));
    this.isNegative && parts.unshift({ type: "minusSign", value: formatter.minusSign });
    if (decimals.length) {
      parts.push({ type: "decimal", value: formatter.decimal });
      decimals.split("").forEach((char) => parts.push({ type: "fraction", value: char }));
    }
    return parts;
  }
  format(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const integersFormatted = `${this.isNegative ? formatter.minusSign : ""}${formatter.numberFormatter.format(BigInt(integers))}`;
    const decimalsFormatted = decimals.length
      ? `${formatter.decimal}${decimals
        .split("")
        .map((char) => formatter.numberFormatter.format(Number(char)))
        .join("")}`
      : "";
    return `${integersFormatted}${decimalsFormatted}`;
  }
}
// Configuration: constants
BigDecimal.DECIMALS = 100; // number of decimals on all instances
BigDecimal.ROUNDED = true; // numbers are truncated (false) or rounded (true)
BigDecimal.SHIFT = BigInt("1" + "0".repeat(BigDecimal.DECIMALS)); // derived constant
BigDecimal._divRound = (dividend, divisor) => BigDecimal.fromBigInt(dividend / divisor + (BigDecimal.ROUNDED ? ((dividend * BigInt(2)) / divisor) % BigInt(2) : BigInt(0)));
BigDecimal.fromBigInt = (bigint) => Object.assign(Object.create(BigDecimal.prototype), { value: bigint });
function isValidNumber(numberString) {
  return !(!numberString || isNaN(Number(numberString)));
}
function parseNumberString(numberString) {
  if (!numberString || !stringContainsNumbers(numberString)) {
    return "";
  }
  return sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
    let containsDecimal = false;
    const result = nonExpoNumString
      .split("")
      .filter((value, i) => {
      if (value.match(/\./g) && !containsDecimal) {
        containsDecimal = true;
        return true;
      }
      if (value.match(/\-/g) && i === 0) {
        return true;
      }
      return numberKeys.includes(value);
    })
      .reduce((string, part) => string + part);
    return isValidNumber(result) ? new BigDecimal(result).toString() : "";
  });
}
// regex for number sanitization
const allLeadingZerosOptionallyNegative = /^([-0])0+(?=\d)/;
const decimalOnlyAtEndOfString = /(?!^\.)\.$/;
const allHyphensExceptTheStart = /(?!^-)-/g;
const isNegativeDecimalOnlyZeros = /^-\b0\b\.?0*$/;
const sanitizeNumberString = (numberString) => sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
  const sanitizedValue = nonExpoNumString
    .replace(allHyphensExceptTheStart, "")
    .replace(decimalOnlyAtEndOfString, "")
    .replace(allLeadingZerosOptionallyNegative, "$1");
  return isValidNumber(sanitizedValue)
    ? isNegativeDecimalOnlyZeros.test(sanitizedValue)
      ? sanitizedValue
      : new BigDecimal(sanitizedValue).toString()
    : nonExpoNumString;
});
function sanitizeExponentialNumberString(numberString, func) {
  if (!numberString) {
    return numberString;
  }
  const firstE = numberString.toLowerCase().indexOf("e") + 1;
  if (!firstE) {
    return func(numberString);
  }
  return numberString
    .replace(/[eE]*$/g, "")
    .substring(0, firstE)
    .concat(numberString.slice(firstE).replace(/[eE]/g, ""))
    .split(/[eE]/)
    .map((section, i) => (i === 1 ? func(section.replace(/\./g, "")) : func(section)))
    .join("e")
    .replace(/^e/, "1e");
}
function stringContainsNumbers(string) {
  return numberKeys.some((number) => string.includes(number));
}

const defaultLocale = "en";
const t9nLocales = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "el",
  defaultLocale,
  "es",
  "et",
  "fi",
  "fr",
  "he",
  "hr",
  "hu",
  "id",
  "it",
  "ja",
  "ko",
  "lt",
  "lv",
  "no",
  "nl",
  "pl",
  "pt-BR",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
];
const locales = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "de-CH",
  "el",
  defaultLocale,
  "en-AU",
  "en-CA",
  "en-GB",
  "es",
  "es-MX",
  "et",
  "fi",
  "fr",
  "fr-CH",
  "he",
  "hi",
  "hr",
  "hu",
  "id",
  "it",
  "it-CH",
  "ja",
  "ko",
  "lt",
  "lv",
  "mk",
  "no",
  "nl",
  "pl",
  "pt",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
];
const numberingSystems = [
  "arab",
  "arabext",
  "bali",
  "beng",
  "deva",
  "fullwide",
  "gujr",
  "guru",
  "hanidec",
  "khmr",
  "knda",
  "laoo",
  "latn",
  "limb",
  "mlym",
  "mong",
  "mymr",
  "orya",
  "tamldec",
  "telu",
  "thai",
  "tibt"
];
const isNumberingSystemSupported = (numberingSystem) => numberingSystems.includes(numberingSystem);
const browserNumberingSystem = new Intl.NumberFormat().resolvedOptions().numberingSystem;
const defaultNumberingSystem = browserNumberingSystem === "arab" || !isNumberingSystemSupported(browserNumberingSystem)
  ? "latn"
  : browserNumberingSystem;
const getSupportedNumberingSystem = (numberingSystem) => isNumberingSystemSupported(numberingSystem) ? numberingSystem : defaultNumberingSystem;
/**
 * Gets the locale that best matches the context.
 *
 * @param locale – the BCP 47 locale code
 * @param context - specifies whether the locale code should match in the context of CLDR or T9N (translation)
 */
function getSupportedLocale(locale, context = "cldr") {
  const contextualLocales = context === "cldr" ? locales : t9nLocales;
  if (!locale) {
    return defaultLocale;
  }
  if (contextualLocales.includes(locale)) {
    return locale;
  }
  locale = locale.toLowerCase();
  // we support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  if (locale === "nb") {
    return "no";
  }
  // we use `pt-BR` as it will have the same translations as `pt`, which has no corresponding bundle
  if (context === "t9n" && locale === "pt") {
    return "pt-BR";
  }
  if (locale.includes("-")) {
    locale = locale.replace(/(\w+)-(\w+)/, (_match, language, region) => `${language}-${region.toUpperCase()}`);
    if (!contextualLocales.includes(locale)) {
      locale = locale.split("-")[0];
    }
  }
  // we can `zh-CN` as base translation for chinese locales which has no corresponding bundle.
  if (locale === "zh") {
    return "zh-CN";
  }
  if (!contextualLocales.includes(locale)) {
    console.warn(`Translations for the "${locale}" locale are not available and will fall back to the default, English (en).`);
    return defaultLocale;
  }
  return locale;
}
const connectedComponents = new Set();
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback` before any logic that depends on locale
 *
 * @param component
 */
function connectLocalized(component) {
  updateEffectiveLocale(component);
  if (connectedComponents.size === 0) {
    mutationObserver?.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["lang"],
      subtree: true
    });
  }
  connectedComponents.add(component);
}
/**
 * This is only exported for components that implemented the now deprecated `locale` prop.
 *
 * Do not use this utils for new components.
 *
 * @param component
 */
function updateEffectiveLocale(component) {
  component.effectiveLocale = getLocale(component);
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectLocalized(component) {
  connectedComponents.delete(component);
  if (connectedComponents.size === 0) {
    mutationObserver.disconnect();
  }
}
const mutationObserver = createObserver("mutation", (records) => {
  records.forEach((record) => {
    const el = record.target;
    connectedComponents.forEach((component) => {
      const inUnrelatedSubtree = !containsCrossShadowBoundary(el, component.el);
      if (inUnrelatedSubtree) {
        return;
      }
      const closestLangEl = closestElementCrossShadowBoundary(component.el, "[lang]");
      if (!closestLangEl) {
        component.effectiveLocale = defaultLocale;
        return;
      }
      const closestLang = closestLangEl.lang;
      component.effectiveLocale =
        // user set lang="" means unknown language, so we use default
        closestLangEl.hasAttribute("lang") && closestLang === "" ? defaultLocale : closestLang;
    });
  });
});
/**
 * This util helps resolve a component's locale.
 * It will also fall back on the deprecated `locale` if a component implemented this previously.
 *
 * @param component
 */
function getLocale(component) {
  return (component.el.lang ||
    closestElementCrossShadowBoundary(component.el, "[lang]")?.lang ||
    document.documentElement.lang ||
    defaultLocale);
}
/**
 * This util formats and parses numbers for localization
 */
class NumberStringFormat {
  constructor() {
    this.delocalize = (numberString) => 
    // For performance, (de)localization is skipped if the formatter isn't initialized.
    // In order to localize/delocalize, e.g. when lang/numberingSystem props are not default values,
    // `numberFormatOptions` must be set in a component to create and cache the formatter.
    this._numberFormatOptions
      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => nonExpoNumString
        .trim()
        .replace(new RegExp(`[${this._minusSign}]`, "g"), "-")
        .replace(new RegExp(`[${this._group}]`, "g"), "")
        .replace(new RegExp(`[${this._decimal}]`, "g"), ".")
        .replace(new RegExp(`[${this._digits.join("")}]`, "g"), this._getDigitIndex))
      : numberString;
    this.localize = (numberString) => this._numberFormatOptions
      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => isValidNumber(nonExpoNumString.trim())
        ? new BigDecimal(nonExpoNumString.trim())
          .format(this)
          .replace(new RegExp(`[${this._actualGroup}]`, "g"), this._group)
        : nonExpoNumString)
      : numberString;
  }
  get group() {
    return this._group;
  }
  get decimal() {
    return this._decimal;
  }
  get minusSign() {
    return this._minusSign;
  }
  get digits() {
    return this._digits;
  }
  get numberFormatter() {
    return this._numberFormatter;
  }
  get numberFormatOptions() {
    return this._numberFormatOptions;
  }
  /**
   * numberFormatOptions needs to be set before localize/delocalize is called to ensure the options are up to date
   */
  set numberFormatOptions(options) {
    options.locale = getSupportedLocale(options?.locale);
    options.numberingSystem = getSupportedNumberingSystem(options?.numberingSystem);
    if (
    // No need to create the formatter if `locale` and `numberingSystem`
    // are the default values and `numberFormatOptions` has not been set
    (!this._numberFormatOptions &&
      options.locale === defaultLocale &&
      options.numberingSystem === defaultNumberingSystem &&
      // don't skip initialization if any options besides locale/numberingSystem are set
      Object.keys(options).length === 2) ||
      // cache formatter by only recreating when options change
      JSON.stringify(this._numberFormatOptions) === JSON.stringify(options)) {
      return;
    }
    this._numberFormatOptions = options;
    this._numberFormatter = new Intl.NumberFormat(this._numberFormatOptions.locale, this._numberFormatOptions);
    this._digits = [
      ...new Intl.NumberFormat(this._numberFormatOptions.locale, {
        useGrouping: false,
        numberingSystem: this._numberFormatOptions.numberingSystem
      }).format(9876543210)
    ].reverse();
    const index = new Map(this._digits.map((d, i) => [d, i]));
    const parts = new Intl.NumberFormat(this._numberFormatOptions.locale).formatToParts(-12345678.9);
    this._actualGroup = parts.find((d) => d.type === "group").value;
    // change whitespace group characters that don't render correctly
    this._group = this._actualGroup.trim().length === 0 ? " " : this._actualGroup;
    this._decimal = parts.find((d) => d.type === "decimal").value;
    this._minusSign = parts.find((d) => d.type === "minusSign").value;
    this._getDigitIndex = (d) => index.get(d);
  }
}
const numberStringFormatter = new NumberStringFormat();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const componentLangToMessageBundleCache = {};
async function getMessageBundle(lang, component) {
  const key = `${component}_${lang}`;
  if (componentLangToMessageBundleCache[key]) {
    return componentLangToMessageBundleCache[key];
  }
  componentLangToMessageBundleCache[key] = fetch(getAssetPath(`./assets/${component}/t9n/messages_${lang}.json`))
    .then((resp) => {
    if (!resp.ok) {
      throwMessageFetchError();
    }
    return resp.json();
  })
    .catch(() => throwMessageFetchError());
  return componentLangToMessageBundleCache[key];
}
function throwMessageFetchError() {
  throw new Error("could not fetch component message bundle");
}
function mergeMessages(component) {
  component.messages = {
    ...component.defaultMessages,
    ...component.messageOverrides
  };
}
/**
 * This utility sets up the messages used by the component. It should be awaited in the `componentWillLoad` lifecycle hook.
 *
 * @param component
 */
async function setUpMessages(component) {
  component.defaultMessages = await fetchMessages(component, component.effectiveLocale);
  mergeMessages(component);
}
async function fetchMessages(component, lang) {
  const { el } = component;
  const tag = el.tagName.toLowerCase();
  const componentName = tag.replace("calcite-", "");
  return getMessageBundle(getSupportedLocale(lang, "t9n"), componentName);
}
/**
 * This utility must be set up for the component to update its default message bundle if the locale changes.
 *
 * It can be set up in **either** of the following ways:
 *
 * 1. called from `LocalizedComponent`'s `onLocaleChange` method or
 * 2. called from a watcher configured to watch `LocalizedComponent`'s `effectiveLocale` prop
 *
 * @param component
 * @param lang
 */
async function updateMessages(component, lang) {
  component.defaultMessages = await fetchMessages(component, lang);
  mergeMessages(component);
}
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback`
 *
 * **Note**: this must be called after `LocalizedComponent`'s `connectLocalized` method.
 *
 * @param component
 */
function connectMessages(component) {
  component.onMessagesChange = defaultOnMessagesChange;
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectMessages(component) {
  component.onMessagesChange = undefined;
}
function defaultOnMessagesChange() {
  mergeMessages(this);
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const CSS$4 = {
  icon: "icon",
  flipRtl: "flip-rtl"
};

/**
 * Icon data cache.
 * Exported for testing purposes.
 *
 * @private
 */
const iconCache = {};
/**
 * Icon request cache.
 * Exported for testing purposes.
 *
 * @private
 */
const requestCache = {};
const scaleToPx = {
  s: 16,
  m: 24,
  l: 32
};
async function fetchIcon({ icon, scale }) {
  const size = scaleToPx[scale];
  const name = normalizeIconName(icon);
  const filled = name.charAt(name.length - 1) === "F";
  const iconName = filled ? name.substring(0, name.length - 1) : name;
  const id = `${iconName}${size}${filled ? "F" : ""}`;
  if (iconCache[id]) {
    return iconCache[id];
  }
  if (!requestCache[id]) {
    requestCache[id] = fetch(getAssetPath(`./assets/icon/${id}.json`))
      .then((resp) => resp.json())
      .catch(() => {
      console.error(`"${id}" is not a valid calcite-ui-icon name`);
      return "";
    });
  }
  const path = await requestCache[id];
  iconCache[id] = path;
  return path;
}
/**
 * Normalize the icon name to match the path data module exports.
 * Exported for testing purposes.
 *
 * @param name – an icon name that can be either kebab or camel-cased
 * @private
 */
function normalizeIconName(name) {
  const numberLeadingName = !isNaN(Number(name.charAt(0)));
  const parts = name.split("-");
  const kebabCased = parts.length > 0;
  if (kebabCased) {
    const firstNonDigitInPartPattern = /[a-z]/i;
    name = parts
      .map((part, partIndex) => {
      return part.replace(firstNonDigitInPartPattern, function replacer(match, offset) {
        const isFirstCharInName = partIndex === 0 && offset === 0;
        if (isFirstCharInName) {
          return match;
        }
        return match.toUpperCase();
      });
    })
      .join("");
  }
  return numberLeadingName ? `i${name}` : name;
}

const iconCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host{display:inline-flex;color:var(--calcite-ui-icon-color)}:host([scale=s]){block-size:1rem;inline-size:1rem;min-inline-size:1rem;min-block-size:1rem}:host([scale=m]){block-size:1.5rem;inline-size:1.5rem;min-inline-size:1.5rem;min-block-size:1.5rem}:host([scale=l]){block-size:2rem;inline-size:2rem;min-inline-size:2rem;min-block-size:2rem}.flip-rtl{transform:scaleX(-1)}.svg{display:block}";

const Icon = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.icon = null;
    this.flipRtl = false;
    this.scale = "m";
    this.textLabel = undefined;
    this.pathData = undefined;
    this.visible = false;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.waitUntilVisible(() => {
      this.visible = true;
      this.loadIconPathData();
    });
  }
  disconnectedCallback() {
    this.intersectionObserver?.disconnect();
    this.intersectionObserver = null;
  }
  async componentWillLoad() {
    this.loadIconPathData();
  }
  render() {
    const { el, flipRtl, pathData, scale, textLabel } = this;
    const dir = getElementDir(el);
    const size = scaleToPx[scale];
    const semantic = !!textLabel;
    const paths = [].concat(pathData || "");
    return (h(Host, { "aria-hidden": toAriaBoolean(!semantic), "aria-label": semantic ? textLabel : null, role: semantic ? "img" : null }, h("svg", { "aria-hidden": "true", class: {
        [CSS$4.flipRtl]: dir === "rtl" && flipRtl,
        svg: true
      }, fill: "currentColor", height: "100%", viewBox: `0 0 ${size} ${size}`, width: "100%", xmlns: "http://www.w3.org/2000/svg" }, paths.map((path) => typeof path === "string" ? (h("path", { d: path })) : (h("path", { d: path.d, opacity: "opacity" in path ? path.opacity : 1 }))))));
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  async loadIconPathData() {
    const { icon, scale, visible } = this;
    if (!icon || !visible) {
      return;
    }
    this.pathData = await fetchIcon({ icon, scale });
  }
  waitUntilVisible(callback) {
    this.intersectionObserver = createObserver("intersection", (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.intersectionObserver.disconnect();
          this.intersectionObserver = null;
          callback();
        }
      });
    }, { rootMargin: "50px" });
    if (!this.intersectionObserver) {
      callback();
      return;
    }
    this.intersectionObserver.observe(this.el);
  }
  static get assetsDirs() { return ["assets"]; }
  get el() { return this; }
  static get watchers() { return {
    "icon": ["loadIconPathData"],
    "scale": ["loadIconPathData"]
  }; }
  static get style() { return iconCss; }
}, [1, "calcite-icon", {
    "icon": [513],
    "flipRtl": [516, "flip-rtl"],
    "scale": [513],
    "textLabel": [1, "text-label"],
    "pathData": [32],
    "visible": [32]
  }]);
function defineCustomElement$8() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-icon"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Icon);
      }
      break;
  } });
}
defineCustomElement$8();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const loaderCss = "@charset \"UTF-8\";@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host{position:relative;margin-inline:auto;display:none;align-items:center;justify-content:center;opacity:1;min-block-size:var(--calcite-loader-size);font-size:var(--calcite-loader-font-size);stroke:var(--calcite-ui-brand);stroke-width:3;fill:none;transform:scale(1, 1);animation:loader-color-shift calc(var(--calcite-internal-animation-timing-slow) * 2) alternate-reverse infinite linear;padding-block:var(--calcite-loader-padding, 4rem)}:host([scale=s]){--calcite-loader-font-size:var(--calcite-font-size--2);--calcite-loader-size:2rem;--calcite-loader-size-inline:0.75rem}:host([scale=m]){--calcite-loader-font-size:var(--calcite-font-size-0);--calcite-loader-size:4rem;--calcite-loader-size-inline:1rem}:host([scale=l]){--calcite-loader-font-size:var(--calcite-font-size-2);--calcite-loader-size:6rem;--calcite-loader-size-inline:1.5rem}:host([no-padding]){padding-block:0px}:host{display:flex}.loader__text{display:block;text-align:center;font-size:var(--calcite-font-size--2);line-height:1rem;color:var(--calcite-ui-text-1);margin-block-start:calc(var(--calcite-loader-size) + 1.5rem)}.loader__percentage{position:absolute;display:block;text-align:center;color:var(--calcite-ui-text-1);font-size:var(--calcite-loader-font-size);inline-size:var(--calcite-loader-size);inset-inline-start:50%;margin-inline-start:calc(var(--calcite-loader-size) / 2 * -1);line-height:0.25;transform:scale(1, 1)}.loader__svgs{position:absolute;overflow:visible;opacity:1;inline-size:var(--calcite-loader-size);block-size:var(--calcite-loader-size);inset-inline-start:50%;margin-inline-start:calc(var(--calcite-loader-size) / 2 * -1);transform:scale(1, 1)}.loader__svg{position:absolute;inset-block-start:0px;transform-origin:center;overflow:visible;inset-inline-start:0;inline-size:var(--calcite-loader-size);block-size:var(--calcite-loader-size);animation-iteration-count:infinite;animation-timing-function:linear;animation-name:loader-clockwise}@supports (display: grid){.loader__svg--1{animation-name:loader-offset-1}.loader__svg--2{animation-name:loader-offset-2}.loader__svg--3{animation-name:loader-offset-3}}:host([type=determinate]){animation:none;stroke:var(--calcite-ui-border-3)}:host([type=determinate]) .loader__svg--3{animation:none;stroke:var(--calcite-ui-brand);stroke-dasharray:150.79632;transform:rotate(-90deg);transition:all var(--calcite-internal-animation-timing-fast) linear}:host([inline]){position:relative;margin:0px;animation:none;stroke:currentColor;stroke-width:2;padding-block:0px;block-size:var(--calcite-loader-size-inline);min-block-size:var(--calcite-loader-size-inline);inline-size:var(--calcite-loader-size-inline);margin-inline-end:calc(var(--calcite-loader-size-inline) * 0.5);vertical-align:calc(var(--calcite-loader-size-inline) * -1 * 0.2)}:host([inline]) .loader__svgs{inset-block-start:0px;margin:0px;inset-inline-start:0;inline-size:var(--calcite-loader-size-inline);block-size:var(--calcite-loader-size-inline)}:host([inline]) .loader__svg{inline-size:var(--calcite-loader-size-inline);block-size:var(--calcite-loader-size-inline)}:host([complete]){opacity:0;transform:scale(0.75, 0.75);transform-origin:center;transition:opacity var(--calcite-internal-animation-timing-medium) linear 1000ms, transform var(--calcite-internal-animation-timing-medium) linear 1000ms}:host([complete]) .loader__svgs{opacity:0;transform:scale(0.75, 0.75);transform-origin:center;transition:opacity calc(180ms * var(--calcite-internal-duration-factor)) linear 800ms, transform calc(180ms * var(--calcite-internal-duration-factor)) linear 800ms}:host([complete]) .loader__percentage{color:var(--calcite-ui-brand);transform:scale(1.05, 1.05);transform-origin:center;transition:color var(--calcite-internal-animation-timing-medium) linear, transform var(--calcite-internal-animation-timing-medium) linear}.loader__svg--1{stroke-dasharray:27.9252444444% 139.6262222222%;animation-duration:calc(var(--calcite-internal-animation-timing-slow) * 2.4)}@keyframes loader-offset-1{0%{stroke-dasharray:27.9252444444% 251.3272%;stroke-dashoffset:0}50%{stroke-dasharray:139.6262222222% 139.6262222222%;stroke-dashoffset:-83.7757333333%}100%{stroke-dasharray:27.9252444444% 251.3272%;stroke-dashoffset:-279.2524444444%}}.loader__svg--2{stroke-dasharray:55.8504888889% 139.6262222222%;animation-duration:calc(var(--calcite-internal-animation-timing-slow) * 3.2)}@keyframes loader-offset-2{0%{stroke-dasharray:55.8504888889% 223.4019555556%;stroke-dashoffset:0}50%{stroke-dasharray:139.6262222222% 139.6262222222%;stroke-dashoffset:-97.7383555556%}100%{stroke-dasharray:55.8504888889% 223.4019555556%;stroke-dashoffset:-279.2524444444%}}.loader__svg--3{stroke-dasharray:13.9626222222% 139.6262222222%;animation-duration:calc(var(--calcite-internal-animation-timing-slow) * 3.867)}@keyframes loader-offset-3{0%{stroke-dasharray:13.9626222222% 265.2898222222%;stroke-dashoffset:0}50%{stroke-dasharray:139.6262222222% 139.6262222222%;stroke-dashoffset:-76.7944222222%}100%{stroke-dasharray:13.9626222222% 265.2898222222%;stroke-dashoffset:-279.2524444444%}}@keyframes loader-color-shift{0%{stroke:var(--calcite-ui-brand)}33%{stroke:var(--calcite-ui-brand-press)}66%{stroke:var(--calcite-ui-brand-hover)}100%{stroke:var(--calcite-ui-brand)}}@keyframes loader-clockwise{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}";

const Loader = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.inline = false;
    this.label = undefined;
    this.scale = "m";
    this.type = undefined;
    this.value = 0;
    this.text = "";
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    const { el, inline, label, scale, text, type, value } = this;
    const id = el.id || guid();
    const radiusRatio = 0.45;
    const size = inline ? this.getInlineSize(scale) : this.getSize(scale);
    const radius = size * radiusRatio;
    const viewbox = `0 0 ${size} ${size}`;
    const isDeterminate = type === "determinate";
    const circumference = 2 * radius * Math.PI;
    const progress = (value / 100) * circumference;
    const remaining = circumference - progress;
    const valueNow = Math.floor(value);
    const hostAttributes = {
      "aria-valuenow": valueNow,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      complete: valueNow === 100
    };
    const svgAttributes = { r: radius, cx: size / 2, cy: size / 2 };
    const determinateStyle = { "stroke-dasharray": `${progress} ${remaining}` };
    return (h(Host, { "aria-label": label, id: id, role: "progressbar", ...(isDeterminate ? hostAttributes : {}) }, h("div", { class: "loader__svgs" }, h("svg", { "aria-hidden": "true", class: "loader__svg loader__svg--1", viewBox: viewbox }, h("circle", { ...svgAttributes })), h("svg", { "aria-hidden": "true", class: "loader__svg loader__svg--2", viewBox: viewbox }, h("circle", { ...svgAttributes })), h("svg", { "aria-hidden": "true", class: "loader__svg loader__svg--3", viewBox: viewbox, ...(isDeterminate ? { style: determinateStyle } : {}) }, h("circle", { ...svgAttributes }))), text && h("div", { class: "loader__text" }, text), isDeterminate && h("div", { class: "loader__percentage" }, value)));
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Return the proper sizes based on the scale property
   *
   * @param scale
   */
  getSize(scale) {
    return {
      s: 32,
      m: 56,
      l: 80
    }[scale];
  }
  getInlineSize(scale) {
    return {
      s: 12,
      m: 16,
      l: 20
    }[scale];
  }
  get el() { return this; }
  static get style() { return loaderCss; }
}, [1, "calcite-loader", {
    "inline": [516],
    "label": [1],
    "scale": [513],
    "type": [513],
    "value": [2],
    "text": [1]
  }]);
function defineCustomElement$7() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-loader"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-loader":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Loader);
      }
      break;
  } });
}
defineCustomElement$7();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const CSS$3 = {
  button: "button",
  buttonTextVisible: "button--text-visible",
  buttonCompact: "button--compact",
  indicatorText: "indicator-text",
  iconContainer: "icon-container",
  slotContainer: "slot-container",
  slotContainerHidden: "slot-container--hidden",
  textContainer: "text-container",
  textContainerVisible: "text-container--visible"
};
const SLOTS$2 = {
  tooltip: "tooltip"
};

const actionCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:host{box-sizing:border-box;background-color:var(--calcite-ui-foreground-1);color:var(--calcite-ui-text-2);font-size:var(--calcite-font-size--1)}:host *{box-sizing:border-box}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host([disabled]){pointer-events:none;cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-ui-opacity-disabled)}:host{display:flex;background-color:transparent;--calcite-action-indicator-color:var(--calcite-ui-brand)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.button{position:relative;margin:0px;display:flex;inline-size:auto;cursor:pointer;align-items:center;justify-content:flex-start;border-style:none;background-color:var(--calcite-ui-foreground-1);fill:var(--calcite-ui-text-3);font-family:var(--calcite-sans-family);font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-ui-text-3);outline-color:transparent;text-align:unset;flex:1 0 auto}.button:hover{background-color:var(--calcite-ui-foreground-2);fill:var(--calcite-ui-text-1);color:var(--calcite-ui-text-1)}.button:focus{background-color:var(--calcite-ui-foreground-2);fill:var(--calcite-ui-text-1);color:var(--calcite-ui-text-1);outline:2px solid var(--calcite-ui-brand);outline-offset:-2px}.button:active{background-color:var(--calcite-ui-foreground-3)}.button .icon-container{pointer-events:none;margin:0px;display:flex;align-items:center;justify-content:center;min-inline-size:1rem;min-block-size:1rem}.button .text-container{margin:0px;inline-size:0px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.5rem;opacity:0;transition-property:opacity;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-property:margin;transition-property:inline-size}.button .text-container--visible{inline-size:auto;flex:1 1 auto;opacity:1}:host([scale=s]) .button{padding-inline:0.5rem;padding-block:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}:host([scale=s]) .button--text-visible .icon-container{margin-inline-end:0.5rem}:host([scale=m]) .button{padding-inline:1rem;padding-block:0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}:host([scale=m]) .button--text-visible .icon-container{margin-inline-end:0.75rem}:host([scale=l]) .button{padding:1.25rem;font-size:var(--calcite-font-size-0);line-height:1.25rem;font-weight:var(--calcite-font-weight-normal)}:host([scale=l]) .button--text-visible .icon-container{margin-inline-end:1rem}:host([alignment=center]) .button{justify-content:center}:host([alignment=end]) .button{justify-content:flex-end}:host([alignment=center]) .button .text-container--visible,:host([alignment=end]) .button .text-container--visible{flex:0 1 auto}:host([scale=s][compact]) .button,:host([scale=m][compact]) .button,:host([scale=l][compact]) .button{padding-inline:0px}.slot-container{display:flex}.slot-container--hidden{display:none}.button--text-visible{inline-size:100%}:host([active]) .button,:host([active]) .button:hover,:host([active]) .button:focus,:host([active][loading]) .button{background-color:var(--calcite-ui-foreground-3);fill:var(--calcite-ui-text-1);color:var(--calcite-ui-text-1)}:host([active]) .button:active{background-color:var(--calcite-ui-foreground-1)}:host([appearance=transparent]) .button{background-color:transparent;transition-property:box-shadow;transition-duration:150ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}:host([appearance=transparent]) .button:hover,:host([appearance=transparent]) .button:focus{background-color:transparent;box-shadow:0 0 0 2px var(--calcite-ui-border-1) inset}:host([active][appearance=transparent]) .button,:host([active][appearance=transparent]) .button:hover,:host([active][appearance=transparent]) .button:focus{background-color:var(--calcite-ui-foreground-3);fill:var(--calcite-ui-text-1);color:var(--calcite-ui-text-1)}:host([appearance=transparent][loading]) .button,:host([appearance=transparent][disabled]) .button{background-color:transparent}:host([loading]) .button,:host([loading]) .button:hover,:host([loading]) .button:focus{background-color:var(--calcite-ui-foreground-1)}:host([loading]) .button .text-container,:host([loading]) .button:hover .text-container,:host([loading]) .button:focus .text-container{opacity:var(--calcite-ui-opacity-disabled)}:host([loading]) calcite-loader[inline]{color:var(--calcite-ui-text-3);margin-inline-end:0px}:host([disabled]) .button,:host([disabled]) .button:hover,:host([disabled]) .button:focus{cursor:default;background-color:var(--calcite-ui-foreground-1);opacity:var(--calcite-ui-opacity-disabled)}:host([disabled][active]) .button,:host([disabled][active]) .button:hover,:host([disabled][active]) .button:focus{background-color:var(--calcite-ui-foreground-3);opacity:var(--calcite-ui-opacity-disabled)}:host([indicator]) .button::after{content:\"\";position:absolute;block-size:0.5rem;inline-size:0.5rem;border-radius:9999px;border-width:2px;background-color:var(--calcite-action-indicator-color);border-color:var(--calcite-ui-foreground-1);inset-block-end:0.75rem;inset-inline-end:0.75rem}:host([indicator]) .button--text-visible::after{inset-block-end:auto}:host([indicator]) .button--text-visible .text-container--visible{margin-inline-end:1rem}:host([indicator]) .button:hover::after,:host([indicator]) .button:focus::after{border-color:var(--calcite-ui-foreground-1)}:host([indicator][scale=s]) .button::after{inset-block-end:0.25rem;inset-inline-end:0.25rem}:host([indicator][scale=s]) .button--text-visible::after{inset-block-end:auto;inset-inline-end:0.5rem}:host([indicator][active]) .button::after{border-color:var(--calcite-ui-foreground-3)}.indicator-text{position:absolute;inline-size:1px;block-size:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}";

const Action = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.mutationObserver = createObserver("mutation", () => forceUpdate(this));
    this.guid = `calcite-action-${guid()}`;
    this.indicatorId = `${this.guid}-indicator`;
    this.buttonId = `${this.guid}-button`;
    // --------------------------------------------------------------------------
    //
    //  Private Methods
    //
    // --------------------------------------------------------------------------
    this.handleTooltipSlotChange = (event) => {
      const tooltips = event.target
        .assignedElements({
        flatten: true
      })
        .filter((el) => el?.matches("calcite-tooltip"));
      const tooltip = tooltips[0];
      if (tooltip) {
        tooltip.referenceElement = this.buttonEl;
      }
    };
    this.active = false;
    this.alignment = undefined;
    this.appearance = "solid";
    this.compact = false;
    this.disabled = false;
    this.icon = undefined;
    this.iconFlipRtl = false;
    this.indicator = false;
    this.label = undefined;
    this.loading = false;
    this.scale = "m";
    this.text = undefined;
    this.textEnabled = false;
    this.messages = undefined;
    this.messageOverrides = undefined;
    this.effectiveLocale = "";
    this.defaultMessages = undefined;
  }
  onMessagesChange() {
    /* wired up by t9n util */
  }
  effectiveLocaleChange() {
    updateMessages(this, this.effectiveLocale);
  }
  // --------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  // --------------------------------------------------------------------------
  connectedCallback() {
    connectLocalized(this);
    connectMessages(this);
    this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
  }
  async componentWillLoad() {
    setUpLoadableComponent(this);
    {
      await setUpMessages(this);
    }
  }
  componentDidLoad() {
    setComponentLoaded(this);
  }
  disconnectedCallback() {
    disconnectLocalized(this);
    disconnectMessages(this);
    this.mutationObserver?.disconnect();
  }
  componentDidRender() {
    updateHostInteraction(this);
  }
  // --------------------------------------------------------------------------
  //
  //  Methods
  //
  // --------------------------------------------------------------------------
  /** Sets focus on the component. */
  async setFocus() {
    await componentLoaded(this);
    this.buttonEl?.focus();
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  // --------------------------------------------------------------------------
  renderTextContainer() {
    const { text, textEnabled } = this;
    const textContainerClasses = {
      [CSS$3.textContainer]: true,
      [CSS$3.textContainerVisible]: textEnabled
    };
    return text ? (h("div", { class: textContainerClasses, key: "text-container" }, text)) : null;
  }
  renderIndicatorText() {
    const { indicator, messages, indicatorId, buttonId } = this;
    return (h("div", { "aria-labelledby": buttonId, "aria-live": "polite", class: CSS$3.indicatorText, id: indicatorId, role: "region" }, indicator ? messages.indicator : null));
  }
  renderIconContainer() {
    const { loading, icon, scale, el, iconFlipRtl } = this;
    const iconScale = scale === "l" ? "m" : "s";
    const loaderScale = scale === "l" ? "l" : "m";
    const calciteLoaderNode = loading ? (h("calcite-loader", { inline: true, label: this.messages.loading, scale: loaderScale })) : null;
    const calciteIconNode = icon ? (h("calcite-icon", { flipRtl: iconFlipRtl, icon: icon, scale: iconScale })) : null;
    const iconNode = calciteLoaderNode || calciteIconNode;
    const hasIconToDisplay = iconNode || el.children?.length;
    const slotContainerNode = (h("div", { class: {
        [CSS$3.slotContainer]: true,
        [CSS$3.slotContainerHidden]: loading
      } }, h("slot", null)));
    return hasIconToDisplay ? (h("div", { "aria-hidden": "true", class: CSS$3.iconContainer, key: "icon-container" }, iconNode, slotContainerNode)) : null;
  }
  render() {
    const { active, compact, disabled, loading, textEnabled, label, text, indicator, indicatorId, buttonId, messages } = this;
    const ariaLabel = `${label || text}${indicator ? ` (${messages.indicator})` : ""}`;
    const buttonClasses = {
      [CSS$3.button]: true,
      [CSS$3.buttonTextVisible]: textEnabled,
      [CSS$3.buttonCompact]: compact
    };
    return (h(Host, null, h("button", { "aria-busy": toAriaBoolean(loading), "aria-controls": indicator ? indicatorId : null, "aria-disabled": toAriaBoolean(disabled), "aria-label": ariaLabel, "aria-pressed": toAriaBoolean(active), class: buttonClasses, disabled: disabled, id: buttonId, ref: (buttonEl) => (this.buttonEl = buttonEl) }, this.renderIconContainer(), this.renderTextContainer()), h("slot", { name: SLOTS$2.tooltip, onSlotchange: this.handleTooltipSlotChange }), this.renderIndicatorText()));
  }
  static get assetsDirs() { return ["assets"]; }
  get el() { return this; }
  static get watchers() { return {
    "messageOverrides": ["onMessagesChange"],
    "effectiveLocale": ["effectiveLocaleChange"]
  }; }
  static get style() { return actionCss; }
}, [1, "calcite-action", {
    "active": [516],
    "alignment": [513],
    "appearance": [513],
    "compact": [516],
    "disabled": [516],
    "icon": [1],
    "iconFlipRtl": [516, "icon-flip-rtl"],
    "indicator": [516],
    "label": [1],
    "loading": [516],
    "scale": [513],
    "text": [1],
    "textEnabled": [516, "text-enabled"],
    "messages": [1040],
    "messageOverrides": [1040],
    "effectiveLocale": [32],
    "defaultMessages": [32],
    "setFocus": [64]
  }]);
function defineCustomElement$6() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-action", "calcite-icon", "calcite-loader"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-action":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Action);
      }
      break;
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
    case "calcite-loader":
      if (!customElements.get(tagName)) {
        defineCustomElement$7();
      }
      break;
  } });
}
defineCustomElement$6();

const searchStepCss = ":host{display:block}.arcgisSearchStepDescription{margin-bottom:8px}.selectedSearchResultRowWF{position:absolute;width:100%;overflow:visible;flex:1 1 auto;align-items:stretch;max-width:100%;background-color:var(--calcite-ui-foreground-2);color:var(--calcite-ui-text-1);z-index:9}.selectedSearchResultWF{width:100%;padding:7px 10px;display:flex;align-items:center;}.close-icon{margin-left:auto;cursor:pointer}.d-flex{display:flex;align-items:center}.search-result-string{padding-left:5px}";

const SearchStep = class {
  constructor(hostRef) {
    (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.searchResultObjChanged = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "searchResultObjChanged", 6);
    this.drawPointClickSearchStep = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "drawPointClickSearchStep", 6);
    this.drawPolygonClickSearchStep = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "drawPolygonClickSearchStep", 6);
    this._idPrefix = 'search-step-';
    this._idPrefixSearch = 'search-step-comp-';
    this._dbg = false;
    this.baseConfig = new _base_util_b7db69f0_js__WEBPACK_IMPORTED_MODULE_1__.B('search-step', this, this.onUpdateUI);
  }
  //
  // Update Props/States when the main config changes
  onConfigChange(newConfig, oldConfig) {
    if (this._dbg) {
      console.log('%c SEARCH-STEP config update', 'color:orange;font-size:11pt');
    }
    if (!newConfig || typeof newConfig != 'string') {
      return;
    }
    if (_ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(newConfig)) {
      const newCfg = JSON.parse(newConfig);
      const oldCfg = (oldConfig && _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(oldConfig)) ? JSON.parse(oldConfig) : null;
      if (this._dbg) {
        console.log('%c ....SEARCH-STEP searchType', 'color:orange;font-size:11pt', newCfg.baSearchType);
      }
      //
      // COLORS:
      // define a temp color object so that we update the 'colors' Prop one time
      this.baseConfig.updateConfig(newCfg, oldCfg);
    }
  }
  onThemeChanged() {
    this.stTheme = this.theme;
    this.baseConfig.setTheme(this.theme);
  }
  searchResultsEventHandler(e) {
    this.onSiteObjectChanged({ origin: 'basearch', data: e });
  }
  /**
   * setActiveLevels
   *    Passes the geography levels that will be requested/displayed
   *    in the arcgis-ba-search component.
   */
  async setActiveLevels(names) {
    const searchElem = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.queryElementById.call(this, this._searchId);
    if (searchElem) {
      searchElem.setActiveLevels(names);
    }
  }
  setLocaleStrings() {
    // console.log("setLocaleStrings() for search-step")
    // TODO: initialize locale strings for this component
  }
  _loadInstances() {
    if (!this._instanceId)
      this._instanceId = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.E.generateId(this._idPrefix).id;
    if (!this._searchId)
      this._searchId = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.E.generateId(this._idPrefixSearch).id;
  }
  onsearchResultChange(newSelectedFeatureResult) {
    // console.log('search-step Selected Feature Result changed:', newSelectedFeatureResult);
    this.onSiteObjectChanged({ origin: 'selectedFeatureResult', data: JSON.parse(newSelectedFeatureResult) });
  }
  // BaseUtil config-changed render callback
  onUpdateUI() {
  }
  async componentWillLoad() {
    // console.log('%c search-step willLoad', 'font-size:8pt;color:orange;')
    if (this.config) {
      this.onConfigChange(this.config, '');
    }
    if (this.theme) {
      this.baseConfig.setTheme(this.theme);
    }
    else {
      this.baseConfig.setTheme('light');
    }
    this._loadInstances();
  }
  // Stencil lifecycle - called just after component updates, but not called during first render()
  componentDidUpdate() {
    if (this._dbg) {
      console.log('%c SEARCH-STEP didUpdate', 'color:yellow;font-size:11pt', this.baseConfig.config);
    }
    if (this.baseConfig) {
      this.baseConfig.onComponentHasRendered();
    }
  }
  // Stencil lifecycle - called once after component is fully loaded and 1st render occurred
  componentDidLoad() {
    this._loadInstances();
    if (this._dbg) {
      console.log('%c SEARCH-STEP did load', 'color:orange;font-size:11pt', this.baseConfig.hasSubComponents(), this._searchId);
    }
    if (this.baseConfig) {
      this.baseConfig.onComponentHasRendered();
    }
  }
  isLocationType(v) {
    if (typeof v !== 'string') {
      return false;
    }
    return (v && (v?.toLowerCase() === 'location' || v?.toLowerCase() === 'point'));
  }
  clearSearchResult() {
    if (this.baseConfig) {
      // updates config and sub-component configs
      this.baseConfig.updateConfig({ searchResultObj: {} }, null);
    }
    this.searchResultObj = {};
    this.searchResultString = '';
    this.searchResultObjChanged.emit({});
  }
  onSiteObjectChanged(searchResult) {
    if (!searchResult)
      return;
    if (searchResult.origin === 'basearch' || searchResult.origin === 'selectedFeatureResult') {
      // data is coming from arcgis-ba-search result
      const e = searchResult.data;
      let result = {};
      // If coming from externally, allow it to flow through
      if (searchResult.origin === 'selectedFeatureResult') {
        result = searchResult.data.detail;
      }
      else if (e.detail.type === 'location') {
        result = {
          type: 'location',
          name: e.detail.name,
          address: e.detail.address,
          lat: e.detail.location?.lat || e.detail.lat,
          lon: e.detail.location?.lon || e.detail.lon
        };
      }
      else if (e.detail.type === 'geography') {
        //setup geometry compatible with infographic component
        const geom = {
          type: 'polygon',
          rings: e.detail.geometry,
          spatial: { wkid: 102100 },
          latitude: 34.055561,
          longitude: -117.182602
        };
        result = {
          type: 'geography',
          name: e.detail.title,
          areaId: e.detail.areaId,
          geography: {
            sourceCountry: e.detail.attributes.CountryAbbr,
            levelId: e.detail.attributes.DataLayerID,
            hierarchy: e.detail.attributes.Hierarchy,
            id: e.detail.areaId,
            attributes: e.detail.attributes
          },
          geometry: geom
        };
      }
      this.searchResultString = '';
      const strName = (result.name && _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(result.name)) ? result.name : result.displayName || null;
      const strAddress = (result.address && _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(result.address)) ? result.address : null;
      if (this.isLocationType(result.type)) {
        if (strAddress) {
          this.searchResultString = strAddress;
        }
        else if (strName) {
          this.searchResultString = strName;
        }
      }
      else {
        this.searchResultString = strName || '';
      }
      this.searchResultObj = result;
      // Only emit if coming from search results (if coming from top (infographic-workflow selection) down, we don't want to emit)
      if (searchResult.origin !== 'selectedFeatureResult') {
        this.searchResultObjChanged.emit(result);
      }
    }
  }
  render() {
    const username = this.username;
    const env = this.env;
    const token = this.token;
    const geoenrichmentUrl = this.geoenrichmentUrl;
    const selectedCountry = this.baseConfig.config.sourceCountry || this.baseConfig._localeSettings.country;
    const language = this.langCode;
    const searchStyle = { 'width': 'calc(100% - 3px)' };
    return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.isEmptyObject(this.searchResultObj) ? ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'flex-grid' }, this.baseConfig.config.workflowDisplayIntroText &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'col arcgisSearchStepDescription' }, this.baseConfig.config.workflowIntroText)), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-ba-search", { id: this._searchId, config: this.baseConfig.getConfigString(),
      //style={stepBaSearchComponent}
      style: searchStyle, username: username,
      //nogeography={noWorkflowGeographySearch}
      env: env, token: token, geoenrichmentUrl: geoenrichmentUrl, geocodeUrl: this.geocodeUrl,
      //colors={this.stringifyTheme()}
      sourceCountry: selectedCountry, langCode: language, suglite: 'true' }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", { name: "draw-components" })))) : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'd-flex selectedSearchResultRowWF' }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'd-flex selectedSearchResultWF' }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'd-flex search-result-icon' }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: 'm', icon: this.isLocationType(this.searchResultObj.type) ? 'pin' : 'polygon' })), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'd-flex search-result-string' }, this.searchResultString), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'd-flex close-icon', onClick: () => { this.clearSearchResult(); } }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { size: 'm', icon: 'x', id: "clearSearch-button" })), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { label: _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('clear-search'), "reference-element": "clearSearch-button" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", null, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('clear-search'))))))));
  }
  get el() { return (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
  static get watchers() { return {
    "config": ["onConfigChange"],
    "theme": ["onThemeChanged"],
    "selectedFeatureResult": ["onsearchResultChange"]
  }; }
};
SearchStep.style = searchStepCss;

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const SLOTS$1 = {
  titleGroup: "title-group"
};

const tabsCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host{display:flex;flex-direction:column}:host([bordered]){box-shadow:inset 0 1px 0 var(--calcite-ui-border-1);background-color:var(--calcite-ui-foreground-1)}:host([bordered]:not([position=bottom])) ::slotted(calcite-tab-nav){margin-block-end:-1px}:host([bordered][position=bottom]){box-shadow:inset 0 1px 0 var(--calcite-ui-border-1), inset 0 -1px 0 var(--calcite-ui-border-1)}:host([bordered]) section{border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-1)}:host([bordered][scale=s]) section{padding:0.75rem}:host([bordered][scale=m]) section{padding:0.5rem}:host([bordered][scale=l]) section{padding:1rem}:host([position=bottom]){flex-direction:column-reverse}section{display:flex;flex-grow:1;overflow:hidden;border-block-start-width:1px;border-block-start-color:var(--calcite-ui-border-1);border-block-start-style:solid}:host([position=bottom]) section{flex-direction:column-reverse;border-block-start-width:0px;border-block-end-width:1px;border-block-end-color:var(--calcite-ui-border-1)}:host([position=bottom]:not([bordered])) section{border-block-end-style:solid}@media (forced-colors: active){:host([bordered]) section{border-block-start-width:0px;border-block-end-width:1px}:host([position=bottom][bordered]) section{border-block-start-width:1px;border-block-end-width:0px}}";

const Tabs = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.layout = "inline";
    this.position = "top";
    this.scale = "m";
    this.bordered = false;
    this.titles = [];
    this.tabs = [];
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    return (h(Fragment, null, h("slot", { name: SLOTS$1.titleGroup }), h("section", null, h("slot", null))));
  }
  //--------------------------------------------------------------------------
  //
  //  Event Listeners
  //
  //--------------------------------------------------------------------------
  /**
   * @param event
   * @internal
   */
  calciteInternalTabTitleRegister(event) {
    this.titles = [...this.titles, event.target];
    this.registryHandler();
    event.stopPropagation();
  }
  /**
   * @param event
   * @internal
   */
  calciteTabTitleUnregister(event) {
    this.titles = this.titles.filter((el) => el !== event.detail);
    this.registryHandler();
    event.stopPropagation();
  }
  /**
   * @param event
   * @internal
   */
  calciteInternalTabRegister(event) {
    this.tabs = [...this.tabs, event.target];
    this.registryHandler();
    event.stopPropagation();
  }
  /**
   * @param event
   * @internal
   */
  calciteTabUnregister(event) {
    this.tabs = this.tabs.filter((el) => el !== event.detail);
    this.registryHandler();
    event.stopPropagation();
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  /**
   *
   * Matches up elements from the internal `tabs` and `titles` to automatically
   * update the ARIA attributes and link `<calcite-tab>` and
   * `<calcite-tab-title>` components.
   */
  async registryHandler() {
    let tabIds;
    let titleIds;
    // determine if we are using `tab` based or `index` based tab identifiers.
    if (this.tabs.some((el) => el.tab) || this.titles.some((el) => el.tab)) {
      // if we are using `tab` based identifiers sort by `tab` to account for
      // possible out of order tabs and get the id of each tab
      tabIds = this.tabs.sort((a, b) => a.tab.localeCompare(b.tab)).map((el) => el.id);
      titleIds = this.titles.sort((a, b) => a.tab.localeCompare(b.tab)).map((el) => el.id);
    }
    else {
      // if we are using index based tabs then the `<calcite-tab>` and
      // `<calcite-tab-title>` might have been rendered out of order so the
      // order of `this.tabs` and `this.titles` might not reflect the DOM state,
      // and might not match each other so we need to get the index of all the
      // tabs and titles in the DOM order to match them up as a source of truth
      const tabDomIndexes = await Promise.all(this.tabs.map((el) => el.getTabIndex()));
      const titleDomIndexes = await Promise.all(this.titles.map((el) => el.getTabIndex()));
      // once we have the DOM order as a source of truth we can build the
      // matching tabIds and titleIds arrays
      tabIds = tabDomIndexes.reduce((ids, indexInDOM, registryIndex) => {
        ids[indexInDOM] = this.tabs[registryIndex].id;
        return ids;
      }, []);
      titleIds = titleDomIndexes.reduce((ids, indexInDOM, registryIndex) => {
        ids[indexInDOM] = this.titles[registryIndex].id;
        return ids;
      }, []);
    }
    // pass all our new aria information to each `<calcite-tab>` and
    // `<calcite-tab-title>` which will check if they can update their internal
    // `controlled` or `labeledBy` states and re-render if necessary
    this.tabs.forEach((el) => el.updateAriaInfo(tabIds, titleIds));
    this.titles.forEach((el) => el.updateAriaInfo(tabIds, titleIds));
  }
  get el() { return this; }
  static get style() { return tabsCss; }
}, [1, "calcite-tabs", {
    "layout": [513],
    "position": [513],
    "scale": [513],
    "bordered": [1540],
    "titles": [32],
    "tabs": [32]
  }, [[0, "calciteInternalTabTitleRegister", "calciteInternalTabTitleRegister"], [16, "calciteTabTitleUnregister", "calciteTabTitleUnregister"], [0, "calciteInternalTabRegister", "calciteInternalTabRegister"], [16, "calciteTabUnregister", "calciteTabUnregister"]]]);
function defineCustomElement$5() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-tabs"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-tabs":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Tabs);
      }
      break;
  } });
}
defineCustomElement$5();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const tabNavCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host{position:relative;display:flex}:host([scale=s]){min-block-size:1.5rem}:host([scale=m]){min-block-size:2rem}:host([scale=l]){min-block-size:2.75rem}.tab-nav{display:flex;inline-size:100%;justify-content:flex-start;overflow:auto}.tab-nav-active-indicator-container{position:absolute;inset-inline:0px;inset-block-end:0px;block-size:0.125rem;inline-size:100%;overflow:hidden}.tab-nav-active-indicator{position:absolute;inset-block-end:0px;display:block;block-size:0.125rem;background-color:var(--calcite-ui-brand);transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;transition-timing-function:cubic-bezier(0, 0, 0.2, 1)}:host([position=bottom]) .tab-nav-active-indicator{inset-block-end:unset;inset-block-start:0px}:host([position=bottom]) .tab-nav-active-indicator-container{inset-block-end:unset;inset-block-start:0px}:host([bordered]) .tab-nav-active-indicator-container{inset-block-end:unset}:host([bordered][position=bottom]) .tab-nav-active-indicator-container{inset-block-end:0;inset-block-start:unset}@media (forced-colors: active){.tab-nav-active-indicator{background-color:highlight}}";

const TabNav = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteTabChange = createEvent(this, "calciteTabChange", 6);
    this.calciteInternalTabChange = createEvent(this, "calciteInternalTabChange", 6);
    this.animationActiveDuration = 0.3;
    this.resizeObserver = createObserver("resize", () => {
      if (!this.activeIndicatorEl) {
        return;
      }
      // remove active indicator transition duration during resize to prevent wobble
      this.activeIndicatorEl.style.transitionDuration = "0s";
      this.updateActiveWidth();
      this.updateOffsetPosition();
    });
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.handleTabFocus = (event, el, destination) => {
      focusElementInGroup(this.enabledTabTitles, el, destination);
      event.stopPropagation();
      event.preventDefault();
    };
    this.handleContainerScroll = () => {
      // remove active indicator transition duration while container is scrolling to prevent wobble
      this.activeIndicatorEl.style.transitionDuration = "0s";
      this.updateOffsetPosition();
    };
    this.storageId = undefined;
    this.syncId = undefined;
    this.selectedTitle = null;
    this.scale = "m";
    this.layout = "inline";
    this.position = "bottom";
    this.bordered = false;
    this.indicatorOffset = undefined;
    this.indicatorWidth = undefined;
    this.selectedTabId = undefined;
  }
  async selectedTabIdChanged() {
    if (localStorage &&
      this.storageId &&
      this.selectedTabId !== undefined &&
      this.selectedTabId !== null) {
      localStorage.setItem(`calcite-tab-nav-${this.storageId}`, JSON.stringify(this.selectedTabId));
    }
    this.calciteInternalTabChange.emit({
      tab: this.selectedTabId
    });
    this.selectedTitle = await this.getTabTitleById(this.selectedTabId);
  }
  selectedTitleChanged() {
    this.updateOffsetPosition();
    this.updateActiveWidth();
    // reset the animation time on tab selection
    this.activeIndicatorEl.style.transitionDuration = `${this.animationActiveDuration}s`;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.parentTabsEl = this.el.closest("calcite-tabs");
    this.resizeObserver?.observe(this.el);
  }
  disconnectedCallback() {
    this.resizeObserver?.disconnect();
  }
  componentWillLoad() {
    const storageKey = `calcite-tab-nav-${this.storageId}`;
    if (localStorage && this.storageId && localStorage.getItem(storageKey)) {
      const storedTab = JSON.parse(localStorage.getItem(storageKey));
      this.selectedTabId = storedTab;
    }
  }
  componentWillRender() {
    const { parentTabsEl } = this;
    this.layout = parentTabsEl?.layout;
    this.position = parentTabsEl?.position;
    this.scale = parentTabsEl?.scale;
    this.bordered = parentTabsEl?.bordered;
    // fix issue with active tab-title not lining up with blue indicator
    if (this.selectedTitle) {
      this.updateOffsetPosition();
    }
  }
  componentDidRender() {
    // if every tab title is active select the first tab.
    if (this.tabTitles.length &&
      this.tabTitles.every((title) => !title.selected) &&
      !this.selectedTabId) {
      this.tabTitles[0].getTabIdentifier().then((tab) => {
        this.calciteInternalTabChange.emit({
          tab
        });
      });
    }
  }
  render() {
    const dir = getElementDir(this.el);
    const width = `${this.indicatorWidth}px`;
    const offset = `${this.indicatorOffset}px`;
    const indicatorStyle = dir !== "rtl" ? { width, left: offset } : { width, right: offset };
    return (h(Host, { role: "tablist" }, h("div", { class: "tab-nav", onScroll: this.handleContainerScroll, ref: (el) => (this.tabNavEl = el) }, h("div", { class: "tab-nav-active-indicator-container", ref: (el) => (this.activeIndicatorContainerEl = el) }, h("div", { class: "tab-nav-active-indicator", ref: (el) => (this.activeIndicatorEl = el), style: indicatorStyle })), h("slot", null))));
  }
  //--------------------------------------------------------------------------
  //
  //  Event Listeners
  //
  //--------------------------------------------------------------------------
  focusPreviousTabHandler(event) {
    this.handleTabFocus(event, event.target, "previous");
  }
  focusNextTabHandler(event) {
    this.handleTabFocus(event, event.target, "next");
  }
  focusFirstTabHandler(event) {
    this.handleTabFocus(event, event.target, "first");
  }
  focusLastTabHandler(event) {
    this.handleTabFocus(event, event.target, "last");
  }
  internalActivateTabHandler(event) {
    this.selectedTabId = event.detail.tab
      ? event.detail.tab
      : this.getIndexOfTabTitle(event.target);
    event.stopPropagation();
    event.preventDefault();
  }
  activateTabHandler(event) {
    this.calciteTabChange.emit();
    event.stopPropagation();
    event.preventDefault();
  }
  /**
   * Check for active tabs on register and update selected
   *
   * @param event
   */
  updateTabTitles(event) {
    if (event.target.selected) {
      this.selectedTabId = event.detail;
    }
  }
  globalInternalTabChangeHandler(event) {
    if (this.syncId &&
      event.target !== this.el &&
      event.target.syncId === this.syncId &&
      this.selectedTabId !== event.detail.tab) {
      this.selectedTabId = event.detail.tab;
    }
    event.stopPropagation();
  }
  iconStartChangeHandler() {
    this.updateActiveWidth();
  }
  updateOffsetPosition() {
    const dir = getElementDir(this.el);
    const navWidth = this.activeIndicatorContainerEl?.offsetWidth;
    const tabLeft = this.selectedTitle?.offsetLeft;
    const tabWidth = this.selectedTitle?.offsetWidth;
    const offsetRight = navWidth - (tabLeft + tabWidth);
    this.indicatorOffset =
      dir !== "rtl" ? tabLeft - this.tabNavEl?.scrollLeft : offsetRight + this.tabNavEl?.scrollLeft;
  }
  updateActiveWidth() {
    this.indicatorWidth = this.selectedTitle?.offsetWidth;
  }
  getIndexOfTabTitle(el, tabTitles = this.tabTitles) {
    // In most cases, since these indexes correlate with tab contents, we want to consider all tab titles.
    // However, when doing relative index operations, it makes sense to pass in this.enabledTabTitles as the 2nd arg.
    return tabTitles.indexOf(el);
  }
  async getTabTitleById(id) {
    return Promise.all(this.tabTitles.map((el) => el.getTabIdentifier())).then((ids) => {
      return this.tabTitles[ids.indexOf(id)];
    });
  }
  get tabTitles() {
    return filterDirectChildren(this.el, "calcite-tab-title");
  }
  get enabledTabTitles() {
    return filterDirectChildren(this.el, "calcite-tab-title:not([disabled])");
  }
  get el() { return this; }
  static get watchers() { return {
    "selectedTabId": ["selectedTabIdChanged"],
    "selectedTitle": ["selectedTitleChanged"]
  }; }
  static get style() { return tabNavCss; }
}, [1, "calcite-tab-nav", {
    "storageId": [513, "storage-id"],
    "syncId": [513, "sync-id"],
    "selectedTitle": [1040],
    "scale": [1537],
    "layout": [1537],
    "position": [1537],
    "bordered": [1540],
    "indicatorOffset": [1026, "indicator-offset"],
    "indicatorWidth": [1026, "indicator-width"],
    "selectedTabId": [32]
  }, [[0, "calciteInternalTabsFocusPrevious", "focusPreviousTabHandler"], [0, "calciteInternalTabsFocusNext", "focusNextTabHandler"], [0, "calciteInternalTabsFocusFirst", "focusFirstTabHandler"], [0, "calciteInternalTabsFocusLast", "focusLastTabHandler"], [0, "calciteInternalTabsActivate", "internalActivateTabHandler"], [0, "calciteTabsActivate", "activateTabHandler"], [0, "calciteInternalTabTitleRegister", "updateTabTitles"], [16, "calciteInternalTabChange", "globalInternalTabChangeHandler"], [0, "calciteInternalTabIconChanged", "iconStartChangeHandler"]]]);
function defineCustomElement$4() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-tab-nav"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-tab-nav":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, TabNav);
      }
      break;
  } });
}
defineCustomElement$4();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const tabCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host([selected]) section,:host([selected]) .container{display:block}:host{display:none;block-size:100%;inline-size:100%}:host([selected]){display:block;block-size:100%;inline-size:100%;overflow:auto}section,.container{display:none;block-size:100%;inline-size:100%}:host([scale=s]){padding-block:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem}:host([scale=m]){padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=l]){font-size:var(--calcite-font-size-0);line-height:1.25rem;padding-block:13px}";

const Tab = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteInternalTabRegister = createEvent(this, "calciteInternalTabRegister", 6);
    this.guid = `calcite-tab-title-${guid()}`;
    this.tab = undefined;
    this.selected = false;
    this.scale = "m";
    this.labeledBy = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    const id = this.el.id || this.guid;
    return (h(Host, { "aria-labelledby": this.labeledBy, id: id }, h("div", { class: "container", role: "tabpanel", tabIndex: this.selected ? 0 : -1 }, h("section", null, h("slot", null)))));
  }
  connectedCallback() {
    this.parentTabsEl = this.el.closest("calcite-tabs");
  }
  componentDidLoad() {
    this.calciteInternalTabRegister.emit();
  }
  componentWillRender() {
    this.scale = this.parentTabsEl?.scale;
  }
  disconnectedCallback() {
    // Dispatching to body in order to be listened by other elements that are still connected to the DOM.
    document.body?.dispatchEvent(new CustomEvent("calciteTabUnregister", {
      detail: this.el
    }));
  }
  //--------------------------------------------------------------------------
  //
  //  Event Listeners
  //
  //--------------------------------------------------------------------------
  internalTabChangeHandler(event) {
    const targetTabsEl = event
      .composedPath()
      .find((el) => el.tagName === "CALCITE-TABS");
    // to allow `<calcite-tabs>` to be nested we need to make sure this
    // `calciteTabChange` event was actually fired from a within the same
    // `<calcite-tabs>` that is the a parent of this tab.
    if (targetTabsEl !== this.parentTabsEl) {
      return;
    }
    if (this.tab) {
      this.selected = this.tab === event.detail.tab;
    }
    else {
      this.getTabIndex().then((index) => {
        this.selected = index === event.detail.tab;
      });
    }
    event.stopPropagation();
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Returns the index of the component item within the tab array.
   */
  async getTabIndex() {
    return Array.prototype.indexOf.call(nodeListToArray(this.el.parentElement.children).filter((el) => el.matches("calcite-tab")), this.el);
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  /**
   * @param tabIds
   * @param titleIds
   * @internal
   */
  async updateAriaInfo(tabIds = [], titleIds = []) {
    this.labeledBy = titleIds[tabIds.indexOf(this.el.id)] || null;
  }
  get el() { return this; }
  static get style() { return tabCss; }
}, [1, "calcite-tab", {
    "tab": [513],
    "selected": [1540],
    "scale": [1537],
    "labeledBy": [32],
    "getTabIndex": [64],
    "updateAriaInfo": [64]
  }, [[16, "calciteInternalTabChange", "internalTabChangeHandler"]]]);
function defineCustomElement$3() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-tab"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-tab":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Tab);
      }
      break;
  } });
}
defineCustomElement$3();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const CSS$2 = {
  container: "container",
  containerHasText: "container--has-text",
  iconEnd: "icon-end",
  iconStart: "icon-start",
  iconPresent: "icon-present",
  titleIcon: "calcite-tab-title--icon"
};

const tabTitleCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host([disabled]){pointer-events:none;cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-ui-opacity-disabled)}:host{display:block;flex:0 1 auto;outline:2px solid transparent;outline-offset:2px;margin-inline-start:0px;margin-inline-end:1.25rem}:host([layout=center]){margin-block:0px;margin-inline:1.25rem;text-align:center;flex-basis:12rem;margin:auto}:host([position=bottom]) .container{border-block-end-width:0px;border-block-start-width:2px;border-block-start-color:transparent;border-block-start-style:solid}:host .container{outline-color:transparent}:host(:focus) .container{outline:2px solid var(--calcite-ui-brand);outline-offset:-2px}:host(:active) a,:host(:focus) a,:host(:hover) a{border-color:var(--calcite-ui-border-2);color:var(--calcite-ui-text-1);text-decoration-line:none}:host([selected]) .container{border-color:transparent;color:var(--calcite-ui-text-1)}:host([disabled]) .container{pointer-events:none;opacity:0.5}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}:host([scale=s]){margin-inline-end:1rem}:host([scale=s]) .container{padding-block:0.25rem;font-size:var(--calcite-font-size--2);line-height:1rem}:host([scale=m]) .container{padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=l]){margin-inline-end:1.5rem}:host([scale=l]) .container{padding-block:0.625rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}.container{box-sizing:border-box;display:flex;block-size:100%;inline-size:100%;cursor:pointer;-webkit-appearance:none;appearance:none;justify-content:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;border-block-end-width:2px;padding-inline:0px;font-size:var(--calcite-font-size--1);line-height:1rem;color:var(--calcite-ui-text-3);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-block-end-color:transparent;border-block-end-style:solid}.calcite-tab-title--icon{position:relative;margin:0px;display:inline-flex;align-self:center}.calcite-tab-title--icon svg{transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}.container--has-text{padding:0.25rem}.container--has-text .calcite-tab-title--icon.icon-start{margin-inline-end:0.5rem}.container--has-text .calcite-tab-title--icon.icon-end{margin-inline-start:0.5rem}:host([icon-start][icon-end]) .calcite-tab-title--icon:first-child{margin-inline-end:0.5rem}:host([bordered]){margin-inline-end:0}:host([bordered][selected]){box-shadow:inset 0px -2px var(--calcite-ui-foreground-1)}:host([bordered][selected][position=bottom]){box-shadow:inset 0 2px 0 var(--calcite-ui-foreground-1)}:host([bordered]:hover) .container,:host([bordered]:focus) .container,:host([bordered]:active) .container{position:relative}:host([bordered]:hover) .container{background-color:var(--calcite-button-transparent-hover)}:host([bordered]) .container{border-block-end-style:unset;border-inline-start:1px solid transparent;border-inline-end:1px solid transparent}:host([bordered][position=bottom]) .container{border-block-start-style:unset}:host([selected][bordered]) .container{border-inline-start-color:var(--calcite-ui-border-1);border-inline-end-color:var(--calcite-ui-border-1)}:host([bordered]) .container{padding-inline:0.75rem}:host([bordered][scale=s]) .container{padding-inline:0.5rem}:host([bordered][scale=l]) .container{padding-inline:1rem}:host([bordered][scale=l]) .icon-present{padding-block:11px}@media (forced-colors: active){:host{outline-width:0;outline-offset:0}:host(:focus) .container{outline-color:highlight}:host([bordered]) .container{border-block-end-style:solid}:host([bordered][position=bottom]) .container{border-block-start-style:solid}:host([bordered][selected]) .container{border-block-end-style:none}:host([bordered][position=bottom][selected]) .container{border-block-start-style:none}}";

const TabTitle = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteTabsActivate = createEvent(this, "calciteTabsActivate", 6);
    this.calciteInternalTabsActivate = createEvent(this, "calciteInternalTabsActivate", 6);
    this.calciteInternalTabsFocusNext = createEvent(this, "calciteInternalTabsFocusNext", 6);
    this.calciteInternalTabsFocusPrevious = createEvent(this, "calciteInternalTabsFocusPrevious", 6);
    this.calciteInternalTabsFocusFirst = createEvent(this, "calciteInternalTabsFocusFirst", 6);
    this.calciteInternalTabsFocusLast = createEvent(this, "calciteInternalTabsFocusLast", 6);
    this.calciteInternalTabTitleRegister = createEvent(this, "calciteInternalTabTitleRegister", 6);
    this.calciteInternalTabIconChanged = createEvent(this, "calciteInternalTabIconChanged", 6);
    //--------------------------------------------------------------------------
    //
    //  Private State/Props
    //
    //--------------------------------------------------------------------------
    /** watches for changing text content */
    this.mutationObserver = createObserver("mutation", () => this.updateHasText());
    this.resizeObserver = createObserver("resize", () => {
      this.calciteInternalTabIconChanged.emit();
    });
    this.guid = `calcite-tab-title-${guid()}`;
    this.selected = false;
    this.disabled = false;
    this.iconEnd = undefined;
    this.iconFlipRtl = undefined;
    this.iconStart = undefined;
    this.layout = undefined;
    this.position = undefined;
    this.scale = undefined;
    this.bordered = false;
    this.tab = undefined;
    this.controls = undefined;
    this.hasText = false;
  }
  selectedHandler() {
    if (this.selected) {
      this.emitActiveTab(false);
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.setupTextContentObserver();
    this.parentTabNavEl = this.el.closest("calcite-tab-nav");
    this.parentTabsEl = this.el.closest("calcite-tabs");
  }
  disconnectedCallback() {
    this.mutationObserver?.disconnect();
    // Dispatching to body in order to be listened by other elements that are still connected to the DOM.
    document.body?.dispatchEvent(new CustomEvent("calciteTabTitleUnregister", {
      detail: this.el
    }));
    this.resizeObserver?.disconnect();
  }
  componentWillLoad() {
    {
      this.updateHasText();
    }
    if (this.tab && this.selected) {
      this.emitActiveTab(false);
    }
  }
  componentWillRender() {
    if (this.parentTabsEl) {
      this.layout = this.parentTabsEl.layout;
      this.position = this.parentTabsEl.position;
      this.scale = this.parentTabsEl.scale;
      this.bordered = this.parentTabsEl.bordered;
    }
    // handle case when tab-nav is only parent
    if (!this.parentTabsEl && this.parentTabNavEl) {
      this.position = getElementProp(this.parentTabNavEl, "position", this.position);
      this.scale = getElementProp(this.parentTabNavEl, "scale", this.scale);
    }
  }
  render() {
    const id = this.el.id || this.guid;
    const iconStartEl = (h("calcite-icon", { class: { [CSS$2.titleIcon]: true, [CSS$2.iconStart]: true }, flipRtl: this.iconFlipRtl === "start" || this.iconFlipRtl === "both", icon: this.iconStart, scale: this.scale === "l" ? "m" : "s" }));
    const iconEndEl = (h("calcite-icon", { class: { [CSS$2.titleIcon]: true, [CSS$2.iconEnd]: true }, flipRtl: this.iconFlipRtl === "end" || this.iconFlipRtl === "both", icon: this.iconEnd, scale: this.scale === "l" ? "m" : "s" }));
    return (h(Host, { "aria-controls": this.controls, "aria-selected": toAriaBoolean(this.selected), id: id, role: "tab", tabIndex: this.selected ? 0 : -1 }, h("div", { class: {
        container: true,
        [CSS$2.iconPresent]: this.iconStart || this.iconEnd ? true : null,
        [CSS$2.containerHasText]: this.hasText
      }, ref: (el) => this.resizeObserver?.observe(el) }, this.iconStart ? iconStartEl : null, h("slot", null), this.iconEnd ? iconEndEl : null)));
  }
  async componentDidLoad() {
    this.calciteInternalTabTitleRegister.emit(await this.getTabIdentifier());
  }
  componentDidRender() {
    updateHostInteraction(this, () => {
      return this.selected;
    });
  }
  //--------------------------------------------------------------------------
  //
  //  Event Listeners
  //
  //--------------------------------------------------------------------------
  internalTabChangeHandler(event) {
    const targetTabsEl = event
      .composedPath()
      .find((el) => el.tagName === "CALCITE-TABS");
    if (targetTabsEl !== this.parentTabsEl) {
      return;
    }
    if (this.tab) {
      this.selected = this.tab === event.detail.tab;
    }
    else {
      this.getTabIndex().then((index) => {
        this.selected = index === event.detail.tab;
      });
    }
    event.stopPropagation();
  }
  onClick() {
    this.emitActiveTab();
  }
  keyDownHandler(event) {
    switch (event.key) {
      case " ":
      case "Enter":
        this.emitActiveTab();
        event.preventDefault();
        break;
      case "ArrowRight":
        event.preventDefault();
        if (getElementDir(this.el) === "ltr") {
          this.calciteInternalTabsFocusNext.emit();
        }
        else {
          this.calciteInternalTabsFocusPrevious.emit();
        }
        break;
      case "ArrowLeft":
        event.preventDefault();
        if (getElementDir(this.el) === "ltr") {
          this.calciteInternalTabsFocusPrevious.emit();
        }
        else {
          this.calciteInternalTabsFocusNext.emit();
        }
        break;
      case "Home":
        event.preventDefault();
        this.calciteInternalTabsFocusFirst.emit();
        break;
      case "End":
        event.preventDefault();
        this.calciteInternalTabsFocusLast.emit();
        break;
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Returns the index of the title within the `calcite-tab-nav`.
   */
  async getTabIndex() {
    return Array.prototype.indexOf.call(this.el.parentElement.querySelectorAll("calcite-tab-title"), this.el);
  }
  /**
   * @internal
   */
  async getTabIdentifier() {
    return this.tab ? this.tab : this.getTabIndex();
  }
  /**
   * @param tabIds
   * @param titleIds
   * @internal
   */
  async updateAriaInfo(tabIds = [], titleIds = []) {
    this.controls = tabIds[titleIds.indexOf(this.el.id)] || null;
  }
  updateHasText() {
    this.hasText = this.el.textContent.trim().length > 0;
  }
  setupTextContentObserver() {
    this.mutationObserver?.observe(this.el, { childList: true, subtree: true });
  }
  emitActiveTab(userTriggered = true) {
    if (this.disabled) {
      return;
    }
    const payload = { tab: this.tab };
    this.calciteInternalTabsActivate.emit(payload);
    if (userTriggered) {
      this.calciteTabsActivate.emit();
    }
  }
  get el() { return this; }
  static get watchers() { return {
    "selected": ["selectedHandler"]
  }; }
  static get style() { return tabTitleCss; }
}, [1, "calcite-tab-title", {
    "selected": [1540],
    "disabled": [516],
    "iconEnd": [513, "icon-end"],
    "iconFlipRtl": [513, "icon-flip-rtl"],
    "iconStart": [513, "icon-start"],
    "layout": [1537],
    "position": [1537],
    "scale": [1537],
    "bordered": [1540],
    "tab": [513],
    "controls": [32],
    "hasText": [32],
    "getTabIndex": [64],
    "getTabIdentifier": [64],
    "updateAriaInfo": [64]
  }, [[16, "calciteInternalTabChange", "internalTabChangeHandler"], [0, "click", "onClick"], [0, "keydown", "keyDownHandler"]]]);
function defineCustomElement$2() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-tab-title", "calcite-icon"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-tab-title":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, TabTitle);
      }
      break;
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
  } });
}
defineCustomElement$2();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

/**
 * Exported for testing purposes.
 */
const hiddenFormInputSlotName = "hidden-form-input";
function isCheckable(component) {
  return "checked" in component;
}
const onFormResetMap = new WeakMap();
const formComponentSet = new WeakSet();
function hasRegisteredFormComponentParent(form, formComponentEl) {
  // we use events as a way to test for nested form-associated components across shadow bounds
  const formComponentRegisterEventName = "calciteInternalFormComponentRegister";
  let hasRegisteredFormComponentParent = false;
  form.addEventListener(formComponentRegisterEventName, (event) => {
    hasRegisteredFormComponentParent = event
      .composedPath()
      .some((element) => formComponentSet.has(element));
    event.stopPropagation();
  }, { once: true });
  formComponentEl.dispatchEvent(new CustomEvent(formComponentRegisterEventName, {
    bubbles: true,
    composed: true
  }));
  return hasRegisteredFormComponentParent;
}
/**
 * Helper to submit a form.
 *
 * @param component
 * @returns true if its associated form was submitted, false otherwise.
 */
function submitForm(component) {
  const { formEl } = component;
  if (!formEl) {
    return false;
  }
  "requestSubmit" in formEl ? formEl.requestSubmit() : formEl.submit();
  return true;
}
/**
 * Helper to reset a form.
 *
 * @param component
 */
function resetForm(component) {
  component.formEl?.reset();
}
/**
 * Helper to set up form interactions on connectedCallback.
 *
 * @param component
 */
function connectForm(component) {
  const { el, value } = component;
  const form = closestElementCrossShadowBoundary(el, "form");
  if (!form || hasRegisteredFormComponentParent(form, el)) {
    return;
  }
  component.formEl = form;
  component.defaultValue = value;
  if (isCheckable(component)) {
    component.defaultChecked = component.checked;
  }
  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);
  form.addEventListener("reset", boundOnFormReset);
  onFormResetMap.set(component.el, boundOnFormReset);
  formComponentSet.add(el);
}
function onFormReset() {
  if (isCheckable(this)) {
    this.checked = this.defaultChecked;
    return;
  }
  this.value = this.defaultValue;
}
/**
 * Helper to tear down form interactions on disconnectedCallback.
 *
 * @param component
 */
function disconnectForm(component) {
  const { el, formEl } = component;
  if (!formEl) {
    return;
  }
  const boundOnFormReset = onFormResetMap.get(el);
  formEl.removeEventListener("reset", boundOnFormReset);
  onFormResetMap.delete(el);
  component.formEl = null;
  formComponentSet.delete(el);
}
/**
 * Helper for setting the default value on initialization after connectedCallback.
 *
 * Note that this is only needed if the default value cannot be determined on connectedCallback.
 *
 * @param component
 * @param value
 */
function afterConnectDefaultValueSet(component, value) {
  component.defaultValue = value;
}
const hiddenInputChangeHandler = (event) => {
  event.target.dispatchEvent(new CustomEvent("calciteInternalHiddenInputChange", { bubbles: true }));
};
const removeHiddenInputChangeEventListener = (input) => input.removeEventListener("change", hiddenInputChangeHandler);
/**
 * Helper for maintaining a form-associated's hidden input in sync with the component.
 *
 * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198
 *
 * @param component
 */
function syncHiddenFormInput(component) {
  const { el, formEl, name, value } = component;
  const { ownerDocument } = el;
  const inputs = el.querySelectorAll(`input[slot="${hiddenFormInputSlotName}"]`);
  if (!formEl || !name) {
    inputs.forEach((input) => {
      removeHiddenInputChangeEventListener(input);
      input.remove();
    });
    return;
  }
  const values = Array.isArray(value) ? value : [value];
  const extra = [];
  const seen = new Set();
  inputs.forEach((input) => {
    const valueMatch = values.find((val) => 
    /* intentional non-strict equality check */
    val == input.value);
    if (valueMatch != null) {
      seen.add(valueMatch);
      defaultSyncHiddenFormInput(component, input, valueMatch);
    }
    else {
      extra.push(input);
    }
  });
  let docFrag;
  values.forEach((value) => {
    if (seen.has(value)) {
      return;
    }
    let input = extra.pop();
    if (!input) {
      input = ownerDocument.createElement("input");
      input.slot = hiddenFormInputSlotName;
    }
    if (!docFrag) {
      docFrag = ownerDocument.createDocumentFragment();
    }
    docFrag.append(input);
    // emits when hidden input is autofilled
    input.addEventListener("change", hiddenInputChangeHandler);
    defaultSyncHiddenFormInput(component, input, value);
  });
  if (docFrag) {
    el.append(docFrag);
  }
  extra.forEach((input) => {
    removeHiddenInputChangeEventListener(input);
    input.remove();
  });
}
function defaultSyncHiddenFormInput(component, input, value) {
  const { defaultValue, disabled, name, required } = component;
  // keep in sync to prevent losing reset value
  input.defaultValue = defaultValue;
  input.disabled = disabled;
  input.name = name;
  input.required = required;
  input.tabIndex = -1;
  if (isCheckable(component)) {
    input.checked = component.checked;
    // keep in sync to prevent losing reset value
    input.defaultChecked = component.defaultChecked;
    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on
    input.value = component.checked ? value || "on" : "";
  }
  else {
    input.value = value || "";
  }
  component.syncHiddenFormInput?.(input);
}
/**
 * Helper to render the slot for form-associated component's hidden input.
 *
 * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.
 *
 * render(): VNode {
 *   <Host>
 *     <div class={CSS.container}>
 *     // ...
 *     <HiddenFormInputSlot component={this} />
 *     </div>
 *   </Host>
 * }
 *
 * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.
 *
 * @param root0
 * @param root0.component
 */
const HiddenFormInputSlot = ({ component }) => {
  syncHiddenFormInput(component);
  return h("slot", { name: hiddenFormInputSlotName });
};

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

/**
 * Exported for testing purposes only
 *
 * @internal
 */
const labelClickEvent = "calciteInternalLabelClick";
const labelConnectedEvent = "calciteInternalLabelConnected";
const labelDisconnectedEvent = "calciteInternaLabelDisconnected";
const labelTagName = "calcite-label";
const onLabelClickMap = new WeakMap();
const onLabelConnectedMap = new WeakMap();
const onLabelDisconnectedMap = new WeakMap();
const unlabeledComponents = new Set();
const findLabelForComponent = (componentEl) => {
  const { id } = componentEl;
  const forLabel = id && queryElementRoots(componentEl, { selector: `${labelTagName}[for="${id}"]` });
  if (forLabel) {
    return forLabel;
  }
  const parentLabel = closestElementCrossShadowBoundary(componentEl, labelTagName);
  if (!parentLabel ||
    // labelable components within other custom elements are not considered labelable
    hasAncestorCustomElements(parentLabel, componentEl)) {
    return null;
  }
  return parentLabel;
};
function hasAncestorCustomElements(label, componentEl) {
  let traversedElements;
  const customElementAncestorCheckEventType = "custom-element-ancestor-check";
  const listener = (event) => {
    event.stopImmediatePropagation();
    const composedPath = event.composedPath();
    traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));
  };
  label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });
  componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));
  label.removeEventListener(customElementAncestorCheckEventType, listener);
  const ancestorCustomElements = traversedElements
    .filter((el) => el !== componentEl && el !== label)
    .filter((el) => el.tagName?.includes("-"));
  return ancestorCustomElements.length > 0;
}
/**
 * Helper to set up label interactions on connectedCallback.
 *
 * @param component
 */
function connectLabel(component) {
  const labelEl = findLabelForComponent(component.el);
  if (onLabelClickMap.has(labelEl) || (!labelEl && unlabeledComponents.has(component))) {
    return;
  }
  const boundOnLabelDisconnected = onLabelDisconnected.bind(component);
  if (labelEl) {
    component.labelEl = labelEl;
    const boundOnLabelClick = onLabelClick.bind(component);
    onLabelClickMap.set(component.labelEl, boundOnLabelClick);
    component.labelEl.addEventListener(labelClickEvent, boundOnLabelClick);
    unlabeledComponents.delete(component);
    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));
    onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);
    document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);
  }
  else if (!unlabeledComponents.has(component)) {
    boundOnLabelDisconnected();
    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));
  }
}
/**
 * Helper to tear down label interactions on disconnectedCallback on labelable components.
 *
 * @param component
 */
function disconnectLabel(component) {
  unlabeledComponents.delete(component);
  document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));
  document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));
  onLabelConnectedMap.delete(component);
  onLabelDisconnectedMap.delete(component);
  if (!component.labelEl) {
    return;
  }
  const boundOnLabelClick = onLabelClickMap.get(component.labelEl);
  component.labelEl.removeEventListener(labelClickEvent, boundOnLabelClick);
  onLabelClickMap.delete(component.labelEl);
}
/**
 * Helper to get the label text from a component.
 *
 * @param component
 */
function getLabelText(component) {
  return component.label || component.labelEl?.textContent?.trim() || "";
}
function onLabelClick(event) {
  if (this.disabled) {
    return;
  }
  const containedLabelableChildClicked = this.el.contains(event.detail.sourceEvent.target);
  if (containedLabelableChildClicked) {
    return;
  }
  this.onLabelClick(event);
}
function onLabelConnected() {
  if (unlabeledComponents.has(this)) {
    connectLabel(this);
  }
}
function onLabelDisconnected() {
  unlabeledComponents.add(this);
  const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);
  onLabelConnectedMap.set(this, boundOnLabelConnected);
  document.addEventListener(labelConnectedEvent, boundOnLabelConnected);
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const CSS$1 = {
  icon: "icon",
  iconContainer: "icon-container",
  select: "select"
};

const selectCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:host{--calcite-icon-size:1rem;--calcite-spacing-eighth:0.125rem;--calcite-spacing-quarter:0.25rem;--calcite-spacing-half:0.5rem;--calcite-spacing-three-quarters:0.75rem;--calcite-spacing:1rem;--calcite-spacing-plus-quarter:1.25rem;--calcite-spacing-plus-half:1.5rem;--calcite-spacing-double:2rem;--calcite-menu-min-width:10rem;--calcite-header-min-height:3rem;--calcite-footer-min-height:3rem}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host([disabled]){pointer-events:none;cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-ui-opacity-disabled)}:host{position:relative;display:flex;align-items:stretch;inline-size:var(--select-width)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}:host([scale=s]){block-size:1.5rem;--calcite-select-font-size:var(--calcite-font-size--2);--calcite-select-spacing-inline:0.5rem 2rem}:host([scale=s]) .icon-container{padding-inline:0.5rem}:host([scale=m]){block-size:2rem;--calcite-select-font-size:var(--calcite-font-size--1);--calcite-select-spacing-inline:0.75rem 2.5rem}:host([scale=m]) .icon-container{padding-inline:0.75rem}:host([scale=l]){block-size:44px;--calcite-select-font-size:var(--calcite-font-size-0);--calcite-select-spacing-inline:1rem 3rem}:host([scale=l]) .icon-container{padding-inline:1rem}:host([width=auto]){inline-size:auto}:host([width=half]){inline-size:50%}:host([width=full]){inline-size:100%}.select{margin:0px;box-sizing:border-box;inline-size:100%;cursor:pointer;-webkit-appearance:none;appearance:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;border-radius:0px;border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-input);background-color:var(--calcite-ui-foreground-1);font-family:inherit;color:var(--calcite-ui-text-2);outline-color:transparent;font-size:var(--calcite-select-font-size);padding-inline:var(--calcite-select-spacing-inline);border-inline-end-width:0px}.select:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:-2px}.select:hover{background-color:var(--calcite-ui-foreground-2)}select:disabled{border-color:var(--calcite-ui-border-input);--tw-bg-opacity:1}.icon-container{pointer-events:none;position:absolute;inset-block:0px;display:flex;align-items:center;border-width:0px;border-style:solid;border-color:var(--calcite-ui-border-input);background-color:transparent;color:var(--calcite-ui-text-2);inset-inline-end:0px;border-inline-width:0px 1px}.select:focus~.icon-container{border-color:transparent}::slotted(input[slot=hidden-form-input]){margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}";

function isOption(optionOrGroup) {
  return optionOrGroup.tagName === "CALCITE-OPTION";
}
function isOptionGroup(optionOrGroup) {
  return optionOrGroup.tagName === "CALCITE-OPTION-GROUP";
}
const Select = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteSelectChange = createEvent(this, "calciteSelectChange", 6);
    this.componentToNativeEl = new Map();
    this.mutationObserver = createObserver("mutation", () => this.populateInternalSelect());
    this.handleInternalSelectChange = () => {
      const selected = this.selectEl.selectedOptions[0];
      this.selectFromNativeOption(selected);
      requestAnimationFrame(() => this.emitChangeEvent());
    };
    this.populateInternalSelect = () => {
      const optionsAndGroups = Array.from(this.el.children).filter((child) => child.tagName === "CALCITE-OPTION" || child.tagName === "CALCITE-OPTION-GROUP");
      this.clearInternalSelect();
      optionsAndGroups.forEach((optionOrGroup) => this.selectEl?.append(this.toNativeElement(optionOrGroup)));
    };
    this.storeSelectRef = (node) => {
      this.selectEl = node;
      this.populateInternalSelect();
      const selected = this.selectEl.selectedOptions[0];
      this.selectFromNativeOption(selected);
    };
    this.emitChangeEvent = () => {
      this.calciteSelectChange.emit();
    };
    this.disabled = false;
    this.label = undefined;
    this.name = undefined;
    this.required = false;
    this.scale = "m";
    this.value = null;
    this.selectedOption = undefined;
    this.width = "auto";
  }
  valueHandler(value) {
    const items = this.el.querySelectorAll("calcite-option");
    items.forEach((item) => (item.selected = item.value === value));
  }
  selectedOptionHandler(selectedOption) {
    this.value = selectedOption?.value;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    const { el } = this;
    this.mutationObserver?.observe(el, {
      subtree: true,
      childList: true
    });
    connectLabel(this);
    connectForm(this);
  }
  disconnectedCallback() {
    this.mutationObserver?.disconnect();
    disconnectLabel(this);
    disconnectForm(this);
  }
  componentWillLoad() {
    setUpLoadableComponent(this);
  }
  componentDidLoad() {
    setComponentLoaded(this);
    afterConnectDefaultValueSet(this, this.selectedOption?.value ?? "");
  }
  componentDidRender() {
    updateHostInteraction(this);
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /** Sets focus on the component. */
  async setFocus() {
    await componentLoaded(this);
    focusElement(this.selectEl);
  }
  handleOptionOrGroupChange(event) {
    event.stopPropagation();
    const optionOrGroup = event.target;
    const nativeEl = this.componentToNativeEl.get(optionOrGroup);
    if (!nativeEl) {
      return;
    }
    this.updateNativeElement(optionOrGroup, nativeEl);
    if (isOption(optionOrGroup) && optionOrGroup.selected) {
      this.deselectAllExcept(optionOrGroup);
      this.selectedOption = optionOrGroup;
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  onLabelClick() {
    this.setFocus();
  }
  updateNativeElement(optionOrGroup, nativeOptionOrGroup) {
    nativeOptionOrGroup.disabled = optionOrGroup.disabled;
    nativeOptionOrGroup.label = optionOrGroup.label;
    if (isOption(optionOrGroup)) {
      const option = nativeOptionOrGroup;
      option.selected = optionOrGroup.selected;
      option.value = optionOrGroup.value;
      // need to set innerText for mobile
      // see https://stackoverflow.com/questions/35021620/ios-safari-not-showing-all-options-for-select-menu/41749701
      option.innerText = optionOrGroup.label;
    }
  }
  clearInternalSelect() {
    this.componentToNativeEl.forEach((value) => value.remove());
    this.componentToNativeEl.clear();
  }
  selectFromNativeOption(nativeOption) {
    if (!nativeOption) {
      return;
    }
    let futureSelected;
    this.componentToNativeEl.forEach((nativeOptionOrGroup, optionOrGroup) => {
      if (isOption(optionOrGroup) && nativeOptionOrGroup === nativeOption) {
        optionOrGroup.selected = true;
        futureSelected = optionOrGroup;
        this.deselectAllExcept(optionOrGroup);
      }
    });
    if (futureSelected) {
      this.selectedOption = futureSelected;
    }
  }
  toNativeElement(optionOrGroup) {
    if (isOption(optionOrGroup)) {
      const option = document.createElement("option");
      this.updateNativeElement(optionOrGroup, option);
      this.componentToNativeEl.set(optionOrGroup, option);
      return option;
    }
    if (isOptionGroup(optionOrGroup)) {
      const group = document.createElement("optgroup");
      this.updateNativeElement(optionOrGroup, group);
      Array.from(optionOrGroup.children).forEach((option) => {
        const nativeOption = this.toNativeElement(option);
        group.append(nativeOption);
        this.componentToNativeEl.set(optionOrGroup, nativeOption);
      });
      this.componentToNativeEl.set(optionOrGroup, group);
      return group;
    }
    throw new Error("unsupported element child provided");
  }
  deselectAllExcept(except) {
    this.el.querySelectorAll("calcite-option").forEach((option) => {
      if (option === except) {
        return;
      }
      option.selected = false;
    });
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  renderChevron() {
    return (h("div", { class: CSS$1.iconContainer }, h("calcite-icon", { class: CSS$1.icon, icon: "chevron-down", scale: this.scale === "l" ? "m" : "s" })));
  }
  render() {
    return (h(Fragment, null, h("select", { "aria-label": this.label, class: CSS$1.select, disabled: this.disabled, onChange: this.handleInternalSelectChange, ref: this.storeSelectRef }, h("slot", null)), this.renderChevron(), h(HiddenFormInputSlot, { component: this })));
  }
  get el() { return this; }
  static get watchers() { return {
    "value": ["valueHandler"],
    "selectedOption": ["selectedOptionHandler"]
  }; }
  static get style() { return selectCss; }
}, [1, "calcite-select", {
    "disabled": [516],
    "label": [1],
    "name": [513],
    "required": [516],
    "scale": [513],
    "value": [1025],
    "selectedOption": [1040],
    "width": [513],
    "setFocus": [64]
  }, [[0, "calciteInternalOptionChange", "handleOptionOrGroupChange"], [0, "calciteInternalOptionGroupChange", "handleOptionOrGroupChange"]]]);
function defineCustomElement$1$2() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-select", "calcite-icon"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-select":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Select);
      }
      break;
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
  } });
}
defineCustomElement$1$2();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const optionCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host{display:block}";

const Option = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteInternalOptionChange = createEvent(this, "calciteInternalOptionChange", 6);
    this.mutationObserver = createObserver("mutation", () => {
      this.ensureTextContentDependentProps();
      this.calciteInternalOptionChange.emit();
    });
    this.disabled = false;
    this.label = undefined;
    this.selected = undefined;
    this.value = undefined;
  }
  handlePropChange(_newValue, _oldValue, propName) {
    if (propName === "label" || propName === "value") {
      this.ensureTextContentDependentProps();
    }
    this.calciteInternalOptionChange.emit();
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  ensureTextContentDependentProps() {
    const { el: { textContent } } = this;
    if (!this.label || this.label === this.internallySetLabel) {
      this.label = textContent;
      this.internallySetLabel = textContent;
    }
    if (!this.value || this.value === this.internallySetValue) {
      this.value = textContent;
      this.internallySetValue = textContent;
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.ensureTextContentDependentProps();
    this.mutationObserver?.observe(this.el, {
      attributeFilter: ["label", "value"],
      characterData: true,
      childList: true,
      subtree: true
    });
  }
  disconnectedCallback() {
    this.mutationObserver?.disconnect();
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    return h("slot", null, this.label);
  }
  get el() { return this; }
  static get watchers() { return {
    "disabled": ["handlePropChange"],
    "label": ["handlePropChange"],
    "selected": ["handlePropChange"],
    "value": ["handlePropChange"]
  }; }
  static get style() { return optionCss; }
}, [1, "calcite-option", {
    "disabled": [516],
    "label": [1025],
    "selected": [516],
    "value": [1032]
  }]);
function defineCustomElement$1$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-option"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-option":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Option);
      }
      break;
  } });
}
defineCustomElement$1$1();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const decimalPlaces = (value) => {
  const match = ("" + value).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  if (!match) {
    return 0;
  }
  return Math.max(0, 
  // Number of digits right of decimal point.
  (match[1] ? match[1].length : 0) -
    // Adjust for scientific notation.
    (match[2] ? +match[2] : 0));
};

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const progressCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host{position:relative;display:block;inline-size:100%}.track,.bar{position:absolute;inset-block-start:0px;block-size:2px}.track{z-index:1;inline-size:100%;overflow:hidden;background:var(--calcite-ui-border-3)}.bar{z-index:1;background-color:var(--calcite-ui-brand)}@media (forced-colors: active){.track{background-color:highlightText}.bar{background-color:linkText}}.indeterminate{inline-size:20%;animation:looping-progress-bar-ani calc(var(--calcite-internal-animation-timing-medium) * 11) linear infinite}.reversed{animation-direction:reverse}.text{padding-inline:0px;padding-block:1rem 0px;text-align:center;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-ui-text-2)}@keyframes looping-progress-bar-ani{0%{transform:translate3d(-100%, 0, 0)}50%{inline-size:40%}100%{transform:translate3d(600%, 0, 0)}}";

const Progress = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.type = "determinate";
    this.value = 0;
    this.label = undefined;
    this.text = undefined;
    this.reversed = false;
  }
  render() {
    const isDeterminate = this.type === "determinate";
    const barStyles = isDeterminate ? { width: `${this.value * 100}%` } : {};
    return (h("div", { "aria-label": this.label || this.text, "aria-valuemax": 1, "aria-valuemin": 0, "aria-valuenow": this.value, role: "progressbar" }, h("div", { class: "track" }, h("div", { class: {
        bar: true,
        indeterminate: this.type === "indeterminate",
        reversed: this.reversed
      }, style: barStyles })), this.text ? h("div", { class: "text" }, this.text) : null));
  }
  get el() { return this; }
  static get style() { return progressCss; }
}, [1, "calcite-progress", {
    "type": [513],
    "value": [2],
    "label": [1],
    "text": [1],
    "reversed": [516]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-progress"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-progress":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Progress);
      }
      break;
  } });
}
defineCustomElement();

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */

const CSS = {
  loader: "loader",
  clearButton: "clear-button",
  editingEnabled: "editing-enabled",
  inlineChild: "inline-child",
  inputIcon: "icon",
  prefix: "prefix",
  suffix: "suffix",
  numberButtonWrapper: "number-button-wrapper",
  buttonItemHorizontal: "number-button-item--horizontal",
  wrapper: "element-wrapper",
  inputWrapper: "wrapper",
  actionWrapper: "action-wrapper",
  resizeIconWrapper: "resize-icon-wrapper",
  numberButtonItem: "number-button-item"
};
const SLOTS = {
  action: "action"
};

const inputNumberCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host([disabled]){pointer-events:none;cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-ui-opacity-disabled)}:host{display:block}:host([scale=s]) input,:host([scale=s]) .prefix,:host([scale=s]) .suffix{block-size:1.5rem;padding-inline:0.5rem;font-size:var(--calcite-font-size--2);line-height:1rem}:host([scale=s]) .number-button-wrapper,:host([scale=s]) .action-wrapper calcite-button,:host([scale=s]) .action-wrapper calcite-button button{block-size:1.5rem}:host([scale=s]) .clear-button{min-block-size:1.5rem;min-inline-size:1.5rem}:host([scale=m]) input,:host([scale=m]) .prefix,:host([scale=m]) .suffix{block-size:2rem;padding-inline:0.75rem;font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=m]) .number-button-wrapper,:host([scale=m]) .action-wrapper calcite-button,:host([scale=m]) .action-wrapper calcite-button button{block-size:2rem}:host([scale=m]) .clear-button{min-block-size:2rem;min-inline-size:2rem}:host([scale=l]) input,:host([scale=l]) .prefix,:host([scale=l]) .suffix{block-size:2.75rem;padding-inline:1rem;font-size:var(--calcite-font-size-0);line-height:1.25rem}:host([scale=l]) .number-button-wrapper,:host([scale=l]) .action-wrapper calcite-button,:host([scale=l]) .action-wrapper calcite-button button{block-size:2.75rem}:host([scale=l]) .clear-button{min-block-size:2.75rem;min-inline-size:2.75rem}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}:host input{transition:var(--calcite-animation-timing), block-size 0, outline-offset 0s;-webkit-appearance:none;position:relative;margin:0px;box-sizing:border-box;display:flex;max-block-size:100%;inline-size:100%;max-inline-size:100%;flex:1 1 0%;border-radius:0px;background-color:var(--calcite-ui-foreground-1);font-family:inherit;font-weight:var(--calcite-font-weight-normal);border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-input);color:var(--calcite-ui-text-1)}:host input::placeholder,:host input:-ms-input-placeholder,:host input::-ms-input-placeholder{font-weight:var(--calcite-font-weight-normal);color:var(--calcite-ui-text-3)}:host input:focus{border-color:var(--calcite-ui-brand);color:var(--calcite-ui-text-1)}:host input[readonly]{background-color:var(--calcite-ui-background);font-weight:var(--calcite-font-weight-medium)}:host input[readonly]:focus{color:var(--calcite-ui-text-1)}:host calcite-icon{color:var(--calcite-ui-text-3)}:host input{outline-color:transparent}:host input:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:-2px}:host([status=invalid]) input{border-color:var(--calcite-ui-danger)}:host([status=invalid]) input:focus{outline:2px solid var(--calcite-ui-danger);outline-offset:-2px}:host([scale=s]) .icon{inset-inline-start:0.5rem}:host([scale=m]) .icon{inset-inline-start:0.75rem}:host([scale=l]) .icon{inset-inline-start:1rem}:host([icon][scale=s]) input{padding-inline-start:2rem}:host([icon][scale=m]) input{padding-inline-start:2.5rem}:host([icon][scale=l]) input{padding-inline-start:3.5rem}.element-wrapper{position:relative;order:3;display:inline-flex;flex:1 1 0%;align-items:center}.icon{pointer-events:none;position:absolute;z-index:1;display:block;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}.clear-button{pointer-events:initial;order:4;margin:0px;box-sizing:border-box;display:flex;min-block-size:100%;cursor:pointer;align-items:center;justify-content:center;align-self:stretch;border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-input);background-color:var(--calcite-ui-foreground-1);outline-color:transparent;border-inline-start-width:0px}.clear-button:hover{background-color:var(--calcite-ui-foreground-2);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}.clear-button:hover calcite-icon{color:var(--calcite-ui-text-1);transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}.clear-button:active{background-color:var(--calcite-ui-foreground-3)}.clear-button:active calcite-icon{color:var(--calcite-ui-text-1)}.clear-button:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:-2px}.clear-button:disabled{opacity:var(--calcite-ui-opacity-disabled)}.loader{inset-block-start:1px;inset-inline:1px;pointer-events:none;position:absolute;display:block}.action-wrapper{order:7;display:flex}.prefix,.suffix{box-sizing:border-box;display:flex;block-size:auto;min-block-size:100%;-webkit-user-select:none;user-select:none;align-content:center;align-items:center;overflow-wrap:break-word;border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-input);background-color:var(--calcite-ui-background);font-weight:var(--calcite-font-weight-medium);line-height:1;color:var(--calcite-ui-text-2)}.prefix{order:2;border-inline-end-width:0px}.suffix{order:5;border-inline-start-width:0px}:host([alignment=start]) input{text-align:start}:host([alignment=end]) input{text-align:end}.number-button-wrapper{pointer-events:none;order:6;box-sizing:border-box;display:flex;flex-direction:column;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}:host([number-button-type=vertical]) .wrapper{flex-direction:row;display:flex}:host([number-button-type=vertical]) input{order:2}:host([number-button-type=horizontal]) .calcite--rtl .number-button-item[data-adjustment=down] calcite-icon{transform:rotate(-90deg)}:host([number-button-type=horizontal]) .calcite--rtl .number-button-item[data-adjustment=up] calcite-icon{transform:rotate(-90deg)}.number-button-item.number-button-item--horizontal[data-adjustment=down],.number-button-item.number-button-item--horizontal[data-adjustment=up]{order:1;max-block-size:100%;min-block-size:100%;align-self:stretch}.number-button-item.number-button-item--horizontal[data-adjustment=down] calcite-icon,.number-button-item.number-button-item--horizontal[data-adjustment=up] calcite-icon{transform:rotate(90deg)}.number-button-item.number-button-item--horizontal[data-adjustment=down]{border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-input);border-inline-end-width:0px}.number-button-item.number-button-item--horizontal[data-adjustment=down]:hover{background-color:var(--calcite-ui-foreground-2)}.number-button-item.number-button-item--horizontal[data-adjustment=down]:hover calcite-icon{color:var(--calcite-ui-text-1)}.number-button-item.number-button-item--horizontal[data-adjustment=up]{order:5}.number-button-item.number-button-item--horizontal[data-adjustment=up]:hover{background-color:var(--calcite-ui-foreground-2)}.number-button-item.number-button-item--horizontal[data-adjustment=up]:hover calcite-icon{color:var(--calcite-ui-text-1)}:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]:hover{background-color:var(--calcite-ui-foreground-2)}:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]:hover calcite-icon{color:var(--calcite-ui-text-1)}:host([number-button-type=vertical]) .number-button-item[data-adjustment=up]:hover{background-color:var(--calcite-ui-foreground-2)}:host([number-button-type=vertical]) .number-button-item[data-adjustment=up]:hover calcite-icon{color:var(--calcite-ui-text-1)}:host([number-button-type=vertical]) .number-button-item[data-adjustment=down]{border-block-start-width:0px}.number-button-item{max-block-size:50%;min-block-size:50%;pointer-events:initial;margin:0px;box-sizing:border-box;display:flex;cursor:pointer;align-items:center;align-self:center;border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-input);background-color:var(--calcite-ui-foreground-1);padding-block:0px;padding-inline:0.5rem;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s;border-inline-start-width:0px}.number-button-item calcite-icon{pointer-events:none;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}.number-button-item:focus{background-color:var(--calcite-ui-foreground-2)}.number-button-item:focus calcite-icon{color:var(--calcite-ui-text-1)}.number-button-item:active{background-color:var(--calcite-ui-foreground-3)}.number-button-item:disabled{pointer-events:none}.wrapper{position:relative;display:flex;flex-direction:row;align-items:center}:host(.no-bottom-border) input{border-block-end-width:0px}:host(.border-top-color-one) input{border-block-start-color:var(--calcite-ui-border-1)}:host .inline-child{background-color:transparent;transition:all var(--calcite-animation-timing) ease-in-out 0s, outline 0s, outline-offset 0s}:host .inline-child .editing-enabled{background-color:inherit}:host .inline-child:not(.editing-enabled){display:flex;cursor:pointer;border-color:transparent;padding-inline-start:0}::slotted(input[slot=hidden-form-input]){margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}";

const InputNumber = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteInternalInputNumberFocus = createEvent(this, "calciteInternalInputNumberFocus", 6);
    this.calciteInternalInputNumberBlur = createEvent(this, "calciteInternalInputNumberBlur", 6);
    this.calciteInputNumberInput = createEvent(this, "calciteInputNumberInput", 7);
    this.calciteInputNumberChange = createEvent(this, "calciteInputNumberChange", 6);
    this.previousValueOrigin = "initial";
    this.mutationObserver = createObserver("mutation", () => this.setDisabledAction());
    this.userChangedValue = false;
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.keyDownHandler = (event) => {
      if (this.readOnly || this.disabled) {
        return;
      }
      if (this.isClearable && event.key === "Escape") {
        this.clearInputValue(event);
        event.preventDefault();
      }
      if (event.key === "Enter" && !event.defaultPrevented) {
        if (submitForm(this)) {
          event.preventDefault();
        }
      }
    };
    this.clearInputValue = (nativeEvent) => {
      this.setNumberValue({
        committing: true,
        nativeEvent,
        origin: "user",
        value: ""
      });
    };
    this.emitChangeIfUserModified = () => {
      if (this.previousValueOrigin === "user" && this.value !== this.previousEmittedNumberValue) {
        this.calciteInputNumberChange.emit();
        this.setPreviousEmittedNumberValue(this.value);
      }
    };
    this.inputNumberBlurHandler = () => {
      this.calciteInternalInputNumberBlur.emit();
      this.emitChangeIfUserModified();
    };
    this.clickHandler = (event) => {
      const slottedActionEl = getSlotted(this.el, "action");
      if (event.target !== slottedActionEl) {
        this.setFocus();
      }
    };
    this.inputNumberFocusHandler = () => {
      this.calciteInternalInputNumberFocus.emit();
    };
    this.inputNumberInputHandler = (nativeEvent) => {
      if (this.disabled || this.readOnly) {
        return;
      }
      const value = nativeEvent.target.value;
      numberStringFormatter.numberFormatOptions = {
        locale: this.effectiveLocale,
        numberingSystem: this.numberingSystem,
        useGrouping: this.groupSeparator
      };
      const delocalizedValue = numberStringFormatter.delocalize(value);
      if (nativeEvent.inputType === "insertFromPaste") {
        if (!isValidNumber(delocalizedValue)) {
          nativeEvent.preventDefault();
        }
        this.setNumberValue({
          nativeEvent,
          origin: "user",
          value: parseNumberString(delocalizedValue)
        });
        this.childNumberEl.value = this.localizedValue;
      }
      else {
        this.setNumberValue({
          nativeEvent,
          origin: "user",
          value: delocalizedValue
        });
      }
    };
    this.inputNumberKeyDownHandler = (event) => {
      if (this.disabled || this.readOnly) {
        return;
      }
      if (event.key === "ArrowUp") {
        /* prevent default behavior of moving cursor to the beginning of the input when holding down ArrowUp */
        event.preventDefault();
        this.nudgeNumberValue("up", event);
        return;
      }
      if (event.key === "ArrowDown") {
        this.nudgeNumberValue("down", event);
        return;
      }
      const supportedKeys = [
        ...numberKeys,
        "ArrowLeft",
        "ArrowRight",
        "Backspace",
        "Delete",
        "Enter",
        "Escape",
        "Tab"
      ];
      if (event.altKey || event.ctrlKey || event.metaKey) {
        return;
      }
      const isShiftTabEvent = event.shiftKey && event.key === "Tab";
      if (supportedKeys.includes(event.key) && (!event.shiftKey || isShiftTabEvent)) {
        if (event.key === "Enter") {
          this.emitChangeIfUserModified();
        }
        return;
      }
      numberStringFormatter.numberFormatOptions = {
        locale: this.effectiveLocale,
        numberingSystem: this.numberingSystem,
        useGrouping: this.groupSeparator
      };
      if (event.key === numberStringFormatter.decimal) {
        if (!this.value && !this.childNumberEl.value) {
          return;
        }
        if (this.value && this.childNumberEl.value.indexOf(numberStringFormatter.decimal) === -1) {
          return;
        }
      }
      if (/[eE]/.test(event.key)) {
        if (!this.value && !this.childNumberEl.value) {
          return;
        }
        if (this.value && !/[eE]/.test(this.childNumberEl.value)) {
          return;
        }
      }
      if (event.key === "-") {
        if (!this.value && !this.childNumberEl.value) {
          return;
        }
        if (this.value && this.childNumberEl.value.split("-").length <= 2) {
          return;
        }
      }
      event.preventDefault();
    };
    this.nudgeNumberValue = (direction, nativeEvent) => {
      if (nativeEvent instanceof KeyboardEvent && nativeEvent.repeat) {
        return;
      }
      const inputMax = this.maxString ? parseFloat(this.maxString) : null;
      const inputMin = this.minString ? parseFloat(this.minString) : null;
      const valueNudgeDelayInMs = 150;
      this.incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent);
      if (this.nudgeNumberValueIntervalId) {
        window.clearInterval(this.nudgeNumberValueIntervalId);
      }
      let firstValueNudge = true;
      this.nudgeNumberValueIntervalId = window.setInterval(() => {
        if (firstValueNudge) {
          firstValueNudge = false;
          return;
        }
        this.incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent);
      }, valueNudgeDelayInMs);
    };
    this.nudgeButtonPointerUpAndOutHandler = (event) => {
      if (!isPrimaryPointerButton(event)) {
        return;
      }
      window.clearInterval(this.nudgeNumberValueIntervalId);
    };
    this.nudgeButtonPointerDownHandler = (event) => {
      if (!isPrimaryPointerButton(event)) {
        return;
      }
      event.preventDefault();
      const direction = event.target.dataset.adjustment;
      if (!this.disabled) {
        this.nudgeNumberValue(direction, event);
      }
    };
    this.hiddenInputChangeHandler = (event) => {
      if (event.target.name === this.name) {
        this.setNumberValue({
          value: event.target.value,
          origin: "direct"
        });
      }
      event.stopPropagation();
    };
    this.setChildNumberElRef = (el) => {
      this.childNumberEl = el;
    };
    this.setInputNumberValue = (newInputValue) => {
      if (!this.childNumberEl) {
        return;
      }
      this.childNumberEl.value = newInputValue;
    };
    this.setPreviousEmittedNumberValue = (value) => {
      this.previousEmittedNumberValue = this.normalizeValue(value);
    };
    this.setPreviousNumberValue = (value) => {
      this.previousValue = this.normalizeValue(value);
    };
    this.setNumberValue = ({ committing = false, nativeEvent, origin, previousValue, value }) => {
      numberStringFormatter.numberFormatOptions = {
        locale: this.effectiveLocale,
        numberingSystem: this.numberingSystem,
        useGrouping: this.groupSeparator
      };
      const sanitizedValue = sanitizeNumberString(
      // no need to delocalize a string that ia already in latn numerals
      (this.numberingSystem && this.numberingSystem !== "latn") || defaultNumberingSystem !== "latn"
        ? numberStringFormatter.delocalize(value)
        : value);
      const newValue = value && !sanitizedValue
        ? isValidNumber(this.previousValue)
          ? this.previousValue
          : ""
        : sanitizedValue;
      const newLocalizedValue = numberStringFormatter.localize(newValue);
      this.localizedValue = newLocalizedValue;
      this.setPreviousNumberValue(previousValue ?? this.value);
      this.previousValueOrigin = origin;
      this.userChangedValue = origin === "user" && this.value !== newValue;
      // don't sanitize the start of negative/decimal numbers, but
      // don't set value to an invalid number
      this.value = ["-", "."].includes(newValue) ? "" : newValue;
      if (origin === "direct") {
        this.setInputNumberValue(newLocalizedValue);
        this.setPreviousEmittedNumberValue(newLocalizedValue);
      }
      if (nativeEvent) {
        const calciteInputNumberInputEvent = this.calciteInputNumberInput.emit();
        if (calciteInputNumberInputEvent.defaultPrevented) {
          this.value = this.previousValue;
          this.localizedValue = numberStringFormatter.localize(this.previousValue);
        }
        else if (committing) {
          this.emitChangeIfUserModified();
        }
      }
    };
    this.inputNumberKeyUpHandler = () => {
      window.clearInterval(this.nudgeNumberValueIntervalId);
    };
    this.alignment = "start";
    this.autofocus = false;
    this.clearable = false;
    this.disabled = false;
    this.groupSeparator = false;
    this.hidden = false;
    this.icon = undefined;
    this.iconFlipRtl = false;
    this.label = undefined;
    this.loading = false;
    this.numberingSystem = undefined;
    this.localeFormat = false;
    this.max = undefined;
    this.min = undefined;
    this.maxLength = undefined;
    this.minLength = undefined;
    this.name = undefined;
    this.numberButtonType = "vertical";
    this.placeholder = undefined;
    this.prefixText = undefined;
    this.readOnly = false;
    this.required = false;
    this.scale = "m";
    this.status = "idle";
    this.step = undefined;
    this.autocomplete = undefined;
    this.inputMode = "decimal";
    this.enterKeyHint = undefined;
    this.suffixText = undefined;
    this.editingEnabled = false;
    this.value = "";
    this.messages = undefined;
    this.messageOverrides = undefined;
    this.effectiveLocale = "";
    this.defaultMessages = undefined;
    this.localizedValue = undefined;
    this.slottedActionElDisabledInternally = false;
  }
  disabledWatcher() {
    this.setDisabledAction();
  }
  /** watcher to update number-to-string for max */
  maxWatcher() {
    this.maxString = this.max?.toString() || null;
  }
  /** watcher to update number-to-string for min */
  minWatcher() {
    this.minString = this.min?.toString() || null;
  }
  onMessagesChange() {
    /* wired up by t9n util */
  }
  valueWatcher(newValue, previousValue) {
    if (!this.userChangedValue) {
      this.setNumberValue({
        origin: "direct",
        previousValue,
        value: newValue == null || newValue == ""
          ? ""
          : isValidNumber(newValue)
            ? newValue
            : this.previousValue || ""
      });
      this.warnAboutInvalidNumberValue(newValue);
    }
    this.userChangedValue = false;
  }
  updateRequestedIcon() {
    this.requestedIcon = setRequestedIcon({}, this.icon, "number");
  }
  get isClearable() {
    return this.clearable && this.value.length > 0;
  }
  effectiveLocaleWatcher(locale) {
    updateMessages(this, this.effectiveLocale);
    numberStringFormatter.numberFormatOptions = {
      locale,
      numberingSystem: this.numberingSystem,
      useGrouping: false
    };
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    connectLocalized(this);
    connectMessages(this);
    this.scale = getElementProp(this.el, "scale", this.scale);
    this.inlineEditableEl = this.el.closest("calcite-inline-editable");
    if (this.inlineEditableEl) {
      this.editingEnabled = this.inlineEditableEl.editingEnabled || false;
    }
    connectLabel(this);
    connectForm(this);
    this.setPreviousEmittedNumberValue(this.value);
    this.setPreviousNumberValue(this.value);
    this.warnAboutInvalidNumberValue(this.value);
    this.setNumberValue({
      origin: "connected",
      value: isValidNumber(this.value) ? this.value : ""
    });
    this.mutationObserver?.observe(this.el, { childList: true });
    this.setDisabledAction();
    this.el.addEventListener("calciteInternalHiddenInputChange", this.hiddenInputChangeHandler);
  }
  componentDidLoad() {
    setComponentLoaded(this);
  }
  disconnectedCallback() {
    disconnectLabel(this);
    disconnectForm(this);
    disconnectLocalized(this);
    disconnectMessages(this);
    this.mutationObserver?.disconnect();
    this.el.removeEventListener("calciteInternalHiddenInputChange", this.hiddenInputChangeHandler);
  }
  async componentWillLoad() {
    setUpLoadableComponent(this);
    this.maxString = this.max?.toString();
    this.minString = this.min?.toString();
    this.requestedIcon = setRequestedIcon({}, this.icon, "number");
    await setUpMessages(this);
  }
  componentShouldUpdate(newValue, oldValue, property) {
    if (property === "value" && newValue && !isValidNumber(newValue)) {
      this.setNumberValue({
        origin: "reset",
        value: oldValue
      });
      return false;
    }
    return true;
  }
  componentDidRender() {
    updateHostInteraction(this);
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /** Sets focus on the component. */
  async setFocus() {
    await componentLoaded(this);
    this.childNumberEl?.focus();
  }
  /** Selects all text of the component's `value`. */
  async selectText() {
    this.childNumberEl?.select();
  }
  onLabelClick() {
    this.setFocus();
  }
  incrementOrDecrementNumberValue(direction, inputMax, inputMin, nativeEvent) {
    const { value } = this;
    const inputStep = this.step === "any" ? 1 : Math.abs(this.step || 1);
    const inputVal = value && value !== "" ? parseFloat(value) : 0;
    const adjustment = direction === "up" ? 1 : -1;
    const nudgedValue = inputVal + inputStep * adjustment;
    const finalValue = typeof inputMin === "number" && !isNaN(inputMin) && nudgedValue < inputMin
      ? inputMin
      : typeof inputMax === "number" && !isNaN(inputMax) && nudgedValue > inputMax
        ? inputMax
        : nudgedValue;
    const inputValPlaces = decimalPlaces(inputVal);
    const inputStepPlaces = decimalPlaces(inputStep);
    this.setNumberValue({
      committing: true,
      nativeEvent,
      origin: "user",
      value: finalValue.toFixed(Math.max(inputValPlaces, inputStepPlaces))
    });
  }
  onFormReset() {
    this.setNumberValue({
      origin: "reset",
      value: this.defaultValue
    });
  }
  syncHiddenFormInput(input) {
    input.type = "number";
    input.min = this.min?.toString(10) ?? "";
    input.max = this.max?.toString(10) ?? "";
  }
  setDisabledAction() {
    const slottedActionEl = getSlotted(this.el, "action");
    if (!slottedActionEl) {
      return;
    }
    if (this.disabled) {
      if (slottedActionEl.getAttribute("disabled") == null) {
        this.slottedActionElDisabledInternally = true;
      }
      slottedActionEl.setAttribute("disabled", "");
    }
    else if (this.slottedActionElDisabledInternally) {
      slottedActionEl.removeAttribute("disabled");
      this.slottedActionElDisabledInternally = false;
    }
  }
  normalizeValue(value) {
    return isValidNumber(value) ? value : "";
  }
  warnAboutInvalidNumberValue(value) {
    if (value && !isValidNumber(value)) {
      console.warn(`The specified value "${value}" cannot be parsed, or is out of range.`);
    }
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  // --------------------------------------------------------------------------
  render() {
    const dir = getElementDir(this.el);
    const loader = (h("div", { class: CSS.loader }, h("calcite-progress", { label: this.messages.loading, type: "indeterminate" })));
    const inputClearButton = (h("button", { "aria-label": this.messages.clear, class: CSS.clearButton, disabled: this.disabled || this.readOnly, onClick: this.clearInputValue, tabIndex: -1, type: "button" }, h("calcite-icon", { icon: "x", scale: this.scale === "l" ? "m" : "s" })));
    const iconEl = (h("calcite-icon", { class: CSS.inputIcon, flipRtl: this.iconFlipRtl, icon: this.requestedIcon, scale: this.scale === "l" ? "m" : "s" }));
    const isHorizontalNumberButton = this.numberButtonType === "horizontal";
    const numberButtonsHorizontalUp = (h("button", { "aria-hidden": "true", class: {
        [CSS.numberButtonItem]: true,
        [CSS.buttonItemHorizontal]: isHorizontalNumberButton
      }, "data-adjustment": "up", disabled: this.disabled || this.readOnly, onPointerDown: this.nudgeButtonPointerDownHandler, onPointerOut: this.nudgeButtonPointerUpAndOutHandler, onPointerUp: this.nudgeButtonPointerUpAndOutHandler, tabIndex: -1, type: "button" }, h("calcite-icon", { icon: "chevron-up", scale: this.scale === "l" ? "m" : "s" })));
    const numberButtonsHorizontalDown = (h("button", { "aria-hidden": "true", class: {
        [CSS.numberButtonItem]: true,
        [CSS.buttonItemHorizontal]: isHorizontalNumberButton
      }, "data-adjustment": "down", disabled: this.disabled || this.readOnly, onPointerDown: this.nudgeButtonPointerDownHandler, onPointerOut: this.nudgeButtonPointerUpAndOutHandler, onPointerUp: this.nudgeButtonPointerUpAndOutHandler, tabIndex: -1, type: "button" }, h("calcite-icon", { icon: "chevron-down", scale: this.scale === "l" ? "m" : "s" })));
    const numberButtonsVertical = (h("div", { class: CSS.numberButtonWrapper }, numberButtonsHorizontalUp, numberButtonsHorizontalDown));
    const prefixText = h("div", { class: CSS.prefix }, this.prefixText);
    const suffixText = h("div", { class: CSS.suffix }, this.suffixText);
    const childEl = (h("input", { "aria-label": getLabelText(this), autocomplete: this.autocomplete, autofocus: this.autofocus ? true : null, defaultValue: this.defaultValue, disabled: this.disabled ? true : null, enterKeyHint: this.enterKeyHint, inputMode: this.inputMode, key: "localized-input", maxLength: this.maxLength, minLength: this.minLength, name: undefined, onBlur: this.inputNumberBlurHandler, onFocus: this.inputNumberFocusHandler, onInput: this.inputNumberInputHandler, onKeyDown: this.inputNumberKeyDownHandler, onKeyUp: this.inputNumberKeyUpHandler, placeholder: this.placeholder || "", readOnly: this.readOnly, ref: this.setChildNumberElRef, type: "text", value: this.localizedValue }));
    return (h(Host, { onClick: this.clickHandler, onKeyDown: this.keyDownHandler }, h("div", { class: { [CSS.inputWrapper]: true, [CSS_UTILITY.rtl]: dir === "rtl" } }, this.numberButtonType === "horizontal" && !this.readOnly
      ? numberButtonsHorizontalDown
      : null, this.prefixText ? prefixText : null, h("div", { class: CSS.wrapper }, childEl, this.isClearable ? inputClearButton : null, this.requestedIcon ? iconEl : null, this.loading ? loader : null), h("div", { class: CSS.actionWrapper }, h("slot", { name: SLOTS.action })), this.numberButtonType === "vertical" && !this.readOnly ? numberButtonsVertical : null, this.suffixText ? suffixText : null, this.numberButtonType === "horizontal" && !this.readOnly
      ? numberButtonsHorizontalUp
      : null, h(HiddenFormInputSlot, { component: this }))));
  }
  static get assetsDirs() { return ["assets"]; }
  get el() { return this; }
  static get watchers() { return {
    "disabled": ["disabledWatcher"],
    "max": ["maxWatcher"],
    "min": ["minWatcher"],
    "messageOverrides": ["onMessagesChange"],
    "value": ["valueWatcher"],
    "icon": ["updateRequestedIcon"],
    "effectiveLocale": ["effectiveLocaleWatcher"]
  }; }
  static get style() { return inputNumberCss; }
}, [1, "calcite-input-number", {
    "alignment": [513],
    "autofocus": [516],
    "clearable": [516],
    "disabled": [516],
    "groupSeparator": [516, "group-separator"],
    "hidden": [516],
    "icon": [520],
    "iconFlipRtl": [516, "icon-flip-rtl"],
    "label": [1],
    "loading": [516],
    "numberingSystem": [513, "numbering-system"],
    "localeFormat": [4, "locale-format"],
    "max": [514],
    "min": [514],
    "maxLength": [514, "max-length"],
    "minLength": [514, "min-length"],
    "name": [513],
    "numberButtonType": [513, "number-button-type"],
    "placeholder": [1],
    "prefixText": [1, "prefix-text"],
    "readOnly": [516, "read-only"],
    "required": [516],
    "scale": [1537],
    "status": [1537],
    "step": [520],
    "autocomplete": [1],
    "inputMode": [1, "input-mode"],
    "enterKeyHint": [1, "enter-key-hint"],
    "suffixText": [1, "suffix-text"],
    "editingEnabled": [1540, "editing-enabled"],
    "value": [1025],
    "messages": [1040],
    "messageOverrides": [1040],
    "effectiveLocale": [32],
    "defaultMessages": [32],
    "localizedValue": [32],
    "slottedActionElDisabledInternally": [32],
    "setFocus": [64],
    "selectText": [64]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-input-number", "calcite-icon", "calcite-progress"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-input-number":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, InputNumber);
      }
      break;
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$8();
      }
      break;
    case "calcite-progress":
      if (!customElements.get(tagName)) {
        defineCustomElement();
      }
      break;
  } });
}
defineCustomElement$1();

const buffersStepCss = ":host{display:block}.flex-grid{display:flex}.flex-grid .col{flex:1;padding-inline:unset}.flex-grid-fifths{display:flex;max-width:400px;min-width:275px}.flex-grid-fifths .col{padding:0 3px;box-sizing:border-box}.flex-grid-fifths .col:first-child{flex-grow:0}.flex-grid-fifths .col:not(:first-child){flex-grow:1;width:0}.flex-grid-fifths .col:nth-child(5){min-width:110px;width:110px}@media (max-width: 400px){.flex-grid,.flex-grid-fifths{display:block}.flex-grid .col,.flex-grid-fifths .col{width:100%;margin:0 0 5px 0;padding:0}}.arcgisBuffersStepDescription{margin-bottom:8px}";

const BuffersStep = class {
  constructor(hostRef) {
    (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.bufferTypeChanged = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "bufferTypeChanged", 7);
    this.bufferValsChanged = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "bufferValsChanged", 7);
    this.bufferUnitChanged = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "bufferUnitChanged", 7);
    this._idPrefix = 'buffers-step-';
    this._dbg = false;
    this.currentBufferType = BufferTypesValues.ring;
    this.bufferData = {
      [BufferTypesValues.ring]: { bufferVals: [1, 3, 5], bufferUnit: 'miles' },
      [BufferTypesValues.drivetime]: { bufferVals: [5, 10, 15], bufferUnit: 'minutes' },
      [BufferTypesValues.walktime]: { bufferVals: [5, 10, 15], bufferUnit: 'minutes' }
    };
    this.baseConfig = new _base_util_b7db69f0_js__WEBPACK_IMPORTED_MODULE_1__.B('buffers-step', this, this.onUpdateUI);
  }
  //
  // Update Props/States when the main config changes
  onConfigChange(newConfig, oldConfig) {
    if (!newConfig || typeof newConfig != 'string') {
      return;
    }
    if (_ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(newConfig)) {
      const newCfg = JSON.parse(newConfig);
      const oldCfg = (oldConfig && _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(oldConfig)) ? JSON.parse(oldConfig) : null;
      //
      // COLORS:
      // define a temp color object so that we update the 'colors' Prop one time
      this.baseConfig.updateConfig(newCfg, oldCfg);
      if (!oldCfg || this._isBufferDataChanged(newCfg, oldCfg)) {
        this._setBufferDataFromConfig();
      }
    }
  }
  onThemeChanged() {
    this.stTheme = this.theme;
    this.baseConfig.setTheme(this.theme);
  }
  onBufferTypeChange() {
    this.minBuffer = this.getMinBuffer();
    this.maxBuffer = this.getMaxBuffer();
  }
  setLocaleStrings() {
    // TODO: initialize locale strings for this component
  }
  _loadInstances() {
    if (!this._instanceId)
      this._instanceId = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.E.generateId(this._idPrefix).id;
  }
  _isBufferDataChanged(newCfg, oldCfg) {
    // Rings
    if (newCfg.workflowRingsBuffer1 !== oldCfg.workflowRingsBuffer1 ||
      newCfg.workflowRingsBuffer2 !== oldCfg.workflowRingsBuffer2 ||
      newCfg.workflowRingsBuffer3 !== oldCfg.workflowRingsBuffer3 ||
      newCfg.workflowRingsBufferUnit !== oldCfg.workflowRingsBufferUnit ||
      newCfg.workflowAvailableBufferRings !== oldCfg.workflowAvailableBufferRings) {
      return true;
    }
    // Drivetime
    if (newCfg.workflowDrivetimeBuffer1 !== oldCfg.workflowDrivetimeBuffer1 ||
      newCfg.workflowDrivetimeBuffer2 !== oldCfg.workflowDrivetimeBuffer2 ||
      newCfg.workflowDrivetimeBuffer3 !== oldCfg.workflowDrivetimeBuffer3 ||
      newCfg.workflowDrivetimeBufferUnit !== oldCfg.workflowDrivetimeBufferUnit ||
      newCfg.workflowAvailableBufferDrivetime !== oldCfg.workflowAvailableBufferDrivetime) {
      return true;
    }
    // Walktime
    if (newCfg.workflowWalktimeBuffer1 !== oldCfg.workflowWalktimeBuffer1 ||
      newCfg.workflowWalktimeBuffer2 !== oldCfg.workflowWalktimeBuffer2 ||
      newCfg.workflowWalktimeBuffer3 !== oldCfg.workflowWalktimeBuffer3 ||
      newCfg.workflowWalktimeBufferUnit !== oldCfg.workflowWalktimeBufferUnit ||
      newCfg.workflowAvailableBufferWalktime !== oldCfg.workflowAvailableBufferWalktime) {
      return true;
    }
    return false;
  }
  _setBufferDataFromConfig() {
    const cfg = this.baseConfig.config;
    this.bufferData[BufferTypesValues.ring] = { bufferVals: [cfg.workflowRingsBuffer1, cfg.workflowRingsBuffer2, cfg.workflowRingsBuffer3], bufferUnit: cfg.workflowRingsBufferUnit };
    this.bufferData[BufferTypesValues.drivetime] = { bufferVals: [cfg.workflowDrivetimeBuffer1, cfg.workflowDrivetimeBuffer2, cfg.workflowDrivetimeBuffer3], bufferUnit: cfg.workflowDrivetimeBufferUnit };
    this.bufferData[BufferTypesValues.walktime] = { bufferVals: [cfg.workflowWalktimeBuffer1, cfg.workflowWalktimeBuffer2, cfg.workflowWalktimeBuffer3], bufferUnit: cfg.workflowWalktimeBufferUnit };
    // Handle current buffer type not available
    if (this.currentBufferType === BufferTypesValues.ring && !cfg.workflowAvailableBufferRings) {
      if (cfg.workflowAvailableBufferDrivetime) {
        this.currentBufferType = BufferTypesValues.drivetime;
      }
      else {
        this.currentBufferType = BufferTypesValues.walktime;
      }
    }
    else if (this.currentBufferType === BufferTypesValues.drivetime && !cfg.workflowAvailableBufferDrivetime) {
      if (cfg.workflowAvailableBufferRings) {
        this.currentBufferType = BufferTypesValues.ring;
      }
      else {
        this.currentBufferType = BufferTypesValues.walktime;
      }
    }
    else if (this.currentBufferType === BufferTypesValues.walktime && !cfg.workflowAvailableBufferWalktime) {
      if (cfg.workflowAvailableBufferRings) {
        this.currentBufferType = BufferTypesValues.ring;
      }
      else {
        this.currentBufferType = BufferTypesValues.drivetime;
      }
    }
    this.bufferTypeChanged.emit(this.currentBufferType);
    this.bufferValsChanged.emit(this.bufferData[this.currentBufferType].bufferVals);
    this.bufferUnitChanged.emit(this.bufferData[this.currentBufferType].bufferUnit);
  }
  onUpdateUI() {
    this.applyStyles();
  }
  applyStyles() {
    if (this.baseConfig?.config?.colors && Object.keys(this.baseConfig.config.colors).length > 0) {
      const c = this.baseConfig.config.colors;
      const calciteTabsOuter = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.queryElement.call(this.el, 'calcite-tabs');
      if (calciteTabsOuter && 'style' in calciteTabsOuter) {
        calciteTabsOuter.style.setProperty("--calcite-ui-border-input", 'unset');
        calciteTabsOuter.style.setProperty("--calcite-ui-foreground-1", c.foreground);
        calciteTabsOuter.style.setProperty("--calcite-ui-brand", c.brand);
        // const calciteTabs = ACLUtils.queryElement.call(this.el, 'calcite-tabs');
        // console.log('calciteTabs',calciteTabs)
        // if (calciteTabs){
        // console.log(calciteTabsOuter)
        // calciteTabsOuter.querySelectorAll("calcite-tab").forEach(tab => {
        //   if (tab.shadowRoot) {
        //     const bufferRow = tab.shadowRoot.querySelector("div.flex-grid-fifths");
        //     if (bufferRow) {
        //       const calciteSelect = bufferRow.querySelector("calcite-select");
        //       if (calciteSelect.shadowRoot){
        //         const select =  calciteSelect.shadowRoot.querySelector("calcite-select")
        //         if (select && 'style' in select) {
        //           (select as HTMLElement).style.setProperty("background-color", 'transparent');
        //           (select as HTMLElement).style.setProperty("border", 'none');
        //           (select as HTMLElement).style.setProperty("padding", '0px');
        //           (select as HTMLElement).style.setProperty("margin", '0px');
        //         }
        //       }
        //     }
        //   }
        // })
        //}
      }
    }
  }
  async componentWillLoad() {
    if (this.config) {
      this.onConfigChange(this.config, '');
    }
    if (this.theme) {
      this.baseConfig.setTheme(this.theme);
    }
    else {
      this.baseConfig.setTheme('light');
    }
    this.minBuffer = this.getMinBuffer();
    this.maxBuffer = this.getMaxBuffer();
    this._loadInstances();
  }
  // Stencil lifecycle - called just after component updates, but not called during first render()
  componentDidUpdate() {
    if (this.baseConfig) {
      this.baseConfig.onComponentHasRendered();
    }
  }
  // Stencil lifecycle - called once after component is fully loaded and 1st render occurred
  componentDidLoad() {
    this._loadInstances();
    if (this.baseConfig) {
      this.baseConfig.onComponentHasRendered();
    }
  }
  cleanArray(inputArr) {
    let outputArray = [];
    for (let i = 0; i < inputArr.length; i++) {
      if (!isNaN(inputArr[i])) {
        outputArray.push(inputArr[i]);
      }
    }
    return outputArray;
  }
  handleBufferValsChange(index, value) {
    const { bufferData, currentBufferType, minBuffer } = this;
    const bufferVals = bufferData[currentBufferType].bufferVals;
    if (this._dbg) {
      console.log('buffers-step data, vals', bufferData, bufferVals);
    }
    const numNullValues = bufferVals.reduce((count, val) => {
      return isNaN(val) ? count + 1 : count;
    }, 0);
    if (this._dbg) {
      console.log('buffers-step  null values', numNullValues);
    }
    if (value !== null) {
      bufferVals[index] = value;
    }
    if (numNullValues === 3) {
      bufferVals[0] = minBuffer;
    }
    this.bufferValsChanged.emit(this.cleanArray(bufferVals));
  }
  handleBufferUnitChange(value) {
    this.bufferData[this.currentBufferType].bufferUnit = value;
    this.bufferUnitChanged.emit(value);
    // Update maxBuffer based on the current buffer type and unit
    this.maxBuffer = this.getMaxBuffer();
    if (this._dbg) {
      console.log('buffers-step  maxBuffer', this.maxBuffer);
    }
    // const calciteTabs = ACLUtils.queryElement.call(this, 'calcite-tabs');
    // if (calciteTabs){
    //   const tabsShadowRoot = calciteTabs.shadowRoot;
    //   tabsShadowRoot.forEach((calciteTab) => {
    //     const tabShadowRoot = calciteTab.shadowRoot;
    //     if (tabShadowRoot) {
    //       const inputElements = tabShadowRoot.querySelectorAll('calcite-input-number');
    //       inputElements.forEach((inputElement: any) => {
    //         const currentValue = parseFloat(inputElement.value);
    //         if (!isNaN(currentValue) && currentValue > this.maxBuffer) {
    //           inputElement.value = this.maxBuffer.toString();
    //         }
    //       });
    //     }
    //   });
    // }
  }
  handleTabClick(bufferType) {
    this.currentBufferType = bufferType;
    this.bufferTypeChanged.emit(bufferType);
    this.bufferValsChanged.emit(this.bufferData[bufferType].bufferVals);
    this.bufferUnitChanged.emit(this.bufferData[bufferType].bufferUnit);
  }
  getMaxBuffer() {
    const { bufferData, currentBufferType } = this;
    const bufferUnit = bufferData[currentBufferType]?.bufferUnit;
    switch (currentBufferType) {
      case BufferTypesValues.ring:
        return MaxBuffers.Rings;
      case BufferTypesValues.drivetime:
        if (bufferUnit === BufferUnitsValues.minutes) {
          return MaxBuffers.DriveMinutes;
        }
        else if (bufferUnit === BufferUnitsValues.miles) {
          return MaxBuffers.DriveMile;
        }
        else if (bufferUnit === BufferUnitsValues.kilometers) {
          return MaxBuffers.DriveKm;
        }
        break;
      case BufferTypesValues.walktime:
        if (bufferUnit === BufferUnitsValues.minutes) {
          return MaxBuffers.WalkMinutes;
        }
        else if (bufferUnit === BufferUnitsValues.miles) {
          return MaxBuffers.WalkMile;
        }
        else if (bufferUnit === BufferUnitsValues.kilometers) {
          return MaxBuffers.WalkKm;
        }
        break;
      default:
        return 300;
    }
    return 300;
  }
  getMinBuffer() {
    switch (this.currentBufferType) {
      case BufferTypesValues.ring:
        return MinBuffers.Rings;
      case BufferTypesValues.drivetime:
        return MinBuffers.Drive;
      case BufferTypesValues.walktime:
        return MinBuffers.Walk;
      default:
        return 1;
    }
  }
  enforceMinMaxValues(e, min, max, index) {
    let value = parseFloat(e.target.value);
    if (!isNaN(value)) {
      if (value < min) {
        value = min; // Enforce the minimum value
      }
      else if (value > max) {
        value = max; // Enforce the maximum value
      }
    }
    e.target.value = value;
    this.handleBufferValsChange(index, value);
  }
  getCalciteTab(bufferType, bufferLabel, tab) {
    _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B._initialize(this.langCode);
    return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'flex-grid-fifths' }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'col', style: { display: 'flex', alignItems: 'center' } }, bufferLabel), Array(3).fill(null).map((_, i) => {
      const bufferVal = this.maxBuffer < this.bufferData[tab].bufferVals[i] ? this.maxBuffer : !isNaN(this.bufferData[tab].bufferVals[i]) ? this.bufferData[tab].bufferVals[i] : null;
      return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "col" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-number", { numberButtonType: "none", max: this.maxBuffer, min: this.minBuffer, value: bufferVal, onInput: (event) => {
          const target = event.target;
          const value = parseFloat(target.value);
          if (value >= this.minBuffer && value <= this.maxBuffer) {
            this.handleBufferValsChange(i, value);
          }
        }, onBlur: (e) => {
          const target = e.target;
          const value = parseFloat(target.value);
          const { bufferData, currentBufferType, minBuffer } = this;
          const bufferVals = bufferData[currentBufferType].bufferVals;
          // Check if two values in bufferVals are NaN
          const numNaN = bufferVals.filter(val => isNaN(val)).length;
          if (isNaN(value) && numNaN === 2) {
            // If two values in bufferVals are NaN and target.value is NaN, set bufferVals[0] to minBuffer
            bufferVals[0] = minBuffer;
          }
          // Ensure the minimum value is enforced for the current field
          this.enforceMinMaxValues(e, this.minBuffer, this.maxBuffer, i);
        } })));
    }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "col" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { onCalciteSelectChange: (event) => {
        const target = event.target;
        const value = target.value;
        this.handleBufferUnitChange(value);
      } }, bufferType === 'time' && ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: "minutes", selected: this.bufferData[tab].bufferUnit === 'minutes' }, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('minutes'))), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: "miles", selected: this.bufferData[tab].bufferUnit === 'miles' }, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('milesLowercase')), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: "kilometers", selected: this.bufferData[tab].bufferUnit === 'kilometers' }, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('kilometerAbbreviation'))))));
  }
  render() {
    const introText = (this.baseConfig.config) ? this.baseConfig.config.workflowIntroTextBuffers : ''; // const {workflowIntroTextBuffers} = this._base.config;
    const activeTab = this.baseConfig.config.workflowAvailableBufferRings ? "rings" : this.baseConfig.config.workflowAvailableBufferDrivetime ? "dt" : "wt";
    _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B._initialize(this.langCode);
    return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'flex-grid' }, this.baseConfig.config.workflowIntroTextBuffersCheckbox &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "arcgisBuffersStepDescription" }, introText)), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'flex-grid' }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "col" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tabs", null, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab-nav", { slot: "title-group" }, this.baseConfig.config.workflowAvailableBufferRings &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab-title", { active: activeTab === "rings", onClick: () => this.handleTabClick(BufferTypesValues.ring) }, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('rings')), this.baseConfig.config.workflowAvailableBufferDrivetime &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab-title", { active: activeTab === "dt", onClick: () => this.handleTabClick(BufferTypesValues.drivetime) }, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('drivetime')), this.baseConfig.config.workflowAvailableBufferWalktime &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab-title", { active: activeTab === "wt", onClick: () => this.handleTabClick(BufferTypesValues.walktime) }, _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('walktime'))), this.baseConfig.config.workflowAvailableBufferRings &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab", { active: activeTab === "rings", selected: activeTab === "rings" }, this.getCalciteTab('radius', _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('radius'), BufferTypesValues.ring)), this.baseConfig.config.workflowAvailableBufferDrivetime &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab", { active: activeTab === "dt", selected: activeTab === "dt" }, this.getCalciteTab('time', _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('time'), BufferTypesValues.drivetime)), this.baseConfig.config.workflowAvailableBufferWalktime &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tab", { active: activeTab === "wt", selected: activeTab === "wt" }, this.getCalciteTab('time', _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.B.i18n('time'), BufferTypesValues.walktime)))))));
  }
  get el() { return (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
  static get watchers() { return {
    "config": ["onConfigChange"],
    "theme": ["onThemeChanged"],
    "currentBufferType": ["onBufferTypeChange"]
  }; }
};
BuffersStep.style = buffersStepCss;

const infographicsStepCss = ":host{display:block}.flex-grid{display:flex}.flex-grid .col{flex:1}.wf-infographic-selector{position:relative;width:calc(100% - 10px);height:40px}.arcgisInfographicsStepDescription{margin-bottom:8px}";

const InfographicsStep = class {
  constructor(hostRef) {
    (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this._idPrefix = 'infographics-step-';
    this._idPrefixReports = 'infographics-step-comp-';
    this._idPrefixReportsCont = 'infographics-report-cont-';
    this.baseConfig = new _base_util_b7db69f0_js__WEBPACK_IMPORTED_MODULE_1__.B('infographics-step', this, this.onUpdateUI);
  }
  //
  // Update Props/States when the main config changes
  onConfigChange(newConfig, oldConfig) {
    if (!newConfig || typeof newConfig != 'string') {
      return;
    }
    if (_ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(newConfig)) {
      const newCfg = JSON.parse(newConfig);
      const oldCfg = (oldConfig && _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.hasText(oldConfig)) ? JSON.parse(oldConfig) : null;
      //
      // COLORS:
      // define a temp color object so that we update the 'colors' Prop one time
      this.baseConfig.updateConfig(newCfg, oldCfg);
    }
  }
  onThemeChanged() {
    this.stTheme = this.theme;
    this.baseConfig.setTheme(this.theme);
  }
  setLocaleStrings() {
    // TODO: initialize locale strings for this component
  }
  _loadInstances() {
    if (!this._instanceId)
      this._instanceId = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.E.generateId(this._idPrefix).id;
    if (!this._reportsId)
      this._reportsId = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.E.generateId(this._idPrefixReports).id;
    if (!this._reportsContId)
      this._reportsContId = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.E.generateId(this._idPrefixReportsCont).id;
  }
  onUpdateUI() {
    this.applyStyles();
  }
  applyStyles() {
    if (this.baseConfig?.config?.colors && Object.keys(this.baseConfig.config.colors).length > 0) {
      const c = this.baseConfig.config.colors;
      const infographicSelector = _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_2__.A.queryElement.call(this.el, 'arcgis-infographic-selector');
      if (infographicSelector && infographicSelector.shadowRoot) {
        const selector = infographicSelector.shadowRoot.querySelector("div.infographicSelectorOuter");
        if (selector && 'style' in selector) {
          selector.style.setProperty("background-color", c.foreground);
          selector.style.setProperty("border", 'solid 1px ' + c.border);
          const popover = infographicSelector.shadowRoot.querySelector("calcite-popover");
          if (popover && 'style' in popover) {
            popover.style.setProperty("--calcite-ui-border-input", 'unset');
            popover.style.setProperty("--calcite-ui-foreground-1", c.foreground);
            popover.style.setProperty("--calcite-ui-brand", c.brand);
          }
        }
      }
    }
  }
  async componentWillLoad() {
    // console.log('%c infographics-step willLoad', 'font-size:8pt;color:orange;')
    if (this.config && typeof this.config == 'string') {
      this.onConfigChange(this.config, '');
    }
    // if (this.theme) {
    //   this.baseConfig.setTheme(this.theme)
    // } else {
    //   this.baseConfig.setTheme('light')
    // }
    this._loadInstances();
  }
  // Stencil lifecycle - called once after component is fully loaded and 1st render occurred
  componentDidLoad() {
    // console.log('%c infographics-step didUpdate', 'font-size:8pt;color:orange;')
    this._loadInstances();
    // const { username, token, env, sourceCountry, langCode, reportList } = this.configObj;
    const reportsElem = (this._reportsId) ? this.el.shadowRoot?.querySelector(`#${this._reportsId}`) : null;
    if (reportsElem) {
      const b = this.baseConfig.config;
      // @ts-expect-error
      reportsElem.initialize(b.username, b.token, b.env, b.sourceCountry, b.langCode, JSON.stringify(b.reportList));
    }
    if (this.baseConfig) {
      this.baseConfig.onComponentHasRendered();
    }
  }
  // Stencil lifecycle - called just after component updates, but not called during first render()
  componentDidUpdate() {
    if (this.baseConfig) {
      this.baseConfig.onComponentHasRendered();
    }
  }
  render() {
    const user = this.baseConfig.config.username;
    const env = this.baseConfig.config.env;
    const token = this.baseConfig.config.token;
    const gUrl = this.baseConfig.config.geoenrichmentUrl;
    const country = this.baseConfig.config.selectedCountry;
    const reports = this.baseConfig.config.reportList;
    const lang = this.baseConfig.config.langCode;
    const introTextChk = this.baseConfig.config.workflowIntroTextReportCheckbox;
    const introTextRep = this.baseConfig.config.workflowIntroTextReports;
    const cfg = {
      env: env,
      username: user,
      token: token,
      geoenrichmentUrl: gUrl,
      sourceCountry: country,
      langCode: lang,
      selectedReportId: this.selectedReport,
      reportList: JSON.stringify(reports),
      _parentConfigId: this.baseConfig.configInstanceId
    };
    const sCfg = JSON.stringify(cfg);
    return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'flex-grid' }, introTextChk &&
      (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'arcgisInfographicsStepDescription' }, introTextRep)), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'flex-grid' }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: 'col', id: this._reportsContId }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "tree-container" }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-infographic-selector", { id: this._reportsId, portalOnlineGEProxy: this.portalOnlineGEProxy, config: sCfg, class: "wf-infographic-selector" }))))));
  }
  get el() { return (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
  static get watchers() { return {
    "config": ["onConfigChange"],
    "theme": ["onThemeChanged"]
  }; }
};
InfographicsStep.style = infographicsStepCss;



//# sourceMappingURL=infographics-step-9e7ffb8d.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLTBhYTQwMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBJO0FBQ2xHO0FBQ2dCO0FBQzBDO0FBQ25EOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFdBQVcsaURBQVMsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZPQUtQLEdBQUcsRUFBRSxTQUFTLFVBQWUsQ0FBQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSztBQUM5QyxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsY0FBYywyQkFBMkIsRUFBRSxTQUFTLEVBQUUsc0NBQXNDO0FBQzVGO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLHVDQUF1QywrQ0FBK0M7QUFDdEY7QUFDQSxtQkFBbUIsMkNBQTJDO0FBQzlELHdEQUF3RCwrQkFBK0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxpQ0FBaUMsMkNBQTJDLEVBQUUsbURBQW1EO0FBQ2pJO0FBQ0EsV0FBVyxrQkFBa0IsRUFBRTtBQUMvQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsY0FBYyxrQkFBa0IsRUFBRSxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixrRUFBa0U7QUFDbEU7QUFDQSx5RkFBeUYsZUFBZTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxTQUFTLEdBQUcscUJBQXFCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QU8saURBQWlEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdDQUFnQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUErRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEMsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBRyxDQUFDLGlEQUFNLFFBQVEscURBQUcsVUFBVSxvQkFBb0I7QUFDL0QsTUFBTSxxREFBRyxVQUFVLDRDQUE0QyxrQkFBa0IscURBQUcsVUFBVSxvQkFBb0IsRUFBRSxxREFBRyxVQUFVLHVDQUF1QyxFQUFFLHFEQUFHLFVBQVUseUJBQXlCLEVBQUUscURBQUcsa0NBQWtDLG9IQUFvSDtBQUMzVztBQUNBLGFBQWEsT0FBTyxxREFBWTtBQUNoQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbXVCOztBQUVudUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9pbmZvZ3JhcGhpY3Mtc3RlcC05ZTdmZmI4ZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOIGFzIE5BTUVTUEFDRSwgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50JDEsIGggYXMgaCQxLCBnIGFzIGdldEVsZW1lbnQkMSwgSCBhcyBIb3N0JDEgfSBmcm9tICcuL2luZGV4LTRlNjQ3NDExLmpzJztcbmltcG9ydCAnLi9hcmNnaXMtYmEtc2VhcmNoLWI2MGE3OGY5LmpzJztcbmltcG9ydCB7IEIgYXMgQmFzZVV0aWwgfSBmcm9tICcuL2Jhc2UtdXRpbC1iN2RiNjlmMC5qcyc7XG5pbXBvcnQgeyBBIGFzIEFDTFV0aWxzLCBFIGFzIEVsZW1lbnRJZHMsIEIgYXMgQmFSZXBvcnRzTGFuZ3VhZ2UgfSBmcm9tICcuL0VsZW1lbnRJZHMtYTJjNDA1OTIuanMnO1xuaW1wb3J0ICcuL2FyY2dpcy1pbmZvZ3JhcGhpYy10cmVlLTU3ZWFiZjJjLmpzJztcblxudmFyIE1heEJ1ZmZlcnM7XHJcbihmdW5jdGlvbiAoTWF4QnVmZmVycykge1xyXG4gIE1heEJ1ZmZlcnNbTWF4QnVmZmVyc1tcIlJpbmdzXCJdID0gMTAwMF0gPSBcIlJpbmdzXCI7XHJcbiAgTWF4QnVmZmVyc1tNYXhCdWZmZXJzW1wiRHJpdmVNaW51dGVzXCJdID0gMzAwXSA9IFwiRHJpdmVNaW51dGVzXCI7XHJcbiAgTWF4QnVmZmVyc1tNYXhCdWZmZXJzW1wiRHJpdmVNaWxlXCJdID0gMzAwXSA9IFwiRHJpdmVNaWxlXCI7XHJcbiAgTWF4QnVmZmVyc1tNYXhCdWZmZXJzW1wiRHJpdmVLbVwiXSA9IDQ4Mi44XSA9IFwiRHJpdmVLbVwiO1xyXG4gIE1heEJ1ZmZlcnNbTWF4QnVmZmVyc1tcIldhbGtNaW51dGVzXCJdID0gMzAwXSA9IFwiV2Fsa01pbnV0ZXNcIjtcclxuICBNYXhCdWZmZXJzW01heEJ1ZmZlcnNbXCJXYWxrTWlsZVwiXSA9IDI3XSA9IFwiV2Fsa01pbGVcIjtcclxuICBNYXhCdWZmZXJzW01heEJ1ZmZlcnNbXCJXYWxrS21cIl0gPSA0My40NV0gPSBcIldhbGtLbVwiO1xyXG59KShNYXhCdWZmZXJzIHx8IChNYXhCdWZmZXJzID0ge30pKTtcclxudmFyIE1pbkJ1ZmZlcnM7XHJcbihmdW5jdGlvbiAoTWluQnVmZmVycykge1xyXG4gIE1pbkJ1ZmZlcnNbTWluQnVmZmVyc1tcIlJpbmdzXCJdID0gMC4xXSA9IFwiUmluZ3NcIjtcclxuICBNaW5CdWZmZXJzW01pbkJ1ZmZlcnNbXCJEcml2ZVwiXSA9IDFdID0gXCJEcml2ZVwiO1xyXG4gIE1pbkJ1ZmZlcnNbTWluQnVmZmVyc1tcIldhbGtcIl0gPSAxXSA9IFwiV2Fsa1wiO1xyXG59KShNaW5CdWZmZXJzIHx8IChNaW5CdWZmZXJzID0ge30pKTtcclxuY29uc3QgQnVmZmVyVHlwZXNWYWx1ZXMgPSB7XHJcbiAgcmluZzogJ3JpbmcnLFxyXG4gIGRyaXZldGltZTogJ2RyaXZldGltZScsXHJcbiAgd2Fsa3RpbWU6ICd3YWxrdGltZScsXHJcbn07XHJcbmNvbnN0IEJ1ZmZlclVuaXRzVmFsdWVzID0ge1xyXG4gIG1pbnV0ZXM6ICdtaW51dGVzJyxcclxuICBraWxvbWV0ZXJzOiAna2lsb21ldGVycycsXHJcbiAgbWlsZXM6ICdtaWxlcycsXHJcbn07XHJcbmNvbnN0IFN0ZXBWYWx1ZXMgPSB7XHJcbiAgc2VhcmNoOiAnU2VhcmNoJyxcclxuICBidWZmZXJzOiAnQnVmZmVycycsXHJcbiAgaW5mb2dyYXBoaWNzOiAnSW5mb2dyYXBoaWNzJyxcclxufTtcblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3NuYWJiZG9tL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNb2RpZmllZCBmb3IgU3RlbmNpbCdzIHJlbmRlcmVyIGFuZCBzbG90IHByb2plY3Rpb25cbiAqL1xubGV0IHNjb3BlSWQ7XG5sZXQgaG9zdFRhZ05hbWU7XG5sZXQgaXNTdmdNb2RlID0gZmFsc2U7XG5sZXQgcXVldWVQZW5kaW5nID0gZmFsc2U7XG5jb25zdCBnZXRBc3NldFBhdGggPSAocGF0aCkgPT4ge1xuICAgIGNvbnN0IGFzc2V0VXJsID0gbmV3IFVSTChwYXRoLCBwbHQuJHJlc291cmNlc1VybCQpO1xuICAgIHJldHVybiBhc3NldFVybC5vcmlnaW4gIT09IHdpbi5sb2NhdGlvbi5vcmlnaW4gPyBhc3NldFVybC5ocmVmIDogYXNzZXRVcmwucGF0aG5hbWU7XG59O1xuY29uc3QgY3JlYXRlVGltZSA9IChmbk5hbWUsIHRhZ05hbWUgPSAnJykgPT4ge1xuICAgIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgdW5pcXVlVGltZSA9IChrZXksIG1lYXN1cmVUZXh0KSA9PiB7XG4gICAge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBYTElOS19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbi8qKlxuICogRGVmYXVsdCBzdHlsZSBtb2RlIGlkXG4gKi9cbi8qKlxuICogUmV1c2FibGUgZW1wdHkgb2JqL2FycmF5XG4gKiBEb24ndCBhZGQgdmFsdWVzIHRvIHRoZXNlISFcbiAqL1xuY29uc3QgRU1QVFlfT0JKID0ge307XG4vKipcbiAqIE5hbWVzcGFjZXNcbiAqL1xuY29uc3QgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IEhUTUxfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5jb25zdCBpc0RlZiA9ICh2KSA9PiB2ICE9IG51bGw7XG5jb25zdCBpc0NvbXBsZXhUeXBlID0gKG8pID0+IHtcbiAgICAvLyBodHRwczovL2pzcGVyZi5jb20vdHlwZW9mLWZuLW9iamVjdC81XG4gICAgbyA9IHR5cGVvZiBvO1xuICAgIHJldHVybiBvID09PSAnb2JqZWN0JyB8fCBvID09PSAnZnVuY3Rpb24nO1xufTtcbi8qKlxuICogUHJvZHVjdGlvbiBoKCkgZnVuY3Rpb24gYmFzZWQgb24gUHJlYWN0IGJ5XG4gKiBKYXNvbiBNaWxsZXIgKEBkZXZlbG9waXQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNb2RpZmllZCBmb3IgU3RlbmNpbCdzIGNvbXBpbGVyIGFuZCB2ZG9tXG4gKi9cbi8vIGNvbnN0IHN0YWNrOiBhbnlbXSA9IFtdO1xuLy8gZXhwb3J0IGZ1bmN0aW9uIGgobm9kZU5hbWU6IHN0cmluZyB8IGQuRnVuY3Rpb25hbENvbXBvbmVudCwgdm5vZGVEYXRhOiBkLlByb3BzVHlwZSwgY2hpbGQ/OiBkLkNoaWxkVHlwZSk6IGQuVk5vZGU7XG4vLyBleHBvcnQgZnVuY3Rpb24gaChub2RlTmFtZTogc3RyaW5nIHwgZC5GdW5jdGlvbmFsQ29tcG9uZW50LCB2bm9kZURhdGE6IGQuUHJvcHNUeXBlLCAuLi5jaGlsZHJlbjogZC5DaGlsZFR5cGVbXSk6IGQuVk5vZGU7XG5jb25zdCBoID0gKG5vZGVOYW1lLCB2bm9kZURhdGEsIC4uLmNoaWxkcmVuKSA9PiB7XG4gICAgbGV0IGNoaWxkID0gbnVsbDtcbiAgICBsZXQga2V5ID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RTaW1wbGUgPSBmYWxzZTtcbiAgICBjb25zdCB2Tm9kZUNoaWxkcmVuID0gW107XG4gICAgY29uc3Qgd2FsayA9IChjKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCAhPSBudWxsICYmIHR5cGVvZiBjaGlsZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09ICdmdW5jdGlvbicgJiYgIWlzQ29tcGxleFR5cGUoY2hpbGQpKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IFN0cmluZyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgY2hpbGQgd2FzIHNpbXBsZSAoc3RyaW5nKSwgd2UgbWVyZ2UgYm90aFxuICAgICAgICAgICAgICAgICAgICB2Tm9kZUNoaWxkcmVuW3ZOb2RlQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uJHRleHQkICs9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHZOb2RlLCBpZiBpdCdzIHRleHQsIHdlIGNyZWF0ZSBhIHRleHQgdk5vZGVcbiAgICAgICAgICAgICAgICAgICAgdk5vZGVDaGlsZHJlbi5wdXNoKHNpbXBsZSA/IG5ld1ZOb2RlKG51bGwsIGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNpbXBsZSA9IHNpbXBsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgd2FsayhjaGlsZHJlbik7XG4gICAgaWYgKHZub2RlRGF0YSkge1xuICAgICAgICAvLyBub3JtYWxpemUgY2xhc3MgLyBjbGFzc25hbWUgYXR0cmlidXRlc1xuICAgICAgICBpZiAodm5vZGVEYXRhLmtleSkge1xuICAgICAgICAgICAga2V5ID0gdm5vZGVEYXRhLmtleTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0RhdGEgPSB2bm9kZURhdGEuY2xhc3NOYW1lIHx8IHZub2RlRGF0YS5jbGFzcztcbiAgICAgICAgICAgIGlmIChjbGFzc0RhdGEpIHtcbiAgICAgICAgICAgICAgICB2bm9kZURhdGEuY2xhc3MgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2xhc3NEYXRhICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbGFzc0RhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LmtleXMoY2xhc3NEYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IGNsYXNzRGF0YVtrXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygbm9kZU5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm9kZU5hbWUgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgICByZXR1cm4gbm9kZU5hbWUodm5vZGVEYXRhID09PSBudWxsID8ge30gOiB2bm9kZURhdGEsIHZOb2RlQ2hpbGRyZW4sIHZkb21GblV0aWxzKTtcbiAgICB9XG4gICAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlTmFtZSwgbnVsbCk7XG4gICAgdm5vZGUuJGF0dHJzJCA9IHZub2RlRGF0YTtcbiAgICBpZiAodk5vZGVDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZub2RlLiRjaGlsZHJlbiQgPSB2Tm9kZUNoaWxkcmVuO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZub2RlLiRrZXkkID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59O1xuY29uc3QgbmV3Vk5vZGUgPSAodGFnLCB0ZXh0KSA9PiB7XG4gICAgY29uc3Qgdm5vZGUgPSB7XG4gICAgICAgICRmbGFncyQ6IDAsXG4gICAgICAgICR0YWckOiB0YWcsXG4gICAgICAgICR0ZXh0JDogdGV4dCxcbiAgICAgICAgJGVsbSQ6IG51bGwsXG4gICAgICAgICRjaGlsZHJlbiQ6IG51bGwsXG4gICAgfTtcbiAgICB7XG4gICAgICAgIHZub2RlLiRhdHRycyQgPSBudWxsO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZub2RlLiRrZXkkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbmNvbnN0IEhvc3QgPSB7fTtcbmNvbnN0IGlzSG9zdCA9IChub2RlKSA9PiBub2RlICYmIG5vZGUuJHRhZyQgPT09IEhvc3Q7XG5jb25zdCB2ZG9tRm5VdGlscyA9IHtcbiAgICBmb3JFYWNoOiAoY2hpbGRyZW4sIGNiKSA9PiBjaGlsZHJlbi5tYXAoY29udmVydFRvUHVibGljKS5mb3JFYWNoKGNiKSxcbiAgICBtYXA6IChjaGlsZHJlbiwgY2IpID0+IGNoaWxkcmVuLm1hcChjb252ZXJ0VG9QdWJsaWMpLm1hcChjYikubWFwKGNvbnZlcnRUb1ByaXZhdGUpLFxufTtcbmNvbnN0IGNvbnZlcnRUb1B1YmxpYyA9IChub2RlKSA9PiAoe1xuICAgIHZhdHRyczogbm9kZS4kYXR0cnMkLFxuICAgIHZjaGlsZHJlbjogbm9kZS4kY2hpbGRyZW4kLFxuICAgIHZrZXk6IG5vZGUuJGtleSQsXG4gICAgdm5hbWU6IG5vZGUuJG5hbWUkLFxuICAgIHZ0YWc6IG5vZGUuJHRhZyQsXG4gICAgdnRleHQ6IG5vZGUuJHRleHQkLFxufSk7XG5jb25zdCBjb252ZXJ0VG9Qcml2YXRlID0gKG5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIG5vZGUudnRhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCB2bm9kZURhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLnZhdHRycyk7XG4gICAgICAgIGlmIChub2RlLnZrZXkpIHtcbiAgICAgICAgICAgIHZub2RlRGF0YS5rZXkgPSBub2RlLnZrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudm5hbWUpIHtcbiAgICAgICAgICAgIHZub2RlRGF0YS5uYW1lID0gbm9kZS52bmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaChub2RlLnZ0YWcsIHZub2RlRGF0YSwgLi4uKG5vZGUudmNoaWxkcmVuIHx8IFtdKSk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gbmV3Vk5vZGUobm9kZS52dGFnLCBub2RlLnZ0ZXh0KTtcbiAgICB2bm9kZS4kYXR0cnMkID0gbm9kZS52YXR0cnM7XG4gICAgdm5vZGUuJGNoaWxkcmVuJCA9IG5vZGUudmNoaWxkcmVuO1xuICAgIHZub2RlLiRrZXkkID0gbm9kZS52a2V5O1xuICAgIHZub2RlLiRuYW1lJCA9IG5vZGUudm5hbWU7XG4gICAgcmV0dXJuIHZub2RlO1xufTtcbi8qKlxuICogUGFyc2UgYSBuZXcgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gcHJvcGVydHkgdHlwZS5cbiAqXG4gKiBXaGlsZSB0aGUgcHJvcCB2YWx1ZSBjYW4gcmVhc29uYWJseSBiZSBleHBlY3RlZCB0byBiZSBvZiBgYW55YCB0eXBlIGFzIGZhciBhcyBUeXBlU2NyaXB0J3MgdHlwZSBjaGVja2VyIGlzIGNvbmNlcm5lZCxcbiAqIGl0IGlzIG5vdCBzYWZlIHRvIGFzc3VtZSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgZXZhbHVhdGluZyBgdHlwZW9mIHByb3BWYWx1ZWAgbWF0Y2hlczpcbiAqICAgMS4gYGFueWAsIHRoZSB0eXBlIGdpdmVuIHRvIGBwcm9wVmFsdWVgIGluIHRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbiAqICAgMi4gdGhlIHR5cGUgc3RvcmVkIGZyb20gYHByb3BUeXBlYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIHRoZSBjYXBhYmlsaXR5IHRvIHBhcnNlL2NvZXJjZSBhIHByb3BlcnR5J3MgdmFsdWUgdG8gcG90ZW50aWFsbHkgYW55IG90aGVyIEphdmFTY3JpcHQgdHlwZS5cbiAqXG4gKiBQcm9wZXJ0eSB2YWx1ZXMgcmVwcmVzZW50ZWQgaW4gVFNYIHByZXNlcnZlIHRoZWlyIHR5cGUgaW5mb3JtYXRpb24uIEluIHRoZSBleGFtcGxlIGJlbG93LCB0aGUgbnVtYmVyIDAgaXMgcGFzc2VkIHRvXG4gKiBhIGNvbXBvbmVudC4gVGhpcyBgcHJvcFZhbHVlYCB3aWxsIHByZXNlcnZlIGl0cyB0eXBlIGluZm9ybWF0aW9uIChgdHlwZW9mIHByb3BWYWx1ZSA9PT0gJ251bWJlcidgKS4gTm90ZSB0aGF0IGlzXG4gKiBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGluLCBub3QgdGhlIHR5cGUgZGVjbGFyZWQgb2YgdGhlIGNsYXNzIG1lbWJlciBkZWNvcmF0ZWQgd2l0aCBgQFByb3BgLlxuICogYGBgdHN4XG4gKiA8bXktY21wIHByb3AtdmFsPXswfT48L215LWNtcD5cbiAqIGBgYFxuICpcbiAqIEhUTUwgcHJvcCB2YWx1ZXMgb24gdGhlIG90aGVyIGhhbmQsIHdpbGwgYWx3YXlzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHByb3BWYWx1ZSB0aGUgbmV3IHZhbHVlIHRvIGNvZXJjZSB0byBzb21lIHR5cGVcbiAqIEBwYXJhbSBwcm9wVHlwZSB0aGUgdHlwZSBvZiB0aGUgcHJvcCwgZXhwcmVzc2VkIGFzIGEgYmluYXJ5IG51bWJlclxuICogQHJldHVybnMgdGhlIHBhcnNlZC9jb2VyY2VkIHZhbHVlXG4gKi9cbmNvbnN0IHBhcnNlUHJvcGVydHlWYWx1ZSA9IChwcm9wVmFsdWUsIHByb3BUeXBlKSA9PiB7XG4gICAgLy8gZW5zdXJlIHRoaXMgdmFsdWUgaXMgb2YgdGhlIGNvcnJlY3QgcHJvcCB0eXBlXG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmICFpc0NvbXBsZXhUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgaWYgKHByb3BUeXBlICYgNCAvKiBNRU1CRVJfRkxBR1MuQm9vbGVhbiAqLykge1xuICAgICAgICAgICAgLy8gcGVyIHRoZSBIVE1MIHNwZWMsIGFueSBzdHJpbmcgdmFsdWUgbWVhbnMgaXQgaXMgYSBib29sZWFuIHRydWUgdmFsdWVcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSdsbCBjaGVhdCBoZXJlIGFuZCBzYXkgdGhhdCB0aGUgc3RyaW5nIFwiZmFsc2VcIiBpcyB0aGUgYm9vbGVhbiBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogcHJvcFZhbHVlID09PSAnJyB8fCAhIXByb3BWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFR5cGUgJiAyIC8qIE1FTUJFUl9GTEFHUy5OdW1iZXIgKi8pIHtcbiAgICAgICAgICAgIC8vIGZvcmNlIGl0IHRvIGJlIGEgbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVHlwZSAmIDEgLyogTUVNQkVSX0ZMQUdTLlN0cmluZyAqLykge1xuICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBiZWVuIHBhc3NlZCBhcyBhIG51bWJlciBvciBib29sZWFuXG4gICAgICAgICAgICAvLyBidXQgd2Ugc3RpbGwgd2FudCBpdCBhcyBhIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVuZGFudCByZXR1cm4gaGVyZSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvblxuICAgICAgICByZXR1cm4gcHJvcFZhbHVlO1xuICAgIH1cbiAgICAvLyBub3Qgc3VyZSBleGFjdGx5IHdoYXQgdHlwZSB3ZSB3YW50XG4gICAgLy8gc28gbm8gbmVlZCB0byBjaGFuZ2UgdG8gYSBkaWZmZXJlbnQgdHlwZVxuICAgIHJldHVybiBwcm9wVmFsdWU7XG59O1xuY29uc3QgZ2V0RWxlbWVudCA9IChyZWYpID0+IChnZXRIb3N0UmVmKHJlZikuJGhvc3RFbGVtZW50JCApO1xuY29uc3QgY3JlYXRlRXZlbnQgPSAocmVmLCBuYW1lLCBmbGFncykgPT4ge1xuICAgIGNvbnN0IGVsbSA9IGdldEVsZW1lbnQocmVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbWl0OiAoZGV0YWlsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZW1pdEV2ZW50KGVsbSwgbmFtZSwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEhKGZsYWdzICYgNCAvKiBFVkVOVF9GTEFHUy5CdWJibGVzICovKSxcbiAgICAgICAgICAgICAgICBjb21wb3NlZDogISEoZmxhZ3MgJiAyIC8qIEVWRU5UX0ZMQUdTLkNvbXBvc2VkICovKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiAhIShmbGFncyAmIDEgLyogRVZFTlRfRkxBR1MuQ2FuY2VsbGFibGUgKi8pLFxuICAgICAgICAgICAgICAgIGRldGFpbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlICYgZGlzcGF0Y2ggYSBjdXN0b20gRXZlbnQgb24gYSBwcm92aWRlZCB0YXJnZXRcbiAqIEBwYXJhbSBlbG0gdGhlIHRhcmdldCBvZiB0aGUgRXZlbnRcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIHRvIGdpdmUgdGhlIGN1c3RvbSBFdmVudFxuICogQHBhcmFtIG9wdHMgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgYSBjdXN0b20gRXZlbnRcbiAqIEByZXR1cm5zIHRoZSBjdXN0b20gRXZlbnRcbiAqL1xuY29uc3QgZW1pdEV2ZW50ID0gKGVsbSwgbmFtZSwgb3B0cykgPT4ge1xuICAgIGNvbnN0IGV2ID0gcGx0LmNlKG5hbWUsIG9wdHMpO1xuICAgIGVsbS5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICByZXR1cm4gZXY7XG59O1xuY29uc3Qgcm9vdEFwcGxpZWRTdHlsZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWdpc3RlclN0eWxlID0gKHNjb3BlSWQsIGNzc1RleHQsIGFsbG93Q1MpID0+IHtcbiAgICBsZXQgc3R5bGUgPSBzdHlsZXMuZ2V0KHNjb3BlSWQpO1xuICAgIGlmIChzdXBwb3J0c0NvbnN0cnVjdGFibGVTdHlsZXNoZWV0cyAmJiBhbGxvd0NTKSB7XG4gICAgICAgIHN0eWxlID0gKHN0eWxlIHx8IG5ldyBDU1NTdHlsZVNoZWV0KCkpO1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3R5bGUgPSBjc3NUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGUucmVwbGFjZVN5bmMoY3NzVGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0eWxlID0gY3NzVGV4dDtcbiAgICB9XG4gICAgc3R5bGVzLnNldChzY29wZUlkLCBzdHlsZSk7XG59O1xuY29uc3QgYWRkU3R5bGUgPSAoc3R5bGVDb250YWluZXJOb2RlLCBjbXBNZXRhLCBtb2RlLCBob3N0RWxtKSA9PiB7XG4gICAgbGV0IHNjb3BlSWQgPSBnZXRTY29wZUlkKGNtcE1ldGEpO1xuICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzLmdldChzY29wZUlkKTtcbiAgICAvLyBpZiBhbiBlbGVtZW50IGlzIE5PVCBjb25uZWN0ZWQgdGhlbiBnZXRSb290Tm9kZSgpIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyByb290IG5vZGVcbiAgICAvLyBzbyB0aGUgZmFsbGJhY2sgaXMgdG8gYWx3YXlzIHVzZSB0aGUgZG9jdW1lbnQgZm9yIHRoZSByb290IG5vZGUgaW4gdGhvc2UgY2FzZXNcbiAgICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUubm9kZVR5cGUgPT09IDExIC8qIE5PREVfVFlQRS5Eb2N1bWVudEZyYWdtZW50ICovID8gc3R5bGVDb250YWluZXJOb2RlIDogZG9jO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlID0gc3R5bGVDb250YWluZXJOb2RlLmhlYWQgfHwgc3R5bGVDb250YWluZXJOb2RlO1xuICAgICAgICAgICAgbGV0IGFwcGxpZWRTdHlsZXMgPSByb290QXBwbGllZFN0eWxlcy5nZXQoc3R5bGVDb250YWluZXJOb2RlKTtcbiAgICAgICAgICAgIGxldCBzdHlsZUVsbTtcbiAgICAgICAgICAgIGlmICghYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgICAgICAgIHJvb3RBcHBsaWVkU3R5bGVzLnNldChzdHlsZUNvbnRhaW5lck5vZGUsIChhcHBsaWVkU3R5bGVzID0gbmV3IFNldCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFwcGxpZWRTdHlsZXMuaGFzKHNjb3BlSWQpKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsbSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVFbG0uaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmluc2VydEJlZm9yZShzdHlsZUVsbSwgc3R5bGVDb250YWluZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoJ2xpbmsnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMuYWRkKHNjb3BlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cy5pbmNsdWRlcyhzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBbLi4uc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cywgc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29wZUlkO1xufTtcbmNvbnN0IGF0dGFjaFN0eWxlcyA9IChob3N0UmVmKSA9PiB7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IGVsbSA9IGhvc3RSZWYuJGhvc3RFbGVtZW50JDtcbiAgICBjb25zdCBmbGFncyA9IGNtcE1ldGEuJGZsYWdzJDtcbiAgICBjb25zdCBlbmRBdHRhY2hTdHlsZXMgPSBjcmVhdGVUaW1lKCdhdHRhY2hTdHlsZXMnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgY29uc3Qgc2NvcGVJZCA9IGFkZFN0eWxlKGVsbS5zaGFkb3dSb290ID8gZWxtLnNoYWRvd1Jvb3QgOiBlbG0uZ2V0Um9vdE5vZGUoKSwgY21wTWV0YSk7XG4gICAgaWYgKGZsYWdzICYgMTAgLyogQ01QX0ZMQUdTLm5lZWRzU2NvcGVkRW5jYXBzdWxhdGlvbiAqLykge1xuICAgICAgICAvLyBvbmx5IHJlcXVpcmVkIHdoZW4gd2UncmUgTk9UIHVzaW5nIG5hdGl2ZSBzaGFkb3cgZG9tIChzbG90KVxuICAgICAgICAvLyBvciB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IG5hdGl2ZSBzaGFkb3cgZG9tXG4gICAgICAgIC8vIGFuZCB0aGlzIGhvc3QgZWxlbWVudCB3YXMgTk9UIGNyZWF0ZWQgd2l0aCBTU1JcbiAgICAgICAgLy8gbGV0J3MgcGljayBvdXQgdGhlIGlubmVyIGNvbnRlbnQgZm9yIHNsb3QgcHJvamVjdGlvblxuICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRvIHJlcHJlc2VudCB3aGVyZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gY29udGVudCB3YXMgZmlyc3QgcGxhY2VkLCB3aGljaCBpcyB1c2VmdWwgbGF0ZXIgb25cbiAgICAgICAgLy8gRE9NIFdSSVRFISFcbiAgICAgICAgZWxtWydzLXNjJ10gPSBzY29wZUlkO1xuICAgICAgICBlbG0uY2xhc3NMaXN0LmFkZChzY29wZUlkICsgJy1oJyk7XG4gICAgfVxuICAgIGVuZEF0dGFjaFN0eWxlcygpO1xufTtcbmNvbnN0IGdldFNjb3BlSWQgPSAoY21wLCBtb2RlKSA9PiAnc2MtJyArIChjbXAuJHRhZ05hbWUkKTtcbi8qKlxuICogUHJvZHVjdGlvbiBzZXRBY2Nlc3NvcigpIGZ1bmN0aW9uIGJhc2VkIG9uIFByZWFjdCBieVxuICogSmFzb24gTWlsbGVyIChAZGV2ZWxvcGl0KVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTW9kaWZpZWQgZm9yIFN0ZW5jaWwncyBjb21waWxlciBhbmQgdmRvbVxuICovXG5jb25zdCBzZXRBY2Nlc3NvciA9IChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgaXNTdmcsIGZsYWdzKSA9PiB7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgaXNQcm9wID0gaXNNZW1iZXJJbkVsZW1lbnQoZWxtLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgbGV0IGxuID0gbWVtYmVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobWVtYmVyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWxtLmNsYXNzTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IG9sZENsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChvbGRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3QobmV3VmFsdWUpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSguLi5vbGRDbGFzc2VzLmZpbHRlcigoYykgPT4gYyAmJiAhbmV3Q2xhc3Nlcy5pbmNsdWRlcyhjKSkpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCguLi5uZXdDbGFzc2VzLmZpbHRlcigoYykgPT4gYyAmJiAhb2xkQ2xhc3Nlcy5pbmNsdWRlcyhjKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lbWJlck5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBhdHRyaWJ1dGUsIGNzcyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZFZhbHVlIHx8IG5ld1ZhbHVlW3Byb3BdICE9PSBvbGRWYWx1ZVtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0uc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgbmV3VmFsdWVbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnN0eWxlW3Byb3BdID0gbmV3VmFsdWVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVtYmVyTmFtZSA9PT0gJ2tleScpXG4gICAgICAgICAgICA7XG4gICAgICAgIGVsc2UgaWYgKG1lbWJlck5hbWUgPT09ICdyZWYnKSB7XG4gICAgICAgICAgICAvLyBtaW5pZmllciB3aWxsIGNsZWFuIHRoaXMgdXBcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlKGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKCFpc1Byb3AgKSAmJlxuICAgICAgICAgICAgbWVtYmVyTmFtZVswXSA9PT0gJ28nICYmXG4gICAgICAgICAgICBtZW1iZXJOYW1lWzFdID09PSAnbicpIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsZXJzXG4gICAgICAgICAgICAvLyBzbyBpZiB0aGUgbWVtYmVyIG5hbWUgc3RhcnRzIHdpdGggXCJvblwiIGFuZCB0aGUgM3JkIGNoYXJhY3RlcnMgaXNcbiAgICAgICAgICAgIC8vIGEgY2FwaXRhbCBsZXR0ZXIsIGFuZCBpdCdzIG5vdCBhbHJlYWR5IGEgbWVtYmVyIG9uIHRoZSBlbGVtZW50LFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSdyZSBhc3N1bWluZyBpdCdzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICBpZiAobWVtYmVyTmFtZVsyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgLy8gb24tIHByZWZpeGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0byBiZSBleHBsaWNpdCBhYm91dCB0aGUgZG9tIGV2ZW50IHRvIGxpc3RlbiB3aXRob3V0IGFueSBtYWdpY1xuICAgICAgICAgICAgICAgIC8vIHVuZGVyIHRoZSBob29kOlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tY2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiY2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24tQ2xpY2s+IC8vIGxpc3RlbnMgZm9yIFwiQ2xpY2tcIlxuICAgICAgICAgICAgICAgIC8vIDxteS1jbXAgb24taW9uQ2hhbmdlPiAvLyBsaXN0ZW5zIGZvciBcImlvbkNoYW5nZVwiXG4gICAgICAgICAgICAgICAgLy8gPG15LWNtcCBvbi1FVkVOVFM+IC8vIGxpc3RlbnMgZm9yIFwiRVZFTlRTXCJcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5zbGljZSgzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTWVtYmVySW5FbGVtZW50KHdpbiwgbG4pKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk1vdXNlT3ZlclwiIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZW1iZXIgbmFtZSBcIm9ubW91c2VvdmVyXCIgaXMgb24gdGhlIHdpbmRvdydzIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIGFkZCB0aGUgbGlzdGVuZXIgXCJtb3VzZW92ZXJcIiwgd2hpY2ggaXMgYWxsIGxvd2VyY2FzZWRcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG4uc2xpY2UoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgSlNYIGF0dHJpYnV0ZSBjb3VsZCBoYXZlIGJlZW4gXCJvbk15Q3VzdG9tRXZlbnRcIlxuICAgICAgICAgICAgICAgIC8vIHNvIGxldCdzIHRyaW0gb2ZmIHRoZSBcIm9uXCIgcHJlZml4IGFuZCBsb3dlcmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIGxpc3RlbmVyIFwibXlDdXN0b21FdmVudFwiXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB3ZSBrZWVwIHRoZSBldmVudCBuYW1lIGNhc2VcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lID0gbG5bMl0gKyBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcGx0LnJlbChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuYWVsKGVsbSwgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNldCBwcm9wZXJ0eSBpZiBpdCBleGlzdHMgYW5kIGl0J3Mgbm90IGEgU1ZHXG4gICAgICAgICAgICBjb25zdCBpc0NvbXBsZXggPSBpc0NvbXBsZXhUeXBlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmICgoaXNQcm9wIHx8IChpc0NvbXBsZXggJiYgbmV3VmFsdWUgIT09IG51bGwpKSAmJiAhaXNTdmcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsbS50YWdOYW1lLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBuZXdWYWx1ZSA9PSBudWxsID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaSwgbW92aW5nIHRoZSA8aW5wdXQ+IGNhcmV0IHdoZW4gcmUtYXNzaWduaW5nIHRoZSBzYW1lIHZhbHVlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgPT0gbnVsbCB8fCBlbG1bbWVtYmVyTmFtZV0gIT0gbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIGF0dHJpYnV0ZSBpZjpcbiAgICAgICAgICAgICAqIC0gbWVtYmVyTmFtZSBpcyBub3QgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGFyZSByZW5kZXJpbmcgdGhlIGhvc3QgZWxlbWVudCBpbiBvcmRlciB0byByZWZsZWN0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogLSBpZiBpdCdzIGEgU1ZHLCBzaW5jZSBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCB3b3JrIGluIDxzdmc+XG4gICAgICAgICAgICAgKiAtIGlmIHRoZSBuZXdWYWx1ZSBpcyBudWxsL3VuZGVmaW5lZCBvciAnZmFsc2UnLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgeGxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobG4gIT09IChsbiA9IGxuLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWUgPSBsbjtcbiAgICAgICAgICAgICAgICAgICAgeGxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gZmFsc2UgfHwgZWxtLmdldEF0dHJpYnV0ZShtZW1iZXJOYW1lKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoWExJTktfTlMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShtZW1iZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCghaXNQcm9wIHx8IGZsYWdzICYgNCAvKiBWTk9ERV9GTEFHUy5pc0hvc3QgKi8gfHwgaXNTdmcpICYmICFpc0NvbXBsZXgpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlID09PSB0cnVlID8gJycgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoeGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZU5TKFhMSU5LX05TLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKG1lbWJlck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgcGFyc2VDbGFzc0xpc3RSZWdleCA9IC9cXHMvO1xuY29uc3QgcGFyc2VDbGFzc0xpc3QgPSAodmFsdWUpID0+ICghdmFsdWUgPyBbXSA6IHZhbHVlLnNwbGl0KHBhcnNlQ2xhc3NMaXN0UmVnZXgpKTtcbmNvbnN0IHVwZGF0ZUVsZW1lbnQgPSAob2xkVm5vZGUsIG5ld1Zub2RlLCBpc1N2Z01vZGUsIG1lbWJlck5hbWUpID0+IHtcbiAgICAvLyBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaW4gaXMgYSBzaGFkb3cgcm9vdCwgd2hpY2ggaXMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgIC8vIHRoZW4gd2Ugd2FudCB0byBiZSBhZGRpbmcgYXR0cnMvcHJvcHMgdG8gdGhlIHNoYWRvdyByb290J3MgXCJob3N0XCIgZWxlbWVudFxuICAgIC8vIGlmIGl0J3Mgbm90IGEgc2hhZG93IHJvb3QsIHRoZW4gd2UgYWRkIGF0dHJzL3Byb3BzIHRvIHRoZSBzYW1lIGVsZW1lbnRcbiAgICBjb25zdCBlbG0gPSBuZXdWbm9kZS4kZWxtJC5ub2RlVHlwZSA9PT0gMTEgLyogTk9ERV9UWVBFLkRvY3VtZW50RnJhZ21lbnQgKi8gJiYgbmV3Vm5vZGUuJGVsbSQuaG9zdFxuICAgICAgICA/IG5ld1Zub2RlLiRlbG0kLmhvc3RcbiAgICAgICAgOiBuZXdWbm9kZS4kZWxtJDtcbiAgICBjb25zdCBvbGRWbm9kZUF0dHJzID0gKG9sZFZub2RlICYmIG9sZFZub2RlLiRhdHRycyQpIHx8IEVNUFRZX09CSjtcbiAgICBjb25zdCBuZXdWbm9kZUF0dHJzID0gbmV3Vm5vZGUuJGF0dHJzJCB8fCBFTVBUWV9PQko7XG4gICAge1xuICAgICAgICAvLyByZW1vdmUgYXR0cmlidXRlcyBubyBsb25nZXIgcHJlc2VudCBvbiB0aGUgdm5vZGUgYnkgc2V0dGluZyB0aGVtIHRvIHVuZGVmaW5lZFxuICAgICAgICBmb3IgKG1lbWJlck5hbWUgaW4gb2xkVm5vZGVBdHRycykge1xuICAgICAgICAgICAgaWYgKCEobWVtYmVyTmFtZSBpbiBuZXdWbm9kZUF0dHJzKSkge1xuICAgICAgICAgICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgdW5kZWZpbmVkLCBpc1N2Z01vZGUsIG5ld1Zub2RlLiRmbGFncyQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBuZXcgJiB1cGRhdGUgY2hhbmdlZCBhdHRyaWJ1dGVzXG4gICAgZm9yIChtZW1iZXJOYW1lIGluIG5ld1Zub2RlQXR0cnMpIHtcbiAgICAgICAgc2V0QWNjZXNzb3IoZWxtLCBtZW1iZXJOYW1lLCBvbGRWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBuZXdWbm9kZUF0dHJzW21lbWJlck5hbWVdLCBpc1N2Z01vZGUsIG5ld1Zub2RlLiRmbGFncyQpO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZSBhIERPTSBOb2RlIGNvcnJlc3BvbmRpbmcgdG8gb25lIG9mIHRoZSBjaGlsZHJlbiBvZiBhIGdpdmVuIFZOb2RlLlxuICpcbiAqIEBwYXJhbSBvbGRQYXJlbnRWTm9kZSB0aGUgcGFyZW50IFZOb2RlIGZyb20gdGhlIHByZXZpb3VzIHJlbmRlclxuICogQHBhcmFtIG5ld1BhcmVudFZOb2RlIHRoZSBwYXJlbnQgVk5vZGUgZnJvbSB0aGUgY3VycmVudCByZW5kZXJcbiAqIEBwYXJhbSBjaGlsZEluZGV4IHRoZSBpbmRleCBvZiB0aGUgVk5vZGUsIGluIHRoZSBfbmV3XyBwYXJlbnQgbm9kZSdzXG4gKiBjaGlsZHJlbiwgZm9yIHdoaWNoIHdlIHdpbGwgY3JlYXRlIGEgbmV3IERPTSBub2RlXG4gKiBAcGFyYW0gcGFyZW50RWxtIHRoZSBwYXJlbnQgRE9NIG5vZGUgd2hpY2ggb3VyIG5ldyBub2RlIHdpbGwgYmUgYSBjaGlsZCBvZlxuICogQHJldHVybnMgdGhlIG5ld2x5IGNyZWF0ZWQgbm9kZVxuICovXG5jb25zdCBjcmVhdGVFbG0gPSAob2xkUGFyZW50Vk5vZGUsIG5ld1BhcmVudFZOb2RlLCBjaGlsZEluZGV4LCBwYXJlbnRFbG0pID0+IHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHByZWZlci1jb25zdFxuICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3UGFyZW50Vk5vZGUuJGNoaWxkcmVuJFtjaGlsZEluZGV4XTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGVsbTtcbiAgICBsZXQgY2hpbGROb2RlO1xuICAgIGlmIChuZXdWTm9kZS4kdGV4dCQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRleHQgbm9kZVxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IGRvYy5jcmVhdGVUZXh0Tm9kZShuZXdWTm9kZS4kdGV4dCQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFpc1N2Z01vZGUpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IG5ld1ZOb2RlLiR0YWckID09PSAnc3ZnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgZWxlbWVudFxuICAgICAgICBlbG0gPSBuZXdWTm9kZS4kZWxtJCA9IChkb2MuY3JlYXRlRWxlbWVudE5TKGlzU3ZnTW9kZSA/IFNWR19OUyA6IEhUTUxfTlMsIG5ld1ZOb2RlLiR0YWckKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgaWYgKGlzU3ZnTW9kZSAmJiBuZXdWTm9kZS4kdGFnJCA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgY3NzIGNsYXNzZXMsIGF0dHJzLCBwcm9wcywgbGlzdGVuZXJzLCBldGMuXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQobnVsbCwgbmV3Vk5vZGUsIGlzU3ZnTW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKHNjb3BlSWQpICYmIGVsbVsncy1zaSddICE9PSBzY29wZUlkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjb3BlSWQgYW5kIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAvLyB0aGVuIGxldCdzIGFkZCB0aGUgc2NvcGVJZCBhcyBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoKGVsbVsncy1zaSddID0gc2NvcGVJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWTm9kZS4kY2hpbGRyZW4kKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3Vk5vZGUuJGNoaWxkcmVuJC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShvbGRQYXJlbnRWTm9kZSwgbmV3Vk5vZGUsIGkpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBub2RlIGNvdWxkIGhhdmUgYmVlbiBudWxsXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhcHBlbmQgb3VyIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Vk5vZGUuJHRhZyQgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZXNldCB0aGUgU1ZHIGNvbnRleHQgd2hlbiB3ZSdyZSBleGl0aW5nIDxzdmc+IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsbS50YWdOYW1lID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWVudGVyIFNWRyBjb250ZXh0IHdoZW4gd2UncmUgZXhpdGluZyA8Zm9yZWlnbk9iamVjdD4gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlzU3ZnTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsbTtcbn07XG5jb25zdCBhZGRWbm9kZXMgPSAocGFyZW50RWxtLCBiZWZvcmUsIHBhcmVudFZOb2RlLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyRWxtID0gKHBhcmVudEVsbSk7XG4gICAgbGV0IGNoaWxkTm9kZTtcbiAgICBpZiAoY29udGFpbmVyRWxtLnNoYWRvd1Jvb3QgJiYgY29udGFpbmVyRWxtLnRhZ05hbWUgPT09IGhvc3RUYWdOYW1lKSB7XG4gICAgICAgIGNvbnRhaW5lckVsbSA9IGNvbnRhaW5lckVsbS5zaGFkb3dSb290O1xuICAgIH1cbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICh2bm9kZXNbc3RhcnRJZHhdKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjcmVhdGVFbG0obnVsbCwgcGFyZW50Vk5vZGUsIHN0YXJ0SWR4KTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bm9kZXNbc3RhcnRJZHhdLiRlbG0kID0gY2hpbGROb2RlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsbS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIHZub2RlLCBlbG0pID0+IHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGlmICgodm5vZGUgPSB2bm9kZXNbc3RhcnRJZHhdKSkge1xuICAgICAgICAgICAgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICAgICAgICBjYWxsTm9kZVJlZnModm5vZGUpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB2bm9kZSdzIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBSZWNvbmNpbGUgdGhlIGNoaWxkcmVuIG9mIGEgbmV3IFZOb2RlIHdpdGggdGhlIGNoaWxkcmVuIG9mIGFuIG9sZCBWTm9kZSBieVxuICogdHJhdmVyc2luZyB0aGUgdHdvIGNvbGxlY3Rpb25zIG9mIGNoaWxkcmVuLCBpZGVudGlmeWluZyBub2RlcyB0aGF0IGFyZVxuICogY29uc2VydmVkIG9yIGNoYW5nZWQsIGNhbGxpbmcgb3V0IHRvIGBwYXRjaGAgdG8gbWFrZSBhbnkgbmVjZXNzYXJ5XG4gKiB1cGRhdGVzIHRvIHRoZSBET00sIGFuZCByZWFycmFuZ2luZyBET00gbm9kZXMgYXMgbmVlZGVkLlxuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIHJlY29uY2lsaW5nIGNoaWxkcmVuIHdvcmtzIGJ5IGFuYWx5emluZyB0d28gJ3dpbmRvd3MnIG9udG9cbiAqIHRoZSB0d28gYXJyYXlzIG9mIGNoaWxkcmVuIChgb2xkQ2hgIGFuZCBgbmV3Q2hgKS4gV2Uga2VlcCB0cmFjayBvZiB0aGVcbiAqICd3aW5kb3dzJyBieSBzdG9yaW5nIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBhbmQgcmVmZXJlbmNlcyB0byB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgYXJyYXkgZW50cmllcy4gSW5pdGlhbGx5IHRoZSB0d28gJ3dpbmRvd3MnIGFyZSBiYXNpY2FsbHkgZXF1YWxcbiAqIHRvIHRoZSBlbnRpcmUgYXJyYXksIGJ1dCB3ZSBwcm9ncmVzc2l2ZWx5IG5hcnJvdyB0aGUgd2luZG93cyB1bnRpbCB0aGVyZSBhcmVcbiAqIG5vIGNoaWxkcmVuIGxlZnQgdG8gdXBkYXRlIGJ5IGRvaW5nIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogMS4gU2tpcCBhbnkgYG51bGxgIGVudHJpZXMgYXQgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIHR3byBhcnJheXMsIHNvXG4gKiAgICB0aGF0IGlmIHdlIGhhdmUgYW4gaW5pdGlhbCBhcnJheSBsaWtlIHRoZSBmb2xsb3dpbmcgd2UnbGwgZW5kIHVwIGRlYWxpbmdcbiAqICAgIG9ubHkgd2l0aCBhIHdpbmRvdyBib3VuZGVkIGJ5IHRoZSBoaWdobGlnaHRlZCBlbGVtZW50czpcbiAqXG4gKiAgICBbbnVsbCwgbnVsbCwgVk5vZGUxICwgLi4uICwgVk5vZGUyLCBudWxsLCBudWxsXVxuICogICAgICAgICAgICAgICAgIF5eXl5eXiAgICAgICAgIF5eXl5eXlxuICpcbiAqIDIuIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudHMgYXQgdGhlIGhlYWQgYW5kIHRhaWwgcG9zaXRpb25zIGFyZSBlcXVhbFxuICogICAgYWNyb3NzIHRoZSB3aW5kb3dzLiBUaGlzIHdpbGwgYmFzaWNhbGx5IGRldGVjdCBlbGVtZW50cyB3aGljaCBoYXZlbid0XG4gKiAgICBiZWVuIGFkZGVkLCByZW1vdmVkLCBvciBjaGFuZ2VkIHBvc2l0aW9uLCBpLmUuIGlmIHlvdSBoYWQgdGhlIGZvbGxvd2luZ1xuICogICAgVk5vZGUgZWxlbWVudHMgKHJlcHJlc2VudGVkIGFzIEhUTUwpOlxuICpcbiAqICAgIG9sZFZOb2RlOiBgPGRpdj48cD48c3Bhbj5IRVk8L3NwYW4+PC9wPjwvZGl2PmBcbiAqICAgIG5ld1ZOb2RlOiBgPGRpdj48cD48c3Bhbj5USEVSRTwvc3Bhbj48L3A+PC9kaXY+YFxuICpcbiAqICAgIFRoZW4gd2hlbiBjb21wYXJpbmcgdGhlIGNoaWxkcmVuIG9mIHRoZSBgPGRpdj5gIHRhZyB3ZSBjaGVjayB0aGUgZXF1YWxpdHlcbiAqICAgIG9mIHRoZSBWTm9kZXMgY29ycmVzcG9uZGluZyB0byB0aGUgYDxwPmAgdGFncyBhbmQsIHNpbmNlIHRoZXkgYXJlIHRoZVxuICogICAgc2FtZSB0YWcgaW4gdGhlIHNhbWUgcG9zaXRpb24sIHdlJ2QgYmUgYWJsZSB0byBhdm9pZCBjb21wbGV0ZWx5XG4gKiAgICByZS1yZW5kZXJpbmcgdGhlIHN1YnRyZWUgdW5kZXIgdGhlbSB3aXRoIGEgbmV3IERPTSBlbGVtZW50IGFuZCB3b3VsZCBqdXN0XG4gKiAgICBjYWxsIG91dCB0byBgcGF0Y2hgIHRvIGhhbmRsZSByZWNvbmNpbGluZyB0aGVpciBjaGlsZHJlbiBhbmQgc28gb24uXG4gKlxuICogMy4gQ2hlY2ssIGZvciBib3RoIHdpbmRvd3MsIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICogICAgd2luZG93IGNvcnJlc3BvbmRzIHRvIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIG90aGVyIHdpbmRvdy4gVGhpcyBpc1xuICogICAgYSBoZXVyaXN0aWMgd2hpY2ggd2lsbCBsZXQgdXMgaWRlbnRpZnkgX3NvbWVfIHNpdHVhdGlvbnMgaW4gd2hpY2hcbiAqICAgIGVsZW1lbnRzIGhhdmUgY2hhbmdlZCBwb3NpdGlvbiwgZm9yIGluc3RhbmNlIGl0IF9zaG91bGRfIGRldGVjdCB0aGF0IHRoZVxuICogICAgY2hpbGRyZW4gbm9kZXMgdGhlbXNlbHZlcyBoYXZlIG5vdCBjaGFuZ2VkIGJ1dCBtZXJlbHkgbW92ZWQgaW4gdGhlXG4gKiAgICBmb2xsb3dpbmcgZXhhbXBsZTpcbiAqXG4gKiAgICBvbGRWTm9kZTogYDxkaXY+PGVsZW1lbnQtb25lIC8+PGVsZW1lbnQtdHdvIC8+PC9kaXY+YFxuICogICAgbmV3Vk5vZGU6IGA8ZGl2PjxlbGVtZW50LXR3byAvPjxlbGVtZW50LW9uZSAvPjwvZGl2PmBcbiAqXG4gKiAgICBJZiB3ZSBmaW5kIGNhc2VzIGxpa2UgdGhpcyB0aGVuIHdlIGFsc28gbmVlZCB0byBtb3ZlIHRoZSBjb25jcmV0ZSBET01cbiAqICAgIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vdmVkIGNoaWxkcmVuIHRvIHdyaXRlIHRoZSByZS1vcmRlciB0byB0aGVcbiAqICAgIERPTS5cbiAqXG4gKiA0LiBGaW5hbGx5LCBpZiBWTm9kZXMgaGF2ZSB0aGUgYGtleWAgYXR0cmlidXRlIHNldCBvbiB0aGVtIHdlIGNoZWNrIGZvciBhbnlcbiAqICAgIG5vZGVzIGluIHRoZSBvbGQgY2hpbGRyZW4gd2hpY2ggaGF2ZSB0aGUgc2FtZSBrZXkgYXMgdGhlIGZpcnN0IGVsZW1lbnQgaW5cbiAqICAgIG91ciB3aW5kb3cgb24gdGhlIG5ldyBjaGlsZHJlbi4gSWYgd2UgZmluZCBzdWNoIGEgbm9kZSB3ZSBoYW5kbGUgY2FsbGluZ1xuICogICAgb3V0IHRvIGBwYXRjaGAsIG1vdmluZyByZWxldmFudCBET00gbm9kZXMsIGFuZCBzbyBvbiwgaW4gYWNjb3JkYW5jZSB3aXRoXG4gKiAgICB3aGF0IHdlIGZpbmQuXG4gKlxuICogRmluYWxseSwgb25jZSB3ZSd2ZSBuYXJyb3dlZCBvdXIgJ3dpbmRvd3MnIHRvIHRoZSBwb2ludCB0aGF0IGVpdGhlciBvZiB0aGVtXG4gKiBjb2xsYXBzZSAoaS5lLiB0aGV5IGhhdmUgbGVuZ3RoIDApIHdlIHRoZW4gaGFuZGxlIGFueSByZW1haW5pbmcgVk5vZGVcbiAqIGluc2VydGlvbiBvciBkZWxldGlvbiB0aGF0IG5lZWRzIHRvIGhhcHBlbiB0byBnZXQgYSBET00gc3RhdGUgdGhhdCBjb3JyZWN0bHlcbiAqIHJlZmxlY3RzIHRoZSBuZXcgY2hpbGQgVk5vZGVzLiBJZiwgZm9yIGluc3RhbmNlLCBhZnRlciBvdXIgd2luZG93IG9uIHRoZSBvbGRcbiAqIGNoaWxkcmVuIGhhcyBjb2xsYXBzZWQgd2Ugc3RpbGwgaGF2ZSBtb3JlIG5vZGVzIG9uIHRoZSBuZXcgY2hpbGRyZW4gdGhhdFxuICogd2UgaGF2ZW4ndCBkZWFsdCB3aXRoIHlldCB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZW0sIG9yIGlmIHRoZSBuZXcgY2hpbGRyZW5cbiAqIGNvbGxhcHNlIGJ1dCB3ZSBzdGlsbCBoYXZlIHVuaGFuZGxlZCBfb2xkXyBjaGlsZHJlbiB0aGVuIHdlIG5lZWQgdG8gbWFrZVxuICogc3VyZSB0aGUgY29ycmVzcG9uZGluZyBET00gbm9kZXMgYXJlIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHBhcmVudEVsbSB0aGUgbm9kZSBpbnRvIHdoaWNoIHRoZSBwYXJlbnQgVk5vZGUgaXMgcmVuZGVyZWRcbiAqIEBwYXJhbSBvbGRDaCB0aGUgb2xkIGNoaWxkcmVuIG9mIHRoZSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIG5ld1ZOb2RlIHRoZSBuZXcgVk5vZGUgd2hpY2ggd2lsbCByZXBsYWNlIHRoZSBwYXJlbnRcbiAqIEBwYXJhbSBuZXdDaCB0aGUgbmV3IGNoaWxkcmVuIG9mIHRoZSBwYXJlbnQgbm9kZVxuICovXG5jb25zdCB1cGRhdGVDaGlsZHJlbiA9IChwYXJlbnRFbG0sIG9sZENoLCBuZXdWTm9kZSwgbmV3Q2gpID0+IHtcbiAgICBsZXQgb2xkU3RhcnRJZHggPSAwO1xuICAgIGxldCBuZXdTdGFydElkeCA9IDA7XG4gICAgbGV0IGlkeEluT2xkID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICBsZXQgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIGxldCBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIGxldCBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgbGV0IG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZWxtVG9Nb3ZlO1xuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChvbGRTdGFydFZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFZOb2RlIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkRW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3RW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGFydCBub2RlcyBhcmUgdGhlIHNhbWUgdGhlbiB3ZSBzaG91bGQgcGF0Y2ggdGhlIG5ldyBWTm9kZVxuICAgICAgICAgICAgLy8gb250byB0aGUgb2xkIG9uZSwgYW5kIGluY3JlbWVudCBvdXIgYG5ld1N0YXJ0SWR4YCBhbmQgYG9sZFN0YXJ0SWR4YFxuICAgICAgICAgICAgLy8gaW5kaWNlcyB0byByZWZsZWN0IHRoYXQuIFdlIGRvbid0IG5lZWQgdG8gbW92ZSBhbnkgRE9NIE5vZGVzIGFyb3VuZFxuICAgICAgICAgICAgLy8gc2luY2UgdGhpbmdzIGFyZSBtYXRjaGVkIHVwIGluIG9yZGVyLlxuICAgICAgICAgICAgcGF0Y2gob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAgICAgLy8gbGlrZXdpc2UsIGlmIHRoZSBlbmQgbm9kZXMgYXJlIHRoZSBzYW1lIHdlIHBhdGNoIG5ldyBvbnRvIG9sZCBhbmRcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCBvdXIgZW5kIGluZGljZXMsIGFuZCBhbHNvIGxpa2V3aXNlIGluIHRoaXMgY2FzZSB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBtb3ZlIGFueSBET00gTm9kZXMuXG4gICAgICAgICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbW92ZSB0aGUgZWxlbWVudCBmb3IgYG9sZFN0YXJ0Vm5vZGVgIGludG8gYSBwb3NpdGlvbiB3aGljaFxuICAgICAgICAgICAgLy8gd2lsbCBiZSBhcHByb3ByaWF0ZSBmb3IgYG5ld0VuZFZub2RlYC4gRm9yIHRoaXMgd2UgY2FuIHVzZVxuICAgICAgICAgICAgLy8gYC5pbnNlcnRCZWZvcmVgIGFuZCBgb2xkRW5kVm5vZGUuJGVsbSQubmV4dFNpYmxpbmdgLiBJZiB0aGVyZSBpcyBhXG4gICAgICAgICAgICAvLyBzaWJsaW5nIGZvciBgb2xkRW5kVm5vZGUuJGVsbSRgIHRoZW4gd2Ugd2FudCB0byBtb3ZlIHRoZSBET00gbm9kZSBmb3JcbiAgICAgICAgICAgIC8vIGBvbGRTdGFydFZub2RlYCBiZXR3ZWVuIGBvbGRFbmRWbm9kZWAgYW5kIGl0J3Mgc2libGluZywgbGlrZSBzbzpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyA8b2xkLXN0YXJ0LW5vZGUgLz5cbiAgICAgICAgICAgIC8vIDxzb21lLWludGVydmVuaW5nLW5vZGUgLz5cbiAgICAgICAgICAgIC8vIDxvbGQtZW5kLW5vZGUgLz5cbiAgICAgICAgICAgIC8vIDwhLS0gLT4gICAgICAgICAgICAgIDwtLSBgb2xkU3RhcnRWbm9kZS4kZWxtJGAgc2hvdWxkIGJlIGluc2VydGVkIGhlcmVcbiAgICAgICAgICAgIC8vIDxuZXh0LXNpYmxpbmcgLz5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiBpbnN0ZWFkIGBvbGRFbmRWbm9kZS4kZWxtJGAgaGFzIG5vIHNpYmxpbmcgdGhlbiB3ZSBqdXN0IHdhbnQgdG8gcHV0XG4gICAgICAgICAgICAvLyB0aGUgbm9kZSBmb3IgYG9sZFN0YXJ0Vm5vZGVgIGF0IHRoZSBlbmQgb2YgdGhlIGNoaWxkcmVuIG9mXG4gICAgICAgICAgICAvLyBgcGFyZW50RWxtYC4gTHVja2lseSwgYE5vZGUubmV4dFNpYmxpbmdgIHdpbGwgcmV0dXJuIGBudWxsYCBpZiB0aGVyZVxuICAgICAgICAgICAgLy8gYXJlbid0IGFueSBzaWJsaW5ncywgYW5kIHBhc3NpbmcgYG51bGxgIHRvIGBOb2RlLmluc2VydEJlZm9yZWAgd2lsbFxuICAgICAgICAgICAgLy8gYXBwZW5kIGl0IHRvIHRoZSBjaGlsZHJlbiBvZiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZFN0YXJ0Vm5vZGUuJGVsbSQsIG9sZEVuZFZub2RlLiRlbG0kLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2gob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBjaGVja2VkIGFib3ZlIGlmIGBvbGRTdGFydFZub2RlYCBhbmQgYG5ld1N0YXJ0Vm5vZGVgIGFyZVxuICAgICAgICAgICAgLy8gdGhlIHNhbWUgbm9kZSwgc28gc2luY2Ugd2UncmUgaGVyZSB3ZSBrbm93IHRoYXQgdGhleSBhcmUgbm90LiBUaHVzIHdlXG4gICAgICAgICAgICAvLyBjYW4gbW92ZSB0aGUgZWxlbWVudCBmb3IgYG9sZEVuZFZub2RlYCBfYmVmb3JlXyB0aGUgZWxlbWVudCBmb3JcbiAgICAgICAgICAgIC8vIGBvbGRTdGFydFZub2RlYCwgbGVhdmluZyBgb2xkU3RhcnRWbm9kZWAgdG8gYmUgcmVjb25jaWxlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGZ1dHVyZS5cbiAgICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUob2xkRW5kVm5vZGUuJGVsbSQsIG9sZFN0YXJ0Vm5vZGUuJGVsbSQpO1xuICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIZXJlIHdlIGRvIHNvbWUgY2hlY2tzIHRvIG1hdGNoIHVwIG9sZCBhbmQgbmV3IG5vZGVzIGJhc2VkIG9uIHRoZVxuICAgICAgICAgICAgLy8gYCRrZXkkYCBhdHRyaWJ1dGUsIHdoaWNoIGlzIHNldCBieSBwdXR0aW5nIGEgYGtleT1cIm15LWtleVwiYCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIC8vIGluIHRoZSBKU1ggZm9yIGEgRE9NIGVsZW1lbnQgaW4gdGhlIGltcGxlbWVudGF0aW9uIG9mIGEgU3RlbmNpbFxuICAgICAgICAgICAgLy8gY29tcG9uZW50LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IG5vZGVzIGluIHRoZSBhcnJheSBvZiBvbGRcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIHdoaWNoIGhhdmUgdGhlIHNhbWUga2V5IGFzIHRoZSBmaXJzdCBub2RlIGluIHRoZSBuZXdcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuLlxuICAgICAgICAgICAgaWR4SW5PbGQgPSAtMTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBvbGRTdGFydElkeDsgaSA8PSBvbGRFbmRJZHg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkQ2hbaV0gJiYgb2xkQ2hbaV0uJGtleSQgIT09IG51bGwgJiYgb2xkQ2hbaV0uJGtleSQgPT09IG5ld1N0YXJ0Vm5vZGUuJGtleSQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeEluT2xkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkeEluT2xkID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG5vZGUgaW4gdGhlIG9sZCBjaGlsZHJlbiB3aGljaCBtYXRjaGVzIHVwIHdpdGggdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gbm9kZSBpbiB0aGUgbmV3IGNoaWxkcmVuISBTbyBsZXQncyBkZWFsIHdpdGggdGhhdFxuICAgICAgICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxtVG9Nb3ZlLiR0YWckICE9PSBuZXdTdGFydFZub2RlLiR0YWckKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0YWcgZG9lc24ndCBtYXRjaCBzbyB3ZSdsbCBuZWVkIGEgbmV3IERPTSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVFbG0ob2xkQ2ggJiYgb2xkQ2hbbmV3U3RhcnRJZHhdLCBuZXdWTm9kZSwgaWR4SW5PbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZGF0ZSB0aGUgbWF0Y2hpbmcgb2xkIG5vZGUgc28gdGhhdCB3ZSB3b24ndCB0cnkgdG8gdXBkYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFnYWluIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsbVRvTW92ZS4kZWxtJDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZWl0aGVyIGRpZG4ndCBmaW5kIGFuIGVsZW1lbnQgaW4gdGhlIG9sZCBjaGlsZHJlbiB0aGF0IG1hdGNoZXNcbiAgICAgICAgICAgICAgICAvLyB0aGUga2V5IG9mIHRoZSBmaXJzdCBuZXcgY2hpbGQgT1IgdGhlIGJ1aWxkIGlzIG5vdCB1c2luZyBga2V5YFxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgYXQgYWxsLiBJbiBlaXRoZXIgY2FzZSB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBuZXcgbm9kZS5cbiAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNyZWF0ZWQgYSBuZXcgbm9kZSB0aGVuIGhhbmRsZSBpbnNlcnRpbmcgaXQgdG8gdGhlIERPTVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvbGRTdGFydFZub2RlLiRlbG0kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICAgIC8vIHdlIGhhdmUgc29tZSBtb3JlIG5ldyBub2RlcyB0byBhZGQgd2hpY2ggZG9uJ3QgbWF0Y2ggdXAgd2l0aCBvbGQgbm9kZXNcbiAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgbmV3Q2hbbmV3RW5kSWR4ICsgMV0gPT0gbnVsbCA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS4kZWxtJCwgbmV3Vk5vZGUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgICAgLy8gdGhlcmUgYXJlIG5vZGVzIGluIHRoZSBgb2xkQ2hgIGFycmF5IHdoaWNoIG5vIGxvbmdlciBjb3JyZXNwb25kIHRvIG5vZGVzXG4gICAgICAgIC8vIGluIHRoZSBuZXcgYXJyYXksIHNvIGxldHMgcmVtb3ZlIHRoZW0gKHdoaWNoIGVudGFpbHMgY2xlYW5pbmcgdXAgdGhlXG4gICAgICAgIC8vIHJlbGV2YW50IERPTSBub2RlcylcbiAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG59O1xuLyoqXG4gKiBDb21wYXJlIHR3byBWTm9kZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIHRoZSBzYW1lXG4gKlxuICogKipOQioqOiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGVxdWFsaXR5IF9oZXVyaXN0aWNfIGJhc2VkIG9uIHRoZSBhdmFpbGFibGVcbiAqIGluZm9ybWF0aW9uIHNldCBvbiB0aGUgdHdvIFZOb2RlcyBhbmQgY2FuIGJlIG1pc2xlYWRpbmcgdW5kZXIgY2VydGFpblxuICogY2lyY3Vtc3RhbmNlcy4gSW4gcGFydGljdWxhciwgaWYgdGhlIHR3byBub2RlcyBkbyBub3QgaGF2ZSBga2V5YCBhdHRyc1xuICogKGF2YWlsYWJsZSB1bmRlciBgJGtleSRgIG9uIFZOb2RlcykgdGhlbiB0aGUgZnVuY3Rpb24gZmFsbHMgYmFjayBvbiBtZXJlbHlcbiAqIGNoZWNraW5nIHRoYXQgdGhleSBoYXZlIHRoZSBzYW1lIHRhZy5cbiAqXG4gKiBTbywgaW4gb3RoZXIgd29yZHMsIGlmIGBrZXlgIGF0dHJzIGFyZSBub3Qgc2V0IG9uIFZOb2RlcyB3aGljaCBtYXkgYmVcbiAqIGNoYW5naW5nIG9yZGVyIHdpdGhpbiBhIGBjaGlsZHJlbmAgYXJyYXkgb3Igc29tZXRoaW5nIGFsb25nIHRob3NlIGxpbmVzIHRoZW5cbiAqIHdlIGNvdWxkIG9idGFpbiBhIGZhbHNlIHBvc2l0aXZlIGFuZCB0aGVuIGhhdmUgdG8gZG8gbmVlZGxlc3MgcmUtcmVuZGVyaW5nLlxuICpcbiAqIEBwYXJhbSBsZWZ0Vk5vZGUgdGhlIGZpcnN0IFZOb2RlIHRvIGNoZWNrXG4gKiBAcGFyYW0gcmlnaHRWTm9kZSB0aGUgc2Vjb25kIFZOb2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZXkncmUgZXF1YWwgb3Igbm90XG4gKi9cbmNvbnN0IGlzU2FtZVZub2RlID0gKGxlZnRWTm9kZSwgcmlnaHRWTm9kZSkgPT4ge1xuICAgIC8vIGNvbXBhcmUgaWYgdHdvIHZub2RlIHRvIHNlZSBpZiB0aGV5J3JlIFwidGVjaG5pY2FsbHlcIiB0aGUgc2FtZVxuICAgIC8vIG5lZWQgdG8gaGF2ZSB0aGUgc2FtZSBlbGVtZW50IHRhZywgYW5kIHNhbWUga2V5IHRvIGJlIHRoZSBzYW1lXG4gICAgaWYgKGxlZnRWTm9kZS4kdGFnJCA9PT0gcmlnaHRWTm9kZS4kdGFnJCkge1xuICAgICAgICAvLyB0aGlzIHdpbGwgYmUgc2V0IGlmIGNvbXBvbmVudHMgaW4gdGhlIGJ1aWxkIGhhdmUgYGtleWAgYXR0cnMgc2V0IG9uIHRoZW1cbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnRWTm9kZS4ka2V5JCA9PT0gcmlnaHRWTm9kZS4ka2V5JDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBIYW5kbGUgcmVjb25jaWxpbmcgYW4gb3V0ZGF0ZWQgVk5vZGUgd2l0aCBhIG5ldyBvbmUgd2hpY2ggY29ycmVzcG9uZHMgdG9cbiAqIGl0LiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgZmx1c2hpbmcgdXBkYXRlcyB0byB0aGUgRE9NIGFuZCByZWNvbmNpbGluZyB0aGVcbiAqIGNoaWxkcmVuIG9mIHRoZSB0d28gbm9kZXMgKGlmIGFueSkuXG4gKlxuICogQHBhcmFtIG9sZFZOb2RlIGFuIG9sZCBWTm9kZSB3aG9zZSBET00gZWxlbWVudCBhbmQgY2hpbGRyZW4gd2Ugd2FudCB0byB1cGRhdGVcbiAqIEBwYXJhbSBuZXdWTm9kZSBhIG5ldyBWTm9kZSByZXByZXNlbnRpbmcgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBvbGQgb25lXG4gKi9cbmNvbnN0IHBhdGNoID0gKG9sZFZOb2RlLCBuZXdWTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsbSA9IChuZXdWTm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kKTtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IG9sZFZOb2RlLiRjaGlsZHJlbiQ7XG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZS4kY2hpbGRyZW4kO1xuICAgIGNvbnN0IHRhZyA9IG5ld1ZOb2RlLiR0YWckO1xuICAgIGNvbnN0IHRleHQgPSBuZXdWTm9kZS4kdGV4dCQ7XG4gICAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGVzdCBpZiB3ZSdyZSByZW5kZXJpbmcgYW4gc3ZnIGVsZW1lbnQsIG9yIHN0aWxsIHJlbmRlcmluZyBub2RlcyBpbnNpZGUgb2Ygb25lXG4gICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGlzIHRvIHRoZSB3aGVuIHRoZSBjb21waWxlciBzZWVzIHdlJ3JlIHVzaW5nIGFuIHN2ZyBzb21ld2hlcmVcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IHRhZyA9PT0gJ3N2ZycgPyB0cnVlIDogdGFnID09PSAnZm9yZWlnbk9iamVjdCcgPyBmYWxzZSA6IGlzU3ZnTW9kZTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGFnID09PSAnc2xvdCcpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBvZiBhbiBlbGVtZW50IE9SIGl0J3MgYW4gdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gQU5EIHdlIGFscmVhZHkga25vdyBpdCdzIHBvc3NpYmxlIGl0IGNvdWxkIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdXBkYXRlcyB0aGUgZWxlbWVudCdzIGNzcyBjbGFzc2VzLCBhdHRycywgcHJvcHMsIGxpc3RlbmVycywgZXRjLlxuICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnQob2xkVk5vZGUsIG5ld1ZOb2RlLCBpc1N2Z01vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRDaGlsZHJlbiAhPT0gbnVsbCAmJiBuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB0aGVyZSdzIGNoaWxkIHZub2RlcyBmb3IgYm90aCB0aGUgb2xkIGFuZCBuZXcgdm5vZGVzXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGNhbGwgYHVwZGF0ZUNoaWxkcmVuYCB0byByZWNvbmNpbGUgdGhlbVxuICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaGlsZHJlbiwgbmV3Vk5vZGUsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gb2xkIGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBuZXcgY2hpbGQgdm5vZGVzIHRvIGFkZFxuICAgICAgICAgICAgaWYgKG9sZFZOb2RlLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdm5vZGUgd2FzIHRleHQsIHNvIGJlIHN1cmUgdG8gY2xlYXIgaXQgb3V0XG4gICAgICAgICAgICAgICAgZWxtLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgdGhlIG5ldyB2bm9kZSBjaGlsZHJlblxuICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgbmV3Vk5vZGUsIG5ld0NoaWxkcmVuLCAwLCBuZXdDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRDaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkIHZub2RlcywgYnV0IHRoZXJlIGFyZSBvbGQgY2hpbGQgdm5vZGVzIHRvIHJlbW92ZVxuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoaWxkcmVuLCAwLCBvbGRDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdmdNb2RlICYmIHRhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG9sZFZOb2RlLiR0ZXh0JCAhPT0gdGV4dCkge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHRleHQgY29udGVudCBmb3IgdGhlIHRleHQgb25seSB2bm9kZVxuICAgICAgICAvLyBhbmQgYWxzbyBvbmx5IGlmIHRoZSB0ZXh0IGlzIGRpZmZlcmVudCB0aGFuIGJlZm9yZVxuICAgICAgICBlbG0uZGF0YSA9IHRleHQ7XG4gICAgfVxufTtcbmNvbnN0IGNhbGxOb2RlUmVmcyA9ICh2Tm9kZSkgPT4ge1xuICAgIHtcbiAgICAgICAgdk5vZGUuJGF0dHJzJCAmJiB2Tm9kZS4kYXR0cnMkLnJlZiAmJiB2Tm9kZS4kYXR0cnMkLnJlZihudWxsKTtcbiAgICAgICAgdk5vZGUuJGNoaWxkcmVuJCAmJiB2Tm9kZS4kY2hpbGRyZW4kLm1hcChjYWxsTm9kZVJlZnMpO1xuICAgIH1cbn07XG5jb25zdCByZW5kZXJWZG9tID0gKGhvc3RSZWYsIHJlbmRlckZuUmVzdWx0cykgPT4ge1xuICAgIGNvbnN0IGhvc3RFbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IG9sZFZOb2RlID0gaG9zdFJlZi4kdm5vZGUkIHx8IG5ld1ZOb2RlKG51bGwsIG51bGwpO1xuICAgIGNvbnN0IHJvb3RWbm9kZSA9IGlzSG9zdChyZW5kZXJGblJlc3VsdHMpID8gcmVuZGVyRm5SZXN1bHRzIDogaChudWxsLCBudWxsLCByZW5kZXJGblJlc3VsdHMpO1xuICAgIGhvc3RUYWdOYW1lID0gaG9zdEVsbS50YWdOYW1lO1xuICAgIGlmIChjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQpIHtcbiAgICAgICAgcm9vdFZub2RlLiRhdHRycyQgPSByb290Vm5vZGUuJGF0dHJzJCB8fCB7fTtcbiAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkLm1hcCgoW3Byb3BOYW1lLCBhdHRyaWJ1dGVdKSA9PiAocm9vdFZub2RlLiRhdHRycyRbYXR0cmlidXRlXSA9IGhvc3RFbG1bcHJvcE5hbWVdKSk7XG4gICAgfVxuICAgIHJvb3RWbm9kZS4kdGFnJCA9IG51bGw7XG4gICAgcm9vdFZub2RlLiRmbGFncyQgfD0gNCAvKiBWTk9ERV9GTEFHUy5pc0hvc3QgKi87XG4gICAgaG9zdFJlZi4kdm5vZGUkID0gcm9vdFZub2RlO1xuICAgIHJvb3RWbm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kID0gKGhvc3RFbG0uc2hhZG93Um9vdCB8fCBob3N0RWxtICk7XG4gICAge1xuICAgICAgICBzY29wZUlkID0gaG9zdEVsbVsncy1zYyddO1xuICAgIH1cbiAgICAvLyBzeW5jaHJvbm91cyBwYXRjaFxuICAgIHBhdGNoKG9sZFZOb2RlLCByb290Vm5vZGUpO1xufTtcbmNvbnN0IGF0dGFjaFRvQW5jZXN0b3IgPSAoaG9zdFJlZiwgYW5jZXN0b3JDb21wb25lbnQpID0+IHtcbiAgICBpZiAoYW5jZXN0b3JDb21wb25lbnQgJiYgIWhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgJiYgYW5jZXN0b3JDb21wb25lbnRbJ3MtcCddKSB7XG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXS5wdXNoKG5ldyBQcm9taXNlKChyKSA9PiAoaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCA9IHIpKSk7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVkdWxlVXBkYXRlID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxNiAvKiBIT1NUX0ZMQUdTLmlzUXVldWVkRm9yVXBkYXRlICovO1xuICAgIH1cbiAgICBpZiAoaG9zdFJlZi4kZmxhZ3MkICYgNCAvKiBIT1NUX0ZMQUdTLmlzV2FpdGluZ0ZvckNoaWxkcmVuICovKSB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSA1MTIgLyogSE9TVF9GTEFHUy5uZWVkc1JlcmVuZGVyICovO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF0dGFjaFRvQW5jZXN0b3IoaG9zdFJlZiwgaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkKTtcbiAgICAvLyB0aGVyZSBpcyBubyBhbmNlc3RvciBjb21wb25lbnQgb3IgdGhlIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgIC8vIGhhcyBhbHJlYWR5IGZpcmVkIG9mZiBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB0aGVuXG4gICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgY29uc3QgZGlzcGF0Y2ggPSAoKSA9PiBkaXNwYXRjaEhvb2tzKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpO1xuICAgIHJldHVybiB3cml0ZVRhc2soZGlzcGF0Y2gpIDtcbn07XG5jb25zdCBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICBjb25zdCBlbmRTY2hlZHVsZSA9IGNyZWF0ZVRpbWUoJ3NjaGVkdWxlVXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgO1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmIChpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAyNTYgLyogSE9TVF9GTEFHUy5pc0xpc3RlblJlYWR5ICovO1xuICAgICAgICAgICAgaWYgKGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQpIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRxdWV1ZWRMaXN0ZW5lcnMkLm1hcCgoW21ldGhvZE5hbWUsIGV2ZW50XSkgPT4gc2FmZUNhbGwoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbExvYWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICAgIHByb21pc2UgPSB0aGVuKHByb21pc2UsICgpID0+IHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50V2lsbFJlbmRlcicpKTtcbiAgICB9XG4gICAgZW5kU2NoZWR1bGUoKTtcbiAgICByZXR1cm4gdGhlbihwcm9taXNlLCAoKSA9PiB1cGRhdGVDb21wb25lbnQoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpKTtcbn07XG5jb25zdCB1cGRhdGVDb21wb25lbnQgPSBhc3luYyAoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQ7XG4gICAgY29uc3QgZW5kVXBkYXRlID0gY3JlYXRlVGltZSgndXBkYXRlJywgaG9zdFJlZi4kY21wTWV0YSQuJHRhZ05hbWUkKTtcbiAgICBjb25zdCByYyA9IGVsbVsncy1yYyddO1xuICAgIGlmIChpc0luaXRpYWxMb2FkKSB7XG4gICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgYXR0YWNoU3R5bGVzKGhvc3RSZWYpO1xuICAgIH1cbiAgICBjb25zdCBlbmRSZW5kZXIgPSBjcmVhdGVUaW1lKCdyZW5kZXInLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICAgIHtcbiAgICAgICAgY2FsbFJlbmRlcihob3N0UmVmLCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChyYykge1xuICAgICAgICAvLyBvaywgc28gdHVybnMgb3V0IHRoZXJlIGFyZSBzb21lIGNoaWxkIGhvc3QgZWxlbWVudHNcbiAgICAgICAgLy8gd2FpdGluZyBvbiB0aGlzIHBhcmVudCBlbGVtZW50IHRvIGxvYWRcbiAgICAgICAgLy8gbGV0J3MgZmlyZSBvZmYgYWxsIHVwZGF0ZSBjYWxsYmFja3Mgd2FpdGluZ1xuICAgICAgICByYy5tYXAoKGNiKSA9PiBjYigpKTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuZFJlbmRlcigpO1xuICAgIGVuZFVwZGF0ZSgpO1xuICAgIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Qcm9taXNlcyA9IGVsbVsncy1wJ107XG4gICAgICAgIGNvbnN0IHBvc3RVcGRhdGUgPSAoKSA9PiBwb3N0VXBkYXRlQ29tcG9uZW50KGhvc3RSZWYpO1xuICAgICAgICBpZiAoY2hpbGRyZW5Qcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBvc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNoaWxkcmVuUHJvbWlzZXMpLnRoZW4ocG9zdFVwZGF0ZSk7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNCAvKiBIT1NUX0ZMQUdTLmlzV2FpdGluZ0ZvckNoaWxkcmVuICovO1xuICAgICAgICAgICAgY2hpbGRyZW5Qcm9taXNlcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmVuZGVyKCkgO1xuICAgICAgICB7XG4gICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgJj0gfjE2IC8qIEhPU1RfRkxBR1MuaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDIgLyogSE9TVF9GTEFHUy5oYXNSZW5kZXJlZCAqLztcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gbG9va3MgbGlrZSB3ZSd2ZSBnb3QgY2hpbGQgbm9kZXMgdG8gcmVuZGVyIGludG8gdGhpcyBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBvciB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgY3NzIGNsYXNzL2F0dHJzIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBET00gV1JJVEUhXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJWZG9tKGhvc3RSZWYsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUsIGhvc3RSZWYuJGhvc3RFbGVtZW50JCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IHBvc3RVcGRhdGVDb21wb25lbnQgPSAoaG9zdFJlZikgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQ7XG4gICAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICAgIGNvbnN0IGVuZFBvc3RVcGRhdGUgPSBjcmVhdGVUaW1lKCdwb3N0VXBkYXRlJywgdGFnTmFtZSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBob3N0UmVmLiRsYXp5SW5zdGFuY2UkIDtcbiAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudCA9IGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JDtcbiAgICB7XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkUmVuZGVyJyk7XG4gICAgfVxuICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDY0IC8qIEhPU1RfRkxBR1MuaGFzTG9hZGVkQ29tcG9uZW50ICovKSkge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gNjQgLyogSE9TVF9GTEFHUy5oYXNMb2FkZWRDb21wb25lbnQgKi87XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIERPTSBXUklURSFcbiAgICAgICAgICAgIGFkZEh5ZHJhdGVkRmxhZyhlbG0pO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29tcG9uZW50RGlkTG9hZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVuZFBvc3RVcGRhdGUoKTtcbiAgICAgICAge1xuICAgICAgICAgICAgaG9zdFJlZi4kb25SZWFkeVJlc29sdmUkKGVsbSk7XG4gICAgICAgICAgICBpZiAoIWFuY2VzdG9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgYXBwRGlkTG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgICBzYWZlQ2FsbChpbnN0YW5jZSwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGVuZFBvc3RVcGRhdGUoKTtcbiAgICB9XG4gICAge1xuICAgICAgICBob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQoZWxtKTtcbiAgICB9XG4gICAgLy8gbG9hZCBldmVudHMgZmlyZSBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICAvLyB0aGUgZGVlcGVzdCBlbGVtZW50cyBsb2FkIGZpcnN0IHRoZW4gYnViYmxlcyB1cFxuICAgIHtcbiAgICAgICAgaWYgKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQpIHtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQoKTtcbiAgICAgICAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RSZWYuJGZsYWdzJCAmIDUxMiAvKiBIT1NUX0ZMQUdTLm5lZWRzUmVyZW5kZXIgKi8pIHtcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4oNCAvKiBIT1NUX0ZMQUdTLmlzV2FpdGluZ0ZvckNoaWxkcmVuICovIHwgNTEyIC8qIEhPU1RfRkxBR1MubmVlZHNSZXJlbmRlciAqLyk7XG4gICAgfVxuICAgIC8vICgg4oCiX+KAoilcbiAgICAvLyAoIOKAol/igKIpPuKMkOKWoC3ilqBcbiAgICAvLyAo4oyQ4pagX+KWoClcbn07XG5jb25zdCBmb3JjZVVwZGF0ZSA9IChyZWYpID0+IHtcbiAgICB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkLmlzQ29ubmVjdGVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQgJiZcbiAgICAgICAgICAgIChob3N0UmVmLiRmbGFncyQgJiAoMiAvKiBIT1NUX0ZMQUdTLmhhc1JlbmRlcmVkICovIHwgMTYgLyogSE9TVF9GTEFHUy5pc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIEhPU1RfRkxBR1MuaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIFwidHJ1ZVwiIHdoZW4gdGhlIGZvcmNlZCB1cGRhdGUgd2FzIHN1Y2Nlc3NmdWxseSBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuIGlzQ29ubmVjdGVkO1xuICAgIH1cbn07XG5jb25zdCBhcHBEaWRMb2FkID0gKHdobykgPT4ge1xuICAgIC8vIG9uIGFwcGxvYWRcbiAgICAvLyB3ZSBoYXZlIGZpbmlzaCB0aGUgZmlyc3QgYmlnIGluaXRpYWwgcmVuZGVyXG4gICAge1xuICAgICAgICBhZGRIeWRyYXRlZEZsYWcoZG9jLmRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICAgIG5leHRUaWNrKCgpID0+IGVtaXRFdmVudCh3aW4sICdhcHBsb2FkJywgeyBkZXRhaWw6IHsgbmFtZXNwYWNlOiBOQU1FU1BBQ0UgfSB9KSk7XG59O1xuY29uc3Qgc2FmZUNhbGwgPSAoaW5zdGFuY2UsIG1ldGhvZCwgYXJnKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlW21ldGhvZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmNvbnN0IHRoZW4gPSAocHJvbWlzZSwgdGhlbkZuKSA9PiB7XG4gICAgcmV0dXJuIHByb21pc2UgJiYgcHJvbWlzZS50aGVuID8gcHJvbWlzZS50aGVuKHRoZW5GbikgOiB0aGVuRm4oKTtcbn07XG5jb25zdCBhZGRIeWRyYXRlZEZsYWcgPSAoZWxtKSA9PiBlbG0uY2xhc3NMaXN0LmFkZCgnaHlkcmF0ZWQnKVxuICAgIDtcbmNvbnN0IGdldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUpID0+IGdldEhvc3RSZWYocmVmKS4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG5jb25zdCBzZXRWYWx1ZSA9IChyZWYsIHByb3BOYW1lLCBuZXdWYWwsIGNtcE1ldGEpID0+IHtcbiAgICAvLyBjaGVjayBvdXIgbmV3IHByb3BlcnR5IHZhbHVlIGFnYWluc3Qgb3VyIGludGVybmFsIHZhbHVlXG4gICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYocmVmKTtcbiAgICBjb25zdCBlbG0gPSBob3N0UmVmLiRob3N0RWxlbWVudCQgO1xuICAgIGNvbnN0IG9sZFZhbCA9IGhvc3RSZWYuJGluc3RhbmNlVmFsdWVzJC5nZXQocHJvcE5hbWUpO1xuICAgIGNvbnN0IGZsYWdzID0gaG9zdFJlZi4kZmxhZ3MkO1xuICAgIGNvbnN0IGluc3RhbmNlID0gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA7XG4gICAgbmV3VmFsID0gcGFyc2VQcm9wZXJ0eVZhbHVlKG5ld1ZhbCwgY21wTWV0YS4kbWVtYmVycyRbcHJvcE5hbWVdWzBdKTtcbiAgICAvLyBleHBsaWNpdGx5IGNoZWNrIGZvciBOYU4gb24gYm90aCBzaWRlcywgYXMgYE5hTiA9PT0gTmFOYCBpcyBhbHdheXMgZmFsc2VcbiAgICBjb25zdCBhcmVCb3RoTmFOID0gTnVtYmVyLmlzTmFOKG9sZFZhbCkgJiYgTnVtYmVyLmlzTmFOKG5ld1ZhbCk7XG4gICAgY29uc3QgZGlkVmFsdWVDaGFuZ2UgPSBuZXdWYWwgIT09IG9sZFZhbCAmJiAhYXJlQm90aE5hTjtcbiAgICBpZiAoKCEoZmxhZ3MgJiA4IC8qIEhPU1RfRkxBR1MuaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgfHwgb2xkVmFsID09PSB1bmRlZmluZWQpICYmIGRpZFZhbHVlQ2hhbmdlKSB7XG4gICAgICAgIC8vIGdhZHpvb2tzISB0aGUgcHJvcGVydHkncyB2YWx1ZSBoYXMgY2hhbmdlZCEhXG4gICAgICAgIC8vIHNldCBvdXIgbmV3IHZhbHVlIVxuICAgICAgICBob3N0UmVmLiRpbnN0YW5jZVZhbHVlcyQuc2V0KHByb3BOYW1lLCBuZXdWYWwpO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBtZXRob2QgbmFtZXMgb2Ygd2F0Y2ggZnVuY3Rpb25zIHRvIGNhbGxcbiAgICAgICAgICAgIGlmIChjbXBNZXRhLiR3YXRjaGVycyQgJiYgZmxhZ3MgJiAxMjggLyogSE9TVF9GTEFHUy5pc1dhdGNoUmVhZHkgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRjaE1ldGhvZHMgPSBjbXBNZXRhLiR3YXRjaGVycyRbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaE1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpbnN0YW5jZSBpcyB3YXRjaGluZyBmb3Igd2hlbiB0aGlzIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hNZXRob2RzLm1hcCgod2F0Y2hNZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgb2ZmIGVhY2ggb2YgdGhlIHdhdGNoIG1ldGhvZHMgdGhhdCBhcmUgd2F0Y2hpbmcgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW3dhdGNoTWV0aG9kTmFtZV0obmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAoMiAvKiBIT1NUX0ZMQUdTLmhhc1JlbmRlcmVkICovIHwgMTYgLyogSE9TVF9GTEFHUy5pc1F1ZXVlZEZvclVwZGF0ZSAqLykpID09PSAyIC8qIEhPU1RfRkxBR1MuaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUobmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBsb29rcyBsaWtlIHRoaXMgdmFsdWUgYWN0dWFsbHkgY2hhbmdlZCwgc28gd2UndmUgZ290IHdvcmsgdG8gZG8hXG4gICAgICAgICAgICAgICAgLy8gYnV0IG9ubHkgaWYgd2UndmUgYWxyZWFkeSByZW5kZXJlZCwgb3RoZXJ3aXNlIGp1c3QgY2hpbGwgb3V0XG4gICAgICAgICAgICAgICAgLy8gcXVldWUgdGhhdCB3ZSBuZWVkIHRvIGRvIGFuIHVwZGF0ZSwgYnV0IGRvbid0IHdvcnJ5IGFib3V0IHF1ZXVpbmdcbiAgICAgICAgICAgICAgICAvLyB1cCBtaWxsaW9ucyBjdXogdGhpcyBmdW5jdGlvbiBlbnN1cmVzIGl0IG9ubHkgcnVucyBvbmNlXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQXR0YWNoIGEgc2VyaWVzIG9mIHJ1bnRpbWUgY29uc3RydWN0cyB0byBhIGNvbXBpbGVkIFN0ZW5jaWwgY29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIHRoZSBgQFByb3BgIGFuZCBgQFN0YXRlYFxuICogZGVjb3JhdG9ycywgY2FsbGJhY2tzIGZvciB3aGVuIGF0dHJpYnV0ZXMgY2hhbmdlLCBhbmQgc28gb24uXG4gKlxuICogQHBhcmFtIENzdHIgdGhlIGNvbnN0cnVjdG9yIGZvciBhIGNvbXBvbmVudCB0aGF0IHdlIG5lZWQgdG8gcHJvY2Vzc1xuICogQHBhcmFtIGNtcE1ldGEgbWV0YWRhdGEgY29sbGVjdGVkIHByZXZpb3VzbHkgYWJvdXQgdGhlIGNvbXBvbmVudFxuICogQHBhcmFtIGZsYWdzIGEgbnVtYmVyIHVzZWQgdG8gc3RvcmUgYSBzZXJpZXMgb2YgYml0IGZsYWdzXG4gKiBAcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBjb25zdHJ1Y3RvciBwYXNzZWQgaW4gKGJ1dCBub3cgbXV0YXRlZClcbiAqL1xuY29uc3QgcHJveHlDb21wb25lbnQgPSAoQ3N0ciwgY21wTWV0YSwgZmxhZ3MpID0+IHtcbiAgICBpZiAoY21wTWV0YS4kbWVtYmVycyQpIHtcbiAgICAgICAgaWYgKENzdHIud2F0Y2hlcnMpIHtcbiAgICAgICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IENzdHIud2F0Y2hlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gaGF2ZSBhIGNvbnN0IHRoYW4gdHdvIE9iamVjdC5lbnRyaWVzKClcbiAgICAgICAgY29uc3QgbWVtYmVycyA9IE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKTtcbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gQ3N0ci5wcm90b3R5cGU7XG4gICAgICAgIG1lbWJlcnMubWFwKChbbWVtYmVyTmFtZSwgW21lbWJlckZsYWdzXV0pID0+IHtcbiAgICAgICAgICAgIGlmICgobWVtYmVyRmxhZ3MgJiAzMSAvKiBNRU1CRVJfRkxBR1MuUHJvcCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAoKGZsYWdzICYgMiAvKiBQUk9YWV9GTEFHUy5wcm94eVN0YXRlICovKSAmJiBtZW1iZXJGbGFncyAmIDMyIC8qIE1FTUJFUl9GTEFHUy5TdGF0ZSAqLykpKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQgLSBwcm9wXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCwgZ2V0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUodGhpcywgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJveHlDb21wb25lbnQsIHNldCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUodGhpcywgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGNtcE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmbGFncyAmIDEgLyogUFJPWFlfRkxBR1MuaXNFbGVtZW50Q29uc3RydWN0b3IgKi8gJiZcbiAgICAgICAgICAgICAgICBtZW1iZXJGbGFncyAmIDY0IC8qIE1FTUJFUl9GTEFHUy5NZXRob2QgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm94eUNvbXBvbmVudCAtIG1ldGhvZFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWYuJG9uSW5zdGFuY2VQcm9taXNlJC50aGVuKCgpID0+IHJlZi4kbGF6eUluc3RhbmNlJFttZW1iZXJOYW1lXSguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKGZsYWdzICYgMSAvKiBQUk9YWV9GTEFHUy5pc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lVG9Qcm9wTmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwbHQuam1wKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBhdHRyTmFtZVRvUHJvcE5hbWUuZ2V0KGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluIGEgd2ViIGNvbXBvbmVudCBsaWZlY3ljbGUgdGhlIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBydW5zIHByaW9yIHRvIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vICBpbiB0aGUgY2FzZSB3aGVyZSBhbiBhdHRyaWJ1dGUgd2FzIHNldCBpbmxpbmUuXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDxteS1jb21wb25lbnQgc29tZS1hdHRyaWJ1dGU9XCJzb21lLXZhbHVlXCI+PC9teS1jb21wb25lbnQ+XG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZXJlIGlzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGRldmVsb3BlciBzZXRzIHRoZSBhdHRyaWJ1dGUgaW5saW5lIG9uIGEgY3VzdG9tIGVsZW1lbnQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyBpdCBiZWZvcmUgaXQgaGFzIGJlZW4gdXBncmFkZWQgYXMgc2hvd24gYmVsb3c6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBgYGBodG1sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIDwhLS0gdGhpcyBjb21wb25lbnQgaGFzIF9ub3RfIGJlZW4gdXBncmFkZWQgeWV0IC0tPlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8bXktY29tcG9uZW50IGlkPVwidGVzdFwiIHNvbWUtYXR0cmlidXRlPVwic29tZS12YWx1ZVwiPjwvbXktY29tcG9uZW50PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICA8c2NyaXB0PlxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIC8vIGdyYWIgbm9uLXVwZ3JhZGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGVsLnNvbWVBdHRyaWJ1dGUgPSBcImFub3RoZXItdmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAvLyB1cGdyYWRlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbXktY29tcG9uZW50JywgTXlDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICA8L3NjcmlwdD5cbiAgICAgICAgICAgICAgICAgICAgLy8gIGBgYFxuICAgICAgICAgICAgICAgICAgICAvLyAgSW4gdGhpcyBjYXNlIGlmIHdlIGRvIG5vdCB1bnNoYWRvdyBoZXJlIGFuZCB1c2UgdGhlIHZhbHVlIG9mIHRoZSBzaGFkb3dpbmcgcHJvcGVydHksIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyAgd2lsbCBiZSBjYWxsZWQgd2l0aCBgbmV3VmFsdWUgPSBcInNvbWUtdmFsdWVcImAgYW5kIHdpbGwgc2V0IHRoZSBzaGFkb3dlZCBwcm9wZXJ0eSAodGhpcy5zb21lQXR0cmlidXRlID0gXCJhbm90aGVyLXZhbHVlXCIpXG4gICAgICAgICAgICAgICAgICAgIC8vICB0byB0aGUgdmFsdWUgdGhhdCB3YXMgc2V0IGlubGluZSBpLmUuIFwic29tZS12YWx1ZVwiIGZyb20gYWJvdmUgZXhhbXBsZS4gV2hlblxuICAgICAgICAgICAgICAgICAgICAvLyAgdGhlIGNvbm5lY3RlZENhbGxiYWNrIGF0dGVtcHRzIHRvIHVuc2hhZG93IGl0IHdpbGwgdXNlIFwic29tZS12YWx1ZVwiIGFzIHRoZSBpbml0aWFsIHZhbHVlIHJhdGhlciB0aGFuIFwiYW5vdGhlci12YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIHdhcyBOT1Qgc2V0IGlubGluZSBidXQgd2FzIG5vdCBzZXQgcHJvZ3JhbW1hdGljYWxseSBzaGFsbCBiZSBoYW5kbGVkL3Vuc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gIGJ5IGNvbm5lY3RlZENhbGxiYWNrIGFzIHRoaXMgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgVE9ETyhTVEVOQ0lMLTE2KSB3ZSBzaG91bGQgdGhpbmsgYWJvdXQgd2hldGhlciBvciBub3Qgd2UgYWN0dWFsbHkgd2FudCB0byBiZSByZWZsZWN0aW5nIHRoZSBhdHRyaWJ1dGVzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vICBwcm9wZXJ0aWVzIGhlcmUgZ2l2ZW4gdGhhdCB0aGlzIGdvZXMgYWdhaW5zdCBiZXN0IHByYWN0aWNlcyBvdXRsaW5lZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2F2b2lkLXJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcE5hbWUgZXhpc3RzIG9uIHRoZSBwcm90b3R5cGUgb2YgYENzdHJgLCB0aGlzIHVwZGF0ZSBtYXkgYmUgYSByZXN1bHQgb2YgU3RlbmNpbCB1c2luZyBuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFQSXMgdG8gcmVmbGVjdCBwcm9wcyBhcyBhdHRyaWJ1dGVzLiBDYWxscyB0byBgc2V0QXR0cmlidXRlKHNvbWVFbGVtZW50LCBwcm9wTmFtZSlgIHdpbGwgcmVzdWx0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgcHJvcE5hbWVgIHRvIGJlIGNvbnZlcnRlZCB0byBhIGBET01TdHJpbmdgLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgd2Ugd2FudCBmb3Igb3RoZXIgcHJpbWl0aXZlIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmV3VmFsdWUgPT09IG51bGwgJiYgdHlwZW9mIHRoaXNbcHJvcE5hbWVdID09PSAnYm9vbGVhbicgPyBmYWxzZSA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIG9ic2VydmVcbiAgICAgICAgICAgIC8vIGFuZCBhbHNvIGNyZWF0ZSBhIG1hcCBvZiBodG1sIGF0dHJpYnV0ZSBuYW1lIHRvIGpzIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgIENzdHIub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbWVtYmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtfLCBtXSkgPT4gbVswXSAmIDE1IC8qIE1FTUJFUl9GTEFHUy5IYXNBdHRyaWJ1dGUgKi8pIC8vIGZpbHRlciB0byBvbmx5IGtlZXAgcHJvcHMgdGhhdCBzaG91bGQgbWF0Y2ggYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC5tYXAoKFtwcm9wTmFtZSwgbV0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IG1bMV0gfHwgcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgYXR0ck5hbWVUb1Byb3BOYW1lLnNldChhdHRyTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtWzBdICYgNTEyIC8qIE1FTUJFUl9GTEFHUy5SZWZsZWN0QXR0ciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiRhdHRyc1RvUmVmbGVjdCQucHVzaChbcHJvcE5hbWUsIGF0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBDc3RyO1xufTtcbmNvbnN0IGluaXRpYWxpemVDb21wb25lbnQgPSBhc3luYyAoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQsIENzdHIpID0+IHtcbiAgICAvLyBpbml0aWFsaXplQ29tcG9uZW50XG4gICAgaWYgKChob3N0UmVmLiRmbGFncyQgJiAzMiAvKiBIT1NUX0ZMQUdTLmhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovKSA9PT0gMCkge1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlbid0IGluaXRpYWxpemVkIHRoaXMgZWxlbWVudCB5ZXRcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAzMiAvKiBIT1NUX0ZMQUdTLmhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgICAgICAgICAgLy8gbGF6eSBsb2FkZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gcmVxdWVzdCB0aGUgY29tcG9uZW50J3MgaW1wbGVtZW50YXRpb24gdG8gYmVcbiAgICAgICAgICAgIC8vIHdpcmVkIHVwIHdpdGggdGhlIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgQ3N0ciA9IGxvYWRNb2R1bGUoY21wTWV0YSk7XG4gICAgICAgICAgICBpZiAoQ3N0ci50aGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gQXdhaXQgY3JlYXRlcyBhIG1pY3JvLXRhc2sgYXZvaWQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMb2FkID0gdW5pcXVlVGltZSgpO1xuICAgICAgICAgICAgICAgIENzdHIgPSBhd2FpdCBDc3RyO1xuICAgICAgICAgICAgICAgIGVuZExvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQ3N0ci5pc1Byb3hpZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBuZXZlciBwcm94aWVkIHRoaXMgQ29uc3RydWN0b3IgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gbGV0J3MgYWRkIHRoZSBnZXR0ZXJzL3NldHRlcnMgdG8gaXRzIHByb3RvdHlwZSBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgdGltZSB3ZSBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm94eUNvbXBvbmVudChDc3RyLCBjbXBNZXRhLCAyIC8qIFBST1hZX0ZMQUdTLnByb3h5U3RhdGUgKi8pO1xuICAgICAgICAgICAgICAgIENzdHIuaXNQcm94aWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZE5ld0luc3RhbmNlID0gY3JlYXRlVGltZSgnY3JlYXRlSW5zdGFuY2UnLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgICAgICAvLyBvaywgdGltZSB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICAvLyBidXQgbGV0J3Mga2VlcCB0cmFjayBvZiB3aGVuIHdlIHN0YXJ0IGFuZCBzdG9wXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBnZXR0ZXJzL3NldHRlcnMgZG9uJ3QgaW5jb3JyZWN0bHkgc3RlcCBvbiBkYXRhXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDggLyogSE9TVF9GTEFHUy5pc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3RydWN0IHRoZSBsYXp5LWxvYWRlZCBjb21wb25lbnQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIC8vIHBhc3NpbmcgdGhlIGhvc3RSZWYgaXMgdmVyeSBpbXBvcnRhbnQgZHVyaW5nXG4gICAgICAgICAgICAvLyBjb25zdHJ1Y3Rpb24gaW4gb3JkZXIgdG8gZGlyZWN0bHkgd2lyZSB0b2dldGhlciB0aGVcbiAgICAgICAgICAgIC8vIGhvc3QgZWxlbWVudCBhbmQgdGhlIGxhenktbG9hZGVkIGluc3RhbmNlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBDc3RyKGhvc3RSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kZmxhZ3MkICY9IH44IC8qIEhPU1RfRkxBR1MuaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIEhPU1RfRkxBR1MuaXNXYXRjaFJlYWR5ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTmV3SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ3N0ci5zdHlsZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBjb21wb25lbnQgaGFzIHN0eWxlcyBidXQgd2UgaGF2ZW4ndCByZWdpc3RlcmVkIHRoZW0geWV0XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBDc3RyLnN0eWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVJZCA9IGdldFNjb3BlSWQoY21wTWV0YSk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlcy5oYXMoc2NvcGVJZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRSZWdpc3RlclN0eWxlcyA9IGNyZWF0ZVRpbWUoJ3JlZ2lzdGVyU3R5bGVzJywgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGUoc2NvcGVJZCwgc3R5bGUsICEhKGNtcE1ldGEuJGZsYWdzJCAmIDEgLyogQ01QX0ZMQUdTLnNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKTtcbiAgICAgICAgICAgICAgICBlbmRSZWdpc3RlclN0eWxlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBjcmVhdGVkIGEgbGF6eSBpbnN0YW5jZVxuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICAgIGNvbnN0IHNjaGVkdWxlID0gKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgdHJ1ZSk7XG4gICAgaWYgKGFuY2VzdG9yQ29tcG9uZW50ICYmIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10pIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgaW5pdGlhbCBsb2FkIGFuZCB0aGlzIGNvbXBvbmVudCBpdCBoYXMgYW4gYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGJ1dCB0aGUgYW5jZXN0b3IgY29tcG9uZW50IGhhcyBOT1QgZmlyZWQgaXRzIHdpbGwgdXBkYXRlIGxpZmVjeWNsZSB5ZXRcbiAgICAgICAgLy8gc28gbGV0J3MganVzdCBjb29sIG91ciBqZXRzIGFuZCB3YWl0IGZvciB0aGUgYW5jZXN0b3IgdG8gY29udGludWUgZmlyc3RcbiAgICAgICAgLy8gdGhpcyB3aWxsIGdldCBmaXJlZCBvZmYgd2hlbiB0aGUgYW5jZXN0b3IgY29tcG9uZW50XG4gICAgICAgIC8vIGZpbmFsbHkgZ2V0cyBhcm91bmQgdG8gcmVuZGVyaW5nIGl0cyBsYXp5IHNlbGZcbiAgICAgICAgLy8gZmlyZSBvZmYgdGhlIGluaXRpYWwgdXBkYXRlXG4gICAgICAgIGFuY2VzdG9yQ29tcG9uZW50WydzLXJjJ10ucHVzaChzY2hlZHVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlZHVsZSgpO1xuICAgIH1cbn07XG5jb25zdCBmaXJlQ29ubmVjdGVkQ2FsbGJhY2sgPSAoaW5zdGFuY2UpID0+IHtcbiAgICB7XG4gICAgICAgIHNhZmVDYWxsKGluc3RhbmNlLCAnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICB9XG59O1xuY29uc3QgY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gICAgaWYgKChwbHQuJGZsYWdzJCAmIDEgLyogUExBVEZPUk1fRkxBR1MuaXNUbXBEaXNjb25uZWN0ZWQgKi8pID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgICAgIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgICAgICAgY29uc3QgZW5kQ29ubmVjdGVkID0gY3JlYXRlVGltZSgnY29ubmVjdGVkQ2FsbGJhY2snLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgICAgIGlmICghKGhvc3RSZWYuJGZsYWdzJCAmIDEgLyogSE9TVF9GTEFHUy5oYXNDb25uZWN0ZWQgKi8pKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB0aW1lIHRoaXMgY29tcG9uZW50IGhhcyBjb25uZWN0ZWRcbiAgICAgICAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAxIC8qIEhPU1RfRkxBR1MuaGFzQ29ubmVjdGVkICovO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGFuY2VzdG9yIGNvbXBvbmVudCAoaWYgdGhlcmUgaXMgb25lKSBhbmQgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBhcyBvbmUgb2YgdGhlIGFjdGl2ZWx5IGxvYWRpbmcgY2hpbGQgY29tcG9uZW50cyBmb3IgaXRzIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgbGV0IGFuY2VzdG9yQ29tcG9uZW50ID0gZWxtO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYW5jZXN0b3JDb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudC5wYXJlbnROb2RlIHx8IGFuY2VzdG9yQ29tcG9uZW50Lmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaW1iIHVwIHRoZSBhbmNlc3RvcnMgbG9va2luZyBmb3IgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCB0aGF0IGhhc24ndCBmaW5pc2hlZCBpdHMgbGlmZWN5Y2xlIHVwZGF0ZSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuY2VzdG9yQ29tcG9uZW50WydzLXAnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZm91bmQgdGhpcyBjb21wb25lbnRzIGZpcnN0IGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIGNvbXBvbmVudCdzIGFuY2VzdG9yIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoVG9BbmNlc3Rvcihob3N0UmVmLCAoaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkID0gYW5jZXN0b3JDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGF6eSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL2Jlc3QtcHJhY3RpY2VzI2xhenktcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY21wTWV0YS4kbWVtYmVycyQpLm1hcCgoW21lbWJlck5hbWUsIFttZW1iZXJGbGFnc11dKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXJGbGFncyAmIDMxIC8qIE1FTUJFUl9GTEFHUy5Qcm9wICovICYmIGVsbS5oYXNPd25Qcm9wZXJ0eShtZW1iZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxtW21lbWJlck5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIGZpcnN0IHRpbWUgdGhpcyBoYXMgY29ubmVjdGVkXG4gICAgICAgICAgICAvLyByZWF0dGFjaCBhbnkgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBob3N0XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IHdvdWxkIGhhdmUgYmVlbiByZW1vdmVkIHdoZW4gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICBhZGRIb3N0RXZlbnRMaXN0ZW5lcnMoZWxtLCBob3N0UmVmLCBjbXBNZXRhLiRsaXN0ZW5lcnMkKTtcbiAgICAgICAgICAgIC8vIGZpcmUgb2ZmIGNvbm5lY3RlZENhbGxiYWNrKCkgb24gY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5kQ29ubmVjdGVkKCk7XG4gICAgfVxufTtcbmNvbnN0IGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gKGVsbSkgPT4ge1xuICAgIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIFBMQVRGT1JNX0ZMQUdTLmlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBob3N0UmVmID0gZ2V0SG9zdFJlZihlbG0pO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgO1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaG9zdFJlZi4kcm1MaXN0ZW5lcnMkKSB7XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kcm1MaXN0ZW5lcnMkLm1hcCgocm1MaXN0ZW5lcikgPT4gcm1MaXN0ZW5lcigpKTtcbiAgICAgICAgICAgICAgICBob3N0UmVmLiRybUxpc3RlbmVycyQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsICdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHByb3h5Q3VzdG9tRWxlbWVudCA9IChDc3RyLCBjb21wYWN0TWV0YSkgPT4ge1xuICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgIH07XG4gICAge1xuICAgICAgICBjbXBNZXRhLiRtZW1iZXJzJCA9IGNvbXBhY3RNZXRhWzJdO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGNtcE1ldGEuJGxpc3RlbmVycyQgPSBjb21wYWN0TWV0YVszXTtcbiAgICB9XG4gICAge1xuICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLiR3YXRjaGVycyQ7XG4gICAgfVxuICAgIHtcbiAgICAgICAgY21wTWV0YS4kYXR0cnNUb1JlZmxlY3QkID0gW107XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsQ29ubmVjdGVkQ2FsbGJhY2sgPSBDc3RyLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaztcbiAgICBjb25zdCBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrID0gQ3N0ci5wcm90b3R5cGUuZGlzY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgT2JqZWN0LmFzc2lnbihDc3RyLnByb3RvdHlwZSwge1xuICAgICAgICBfX3JlZ2lzdGVySG9zdCgpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVySG9zdCh0aGlzLCBjbXBNZXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxDb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbERpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9fYXR0YWNoU2hhZG93KCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzRm9jdXM6ICEhKGNtcE1ldGEuJGZsYWdzJCAmIDE2IC8qIENNUF9GTEFHUy5zaGFkb3dEZWxlZ2F0ZXNGb2N1cyAqLyksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBDc3RyLmlzID0gY21wTWV0YS4kdGFnTmFtZSQ7XG4gICAgcmV0dXJuIHByb3h5Q29tcG9uZW50KENzdHIsIGNtcE1ldGEsIDEgLyogUFJPWFlfRkxBR1MuaXNFbGVtZW50Q29uc3RydWN0b3IgKi8gfCAyIC8qIFBST1hZX0ZMQUdTLnByb3h5U3RhdGUgKi8pO1xufTtcbmNvbnN0IEZyYWdtZW50ID0gKF8sIGNoaWxkcmVuKSA9PiBjaGlsZHJlbjtcbmNvbnN0IGFkZEhvc3RFdmVudExpc3RlbmVycyA9IChlbG0sIGhvc3RSZWYsIGxpc3RlbmVycywgYXR0YWNoUGFyZW50TGlzdGVuZXJzKSA9PiB7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcnMubWFwKChbZmxhZ3MsIG5hbWUsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEhvc3RMaXN0ZW5lclRhcmdldChlbG0sIGZsYWdzKSA7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaG9zdExpc3RlbmVyUHJveHkoaG9zdFJlZiwgbWV0aG9kKTtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBob3N0TGlzdGVuZXJPcHRzKGZsYWdzKTtcbiAgICAgICAgICAgIHBsdC5hZWwodGFyZ2V0LCBuYW1lLCBoYW5kbGVyLCBvcHRzKTtcbiAgICAgICAgICAgIChob3N0UmVmLiRybUxpc3RlbmVycyQgPSBob3N0UmVmLiRybUxpc3RlbmVycyQgfHwgW10pLnB1c2goKCkgPT4gcGx0LnJlbCh0YXJnZXQsIG5hbWUsIGhhbmRsZXIsIG9wdHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmNvbnN0IGhvc3RMaXN0ZW5lclByb3h5ID0gKGhvc3RSZWYsIG1ldGhvZE5hbWUpID0+IChldikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiAyNTYgLyogSE9TVF9GTEFHUy5pc0xpc3RlblJlYWR5ICovKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UgaXMgcmVhZHksIGxldCdzIGNhbGwgaXQncyBtZW1iZXIgbWV0aG9kIGZvciB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgaG9zdFJlZi4kbGF6eUluc3RhbmNlJFttZXRob2ROYW1lXShldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoaG9zdFJlZi4kcXVldWVkTGlzdGVuZXJzJCA9IGhvc3RSZWYuJHF1ZXVlZExpc3RlbmVycyQgfHwgW10pLnB1c2goW21ldGhvZE5hbWUsIGV2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgIH1cbn07XG5jb25zdCBnZXRIb3N0TGlzdGVuZXJUYXJnZXQgPSAoZWxtLCBmbGFncykgPT4ge1xuICAgIGlmIChmbGFncyAmIDQgLyogTElTVEVORVJfRkxBR1MuVGFyZ2V0RG9jdW1lbnQgKi8pXG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgaWYgKGZsYWdzICYgOCAvKiBMSVNURU5FUl9GTEFHUy5UYXJnZXRXaW5kb3cgKi8pXG4gICAgICAgIHJldHVybiB3aW47XG4gICAgaWYgKGZsYWdzICYgMTYgLyogTElTVEVORVJfRkxBR1MuVGFyZ2V0Qm9keSAqLylcbiAgICAgICAgcmV0dXJuIGRvYy5ib2R5O1xuICAgIHJldHVybiBlbG07XG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBob3N0TGlzdGVuZXJPcHRzID0gKGZsYWdzKSA9PiAoZmxhZ3MgJiAyIC8qIExJU1RFTkVSX0ZMQUdTLkNhcHR1cmUgKi8pICE9PSAwO1xuY29uc3QgaG9zdFJlZnMgPSAvKkBfX1BVUkVfXyovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRIb3N0UmVmID0gKHJlZikgPT4gaG9zdFJlZnMuZ2V0KHJlZik7XG5jb25zdCByZWdpc3Rlckhvc3QgPSAoZWxtLCBjbXBNZXRhKSA9PiB7XG4gICAgY29uc3QgaG9zdFJlZiA9IHtcbiAgICAgICAgJGZsYWdzJDogMCxcbiAgICAgICAgJGhvc3RFbGVtZW50JDogZWxtLFxuICAgICAgICAkY21wTWV0YSQ6IGNtcE1ldGEsXG4gICAgICAgICRpbnN0YW5jZVZhbHVlcyQ6IG5ldyBNYXAoKSxcbiAgICB9O1xuICAgIHtcbiAgICAgICAgaG9zdFJlZi4kb25JbnN0YW5jZVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvbkluc3RhbmNlUmVzb2x2ZSQgPSByKSk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgaG9zdFJlZi4kb25SZWFkeVByb21pc2UkID0gbmV3IFByb21pc2UoKHIpID0+IChob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQgPSByKSk7XG4gICAgICAgIGVsbVsncy1wJ10gPSBbXTtcbiAgICAgICAgZWxtWydzLXJjJ10gPSBbXTtcbiAgICB9XG4gICAgYWRkSG9zdEV2ZW50TGlzdGVuZXJzKGVsbSwgaG9zdFJlZiwgY21wTWV0YS4kbGlzdGVuZXJzJCk7XG4gICAgcmV0dXJuIGhvc3RSZWZzLnNldChlbG0sIGhvc3RSZWYpO1xufTtcbmNvbnN0IGlzTWVtYmVySW5FbGVtZW50ID0gKGVsbSwgbWVtYmVyTmFtZSkgPT4gbWVtYmVyTmFtZSBpbiBlbG07XG5jb25zdCBjb25zb2xlRXJyb3IgPSAoZSwgZWwpID0+ICgwLCBjb25zb2xlLmVycm9yKShlLCBlbCk7XG5jb25zdCBjbXBNb2R1bGVzID0gLypAX19QVVJFX18qLyBuZXcgTWFwKCk7XG5jb25zdCBsb2FkTW9kdWxlID0gKGNtcE1ldGEsIGhvc3RSZWYsIGhtclZlcnNpb25JZCkgPT4ge1xuICAgIC8vIGxvYWRNb2R1bGVJbXBvcnRcbiAgICBjb25zdCBleHBvcnROYW1lID0gY21wTWV0YS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLCAnXycpO1xuICAgIGNvbnN0IGJ1bmRsZUlkID0gY21wTWV0YS4kbGF6eUJ1bmRsZUlkJDtcbiAgICBjb25zdCBtb2R1bGUgPSBjbXBNb2R1bGVzLmdldChidW5kbGVJZCkgO1xuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lXTtcbiAgICB9XG4gICAgLyohX19TVEVOQ0lMX1NUQVRJQ19JTVBPUlRfU1dJVENIX18qL1xuICAgIHJldHVybiBpbXBvcnQoXG4gICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgLyogd2VicGFja0luY2x1ZGU6IC9cXC5lbnRyeVxcLmpzJC8gKi9cbiAgICAvKiB3ZWJwYWNrRXhjbHVkZTogL1xcLnN5c3RlbVxcLmVudHJ5XFwuanMkLyAqL1xuICAgIC8qIHdlYnBhY2tNb2RlOiBcImxhenlcIiAqL1xuICAgIGAuLyR7YnVuZGxlSWR9LmVudHJ5LmpzJHsnJ31gKS50aGVuKChpbXBvcnRlZE1vZHVsZSkgPT4ge1xuICAgICAgICB7XG4gICAgICAgICAgICBjbXBNb2R1bGVzLnNldChidW5kbGVJZCwgaW1wb3J0ZWRNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRlZE1vZHVsZVtleHBvcnROYW1lXTtcbiAgICB9LCBjb25zb2xlRXJyb3IpO1xufTtcbmNvbnN0IHN0eWxlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hcCgpO1xuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcbmNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudCB8fCB7IGhlYWQ6IHt9IH07XG5jb25zdCBIID0gKHdpbi5IVE1MRWxlbWVudCB8fCBjbGFzcyB7XG59KTtcbmNvbnN0IHBsdCA9IHtcbiAgICAkZmxhZ3MkOiAwLFxuICAgICRyZXNvdXJjZXNVcmwkOiAnJyxcbiAgICBqbXA6IChoKSA9PiBoKCksXG4gICAgcmFmOiAoaCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGgpLFxuICAgIGFlbDogKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSA9PiBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpLFxuICAgIHJlbDogKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpLFxuICAgIGNlOiAoZXZlbnROYW1lLCBvcHRzKSA9PiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBvcHRzKSxcbn07XG5jb25zdCBwcm9taXNlUmVzb2x2ZSA9ICh2KSA9PiBQcm9taXNlLnJlc29sdmUodik7XG5jb25zdCBzdXBwb3J0c0NvbnN0cnVjdGFibGVTdHlsZXNoZWV0cyA9IC8qQF9fUFVSRV9fKi8gKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBDU1NTdHlsZVNoZWV0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG5ldyBDU1NTdHlsZVNoZWV0KCkucmVwbGFjZVN5bmMgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkoKVxuICAgIDtcbmNvbnN0IHF1ZXVlRG9tUmVhZHMgPSBbXTtcbmNvbnN0IHF1ZXVlRG9tV3JpdGVzID0gW107XG5jb25zdCBxdWV1ZVRhc2sgPSAocXVldWUsIHdyaXRlKSA9PiAoY2IpID0+IHtcbiAgICBxdWV1ZS5wdXNoKGNiKTtcbiAgICBpZiAoIXF1ZXVlUGVuZGluZykge1xuICAgICAgICBxdWV1ZVBlbmRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAod3JpdGUgJiYgcGx0LiRmbGFncyQgJiA0IC8qIFBMQVRGT1JNX0ZMQUdTLnF1ZXVlU3luYyAqLykge1xuICAgICAgICAgICAgbmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgY29uc3VtZSA9IChxdWV1ZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1ZXVlW2ldKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG59O1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgLy8gYWx3YXlzIGZvcmNlIGEgYnVuY2ggb2YgbWVkaXVtIGNhbGxiYWNrcyB0byBydW4sIGJ1dCBzdGlsbCBoYXZlXG4gICAgLy8gYSB0aHJvdHRsZSBvbiBob3cgbWFueSBjYW4gcnVuIGluIGEgY2VydGFpbiB0aW1lXG4gICAgLy8gRE9NIFJFQURTISEhXG4gICAgY29uc3VtZShxdWV1ZURvbVJlYWRzKTtcbiAgICAvLyBET00gV1JJVEVTISEhXG4gICAge1xuICAgICAgICBjb25zdW1lKHF1ZXVlRG9tV3JpdGVzKTtcbiAgICAgICAgaWYgKChxdWV1ZVBlbmRpbmcgPSBxdWV1ZURvbVJlYWRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBzdGlsbCBtb3JlIHRvIGRvIHlldCwgYnV0IHdlJ3ZlIHJ1biBvdXQgb2YgdGltZVxuICAgICAgICAgICAgLy8gbGV0J3MgbGV0IHRoaXMgdGhpbmcgY29vbCBvZmYgYW5kIHRyeSBhZ2FpbiBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgICAgICBwbHQucmFmKGZsdXNoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBuZXh0VGljayA9IC8qQF9fUFVSRV9fKi8gKGNiKSA9PiBwcm9taXNlUmVzb2x2ZSgpLnRoZW4oY2IpO1xuY29uc3Qgd3JpdGVUYXNrID0gLypAX19QVVJFX18qLyBxdWV1ZVRhc2socXVldWVEb21Xcml0ZXMsIHRydWUpO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuZnVuY3Rpb24gZ2VuKGNvdW50cykge1xuICByZXR1cm4gY291bnRzXG4gICAgLm1hcCgoY291bnQpID0+IHtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIG91dCArPSAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKSB8IDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0pXG4gICAgLmpvaW4oXCItXCIpO1xufVxuY29uc3QgZ3VpZCA9ICgpID0+IGdlbihbMiwgMSwgMSwgMSwgM10pO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG5jb25zdCBhdXRvTW9kZSA9IFwiY2FsY2l0ZS1tb2RlLWF1dG9cIjtcbmNvbnN0IGRhcmtNb2RlID0gXCJjYWxjaXRlLW1vZGUtZGFya1wiO1xuY29uc3QgbGlnaHRNb2RlID0gXCJjYWxjaXRlLW1vZGUtbGlnaHRcIjtcbmNvbnN0IENTU19VVElMSVRZID0ge1xuICBhdXRvTW9kZSxcbiAgZGFya01vZGUsXG4gIGxpZ2h0TW9kZSxcbiAgcnRsOiBcImNhbGNpdGUtLXJ0bFwiXG59O1xuZnVuY3Rpb24gbm9kZUxpc3RUb0FycmF5KG5vZGVMaXN0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG5vZGVMaXN0KSA/IG5vZGVMaXN0IDogQXJyYXkuZnJvbShub2RlTGlzdCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gIGNvbnN0IHByb3AgPSBcImRpclwiO1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtwcm9wfV1gO1xuICBjb25zdCBjbG9zZXN0ID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBzZWxlY3Rvcik7XG4gIHJldHVybiBjbG9zZXN0ID8gY2xvc2VzdC5nZXRBdHRyaWJ1dGUocHJvcCkgOiBcImx0clwiO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFByb3AoZWwsIHByb3AsIGZhbGxiYWNrVmFsdWUpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7cHJvcH1dYDtcbiAgY29uc3QgY2xvc2VzdCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICByZXR1cm4gY2xvc2VzdCA/IGNsb3Nlc3QuZ2V0QXR0cmlidXRlKHByb3ApIDogZmFsbGJhY2tWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3ROb2RlKGVsKSB7XG4gIHJldHVybiBlbC5nZXRSb290Tm9kZSgpO1xufVxuZnVuY3Rpb24gZ2V0SG9zdChyb290KSB7XG4gIHJldHVybiByb290Lmhvc3QgfHwgbnVsbDtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgcXVlcmllcyBhbiBlbGVtZW50J3Mgcm9vdE5vZGUgYW5kIGFueSBhbmNlc3RvciByb290Tm9kZXMuXG4gKlxuICogSWYgYm90aCBhbiAnaWQnIGFuZCAnc2VsZWN0b3InIGFyZSBzdXBwbGllZCwgJ2lkJyB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyICdzZWxlY3RvcicuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwYXJhbSByb290MFxuICogQHBhcmFtIHJvb3QwLnNlbGVjdG9yXG4gKiBAcGFyYW0gcm9vdDAuaWRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcXVlcnlFbGVtZW50Um9vdHMoZWxlbWVudCwgeyBzZWxlY3RvciwgaWQgfSkge1xuICAvLyBHZXRzIHRoZSByb290Tm9kZSBhbmQgYW55IGFuY2VzdG9yIHJvb3ROb2RlcyAoc2hhZG93Um9vdCBvciBkb2N1bWVudCkgb2YgYW4gZWxlbWVudCBhbmQgcXVlcmllcyB0aGVtIGZvciBhIHNlbGVjdG9yLlxuICAvLyBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU0NTIwNTU0LzE5NDIxNlxuICBmdW5jdGlvbiBxdWVyeUZyb20oZWwpIHtcbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGVsLmFzc2lnbmVkU2xvdCkge1xuICAgICAgZWwgPSBlbC5hc3NpZ25lZFNsb3Q7XG4gICAgfVxuICAgIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUoZWwpO1xuICAgIGNvbnN0IGZvdW5kID0gaWRcbiAgICAgID8gXCJnZXRFbGVtZW50QnlJZFwiIGluIHJvb3ROb2RlXG4gICAgICAgID8gLypcbiAgICAgICAgICBDaGVjayB0byBtYWtlIHN1cmUgJ2dldEVsZW1lbnRCeUlkJyBleGlzdHMgaW4gY2FzZXMgd2hlcmUgZWxlbWVudCBpcyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBET00gYW5kIGdldFJvb3ROb2RlKCkgcmV0dXJucyB0aGUgZWxlbWVudC5cbiAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvcHVsbC80MjgwXG4gICAgICAgICAgICovXG4gICAgICAgICAgcm9vdE5vZGUuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gICAgICAgIDogbnVsbFxuICAgICAgOiBzZWxlY3RvclxuICAgICAgICA/IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBob3N0ID0gZ2V0SG9zdChyb290Tm9kZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gZm91bmQgOiBob3N0ID8gcXVlcnlGcm9tKGhvc3QpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcXVlcnlGcm9tKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIC8vIGJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81NDUyMDU1NC8xOTQyMTZcbiAgZnVuY3Rpb24gY2xvc2VzdEZyb20oZWwpIHtcbiAgICByZXR1cm4gZWwgPyBlbC5jbG9zZXN0KHNlbGVjdG9yKSB8fCBjbG9zZXN0RnJvbShnZXRIb3N0KGdldFJvb3ROb2RlKGVsKSkpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gY2xvc2VzdEZyb20oZWxlbWVudCk7XG59XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBoZWxwcyBpbnZva2UgYSBjYWxsYmFjayBhcyBpdCB0cmF2ZXJzZXMgYSBub2RlIGFuZCBpdHMgYW5jZXN0b3JzIHVudGlsIHJlYWNoaW5nIHRoZSByb290IGRvY3VtZW50LlxuICpcbiAqIFJldHVybmluZyBlYXJseSBvciB1bmRlZmluZWQgaW4gYG9uVmlzaXRgIHdpbGwgY29udGludWUgdHJhdmVyc2luZyB1cCB0aGUgRE9NIHRyZWUuIE90aGVyd2lzZSwgdHJhdmVyc2FsIHdpbGwgaGFsdCB3aXRoIHRoZSByZXR1cm5lZCB2YWx1ZSBhcyB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcGFyYW0gb25WaXNpdFxuICovXG5mdW5jdGlvbiB3YWxrVXBBbmNlc3RyeShlbGVtZW50LCBvblZpc2l0KSB7XG4gIHJldHVybiB2aXNpdChlbGVtZW50LCBvblZpc2l0KTtcbn1cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIG9uVmlzaXQpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG9uVmlzaXQobm9kZSk7XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBub2RlO1xuICByZXR1cm4gdmlzaXQocGFyZW50Tm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBwYXJlbnROb2RlLmhvc3QgOiBwYXJlbnROb2RlLCBvblZpc2l0KTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zQ3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBtYXliZURlc2NlbmRhbnQpIHtcbiAgcmV0dXJuICEhd2Fsa1VwQW5jZXN0cnkobWF5YmVEZXNjZW5kYW50LCAobm9kZSkgPT4gKG5vZGUgPT09IGVsZW1lbnQgPyB0cnVlIDogdW5kZWZpbmVkKSk7XG59XG5mdW5jdGlvbiBpc0NhbGNpdGVGb2N1c2FibGUoZWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBlbD8uc2V0Rm9jdXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZvY3VzRWxlbWVudChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBpc0NhbGNpdGVGb2N1c2FibGUoZWwpID8gZWwuc2V0Rm9jdXMoKSA6IGVsLmZvY3VzKCk7XG59XG5jb25zdCBkZWZhdWx0U2xvdFNlbGVjdG9yID0gXCI6bm90KFtzbG90XSlcIjtcbmZ1bmN0aW9uIGdldFNsb3R0ZWQoZWxlbWVudCwgc2xvdE5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKHNsb3ROYW1lICYmICFBcnJheS5pc0FycmF5KHNsb3ROYW1lKSAmJiB0eXBlb2Ygc2xvdE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICBvcHRpb25zID0gc2xvdE5hbWU7XG4gICAgc2xvdE5hbWUgPSBudWxsO1xuICB9XG4gIGNvbnN0IHNsb3RTZWxlY3RvciA9IHNsb3ROYW1lXG4gICAgPyBBcnJheS5pc0FycmF5KHNsb3ROYW1lKVxuICAgICAgPyBzbG90TmFtZS5tYXAoKG5hbWUpID0+IGBbc2xvdD1cIiR7bmFtZX1cIl1gKS5qb2luKFwiLFwiKVxuICAgICAgOiBgW3Nsb3Q9XCIke3Nsb3ROYW1lfVwiXWBcbiAgICA6IGRlZmF1bHRTbG90U2VsZWN0b3I7XG4gIGlmIChvcHRpb25zPy5hbGwpIHtcbiAgICByZXR1cm4gcXVlcnlNdWx0aXBsZShlbGVtZW50LCBzbG90U2VsZWN0b3IsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBxdWVyeVNpbmdsZShlbGVtZW50LCBzbG90U2VsZWN0b3IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0Q2hpbGRyZW4oZWwsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBlbCA/IEFycmF5LmZyb20oZWwuY2hpbGRyZW4gfHwgW10pLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkPy5tYXRjaGVzKHNlbGVjdG9yKSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5TXVsdGlwbGUoZWxlbWVudCwgc2xvdFNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIGxldCBtYXRjaGVzID0gc2xvdFNlbGVjdG9yID09PSBkZWZhdWx0U2xvdFNlbGVjdG9yXG4gICAgPyBnZXREaXJlY3RDaGlsZHJlbihlbGVtZW50LCBkZWZhdWx0U2xvdFNlbGVjdG9yKVxuICAgIDogQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2xvdFNlbGVjdG9yKSk7XG4gIG1hdGNoZXMgPSBvcHRpb25zICYmIG9wdGlvbnMuZGlyZWN0ID09PSBmYWxzZSA/IG1hdGNoZXMgOiBtYXRjaGVzLmZpbHRlcigoZWwpID0+IGVsLnBhcmVudEVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICBtYXRjaGVzID0gb3B0aW9ucz8ubWF0Y2hlcyA/IG1hdGNoZXMuZmlsdGVyKChlbCkgPT4gZWw/Lm1hdGNoZXMob3B0aW9ucy5tYXRjaGVzKSkgOiBtYXRjaGVzO1xuICBjb25zdCBzZWxlY3RvciA9IG9wdGlvbnM/LnNlbGVjdG9yO1xuICByZXR1cm4gc2VsZWN0b3JcbiAgICA/IG1hdGNoZXNcbiAgICAgIC5tYXAoKGl0ZW0pID0+IEFycmF5LmZyb20oaXRlbS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpXG4gICAgICAucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IFsuLi5wcmV2aW91c1ZhbHVlLCAuLi5jdXJyZW50VmFsdWVdLCBbXSlcbiAgICAgIC5maWx0ZXIoKG1hdGNoKSA9PiAhIW1hdGNoKVxuICAgIDogbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2luZ2xlKGVsZW1lbnQsIHNsb3RTZWxlY3Rvciwgb3B0aW9ucykge1xuICBsZXQgbWF0Y2ggPSBzbG90U2VsZWN0b3IgPT09IGRlZmF1bHRTbG90U2VsZWN0b3JcbiAgICA/IGdldERpcmVjdENoaWxkcmVuKGVsZW1lbnQsIGRlZmF1bHRTbG90U2VsZWN0b3IpWzBdIHx8IG51bGxcbiAgICA6IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzbG90U2VsZWN0b3IpO1xuICBtYXRjaCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXJlY3QgPT09IGZhbHNlID8gbWF0Y2ggOiBtYXRjaD8ucGFyZW50RWxlbWVudCA9PT0gZWxlbWVudCA/IG1hdGNoIDogbnVsbDtcbiAgbWF0Y2ggPSBvcHRpb25zPy5tYXRjaGVzID8gKG1hdGNoPy5tYXRjaGVzKG9wdGlvbnMubWF0Y2hlcykgPyBtYXRjaCA6IG51bGwpIDogbWF0Y2g7XG4gIGNvbnN0IHNlbGVjdG9yID0gb3B0aW9ucz8uc2VsZWN0b3I7XG4gIHJldHVybiBzZWxlY3RvciA/IG1hdGNoPy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IG1hdGNoO1xufVxuZnVuY3Rpb24gZmlsdGVyRGlyZWN0Q2hpbGRyZW4oZWwsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZC5tYXRjaGVzKHNlbGVjdG9yKSk7XG59XG4vLyBzZXQgYSBkZWZhdWx0IGljb24gZnJvbSBhIGRlZmluZWQgc2V0IG9yIGFsbG93IGFuIG92ZXJyaWRlIHdpdGggYW4gaWNvbiBuYW1lIHN0cmluZ1xuZnVuY3Rpb24gc2V0UmVxdWVzdGVkSWNvbihpY29uT2JqZWN0LCBpY29uVmFsdWUsIG1hdGNoZWRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGljb25WYWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBpY29uVmFsdWUgIT09IFwiXCIpIHtcbiAgICByZXR1cm4gaWNvblZhbHVlO1xuICB9XG4gIGVsc2UgaWYgKGljb25WYWx1ZSA9PT0gXCJcIikge1xuICAgIHJldHVybiBpY29uT2JqZWN0W21hdGNoZWRWYWx1ZV07XG4gIH1cbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgbWFrZXMgc3VyZSB0aGF0IGJvb2xlYW4gYXJpYSBhdHRyaWJ1dGVzIGFyZSBwcm9wZXJseSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcuXG4gKlxuICogSXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgYXJpYSBhdHRyaWJ1dGVzIHRoYXQgcmVxdWlyZSBhIHN0cmluZyB2YWx1ZSBvZiBcInRydWVcIiBvciBcImZhbHNlXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIGNvbnZlcnNpb24gb2YgYSBib29sZWFuIHZhbHVlIChcInRydWVcIiB8IFwiZmFsc2VcIikuXG4gKi9cbmZ1bmN0aW9uIHRvQXJpYUJvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpLnRvU3RyaW5nKCk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnRlciBldmVudCBmaXJlZCBmcm9tIHRoZSBwcmltYXJ5IGJ1dHRvbiBvZiB0aGUgZGV2aWNlLlxuICpcbiAqIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jdGhlLWJ1dHRvbi1wcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ByaW1hcnlQb2ludGVyQnV0dG9uKGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5pc1ByaW1hcnkgJiYgZXZlbnQuYnV0dG9uID09PSAwKTtcbn1cbmNvbnN0IGZvY3VzRWxlbWVudEluR3JvdXAgPSAoZWxlbWVudHMsIGN1cnJlbnRFbGVtZW50LCBkZXN0aW5hdGlvbikgPT4ge1xuICBjb25zdCBjdXJyZW50SW5kZXggPSBlbGVtZW50cy5pbmRleE9mKGN1cnJlbnRFbGVtZW50KTtcbiAgY29uc3QgaXNGaXJzdEl0ZW0gPSBjdXJyZW50SW5kZXggPT09IDA7XG4gIGNvbnN0IGlzTGFzdEl0ZW0gPSBjdXJyZW50SW5kZXggPT09IGVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gIGRlc3RpbmF0aW9uID1cbiAgICBkZXN0aW5hdGlvbiA9PT0gXCJwcmV2aW91c1wiICYmIGlzRmlyc3RJdGVtID8gXCJsYXN0XCIgOiBkZXN0aW5hdGlvbiA9PT0gXCJuZXh0XCIgJiYgaXNMYXN0SXRlbSA/IFwiZmlyc3RcIiA6IGRlc3RpbmF0aW9uO1xuICBsZXQgZm9jdXNUYXJnZXQ7XG4gIHN3aXRjaCAoZGVzdGluYXRpb24pIHtcbiAgICBjYXNlIFwiZmlyc3RcIjpcbiAgICAgIGZvY3VzVGFyZ2V0ID0gZWxlbWVudHNbMF07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGFzdFwiOlxuICAgICAgZm9jdXNUYXJnZXQgPSBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJuZXh0XCI6XG4gICAgICBmb2N1c1RhcmdldCA9IGVsZW1lbnRzW2N1cnJlbnRJbmRleCArIDFdIHx8IGVsZW1lbnRzWzBdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInByZXZpb3VzXCI6XG4gICAgICBmb2N1c1RhcmdldCA9IGVsZW1lbnRzW2N1cnJlbnRJbmRleCAtIDFdIHx8IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgZm9jdXNFbGVtZW50KGZvY3VzVGFyZ2V0KTtcbiAgcmV0dXJuIGZvY3VzVGFyZ2V0O1xufTtcblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmZ1bmN0aW9uIG5vb3BDbGljaygpIHtcbiAgLyoqIG5vb3AgKi9cbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgdXBkYXRlcyB0aGUgaG9zdCBlbGVtZW50IHRvIHByZXZlbnQga2V5Ym9hcmQgaW50ZXJhY3Rpb24gb24gaXRzIHN1YnRyZWUgYW5kIHNldHMgdGhlIGFwcHJvcHJpYXRlIGFyaWEgYXR0cmlidXRlIGZvciBhY2Nlc3NpYmlsaXR5LlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGBjb21wb25lbnREaWRSZW5kZXJgIGxpZmVjeWNsZSBob29rLlxuICpcbiAqICoqTm90ZXMqKlxuICpcbiAqIHRoaXMgdXRpbCBpcyBub3QgbmVlZGVkIGZvciBzaW1wbGUgY29tcG9uZW50cyB3aG9zZSByb290IGVsZW1lbnQgb3IgZWxlbWVudHMgYXJlIGFuIGludGVyYWN0aXZlIGNvbXBvbmVudCAoY3VzdG9tIGVsZW1lbnQgb3IgbmF0aXZlIGNvbnRyb2wpLiBGb3IgdGhvc2UgY2FzZXMsIHNldCB0aGUgYGRpc2FibGVkYCBwcm9wcyBvbiB0aGUgcm9vdCBjb21wb25lbnRzIGluc3RlYWQuXG4gKiB0ZWNobmljYWxseSwgdXNlcnMgY2FuIG92ZXJyaWRlIGB0YWJpbmRleGAgYW5kIHJlc3RvcmUga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYnV0IHRoaXMgd2lsbCBiZSBjb25zaWRlcmVkIHVzZXIgZXJyb3JcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcGFyYW0gaG9zdElzVGFiYmFibGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlSG9zdEludGVyYWN0aW9uKGNvbXBvbmVudCwgaG9zdElzVGFiYmFibGUgPSBmYWxzZSkge1xuICBpZiAoY29tcG9uZW50LmRpc2FibGVkKSB7XG4gICAgY29tcG9uZW50LmVsLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgY29tcG9uZW50LmVsLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIpO1xuICAgIGlmIChjb21wb25lbnQuZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICBjb21wb25lbnQuZWwuY2xpY2sgPSBub29wQ2xpY2s7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXBvbmVudC5lbC5jbGljayA9IEhUTUxFbGVtZW50LnByb3RvdHlwZS5jbGljaztcbiAgaWYgKHR5cGVvZiBob3N0SXNUYWJiYWJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29tcG9uZW50LmVsLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIGhvc3RJc1RhYmJhYmxlLmNhbGwoY29tcG9uZW50KSA/IFwiMFwiIDogXCItMVwiKTtcbiAgfVxuICBlbHNlIGlmIChob3N0SXNUYWJiYWJsZSA9PT0gdHJ1ZSkge1xuICAgIGNvbXBvbmVudC5lbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gIH1cbiAgZWxzZSBpZiAoaG9zdElzVGFiYmFibGUgPT09IGZhbHNlKSB7XG4gICAgY29tcG9uZW50LmVsLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xuICB9XG4gIGVsc2UgO1xuICBjb21wb25lbnQuZWwucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiKTtcbn1cblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmNvbnN0IHJlc29sdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcHJvbWlzZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFRoaXMgaGVscGVyIHV0aWwgc2V0cyB1cCB0aGUgY29tcG9uZW50IGZvciB0aGUgYWJpbGl0eSB0byBrbm93IHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBsb2FkZWQuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbiB0aGUgYGNvbXBvbmVudFdpbGxMb2FkYCBsaWZlY3ljbGUgaG9vay5cbiAqXG4gKiBgYGBcbiAqIGNvbXBvbmVudFdpbGxMb2FkKCk6IHZvaWQge1xuICogICBzZXRVcExvYWRhYmxlQ29tcG9uZW50KHRoaXMpO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBzZXRVcExvYWRhYmxlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICBwcm9taXNlTWFwLnNldChjb21wb25lbnQsIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlTWFwLnNldChjb21wb25lbnQsIHJlc29sdmUpKSk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHV0aWwgbGV0cyB0aGUgbG9hZGFibGUgY29tcG9uZW50IGtub3cgdGhhdCBpdCBpcyBub3cgbG9hZGVkLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGBjb21wb25lbnREaWRMb2FkYCBsaWZlY3ljbGUgaG9vay5cbiAqXG4gKiBgYGBcbiAqIGNvbXBvbmVudERpZExvYWQoKTogdm9pZCB7XG4gKiAgIHNldENvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gc2V0Q29tcG9uZW50TG9hZGVkKGNvbXBvbmVudCkge1xuICByZXNvbHZlTWFwLmdldChjb21wb25lbnQpKCk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHV0aWwgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIGEgY29tcG9uZW50IGhhcyBiZWVuIGxvYWRlZCAoVGhlIFwiY29tcG9uZW50RGlkTG9hZFwiIHN0ZW5jaWwgbGlmZWN5Y2xlIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQpLlxuICpcbiAqIFJlcXVpcmVzIFwic2V0VXBMb2FkYWJsZUNvbXBvbmVudFwiIGFuZCBcInNldENvbXBvbmVudExvYWRlZFwiIHRvIGJlIGNhbGxlZCBmaXJzdC5cbiAqXG4gKiBBIGNvbXBvbmVudCBkZXZlbG9wZXIgY2FuIGF3YWl0IHRoaXMgbWV0aG9kIGJlZm9yZSBwcm9jZWVkaW5nIHdpdGggYW55IGxvZ2ljIHRoYXQgcmVxdWlyZXMgYSBjb21wb25lbnQgdG8gYmUgbG9hZGVkIGZpcnN0LlxuICpcbiAqIGBgYFxuICogYXN5bmMgc2V0Rm9jdXMoKTogUHJvbWlzZTx2b2lkPiB7XG4gKiAgIGF3YWl0IGNvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEByZXR1cm5zIFByb21pc2U8dm9pZD5cbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50TG9hZGVkKGNvbXBvbmVudCkge1xuICByZXR1cm4gcHJvbWlzZU1hcC5nZXQoY29tcG9uZW50KTtcbn1cblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmNvbnN0IG51bWJlcktleXMgPSBbXCIwXCIsIFwiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCJdO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG4vKipcbiAqIFRoaXMgdXRpbGl0eSBlbnN1cmVzIG9ic2VydmVycyBhcmUgY3JlYXRlZCBvbmx5IGZvciBicm93c2VyIGNvbnRleHRzLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHR5cGUgb2Ygb2JzZXJ2ZXIgdG8gY3JlYXRlXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2tcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIG9ic2VydmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3QgT2JzZXJ2ZXIgPSBnZXRPYnNlcnZlcih0eXBlKTtcbiAgcmV0dXJuIG5ldyBPYnNlcnZlcihjYWxsYmFjaywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlcih0eXBlKSB7XG4gIC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZG9tL2lzc3Vlcy8xMjYjaXNzdWVjb21tZW50LTEwNDk4MTQ5NDhcbiAgY2xhc3MgRXh0ZW5kZWRNdXRhdGlvbk9ic2VydmVyIGV4dGVuZHMgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgICBzdXBlcihjYWxsYmFjayk7XG4gICAgICB0aGlzLm9ic2VydmVkRW50cnkgPSBbXTtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeS5wdXNoKHsgdGFyZ2V0LCBvcHRpb25zIH0pO1xuICAgICAgcmV0dXJuIHN1cGVyLm9ic2VydmUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgdW5vYnNlcnZlKHRhcmdldCkge1xuICAgICAgY29uc3QgbmV3T2JzZXJ2ZWRFbnRyaWVzID0gdGhpcy5vYnNlcnZlZEVudHJ5LmZpbHRlcigob2JzZXJ2ZWQpID0+IG9ic2VydmVkLnRhcmdldCAhPT0gdGFyZ2V0KTtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeSA9IFtdO1xuICAgICAgdGhpcy5jYWxsYmFjayhzdXBlci50YWtlUmVjb3JkcygpLCB0aGlzKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgbmV3T2JzZXJ2ZWRFbnRyaWVzLmZvckVhY2goKG9ic2VydmVkKSA9PiB0aGlzLm9ic2VydmUob2JzZXJ2ZWQudGFyZ2V0LCBvYnNlcnZlZC5vcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIlxuICAgICAgPyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgIDogdHlwZSA9PT0gXCJtdXRhdGlvblwiXG4gICAgICAgID8gRXh0ZW5kZWRNdXRhdGlvbk9ic2VydmVyXG4gICAgICAgIDogd2luZG93LlJlc2l6ZU9ic2VydmVyKTtcbiAgfSkoKTtcbn1cblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cblxuY29uc3QgZGVmYXVsdE1pbnVzU2lnblJlZ2V4ID0gbmV3IFJlZ0V4cChcIi1cIiwgXCJnXCIpO1xuY29uc3QgdW5uZWNlc3NhcnlEZWNpbWFsUmVnZXggPSBuZXcgUmVnRXhwKFwiXFxcXC4/MCskXCIpO1xuLy8gYWRvcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82NjkzOTI0NFxuY2xhc3MgQmlnRGVjaW1hbCB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgdGhpcy5hZGQgPSAobnVtKSA9PiBCaWdEZWNpbWFsLmZyb21CaWdJbnQodGhpcy52YWx1ZSArIG5ldyBCaWdEZWNpbWFsKG51bSkudmFsdWUpO1xuICAgIHRoaXMuc3VidHJhY3QgPSAobnVtKSA9PiBCaWdEZWNpbWFsLmZyb21CaWdJbnQodGhpcy52YWx1ZSAtIG5ldyBCaWdEZWNpbWFsKG51bSkudmFsdWUpO1xuICAgIHRoaXMubXVsdGlwbHkgPSAobnVtKSA9PiBCaWdEZWNpbWFsLl9kaXZSb3VuZCh0aGlzLnZhbHVlICogbmV3IEJpZ0RlY2ltYWwobnVtKS52YWx1ZSwgQmlnRGVjaW1hbC5TSElGVCk7XG4gICAgdGhpcy5kaXZpZGUgPSAobnVtKSA9PiBCaWdEZWNpbWFsLl9kaXZSb3VuZCh0aGlzLnZhbHVlICogQmlnRGVjaW1hbC5TSElGVCwgbmV3IEJpZ0RlY2ltYWwobnVtKS52YWx1ZSk7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQmlnRGVjaW1hbCkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBjb25zdCBbaW50ZWdlcnMsIGRlY2ltYWxzXSA9IFN0cmluZyhpbnB1dCkuc3BsaXQoXCIuXCIpLmNvbmNhdChcIlwiKTtcbiAgICB0aGlzLnZhbHVlID1cbiAgICAgIEJpZ0ludChpbnRlZ2VycyArIGRlY2ltYWxzLnBhZEVuZChCaWdEZWNpbWFsLkRFQ0lNQUxTLCBcIjBcIikuc2xpY2UoMCwgQmlnRGVjaW1hbC5ERUNJTUFMUykpICtcbiAgICAgICAgQmlnSW50KEJpZ0RlY2ltYWwuUk9VTkRFRCAmJiBkZWNpbWFsc1tCaWdEZWNpbWFsLkRFQ0lNQUxTXSA+PSBcIjVcIik7XG4gICAgdGhpcy5pc05lZ2F0aXZlID0gaW5wdXQuY2hhckF0KDApID09PSBcIi1cIjtcbiAgfVxuICBnZXRJbnRlZ2Vyc0FuZERlY2ltYWxzKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnZhbHVlXG4gICAgICAudG9TdHJpbmcoKVxuICAgICAgLnJlcGxhY2UoZGVmYXVsdE1pbnVzU2lnblJlZ2V4LCBcIlwiKVxuICAgICAgLnBhZFN0YXJ0KEJpZ0RlY2ltYWwuREVDSU1BTFMgKyAxLCBcIjBcIik7XG4gICAgY29uc3QgaW50ZWdlcnMgPSBzLnNsaWNlKDAsIC1CaWdEZWNpbWFsLkRFQ0lNQUxTKTtcbiAgICBjb25zdCBkZWNpbWFscyA9IHMuc2xpY2UoLUJpZ0RlY2ltYWwuREVDSU1BTFMpLnJlcGxhY2UodW5uZWNlc3NhcnlEZWNpbWFsUmVnZXgsIFwiXCIpO1xuICAgIHJldHVybiB7IGludGVnZXJzLCBkZWNpbWFscyB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHsgaW50ZWdlcnMsIGRlY2ltYWxzIH0gPSB0aGlzLmdldEludGVnZXJzQW5kRGVjaW1hbHMoKTtcbiAgICByZXR1cm4gYCR7dGhpcy5pc05lZ2F0aXZlID8gXCItXCIgOiBcIlwifSR7aW50ZWdlcnN9JHtkZWNpbWFscy5sZW5ndGggPyBcIi5cIiArIGRlY2ltYWxzIDogXCJcIn1gO1xuICB9XG4gIGZvcm1hdFRvUGFydHMoZm9ybWF0dGVyKSB7XG4gICAgY29uc3QgeyBpbnRlZ2VycywgZGVjaW1hbHMgfSA9IHRoaXMuZ2V0SW50ZWdlcnNBbmREZWNpbWFscygpO1xuICAgIGNvbnN0IHBhcnRzID0gZm9ybWF0dGVyLm51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKEJpZ0ludChpbnRlZ2VycykpO1xuICAgIHRoaXMuaXNOZWdhdGl2ZSAmJiBwYXJ0cy51bnNoaWZ0KHsgdHlwZTogXCJtaW51c1NpZ25cIiwgdmFsdWU6IGZvcm1hdHRlci5taW51c1NpZ24gfSk7XG4gICAgaWYgKGRlY2ltYWxzLmxlbmd0aCkge1xuICAgICAgcGFydHMucHVzaCh7IHR5cGU6IFwiZGVjaW1hbFwiLCB2YWx1ZTogZm9ybWF0dGVyLmRlY2ltYWwgfSk7XG4gICAgICBkZWNpbWFscy5zcGxpdChcIlwiKS5mb3JFYWNoKChjaGFyKSA9PiBwYXJ0cy5wdXNoKHsgdHlwZTogXCJmcmFjdGlvblwiLCB2YWx1ZTogY2hhciB9KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbiAgfVxuICBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgY29uc3QgeyBpbnRlZ2VycywgZGVjaW1hbHMgfSA9IHRoaXMuZ2V0SW50ZWdlcnNBbmREZWNpbWFscygpO1xuICAgIGNvbnN0IGludGVnZXJzRm9ybWF0dGVkID0gYCR7dGhpcy5pc05lZ2F0aXZlID8gZm9ybWF0dGVyLm1pbnVzU2lnbiA6IFwiXCJ9JHtmb3JtYXR0ZXIubnVtYmVyRm9ybWF0dGVyLmZvcm1hdChCaWdJbnQoaW50ZWdlcnMpKX1gO1xuICAgIGNvbnN0IGRlY2ltYWxzRm9ybWF0dGVkID0gZGVjaW1hbHMubGVuZ3RoXG4gICAgICA/IGAke2Zvcm1hdHRlci5kZWNpbWFsfSR7ZGVjaW1hbHNcbiAgICAgICAgLnNwbGl0KFwiXCIpXG4gICAgICAgIC5tYXAoKGNoYXIpID0+IGZvcm1hdHRlci5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0KE51bWJlcihjaGFyKSkpXG4gICAgICAgIC5qb2luKFwiXCIpfWBcbiAgICAgIDogXCJcIjtcbiAgICByZXR1cm4gYCR7aW50ZWdlcnNGb3JtYXR0ZWR9JHtkZWNpbWFsc0Zvcm1hdHRlZH1gO1xuICB9XG59XG4vLyBDb25maWd1cmF0aW9uOiBjb25zdGFudHNcbkJpZ0RlY2ltYWwuREVDSU1BTFMgPSAxMDA7IC8vIG51bWJlciBvZiBkZWNpbWFscyBvbiBhbGwgaW5zdGFuY2VzXG5CaWdEZWNpbWFsLlJPVU5ERUQgPSB0cnVlOyAvLyBudW1iZXJzIGFyZSB0cnVuY2F0ZWQgKGZhbHNlKSBvciByb3VuZGVkICh0cnVlKVxuQmlnRGVjaW1hbC5TSElGVCA9IEJpZ0ludChcIjFcIiArIFwiMFwiLnJlcGVhdChCaWdEZWNpbWFsLkRFQ0lNQUxTKSk7IC8vIGRlcml2ZWQgY29uc3RhbnRcbkJpZ0RlY2ltYWwuX2RpdlJvdW5kID0gKGRpdmlkZW5kLCBkaXZpc29yKSA9PiBCaWdEZWNpbWFsLmZyb21CaWdJbnQoZGl2aWRlbmQgLyBkaXZpc29yICsgKEJpZ0RlY2ltYWwuUk9VTkRFRCA/ICgoZGl2aWRlbmQgKiBCaWdJbnQoMikpIC8gZGl2aXNvcikgJSBCaWdJbnQoMikgOiBCaWdJbnQoMCkpKTtcbkJpZ0RlY2ltYWwuZnJvbUJpZ0ludCA9IChiaWdpbnQpID0+IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShCaWdEZWNpbWFsLnByb3RvdHlwZSksIHsgdmFsdWU6IGJpZ2ludCB9KTtcbmZ1bmN0aW9uIGlzVmFsaWROdW1iZXIobnVtYmVyU3RyaW5nKSB7XG4gIHJldHVybiAhKCFudW1iZXJTdHJpbmcgfHwgaXNOYU4oTnVtYmVyKG51bWJlclN0cmluZykpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyU3RyaW5nKG51bWJlclN0cmluZykge1xuICBpZiAoIW51bWJlclN0cmluZyB8fCAhc3RyaW5nQ29udGFpbnNOdW1iZXJzKG51bWJlclN0cmluZykpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gc2FuaXRpemVFeHBvbmVudGlhbE51bWJlclN0cmluZyhudW1iZXJTdHJpbmcsIChub25FeHBvTnVtU3RyaW5nKSA9PiB7XG4gICAgbGV0IGNvbnRhaW5zRGVjaW1hbCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5vbkV4cG9OdW1TdHJpbmdcbiAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgLmZpbHRlcigodmFsdWUsIGkpID0+IHtcbiAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXFwuL2cpICYmICFjb250YWluc0RlY2ltYWwpIHtcbiAgICAgICAgY29udGFpbnNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUubWF0Y2goL1xcLS9nKSAmJiBpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcktleXMuaW5jbHVkZXModmFsdWUpO1xuICAgIH0pXG4gICAgICAucmVkdWNlKChzdHJpbmcsIHBhcnQpID0+IHN0cmluZyArIHBhcnQpO1xuICAgIHJldHVybiBpc1ZhbGlkTnVtYmVyKHJlc3VsdCkgPyBuZXcgQmlnRGVjaW1hbChyZXN1bHQpLnRvU3RyaW5nKCkgOiBcIlwiO1xuICB9KTtcbn1cbi8vIHJlZ2V4IGZvciBudW1iZXIgc2FuaXRpemF0aW9uXG5jb25zdCBhbGxMZWFkaW5nWmVyb3NPcHRpb25hbGx5TmVnYXRpdmUgPSAvXihbLTBdKTArKD89XFxkKS87XG5jb25zdCBkZWNpbWFsT25seUF0RW5kT2ZTdHJpbmcgPSAvKD8hXlxcLilcXC4kLztcbmNvbnN0IGFsbEh5cGhlbnNFeGNlcHRUaGVTdGFydCA9IC8oPyFeLSktL2c7XG5jb25zdCBpc05lZ2F0aXZlRGVjaW1hbE9ubHlaZXJvcyA9IC9eLVxcYjBcXGJcXC4/MCokLztcbmNvbnN0IHNhbml0aXplTnVtYmVyU3RyaW5nID0gKG51bWJlclN0cmluZykgPT4gc2FuaXRpemVFeHBvbmVudGlhbE51bWJlclN0cmluZyhudW1iZXJTdHJpbmcsIChub25FeHBvTnVtU3RyaW5nKSA9PiB7XG4gIGNvbnN0IHNhbml0aXplZFZhbHVlID0gbm9uRXhwb051bVN0cmluZ1xuICAgIC5yZXBsYWNlKGFsbEh5cGhlbnNFeGNlcHRUaGVTdGFydCwgXCJcIilcbiAgICAucmVwbGFjZShkZWNpbWFsT25seUF0RW5kT2ZTdHJpbmcsIFwiXCIpXG4gICAgLnJlcGxhY2UoYWxsTGVhZGluZ1plcm9zT3B0aW9uYWxseU5lZ2F0aXZlLCBcIiQxXCIpO1xuICByZXR1cm4gaXNWYWxpZE51bWJlcihzYW5pdGl6ZWRWYWx1ZSlcbiAgICA/IGlzTmVnYXRpdmVEZWNpbWFsT25seVplcm9zLnRlc3Qoc2FuaXRpemVkVmFsdWUpXG4gICAgICA/IHNhbml0aXplZFZhbHVlXG4gICAgICA6IG5ldyBCaWdEZWNpbWFsKHNhbml0aXplZFZhbHVlKS50b1N0cmluZygpXG4gICAgOiBub25FeHBvTnVtU3RyaW5nO1xufSk7XG5mdW5jdGlvbiBzYW5pdGl6ZUV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKG51bWJlclN0cmluZywgZnVuYykge1xuICBpZiAoIW51bWJlclN0cmluZykge1xuICAgIHJldHVybiBudW1iZXJTdHJpbmc7XG4gIH1cbiAgY29uc3QgZmlyc3RFID0gbnVtYmVyU3RyaW5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImVcIikgKyAxO1xuICBpZiAoIWZpcnN0RSkge1xuICAgIHJldHVybiBmdW5jKG51bWJlclN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIG51bWJlclN0cmluZ1xuICAgIC5yZXBsYWNlKC9bZUVdKiQvZywgXCJcIilcbiAgICAuc3Vic3RyaW5nKDAsIGZpcnN0RSlcbiAgICAuY29uY2F0KG51bWJlclN0cmluZy5zbGljZShmaXJzdEUpLnJlcGxhY2UoL1tlRV0vZywgXCJcIikpXG4gICAgLnNwbGl0KC9bZUVdLylcbiAgICAubWFwKChzZWN0aW9uLCBpKSA9PiAoaSA9PT0gMSA/IGZ1bmMoc2VjdGlvbi5yZXBsYWNlKC9cXC4vZywgXCJcIikpIDogZnVuYyhzZWN0aW9uKSkpXG4gICAgLmpvaW4oXCJlXCIpXG4gICAgLnJlcGxhY2UoL15lLywgXCIxZVwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0NvbnRhaW5zTnVtYmVycyhzdHJpbmcpIHtcbiAgcmV0dXJuIG51bWJlcktleXMuc29tZSgobnVtYmVyKSA9PiBzdHJpbmcuaW5jbHVkZXMobnVtYmVyKSk7XG59XG5cbmNvbnN0IGRlZmF1bHRMb2NhbGUgPSBcImVuXCI7XG5jb25zdCB0OW5Mb2NhbGVzID0gW1xuICBcImFyXCIsXG4gIFwiYmdcIixcbiAgXCJic1wiLFxuICBcImNhXCIsXG4gIFwiY3NcIixcbiAgXCJkYVwiLFxuICBcImRlXCIsXG4gIFwiZWxcIixcbiAgZGVmYXVsdExvY2FsZSxcbiAgXCJlc1wiLFxuICBcImV0XCIsXG4gIFwiZmlcIixcbiAgXCJmclwiLFxuICBcImhlXCIsXG4gIFwiaHJcIixcbiAgXCJodVwiLFxuICBcImlkXCIsXG4gIFwiaXRcIixcbiAgXCJqYVwiLFxuICBcImtvXCIsXG4gIFwibHRcIixcbiAgXCJsdlwiLFxuICBcIm5vXCIsXG4gIFwibmxcIixcbiAgXCJwbFwiLFxuICBcInB0LUJSXCIsXG4gIFwicHQtUFRcIixcbiAgXCJyb1wiLFxuICBcInJ1XCIsXG4gIFwic2tcIixcbiAgXCJzbFwiLFxuICBcInNyXCIsXG4gIFwic3ZcIixcbiAgXCJ0aFwiLFxuICBcInRyXCIsXG4gIFwidWtcIixcbiAgXCJ2aVwiLFxuICBcInpoLUNOXCIsXG4gIFwiemgtSEtcIixcbiAgXCJ6aC1UV1wiXG5dO1xuY29uc3QgbG9jYWxlcyA9IFtcbiAgXCJhclwiLFxuICBcImJnXCIsXG4gIFwiYnNcIixcbiAgXCJjYVwiLFxuICBcImNzXCIsXG4gIFwiZGFcIixcbiAgXCJkZVwiLFxuICBcImRlLUNIXCIsXG4gIFwiZWxcIixcbiAgZGVmYXVsdExvY2FsZSxcbiAgXCJlbi1BVVwiLFxuICBcImVuLUNBXCIsXG4gIFwiZW4tR0JcIixcbiAgXCJlc1wiLFxuICBcImVzLU1YXCIsXG4gIFwiZXRcIixcbiAgXCJmaVwiLFxuICBcImZyXCIsXG4gIFwiZnItQ0hcIixcbiAgXCJoZVwiLFxuICBcImhpXCIsXG4gIFwiaHJcIixcbiAgXCJodVwiLFxuICBcImlkXCIsXG4gIFwiaXRcIixcbiAgXCJpdC1DSFwiLFxuICBcImphXCIsXG4gIFwia29cIixcbiAgXCJsdFwiLFxuICBcImx2XCIsXG4gIFwibWtcIixcbiAgXCJub1wiLFxuICBcIm5sXCIsXG4gIFwicGxcIixcbiAgXCJwdFwiLFxuICBcInB0LVBUXCIsXG4gIFwicm9cIixcbiAgXCJydVwiLFxuICBcInNrXCIsXG4gIFwic2xcIixcbiAgXCJzclwiLFxuICBcInN2XCIsXG4gIFwidGhcIixcbiAgXCJ0clwiLFxuICBcInVrXCIsXG4gIFwidmlcIixcbiAgXCJ6aC1DTlwiLFxuICBcInpoLUhLXCIsXG4gIFwiemgtVFdcIlxuXTtcbmNvbnN0IG51bWJlcmluZ1N5c3RlbXMgPSBbXG4gIFwiYXJhYlwiLFxuICBcImFyYWJleHRcIixcbiAgXCJiYWxpXCIsXG4gIFwiYmVuZ1wiLFxuICBcImRldmFcIixcbiAgXCJmdWxsd2lkZVwiLFxuICBcImd1anJcIixcbiAgXCJndXJ1XCIsXG4gIFwiaGFuaWRlY1wiLFxuICBcImtobXJcIixcbiAgXCJrbmRhXCIsXG4gIFwibGFvb1wiLFxuICBcImxhdG5cIixcbiAgXCJsaW1iXCIsXG4gIFwibWx5bVwiLFxuICBcIm1vbmdcIixcbiAgXCJteW1yXCIsXG4gIFwib3J5YVwiLFxuICBcInRhbWxkZWNcIixcbiAgXCJ0ZWx1XCIsXG4gIFwidGhhaVwiLFxuICBcInRpYnRcIlxuXTtcbmNvbnN0IGlzTnVtYmVyaW5nU3lzdGVtU3VwcG9ydGVkID0gKG51bWJlcmluZ1N5c3RlbSkgPT4gbnVtYmVyaW5nU3lzdGVtcy5pbmNsdWRlcyhudW1iZXJpbmdTeXN0ZW0pO1xuY29uc3QgYnJvd3Nlck51bWJlcmluZ1N5c3RlbSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLm51bWJlcmluZ1N5c3RlbTtcbmNvbnN0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBicm93c2VyTnVtYmVyaW5nU3lzdGVtID09PSBcImFyYWJcIiB8fCAhaXNOdW1iZXJpbmdTeXN0ZW1TdXBwb3J0ZWQoYnJvd3Nlck51bWJlcmluZ1N5c3RlbSlcbiAgPyBcImxhdG5cIlxuICA6IGJyb3dzZXJOdW1iZXJpbmdTeXN0ZW07XG5jb25zdCBnZXRTdXBwb3J0ZWROdW1iZXJpbmdTeXN0ZW0gPSAobnVtYmVyaW5nU3lzdGVtKSA9PiBpc051bWJlcmluZ1N5c3RlbVN1cHBvcnRlZChudW1iZXJpbmdTeXN0ZW0pID8gbnVtYmVyaW5nU3lzdGVtIDogZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbi8qKlxuICogR2V0cyB0aGUgbG9jYWxlIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBsb2NhbGUg4oCTIHRoZSBCQ1AgNDcgbG9jYWxlIGNvZGVcbiAqIEBwYXJhbSBjb250ZXh0IC0gc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGxvY2FsZSBjb2RlIHNob3VsZCBtYXRjaCBpbiB0aGUgY29udGV4dCBvZiBDTERSIG9yIFQ5TiAodHJhbnNsYXRpb24pXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZExvY2FsZShsb2NhbGUsIGNvbnRleHQgPSBcImNsZHJcIikge1xuICBjb25zdCBjb250ZXh0dWFsTG9jYWxlcyA9IGNvbnRleHQgPT09IFwiY2xkclwiID8gbG9jYWxlcyA6IHQ5bkxvY2FsZXM7XG4gIGlmICghbG9jYWxlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cbiAgaWYgKGNvbnRleHR1YWxMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICByZXR1cm4gbG9jYWxlO1xuICB9XG4gIGxvY2FsZSA9IGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAvLyB3ZSBzdXBwb3J0IGJvdGggJ25iJyBhbmQgJ25vJyAoQkNQIDQ3KSBmb3IgTm9yd2VnaWFuIGJ1dCBvbmx5IGBub2AgaGFzIGNvcnJlc3BvbmRpbmcgYnVuZGxlXG4gIGlmIChsb2NhbGUgPT09IFwibmJcIikge1xuICAgIHJldHVybiBcIm5vXCI7XG4gIH1cbiAgLy8gd2UgdXNlIGBwdC1CUmAgYXMgaXQgd2lsbCBoYXZlIHRoZSBzYW1lIHRyYW5zbGF0aW9ucyBhcyBgcHRgLCB3aGljaCBoYXMgbm8gY29ycmVzcG9uZGluZyBidW5kbGVcbiAgaWYgKGNvbnRleHQgPT09IFwidDluXCIgJiYgbG9jYWxlID09PSBcInB0XCIpIHtcbiAgICByZXR1cm4gXCJwdC1CUlwiO1xuICB9XG4gIGlmIChsb2NhbGUuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgbG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoLyhcXHcrKS0oXFx3KykvLCAoX21hdGNoLCBsYW5ndWFnZSwgcmVnaW9uKSA9PiBgJHtsYW5ndWFnZX0tJHtyZWdpb24udG9VcHBlckNhc2UoKX1gKTtcbiAgICBpZiAoIWNvbnRleHR1YWxMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgIGxvY2FsZSA9IGxvY2FsZS5zcGxpdChcIi1cIilbMF07XG4gICAgfVxuICB9XG4gIC8vIHdlIGNhbiBgemgtQ05gIGFzIGJhc2UgdHJhbnNsYXRpb24gZm9yIGNoaW5lc2UgbG9jYWxlcyB3aGljaCBoYXMgbm8gY29ycmVzcG9uZGluZyBidW5kbGUuXG4gIGlmIChsb2NhbGUgPT09IFwiemhcIikge1xuICAgIHJldHVybiBcInpoLUNOXCI7XG4gIH1cbiAgaWYgKCFjb250ZXh0dWFsTG9jYWxlcy5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgY29uc29sZS53YXJuKGBUcmFuc2xhdGlvbnMgZm9yIHRoZSBcIiR7bG9jYWxlfVwiIGxvY2FsZSBhcmUgbm90IGF2YWlsYWJsZSBhbmQgd2lsbCBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQsIEVuZ2xpc2ggKGVuKS5gKTtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuICByZXR1cm4gbG9jYWxlO1xufVxuY29uc3QgY29ubmVjdGVkQ29tcG9uZW50cyA9IG5ldyBTZXQoKTtcbi8qKlxuICogVGhpcyB1dGlsaXR5IHNldHMgdXAgaW50ZXJuYWxzIGZvciBtZXNzYWdlcyBzdXBwb3J0LlxuICpcbiAqIEl0IG5lZWRzIHRvIGJlIGNhbGxlZCBpbiBgY29ubmVjdGVkQ2FsbGJhY2tgIGJlZm9yZSBhbnkgbG9naWMgdGhhdCBkZXBlbmRzIG9uIGxvY2FsZVxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gY29ubmVjdExvY2FsaXplZChjb21wb25lbnQpIHtcbiAgdXBkYXRlRWZmZWN0aXZlTG9jYWxlKGNvbXBvbmVudCk7XG4gIGlmIChjb25uZWN0ZWRDb21wb25lbnRzLnNpemUgPT09IDApIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyPy5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wibGFuZ1wiXSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjb25uZWN0ZWRDb21wb25lbnRzLmFkZChjb21wb25lbnQpO1xufVxuLyoqXG4gKiBUaGlzIGlzIG9ubHkgZXhwb3J0ZWQgZm9yIGNvbXBvbmVudHMgdGhhdCBpbXBsZW1lbnRlZCB0aGUgbm93IGRlcHJlY2F0ZWQgYGxvY2FsZWAgcHJvcC5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgdXRpbHMgZm9yIG5ldyBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRWZmZWN0aXZlTG9jYWxlKGNvbXBvbmVudCkge1xuICBjb21wb25lbnQuZWZmZWN0aXZlTG9jYWxlID0gZ2V0TG9jYWxlKGNvbXBvbmVudCk7XG59XG4vKipcbiAqIFRoaXMgdXRpbGl0eSB0ZWFycyBkb3duIGludGVybmFscyBmb3IgbWVzc2FnZXMgc3VwcG9ydC5cbiAqXG4gKiBJdCBuZWVkcyB0byBiZSBjYWxsZWQgaW4gYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gZGlzY29ubmVjdExvY2FsaXplZChjb21wb25lbnQpIHtcbiAgY29ubmVjdGVkQ29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50KTtcbiAgaWYgKGNvbm5lY3RlZENvbXBvbmVudHMuc2l6ZSA9PT0gMCkge1xuICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG59XG5jb25zdCBtdXRhdGlvbk9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIoXCJtdXRhdGlvblwiLCAocmVjb3JkcykgPT4ge1xuICByZWNvcmRzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuICAgIGNvbnN0IGVsID0gcmVjb3JkLnRhcmdldDtcbiAgICBjb25uZWN0ZWRDb21wb25lbnRzLmZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgY29uc3QgaW5VbnJlbGF0ZWRTdWJ0cmVlID0gIWNvbnRhaW5zQ3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgY29tcG9uZW50LmVsKTtcbiAgICAgIGlmIChpblVucmVsYXRlZFN1YnRyZWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xvc2VzdExhbmdFbCA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShjb21wb25lbnQuZWwsIFwiW2xhbmddXCIpO1xuICAgICAgaWYgKCFjbG9zZXN0TGFuZ0VsKSB7XG4gICAgICAgIGNvbXBvbmVudC5lZmZlY3RpdmVMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjbG9zZXN0TGFuZyA9IGNsb3Nlc3RMYW5nRWwubGFuZztcbiAgICAgIGNvbXBvbmVudC5lZmZlY3RpdmVMb2NhbGUgPVxuICAgICAgICAvLyB1c2VyIHNldCBsYW5nPVwiXCIgbWVhbnMgdW5rbm93biBsYW5ndWFnZSwgc28gd2UgdXNlIGRlZmF1bHRcbiAgICAgICAgY2xvc2VzdExhbmdFbC5oYXNBdHRyaWJ1dGUoXCJsYW5nXCIpICYmIGNsb3Nlc3RMYW5nID09PSBcIlwiID8gZGVmYXVsdExvY2FsZSA6IGNsb3Nlc3RMYW5nO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuLyoqXG4gKiBUaGlzIHV0aWwgaGVscHMgcmVzb2x2ZSBhIGNvbXBvbmVudCdzIGxvY2FsZS5cbiAqIEl0IHdpbGwgYWxzbyBmYWxsIGJhY2sgb24gdGhlIGRlcHJlY2F0ZWQgYGxvY2FsZWAgaWYgYSBjb21wb25lbnQgaW1wbGVtZW50ZWQgdGhpcyBwcmV2aW91c2x5LlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxlKGNvbXBvbmVudCkge1xuICByZXR1cm4gKGNvbXBvbmVudC5lbC5sYW5nIHx8XG4gICAgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGNvbXBvbmVudC5lbCwgXCJbbGFuZ11cIik/LmxhbmcgfHxcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyB8fFxuICAgIGRlZmF1bHRMb2NhbGUpO1xufVxuLyoqXG4gKiBUaGlzIHV0aWwgZm9ybWF0cyBhbmQgcGFyc2VzIG51bWJlcnMgZm9yIGxvY2FsaXphdGlvblxuICovXG5jbGFzcyBOdW1iZXJTdHJpbmdGb3JtYXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRlbG9jYWxpemUgPSAobnVtYmVyU3RyaW5nKSA9PiBcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UsIChkZSlsb2NhbGl6YXRpb24gaXMgc2tpcHBlZCBpZiB0aGUgZm9ybWF0dGVyIGlzbid0IGluaXRpYWxpemVkLlxuICAgIC8vIEluIG9yZGVyIHRvIGxvY2FsaXplL2RlbG9jYWxpemUsIGUuZy4gd2hlbiBsYW5nL251bWJlcmluZ1N5c3RlbSBwcm9wcyBhcmUgbm90IGRlZmF1bHQgdmFsdWVzLFxuICAgIC8vIGBudW1iZXJGb3JtYXRPcHRpb25zYCBtdXN0IGJlIHNldCBpbiBhIGNvbXBvbmVudCB0byBjcmVhdGUgYW5kIGNhY2hlIHRoZSBmb3JtYXR0ZXIuXG4gICAgdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9uc1xuICAgICAgPyBzYW5pdGl6ZUV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKG51bWJlclN0cmluZywgKG5vbkV4cG9OdW1TdHJpbmcpID0+IG5vbkV4cG9OdW1TdHJpbmdcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGBbJHt0aGlzLl9taW51c1NpZ259XWAsIFwiZ1wiKSwgXCItXCIpXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX2dyb3VwfV1gLCBcImdcIiksIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX2RlY2ltYWx9XWAsIFwiZ1wiKSwgXCIuXCIpXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX2RpZ2l0cy5qb2luKFwiXCIpfV1gLCBcImdcIiksIHRoaXMuX2dldERpZ2l0SW5kZXgpKVxuICAgICAgOiBudW1iZXJTdHJpbmc7XG4gICAgdGhpcy5sb2NhbGl6ZSA9IChudW1iZXJTdHJpbmcpID0+IHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnNcbiAgICAgID8gc2FuaXRpemVFeHBvbmVudGlhbE51bWJlclN0cmluZyhudW1iZXJTdHJpbmcsIChub25FeHBvTnVtU3RyaW5nKSA9PiBpc1ZhbGlkTnVtYmVyKG5vbkV4cG9OdW1TdHJpbmcudHJpbSgpKVxuICAgICAgICA/IG5ldyBCaWdEZWNpbWFsKG5vbkV4cG9OdW1TdHJpbmcudHJpbSgpKVxuICAgICAgICAgIC5mb3JtYXQodGhpcylcbiAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGBbJHt0aGlzLl9hY3R1YWxHcm91cH1dYCwgXCJnXCIpLCB0aGlzLl9ncm91cClcbiAgICAgICAgOiBub25FeHBvTnVtU3RyaW5nKVxuICAgICAgOiBudW1iZXJTdHJpbmc7XG4gIH1cbiAgZ2V0IGdyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cDtcbiAgfVxuICBnZXQgZGVjaW1hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjaW1hbDtcbiAgfVxuICBnZXQgbWludXNTaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9taW51c1NpZ247XG4gIH1cbiAgZ2V0IGRpZ2l0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlnaXRzO1xuICB9XG4gIGdldCBudW1iZXJGb3JtYXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX251bWJlckZvcm1hdHRlcjtcbiAgfVxuICBnZXQgbnVtYmVyRm9ybWF0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogbnVtYmVyRm9ybWF0T3B0aW9ucyBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIGxvY2FsaXplL2RlbG9jYWxpemUgaXMgY2FsbGVkIHRvIGVuc3VyZSB0aGUgb3B0aW9ucyBhcmUgdXAgdG8gZGF0ZVxuICAgKi9cbiAgc2V0IG51bWJlckZvcm1hdE9wdGlvbnMob3B0aW9ucykge1xuICAgIG9wdGlvbnMubG9jYWxlID0gZ2V0U3VwcG9ydGVkTG9jYWxlKG9wdGlvbnM/LmxvY2FsZSk7XG4gICAgb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gPSBnZXRTdXBwb3J0ZWROdW1iZXJpbmdTeXN0ZW0ob3B0aW9ucz8ubnVtYmVyaW5nU3lzdGVtKTtcbiAgICBpZiAoXG4gICAgLy8gTm8gbmVlZCB0byBjcmVhdGUgdGhlIGZvcm1hdHRlciBpZiBgbG9jYWxlYCBhbmQgYG51bWJlcmluZ1N5c3RlbWBcbiAgICAvLyBhcmUgdGhlIGRlZmF1bHQgdmFsdWVzIGFuZCBgbnVtYmVyRm9ybWF0T3B0aW9uc2AgaGFzIG5vdCBiZWVuIHNldFxuICAgICghdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucyAmJlxuICAgICAgb3B0aW9ucy5sb2NhbGUgPT09IGRlZmF1bHRMb2NhbGUgJiZcbiAgICAgIG9wdGlvbnMubnVtYmVyaW5nU3lzdGVtID09PSBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtICYmXG4gICAgICAvLyBkb24ndCBza2lwIGluaXRpYWxpemF0aW9uIGlmIGFueSBvcHRpb25zIGJlc2lkZXMgbG9jYWxlL251bWJlcmluZ1N5c3RlbSBhcmUgc2V0XG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDIpIHx8XG4gICAgICAvLyBjYWNoZSBmb3JtYXR0ZXIgYnkgb25seSByZWNyZWF0aW5nIHdoZW4gb3B0aW9ucyBjaGFuZ2VcbiAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMpID09PSBKU09OLnN0cmluZ2lmeShvcHRpb25zKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9udW1iZXJGb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucy5sb2NhbGUsIHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMpO1xuICAgIHRoaXMuX2RpZ2l0cyA9IFtcbiAgICAgIC4uLm5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLmxvY2FsZSwge1xuICAgICAgICB1c2VHcm91cGluZzogZmFsc2UsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbTogdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucy5udW1iZXJpbmdTeXN0ZW1cbiAgICAgIH0pLmZvcm1hdCg5ODc2NTQzMjEwKVxuICAgIF0ucmV2ZXJzZSgpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IE1hcCh0aGlzLl9kaWdpdHMubWFwKChkLCBpKSA9PiBbZCwgaV0pKTtcbiAgICBjb25zdCBwYXJ0cyA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLmxvY2FsZSkuZm9ybWF0VG9QYXJ0cygtMTIzNDU2NzguOSk7XG4gICAgdGhpcy5fYWN0dWFsR3JvdXAgPSBwYXJ0cy5maW5kKChkKSA9PiBkLnR5cGUgPT09IFwiZ3JvdXBcIikudmFsdWU7XG4gICAgLy8gY2hhbmdlIHdoaXRlc3BhY2UgZ3JvdXAgY2hhcmFjdGVycyB0aGF0IGRvbid0IHJlbmRlciBjb3JyZWN0bHlcbiAgICB0aGlzLl9ncm91cCA9IHRoaXMuX2FjdHVhbEdyb3VwLnRyaW0oKS5sZW5ndGggPT09IDAgPyBcIiBcIiA6IHRoaXMuX2FjdHVhbEdyb3VwO1xuICAgIHRoaXMuX2RlY2ltYWwgPSBwYXJ0cy5maW5kKChkKSA9PiBkLnR5cGUgPT09IFwiZGVjaW1hbFwiKS52YWx1ZTtcbiAgICB0aGlzLl9taW51c1NpZ24gPSBwYXJ0cy5maW5kKChkKSA9PiBkLnR5cGUgPT09IFwibWludXNTaWduXCIpLnZhbHVlO1xuICAgIHRoaXMuX2dldERpZ2l0SW5kZXggPSAoZCkgPT4gaW5kZXguZ2V0KGQpO1xuICB9XG59XG5jb25zdCBudW1iZXJTdHJpbmdGb3JtYXR0ZXIgPSBuZXcgTnVtYmVyU3RyaW5nRm9ybWF0KCk7XG5cbi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5cbmNvbnN0IGNvbXBvbmVudExhbmdUb01lc3NhZ2VCdW5kbGVDYWNoZSA9IHt9O1xuYXN5bmMgZnVuY3Rpb24gZ2V0TWVzc2FnZUJ1bmRsZShsYW5nLCBjb21wb25lbnQpIHtcbiAgY29uc3Qga2V5ID0gYCR7Y29tcG9uZW50fV8ke2xhbmd9YDtcbiAgaWYgKGNvbXBvbmVudExhbmdUb01lc3NhZ2VCdW5kbGVDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudExhbmdUb01lc3NhZ2VCdW5kbGVDYWNoZVtrZXldO1xuICB9XG4gIGNvbXBvbmVudExhbmdUb01lc3NhZ2VCdW5kbGVDYWNoZVtrZXldID0gZmV0Y2goZ2V0QXNzZXRQYXRoKGAuL2Fzc2V0cy8ke2NvbXBvbmVudH0vdDluL21lc3NhZ2VzXyR7bGFuZ30uanNvbmApKVxuICAgIC50aGVuKChyZXNwKSA9PiB7XG4gICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICB0aHJvd01lc3NhZ2VGZXRjaEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwLmpzb24oKTtcbiAgfSlcbiAgICAuY2F0Y2goKCkgPT4gdGhyb3dNZXNzYWdlRmV0Y2hFcnJvcigpKTtcbiAgcmV0dXJuIGNvbXBvbmVudExhbmdUb01lc3NhZ2VCdW5kbGVDYWNoZVtrZXldO1xufVxuZnVuY3Rpb24gdGhyb3dNZXNzYWdlRmV0Y2hFcnJvcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiY291bGQgbm90IGZldGNoIGNvbXBvbmVudCBtZXNzYWdlIGJ1bmRsZVwiKTtcbn1cbmZ1bmN0aW9uIG1lcmdlTWVzc2FnZXMoY29tcG9uZW50KSB7XG4gIGNvbXBvbmVudC5tZXNzYWdlcyA9IHtcbiAgICAuLi5jb21wb25lbnQuZGVmYXVsdE1lc3NhZ2VzLFxuICAgIC4uLmNvbXBvbmVudC5tZXNzYWdlT3ZlcnJpZGVzXG4gIH07XG59XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBzZXRzIHVwIHRoZSBtZXNzYWdlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIEl0IHNob3VsZCBiZSBhd2FpdGVkIGluIHRoZSBgY29tcG9uZW50V2lsbExvYWRgIGxpZmVjeWNsZSBob29rLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2V0VXBNZXNzYWdlcyhjb21wb25lbnQpIHtcbiAgY29tcG9uZW50LmRlZmF1bHRNZXNzYWdlcyA9IGF3YWl0IGZldGNoTWVzc2FnZXMoY29tcG9uZW50LCBjb21wb25lbnQuZWZmZWN0aXZlTG9jYWxlKTtcbiAgbWVyZ2VNZXNzYWdlcyhjb21wb25lbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hNZXNzYWdlcyhjb21wb25lbnQsIGxhbmcpIHtcbiAgY29uc3QgeyBlbCB9ID0gY29tcG9uZW50O1xuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0YWcucmVwbGFjZShcImNhbGNpdGUtXCIsIFwiXCIpO1xuICByZXR1cm4gZ2V0TWVzc2FnZUJ1bmRsZShnZXRTdXBwb3J0ZWRMb2NhbGUobGFuZywgXCJ0OW5cIiksIGNvbXBvbmVudE5hbWUpO1xufVxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgbXVzdCBiZSBzZXQgdXAgZm9yIHRoZSBjb21wb25lbnQgdG8gdXBkYXRlIGl0cyBkZWZhdWx0IG1lc3NhZ2UgYnVuZGxlIGlmIHRoZSBsb2NhbGUgY2hhbmdlcy5cbiAqXG4gKiBJdCBjYW4gYmUgc2V0IHVwIGluICoqZWl0aGVyKiogb2YgdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqIDEuIGNhbGxlZCBmcm9tIGBMb2NhbGl6ZWRDb21wb25lbnRgJ3MgYG9uTG9jYWxlQ2hhbmdlYCBtZXRob2Qgb3JcbiAqIDIuIGNhbGxlZCBmcm9tIGEgd2F0Y2hlciBjb25maWd1cmVkIHRvIHdhdGNoIGBMb2NhbGl6ZWRDb21wb25lbnRgJ3MgYGVmZmVjdGl2ZUxvY2FsZWAgcHJvcFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEBwYXJhbSBsYW5nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU1lc3NhZ2VzKGNvbXBvbmVudCwgbGFuZykge1xuICBjb21wb25lbnQuZGVmYXVsdE1lc3NhZ2VzID0gYXdhaXQgZmV0Y2hNZXNzYWdlcyhjb21wb25lbnQsIGxhbmcpO1xuICBtZXJnZU1lc3NhZ2VzKGNvbXBvbmVudCk7XG59XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBzZXRzIHVwIGludGVybmFscyBmb3IgbWVzc2FnZXMgc3VwcG9ydC5cbiAqXG4gKiBJdCBuZWVkcyB0byBiZSBjYWxsZWQgaW4gYGNvbm5lY3RlZENhbGxiYWNrYFxuICpcbiAqICoqTm90ZSoqOiB0aGlzIG11c3QgYmUgY2FsbGVkIGFmdGVyIGBMb2NhbGl6ZWRDb21wb25lbnRgJ3MgYGNvbm5lY3RMb2NhbGl6ZWRgIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3RNZXNzYWdlcyhjb21wb25lbnQpIHtcbiAgY29tcG9uZW50Lm9uTWVzc2FnZXNDaGFuZ2UgPSBkZWZhdWx0T25NZXNzYWdlc0NoYW5nZTtcbn1cbi8qKlxuICogVGhpcyB1dGlsaXR5IHRlYXJzIGRvd24gaW50ZXJuYWxzIGZvciBtZXNzYWdlcyBzdXBwb3J0LlxuICpcbiAqIEl0IG5lZWRzIHRvIGJlIGNhbGxlZCBpbiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBkaXNjb25uZWN0TWVzc2FnZXMoY29tcG9uZW50KSB7XG4gIGNvbXBvbmVudC5vbk1lc3NhZ2VzQ2hhbmdlID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uTWVzc2FnZXNDaGFuZ2UoKSB7XG4gIG1lcmdlTWVzc2FnZXModGhpcyk7XG59XG5cbi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5cbmNvbnN0IENTUyQ0ID0ge1xuICBpY29uOiBcImljb25cIixcbiAgZmxpcFJ0bDogXCJmbGlwLXJ0bFwiXG59O1xuXG4vKipcbiAqIEljb24gZGF0YSBjYWNoZS5cbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGljb25DYWNoZSA9IHt9O1xuLyoqXG4gKiBJY29uIHJlcXVlc3QgY2FjaGUuXG4gKiBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCByZXF1ZXN0Q2FjaGUgPSB7fTtcbmNvbnN0IHNjYWxlVG9QeCA9IHtcbiAgczogMTYsXG4gIG06IDI0LFxuICBsOiAzMlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoSWNvbih7IGljb24sIHNjYWxlIH0pIHtcbiAgY29uc3Qgc2l6ZSA9IHNjYWxlVG9QeFtzY2FsZV07XG4gIGNvbnN0IG5hbWUgPSBub3JtYWxpemVJY29uTmFtZShpY29uKTtcbiAgY29uc3QgZmlsbGVkID0gbmFtZS5jaGFyQXQobmFtZS5sZW5ndGggLSAxKSA9PT0gXCJGXCI7XG4gIGNvbnN0IGljb25OYW1lID0gZmlsbGVkID8gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKSA6IG5hbWU7XG4gIGNvbnN0IGlkID0gYCR7aWNvbk5hbWV9JHtzaXplfSR7ZmlsbGVkID8gXCJGXCIgOiBcIlwifWA7XG4gIGlmIChpY29uQ2FjaGVbaWRdKSB7XG4gICAgcmV0dXJuIGljb25DYWNoZVtpZF07XG4gIH1cbiAgaWYgKCFyZXF1ZXN0Q2FjaGVbaWRdKSB7XG4gICAgcmVxdWVzdENhY2hlW2lkXSA9IGZldGNoKGdldEFzc2V0UGF0aChgLi9hc3NldHMvaWNvbi8ke2lkfS5qc29uYCkpXG4gICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5qc29uKCkpXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihgXCIke2lkfVwiIGlzIG5vdCBhIHZhbGlkIGNhbGNpdGUtdWktaWNvbiBuYW1lYCk7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwYXRoID0gYXdhaXQgcmVxdWVzdENhY2hlW2lkXTtcbiAgaWNvbkNhY2hlW2lkXSA9IHBhdGg7XG4gIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGljb24gbmFtZSB0byBtYXRjaCB0aGUgcGF0aCBkYXRhIG1vZHVsZSBleHBvcnRzLlxuICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHBhcmFtIG5hbWUg4oCTIGFuIGljb24gbmFtZSB0aGF0IGNhbiBiZSBlaXRoZXIga2ViYWIgb3IgY2FtZWwtY2FzZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUljb25OYW1lKG5hbWUpIHtcbiAgY29uc3QgbnVtYmVyTGVhZGluZ05hbWUgPSAhaXNOYU4oTnVtYmVyKG5hbWUuY2hhckF0KDApKSk7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdChcIi1cIik7XG4gIGNvbnN0IGtlYmFiQ2FzZWQgPSBwYXJ0cy5sZW5ndGggPiAwO1xuICBpZiAoa2ViYWJDYXNlZCkge1xuICAgIGNvbnN0IGZpcnN0Tm9uRGlnaXRJblBhcnRQYXR0ZXJuID0gL1thLXpdL2k7XG4gICAgbmFtZSA9IHBhcnRzXG4gICAgICAubWFwKChwYXJ0LCBwYXJ0SW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBwYXJ0LnJlcGxhY2UoZmlyc3ROb25EaWdpdEluUGFydFBhdHRlcm4sIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdENoYXJJbk5hbWUgPSBwYXJ0SW5kZXggPT09IDAgJiYgb2Zmc2V0ID09PSAwO1xuICAgICAgICBpZiAoaXNGaXJzdENoYXJJbk5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9KVxuICAgICAgLmpvaW4oXCJcIik7XG4gIH1cbiAgcmV0dXJuIG51bWJlckxlYWRpbmdOYW1lID8gYGkke25hbWV9YCA6IG5hbWU7XG59XG5cbmNvbnN0IGljb25Dc3MgPSBcIkBrZXlmcmFtZXMgaW57MCV7b3BhY2l0eTowfTEwMCV7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGluLWRvd257MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAtNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tdXB7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCA1cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi1zY2FsZXswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM0QoMC45NSwgMC45NSwgMSl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM0QoMSwgMSwgMSl9fTpyb290ey0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nOmNhbGMoMTUwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6dmFyKC0tY2FsY2l0ZS1kdXJhdGlvbi1mYWN0b3IsIDEpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3Q6Y2FsYygxMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtOmNhbGMoMjAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3c6Y2FsYygzMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSl9LmNhbGNpdGUtYW5pbWF0ZXtvcGFjaXR5OjA7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO2FuaW1hdGlvbi1kdXJhdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpfS5jYWxjaXRlLWFuaW1hdGVfX2lue2FuaW1hdGlvbi1uYW1lOmlufS5jYWxjaXRlLWFuaW1hdGVfX2luLWRvd257YW5pbWF0aW9uLW5hbWU6aW4tZG93bn0uY2FsY2l0ZS1hbmltYXRlX19pbi11cHthbmltYXRpb24tbmFtZTppbi11cH0uY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZXthbmltYXRpb24tbmFtZTppbi1zY2FsZX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7OnJvb3R7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcjowfX06cm9vdHstLWNhbGNpdGUtZmxvYXRpbmctdWktdHJhbnNpdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpOy0tY2FsY2l0ZS1mbG9hdGluZy11aS16LWluZGV4OjYwMH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfTpob3N0e2Rpc3BsYXk6aW5saW5lLWZsZXg7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS1pY29uLWNvbG9yKX06aG9zdChbc2NhbGU9c10pe2Jsb2NrLXNpemU6MXJlbTtpbmxpbmUtc2l6ZToxcmVtO21pbi1pbmxpbmUtc2l6ZToxcmVtO21pbi1ibG9jay1zaXplOjFyZW19Omhvc3QoW3NjYWxlPW1dKXtibG9jay1zaXplOjEuNXJlbTtpbmxpbmUtc2l6ZToxLjVyZW07bWluLWlubGluZS1zaXplOjEuNXJlbTttaW4tYmxvY2stc2l6ZToxLjVyZW19Omhvc3QoW3NjYWxlPWxdKXtibG9jay1zaXplOjJyZW07aW5saW5lLXNpemU6MnJlbTttaW4taW5saW5lLXNpemU6MnJlbTttaW4tYmxvY2stc2l6ZToycmVtfS5mbGlwLXJ0bHt0cmFuc2Zvcm06c2NhbGVYKC0xKX0uc3Zne2Rpc3BsYXk6YmxvY2t9XCI7XG5cbmNvbnN0IEljb24gPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5pY29uID0gbnVsbDtcbiAgICB0aGlzLmZsaXBSdGwgPSBmYWxzZTtcbiAgICB0aGlzLnNjYWxlID0gXCJtXCI7XG4gICAgdGhpcy50ZXh0TGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXRoRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLndhaXRVbnRpbFZpc2libGUoKCkgPT4ge1xuICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9hZEljb25QYXRoRGF0YSgpO1xuICAgIH0pO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgfVxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICB0aGlzLmxvYWRJY29uUGF0aERhdGEoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBlbCwgZmxpcFJ0bCwgcGF0aERhdGEsIHNjYWxlLCB0ZXh0TGFiZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgZGlyID0gZ2V0RWxlbWVudERpcihlbCk7XG4gICAgY29uc3Qgc2l6ZSA9IHNjYWxlVG9QeFtzY2FsZV07XG4gICAgY29uc3Qgc2VtYW50aWMgPSAhIXRleHRMYWJlbDtcbiAgICBjb25zdCBwYXRocyA9IFtdLmNvbmNhdChwYXRoRGF0YSB8fCBcIlwiKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBcImFyaWEtaGlkZGVuXCI6IHRvQXJpYUJvb2xlYW4oIXNlbWFudGljKSwgXCJhcmlhLWxhYmVsXCI6IHNlbWFudGljID8gdGV4dExhYmVsIDogbnVsbCwgcm9sZTogc2VtYW50aWMgPyBcImltZ1wiIDogbnVsbCB9LCBoKFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2xhc3M6IHtcbiAgICAgICAgW0NTUyQ0LmZsaXBSdGxdOiBkaXIgPT09IFwicnRsXCIgJiYgZmxpcFJ0bCxcbiAgICAgICAgc3ZnOiB0cnVlXG4gICAgICB9LCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCBoZWlnaHQ6IFwiMTAwJVwiLCB2aWV3Qm94OiBgMCAwICR7c2l6ZX0gJHtzaXplfWAsIHdpZHRoOiBcIjEwMCVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LCBwYXRocy5tYXAoKHBhdGgpID0+IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gKGgoXCJwYXRoXCIsIHsgZDogcGF0aCB9KSkgOiAoaChcInBhdGhcIiwgeyBkOiBwYXRoLmQsIG9wYWNpdHk6IFwib3BhY2l0eVwiIGluIHBhdGggPyBwYXRoLm9wYWNpdHkgOiAxIH0pKSkpKSk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXN5bmMgbG9hZEljb25QYXRoRGF0YSgpIHtcbiAgICBjb25zdCB7IGljb24sIHNjYWxlLCB2aXNpYmxlIH0gPSB0aGlzO1xuICAgIGlmICghaWNvbiB8fCAhdmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhdGhEYXRhID0gYXdhaXQgZmV0Y2hJY29uKHsgaWNvbiwgc2NhbGUgfSk7XG4gIH1cbiAgd2FpdFVudGlsVmlzaWJsZShjYWxsYmFjaykge1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcihcImludGVyc2VjdGlvblwiLCAoZW50cmllcykgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7IHJvb3RNYXJnaW46IFwiNTBweFwiIH0pO1xuICAgIGlmICghdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwpO1xuICB9XG4gIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcImFzc2V0c1wiXTsgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJpY29uXCI6IFtcImxvYWRJY29uUGF0aERhdGFcIl0sXG4gICAgXCJzY2FsZVwiOiBbXCJsb2FkSWNvblBhdGhEYXRhXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIGljb25Dc3M7IH1cbn0sIFsxLCBcImNhbGNpdGUtaWNvblwiLCB7XG4gICAgXCJpY29uXCI6IFs1MTNdLFxuICAgIFwiZmxpcFJ0bFwiOiBbNTE2LCBcImZsaXAtcnRsXCJdLFxuICAgIFwic2NhbGVcIjogWzUxM10sXG4gICAgXCJ0ZXh0TGFiZWxcIjogWzEsIFwidGV4dC1sYWJlbFwiXSxcbiAgICBcInBhdGhEYXRhXCI6IFszMl0sXG4gICAgXCJ2aXNpYmxlXCI6IFszMl1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQ4KCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJjYWxjaXRlLWljb25cIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtaWNvblwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIEljb24pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5kZWZpbmVDdXN0b21FbGVtZW50JDgoKTtcblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cblxuY29uc3QgbG9hZGVyQ3NzID0gXCJAY2hhcnNldCBcXFwiVVRGLThcXFwiO0BrZXlmcmFtZXMgaW57MCV7b3BhY2l0eTowfTEwMCV7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGluLWRvd257MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAtNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tdXB7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCA1cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi1zY2FsZXswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM0QoMC45NSwgMC45NSwgMSl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM0QoMSwgMSwgMSl9fTpyb290ey0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nOmNhbGMoMTUwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6dmFyKC0tY2FsY2l0ZS1kdXJhdGlvbi1mYWN0b3IsIDEpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3Q6Y2FsYygxMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtOmNhbGMoMjAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3c6Y2FsYygzMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSl9LmNhbGNpdGUtYW5pbWF0ZXtvcGFjaXR5OjA7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO2FuaW1hdGlvbi1kdXJhdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpfS5jYWxjaXRlLWFuaW1hdGVfX2lue2FuaW1hdGlvbi1uYW1lOmlufS5jYWxjaXRlLWFuaW1hdGVfX2luLWRvd257YW5pbWF0aW9uLW5hbWU6aW4tZG93bn0uY2FsY2l0ZS1hbmltYXRlX19pbi11cHthbmltYXRpb24tbmFtZTppbi11cH0uY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZXthbmltYXRpb24tbmFtZTppbi1zY2FsZX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7OnJvb3R7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcjowfX06cm9vdHstLWNhbGNpdGUtZmxvYXRpbmctdWktdHJhbnNpdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpOy0tY2FsY2l0ZS1mbG9hdGluZy11aS16LWluZGV4OjYwMH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfTpob3N0e3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1pbmxpbmU6YXV0bztkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7b3BhY2l0eToxO21pbi1ibG9jay1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUpO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWxvYWRlci1mb250LXNpemUpO3N0cm9rZTp2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKTtzdHJva2Utd2lkdGg6MztmaWxsOm5vbmU7dHJhbnNmb3JtOnNjYWxlKDEsIDEpO2FuaW1hdGlvbjpsb2FkZXItY29sb3Itc2hpZnQgY2FsYyh2YXIoLS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctc2xvdykgKiAyKSBhbHRlcm5hdGUtcmV2ZXJzZSBpbmZpbml0ZSBsaW5lYXI7cGFkZGluZy1ibG9jazp2YXIoLS1jYWxjaXRlLWxvYWRlci1wYWRkaW5nLCA0cmVtKX06aG9zdChbc2NhbGU9c10pey0tY2FsY2l0ZS1sb2FkZXItZm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTstLWNhbGNpdGUtbG9hZGVyLXNpemU6MnJlbTstLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lOjAuNzVyZW19Omhvc3QoW3NjYWxlPW1dKXstLWNhbGNpdGUtbG9hZGVyLWZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0wKTstLWNhbGNpdGUtbG9hZGVyLXNpemU6NHJlbTstLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lOjFyZW19Omhvc3QoW3NjYWxlPWxdKXstLWNhbGNpdGUtbG9hZGVyLWZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0yKTstLWNhbGNpdGUtbG9hZGVyLXNpemU6NnJlbTstLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lOjEuNXJlbX06aG9zdChbbm8tcGFkZGluZ10pe3BhZGRpbmctYmxvY2s6MHB4fTpob3N0e2Rpc3BsYXk6ZmxleH0ubG9hZGVyX190ZXh0e2Rpc3BsYXk6YmxvY2s7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtsaW5lLWhlaWdodDoxcmVtO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKTttYXJnaW4tYmxvY2stc3RhcnQ6Y2FsYyh2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplKSArIDEuNXJlbSl9LmxvYWRlcl9fcGVyY2VudGFnZXtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3RleHQtYWxpZ246Y2VudGVyO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1sb2FkZXItZm9udC1zaXplKTtpbmxpbmUtc2l6ZTp2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplKTtpbnNldC1pbmxpbmUtc3RhcnQ6NTAlO21hcmdpbi1pbmxpbmUtc3RhcnQ6Y2FsYyh2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplKSAvIDIgKiAtMSk7bGluZS1oZWlnaHQ6MC4yNTt0cmFuc2Zvcm06c2NhbGUoMSwgMSl9LmxvYWRlcl9fc3Znc3twb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzp2aXNpYmxlO29wYWNpdHk6MTtpbmxpbmUtc2l6ZTp2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplKTtibG9jay1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUpO2luc2V0LWlubGluZS1zdGFydDo1MCU7bWFyZ2luLWlubGluZS1zdGFydDpjYWxjKHZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUpIC8gMiAqIC0xKTt0cmFuc2Zvcm06c2NhbGUoMSwgMSl9LmxvYWRlcl9fc3Zne3Bvc2l0aW9uOmFic29sdXRlO2luc2V0LWJsb2NrLXN0YXJ0OjBweDt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcjtvdmVyZmxvdzp2aXNpYmxlO2luc2V0LWlubGluZS1zdGFydDowO2lubGluZS1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUpO2Jsb2NrLXNpemU6dmFyKC0tY2FsY2l0ZS1sb2FkZXItc2l6ZSk7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmxpbmVhcjthbmltYXRpb24tbmFtZTpsb2FkZXItY2xvY2t3aXNlfUBzdXBwb3J0cyAoZGlzcGxheTogZ3JpZCl7LmxvYWRlcl9fc3ZnLS0xe2FuaW1hdGlvbi1uYW1lOmxvYWRlci1vZmZzZXQtMX0ubG9hZGVyX19zdmctLTJ7YW5pbWF0aW9uLW5hbWU6bG9hZGVyLW9mZnNldC0yfS5sb2FkZXJfX3N2Zy0tM3thbmltYXRpb24tbmFtZTpsb2FkZXItb2Zmc2V0LTN9fTpob3N0KFt0eXBlPWRldGVybWluYXRlXSl7YW5pbWF0aW9uOm5vbmU7c3Ryb2tlOnZhcigtLWNhbGNpdGUtdWktYm9yZGVyLTMpfTpob3N0KFt0eXBlPWRldGVybWluYXRlXSkgLmxvYWRlcl9fc3ZnLS0ze2FuaW1hdGlvbjpub25lO3N0cm9rZTp2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKTtzdHJva2UtZGFzaGFycmF5OjE1MC43OTYzMjt0cmFuc2Zvcm06cm90YXRlKC05MGRlZyk7dHJhbnNpdGlvbjphbGwgdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3QpIGxpbmVhcn06aG9zdChbaW5saW5lXSl7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luOjBweDthbmltYXRpb246bm9uZTtzdHJva2U6Y3VycmVudENvbG9yO3N0cm9rZS13aWR0aDoyO3BhZGRpbmctYmxvY2s6MHB4O2Jsb2NrLXNpemU6dmFyKC0tY2FsY2l0ZS1sb2FkZXItc2l6ZS1pbmxpbmUpO21pbi1ibG9jay1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lKTtpbmxpbmUtc2l6ZTp2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplLWlubGluZSk7bWFyZ2luLWlubGluZS1lbmQ6Y2FsYyh2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplLWlubGluZSkgKiAwLjUpO3ZlcnRpY2FsLWFsaWduOmNhbGModmFyKC0tY2FsY2l0ZS1sb2FkZXItc2l6ZS1pbmxpbmUpICogLTEgKiAwLjIpfTpob3N0KFtpbmxpbmVdKSAubG9hZGVyX19zdmdze2luc2V0LWJsb2NrLXN0YXJ0OjBweDttYXJnaW46MHB4O2luc2V0LWlubGluZS1zdGFydDowO2lubGluZS1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lKTtibG9jay1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lKX06aG9zdChbaW5saW5lXSkgLmxvYWRlcl9fc3Zne2lubGluZS1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lKTtibG9jay1zaXplOnZhcigtLWNhbGNpdGUtbG9hZGVyLXNpemUtaW5saW5lKX06aG9zdChbY29tcGxldGVdKXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlKDAuNzUsIDAuNzUpO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO3RyYW5zaXRpb246b3BhY2l0eSB2YXIoLS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtKSBsaW5lYXIgMTAwMG1zLCB0cmFuc2Zvcm0gdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLW1lZGl1bSkgbGluZWFyIDEwMDBtc306aG9zdChbY29tcGxldGVdKSAubG9hZGVyX19zdmdze29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUoMC43NSwgMC43NSk7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7dHJhbnNpdGlvbjpvcGFjaXR5IGNhbGMoMTgwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpIGxpbmVhciA4MDBtcywgdHJhbnNmb3JtIGNhbGMoMTgwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpIGxpbmVhciA4MDBtc306aG9zdChbY29tcGxldGVdKSAubG9hZGVyX19wZXJjZW50YWdle2NvbG9yOnZhcigtLWNhbGNpdGUtdWktYnJhbmQpO3RyYW5zZm9ybTpzY2FsZSgxLjA1LCAxLjA1KTt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcjt0cmFuc2l0aW9uOmNvbG9yIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1tZWRpdW0pIGxpbmVhciwgdHJhbnNmb3JtIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1tZWRpdW0pIGxpbmVhcn0ubG9hZGVyX19zdmctLTF7c3Ryb2tlLWRhc2hhcnJheToyNy45MjUyNDQ0NDQ0JSAxMzkuNjI2MjIyMjIyMiU7YW5pbWF0aW9uLWR1cmF0aW9uOmNhbGModmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3cpICogMi40KX1Aa2V5ZnJhbWVzIGxvYWRlci1vZmZzZXQtMXswJXtzdHJva2UtZGFzaGFycmF5OjI3LjkyNTI0NDQ0NDQlIDI1MS4zMjcyJTtzdHJva2UtZGFzaG9mZnNldDowfTUwJXtzdHJva2UtZGFzaGFycmF5OjEzOS42MjYyMjIyMjIyJSAxMzkuNjI2MjIyMjIyMiU7c3Ryb2tlLWRhc2hvZmZzZXQ6LTgzLjc3NTczMzMzMzMlfTEwMCV7c3Ryb2tlLWRhc2hhcnJheToyNy45MjUyNDQ0NDQ0JSAyNTEuMzI3MiU7c3Ryb2tlLWRhc2hvZmZzZXQ6LTI3OS4yNTI0NDQ0NDQ0JX19LmxvYWRlcl9fc3ZnLS0ye3N0cm9rZS1kYXNoYXJyYXk6NTUuODUwNDg4ODg4OSUgMTM5LjYyNjIyMjIyMjIlO2FuaW1hdGlvbi1kdXJhdGlvbjpjYWxjKHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1zbG93KSAqIDMuMil9QGtleWZyYW1lcyBsb2FkZXItb2Zmc2V0LTJ7MCV7c3Ryb2tlLWRhc2hhcnJheTo1NS44NTA0ODg4ODg5JSAyMjMuNDAxOTU1NTU1NiU7c3Ryb2tlLWRhc2hvZmZzZXQ6MH01MCV7c3Ryb2tlLWRhc2hhcnJheToxMzkuNjI2MjIyMjIyMiUgMTM5LjYyNjIyMjIyMjIlO3N0cm9rZS1kYXNob2Zmc2V0Oi05Ny43MzgzNTU1NTU2JX0xMDAle3N0cm9rZS1kYXNoYXJyYXk6NTUuODUwNDg4ODg4OSUgMjIzLjQwMTk1NTU1NTYlO3N0cm9rZS1kYXNob2Zmc2V0Oi0yNzkuMjUyNDQ0NDQ0NCV9fS5sb2FkZXJfX3N2Zy0tM3tzdHJva2UtZGFzaGFycmF5OjEzLjk2MjYyMjIyMjIlIDEzOS42MjYyMjIyMjIyJTthbmltYXRpb24tZHVyYXRpb246Y2FsYyh2YXIoLS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctc2xvdykgKiAzLjg2Nyl9QGtleWZyYW1lcyBsb2FkZXItb2Zmc2V0LTN7MCV7c3Ryb2tlLWRhc2hhcnJheToxMy45NjI2MjIyMjIyJSAyNjUuMjg5ODIyMjIyMiU7c3Ryb2tlLWRhc2hvZmZzZXQ6MH01MCV7c3Ryb2tlLWRhc2hhcnJheToxMzkuNjI2MjIyMjIyMiUgMTM5LjYyNjIyMjIyMjIlO3N0cm9rZS1kYXNob2Zmc2V0Oi03Ni43OTQ0MjIyMjIyJX0xMDAle3N0cm9rZS1kYXNoYXJyYXk6MTMuOTYyNjIyMjIyMiUgMjY1LjI4OTgyMjIyMjIlO3N0cm9rZS1kYXNob2Zmc2V0Oi0yNzkuMjUyNDQ0NDQ0NCV9fUBrZXlmcmFtZXMgbG9hZGVyLWNvbG9yLXNoaWZ0ezAle3N0cm9rZTp2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKX0zMyV7c3Ryb2tlOnZhcigtLWNhbGNpdGUtdWktYnJhbmQtcHJlc3MpfTY2JXtzdHJva2U6dmFyKC0tY2FsY2l0ZS11aS1icmFuZC1ob3Zlcil9MTAwJXtzdHJva2U6dmFyKC0tY2FsY2l0ZS11aS1icmFuZCl9fUBrZXlmcmFtZXMgbG9hZGVyLWNsb2Nrd2lzZXswJXt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1cIjtcblxuY29uc3QgTG9hZGVyID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuaW5saW5lID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlID0gXCJtXCI7XG4gICAgdGhpcy50eXBlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsdWUgPSAwO1xuICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZWwsIGlubGluZSwgbGFiZWwsIHNjYWxlLCB0ZXh0LCB0eXBlLCB2YWx1ZSB9ID0gdGhpcztcbiAgICBjb25zdCBpZCA9IGVsLmlkIHx8IGd1aWQoKTtcbiAgICBjb25zdCByYWRpdXNSYXRpbyA9IDAuNDU7XG4gICAgY29uc3Qgc2l6ZSA9IGlubGluZSA/IHRoaXMuZ2V0SW5saW5lU2l6ZShzY2FsZSkgOiB0aGlzLmdldFNpemUoc2NhbGUpO1xuICAgIGNvbnN0IHJhZGl1cyA9IHNpemUgKiByYWRpdXNSYXRpbztcbiAgICBjb25zdCB2aWV3Ym94ID0gYDAgMCAke3NpemV9ICR7c2l6ZX1gO1xuICAgIGNvbnN0IGlzRGV0ZXJtaW5hdGUgPSB0eXBlID09PSBcImRldGVybWluYXRlXCI7XG4gICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IDIgKiByYWRpdXMgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHByb2dyZXNzID0gKHZhbHVlIC8gMTAwKSAqIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3QgcmVtYWluaW5nID0gY2lyY3VtZmVyZW5jZSAtIHByb2dyZXNzO1xuICAgIGNvbnN0IHZhbHVlTm93ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgY29uc3QgaG9zdEF0dHJpYnV0ZXMgPSB7XG4gICAgICBcImFyaWEtdmFsdWVub3dcIjogdmFsdWVOb3csXG4gICAgICBcImFyaWEtdmFsdWVtaW5cIjogMCxcbiAgICAgIFwiYXJpYS12YWx1ZW1heFwiOiAxMDAsXG4gICAgICBjb21wbGV0ZTogdmFsdWVOb3cgPT09IDEwMFxuICAgIH07XG4gICAgY29uc3Qgc3ZnQXR0cmlidXRlcyA9IHsgcjogcmFkaXVzLCBjeDogc2l6ZSAvIDIsIGN5OiBzaXplIC8gMiB9O1xuICAgIGNvbnN0IGRldGVybWluYXRlU3R5bGUgPSB7IFwic3Ryb2tlLWRhc2hhcnJheVwiOiBgJHtwcm9ncmVzc30gJHtyZW1haW5pbmd9YCB9O1xuICAgIHJldHVybiAoaChIb3N0LCB7IFwiYXJpYS1sYWJlbFwiOiBsYWJlbCwgaWQ6IGlkLCByb2xlOiBcInByb2dyZXNzYmFyXCIsIC4uLihpc0RldGVybWluYXRlID8gaG9zdEF0dHJpYnV0ZXMgOiB7fSkgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImxvYWRlcl9fc3Znc1wiIH0sIGgoXCJzdmdcIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjbGFzczogXCJsb2FkZXJfX3N2ZyBsb2FkZXJfX3N2Zy0tMVwiLCB2aWV3Qm94OiB2aWV3Ym94IH0sIGgoXCJjaXJjbGVcIiwgeyAuLi5zdmdBdHRyaWJ1dGVzIH0pKSwgaChcInN2Z1wiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNsYXNzOiBcImxvYWRlcl9fc3ZnIGxvYWRlcl9fc3ZnLS0yXCIsIHZpZXdCb3g6IHZpZXdib3ggfSwgaChcImNpcmNsZVwiLCB7IC4uLnN2Z0F0dHJpYnV0ZXMgfSkpLCBoKFwic3ZnXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2xhc3M6IFwibG9hZGVyX19zdmcgbG9hZGVyX19zdmctLTNcIiwgdmlld0JveDogdmlld2JveCwgLi4uKGlzRGV0ZXJtaW5hdGUgPyB7IHN0eWxlOiBkZXRlcm1pbmF0ZVN0eWxlIH0gOiB7fSkgfSwgaChcImNpcmNsZVwiLCB7IC4uLnN2Z0F0dHJpYnV0ZXMgfSkpKSwgdGV4dCAmJiBoKFwiZGl2XCIsIHsgY2xhc3M6IFwibG9hZGVyX190ZXh0XCIgfSwgdGV4dCksIGlzRGV0ZXJtaW5hdGUgJiYgaChcImRpdlwiLCB7IGNsYXNzOiBcImxvYWRlcl9fcGVyY2VudGFnZVwiIH0sIHZhbHVlKSkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHByb3BlciBzaXplcyBiYXNlZCBvbiB0aGUgc2NhbGUgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHNjYWxlXG4gICAqL1xuICBnZXRTaXplKHNjYWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHM6IDMyLFxuICAgICAgbTogNTYsXG4gICAgICBsOiA4MFxuICAgIH1bc2NhbGVdO1xuICB9XG4gIGdldElubGluZVNpemUoc2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgczogMTIsXG4gICAgICBtOiAxNixcbiAgICAgIGw6IDIwXG4gICAgfVtzY2FsZV07XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gbG9hZGVyQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLWxvYWRlclwiLCB7XG4gICAgXCJpbmxpbmVcIjogWzUxNl0sXG4gICAgXCJsYWJlbFwiOiBbMV0sXG4gICAgXCJzY2FsZVwiOiBbNTEzXSxcbiAgICBcInR5cGVcIjogWzUxM10sXG4gICAgXCJ2YWx1ZVwiOiBbMl0sXG4gICAgXCJ0ZXh0XCI6IFsxXVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50JDcoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImNhbGNpdGUtbG9hZGVyXCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJjYWxjaXRlLWxvYWRlclwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIExvYWRlcik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cbmRlZmluZUN1c3RvbUVsZW1lbnQkNygpO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG5jb25zdCBDU1MkMyA9IHtcbiAgYnV0dG9uOiBcImJ1dHRvblwiLFxuICBidXR0b25UZXh0VmlzaWJsZTogXCJidXR0b24tLXRleHQtdmlzaWJsZVwiLFxuICBidXR0b25Db21wYWN0OiBcImJ1dHRvbi0tY29tcGFjdFwiLFxuICBpbmRpY2F0b3JUZXh0OiBcImluZGljYXRvci10ZXh0XCIsXG4gIGljb25Db250YWluZXI6IFwiaWNvbi1jb250YWluZXJcIixcbiAgc2xvdENvbnRhaW5lcjogXCJzbG90LWNvbnRhaW5lclwiLFxuICBzbG90Q29udGFpbmVySGlkZGVuOiBcInNsb3QtY29udGFpbmVyLS1oaWRkZW5cIixcbiAgdGV4dENvbnRhaW5lcjogXCJ0ZXh0LWNvbnRhaW5lclwiLFxuICB0ZXh0Q29udGFpbmVyVmlzaWJsZTogXCJ0ZXh0LWNvbnRhaW5lci0tdmlzaWJsZVwiXG59O1xuY29uc3QgU0xPVFMkMiA9IHtcbiAgdG9vbHRpcDogXCJ0b29sdGlwXCJcbn07XG5cbmNvbnN0IGFjdGlvbkNzcyA9IFwiQGtleWZyYW1lcyBpbnswJXtvcGFjaXR5OjB9MTAwJXtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgaW4tZG93bnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIC01cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi11cHswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDVweCwgMCl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDAsIDApfX1Aa2V5ZnJhbWVzIGluLXNjYWxlezAle29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUzRCgwLjk1LCAwLjk1LCAxKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGUzRCgxLCAxLCAxKX19OnJvb3R7LS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmc6Y2FsYygxNTBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3Rvcjp2YXIoLS1jYWxjaXRlLWR1cmF0aW9uLWZhY3RvciwgMSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctZmFzdDpjYWxjKDEwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1tZWRpdW06Y2FsYygyMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctc2xvdzpjYWxjKDMwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKX0uY2FsY2l0ZS1hbmltYXRle29wYWNpdHk6MDthbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7YW5pbWF0aW9uLWR1cmF0aW9uOnZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZyl9LmNhbGNpdGUtYW5pbWF0ZV9faW57YW5pbWF0aW9uLW5hbWU6aW59LmNhbGNpdGUtYW5pbWF0ZV9faW4tZG93bnthbmltYXRpb24tbmFtZTppbi1kb3dufS5jYWxjaXRlLWFuaW1hdGVfX2luLXVwe2FuaW1hdGlvbi1uYW1lOmluLXVwfS5jYWxjaXRlLWFuaW1hdGVfX2luLXNjYWxle2FuaW1hdGlvbi1uYW1lOmluLXNjYWxlfUBtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKXs6cm9vdHstLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yOjB9fTpob3N0e2JveC1zaXppbmc6Ym9yZGVyLWJveDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKTtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMik7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0xKX06aG9zdCAqe2JveC1zaXppbmc6Ym9yZGVyLWJveH06cm9vdHstLWNhbGNpdGUtZmxvYXRpbmctdWktdHJhbnNpdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpOy0tY2FsY2l0ZS1mbG9hdGluZy11aS16LWluZGV4OjYwMH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfTpob3N0KFtkaXNhYmxlZF0pe3BvaW50ZXItZXZlbnRzOm5vbmU7Y3Vyc29yOmRlZmF1bHQ7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7b3BhY2l0eTp2YXIoLS1jYWxjaXRlLXVpLW9wYWNpdHktZGlzYWJsZWQpfTpob3N0e2Rpc3BsYXk6ZmxleDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy0tY2FsY2l0ZS1hY3Rpb24taW5kaWNhdG9yLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktYnJhbmQpfTpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRdKSw6aG9zdChbZGlzYWJsZWRdKSBbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRde29wYWNpdHk6MX0uYnV0dG9ue3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjowcHg7ZGlzcGxheTpmbGV4O2lubGluZS1zaXplOmF1dG87Y3Vyc29yOnBvaW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O2JvcmRlci1zdHlsZTpub25lO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpO2ZpbGw6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTMpO2ZvbnQtZmFtaWx5OnZhcigtLWNhbGNpdGUtc2Fucy1mYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMik7bGluZS1oZWlnaHQ6MXJlbTtmb250LXdlaWdodDp2YXIoLS1jYWxjaXRlLWZvbnQtd2VpZ2h0LW1lZGl1bSk7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTMpO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7dGV4dC1hbGlnbjp1bnNldDtmbGV4OjEgMCBhdXRvfS5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMik7ZmlsbDp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMSk7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpfS5idXR0b246Zm9jdXN7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMik7ZmlsbDp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMSk7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO291dGxpbmUtb2Zmc2V0Oi0ycHh9LmJ1dHRvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMyl9LmJ1dHRvbiAuaWNvbi1jb250YWluZXJ7cG9pbnRlci1ldmVudHM6bm9uZTttYXJnaW46MHB4O2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttaW4taW5saW5lLXNpemU6MXJlbTttaW4tYmxvY2stc2l6ZToxcmVtfS5idXR0b24gLnRleHQtY29udGFpbmVye21hcmdpbjowcHg7aW5saW5lLXNpemU6MHB4O292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtsaW5lLWhlaWdodDoxLjVyZW07b3BhY2l0eTowO3RyYW5zaXRpb24tcHJvcGVydHk6b3BhY2l0eTt0cmFuc2l0aW9uLWR1cmF0aW9uOjE1MG1zO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7dHJhbnNpdGlvbi1wcm9wZXJ0eTptYXJnaW47dHJhbnNpdGlvbi1wcm9wZXJ0eTppbmxpbmUtc2l6ZX0uYnV0dG9uIC50ZXh0LWNvbnRhaW5lci0tdmlzaWJsZXtpbmxpbmUtc2l6ZTphdXRvO2ZsZXg6MSAxIGF1dG87b3BhY2l0eToxfTpob3N0KFtzY2FsZT1zXSkgLmJ1dHRvbntwYWRkaW5nLWlubGluZTowLjVyZW07cGFkZGluZy1ibG9jazowLjI1cmVtO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMik7bGluZS1oZWlnaHQ6MXJlbTtmb250LXdlaWdodDp2YXIoLS1jYWxjaXRlLWZvbnQtd2VpZ2h0LW5vcm1hbCl9Omhvc3QoW3NjYWxlPXNdKSAuYnV0dG9uLS10ZXh0LXZpc2libGUgLmljb24tY29udGFpbmVye21hcmdpbi1pbmxpbmUtZW5kOjAuNXJlbX06aG9zdChbc2NhbGU9bV0pIC5idXR0b257cGFkZGluZy1pbmxpbmU6MXJlbTtwYWRkaW5nLWJsb2NrOjAuNzVyZW07Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0xKTtsaW5lLWhlaWdodDoxcmVtO2ZvbnQtd2VpZ2h0OnZhcigtLWNhbGNpdGUtZm9udC13ZWlnaHQtbm9ybWFsKX06aG9zdChbc2NhbGU9bV0pIC5idXR0b24tLXRleHQtdmlzaWJsZSAuaWNvbi1jb250YWluZXJ7bWFyZ2luLWlubGluZS1lbmQ6MC43NXJlbX06aG9zdChbc2NhbGU9bF0pIC5idXR0b257cGFkZGluZzoxLjI1cmVtO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0wKTtsaW5lLWhlaWdodDoxLjI1cmVtO2ZvbnQtd2VpZ2h0OnZhcigtLWNhbGNpdGUtZm9udC13ZWlnaHQtbm9ybWFsKX06aG9zdChbc2NhbGU9bF0pIC5idXR0b24tLXRleHQtdmlzaWJsZSAuaWNvbi1jb250YWluZXJ7bWFyZ2luLWlubGluZS1lbmQ6MXJlbX06aG9zdChbYWxpZ25tZW50PWNlbnRlcl0pIC5idXR0b257anVzdGlmeS1jb250ZW50OmNlbnRlcn06aG9zdChbYWxpZ25tZW50PWVuZF0pIC5idXR0b257anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfTpob3N0KFthbGlnbm1lbnQ9Y2VudGVyXSkgLmJ1dHRvbiAudGV4dC1jb250YWluZXItLXZpc2libGUsOmhvc3QoW2FsaWdubWVudD1lbmRdKSAuYnV0dG9uIC50ZXh0LWNvbnRhaW5lci0tdmlzaWJsZXtmbGV4OjAgMSBhdXRvfTpob3N0KFtzY2FsZT1zXVtjb21wYWN0XSkgLmJ1dHRvbiw6aG9zdChbc2NhbGU9bV1bY29tcGFjdF0pIC5idXR0b24sOmhvc3QoW3NjYWxlPWxdW2NvbXBhY3RdKSAuYnV0dG9ue3BhZGRpbmctaW5saW5lOjBweH0uc2xvdC1jb250YWluZXJ7ZGlzcGxheTpmbGV4fS5zbG90LWNvbnRhaW5lci0taGlkZGVue2Rpc3BsYXk6bm9uZX0uYnV0dG9uLS10ZXh0LXZpc2libGV7aW5saW5lLXNpemU6MTAwJX06aG9zdChbYWN0aXZlXSkgLmJ1dHRvbiw6aG9zdChbYWN0aXZlXSkgLmJ1dHRvbjpob3Zlciw6aG9zdChbYWN0aXZlXSkgLmJ1dHRvbjpmb2N1cyw6aG9zdChbYWN0aXZlXVtsb2FkaW5nXSkgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0zKTtmaWxsOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKTtjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMSl9Omhvc3QoW2FjdGl2ZV0pIC5idXR0b246YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpfTpob3N0KFthcHBlYXJhbmNlPXRyYW5zcGFyZW50XSkgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3RyYW5zaXRpb24tcHJvcGVydHk6Ym94LXNoYWRvdzt0cmFuc2l0aW9uLWR1cmF0aW9uOjE1MG1zO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSl9Omhvc3QoW2FwcGVhcmFuY2U9dHJhbnNwYXJlbnRdKSAuYnV0dG9uOmhvdmVyLDpob3N0KFthcHBlYXJhbmNlPXRyYW5zcGFyZW50XSkgLmJ1dHRvbjpmb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JveC1zaGFkb3c6MCAwIDAgMnB4IHZhcigtLWNhbGNpdGUtdWktYm9yZGVyLTEpIGluc2V0fTpob3N0KFthY3RpdmVdW2FwcGVhcmFuY2U9dHJhbnNwYXJlbnRdKSAuYnV0dG9uLDpob3N0KFthY3RpdmVdW2FwcGVhcmFuY2U9dHJhbnNwYXJlbnRdKSAuYnV0dG9uOmhvdmVyLDpob3N0KFthY3RpdmVdW2FwcGVhcmFuY2U9dHJhbnNwYXJlbnRdKSAuYnV0dG9uOmZvY3Vze2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTMpO2ZpbGw6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKX06aG9zdChbYXBwZWFyYW5jZT10cmFuc3BhcmVudF1bbG9hZGluZ10pIC5idXR0b24sOmhvc3QoW2FwcGVhcmFuY2U9dHJhbnNwYXJlbnRdW2Rpc2FibGVkXSkgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fTpob3N0KFtsb2FkaW5nXSkgLmJ1dHRvbiw6aG9zdChbbG9hZGluZ10pIC5idXR0b246aG92ZXIsOmhvc3QoW2xvYWRpbmddKSAuYnV0dG9uOmZvY3Vze2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpfTpob3N0KFtsb2FkaW5nXSkgLmJ1dHRvbiAudGV4dC1jb250YWluZXIsOmhvc3QoW2xvYWRpbmddKSAuYnV0dG9uOmhvdmVyIC50ZXh0LWNvbnRhaW5lciw6aG9zdChbbG9hZGluZ10pIC5idXR0b246Zm9jdXMgLnRleHQtY29udGFpbmVye29wYWNpdHk6dmFyKC0tY2FsY2l0ZS11aS1vcGFjaXR5LWRpc2FibGVkKX06aG9zdChbbG9hZGluZ10pIGNhbGNpdGUtbG9hZGVyW2lubGluZV17Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTMpO21hcmdpbi1pbmxpbmUtZW5kOjBweH06aG9zdChbZGlzYWJsZWRdKSAuYnV0dG9uLDpob3N0KFtkaXNhYmxlZF0pIC5idXR0b246aG92ZXIsOmhvc3QoW2Rpc2FibGVkXSkgLmJ1dHRvbjpmb2N1c3tjdXJzb3I6ZGVmYXVsdDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKTtvcGFjaXR5OnZhcigtLWNhbGNpdGUtdWktb3BhY2l0eS1kaXNhYmxlZCl9Omhvc3QoW2Rpc2FibGVkXVthY3RpdmVdKSAuYnV0dG9uLDpob3N0KFtkaXNhYmxlZF1bYWN0aXZlXSkgLmJ1dHRvbjpob3Zlciw6aG9zdChbZGlzYWJsZWRdW2FjdGl2ZV0pIC5idXR0b246Zm9jdXN7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMyk7b3BhY2l0eTp2YXIoLS1jYWxjaXRlLXVpLW9wYWNpdHktZGlzYWJsZWQpfTpob3N0KFtpbmRpY2F0b3JdKSAuYnV0dG9uOjphZnRlcntjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO2Jsb2NrLXNpemU6MC41cmVtO2lubGluZS1zaXplOjAuNXJlbTtib3JkZXItcmFkaXVzOjk5OTlweDtib3JkZXItd2lkdGg6MnB4O2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS1hY3Rpb24taW5kaWNhdG9yLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpO2luc2V0LWJsb2NrLWVuZDowLjc1cmVtO2luc2V0LWlubGluZS1lbmQ6MC43NXJlbX06aG9zdChbaW5kaWNhdG9yXSkgLmJ1dHRvbi0tdGV4dC12aXNpYmxlOjphZnRlcntpbnNldC1ibG9jay1lbmQ6YXV0b306aG9zdChbaW5kaWNhdG9yXSkgLmJ1dHRvbi0tdGV4dC12aXNpYmxlIC50ZXh0LWNvbnRhaW5lci0tdmlzaWJsZXttYXJnaW4taW5saW5lLWVuZDoxcmVtfTpob3N0KFtpbmRpY2F0b3JdKSAuYnV0dG9uOmhvdmVyOjphZnRlciw6aG9zdChbaW5kaWNhdG9yXSkgLmJ1dHRvbjpmb2N1czo6YWZ0ZXJ7Ym9yZGVyLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKX06aG9zdChbaW5kaWNhdG9yXVtzY2FsZT1zXSkgLmJ1dHRvbjo6YWZ0ZXJ7aW5zZXQtYmxvY2stZW5kOjAuMjVyZW07aW5zZXQtaW5saW5lLWVuZDowLjI1cmVtfTpob3N0KFtpbmRpY2F0b3JdW3NjYWxlPXNdKSAuYnV0dG9uLS10ZXh0LXZpc2libGU6OmFmdGVye2luc2V0LWJsb2NrLWVuZDphdXRvO2luc2V0LWlubGluZS1lbmQ6MC41cmVtfTpob3N0KFtpbmRpY2F0b3JdW2FjdGl2ZV0pIC5idXR0b246OmFmdGVye2JvcmRlci1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMyl9LmluZGljYXRvci10ZXh0e3Bvc2l0aW9uOmFic29sdXRlO2lubGluZS1zaXplOjFweDtibG9jay1zaXplOjFweDtwYWRkaW5nOjA7bWFyZ2luOi0xcHg7b3ZlcmZsb3c6aGlkZGVuO2NsaXA6cmVjdCgwLCAwLCAwLCAwKTt3aGl0ZS1zcGFjZTpub3dyYXA7Ym9yZGVyLXdpZHRoOjB9XCI7XG5cbmNvbnN0IEFjdGlvbiA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcihcIm11dGF0aW9uXCIsICgpID0+IGZvcmNlVXBkYXRlKHRoaXMpKTtcbiAgICB0aGlzLmd1aWQgPSBgY2FsY2l0ZS1hY3Rpb24tJHtndWlkKCl9YDtcbiAgICB0aGlzLmluZGljYXRvcklkID0gYCR7dGhpcy5ndWlkfS1pbmRpY2F0b3JgO1xuICAgIHRoaXMuYnV0dG9uSWQgPSBgJHt0aGlzLmd1aWR9LWJ1dHRvbmA7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5oYW5kbGVUb29sdGlwU2xvdENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgdG9vbHRpcHMgPSBldmVudC50YXJnZXRcbiAgICAgICAgLmFzc2lnbmVkRWxlbWVudHMoe1xuICAgICAgICBmbGF0dGVuOiB0cnVlXG4gICAgICB9KVxuICAgICAgICAuZmlsdGVyKChlbCkgPT4gZWw/Lm1hdGNoZXMoXCJjYWxjaXRlLXRvb2x0aXBcIikpO1xuICAgICAgY29uc3QgdG9vbHRpcCA9IHRvb2x0aXBzWzBdO1xuICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgdG9vbHRpcC5yZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5idXR0b25FbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5hbGlnbm1lbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hcHBlYXJhbmNlID0gXCJzb2xpZFwiO1xuICAgIHRoaXMuY29tcGFjdCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmljb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pY29uRmxpcFJ0bCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kaWNhdG9yID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNjYWxlID0gXCJtXCI7XG4gICAgdGhpcy50ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGV4dEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVzc2FnZU92ZXJyaWRlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVmZmVjdGl2ZUxvY2FsZSA9IFwiXCI7XG4gICAgdGhpcy5kZWZhdWx0TWVzc2FnZXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb25NZXNzYWdlc0NoYW5nZSgpIHtcbiAgICAvKiB3aXJlZCB1cCBieSB0OW4gdXRpbCAqL1xuICB9XG4gIGVmZmVjdGl2ZUxvY2FsZUNoYW5nZSgpIHtcbiAgICB1cGRhdGVNZXNzYWdlcyh0aGlzLCB0aGlzLmVmZmVjdGl2ZUxvY2FsZSk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25uZWN0TG9jYWxpemVkKHRoaXMpO1xuICAgIGNvbm5lY3RNZXNzYWdlcyh0aGlzKTtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXI/Lm9ic2VydmUodGhpcy5lbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gIH1cbiAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgc2V0VXBMb2FkYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICB7XG4gICAgICBhd2FpdCBzZXRVcE1lc3NhZ2VzKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIHNldENvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBkaXNjb25uZWN0TG9jYWxpemVkKHRoaXMpO1xuICAgIGRpc2Nvbm5lY3RNZXNzYWdlcyh0aGlzKTtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBjb21wb25lbnREaWRSZW5kZXIoKSB7XG4gICAgdXBkYXRlSG9zdEludGVyYWN0aW9uKHRoaXMpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBNZXRob2RzXG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKiBTZXRzIGZvY3VzIG9uIHRoZSBjb21wb25lbnQuICovXG4gIGFzeW5jIHNldEZvY3VzKCkge1xuICAgIGF3YWl0IGNvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAgICB0aGlzLmJ1dHRvbkVsPy5mb2N1cygpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZW5kZXJUZXh0Q29udGFpbmVyKCkge1xuICAgIGNvbnN0IHsgdGV4dCwgdGV4dEVuYWJsZWQgfSA9IHRoaXM7XG4gICAgY29uc3QgdGV4dENvbnRhaW5lckNsYXNzZXMgPSB7XG4gICAgICBbQ1NTJDMudGV4dENvbnRhaW5lcl06IHRydWUsXG4gICAgICBbQ1NTJDMudGV4dENvbnRhaW5lclZpc2libGVdOiB0ZXh0RW5hYmxlZFxuICAgIH07XG4gICAgcmV0dXJuIHRleHQgPyAoaChcImRpdlwiLCB7IGNsYXNzOiB0ZXh0Q29udGFpbmVyQ2xhc3Nlcywga2V5OiBcInRleHQtY29udGFpbmVyXCIgfSwgdGV4dCkpIDogbnVsbDtcbiAgfVxuICByZW5kZXJJbmRpY2F0b3JUZXh0KCkge1xuICAgIGNvbnN0IHsgaW5kaWNhdG9yLCBtZXNzYWdlcywgaW5kaWNhdG9ySWQsIGJ1dHRvbklkIH0gPSB0aGlzO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGJ1dHRvbklkLCBcImFyaWEtbGl2ZVwiOiBcInBvbGl0ZVwiLCBjbGFzczogQ1NTJDMuaW5kaWNhdG9yVGV4dCwgaWQ6IGluZGljYXRvcklkLCByb2xlOiBcInJlZ2lvblwiIH0sIGluZGljYXRvciA/IG1lc3NhZ2VzLmluZGljYXRvciA6IG51bGwpKTtcbiAgfVxuICByZW5kZXJJY29uQ29udGFpbmVyKCkge1xuICAgIGNvbnN0IHsgbG9hZGluZywgaWNvbiwgc2NhbGUsIGVsLCBpY29uRmxpcFJ0bCB9ID0gdGhpcztcbiAgICBjb25zdCBpY29uU2NhbGUgPSBzY2FsZSA9PT0gXCJsXCIgPyBcIm1cIiA6IFwic1wiO1xuICAgIGNvbnN0IGxvYWRlclNjYWxlID0gc2NhbGUgPT09IFwibFwiID8gXCJsXCIgOiBcIm1cIjtcbiAgICBjb25zdCBjYWxjaXRlTG9hZGVyTm9kZSA9IGxvYWRpbmcgPyAoaChcImNhbGNpdGUtbG9hZGVyXCIsIHsgaW5saW5lOiB0cnVlLCBsYWJlbDogdGhpcy5tZXNzYWdlcy5sb2FkaW5nLCBzY2FsZTogbG9hZGVyU2NhbGUgfSkpIDogbnVsbDtcbiAgICBjb25zdCBjYWxjaXRlSWNvbk5vZGUgPSBpY29uID8gKGgoXCJjYWxjaXRlLWljb25cIiwgeyBmbGlwUnRsOiBpY29uRmxpcFJ0bCwgaWNvbjogaWNvbiwgc2NhbGU6IGljb25TY2FsZSB9KSkgOiBudWxsO1xuICAgIGNvbnN0IGljb25Ob2RlID0gY2FsY2l0ZUxvYWRlck5vZGUgfHwgY2FsY2l0ZUljb25Ob2RlO1xuICAgIGNvbnN0IGhhc0ljb25Ub0Rpc3BsYXkgPSBpY29uTm9kZSB8fCBlbC5jaGlsZHJlbj8ubGVuZ3RoO1xuICAgIGNvbnN0IHNsb3RDb250YWluZXJOb2RlID0gKGgoXCJkaXZcIiwgeyBjbGFzczoge1xuICAgICAgICBbQ1NTJDMuc2xvdENvbnRhaW5lcl06IHRydWUsXG4gICAgICAgIFtDU1MkMy5zbG90Q29udGFpbmVySGlkZGVuXTogbG9hZGluZ1xuICAgICAgfSB9LCBoKFwic2xvdFwiLCBudWxsKSkpO1xuICAgIHJldHVybiBoYXNJY29uVG9EaXNwbGF5ID8gKGgoXCJkaXZcIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjbGFzczogQ1NTJDMuaWNvbkNvbnRhaW5lciwga2V5OiBcImljb24tY29udGFpbmVyXCIgfSwgaWNvbk5vZGUsIHNsb3RDb250YWluZXJOb2RlKSkgOiBudWxsO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGFjdGl2ZSwgY29tcGFjdCwgZGlzYWJsZWQsIGxvYWRpbmcsIHRleHRFbmFibGVkLCBsYWJlbCwgdGV4dCwgaW5kaWNhdG9yLCBpbmRpY2F0b3JJZCwgYnV0dG9uSWQsIG1lc3NhZ2VzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFyaWFMYWJlbCA9IGAke2xhYmVsIHx8IHRleHR9JHtpbmRpY2F0b3IgPyBgICgke21lc3NhZ2VzLmluZGljYXRvcn0pYCA6IFwiXCJ9YDtcbiAgICBjb25zdCBidXR0b25DbGFzc2VzID0ge1xuICAgICAgW0NTUyQzLmJ1dHRvbl06IHRydWUsXG4gICAgICBbQ1NTJDMuYnV0dG9uVGV4dFZpc2libGVdOiB0ZXh0RW5hYmxlZCxcbiAgICAgIFtDU1MkMy5idXR0b25Db21wYWN0XTogY29tcGFjdFxuICAgIH07XG4gICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJidXR0b25cIiwgeyBcImFyaWEtYnVzeVwiOiB0b0FyaWFCb29sZWFuKGxvYWRpbmcpLCBcImFyaWEtY29udHJvbHNcIjogaW5kaWNhdG9yID8gaW5kaWNhdG9ySWQgOiBudWxsLCBcImFyaWEtZGlzYWJsZWRcIjogdG9BcmlhQm9vbGVhbihkaXNhYmxlZCksIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsIFwiYXJpYS1wcmVzc2VkXCI6IHRvQXJpYUJvb2xlYW4oYWN0aXZlKSwgY2xhc3M6IGJ1dHRvbkNsYXNzZXMsIGRpc2FibGVkOiBkaXNhYmxlZCwgaWQ6IGJ1dHRvbklkLCByZWY6IChidXR0b25FbCkgPT4gKHRoaXMuYnV0dG9uRWwgPSBidXR0b25FbCkgfSwgdGhpcy5yZW5kZXJJY29uQ29udGFpbmVyKCksIHRoaXMucmVuZGVyVGV4dENvbnRhaW5lcigpKSwgaChcInNsb3RcIiwgeyBuYW1lOiBTTE9UUyQyLnRvb2x0aXAsIG9uU2xvdGNoYW5nZTogdGhpcy5oYW5kbGVUb29sdGlwU2xvdENoYW5nZSB9KSwgdGhpcy5yZW5kZXJJbmRpY2F0b3JUZXh0KCkpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGFzc2V0c0RpcnMoKSB7IHJldHVybiBbXCJhc3NldHNcIl07IH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwibWVzc2FnZU92ZXJyaWRlc1wiOiBbXCJvbk1lc3NhZ2VzQ2hhbmdlXCJdLFxuICAgIFwiZWZmZWN0aXZlTG9jYWxlXCI6IFtcImVmZmVjdGl2ZUxvY2FsZUNoYW5nZVwiXVxuICB9OyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiBhY3Rpb25Dc3M7IH1cbn0sIFsxLCBcImNhbGNpdGUtYWN0aW9uXCIsIHtcbiAgICBcImFjdGl2ZVwiOiBbNTE2XSxcbiAgICBcImFsaWdubWVudFwiOiBbNTEzXSxcbiAgICBcImFwcGVhcmFuY2VcIjogWzUxM10sXG4gICAgXCJjb21wYWN0XCI6IFs1MTZdLFxuICAgIFwiZGlzYWJsZWRcIjogWzUxNl0sXG4gICAgXCJpY29uXCI6IFsxXSxcbiAgICBcImljb25GbGlwUnRsXCI6IFs1MTYsIFwiaWNvbi1mbGlwLXJ0bFwiXSxcbiAgICBcImluZGljYXRvclwiOiBbNTE2XSxcbiAgICBcImxhYmVsXCI6IFsxXSxcbiAgICBcImxvYWRpbmdcIjogWzUxNl0sXG4gICAgXCJzY2FsZVwiOiBbNTEzXSxcbiAgICBcInRleHRcIjogWzFdLFxuICAgIFwidGV4dEVuYWJsZWRcIjogWzUxNiwgXCJ0ZXh0LWVuYWJsZWRcIl0sXG4gICAgXCJtZXNzYWdlc1wiOiBbMTA0MF0sXG4gICAgXCJtZXNzYWdlT3ZlcnJpZGVzXCI6IFsxMDQwXSxcbiAgICBcImVmZmVjdGl2ZUxvY2FsZVwiOiBbMzJdLFxuICAgIFwiZGVmYXVsdE1lc3NhZ2VzXCI6IFszMl0sXG4gICAgXCJzZXRGb2N1c1wiOiBbNjRdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkNigpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiY2FsY2l0ZS1hY3Rpb25cIiwgXCJjYWxjaXRlLWljb25cIiwgXCJjYWxjaXRlLWxvYWRlclwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiY2FsY2l0ZS1hY3Rpb25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBBY3Rpb24pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhbGNpdGUtaWNvblwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCQ4KCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2FsY2l0ZS1sb2FkZXJcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQkNygpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5kZWZpbmVDdXN0b21FbGVtZW50JDYoKTtcblxuY29uc3Qgc2VhcmNoU3RlcENzcyA9IFwiOmhvc3R7ZGlzcGxheTpibG9ja30uYXJjZ2lzU2VhcmNoU3RlcERlc2NyaXB0aW9ue21hcmdpbi1ib3R0b206OHB4fS5zZWxlY3RlZFNlYXJjaFJlc3VsdFJvd1dGe3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6dmlzaWJsZTtmbGV4OjEgMSBhdXRvO2FsaWduLWl0ZW1zOnN0cmV0Y2g7bWF4LXdpZHRoOjEwMCU7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMik7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO3otaW5kZXg6OX0uc2VsZWN0ZWRTZWFyY2hSZXN1bHRXRnt3aWR0aDoxMDAlO3BhZGRpbmc6N3B4IDEwcHg7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjt9LmNsb3NlLWljb257bWFyZ2luLWxlZnQ6YXV0bztjdXJzb3I6cG9pbnRlcn0uZC1mbGV4e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LnNlYXJjaC1yZXN1bHQtc3RyaW5ne3BhZGRpbmctbGVmdDo1cHh9XCI7XG5cbmNvbnN0IFNlYXJjaFN0ZXAgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xyXG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcclxuICAgIHRoaXMuc2VhcmNoUmVzdWx0T2JqQ2hhbmdlZCA9IGNyZWF0ZUV2ZW50JDEodGhpcywgXCJzZWFyY2hSZXN1bHRPYmpDaGFuZ2VkXCIsIDYpO1xyXG4gICAgdGhpcy5kcmF3UG9pbnRDbGlja1NlYXJjaFN0ZXAgPSBjcmVhdGVFdmVudCQxKHRoaXMsIFwiZHJhd1BvaW50Q2xpY2tTZWFyY2hTdGVwXCIsIDYpO1xyXG4gICAgdGhpcy5kcmF3UG9seWdvbkNsaWNrU2VhcmNoU3RlcCA9IGNyZWF0ZUV2ZW50JDEodGhpcywgXCJkcmF3UG9seWdvbkNsaWNrU2VhcmNoU3RlcFwiLCA2KTtcclxuICAgIHRoaXMuX2lkUHJlZml4ID0gJ3NlYXJjaC1zdGVwLSc7XHJcbiAgICB0aGlzLl9pZFByZWZpeFNlYXJjaCA9ICdzZWFyY2gtc3RlcC1jb21wLSc7XHJcbiAgICB0aGlzLl9kYmcgPSBmYWxzZTtcclxuICAgIHRoaXMuYmFzZUNvbmZpZyA9IG5ldyBCYXNlVXRpbCgnc2VhcmNoLXN0ZXAnLCB0aGlzLCB0aGlzLm9uVXBkYXRlVUkpO1xyXG4gIH1cclxuICAvL1xyXG4gIC8vIFVwZGF0ZSBQcm9wcy9TdGF0ZXMgd2hlbiB0aGUgbWFpbiBjb25maWcgY2hhbmdlc1xyXG4gIG9uQ29uZmlnQ2hhbmdlKG5ld0NvbmZpZywgb2xkQ29uZmlnKSB7XHJcbiAgICBpZiAodGhpcy5fZGJnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCclYyBTRUFSQ0gtU1RFUCBjb25maWcgdXBkYXRlJywgJ2NvbG9yOm9yYW5nZTtmb250LXNpemU6MTFwdCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFuZXdDb25maWcgfHwgdHlwZW9mIG5ld0NvbmZpZyAhPSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoQUNMVXRpbHMuaGFzVGV4dChuZXdDb25maWcpKSB7XHJcbiAgICAgIGNvbnN0IG5ld0NmZyA9IEpTT04ucGFyc2UobmV3Q29uZmlnKTtcclxuICAgICAgY29uc3Qgb2xkQ2ZnID0gKG9sZENvbmZpZyAmJiBBQ0xVdGlscy5oYXNUZXh0KG9sZENvbmZpZykpID8gSlNPTi5wYXJzZShvbGRDb25maWcpIDogbnVsbDtcclxuICAgICAgaWYgKHRoaXMuX2RiZykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCclYyAuLi4uU0VBUkNILVNURVAgc2VhcmNoVHlwZScsICdjb2xvcjpvcmFuZ2U7Zm9udC1zaXplOjExcHQnLCBuZXdDZmcuYmFTZWFyY2hUeXBlKTtcclxuICAgICAgfVxyXG4gICAgICAvL1xyXG4gICAgICAvLyBDT0xPUlM6XHJcbiAgICAgIC8vIGRlZmluZSBhIHRlbXAgY29sb3Igb2JqZWN0IHNvIHRoYXQgd2UgdXBkYXRlIHRoZSAnY29sb3JzJyBQcm9wIG9uZSB0aW1lXHJcbiAgICAgIHRoaXMuYmFzZUNvbmZpZy51cGRhdGVDb25maWcobmV3Q2ZnLCBvbGRDZmcpO1xyXG4gICAgfVxyXG4gIH1cclxuICBvblRoZW1lQ2hhbmdlZCgpIHtcclxuICAgIHRoaXMuc3RUaGVtZSA9IHRoaXMudGhlbWU7XHJcbiAgICB0aGlzLmJhc2VDb25maWcuc2V0VGhlbWUodGhpcy50aGVtZSk7XHJcbiAgfVxyXG4gIHNlYXJjaFJlc3VsdHNFdmVudEhhbmRsZXIoZSkge1xyXG4gICAgdGhpcy5vblNpdGVPYmplY3RDaGFuZ2VkKHsgb3JpZ2luOiAnYmFzZWFyY2gnLCBkYXRhOiBlIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBzZXRBY3RpdmVMZXZlbHNcclxuICAgKiAgICBQYXNzZXMgdGhlIGdlb2dyYXBoeSBsZXZlbHMgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZC9kaXNwbGF5ZWRcclxuICAgKiAgICBpbiB0aGUgYXJjZ2lzLWJhLXNlYXJjaCBjb21wb25lbnQuXHJcbiAgICovXHJcbiAgYXN5bmMgc2V0QWN0aXZlTGV2ZWxzKG5hbWVzKSB7XHJcbiAgICBjb25zdCBzZWFyY2hFbGVtID0gQUNMVXRpbHMucXVlcnlFbGVtZW50QnlJZC5jYWxsKHRoaXMsIHRoaXMuX3NlYXJjaElkKTtcclxuICAgIGlmIChzZWFyY2hFbGVtKSB7XHJcbiAgICAgIHNlYXJjaEVsZW0uc2V0QWN0aXZlTGV2ZWxzKG5hbWVzKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2V0TG9jYWxlU3RyaW5ncygpIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwic2V0TG9jYWxlU3RyaW5ncygpIGZvciBzZWFyY2gtc3RlcFwiKVxyXG4gICAgLy8gVE9ETzogaW5pdGlhbGl6ZSBsb2NhbGUgc3RyaW5ncyBmb3IgdGhpcyBjb21wb25lbnRcclxuICB9XHJcbiAgX2xvYWRJbnN0YW5jZXMoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlSWQpXHJcbiAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBFbGVtZW50SWRzLmdlbmVyYXRlSWQodGhpcy5faWRQcmVmaXgpLmlkO1xyXG4gICAgaWYgKCF0aGlzLl9zZWFyY2hJZClcclxuICAgICAgdGhpcy5fc2VhcmNoSWQgPSBFbGVtZW50SWRzLmdlbmVyYXRlSWQodGhpcy5faWRQcmVmaXhTZWFyY2gpLmlkO1xyXG4gIH1cclxuICBvbnNlYXJjaFJlc3VsdENoYW5nZShuZXdTZWxlY3RlZEZlYXR1cmVSZXN1bHQpIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKCdzZWFyY2gtc3RlcCBTZWxlY3RlZCBGZWF0dXJlIFJlc3VsdCBjaGFuZ2VkOicsIG5ld1NlbGVjdGVkRmVhdHVyZVJlc3VsdCk7XHJcbiAgICB0aGlzLm9uU2l0ZU9iamVjdENoYW5nZWQoeyBvcmlnaW46ICdzZWxlY3RlZEZlYXR1cmVSZXN1bHQnLCBkYXRhOiBKU09OLnBhcnNlKG5ld1NlbGVjdGVkRmVhdHVyZVJlc3VsdCkgfSk7XHJcbiAgfVxyXG4gIC8vIEJhc2VVdGlsIGNvbmZpZy1jaGFuZ2VkIHJlbmRlciBjYWxsYmFja1xyXG4gIG9uVXBkYXRlVUkoKSB7XHJcbiAgfVxyXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coJyVjIHNlYXJjaC1zdGVwIHdpbGxMb2FkJywgJ2ZvbnQtc2l6ZTo4cHQ7Y29sb3I6b3JhbmdlOycpXHJcbiAgICBpZiAodGhpcy5jb25maWcpIHtcclxuICAgICAgdGhpcy5vbkNvbmZpZ0NoYW5nZSh0aGlzLmNvbmZpZywgJycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudGhlbWUpIHtcclxuICAgICAgdGhpcy5iYXNlQ29uZmlnLnNldFRoZW1lKHRoaXMudGhlbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMuYmFzZUNvbmZpZy5zZXRUaGVtZSgnbGlnaHQnKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2xvYWRJbnN0YW5jZXMoKTtcclxuICB9XHJcbiAgLy8gU3RlbmNpbCBsaWZlY3ljbGUgLSBjYWxsZWQganVzdCBhZnRlciBjb21wb25lbnQgdXBkYXRlcywgYnV0IG5vdCBjYWxsZWQgZHVyaW5nIGZpcnN0IHJlbmRlcigpXHJcbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgaWYgKHRoaXMuX2RiZykge1xyXG4gICAgICBjb25zb2xlLmxvZygnJWMgU0VBUkNILVNURVAgZGlkVXBkYXRlJywgJ2NvbG9yOnllbGxvdztmb250LXNpemU6MTFwdCcsIHRoaXMuYmFzZUNvbmZpZy5jb25maWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYmFzZUNvbmZpZykge1xyXG4gICAgICB0aGlzLmJhc2VDb25maWcub25Db21wb25lbnRIYXNSZW5kZXJlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBTdGVuY2lsIGxpZmVjeWNsZSAtIGNhbGxlZCBvbmNlIGFmdGVyIGNvbXBvbmVudCBpcyBmdWxseSBsb2FkZWQgYW5kIDFzdCByZW5kZXIgb2NjdXJyZWRcclxuICBjb21wb25lbnREaWRMb2FkKCkge1xyXG4gICAgdGhpcy5fbG9hZEluc3RhbmNlcygpO1xyXG4gICAgaWYgKHRoaXMuX2RiZykge1xyXG4gICAgICBjb25zb2xlLmxvZygnJWMgU0VBUkNILVNURVAgZGlkIGxvYWQnLCAnY29sb3I6b3JhbmdlO2ZvbnQtc2l6ZToxMXB0JywgdGhpcy5iYXNlQ29uZmlnLmhhc1N1YkNvbXBvbmVudHMoKSwgdGhpcy5fc2VhcmNoSWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYmFzZUNvbmZpZykge1xyXG4gICAgICB0aGlzLmJhc2VDb25maWcub25Db21wb25lbnRIYXNSZW5kZXJlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpc0xvY2F0aW9uVHlwZSh2KSB7XHJcbiAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiAodiAmJiAodj8udG9Mb3dlckNhc2UoKSA9PT0gJ2xvY2F0aW9uJyB8fCB2Py50b0xvd2VyQ2FzZSgpID09PSAncG9pbnQnKSk7XHJcbiAgfVxyXG4gIGNsZWFyU2VhcmNoUmVzdWx0KCkge1xyXG4gICAgaWYgKHRoaXMuYmFzZUNvbmZpZykge1xyXG4gICAgICAvLyB1cGRhdGVzIGNvbmZpZyBhbmQgc3ViLWNvbXBvbmVudCBjb25maWdzXHJcbiAgICAgIHRoaXMuYmFzZUNvbmZpZy51cGRhdGVDb25maWcoeyBzZWFyY2hSZXN1bHRPYmo6IHt9IH0sIG51bGwpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZWFyY2hSZXN1bHRPYmogPSB7fTtcclxuICAgIHRoaXMuc2VhcmNoUmVzdWx0U3RyaW5nID0gJyc7XHJcbiAgICB0aGlzLnNlYXJjaFJlc3VsdE9iakNoYW5nZWQuZW1pdCh7fSk7XHJcbiAgfVxyXG4gIG9uU2l0ZU9iamVjdENoYW5nZWQoc2VhcmNoUmVzdWx0KSB7XHJcbiAgICBpZiAoIXNlYXJjaFJlc3VsdClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKHNlYXJjaFJlc3VsdC5vcmlnaW4gPT09ICdiYXNlYXJjaCcgfHwgc2VhcmNoUmVzdWx0Lm9yaWdpbiA9PT0gJ3NlbGVjdGVkRmVhdHVyZVJlc3VsdCcpIHtcclxuICAgICAgLy8gZGF0YSBpcyBjb21pbmcgZnJvbSBhcmNnaXMtYmEtc2VhcmNoIHJlc3VsdFxyXG4gICAgICBjb25zdCBlID0gc2VhcmNoUmVzdWx0LmRhdGE7XHJcbiAgICAgIGxldCByZXN1bHQgPSB7fTtcclxuICAgICAgLy8gSWYgY29taW5nIGZyb20gZXh0ZXJuYWxseSwgYWxsb3cgaXQgdG8gZmxvdyB0aHJvdWdoXHJcbiAgICAgIGlmIChzZWFyY2hSZXN1bHQub3JpZ2luID09PSAnc2VsZWN0ZWRGZWF0dXJlUmVzdWx0Jykge1xyXG4gICAgICAgIHJlc3VsdCA9IHNlYXJjaFJlc3VsdC5kYXRhLmRldGFpbDtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChlLmRldGFpbC50eXBlID09PSAnbG9jYXRpb24nKSB7XHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgdHlwZTogJ2xvY2F0aW9uJyxcclxuICAgICAgICAgIG5hbWU6IGUuZGV0YWlsLm5hbWUsXHJcbiAgICAgICAgICBhZGRyZXNzOiBlLmRldGFpbC5hZGRyZXNzLFxyXG4gICAgICAgICAgbGF0OiBlLmRldGFpbC5sb2NhdGlvbj8ubGF0IHx8IGUuZGV0YWlsLmxhdCxcclxuICAgICAgICAgIGxvbjogZS5kZXRhaWwubG9jYXRpb24/LmxvbiB8fCBlLmRldGFpbC5sb25cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGUuZGV0YWlsLnR5cGUgPT09ICdnZW9ncmFwaHknKSB7XHJcbiAgICAgICAgLy9zZXR1cCBnZW9tZXRyeSBjb21wYXRpYmxlIHdpdGggaW5mb2dyYXBoaWMgY29tcG9uZW50XHJcbiAgICAgICAgY29uc3QgZ2VvbSA9IHtcclxuICAgICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcclxuICAgICAgICAgIHJpbmdzOiBlLmRldGFpbC5nZW9tZXRyeSxcclxuICAgICAgICAgIHNwYXRpYWw6IHsgd2tpZDogMTAyMTAwIH0sXHJcbiAgICAgICAgICBsYXRpdHVkZTogMzQuMDU1NTYxLFxyXG4gICAgICAgICAgbG9uZ2l0dWRlOiAtMTE3LjE4MjYwMlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgdHlwZTogJ2dlb2dyYXBoeScsXHJcbiAgICAgICAgICBuYW1lOiBlLmRldGFpbC50aXRsZSxcclxuICAgICAgICAgIGFyZWFJZDogZS5kZXRhaWwuYXJlYUlkLFxyXG4gICAgICAgICAgZ2VvZ3JhcGh5OiB7XHJcbiAgICAgICAgICAgIHNvdXJjZUNvdW50cnk6IGUuZGV0YWlsLmF0dHJpYnV0ZXMuQ291bnRyeUFiYnIsXHJcbiAgICAgICAgICAgIGxldmVsSWQ6IGUuZGV0YWlsLmF0dHJpYnV0ZXMuRGF0YUxheWVySUQsXHJcbiAgICAgICAgICAgIGhpZXJhcmNoeTogZS5kZXRhaWwuYXR0cmlidXRlcy5IaWVyYXJjaHksXHJcbiAgICAgICAgICAgIGlkOiBlLmRldGFpbC5hcmVhSWQsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGUuZGV0YWlsLmF0dHJpYnV0ZXNcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBnZW9tZXRyeTogZ2VvbVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZWFyY2hSZXN1bHRTdHJpbmcgPSAnJztcclxuICAgICAgY29uc3Qgc3RyTmFtZSA9IChyZXN1bHQubmFtZSAmJiBBQ0xVdGlscy5oYXNUZXh0KHJlc3VsdC5uYW1lKSkgPyByZXN1bHQubmFtZSA6IHJlc3VsdC5kaXNwbGF5TmFtZSB8fCBudWxsO1xyXG4gICAgICBjb25zdCBzdHJBZGRyZXNzID0gKHJlc3VsdC5hZGRyZXNzICYmIEFDTFV0aWxzLmhhc1RleHQocmVzdWx0LmFkZHJlc3MpKSA/IHJlc3VsdC5hZGRyZXNzIDogbnVsbDtcclxuICAgICAgaWYgKHRoaXMuaXNMb2NhdGlvblR5cGUocmVzdWx0LnR5cGUpKSB7XHJcbiAgICAgICAgaWYgKHN0ckFkZHJlc3MpIHtcclxuICAgICAgICAgIHRoaXMuc2VhcmNoUmVzdWx0U3RyaW5nID0gc3RyQWRkcmVzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RyTmFtZSkge1xyXG4gICAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRTdHJpbmcgPSBzdHJOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdFN0cmluZyA9IHN0ck5hbWUgfHwgJyc7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZWFyY2hSZXN1bHRPYmogPSByZXN1bHQ7XHJcbiAgICAgIC8vIE9ubHkgZW1pdCBpZiBjb21pbmcgZnJvbSBzZWFyY2ggcmVzdWx0cyAoaWYgY29taW5nIGZyb20gdG9wIChpbmZvZ3JhcGhpYy13b3JrZmxvdyBzZWxlY3Rpb24pIGRvd24sIHdlIGRvbid0IHdhbnQgdG8gZW1pdClcclxuICAgICAgaWYgKHNlYXJjaFJlc3VsdC5vcmlnaW4gIT09ICdzZWxlY3RlZEZlYXR1cmVSZXN1bHQnKSB7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRPYmpDaGFuZ2VkLmVtaXQocmVzdWx0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB1c2VybmFtZSA9IHRoaXMudXNlcm5hbWU7XHJcbiAgICBjb25zdCBlbnYgPSB0aGlzLmVudjtcclxuICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbjtcclxuICAgIGNvbnN0IGdlb2VucmljaG1lbnRVcmwgPSB0aGlzLmdlb2VucmljaG1lbnRVcmw7XHJcbiAgICBjb25zdCBzZWxlY3RlZENvdW50cnkgPSB0aGlzLmJhc2VDb25maWcuY29uZmlnLnNvdXJjZUNvdW50cnkgfHwgdGhpcy5iYXNlQ29uZmlnLl9sb2NhbGVTZXR0aW5ncy5jb3VudHJ5O1xyXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmxhbmdDb2RlO1xyXG4gICAgY29uc3Qgc2VhcmNoU3R5bGUgPSB7ICd3aWR0aCc6ICdjYWxjKDEwMCUgLSAzcHgpJyB9O1xyXG4gICAgcmV0dXJuIChoJDEoXCJkaXZcIiwgbnVsbCwgQUNMVXRpbHMuaXNFbXB0eU9iamVjdCh0aGlzLnNlYXJjaFJlc3VsdE9iaikgPyAoaCQxKFwiZGl2XCIsIG51bGwsIGgkMShcImRpdlwiLCB7IGNsYXNzOiAnZmxleC1ncmlkJyB9LCB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93RGlzcGxheUludHJvVGV4dCAmJlxyXG4gICAgICBoJDEoXCJkaXZcIiwgeyBjbGFzczogJ2NvbCBhcmNnaXNTZWFyY2hTdGVwRGVzY3JpcHRpb24nIH0sIHRoaXMuYmFzZUNvbmZpZy5jb25maWcud29ya2Zsb3dJbnRyb1RleHQpKSwgaCQxKFwiYXJjZ2lzLWJhLXNlYXJjaFwiLCB7IGlkOiB0aGlzLl9zZWFyY2hJZCwgY29uZmlnOiB0aGlzLmJhc2VDb25maWcuZ2V0Q29uZmlnU3RyaW5nKCksXHJcbiAgICAgIC8vc3R5bGU9e3N0ZXBCYVNlYXJjaENvbXBvbmVudH1cclxuICAgICAgc3R5bGU6IHNlYXJjaFN0eWxlLCB1c2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgIC8vbm9nZW9ncmFwaHk9e25vV29ya2Zsb3dHZW9ncmFwaHlTZWFyY2h9XHJcbiAgICAgIGVudjogZW52LCB0b2tlbjogdG9rZW4sIGdlb2VucmljaG1lbnRVcmw6IGdlb2VucmljaG1lbnRVcmwsIGdlb2NvZGVVcmw6IHRoaXMuZ2VvY29kZVVybCxcclxuICAgICAgLy9jb2xvcnM9e3RoaXMuc3RyaW5naWZ5VGhlbWUoKX1cclxuICAgICAgc291cmNlQ291bnRyeTogc2VsZWN0ZWRDb3VudHJ5LCBsYW5nQ29kZTogbGFuZ3VhZ2UsIHN1Z2xpdGU6ICd0cnVlJyB9KSwgaCQxKFwiZGl2XCIsIG51bGwsIGgkMShcInNsb3RcIiwgeyBuYW1lOiBcImRyYXctY29tcG9uZW50c1wiIH0pKSkpIDogKGgkMShcImRpdlwiLCB7IGNsYXNzOiAnZC1mbGV4IHNlbGVjdGVkU2VhcmNoUmVzdWx0Um93V0YnIH0sIGgkMShcImRpdlwiLCB7IGNsYXNzOiAnZC1mbGV4IHNlbGVjdGVkU2VhcmNoUmVzdWx0V0YnIH0sIGgkMShcImRpdlwiLCB7IGNsYXNzOiAnZC1mbGV4IHNlYXJjaC1yZXN1bHQtaWNvbicgfSwgaCQxKFwiY2FsY2l0ZS1pY29uXCIsIHsgc2NhbGU6ICdtJywgaWNvbjogdGhpcy5pc0xvY2F0aW9uVHlwZSh0aGlzLnNlYXJjaFJlc3VsdE9iai50eXBlKSA/ICdwaW4nIDogJ3BvbHlnb24nIH0pKSwgaCQxKFwiZGl2XCIsIHsgY2xhc3M6ICdkLWZsZXggc2VhcmNoLXJlc3VsdC1zdHJpbmcnIH0sIHRoaXMuc2VhcmNoUmVzdWx0U3RyaW5nKSwgaCQxKFwiZGl2XCIsIHsgY2xhc3M6ICdkLWZsZXggY2xvc2UtaWNvbicsIG9uQ2xpY2s6ICgpID0+IHsgdGhpcy5jbGVhclNlYXJjaFJlc3VsdCgpOyB9IH0sIGgkMShcImNhbGNpdGUtaWNvblwiLCB7IHNpemU6ICdtJywgaWNvbjogJ3gnLCBpZDogXCJjbGVhclNlYXJjaC1idXR0b25cIiB9KSksIGgkMShcImNhbGNpdGUtdG9vbHRpcFwiLCB7IGxhYmVsOiBCYVJlcG9ydHNMYW5ndWFnZS5pMThuKCdjbGVhci1zZWFyY2gnKSwgXCJyZWZlcmVuY2UtZWxlbWVudFwiOiBcImNsZWFyU2VhcmNoLWJ1dHRvblwiIH0sIGgkMShcInNwYW5cIiwgbnVsbCwgQmFSZXBvcnRzTGFuZ3VhZ2UuaTE4bignY2xlYXItc2VhcmNoJykpKSkpKSkpO1xyXG4gIH1cclxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50JDEodGhpcyk7IH1cclxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xyXG4gICAgXCJjb25maWdcIjogW1wib25Db25maWdDaGFuZ2VcIl0sXHJcbiAgICBcInRoZW1lXCI6IFtcIm9uVGhlbWVDaGFuZ2VkXCJdLFxyXG4gICAgXCJzZWxlY3RlZEZlYXR1cmVSZXN1bHRcIjogW1wib25zZWFyY2hSZXN1bHRDaGFuZ2VcIl1cclxuICB9OyB9XHJcbn07XHJcblNlYXJjaFN0ZXAuc3R5bGUgPSBzZWFyY2hTdGVwQ3NzO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG5jb25zdCBTTE9UUyQxID0ge1xuICB0aXRsZUdyb3VwOiBcInRpdGxlLWdyb3VwXCJcbn07XG5cbmNvbnN0IHRhYnNDc3MgPSBcIkBrZXlmcmFtZXMgaW57MCV7b3BhY2l0eTowfTEwMCV7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGluLWRvd257MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAtNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tdXB7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCA1cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi1zY2FsZXswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM0QoMC45NSwgMC45NSwgMSl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM0QoMSwgMSwgMSl9fTpyb290ey0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nOmNhbGMoMTUwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6dmFyKC0tY2FsY2l0ZS1kdXJhdGlvbi1mYWN0b3IsIDEpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3Q6Y2FsYygxMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtOmNhbGMoMjAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3c6Y2FsYygzMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSl9LmNhbGNpdGUtYW5pbWF0ZXtvcGFjaXR5OjA7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO2FuaW1hdGlvbi1kdXJhdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpfS5jYWxjaXRlLWFuaW1hdGVfX2lue2FuaW1hdGlvbi1uYW1lOmlufS5jYWxjaXRlLWFuaW1hdGVfX2luLWRvd257YW5pbWF0aW9uLW5hbWU6aW4tZG93bn0uY2FsY2l0ZS1hbmltYXRlX19pbi11cHthbmltYXRpb24tbmFtZTppbi11cH0uY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZXthbmltYXRpb24tbmFtZTppbi1zY2FsZX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7OnJvb3R7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcjowfX06cm9vdHstLWNhbGNpdGUtZmxvYXRpbmctdWktdHJhbnNpdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpOy0tY2FsY2l0ZS1mbG9hdGluZy11aS16LWluZGV4OjYwMH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfTpob3N0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Omhvc3QoW2JvcmRlcmVkXSl7Ym94LXNoYWRvdzppbnNldCAwIDFweCAwIHZhcigtLWNhbGNpdGUtdWktYm9yZGVyLTEpO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpfTpob3N0KFtib3JkZXJlZF06bm90KFtwb3NpdGlvbj1ib3R0b21dKSkgOjpzbG90dGVkKGNhbGNpdGUtdGFiLW5hdil7bWFyZ2luLWJsb2NrLWVuZDotMXB4fTpob3N0KFtib3JkZXJlZF1bcG9zaXRpb249Ym90dG9tXSl7Ym94LXNoYWRvdzppbnNldCAwIDFweCAwIHZhcigtLWNhbGNpdGUtdWktYm9yZGVyLTEpLCBpbnNldCAwIC0xcHggMCB2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0xKX06aG9zdChbYm9yZGVyZWRdKSBzZWN0aW9ue2JvcmRlci13aWR0aDoxcHg7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0xKX06aG9zdChbYm9yZGVyZWRdW3NjYWxlPXNdKSBzZWN0aW9ue3BhZGRpbmc6MC43NXJlbX06aG9zdChbYm9yZGVyZWRdW3NjYWxlPW1dKSBzZWN0aW9ue3BhZGRpbmc6MC41cmVtfTpob3N0KFtib3JkZXJlZF1bc2NhbGU9bF0pIHNlY3Rpb257cGFkZGluZzoxcmVtfTpob3N0KFtwb3NpdGlvbj1ib3R0b21dKXtmbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZX1zZWN0aW9ue2Rpc3BsYXk6ZmxleDtmbGV4LWdyb3c6MTtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyLWJsb2NrLXN0YXJ0LXdpZHRoOjFweDtib3JkZXItYmxvY2stc3RhcnQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMSk7Ym9yZGVyLWJsb2NrLXN0YXJ0LXN0eWxlOnNvbGlkfTpob3N0KFtwb3NpdGlvbj1ib3R0b21dKSBzZWN0aW9ue2ZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlO2JvcmRlci1ibG9jay1zdGFydC13aWR0aDowcHg7Ym9yZGVyLWJsb2NrLWVuZC13aWR0aDoxcHg7Ym9yZGVyLWJsb2NrLWVuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0xKX06aG9zdChbcG9zaXRpb249Ym90dG9tXTpub3QoW2JvcmRlcmVkXSkpIHNlY3Rpb257Ym9yZGVyLWJsb2NrLWVuZC1zdHlsZTpzb2xpZH1AbWVkaWEgKGZvcmNlZC1jb2xvcnM6IGFjdGl2ZSl7Omhvc3QoW2JvcmRlcmVkXSkgc2VjdGlvbntib3JkZXItYmxvY2stc3RhcnQtd2lkdGg6MHB4O2JvcmRlci1ibG9jay1lbmQtd2lkdGg6MXB4fTpob3N0KFtwb3NpdGlvbj1ib3R0b21dW2JvcmRlcmVkXSkgc2VjdGlvbntib3JkZXItYmxvY2stc3RhcnQtd2lkdGg6MXB4O2JvcmRlci1ibG9jay1lbmQtd2lkdGg6MHB4fX1cIjtcblxuY29uc3QgVGFicyA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmxheW91dCA9IFwiaW5saW5lXCI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwidG9wXCI7XG4gICAgdGhpcy5zY2FsZSA9IFwibVwiO1xuICAgIHRoaXMuYm9yZGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRpdGxlcyA9IFtdO1xuICAgIHRoaXMudGFicyA9IFtdO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKGgoRnJhZ21lbnQsIG51bGwsIGgoXCJzbG90XCIsIHsgbmFtZTogU0xPVFMkMS50aXRsZUdyb3VwIH0pLCBoKFwic2VjdGlvblwiLCBudWxsLCBoKFwic2xvdFwiLCBudWxsKSkpKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBFdmVudCBMaXN0ZW5lcnNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY2FsY2l0ZUludGVybmFsVGFiVGl0bGVSZWdpc3RlcihldmVudCkge1xuICAgIHRoaXMudGl0bGVzID0gWy4uLnRoaXMudGl0bGVzLCBldmVudC50YXJnZXRdO1xuICAgIHRoaXMucmVnaXN0cnlIYW5kbGVyKCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNhbGNpdGVUYWJUaXRsZVVucmVnaXN0ZXIoZXZlbnQpIHtcbiAgICB0aGlzLnRpdGxlcyA9IHRoaXMudGl0bGVzLmZpbHRlcigoZWwpID0+IGVsICE9PSBldmVudC5kZXRhaWwpO1xuICAgIHRoaXMucmVnaXN0cnlIYW5kbGVyKCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNhbGNpdGVJbnRlcm5hbFRhYlJlZ2lzdGVyKGV2ZW50KSB7XG4gICAgdGhpcy50YWJzID0gWy4uLnRoaXMudGFicywgZXZlbnQudGFyZ2V0XTtcbiAgICB0aGlzLnJlZ2lzdHJ5SGFuZGxlcigpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjYWxjaXRlVGFiVW5yZWdpc3RlcihldmVudCkge1xuICAgIHRoaXMudGFicyA9IHRoaXMudGFicy5maWx0ZXIoKGVsKSA9PiBlbCAhPT0gZXZlbnQuZGV0YWlsKTtcbiAgICB0aGlzLnJlZ2lzdHJ5SGFuZGxlcigpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKlxuICAgKiBNYXRjaGVzIHVwIGVsZW1lbnRzIGZyb20gdGhlIGludGVybmFsIGB0YWJzYCBhbmQgYHRpdGxlc2AgdG8gYXV0b21hdGljYWxseVxuICAgKiB1cGRhdGUgdGhlIEFSSUEgYXR0cmlidXRlcyBhbmQgbGluayBgPGNhbGNpdGUtdGFiPmAgYW5kXG4gICAqIGA8Y2FsY2l0ZS10YWItdGl0bGU+YCBjb21wb25lbnRzLlxuICAgKi9cbiAgYXN5bmMgcmVnaXN0cnlIYW5kbGVyKCkge1xuICAgIGxldCB0YWJJZHM7XG4gICAgbGV0IHRpdGxlSWRzO1xuICAgIC8vIGRldGVybWluZSBpZiB3ZSBhcmUgdXNpbmcgYHRhYmAgYmFzZWQgb3IgYGluZGV4YCBiYXNlZCB0YWIgaWRlbnRpZmllcnMuXG4gICAgaWYgKHRoaXMudGFicy5zb21lKChlbCkgPT4gZWwudGFiKSB8fCB0aGlzLnRpdGxlcy5zb21lKChlbCkgPT4gZWwudGFiKSkge1xuICAgICAgLy8gaWYgd2UgYXJlIHVzaW5nIGB0YWJgIGJhc2VkIGlkZW50aWZpZXJzIHNvcnQgYnkgYHRhYmAgdG8gYWNjb3VudCBmb3JcbiAgICAgIC8vIHBvc3NpYmxlIG91dCBvZiBvcmRlciB0YWJzIGFuZCBnZXQgdGhlIGlkIG9mIGVhY2ggdGFiXG4gICAgICB0YWJJZHMgPSB0aGlzLnRhYnMuc29ydCgoYSwgYikgPT4gYS50YWIubG9jYWxlQ29tcGFyZShiLnRhYikpLm1hcCgoZWwpID0+IGVsLmlkKTtcbiAgICAgIHRpdGxlSWRzID0gdGhpcy50aXRsZXMuc29ydCgoYSwgYikgPT4gYS50YWIubG9jYWxlQ29tcGFyZShiLnRhYikpLm1hcCgoZWwpID0+IGVsLmlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBpZiB3ZSBhcmUgdXNpbmcgaW5kZXggYmFzZWQgdGFicyB0aGVuIHRoZSBgPGNhbGNpdGUtdGFiPmAgYW5kXG4gICAgICAvLyBgPGNhbGNpdGUtdGFiLXRpdGxlPmAgbWlnaHQgaGF2ZSBiZWVuIHJlbmRlcmVkIG91dCBvZiBvcmRlciBzbyB0aGVcbiAgICAgIC8vIG9yZGVyIG9mIGB0aGlzLnRhYnNgIGFuZCBgdGhpcy50aXRsZXNgIG1pZ2h0IG5vdCByZWZsZWN0IHRoZSBET00gc3RhdGUsXG4gICAgICAvLyBhbmQgbWlnaHQgbm90IG1hdGNoIGVhY2ggb3RoZXIgc28gd2UgbmVlZCB0byBnZXQgdGhlIGluZGV4IG9mIGFsbCB0aGVcbiAgICAgIC8vIHRhYnMgYW5kIHRpdGxlcyBpbiB0aGUgRE9NIG9yZGVyIHRvIG1hdGNoIHRoZW0gdXAgYXMgYSBzb3VyY2Ugb2YgdHJ1dGhcbiAgICAgIGNvbnN0IHRhYkRvbUluZGV4ZXMgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLnRhYnMubWFwKChlbCkgPT4gZWwuZ2V0VGFiSW5kZXgoKSkpO1xuICAgICAgY29uc3QgdGl0bGVEb21JbmRleGVzID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy50aXRsZXMubWFwKChlbCkgPT4gZWwuZ2V0VGFiSW5kZXgoKSkpO1xuICAgICAgLy8gb25jZSB3ZSBoYXZlIHRoZSBET00gb3JkZXIgYXMgYSBzb3VyY2Ugb2YgdHJ1dGggd2UgY2FuIGJ1aWxkIHRoZVxuICAgICAgLy8gbWF0Y2hpbmcgdGFiSWRzIGFuZCB0aXRsZUlkcyBhcnJheXNcbiAgICAgIHRhYklkcyA9IHRhYkRvbUluZGV4ZXMucmVkdWNlKChpZHMsIGluZGV4SW5ET00sIHJlZ2lzdHJ5SW5kZXgpID0+IHtcbiAgICAgICAgaWRzW2luZGV4SW5ET01dID0gdGhpcy50YWJzW3JlZ2lzdHJ5SW5kZXhdLmlkO1xuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfSwgW10pO1xuICAgICAgdGl0bGVJZHMgPSB0aXRsZURvbUluZGV4ZXMucmVkdWNlKChpZHMsIGluZGV4SW5ET00sIHJlZ2lzdHJ5SW5kZXgpID0+IHtcbiAgICAgICAgaWRzW2luZGV4SW5ET01dID0gdGhpcy50aXRsZXNbcmVnaXN0cnlJbmRleF0uaWQ7XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICAgIC8vIHBhc3MgYWxsIG91ciBuZXcgYXJpYSBpbmZvcm1hdGlvbiB0byBlYWNoIGA8Y2FsY2l0ZS10YWI+YCBhbmRcbiAgICAvLyBgPGNhbGNpdGUtdGFiLXRpdGxlPmAgd2hpY2ggd2lsbCBjaGVjayBpZiB0aGV5IGNhbiB1cGRhdGUgdGhlaXIgaW50ZXJuYWxcbiAgICAvLyBgY29udHJvbGxlZGAgb3IgYGxhYmVsZWRCeWAgc3RhdGVzIGFuZCByZS1yZW5kZXIgaWYgbmVjZXNzYXJ5XG4gICAgdGhpcy50YWJzLmZvckVhY2goKGVsKSA9PiBlbC51cGRhdGVBcmlhSW5mbyh0YWJJZHMsIHRpdGxlSWRzKSk7XG4gICAgdGhpcy50aXRsZXMuZm9yRWFjaCgoZWwpID0+IGVsLnVwZGF0ZUFyaWFJbmZvKHRhYklkcywgdGl0bGVJZHMpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiB0YWJzQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLXRhYnNcIiwge1xuICAgIFwibGF5b3V0XCI6IFs1MTNdLFxuICAgIFwicG9zaXRpb25cIjogWzUxM10sXG4gICAgXCJzY2FsZVwiOiBbNTEzXSxcbiAgICBcImJvcmRlcmVkXCI6IFsxNTQwXSxcbiAgICBcInRpdGxlc1wiOiBbMzJdLFxuICAgIFwidGFic1wiOiBbMzJdXG4gIH0sIFtbMCwgXCJjYWxjaXRlSW50ZXJuYWxUYWJUaXRsZVJlZ2lzdGVyXCIsIFwiY2FsY2l0ZUludGVybmFsVGFiVGl0bGVSZWdpc3RlclwiXSwgWzE2LCBcImNhbGNpdGVUYWJUaXRsZVVucmVnaXN0ZXJcIiwgXCJjYWxjaXRlVGFiVGl0bGVVbnJlZ2lzdGVyXCJdLCBbMCwgXCJjYWxjaXRlSW50ZXJuYWxUYWJSZWdpc3RlclwiLCBcImNhbGNpdGVJbnRlcm5hbFRhYlJlZ2lzdGVyXCJdLCBbMTYsIFwiY2FsY2l0ZVRhYlVucmVnaXN0ZXJcIiwgXCJjYWxjaXRlVGFiVW5yZWdpc3RlclwiXV1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkNSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiY2FsY2l0ZS10YWJzXCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJjYWxjaXRlLXRhYnNcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBUYWJzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuZGVmaW5lQ3VzdG9tRWxlbWVudCQ1KCk7XG5cbi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5cbmNvbnN0IHRhYk5hdkNzcyA9IFwiQGtleWZyYW1lcyBpbnswJXtvcGFjaXR5OjB9MTAwJXtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgaW4tZG93bnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIC01cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi11cHswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDVweCwgMCl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDAsIDApfX1Aa2V5ZnJhbWVzIGluLXNjYWxlezAle29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUzRCgwLjk1LCAwLjk1LCAxKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGUzRCgxLCAxLCAxKX19OnJvb3R7LS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmc6Y2FsYygxNTBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3Rvcjp2YXIoLS1jYWxjaXRlLWR1cmF0aW9uLWZhY3RvciwgMSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctZmFzdDpjYWxjKDEwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1tZWRpdW06Y2FsYygyMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctc2xvdzpjYWxjKDMwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKX0uY2FsY2l0ZS1hbmltYXRle29wYWNpdHk6MDthbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7YW5pbWF0aW9uLWR1cmF0aW9uOnZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZyl9LmNhbGNpdGUtYW5pbWF0ZV9faW57YW5pbWF0aW9uLW5hbWU6aW59LmNhbGNpdGUtYW5pbWF0ZV9faW4tZG93bnthbmltYXRpb24tbmFtZTppbi1kb3dufS5jYWxjaXRlLWFuaW1hdGVfX2luLXVwe2FuaW1hdGlvbi1uYW1lOmluLXVwfS5jYWxjaXRlLWFuaW1hdGVfX2luLXNjYWxle2FuaW1hdGlvbi1uYW1lOmluLXNjYWxlfUBtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKXs6cm9vdHstLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yOjB9fTpyb290ey0tY2FsY2l0ZS1mbG9hdGluZy11aS10cmFuc2l0aW9uOnZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZyk7LS1jYWxjaXRlLWZsb2F0aW5nLXVpLXotaW5kZXg6NjAwfTpob3N0KFtoaWRkZW5dKXtkaXNwbGF5Om5vbmV9Omhvc3R7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpmbGV4fTpob3N0KFtzY2FsZT1zXSl7bWluLWJsb2NrLXNpemU6MS41cmVtfTpob3N0KFtzY2FsZT1tXSl7bWluLWJsb2NrLXNpemU6MnJlbX06aG9zdChbc2NhbGU9bF0pe21pbi1ibG9jay1zaXplOjIuNzVyZW19LnRhYi1uYXZ7ZGlzcGxheTpmbGV4O2lubGluZS1zaXplOjEwMCU7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7b3ZlcmZsb3c6YXV0b30udGFiLW5hdi1hY3RpdmUtaW5kaWNhdG9yLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTtpbnNldC1pbmxpbmU6MHB4O2luc2V0LWJsb2NrLWVuZDowcHg7YmxvY2stc2l6ZTowLjEyNXJlbTtpbmxpbmUtc2l6ZToxMDAlO292ZXJmbG93OmhpZGRlbn0udGFiLW5hdi1hY3RpdmUtaW5kaWNhdG9ye3Bvc2l0aW9uOmFic29sdXRlO2luc2V0LWJsb2NrLWVuZDowcHg7ZGlzcGxheTpibG9jaztibG9jay1zaXplOjAuMTI1cmVtO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7dHJhbnNpdGlvbi1wcm9wZXJ0eTphbGw7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTt0cmFuc2l0aW9uLWR1cmF0aW9uOjE1MG1zO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpfTpob3N0KFtwb3NpdGlvbj1ib3R0b21dKSAudGFiLW5hdi1hY3RpdmUtaW5kaWNhdG9ye2luc2V0LWJsb2NrLWVuZDp1bnNldDtpbnNldC1ibG9jay1zdGFydDowcHh9Omhvc3QoW3Bvc2l0aW9uPWJvdHRvbV0pIC50YWItbmF2LWFjdGl2ZS1pbmRpY2F0b3ItY29udGFpbmVye2luc2V0LWJsb2NrLWVuZDp1bnNldDtpbnNldC1ibG9jay1zdGFydDowcHh9Omhvc3QoW2JvcmRlcmVkXSkgLnRhYi1uYXYtYWN0aXZlLWluZGljYXRvci1jb250YWluZXJ7aW5zZXQtYmxvY2stZW5kOnVuc2V0fTpob3N0KFtib3JkZXJlZF1bcG9zaXRpb249Ym90dG9tXSkgLnRhYi1uYXYtYWN0aXZlLWluZGljYXRvci1jb250YWluZXJ7aW5zZXQtYmxvY2stZW5kOjA7aW5zZXQtYmxvY2stc3RhcnQ6dW5zZXR9QG1lZGlhIChmb3JjZWQtY29sb3JzOiBhY3RpdmUpey50YWItbmF2LWFjdGl2ZS1pbmRpY2F0b3J7YmFja2dyb3VuZC1jb2xvcjpoaWdobGlnaHR9fVwiO1xuXG5jb25zdCBUYWJOYXYgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZWdpc3Rlckhvc3QoKTtcbiAgICB0aGlzLl9fYXR0YWNoU2hhZG93KCk7XG4gICAgdGhpcy5jYWxjaXRlVGFiQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlVGFiQ2hhbmdlXCIsIDYpO1xuICAgIHRoaXMuY2FsY2l0ZUludGVybmFsVGFiQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlSW50ZXJuYWxUYWJDaGFuZ2VcIiwgNik7XG4gICAgdGhpcy5hbmltYXRpb25BY3RpdmVEdXJhdGlvbiA9IDAuMztcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIoXCJyZXNpemVcIiwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZUluZGljYXRvckVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBhY3RpdmUgaW5kaWNhdG9yIHRyYW5zaXRpb24gZHVyYXRpb24gZHVyaW5nIHJlc2l6ZSB0byBwcmV2ZW50IHdvYmJsZVxuICAgICAgdGhpcy5hY3RpdmVJbmRpY2F0b3JFbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVdpZHRoKCk7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldFBvc2l0aW9uKCk7XG4gICAgfSk7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMuaGFuZGxlVGFiRm9jdXMgPSAoZXZlbnQsIGVsLCBkZXN0aW5hdGlvbikgPT4ge1xuICAgICAgZm9jdXNFbGVtZW50SW5Hcm91cCh0aGlzLmVuYWJsZWRUYWJUaXRsZXMsIGVsLCBkZXN0aW5hdGlvbik7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNvbnRhaW5lclNjcm9sbCA9ICgpID0+IHtcbiAgICAgIC8vIHJlbW92ZSBhY3RpdmUgaW5kaWNhdG9yIHRyYW5zaXRpb24gZHVyYXRpb24gd2hpbGUgY29udGFpbmVyIGlzIHNjcm9sbGluZyB0byBwcmV2ZW50IHdvYmJsZVxuICAgICAgdGhpcy5hY3RpdmVJbmRpY2F0b3JFbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLnN0b3JhZ2VJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN5bmNJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkVGl0bGUgPSBudWxsO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgICB0aGlzLmxheW91dCA9IFwiaW5saW5lXCI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy5ib3JkZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kaWNhdG9yT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5kaWNhdG9yV2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWxlY3RlZFRhYklkID0gdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jIHNlbGVjdGVkVGFiSWRDaGFuZ2VkKCkge1xuICAgIGlmIChsb2NhbFN0b3JhZ2UgJiZcbiAgICAgIHRoaXMuc3RvcmFnZUlkICYmXG4gICAgICB0aGlzLnNlbGVjdGVkVGFiSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgdGhpcy5zZWxlY3RlZFRhYklkICE9PSBudWxsKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgY2FsY2l0ZS10YWItbmF2LSR7dGhpcy5zdG9yYWdlSWR9YCwgSlNPTi5zdHJpbmdpZnkodGhpcy5zZWxlY3RlZFRhYklkKSk7XG4gICAgfVxuICAgIHRoaXMuY2FsY2l0ZUludGVybmFsVGFiQ2hhbmdlLmVtaXQoe1xuICAgICAgdGFiOiB0aGlzLnNlbGVjdGVkVGFiSWRcbiAgICB9KTtcbiAgICB0aGlzLnNlbGVjdGVkVGl0bGUgPSBhd2FpdCB0aGlzLmdldFRhYlRpdGxlQnlJZCh0aGlzLnNlbGVjdGVkVGFiSWQpO1xuICB9XG4gIHNlbGVjdGVkVGl0bGVDaGFuZ2VkKCkge1xuICAgIHRoaXMudXBkYXRlT2Zmc2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVdpZHRoKCk7XG4gICAgLy8gcmVzZXQgdGhlIGFuaW1hdGlvbiB0aW1lIG9uIHRhYiBzZWxlY3Rpb25cbiAgICB0aGlzLmFjdGl2ZUluZGljYXRvckVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3RoaXMuYW5pbWF0aW9uQWN0aXZlRHVyYXRpb259c2A7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5wYXJlbnRUYWJzRWwgPSB0aGlzLmVsLmNsb3Nlc3QoXCJjYWxjaXRlLXRhYnNcIik7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcj8ub2JzZXJ2ZSh0aGlzLmVsKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gIH1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgY29uc3Qgc3RvcmFnZUtleSA9IGBjYWxjaXRlLXRhYi1uYXYtJHt0aGlzLnN0b3JhZ2VJZH1gO1xuICAgIGlmIChsb2NhbFN0b3JhZ2UgJiYgdGhpcy5zdG9yYWdlSWQgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkpIHtcbiAgICAgIGNvbnN0IHN0b3JlZFRhYiA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkpO1xuICAgICAgdGhpcy5zZWxlY3RlZFRhYklkID0gc3RvcmVkVGFiO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsUmVuZGVyKCkge1xuICAgIGNvbnN0IHsgcGFyZW50VGFic0VsIH0gPSB0aGlzO1xuICAgIHRoaXMubGF5b3V0ID0gcGFyZW50VGFic0VsPy5sYXlvdXQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBhcmVudFRhYnNFbD8ucG9zaXRpb247XG4gICAgdGhpcy5zY2FsZSA9IHBhcmVudFRhYnNFbD8uc2NhbGU7XG4gICAgdGhpcy5ib3JkZXJlZCA9IHBhcmVudFRhYnNFbD8uYm9yZGVyZWQ7XG4gICAgLy8gZml4IGlzc3VlIHdpdGggYWN0aXZlIHRhYi10aXRsZSBub3QgbGluaW5nIHVwIHdpdGggYmx1ZSBpbmRpY2F0b3JcbiAgICBpZiAodGhpcy5zZWxlY3RlZFRpdGxlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU9mZnNldFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZFJlbmRlcigpIHtcbiAgICAvLyBpZiBldmVyeSB0YWIgdGl0bGUgaXMgYWN0aXZlIHNlbGVjdCB0aGUgZmlyc3QgdGFiLlxuICAgIGlmICh0aGlzLnRhYlRpdGxlcy5sZW5ndGggJiZcbiAgICAgIHRoaXMudGFiVGl0bGVzLmV2ZXJ5KCh0aXRsZSkgPT4gIXRpdGxlLnNlbGVjdGVkKSAmJlxuICAgICAgIXRoaXMuc2VsZWN0ZWRUYWJJZCkge1xuICAgICAgdGhpcy50YWJUaXRsZXNbMF0uZ2V0VGFiSWRlbnRpZmllcigpLnRoZW4oKHRhYikgPT4ge1xuICAgICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICB0YWJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5lbCk7XG4gICAgY29uc3Qgd2lkdGggPSBgJHt0aGlzLmluZGljYXRvcldpZHRofXB4YDtcbiAgICBjb25zdCBvZmZzZXQgPSBgJHt0aGlzLmluZGljYXRvck9mZnNldH1weGA7XG4gICAgY29uc3QgaW5kaWNhdG9yU3R5bGUgPSBkaXIgIT09IFwicnRsXCIgPyB7IHdpZHRoLCBsZWZ0OiBvZmZzZXQgfSA6IHsgd2lkdGgsIHJpZ2h0OiBvZmZzZXQgfTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyByb2xlOiBcInRhYmxpc3RcIiB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidGFiLW5hdlwiLCBvblNjcm9sbDogdGhpcy5oYW5kbGVDb250YWluZXJTY3JvbGwsIHJlZjogKGVsKSA9PiAodGhpcy50YWJOYXZFbCA9IGVsKSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidGFiLW5hdi1hY3RpdmUtaW5kaWNhdG9yLWNvbnRhaW5lclwiLCByZWY6IChlbCkgPT4gKHRoaXMuYWN0aXZlSW5kaWNhdG9yQ29udGFpbmVyRWwgPSBlbCkgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInRhYi1uYXYtYWN0aXZlLWluZGljYXRvclwiLCByZWY6IChlbCkgPT4gKHRoaXMuYWN0aXZlSW5kaWNhdG9yRWwgPSBlbCksIHN0eWxlOiBpbmRpY2F0b3JTdHlsZSB9KSksIGgoXCJzbG90XCIsIG51bGwpKSkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIEV2ZW50IExpc3RlbmVyc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZvY3VzUHJldmlvdXNUYWJIYW5kbGVyKGV2ZW50KSB7XG4gICAgdGhpcy5oYW5kbGVUYWJGb2N1cyhldmVudCwgZXZlbnQudGFyZ2V0LCBcInByZXZpb3VzXCIpO1xuICB9XG4gIGZvY3VzTmV4dFRhYkhhbmRsZXIoZXZlbnQpIHtcbiAgICB0aGlzLmhhbmRsZVRhYkZvY3VzKGV2ZW50LCBldmVudC50YXJnZXQsIFwibmV4dFwiKTtcbiAgfVxuICBmb2N1c0ZpcnN0VGFiSGFuZGxlcihldmVudCkge1xuICAgIHRoaXMuaGFuZGxlVGFiRm9jdXMoZXZlbnQsIGV2ZW50LnRhcmdldCwgXCJmaXJzdFwiKTtcbiAgfVxuICBmb2N1c0xhc3RUYWJIYW5kbGVyKGV2ZW50KSB7XG4gICAgdGhpcy5oYW5kbGVUYWJGb2N1cyhldmVudCwgZXZlbnQudGFyZ2V0LCBcImxhc3RcIik7XG4gIH1cbiAgaW50ZXJuYWxBY3RpdmF0ZVRhYkhhbmRsZXIoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkVGFiSWQgPSBldmVudC5kZXRhaWwudGFiXG4gICAgICA/IGV2ZW50LmRldGFpbC50YWJcbiAgICAgIDogdGhpcy5nZXRJbmRleE9mVGFiVGl0bGUoZXZlbnQudGFyZ2V0KTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGFjdGl2YXRlVGFiSGFuZGxlcihldmVudCkge1xuICAgIHRoaXMuY2FsY2l0ZVRhYkNoYW5nZS5lbWl0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgZm9yIGFjdGl2ZSB0YWJzIG9uIHJlZ2lzdGVyIGFuZCB1cGRhdGUgc2VsZWN0ZWRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqL1xuICB1cGRhdGVUYWJUaXRsZXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkVGFiSWQgPSBldmVudC5kZXRhaWw7XG4gICAgfVxuICB9XG4gIGdsb2JhbEludGVybmFsVGFiQ2hhbmdlSGFuZGxlcihldmVudCkge1xuICAgIGlmICh0aGlzLnN5bmNJZCAmJlxuICAgICAgZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVsICYmXG4gICAgICBldmVudC50YXJnZXQuc3luY0lkID09PSB0aGlzLnN5bmNJZCAmJlxuICAgICAgdGhpcy5zZWxlY3RlZFRhYklkICE9PSBldmVudC5kZXRhaWwudGFiKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkVGFiSWQgPSBldmVudC5kZXRhaWwudGFiO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBpY29uU3RhcnRDaGFuZ2VIYW5kbGVyKCkge1xuICAgIHRoaXMudXBkYXRlQWN0aXZlV2lkdGgoKTtcbiAgfVxuICB1cGRhdGVPZmZzZXRQb3NpdGlvbigpIHtcbiAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuZWwpO1xuICAgIGNvbnN0IG5hdldpZHRoID0gdGhpcy5hY3RpdmVJbmRpY2F0b3JDb250YWluZXJFbD8ub2Zmc2V0V2lkdGg7XG4gICAgY29uc3QgdGFiTGVmdCA9IHRoaXMuc2VsZWN0ZWRUaXRsZT8ub2Zmc2V0TGVmdDtcbiAgICBjb25zdCB0YWJXaWR0aCA9IHRoaXMuc2VsZWN0ZWRUaXRsZT8ub2Zmc2V0V2lkdGg7XG4gICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSBuYXZXaWR0aCAtICh0YWJMZWZ0ICsgdGFiV2lkdGgpO1xuICAgIHRoaXMuaW5kaWNhdG9yT2Zmc2V0ID1cbiAgICAgIGRpciAhPT0gXCJydGxcIiA/IHRhYkxlZnQgLSB0aGlzLnRhYk5hdkVsPy5zY3JvbGxMZWZ0IDogb2Zmc2V0UmlnaHQgKyB0aGlzLnRhYk5hdkVsPy5zY3JvbGxMZWZ0O1xuICB9XG4gIHVwZGF0ZUFjdGl2ZVdpZHRoKCkge1xuICAgIHRoaXMuaW5kaWNhdG9yV2lkdGggPSB0aGlzLnNlbGVjdGVkVGl0bGU/Lm9mZnNldFdpZHRoO1xuICB9XG4gIGdldEluZGV4T2ZUYWJUaXRsZShlbCwgdGFiVGl0bGVzID0gdGhpcy50YWJUaXRsZXMpIHtcbiAgICAvLyBJbiBtb3N0IGNhc2VzLCBzaW5jZSB0aGVzZSBpbmRleGVzIGNvcnJlbGF0ZSB3aXRoIHRhYiBjb250ZW50cywgd2Ugd2FudCB0byBjb25zaWRlciBhbGwgdGFiIHRpdGxlcy5cbiAgICAvLyBIb3dldmVyLCB3aGVuIGRvaW5nIHJlbGF0aXZlIGluZGV4IG9wZXJhdGlvbnMsIGl0IG1ha2VzIHNlbnNlIHRvIHBhc3MgaW4gdGhpcy5lbmFibGVkVGFiVGl0bGVzIGFzIHRoZSAybmQgYXJnLlxuICAgIHJldHVybiB0YWJUaXRsZXMuaW5kZXhPZihlbCk7XG4gIH1cbiAgYXN5bmMgZ2V0VGFiVGl0bGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMudGFiVGl0bGVzLm1hcCgoZWwpID0+IGVsLmdldFRhYklkZW50aWZpZXIoKSkpLnRoZW4oKGlkcykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudGFiVGl0bGVzW2lkcy5pbmRleE9mKGlkKV07XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHRhYlRpdGxlcygpIHtcbiAgICByZXR1cm4gZmlsdGVyRGlyZWN0Q2hpbGRyZW4odGhpcy5lbCwgXCJjYWxjaXRlLXRhYi10aXRsZVwiKTtcbiAgfVxuICBnZXQgZW5hYmxlZFRhYlRpdGxlcygpIHtcbiAgICByZXR1cm4gZmlsdGVyRGlyZWN0Q2hpbGRyZW4odGhpcy5lbCwgXCJjYWxjaXRlLXRhYi10aXRsZTpub3QoW2Rpc2FibGVkXSlcIik7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwic2VsZWN0ZWRUYWJJZFwiOiBbXCJzZWxlY3RlZFRhYklkQ2hhbmdlZFwiXSxcbiAgICBcInNlbGVjdGVkVGl0bGVcIjogW1wic2VsZWN0ZWRUaXRsZUNoYW5nZWRcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gdGFiTmF2Q3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLXRhYi1uYXZcIiwge1xuICAgIFwic3RvcmFnZUlkXCI6IFs1MTMsIFwic3RvcmFnZS1pZFwiXSxcbiAgICBcInN5bmNJZFwiOiBbNTEzLCBcInN5bmMtaWRcIl0sXG4gICAgXCJzZWxlY3RlZFRpdGxlXCI6IFsxMDQwXSxcbiAgICBcInNjYWxlXCI6IFsxNTM3XSxcbiAgICBcImxheW91dFwiOiBbMTUzN10sXG4gICAgXCJwb3NpdGlvblwiOiBbMTUzN10sXG4gICAgXCJib3JkZXJlZFwiOiBbMTU0MF0sXG4gICAgXCJpbmRpY2F0b3JPZmZzZXRcIjogWzEwMjYsIFwiaW5kaWNhdG9yLW9mZnNldFwiXSxcbiAgICBcImluZGljYXRvcldpZHRoXCI6IFsxMDI2LCBcImluZGljYXRvci13aWR0aFwiXSxcbiAgICBcInNlbGVjdGVkVGFiSWRcIjogWzMyXVxuICB9LCBbWzAsIFwiY2FsY2l0ZUludGVybmFsVGFic0ZvY3VzUHJldmlvdXNcIiwgXCJmb2N1c1ByZXZpb3VzVGFiSGFuZGxlclwiXSwgWzAsIFwiY2FsY2l0ZUludGVybmFsVGFic0ZvY3VzTmV4dFwiLCBcImZvY3VzTmV4dFRhYkhhbmRsZXJcIl0sIFswLCBcImNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c0ZpcnN0XCIsIFwiZm9jdXNGaXJzdFRhYkhhbmRsZXJcIl0sIFswLCBcImNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c0xhc3RcIiwgXCJmb2N1c0xhc3RUYWJIYW5kbGVyXCJdLCBbMCwgXCJjYWxjaXRlSW50ZXJuYWxUYWJzQWN0aXZhdGVcIiwgXCJpbnRlcm5hbEFjdGl2YXRlVGFiSGFuZGxlclwiXSwgWzAsIFwiY2FsY2l0ZVRhYnNBY3RpdmF0ZVwiLCBcImFjdGl2YXRlVGFiSGFuZGxlclwiXSwgWzAsIFwiY2FsY2l0ZUludGVybmFsVGFiVGl0bGVSZWdpc3RlclwiLCBcInVwZGF0ZVRhYlRpdGxlc1wiXSwgWzE2LCBcImNhbGNpdGVJbnRlcm5hbFRhYkNoYW5nZVwiLCBcImdsb2JhbEludGVybmFsVGFiQ2hhbmdlSGFuZGxlclwiXSwgWzAsIFwiY2FsY2l0ZUludGVybmFsVGFiSWNvbkNoYW5nZWRcIiwgXCJpY29uU3RhcnRDaGFuZ2VIYW5kbGVyXCJdXV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQ0KCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJjYWxjaXRlLXRhYi1uYXZcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtdGFiLW5hdlwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFRhYk5hdik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cbmRlZmluZUN1c3RvbUVsZW1lbnQkNCgpO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG5jb25zdCB0YWJDc3MgPSBcIkBrZXlmcmFtZXMgaW57MCV7b3BhY2l0eTowfTEwMCV7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGluLWRvd257MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAtNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tdXB7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCA1cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi1zY2FsZXswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM0QoMC45NSwgMC45NSwgMSl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM0QoMSwgMSwgMSl9fTpyb290ey0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nOmNhbGMoMTUwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6dmFyKC0tY2FsY2l0ZS1kdXJhdGlvbi1mYWN0b3IsIDEpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3Q6Y2FsYygxMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtOmNhbGMoMjAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3c6Y2FsYygzMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSl9LmNhbGNpdGUtYW5pbWF0ZXtvcGFjaXR5OjA7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO2FuaW1hdGlvbi1kdXJhdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpfS5jYWxjaXRlLWFuaW1hdGVfX2lue2FuaW1hdGlvbi1uYW1lOmlufS5jYWxjaXRlLWFuaW1hdGVfX2luLWRvd257YW5pbWF0aW9uLW5hbWU6aW4tZG93bn0uY2FsY2l0ZS1hbmltYXRlX19pbi11cHthbmltYXRpb24tbmFtZTppbi11cH0uY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZXthbmltYXRpb24tbmFtZTppbi1zY2FsZX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7OnJvb3R7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcjowfX06cm9vdHstLWNhbGNpdGUtZmxvYXRpbmctdWktdHJhbnNpdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpOy0tY2FsY2l0ZS1mbG9hdGluZy11aS16LWluZGV4OjYwMH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfTpob3N0KFtzZWxlY3RlZF0pIHNlY3Rpb24sOmhvc3QoW3NlbGVjdGVkXSkgLmNvbnRhaW5lcntkaXNwbGF5OmJsb2NrfTpob3N0e2Rpc3BsYXk6bm9uZTtibG9jay1zaXplOjEwMCU7aW5saW5lLXNpemU6MTAwJX06aG9zdChbc2VsZWN0ZWRdKXtkaXNwbGF5OmJsb2NrO2Jsb2NrLXNpemU6MTAwJTtpbmxpbmUtc2l6ZToxMDAlO292ZXJmbG93OmF1dG99c2VjdGlvbiwuY29udGFpbmVye2Rpc3BsYXk6bm9uZTtibG9jay1zaXplOjEwMCU7aW5saW5lLXNpemU6MTAwJX06aG9zdChbc2NhbGU9c10pe3BhZGRpbmctYmxvY2s6MC4yNXJlbTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTIpO2xpbmUtaGVpZ2h0OjFyZW19Omhvc3QoW3NjYWxlPW1dKXtwYWRkaW5nLWJsb2NrOjAuNXJlbTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTEpO2xpbmUtaGVpZ2h0OjFyZW19Omhvc3QoW3NjYWxlPWxdKXtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtMCk7bGluZS1oZWlnaHQ6MS4yNXJlbTtwYWRkaW5nLWJsb2NrOjEzcHh9XCI7XG5cbmNvbnN0IFRhYiA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYlJlZ2lzdGVyID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlSW50ZXJuYWxUYWJSZWdpc3RlclwiLCA2KTtcbiAgICB0aGlzLmd1aWQgPSBgY2FsY2l0ZS10YWItdGl0bGUtJHtndWlkKCl9YDtcbiAgICB0aGlzLnRhYiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsZSA9IFwibVwiO1xuICAgIHRoaXMubGFiZWxlZEJ5ID0gdW5kZWZpbmVkO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZWwuaWQgfHwgdGhpcy5ndWlkO1xuICAgIHJldHVybiAoaChIb3N0LCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRoaXMubGFiZWxlZEJ5LCBpZDogaWQgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImNvbnRhaW5lclwiLCByb2xlOiBcInRhYnBhbmVsXCIsIHRhYkluZGV4OiB0aGlzLnNlbGVjdGVkID8gMCA6IC0xIH0sIGgoXCJzZWN0aW9uXCIsIG51bGwsIGgoXCJzbG90XCIsIG51bGwpKSkpKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnBhcmVudFRhYnNFbCA9IHRoaXMuZWwuY2xvc2VzdChcImNhbGNpdGUtdGFic1wiKTtcbiAgfVxuICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIHRoaXMuY2FsY2l0ZUludGVybmFsVGFiUmVnaXN0ZXIuZW1pdCgpO1xuICB9XG4gIGNvbXBvbmVudFdpbGxSZW5kZXIoKSB7XG4gICAgdGhpcy5zY2FsZSA9IHRoaXMucGFyZW50VGFic0VsPy5zY2FsZTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAvLyBEaXNwYXRjaGluZyB0byBib2R5IGluIG9yZGVyIHRvIGJlIGxpc3RlbmVkIGJ5IG90aGVyIGVsZW1lbnRzIHRoYXQgYXJlIHN0aWxsIGNvbm5lY3RlZCB0byB0aGUgRE9NLlxuICAgIGRvY3VtZW50LmJvZHk/LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2FsY2l0ZVRhYlVucmVnaXN0ZXJcIiwge1xuICAgICAgZGV0YWlsOiB0aGlzLmVsXG4gICAgfSkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIEV2ZW50IExpc3RlbmVyc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGludGVybmFsVGFiQ2hhbmdlSGFuZGxlcihldmVudCkge1xuICAgIGNvbnN0IHRhcmdldFRhYnNFbCA9IGV2ZW50XG4gICAgICAuY29tcG9zZWRQYXRoKClcbiAgICAgIC5maW5kKChlbCkgPT4gZWwudGFnTmFtZSA9PT0gXCJDQUxDSVRFLVRBQlNcIik7XG4gICAgLy8gdG8gYWxsb3cgYDxjYWxjaXRlLXRhYnM+YCB0byBiZSBuZXN0ZWQgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhpc1xuICAgIC8vIGBjYWxjaXRlVGFiQ2hhbmdlYCBldmVudCB3YXMgYWN0dWFsbHkgZmlyZWQgZnJvbSBhIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGA8Y2FsY2l0ZS10YWJzPmAgdGhhdCBpcyB0aGUgYSBwYXJlbnQgb2YgdGhpcyB0YWIuXG4gICAgaWYgKHRhcmdldFRhYnNFbCAhPT0gdGhpcy5wYXJlbnRUYWJzRWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFiKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy50YWIgPT09IGV2ZW50LmRldGFpbC50YWI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5nZXRUYWJJbmRleCgpLnRoZW4oKGluZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBpbmRleCA9PT0gZXZlbnQuZGV0YWlsLnRhYjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQdWJsaWMgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY29tcG9uZW50IGl0ZW0gd2l0aGluIHRoZSB0YWIgYXJyYXkuXG4gICAqL1xuICBhc3luYyBnZXRUYWJJbmRleCgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChub2RlTGlzdFRvQXJyYXkodGhpcy5lbC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoKGVsKSA9PiBlbC5tYXRjaGVzKFwiY2FsY2l0ZS10YWJcIikpLCB0aGlzLmVsKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQHBhcmFtIHRhYklkc1xuICAgKiBAcGFyYW0gdGl0bGVJZHNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyB1cGRhdGVBcmlhSW5mbyh0YWJJZHMgPSBbXSwgdGl0bGVJZHMgPSBbXSkge1xuICAgIHRoaXMubGFiZWxlZEJ5ID0gdGl0bGVJZHNbdGFiSWRzLmluZGV4T2YodGhpcy5lbC5pZCldIHx8IG51bGw7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gdGFiQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLXRhYlwiLCB7XG4gICAgXCJ0YWJcIjogWzUxM10sXG4gICAgXCJzZWxlY3RlZFwiOiBbMTU0MF0sXG4gICAgXCJzY2FsZVwiOiBbMTUzN10sXG4gICAgXCJsYWJlbGVkQnlcIjogWzMyXSxcbiAgICBcImdldFRhYkluZGV4XCI6IFs2NF0sXG4gICAgXCJ1cGRhdGVBcmlhSW5mb1wiOiBbNjRdXG4gIH0sIFtbMTYsIFwiY2FsY2l0ZUludGVybmFsVGFiQ2hhbmdlXCIsIFwiaW50ZXJuYWxUYWJDaGFuZ2VIYW5kbGVyXCJdXV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCQzKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJjYWxjaXRlLXRhYlwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiY2FsY2l0ZS10YWJcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBUYWIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5kZWZpbmVDdXN0b21FbGVtZW50JDMoKTtcblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cblxuY29uc3QgQ1NTJDIgPSB7XG4gIGNvbnRhaW5lcjogXCJjb250YWluZXJcIixcbiAgY29udGFpbmVySGFzVGV4dDogXCJjb250YWluZXItLWhhcy10ZXh0XCIsXG4gIGljb25FbmQ6IFwiaWNvbi1lbmRcIixcbiAgaWNvblN0YXJ0OiBcImljb24tc3RhcnRcIixcbiAgaWNvblByZXNlbnQ6IFwiaWNvbi1wcmVzZW50XCIsXG4gIHRpdGxlSWNvbjogXCJjYWxjaXRlLXRhYi10aXRsZS0taWNvblwiXG59O1xuXG5jb25zdCB0YWJUaXRsZUNzcyA9IFwiQGtleWZyYW1lcyBpbnswJXtvcGFjaXR5OjB9MTAwJXtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgaW4tZG93bnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIC01cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi11cHswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDVweCwgMCl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDAsIDApfX1Aa2V5ZnJhbWVzIGluLXNjYWxlezAle29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUzRCgwLjk1LCAwLjk1LCAxKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGUzRCgxLCAxLCAxKX19OnJvb3R7LS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmc6Y2FsYygxNTBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3Rvcjp2YXIoLS1jYWxjaXRlLWR1cmF0aW9uLWZhY3RvciwgMSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctZmFzdDpjYWxjKDEwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1tZWRpdW06Y2FsYygyMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctc2xvdzpjYWxjKDMwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKX0uY2FsY2l0ZS1hbmltYXRle29wYWNpdHk6MDthbmltYXRpb24tZmlsbC1tb2RlOmJvdGg7YW5pbWF0aW9uLWR1cmF0aW9uOnZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZyl9LmNhbGNpdGUtYW5pbWF0ZV9faW57YW5pbWF0aW9uLW5hbWU6aW59LmNhbGNpdGUtYW5pbWF0ZV9faW4tZG93bnthbmltYXRpb24tbmFtZTppbi1kb3dufS5jYWxjaXRlLWFuaW1hdGVfX2luLXVwe2FuaW1hdGlvbi1uYW1lOmluLXVwfS5jYWxjaXRlLWFuaW1hdGVfX2luLXNjYWxle2FuaW1hdGlvbi1uYW1lOmluLXNjYWxlfUBtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKXs6cm9vdHstLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yOjB9fTpyb290ey0tY2FsY2l0ZS1mbG9hdGluZy11aS10cmFuc2l0aW9uOnZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZyk7LS1jYWxjaXRlLWZsb2F0aW5nLXVpLXotaW5kZXg6NjAwfTpob3N0KFtoaWRkZW5dKXtkaXNwbGF5Om5vbmV9Omhvc3QoW2Rpc2FibGVkXSl7cG9pbnRlci1ldmVudHM6bm9uZTtjdXJzb3I6ZGVmYXVsdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtvcGFjaXR5OnZhcigtLWNhbGNpdGUtdWktb3BhY2l0eS1kaXNhYmxlZCl9Omhvc3R7ZGlzcGxheTpibG9jaztmbGV4OjAgMSBhdXRvO291dGxpbmU6MnB4IHNvbGlkIHRyYW5zcGFyZW50O291dGxpbmUtb2Zmc2V0OjJweDttYXJnaW4taW5saW5lLXN0YXJ0OjBweDttYXJnaW4taW5saW5lLWVuZDoxLjI1cmVtfTpob3N0KFtsYXlvdXQ9Y2VudGVyXSl7bWFyZ2luLWJsb2NrOjBweDttYXJnaW4taW5saW5lOjEuMjVyZW07dGV4dC1hbGlnbjpjZW50ZXI7ZmxleC1iYXNpczoxMnJlbTttYXJnaW46YXV0b306aG9zdChbcG9zaXRpb249Ym90dG9tXSkgLmNvbnRhaW5lcntib3JkZXItYmxvY2stZW5kLXdpZHRoOjBweDtib3JkZXItYmxvY2stc3RhcnQtd2lkdGg6MnB4O2JvcmRlci1ibG9jay1zdGFydC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItYmxvY2stc3RhcnQtc3R5bGU6c29saWR9Omhvc3QgLmNvbnRhaW5lcntvdXRsaW5lLWNvbG9yOnRyYW5zcGFyZW50fTpob3N0KDpmb2N1cykgLmNvbnRhaW5lcntvdXRsaW5lOjJweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKTtvdXRsaW5lLW9mZnNldDotMnB4fTpob3N0KDphY3RpdmUpIGEsOmhvc3QoOmZvY3VzKSBhLDpob3N0KDpob3ZlcikgYXtib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMik7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO3RleHQtZGVjb3JhdGlvbi1saW5lOm5vbmV9Omhvc3QoW3NlbGVjdGVkXSkgLmNvbnRhaW5lcntib3JkZXItY29sb3I6dHJhbnNwYXJlbnQ7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpfTpob3N0KFtkaXNhYmxlZF0pIC5jb250YWluZXJ7cG9pbnRlci1ldmVudHM6bm9uZTtvcGFjaXR5OjAuNX06aG9zdChbZGlzYWJsZWRdKSA6OnNsb3R0ZWQoW2NhbGNpdGUtaHlkcmF0ZWRdW2Rpc2FibGVkXSksOmhvc3QoW2Rpc2FibGVkXSkgW2NhbGNpdGUtaHlkcmF0ZWRdW2Rpc2FibGVkXXtvcGFjaXR5OjF9Omhvc3QoW3NjYWxlPXNdKXttYXJnaW4taW5saW5lLWVuZDoxcmVtfTpob3N0KFtzY2FsZT1zXSkgLmNvbnRhaW5lcntwYWRkaW5nLWJsb2NrOjAuMjVyZW07Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtsaW5lLWhlaWdodDoxcmVtfTpob3N0KFtzY2FsZT1tXSkgLmNvbnRhaW5lcntwYWRkaW5nLWJsb2NrOjAuNXJlbTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTEpO2xpbmUtaGVpZ2h0OjFyZW19Omhvc3QoW3NjYWxlPWxdKXttYXJnaW4taW5saW5lLWVuZDoxLjVyZW19Omhvc3QoW3NjYWxlPWxdKSAuY29udGFpbmVye3BhZGRpbmctYmxvY2s6MC42MjVyZW07Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLTApO2xpbmUtaGVpZ2h0OjEuMjVyZW19LmNvbnRhaW5lcntib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O2Jsb2NrLXNpemU6MTAwJTtpbmxpbmUtc2l6ZToxMDAlO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2FwcGVhcmFuY2U6bm9uZTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtib3JkZXItYmxvY2stZW5kLXdpZHRoOjJweDtwYWRkaW5nLWlubGluZTowcHg7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0xKTtsaW5lLWhlaWdodDoxcmVtO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0zKTt0cmFuc2l0aW9uOmFsbCB2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpIGVhc2UtaW4tb3V0IDBzLCBvdXRsaW5lIDBzLCBvdXRsaW5lLW9mZnNldCAwcztib3JkZXItYmxvY2stZW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ibG9jay1lbmQtc3R5bGU6c29saWR9LmNhbGNpdGUtdGFiLXRpdGxlLS1pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjowcHg7ZGlzcGxheTppbmxpbmUtZmxleDthbGlnbi1zZWxmOmNlbnRlcn0uY2FsY2l0ZS10YWItdGl0bGUtLWljb24gc3Zne3RyYW5zaXRpb246YWxsIHZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZykgZWFzZS1pbi1vdXQgMHMsIG91dGxpbmUgMHMsIG91dGxpbmUtb2Zmc2V0IDBzfS5jb250YWluZXItLWhhcy10ZXh0e3BhZGRpbmc6MC4yNXJlbX0uY29udGFpbmVyLS1oYXMtdGV4dCAuY2FsY2l0ZS10YWItdGl0bGUtLWljb24uaWNvbi1zdGFydHttYXJnaW4taW5saW5lLWVuZDowLjVyZW19LmNvbnRhaW5lci0taGFzLXRleHQgLmNhbGNpdGUtdGFiLXRpdGxlLS1pY29uLmljb24tZW5ke21hcmdpbi1pbmxpbmUtc3RhcnQ6MC41cmVtfTpob3N0KFtpY29uLXN0YXJ0XVtpY29uLWVuZF0pIC5jYWxjaXRlLXRhYi10aXRsZS0taWNvbjpmaXJzdC1jaGlsZHttYXJnaW4taW5saW5lLWVuZDowLjVyZW19Omhvc3QoW2JvcmRlcmVkXSl7bWFyZ2luLWlubGluZS1lbmQ6MH06aG9zdChbYm9yZGVyZWRdW3NlbGVjdGVkXSl7Ym94LXNoYWRvdzppbnNldCAwcHggLTJweCB2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMSl9Omhvc3QoW2JvcmRlcmVkXVtzZWxlY3RlZF1bcG9zaXRpb249Ym90dG9tXSl7Ym94LXNoYWRvdzppbnNldCAwIDJweCAwIHZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKX06aG9zdChbYm9yZGVyZWRdOmhvdmVyKSAuY29udGFpbmVyLDpob3N0KFtib3JkZXJlZF06Zm9jdXMpIC5jb250YWluZXIsOmhvc3QoW2JvcmRlcmVkXTphY3RpdmUpIC5jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmV9Omhvc3QoW2JvcmRlcmVkXTpob3ZlcikgLmNvbnRhaW5lcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtYnV0dG9uLXRyYW5zcGFyZW50LWhvdmVyKX06aG9zdChbYm9yZGVyZWRdKSAuY29udGFpbmVye2JvcmRlci1ibG9jay1lbmQtc3R5bGU6dW5zZXQ7Ym9yZGVyLWlubGluZS1zdGFydDoxcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWlubGluZS1lbmQ6MXB4IHNvbGlkIHRyYW5zcGFyZW50fTpob3N0KFtib3JkZXJlZF1bcG9zaXRpb249Ym90dG9tXSkgLmNvbnRhaW5lcntib3JkZXItYmxvY2stc3RhcnQtc3R5bGU6dW5zZXR9Omhvc3QoW3NlbGVjdGVkXVtib3JkZXJlZF0pIC5jb250YWluZXJ7Ym9yZGVyLWlubGluZS1zdGFydC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0xKTtib3JkZXItaW5saW5lLWVuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0xKX06aG9zdChbYm9yZGVyZWRdKSAuY29udGFpbmVye3BhZGRpbmctaW5saW5lOjAuNzVyZW19Omhvc3QoW2JvcmRlcmVkXVtzY2FsZT1zXSkgLmNvbnRhaW5lcntwYWRkaW5nLWlubGluZTowLjVyZW19Omhvc3QoW2JvcmRlcmVkXVtzY2FsZT1sXSkgLmNvbnRhaW5lcntwYWRkaW5nLWlubGluZToxcmVtfTpob3N0KFtib3JkZXJlZF1bc2NhbGU9bF0pIC5pY29uLXByZXNlbnR7cGFkZGluZy1ibG9jazoxMXB4fUBtZWRpYSAoZm9yY2VkLWNvbG9yczogYWN0aXZlKXs6aG9zdHtvdXRsaW5lLXdpZHRoOjA7b3V0bGluZS1vZmZzZXQ6MH06aG9zdCg6Zm9jdXMpIC5jb250YWluZXJ7b3V0bGluZS1jb2xvcjpoaWdobGlnaHR9Omhvc3QoW2JvcmRlcmVkXSkgLmNvbnRhaW5lcntib3JkZXItYmxvY2stZW5kLXN0eWxlOnNvbGlkfTpob3N0KFtib3JkZXJlZF1bcG9zaXRpb249Ym90dG9tXSkgLmNvbnRhaW5lcntib3JkZXItYmxvY2stc3RhcnQtc3R5bGU6c29saWR9Omhvc3QoW2JvcmRlcmVkXVtzZWxlY3RlZF0pIC5jb250YWluZXJ7Ym9yZGVyLWJsb2NrLWVuZC1zdHlsZTpub25lfTpob3N0KFtib3JkZXJlZF1bcG9zaXRpb249Ym90dG9tXVtzZWxlY3RlZF0pIC5jb250YWluZXJ7Ym9yZGVyLWJsb2NrLXN0YXJ0LXN0eWxlOm5vbmV9fVwiO1xuXG5jb25zdCBUYWJUaXRsZSA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmNhbGNpdGVUYWJzQWN0aXZhdGUgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVUYWJzQWN0aXZhdGVcIiwgNik7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJzQWN0aXZhdGUgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVJbnRlcm5hbFRhYnNBY3RpdmF0ZVwiLCA2KTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c05leHQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c05leHRcIiwgNik7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJzRm9jdXNQcmV2aW91cyA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2FsY2l0ZUludGVybmFsVGFic0ZvY3VzUHJldmlvdXNcIiwgNik7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJzRm9jdXNGaXJzdCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2FsY2l0ZUludGVybmFsVGFic0ZvY3VzRmlyc3RcIiwgNik7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJzRm9jdXNMYXN0ID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlSW50ZXJuYWxUYWJzRm9jdXNMYXN0XCIsIDYpO1xuICAgIHRoaXMuY2FsY2l0ZUludGVybmFsVGFiVGl0bGVSZWdpc3RlciA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2FsY2l0ZUludGVybmFsVGFiVGl0bGVSZWdpc3RlclwiLCA2KTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYkljb25DaGFuZ2VkID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlSW50ZXJuYWxUYWJJY29uQ2hhbmdlZFwiLCA2KTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBTdGF0ZS9Qcm9wc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiB3YXRjaGVzIGZvciBjaGFuZ2luZyB0ZXh0IGNvbnRlbnQgKi9cbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcihcIm11dGF0aW9uXCIsICgpID0+IHRoaXMudXBkYXRlSGFzVGV4dCgpKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIoXCJyZXNpemVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJJY29uQ2hhbmdlZC5lbWl0KCk7XG4gICAgfSk7XG4gICAgdGhpcy5ndWlkID0gYGNhbGNpdGUtdGFiLXRpdGxlLSR7Z3VpZCgpfWA7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmljb25FbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pY29uRmxpcFJ0bCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmljb25TdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxheW91dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3JkZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMudGFiID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29udHJvbHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oYXNUZXh0ID0gZmFsc2U7XG4gIH1cbiAgc2VsZWN0ZWRIYW5kbGVyKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmVtaXRBY3RpdmVUYWIoZmFsc2UpO1xuICAgIH1cbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnNldHVwVGV4dENvbnRlbnRPYnNlcnZlcigpO1xuICAgIHRoaXMucGFyZW50VGFiTmF2RWwgPSB0aGlzLmVsLmNsb3Nlc3QoXCJjYWxjaXRlLXRhYi1uYXZcIik7XG4gICAgdGhpcy5wYXJlbnRUYWJzRWwgPSB0aGlzLmVsLmNsb3Nlc3QoXCJjYWxjaXRlLXRhYnNcIik7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgLy8gRGlzcGF0Y2hpbmcgdG8gYm9keSBpbiBvcmRlciB0byBiZSBsaXN0ZW5lZCBieSBvdGhlciBlbGVtZW50cyB0aGF0IGFyZSBzdGlsbCBjb25uZWN0ZWQgdG8gdGhlIERPTS5cbiAgICBkb2N1bWVudC5ib2R5Py5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNhbGNpdGVUYWJUaXRsZVVucmVnaXN0ZXJcIiwge1xuICAgICAgZGV0YWlsOiB0aGlzLmVsXG4gICAgfSkpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICB7XG4gICAgICB0aGlzLnVwZGF0ZUhhc1RleHQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFiICYmIHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuZW1pdEFjdGl2ZVRhYihmYWxzZSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxSZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50VGFic0VsKSB7XG4gICAgICB0aGlzLmxheW91dCA9IHRoaXMucGFyZW50VGFic0VsLmxheW91dDtcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLnBhcmVudFRhYnNFbC5wb3NpdGlvbjtcbiAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLnBhcmVudFRhYnNFbC5zY2FsZTtcbiAgICAgIHRoaXMuYm9yZGVyZWQgPSB0aGlzLnBhcmVudFRhYnNFbC5ib3JkZXJlZDtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGNhc2Ugd2hlbiB0YWItbmF2IGlzIG9ubHkgcGFyZW50XG4gICAgaWYgKCF0aGlzLnBhcmVudFRhYnNFbCAmJiB0aGlzLnBhcmVudFRhYk5hdkVsKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gZ2V0RWxlbWVudFByb3AodGhpcy5wYXJlbnRUYWJOYXZFbCwgXCJwb3NpdGlvblwiLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMuc2NhbGUgPSBnZXRFbGVtZW50UHJvcCh0aGlzLnBhcmVudFRhYk5hdkVsLCBcInNjYWxlXCIsIHRoaXMuc2NhbGUpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmVsLmlkIHx8IHRoaXMuZ3VpZDtcbiAgICBjb25zdCBpY29uU3RhcnRFbCA9IChoKFwiY2FsY2l0ZS1pY29uXCIsIHsgY2xhc3M6IHsgW0NTUyQyLnRpdGxlSWNvbl06IHRydWUsIFtDU1MkMi5pY29uU3RhcnRdOiB0cnVlIH0sIGZsaXBSdGw6IHRoaXMuaWNvbkZsaXBSdGwgPT09IFwic3RhcnRcIiB8fCB0aGlzLmljb25GbGlwUnRsID09PSBcImJvdGhcIiwgaWNvbjogdGhpcy5pY29uU3RhcnQsIHNjYWxlOiB0aGlzLnNjYWxlID09PSBcImxcIiA/IFwibVwiIDogXCJzXCIgfSkpO1xuICAgIGNvbnN0IGljb25FbmRFbCA9IChoKFwiY2FsY2l0ZS1pY29uXCIsIHsgY2xhc3M6IHsgW0NTUyQyLnRpdGxlSWNvbl06IHRydWUsIFtDU1MkMi5pY29uRW5kXTogdHJ1ZSB9LCBmbGlwUnRsOiB0aGlzLmljb25GbGlwUnRsID09PSBcImVuZFwiIHx8IHRoaXMuaWNvbkZsaXBSdGwgPT09IFwiYm90aFwiLCBpY29uOiB0aGlzLmljb25FbmQsIHNjYWxlOiB0aGlzLnNjYWxlID09PSBcImxcIiA/IFwibVwiIDogXCJzXCIgfSkpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IFwiYXJpYS1jb250cm9sc1wiOiB0aGlzLmNvbnRyb2xzLCBcImFyaWEtc2VsZWN0ZWRcIjogdG9BcmlhQm9vbGVhbih0aGlzLnNlbGVjdGVkKSwgaWQ6IGlkLCByb2xlOiBcInRhYlwiLCB0YWJJbmRleDogdGhpcy5zZWxlY3RlZCA/IDAgOiAtMSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IHtcbiAgICAgICAgY29udGFpbmVyOiB0cnVlLFxuICAgICAgICBbQ1NTJDIuaWNvblByZXNlbnRdOiB0aGlzLmljb25TdGFydCB8fCB0aGlzLmljb25FbmQgPyB0cnVlIDogbnVsbCxcbiAgICAgICAgW0NTUyQyLmNvbnRhaW5lckhhc1RleHRdOiB0aGlzLmhhc1RleHRcbiAgICAgIH0sIHJlZjogKGVsKSA9PiB0aGlzLnJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKGVsKSB9LCB0aGlzLmljb25TdGFydCA/IGljb25TdGFydEVsIDogbnVsbCwgaChcInNsb3RcIiwgbnVsbCksIHRoaXMuaWNvbkVuZCA/IGljb25FbmRFbCA6IG51bGwpKSk7XG4gIH1cbiAgYXN5bmMgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYlRpdGxlUmVnaXN0ZXIuZW1pdChhd2FpdCB0aGlzLmdldFRhYklkZW50aWZpZXIoKSk7XG4gIH1cbiAgY29tcG9uZW50RGlkUmVuZGVyKCkge1xuICAgIHVwZGF0ZUhvc3RJbnRlcmFjdGlvbih0aGlzLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9KTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBFdmVudCBMaXN0ZW5lcnNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBpbnRlcm5hbFRhYkNoYW5nZUhhbmRsZXIoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXRUYWJzRWwgPSBldmVudFxuICAgICAgLmNvbXBvc2VkUGF0aCgpXG4gICAgICAuZmluZCgoZWwpID0+IGVsLnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1UQUJTXCIpO1xuICAgIGlmICh0YXJnZXRUYWJzRWwgIT09IHRoaXMucGFyZW50VGFic0VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRhYikge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMudGFiID09PSBldmVudC5kZXRhaWwudGFiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0VGFiSW5kZXgoKS50aGVuKChpbmRleCkgPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gaW5kZXggPT09IGV2ZW50LmRldGFpbC50YWI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgb25DbGljaygpIHtcbiAgICB0aGlzLmVtaXRBY3RpdmVUYWIoKTtcbiAgfVxuICBrZXlEb3duSGFuZGxlcihldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiIFwiOlxuICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgIHRoaXMuZW1pdEFjdGl2ZVRhYigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChnZXRFbGVtZW50RGlyKHRoaXMuZWwpID09PSBcImx0clwiKSB7XG4gICAgICAgICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJzRm9jdXNOZXh0LmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c1ByZXZpb3VzLmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGdldEVsZW1lbnREaXIodGhpcy5lbCkgPT09IFwibHRyXCIpIHtcbiAgICAgICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c1ByZXZpb3VzLmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c05leHQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJzRm9jdXNGaXJzdC5lbWl0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbFRhYnNGb2N1c0xhc3QuZW1pdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHVibGljIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHRpdGxlIHdpdGhpbiB0aGUgYGNhbGNpdGUtdGFiLW5hdmAuXG4gICAqL1xuICBhc3luYyBnZXRUYWJJbmRleCgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLmVsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtdGFiLXRpdGxlXCIpLCB0aGlzLmVsKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBnZXRUYWJJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnRhYiA/IHRoaXMudGFiIDogdGhpcy5nZXRUYWJJbmRleCgpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdGFiSWRzXG4gICAqIEBwYXJhbSB0aXRsZUlkc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIHVwZGF0ZUFyaWFJbmZvKHRhYklkcyA9IFtdLCB0aXRsZUlkcyA9IFtdKSB7XG4gICAgdGhpcy5jb250cm9scyA9IHRhYklkc1t0aXRsZUlkcy5pbmRleE9mKHRoaXMuZWwuaWQpXSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUhhc1RleHQoKSB7XG4gICAgdGhpcy5oYXNUZXh0ID0gdGhpcy5lbC50ZXh0Q29udGVudC50cmltKCkubGVuZ3RoID4gMDtcbiAgfVxuICBzZXR1cFRleHRDb250ZW50T2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyPy5vYnNlcnZlKHRoaXMuZWwsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICB9XG4gIGVtaXRBY3RpdmVUYWIodXNlclRyaWdnZXJlZCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0geyB0YWI6IHRoaXMudGFiIH07XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxUYWJzQWN0aXZhdGUuZW1pdChwYXlsb2FkKTtcbiAgICBpZiAodXNlclRyaWdnZXJlZCkge1xuICAgICAgdGhpcy5jYWxjaXRlVGFic0FjdGl2YXRlLmVtaXQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwic2VsZWN0ZWRcIjogW1wic2VsZWN0ZWRIYW5kbGVyXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIHRhYlRpdGxlQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLXRhYi10aXRsZVwiLCB7XG4gICAgXCJzZWxlY3RlZFwiOiBbMTU0MF0sXG4gICAgXCJkaXNhYmxlZFwiOiBbNTE2XSxcbiAgICBcImljb25FbmRcIjogWzUxMywgXCJpY29uLWVuZFwiXSxcbiAgICBcImljb25GbGlwUnRsXCI6IFs1MTMsIFwiaWNvbi1mbGlwLXJ0bFwiXSxcbiAgICBcImljb25TdGFydFwiOiBbNTEzLCBcImljb24tc3RhcnRcIl0sXG4gICAgXCJsYXlvdXRcIjogWzE1MzddLFxuICAgIFwicG9zaXRpb25cIjogWzE1MzddLFxuICAgIFwic2NhbGVcIjogWzE1MzddLFxuICAgIFwiYm9yZGVyZWRcIjogWzE1NDBdLFxuICAgIFwidGFiXCI6IFs1MTNdLFxuICAgIFwiY29udHJvbHNcIjogWzMyXSxcbiAgICBcImhhc1RleHRcIjogWzMyXSxcbiAgICBcImdldFRhYkluZGV4XCI6IFs2NF0sXG4gICAgXCJnZXRUYWJJZGVudGlmaWVyXCI6IFs2NF0sXG4gICAgXCJ1cGRhdGVBcmlhSW5mb1wiOiBbNjRdXG4gIH0sIFtbMTYsIFwiY2FsY2l0ZUludGVybmFsVGFiQ2hhbmdlXCIsIFwiaW50ZXJuYWxUYWJDaGFuZ2VIYW5kbGVyXCJdLCBbMCwgXCJjbGlja1wiLCBcIm9uQ2xpY2tcIl0sIFswLCBcImtleWRvd25cIiwgXCJrZXlEb3duSGFuZGxlclwiXV1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMigpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiY2FsY2l0ZS10YWItdGl0bGVcIiwgXCJjYWxjaXRlLWljb25cIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtdGFiLXRpdGxlXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgVGFiVGl0bGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhbGNpdGUtaWNvblwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgZGVmaW5lQ3VzdG9tRWxlbWVudCQ4KCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cbmRlZmluZUN1c3RvbUVsZW1lbnQkMigpO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICovXG5jb25zdCBoaWRkZW5Gb3JtSW5wdXRTbG90TmFtZSA9IFwiaGlkZGVuLWZvcm0taW5wdXRcIjtcbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGNvbXBvbmVudCkge1xuICByZXR1cm4gXCJjaGVja2VkXCIgaW4gY29tcG9uZW50O1xufVxuY29uc3Qgb25Gb3JtUmVzZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgZm9ybUNvbXBvbmVudFNldCA9IG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiBoYXNSZWdpc3RlcmVkRm9ybUNvbXBvbmVudFBhcmVudChmb3JtLCBmb3JtQ29tcG9uZW50RWwpIHtcbiAgLy8gd2UgdXNlIGV2ZW50cyBhcyBhIHdheSB0byB0ZXN0IGZvciBuZXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGNvbXBvbmVudHMgYWNyb3NzIHNoYWRvdyBib3VuZHNcbiAgY29uc3QgZm9ybUNvbXBvbmVudFJlZ2lzdGVyRXZlbnROYW1lID0gXCJjYWxjaXRlSW50ZXJuYWxGb3JtQ29tcG9uZW50UmVnaXN0ZXJcIjtcbiAgbGV0IGhhc1JlZ2lzdGVyZWRGb3JtQ29tcG9uZW50UGFyZW50ID0gZmFsc2U7XG4gIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihmb3JtQ29tcG9uZW50UmVnaXN0ZXJFdmVudE5hbWUsIChldmVudCkgPT4ge1xuICAgIGhhc1JlZ2lzdGVyZWRGb3JtQ29tcG9uZW50UGFyZW50ID0gZXZlbnRcbiAgICAgIC5jb21wb3NlZFBhdGgoKVxuICAgICAgLnNvbWUoKGVsZW1lbnQpID0+IGZvcm1Db21wb25lbnRTZXQuaGFzKGVsZW1lbnQpKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICBmb3JtQ29tcG9uZW50RWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZm9ybUNvbXBvbmVudFJlZ2lzdGVyRXZlbnROYW1lLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjb21wb3NlZDogdHJ1ZVxuICB9KSk7XG4gIHJldHVybiBoYXNSZWdpc3RlcmVkRm9ybUNvbXBvbmVudFBhcmVudDtcbn1cbi8qKlxuICogSGVscGVyIHRvIHN1Ym1pdCBhIGZvcm0uXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHJldHVybnMgdHJ1ZSBpZiBpdHMgYXNzb2NpYXRlZCBmb3JtIHdhcyBzdWJtaXR0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gc3VibWl0Rm9ybShjb21wb25lbnQpIHtcbiAgY29uc3QgeyBmb3JtRWwgfSA9IGNvbXBvbmVudDtcbiAgaWYgKCFmb3JtRWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXCJyZXF1ZXN0U3VibWl0XCIgaW4gZm9ybUVsID8gZm9ybUVsLnJlcXVlc3RTdWJtaXQoKSA6IGZvcm1FbC5zdWJtaXQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEhlbHBlciB0byByZXNldCBhIGZvcm0uXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiByZXNldEZvcm0oY29tcG9uZW50KSB7XG4gIGNvbXBvbmVudC5mb3JtRWw/LnJlc2V0KCk7XG59XG4vKipcbiAqIEhlbHBlciB0byBzZXQgdXAgZm9ybSBpbnRlcmFjdGlvbnMgb24gY29ubmVjdGVkQ2FsbGJhY2suXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBjb25uZWN0Rm9ybShjb21wb25lbnQpIHtcbiAgY29uc3QgeyBlbCwgdmFsdWUgfSA9IGNvbXBvbmVudDtcbiAgY29uc3QgZm9ybSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgXCJmb3JtXCIpO1xuICBpZiAoIWZvcm0gfHwgaGFzUmVnaXN0ZXJlZEZvcm1Db21wb25lbnRQYXJlbnQoZm9ybSwgZWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXBvbmVudC5mb3JtRWwgPSBmb3JtO1xuICBjb21wb25lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gIGlmIChpc0NoZWNrYWJsZShjb21wb25lbnQpKSB7XG4gICAgY29tcG9uZW50LmRlZmF1bHRDaGVja2VkID0gY29tcG9uZW50LmNoZWNrZWQ7XG4gIH1cbiAgY29uc3QgYm91bmRPbkZvcm1SZXNldCA9IChjb21wb25lbnQub25Gb3JtUmVzZXQgfHwgb25Gb3JtUmVzZXQpLmJpbmQoY29tcG9uZW50KTtcbiAgZm9ybS5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgYm91bmRPbkZvcm1SZXNldCk7XG4gIG9uRm9ybVJlc2V0TWFwLnNldChjb21wb25lbnQuZWwsIGJvdW5kT25Gb3JtUmVzZXQpO1xuICBmb3JtQ29tcG9uZW50U2V0LmFkZChlbCk7XG59XG5mdW5jdGlvbiBvbkZvcm1SZXNldCgpIHtcbiAgaWYgKGlzQ2hlY2thYmxlKHRoaXMpKSB7XG4gICAgdGhpcy5jaGVja2VkID0gdGhpcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gdGVhciBkb3duIGZvcm0gaW50ZXJhY3Rpb25zIG9uIGRpc2Nvbm5lY3RlZENhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gZGlzY29ubmVjdEZvcm0oY29tcG9uZW50KSB7XG4gIGNvbnN0IHsgZWwsIGZvcm1FbCB9ID0gY29tcG9uZW50O1xuICBpZiAoIWZvcm1FbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBib3VuZE9uRm9ybVJlc2V0ID0gb25Gb3JtUmVzZXRNYXAuZ2V0KGVsKTtcbiAgZm9ybUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBib3VuZE9uRm9ybVJlc2V0KTtcbiAgb25Gb3JtUmVzZXRNYXAuZGVsZXRlKGVsKTtcbiAgY29tcG9uZW50LmZvcm1FbCA9IG51bGw7XG4gIGZvcm1Db21wb25lbnRTZXQuZGVsZXRlKGVsKTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBzZXR0aW5nIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uIGFmdGVyIGNvbm5lY3RlZENhbGxiYWNrLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgbmVlZGVkIGlmIHRoZSBkZWZhdWx0IHZhbHVlIGNhbm5vdCBiZSBkZXRlcm1pbmVkIG9uIGNvbm5lY3RlZENhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhZnRlckNvbm5lY3REZWZhdWx0VmFsdWVTZXQoY29tcG9uZW50LCB2YWx1ZSkge1xuICBjb21wb25lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG59XG5jb25zdCBoaWRkZW5JbnB1dENoYW5nZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgZXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2FsY2l0ZUludGVybmFsSGlkZGVuSW5wdXRDaGFuZ2VcIiwgeyBidWJibGVzOiB0cnVlIH0pKTtcbn07XG5jb25zdCByZW1vdmVIaWRkZW5JbnB1dENoYW5nZUV2ZW50TGlzdGVuZXIgPSAoaW5wdXQpID0+IGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGlkZGVuSW5wdXRDaGFuZ2VIYW5kbGVyKTtcbi8qKlxuICogSGVscGVyIGZvciBtYWludGFpbmluZyBhIGZvcm0tYXNzb2NpYXRlZCdzIGhpZGRlbiBpbnB1dCBpbiBzeW5jIHdpdGggdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBCYXNlZCBvbiBJb25pYydzIGFwcHJvYWNoOiBodHRwczovL2dpdGh1Yi5jb20vaW9uaWMtdGVhbS9pb25pYy1mcmFtZXdvcmsvYmxvYi9lNGJmMDUyNzk0YWY5YWFjMDdmODg3MDEzYjkyNTBkMmEwNDVlYmEzL2NvcmUvc3JjL3V0aWxzL2hlbHBlcnMudHMjTDE5OFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gc3luY0hpZGRlbkZvcm1JbnB1dChjb21wb25lbnQpIHtcbiAgY29uc3QgeyBlbCwgZm9ybUVsLCBuYW1lLCB2YWx1ZSB9ID0gY29tcG9uZW50O1xuICBjb25zdCB7IG93bmVyRG9jdW1lbnQgfSA9IGVsO1xuICBjb25zdCBpbnB1dHMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKGBpbnB1dFtzbG90PVwiJHtoaWRkZW5Gb3JtSW5wdXRTbG90TmFtZX1cIl1gKTtcbiAgaWYgKCFmb3JtRWwgfHwgIW5hbWUpIHtcbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIHJlbW92ZUhpZGRlbklucHV0Q2hhbmdlRXZlbnRMaXN0ZW5lcihpbnB1dCk7XG4gICAgICBpbnB1dC5yZW1vdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gIGNvbnN0IGV4dHJhID0gW107XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlTWF0Y2ggPSB2YWx1ZXMuZmluZCgodmFsKSA9PiBcbiAgICAvKiBpbnRlbnRpb25hbCBub24tc3RyaWN0IGVxdWFsaXR5IGNoZWNrICovXG4gICAgdmFsID09IGlucHV0LnZhbHVlKTtcbiAgICBpZiAodmFsdWVNYXRjaCAhPSBudWxsKSB7XG4gICAgICBzZWVuLmFkZCh2YWx1ZU1hdGNoKTtcbiAgICAgIGRlZmF1bHRTeW5jSGlkZGVuRm9ybUlucHV0KGNvbXBvbmVudCwgaW5wdXQsIHZhbHVlTWF0Y2gpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGV4dHJhLnB1c2goaW5wdXQpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBkb2NGcmFnO1xuICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBpbnB1dCA9IGV4dHJhLnBvcCgpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIGlucHV0ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBpbnB1dC5zbG90ID0gaGlkZGVuRm9ybUlucHV0U2xvdE5hbWU7XG4gICAgfVxuICAgIGlmICghZG9jRnJhZykge1xuICAgICAgZG9jRnJhZyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBkb2NGcmFnLmFwcGVuZChpbnB1dCk7XG4gICAgLy8gZW1pdHMgd2hlbiBoaWRkZW4gaW5wdXQgaXMgYXV0b2ZpbGxlZFxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGlkZGVuSW5wdXRDaGFuZ2VIYW5kbGVyKTtcbiAgICBkZWZhdWx0U3luY0hpZGRlbkZvcm1JbnB1dChjb21wb25lbnQsIGlucHV0LCB2YWx1ZSk7XG4gIH0pO1xuICBpZiAoZG9jRnJhZykge1xuICAgIGVsLmFwcGVuZChkb2NGcmFnKTtcbiAgfVxuICBleHRyYS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgIHJlbW92ZUhpZGRlbklucHV0Q2hhbmdlRXZlbnRMaXN0ZW5lcihpbnB1dCk7XG4gICAgaW5wdXQucmVtb3ZlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmYXVsdFN5bmNIaWRkZW5Gb3JtSW5wdXQoY29tcG9uZW50LCBpbnB1dCwgdmFsdWUpIHtcbiAgY29uc3QgeyBkZWZhdWx0VmFsdWUsIGRpc2FibGVkLCBuYW1lLCByZXF1aXJlZCB9ID0gY29tcG9uZW50O1xuICAvLyBrZWVwIGluIHN5bmMgdG8gcHJldmVudCBsb3NpbmcgcmVzZXQgdmFsdWVcbiAgaW5wdXQuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICBpbnB1dC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgaW5wdXQucmVxdWlyZWQgPSByZXF1aXJlZDtcbiAgaW5wdXQudGFiSW5kZXggPSAtMTtcbiAgaWYgKGlzQ2hlY2thYmxlKGNvbXBvbmVudCkpIHtcbiAgICBpbnB1dC5jaGVja2VkID0gY29tcG9uZW50LmNoZWNrZWQ7XG4gICAgLy8ga2VlcCBpbiBzeW5jIHRvIHByZXZlbnQgbG9zaW5nIHJlc2V0IHZhbHVlXG4gICAgaW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjb21wb25lbnQuZGVmYXVsdENoZWNrZWQ7XG4gICAgLy8gaGV1cmlzdGljIHRvIHN1cHBvcnQgZGVmYXVsdC9vbiBtb2RlIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCNkb20taW5wdXQtdmFsdWUtZGVmYXVsdC1vblxuICAgIGlucHV0LnZhbHVlID0gY29tcG9uZW50LmNoZWNrZWQgPyB2YWx1ZSB8fCBcIm9uXCIgOiBcIlwiO1xuICB9XG4gIGVsc2Uge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgfHwgXCJcIjtcbiAgfVxuICBjb21wb25lbnQuc3luY0hpZGRlbkZvcm1JbnB1dD8uKGlucHV0KTtcbn1cbi8qKlxuICogSGVscGVyIHRvIHJlbmRlciB0aGUgc2xvdCBmb3IgZm9ybS1hc3NvY2lhdGVkIGNvbXBvbmVudCdzIGhpZGRlbiBpbnB1dC5cbiAqXG4gKiBJZiB0aGUgY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgc2xvdCwgdGhpcyBtdXN0IGJlIHBsYWNlZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBjb21wb25lbnQncyByb290IGNvbnRhaW5lciB0byBlbnN1cmUgaXQgaXMgdGhlIGxhc3QgY2hpbGQuXG4gKlxuICogcmVuZGVyKCk6IFZOb2RlIHtcbiAqICAgPEhvc3Q+XG4gKiAgICAgPGRpdiBjbGFzcz17Q1NTLmNvbnRhaW5lcn0+XG4gKiAgICAgLy8gLi4uXG4gKiAgICAgPEhpZGRlbkZvcm1JbnB1dFNsb3QgY29tcG9uZW50PXt0aGlzfSAvPlxuICogICAgIDwvZGl2PlxuICogICA8L0hvc3Q+XG4gKiB9XG4gKlxuICogTm90ZSB0aGF0IHRoZSBoaWRkZW4tZm9ybS1pbnB1dCBTYXNzIG1peGluIG11c3QgYmUgYWRkZWQgdG8gdGhlIGNvbXBvbmVudCdzIHN0eWxlIHRvIGFwcGx5IHNwZWNpZmljIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0gcm9vdDBcbiAqIEBwYXJhbSByb290MC5jb21wb25lbnRcbiAqL1xuY29uc3QgSGlkZGVuRm9ybUlucHV0U2xvdCA9ICh7IGNvbXBvbmVudCB9KSA9PiB7XG4gIHN5bmNIaWRkZW5Gb3JtSW5wdXQoY29tcG9uZW50KTtcbiAgcmV0dXJuIGgoXCJzbG90XCIsIHsgbmFtZTogaGlkZGVuRm9ybUlucHV0U2xvdE5hbWUgfSk7XG59O1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG4vKipcbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgbGFiZWxDbGlja0V2ZW50ID0gXCJjYWxjaXRlSW50ZXJuYWxMYWJlbENsaWNrXCI7XG5jb25zdCBsYWJlbENvbm5lY3RlZEV2ZW50ID0gXCJjYWxjaXRlSW50ZXJuYWxMYWJlbENvbm5lY3RlZFwiO1xuY29uc3QgbGFiZWxEaXNjb25uZWN0ZWRFdmVudCA9IFwiY2FsY2l0ZUludGVybmFMYWJlbERpc2Nvbm5lY3RlZFwiO1xuY29uc3QgbGFiZWxUYWdOYW1lID0gXCJjYWxjaXRlLWxhYmVsXCI7XG5jb25zdCBvbkxhYmVsQ2xpY2tNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgb25MYWJlbENvbm5lY3RlZE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBvbkxhYmVsRGlzY29ubmVjdGVkTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHVubGFiZWxlZENvbXBvbmVudHMgPSBuZXcgU2V0KCk7XG5jb25zdCBmaW5kTGFiZWxGb3JDb21wb25lbnQgPSAoY29tcG9uZW50RWwpID0+IHtcbiAgY29uc3QgeyBpZCB9ID0gY29tcG9uZW50RWw7XG4gIGNvbnN0IGZvckxhYmVsID0gaWQgJiYgcXVlcnlFbGVtZW50Um9vdHMoY29tcG9uZW50RWwsIHsgc2VsZWN0b3I6IGAke2xhYmVsVGFnTmFtZX1bZm9yPVwiJHtpZH1cIl1gIH0pO1xuICBpZiAoZm9yTGFiZWwpIHtcbiAgICByZXR1cm4gZm9yTGFiZWw7XG4gIH1cbiAgY29uc3QgcGFyZW50TGFiZWwgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoY29tcG9uZW50RWwsIGxhYmVsVGFnTmFtZSk7XG4gIGlmICghcGFyZW50TGFiZWwgfHxcbiAgICAvLyBsYWJlbGFibGUgY29tcG9uZW50cyB3aXRoaW4gb3RoZXIgY3VzdG9tIGVsZW1lbnRzIGFyZSBub3QgY29uc2lkZXJlZCBsYWJlbGFibGVcbiAgICBoYXNBbmNlc3RvckN1c3RvbUVsZW1lbnRzKHBhcmVudExhYmVsLCBjb21wb25lbnRFbCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGFyZW50TGFiZWw7XG59O1xuZnVuY3Rpb24gaGFzQW5jZXN0b3JDdXN0b21FbGVtZW50cyhsYWJlbCwgY29tcG9uZW50RWwpIHtcbiAgbGV0IHRyYXZlcnNlZEVsZW1lbnRzO1xuICBjb25zdCBjdXN0b21FbGVtZW50QW5jZXN0b3JDaGVja0V2ZW50VHlwZSA9IFwiY3VzdG9tLWVsZW1lbnQtYW5jZXN0b3ItY2hlY2tcIjtcbiAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICB0cmF2ZXJzZWRFbGVtZW50cyA9IGNvbXBvc2VkUGF0aC5zbGljZShjb21wb3NlZFBhdGguaW5kZXhPZihjb21wb25lbnRFbCksIGNvbXBvc2VkUGF0aC5pbmRleE9mKGxhYmVsKSk7XG4gIH07XG4gIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoY3VzdG9tRWxlbWVudEFuY2VzdG9yQ2hlY2tFdmVudFR5cGUsIGxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gIGNvbXBvbmVudEVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGN1c3RvbUVsZW1lbnRBbmNlc3RvckNoZWNrRXZlbnRUeXBlLCB7IGNvbXBvc2VkOiB0cnVlLCBidWJibGVzOiB0cnVlIH0pKTtcbiAgbGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihjdXN0b21FbGVtZW50QW5jZXN0b3JDaGVja0V2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICBjb25zdCBhbmNlc3RvckN1c3RvbUVsZW1lbnRzID0gdHJhdmVyc2VkRWxlbWVudHNcbiAgICAuZmlsdGVyKChlbCkgPT4gZWwgIT09IGNvbXBvbmVudEVsICYmIGVsICE9PSBsYWJlbClcbiAgICAuZmlsdGVyKChlbCkgPT4gZWwudGFnTmFtZT8uaW5jbHVkZXMoXCItXCIpKTtcbiAgcmV0dXJuIGFuY2VzdG9yQ3VzdG9tRWxlbWVudHMubGVuZ3RoID4gMDtcbn1cbi8qKlxuICogSGVscGVyIHRvIHNldCB1cCBsYWJlbCBpbnRlcmFjdGlvbnMgb24gY29ubmVjdGVkQ2FsbGJhY2suXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBjb25uZWN0TGFiZWwoY29tcG9uZW50KSB7XG4gIGNvbnN0IGxhYmVsRWwgPSBmaW5kTGFiZWxGb3JDb21wb25lbnQoY29tcG9uZW50LmVsKTtcbiAgaWYgKG9uTGFiZWxDbGlja01hcC5oYXMobGFiZWxFbCkgfHwgKCFsYWJlbEVsICYmIHVubGFiZWxlZENvbXBvbmVudHMuaGFzKGNvbXBvbmVudCkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJvdW5kT25MYWJlbERpc2Nvbm5lY3RlZCA9IG9uTGFiZWxEaXNjb25uZWN0ZWQuYmluZChjb21wb25lbnQpO1xuICBpZiAobGFiZWxFbCkge1xuICAgIGNvbXBvbmVudC5sYWJlbEVsID0gbGFiZWxFbDtcbiAgICBjb25zdCBib3VuZE9uTGFiZWxDbGljayA9IG9uTGFiZWxDbGljay5iaW5kKGNvbXBvbmVudCk7XG4gICAgb25MYWJlbENsaWNrTWFwLnNldChjb21wb25lbnQubGFiZWxFbCwgYm91bmRPbkxhYmVsQ2xpY2spO1xuICAgIGNvbXBvbmVudC5sYWJlbEVsLmFkZEV2ZW50TGlzdGVuZXIobGFiZWxDbGlja0V2ZW50LCBib3VuZE9uTGFiZWxDbGljayk7XG4gICAgdW5sYWJlbGVkQ29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGxhYmVsQ29ubmVjdGVkRXZlbnQsIG9uTGFiZWxDb25uZWN0ZWRNYXAuZ2V0KGNvbXBvbmVudCkpO1xuICAgIG9uTGFiZWxEaXNjb25uZWN0ZWRNYXAuc2V0KGNvbXBvbmVudCwgYm91bmRPbkxhYmVsRGlzY29ubmVjdGVkKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGxhYmVsRGlzY29ubmVjdGVkRXZlbnQsIGJvdW5kT25MYWJlbERpc2Nvbm5lY3RlZCk7XG4gIH1cbiAgZWxzZSBpZiAoIXVubGFiZWxlZENvbXBvbmVudHMuaGFzKGNvbXBvbmVudCkpIHtcbiAgICBib3VuZE9uTGFiZWxEaXNjb25uZWN0ZWQoKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGxhYmVsRGlzY29ubmVjdGVkRXZlbnQsIG9uTGFiZWxEaXNjb25uZWN0ZWRNYXAuZ2V0KGNvbXBvbmVudCkpO1xuICB9XG59XG4vKipcbiAqIEhlbHBlciB0byB0ZWFyIGRvd24gbGFiZWwgaW50ZXJhY3Rpb25zIG9uIGRpc2Nvbm5lY3RlZENhbGxiYWNrIG9uIGxhYmVsYWJsZSBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gZGlzY29ubmVjdExhYmVsKGNvbXBvbmVudCkge1xuICB1bmxhYmVsZWRDb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGxhYmVsQ29ubmVjdGVkRXZlbnQsIG9uTGFiZWxDb25uZWN0ZWRNYXAuZ2V0KGNvbXBvbmVudCkpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGxhYmVsRGlzY29ubmVjdGVkRXZlbnQsIG9uTGFiZWxEaXNjb25uZWN0ZWRNYXAuZ2V0KGNvbXBvbmVudCkpO1xuICBvbkxhYmVsQ29ubmVjdGVkTWFwLmRlbGV0ZShjb21wb25lbnQpO1xuICBvbkxhYmVsRGlzY29ubmVjdGVkTWFwLmRlbGV0ZShjb21wb25lbnQpO1xuICBpZiAoIWNvbXBvbmVudC5sYWJlbEVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGJvdW5kT25MYWJlbENsaWNrID0gb25MYWJlbENsaWNrTWFwLmdldChjb21wb25lbnQubGFiZWxFbCk7XG4gIGNvbXBvbmVudC5sYWJlbEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobGFiZWxDbGlja0V2ZW50LCBib3VuZE9uTGFiZWxDbGljayk7XG4gIG9uTGFiZWxDbGlja01hcC5kZWxldGUoY29tcG9uZW50LmxhYmVsRWwpO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsYWJlbCB0ZXh0IGZyb20gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBnZXRMYWJlbFRleHQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQubGFiZWwgfHwgY29tcG9uZW50LmxhYmVsRWw/LnRleHRDb250ZW50Py50cmltKCkgfHwgXCJcIjtcbn1cbmZ1bmN0aW9uIG9uTGFiZWxDbGljayhldmVudCkge1xuICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb250YWluZWRMYWJlbGFibGVDaGlsZENsaWNrZWQgPSB0aGlzLmVsLmNvbnRhaW5zKGV2ZW50LmRldGFpbC5zb3VyY2VFdmVudC50YXJnZXQpO1xuICBpZiAoY29udGFpbmVkTGFiZWxhYmxlQ2hpbGRDbGlja2VkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMub25MYWJlbENsaWNrKGV2ZW50KTtcbn1cbmZ1bmN0aW9uIG9uTGFiZWxDb25uZWN0ZWQoKSB7XG4gIGlmICh1bmxhYmVsZWRDb21wb25lbnRzLmhhcyh0aGlzKSkge1xuICAgIGNvbm5lY3RMYWJlbCh0aGlzKTtcbiAgfVxufVxuZnVuY3Rpb24gb25MYWJlbERpc2Nvbm5lY3RlZCgpIHtcbiAgdW5sYWJlbGVkQ29tcG9uZW50cy5hZGQodGhpcyk7XG4gIGNvbnN0IGJvdW5kT25MYWJlbENvbm5lY3RlZCA9IG9uTGFiZWxDb25uZWN0ZWRNYXAuZ2V0KHRoaXMpIHx8IG9uTGFiZWxDb25uZWN0ZWQuYmluZCh0aGlzKTtcbiAgb25MYWJlbENvbm5lY3RlZE1hcC5zZXQodGhpcywgYm91bmRPbkxhYmVsQ29ubmVjdGVkKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihsYWJlbENvbm5lY3RlZEV2ZW50LCBib3VuZE9uTGFiZWxDb25uZWN0ZWQpO1xufVxuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG5jb25zdCBDU1MkMSA9IHtcbiAgaWNvbjogXCJpY29uXCIsXG4gIGljb25Db250YWluZXI6IFwiaWNvbi1jb250YWluZXJcIixcbiAgc2VsZWN0OiBcInNlbGVjdFwiXG59O1xuXG5jb25zdCBzZWxlY3RDc3MgPSBcIkBrZXlmcmFtZXMgaW57MCV7b3BhY2l0eTowfTEwMCV7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGluLWRvd257MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAtNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tdXB7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCA1cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi1zY2FsZXswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM0QoMC45NSwgMC45NSwgMSl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM0QoMSwgMSwgMSl9fTpyb290ey0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nOmNhbGMoMTUwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6dmFyKC0tY2FsY2l0ZS1kdXJhdGlvbi1mYWN0b3IsIDEpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3Q6Y2FsYygxMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtOmNhbGMoMjAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3c6Y2FsYygzMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSl9LmNhbGNpdGUtYW5pbWF0ZXtvcGFjaXR5OjA7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO2FuaW1hdGlvbi1kdXJhdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpfS5jYWxjaXRlLWFuaW1hdGVfX2lue2FuaW1hdGlvbi1uYW1lOmlufS5jYWxjaXRlLWFuaW1hdGVfX2luLWRvd257YW5pbWF0aW9uLW5hbWU6aW4tZG93bn0uY2FsY2l0ZS1hbmltYXRlX19pbi11cHthbmltYXRpb24tbmFtZTppbi11cH0uY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZXthbmltYXRpb24tbmFtZTppbi1zY2FsZX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7OnJvb3R7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcjowfX06aG9zdHstLWNhbGNpdGUtaWNvbi1zaXplOjFyZW07LS1jYWxjaXRlLXNwYWNpbmctZWlnaHRoOjAuMTI1cmVtOy0tY2FsY2l0ZS1zcGFjaW5nLXF1YXJ0ZXI6MC4yNXJlbTstLWNhbGNpdGUtc3BhY2luZy1oYWxmOjAuNXJlbTstLWNhbGNpdGUtc3BhY2luZy10aHJlZS1xdWFydGVyczowLjc1cmVtOy0tY2FsY2l0ZS1zcGFjaW5nOjFyZW07LS1jYWxjaXRlLXNwYWNpbmctcGx1cy1xdWFydGVyOjEuMjVyZW07LS1jYWxjaXRlLXNwYWNpbmctcGx1cy1oYWxmOjEuNXJlbTstLWNhbGNpdGUtc3BhY2luZy1kb3VibGU6MnJlbTstLWNhbGNpdGUtbWVudS1taW4td2lkdGg6MTByZW07LS1jYWxjaXRlLWhlYWRlci1taW4taGVpZ2h0OjNyZW07LS1jYWxjaXRlLWZvb3Rlci1taW4taGVpZ2h0OjNyZW19OnJvb3R7LS1jYWxjaXRlLWZsb2F0aW5nLXVpLXRyYW5zaXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKTstLWNhbGNpdGUtZmxvYXRpbmctdWktei1pbmRleDo2MDB9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX06aG9zdChbZGlzYWJsZWRdKXtwb2ludGVyLWV2ZW50czpub25lO2N1cnNvcjpkZWZhdWx0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO29wYWNpdHk6dmFyKC0tY2FsY2l0ZS11aS1vcGFjaXR5LWRpc2FibGVkKX06aG9zdHtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6c3RyZXRjaDtpbmxpbmUtc2l6ZTp2YXIoLS1zZWxlY3Qtd2lkdGgpfTpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRdKSw6aG9zdChbZGlzYWJsZWRdKSBbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRde29wYWNpdHk6MX06aG9zdChbc2NhbGU9c10pe2Jsb2NrLXNpemU6MS41cmVtOy0tY2FsY2l0ZS1zZWxlY3QtZm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTstLWNhbGNpdGUtc2VsZWN0LXNwYWNpbmctaW5saW5lOjAuNXJlbSAycmVtfTpob3N0KFtzY2FsZT1zXSkgLmljb24tY29udGFpbmVye3BhZGRpbmctaW5saW5lOjAuNXJlbX06aG9zdChbc2NhbGU9bV0pe2Jsb2NrLXNpemU6MnJlbTstLWNhbGNpdGUtc2VsZWN0LWZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMSk7LS1jYWxjaXRlLXNlbGVjdC1zcGFjaW5nLWlubGluZTowLjc1cmVtIDIuNXJlbX06aG9zdChbc2NhbGU9bV0pIC5pY29uLWNvbnRhaW5lcntwYWRkaW5nLWlubGluZTowLjc1cmVtfTpob3N0KFtzY2FsZT1sXSl7YmxvY2stc2l6ZTo0NHB4Oy0tY2FsY2l0ZS1zZWxlY3QtZm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLTApOy0tY2FsY2l0ZS1zZWxlY3Qtc3BhY2luZy1pbmxpbmU6MXJlbSAzcmVtfTpob3N0KFtzY2FsZT1sXSkgLmljb24tY29udGFpbmVye3BhZGRpbmctaW5saW5lOjFyZW19Omhvc3QoW3dpZHRoPWF1dG9dKXtpbmxpbmUtc2l6ZTphdXRvfTpob3N0KFt3aWR0aD1oYWxmXSl7aW5saW5lLXNpemU6NTAlfTpob3N0KFt3aWR0aD1mdWxsXSl7aW5saW5lLXNpemU6MTAwJX0uc2VsZWN0e21hcmdpbjowcHg7Ym94LXNpemluZzpib3JkZXItYm94O2lubGluZS1zaXplOjEwMCU7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7YXBwZWFyYW5jZTpub25lO292ZXJmbG93OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtib3JkZXItcmFkaXVzOjBweDtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItaW5wdXQpO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTIpO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtc2VsZWN0LWZvbnQtc2l6ZSk7cGFkZGluZy1pbmxpbmU6dmFyKC0tY2FsY2l0ZS1zZWxlY3Qtc3BhY2luZy1pbmxpbmUpO2JvcmRlci1pbmxpbmUtZW5kLXdpZHRoOjBweH0uc2VsZWN0OmZvY3Vze291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO291dGxpbmUtb2Zmc2V0Oi0ycHh9LnNlbGVjdDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0yKX1zZWxlY3Q6ZGlzYWJsZWR7Ym9yZGVyLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktYm9yZGVyLWlucHV0KTstLXR3LWJnLW9wYWNpdHk6MX0uaWNvbi1jb250YWluZXJ7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTtpbnNldC1ibG9jazowcHg7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtib3JkZXItd2lkdGg6MHB4O2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItaW5wdXQpO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTIpO2luc2V0LWlubGluZS1lbmQ6MHB4O2JvcmRlci1pbmxpbmUtd2lkdGg6MHB4IDFweH0uc2VsZWN0OmZvY3Vzfi5pY29uLWNvbnRhaW5lcntib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9OjpzbG90dGVkKGlucHV0W3Nsb3Q9aGlkZGVuLWZvcm0taW5wdXRdKXttYXJnaW46MCAhaW1wb3J0YW50O29wYWNpdHk6MCAhaW1wb3J0YW50O291dGxpbmU6bm9uZSAhaW1wb3J0YW50O3BhZGRpbmc6MCAhaW1wb3J0YW50O3Bvc2l0aW9uOmFic29sdXRlICFpbXBvcnRhbnQ7aW5zZXQ6MCAhaW1wb3J0YW50O3RyYW5zZm9ybTpub25lICFpbXBvcnRhbnQ7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmUgIWltcG9ydGFudDt6LWluZGV4Oi0xICFpbXBvcnRhbnR9XCI7XG5cbmZ1bmN0aW9uIGlzT3B0aW9uKG9wdGlvbk9yR3JvdXApIHtcbiAgcmV0dXJuIG9wdGlvbk9yR3JvdXAudGFnTmFtZSA9PT0gXCJDQUxDSVRFLU9QVElPTlwiO1xufVxuZnVuY3Rpb24gaXNPcHRpb25Hcm91cChvcHRpb25Pckdyb3VwKSB7XG4gIHJldHVybiBvcHRpb25Pckdyb3VwLnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1PUFRJT04tR1JPVVBcIjtcbn1cbmNvbnN0IFNlbGVjdCA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmNhbGNpdGVTZWxlY3RDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVTZWxlY3RDaGFuZ2VcIiwgNik7XG4gICAgdGhpcy5jb21wb25lbnRUb05hdGl2ZUVsID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKFwibXV0YXRpb25cIiwgKCkgPT4gdGhpcy5wb3B1bGF0ZUludGVybmFsU2VsZWN0KCkpO1xuICAgIHRoaXMuaGFuZGxlSW50ZXJuYWxTZWxlY3RDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0RWwuc2VsZWN0ZWRPcHRpb25zWzBdO1xuICAgICAgdGhpcy5zZWxlY3RGcm9tTmF0aXZlT3B0aW9uKHNlbGVjdGVkKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmVtaXRDaGFuZ2VFdmVudCgpKTtcbiAgICB9O1xuICAgIHRoaXMucG9wdWxhdGVJbnRlcm5hbFNlbGVjdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnNBbmRHcm91cHMgPSBBcnJheS5mcm9tKHRoaXMuZWwuY2hpbGRyZW4pLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLnRhZ05hbWUgPT09IFwiQ0FMQ0lURS1PUFRJT05cIiB8fCBjaGlsZC50YWdOYW1lID09PSBcIkNBTENJVEUtT1BUSU9OLUdST1VQXCIpO1xuICAgICAgdGhpcy5jbGVhckludGVybmFsU2VsZWN0KCk7XG4gICAgICBvcHRpb25zQW5kR3JvdXBzLmZvckVhY2goKG9wdGlvbk9yR3JvdXApID0+IHRoaXMuc2VsZWN0RWw/LmFwcGVuZCh0aGlzLnRvTmF0aXZlRWxlbWVudChvcHRpb25Pckdyb3VwKSkpO1xuICAgIH07XG4gICAgdGhpcy5zdG9yZVNlbGVjdFJlZiA9IChub2RlKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdEVsID0gbm9kZTtcbiAgICAgIHRoaXMucG9wdWxhdGVJbnRlcm5hbFNlbGVjdCgpO1xuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdEVsLnNlbGVjdGVkT3B0aW9uc1swXTtcbiAgICAgIHRoaXMuc2VsZWN0RnJvbU5hdGl2ZU9wdGlvbihzZWxlY3RlZCk7XG4gICAgfTtcbiAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2FsY2l0ZVNlbGVjdENoYW5nZS5lbWl0KCk7XG4gICAgfTtcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5hbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZXF1aXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdGVkT3B0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSBcImF1dG9cIjtcbiAgfVxuICB2YWx1ZUhhbmRsZXIodmFsdWUpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtb3B0aW9uXCIpO1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IChpdGVtLnNlbGVjdGVkID0gaXRlbS52YWx1ZSA9PT0gdmFsdWUpKTtcbiAgfVxuICBzZWxlY3RlZE9wdGlvbkhhbmRsZXIoc2VsZWN0ZWRPcHRpb24pIHtcbiAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWRPcHRpb24/LnZhbHVlO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyPy5vYnNlcnZlKGVsLCB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgfSk7XG4gICAgY29ubmVjdExhYmVsKHRoaXMpO1xuICAgIGNvbm5lY3RGb3JtKHRoaXMpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIGRpc2Nvbm5lY3RMYWJlbCh0aGlzKTtcbiAgICBkaXNjb25uZWN0Rm9ybSh0aGlzKTtcbiAgfVxuICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBzZXRVcExvYWRhYmxlQ29tcG9uZW50KHRoaXMpO1xuICB9XG4gIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgc2V0Q29tcG9uZW50TG9hZGVkKHRoaXMpO1xuICAgIGFmdGVyQ29ubmVjdERlZmF1bHRWYWx1ZVNldCh0aGlzLCB0aGlzLnNlbGVjdGVkT3B0aW9uPy52YWx1ZSA/PyBcIlwiKTtcbiAgfVxuICBjb21wb25lbnREaWRSZW5kZXIoKSB7XG4gICAgdXBkYXRlSG9zdEludGVyYWN0aW9uKHRoaXMpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFB1YmxpYyBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqIFNldHMgZm9jdXMgb24gdGhlIGNvbXBvbmVudC4gKi9cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgYXdhaXQgY29tcG9uZW50TG9hZGVkKHRoaXMpO1xuICAgIGZvY3VzRWxlbWVudCh0aGlzLnNlbGVjdEVsKTtcbiAgfVxuICBoYW5kbGVPcHRpb25Pckdyb3VwQ2hhbmdlKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3Qgb3B0aW9uT3JHcm91cCA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBuYXRpdmVFbCA9IHRoaXMuY29tcG9uZW50VG9OYXRpdmVFbC5nZXQob3B0aW9uT3JHcm91cCk7XG4gICAgaWYgKCFuYXRpdmVFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU5hdGl2ZUVsZW1lbnQob3B0aW9uT3JHcm91cCwgbmF0aXZlRWwpO1xuICAgIGlmIChpc09wdGlvbihvcHRpb25Pckdyb3VwKSAmJiBvcHRpb25Pckdyb3VwLnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmRlc2VsZWN0QWxsRXhjZXB0KG9wdGlvbk9yR3JvdXApO1xuICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IG9wdGlvbk9yR3JvdXA7XG4gICAgfVxuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIG9uTGFiZWxDbGljaygpIHtcbiAgICB0aGlzLnNldEZvY3VzKCk7XG4gIH1cbiAgdXBkYXRlTmF0aXZlRWxlbWVudChvcHRpb25Pckdyb3VwLCBuYXRpdmVPcHRpb25Pckdyb3VwKSB7XG4gICAgbmF0aXZlT3B0aW9uT3JHcm91cC5kaXNhYmxlZCA9IG9wdGlvbk9yR3JvdXAuZGlzYWJsZWQ7XG4gICAgbmF0aXZlT3B0aW9uT3JHcm91cC5sYWJlbCA9IG9wdGlvbk9yR3JvdXAubGFiZWw7XG4gICAgaWYgKGlzT3B0aW9uKG9wdGlvbk9yR3JvdXApKSB7XG4gICAgICBjb25zdCBvcHRpb24gPSBuYXRpdmVPcHRpb25Pckdyb3VwO1xuICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uT3JHcm91cC5zZWxlY3RlZDtcbiAgICAgIG9wdGlvbi52YWx1ZSA9IG9wdGlvbk9yR3JvdXAudmFsdWU7XG4gICAgICAvLyBuZWVkIHRvIHNldCBpbm5lclRleHQgZm9yIG1vYmlsZVxuICAgICAgLy8gc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1MDIxNjIwL2lvcy1zYWZhcmktbm90LXNob3dpbmctYWxsLW9wdGlvbnMtZm9yLXNlbGVjdC1tZW51LzQxNzQ5NzAxXG4gICAgICBvcHRpb24uaW5uZXJUZXh0ID0gb3B0aW9uT3JHcm91cC5sYWJlbDtcbiAgICB9XG4gIH1cbiAgY2xlYXJJbnRlcm5hbFNlbGVjdCgpIHtcbiAgICB0aGlzLmNvbXBvbmVudFRvTmF0aXZlRWwuZm9yRWFjaCgodmFsdWUpID0+IHZhbHVlLnJlbW92ZSgpKTtcbiAgICB0aGlzLmNvbXBvbmVudFRvTmF0aXZlRWwuY2xlYXIoKTtcbiAgfVxuICBzZWxlY3RGcm9tTmF0aXZlT3B0aW9uKG5hdGl2ZU9wdGlvbikge1xuICAgIGlmICghbmF0aXZlT3B0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmdXR1cmVTZWxlY3RlZDtcbiAgICB0aGlzLmNvbXBvbmVudFRvTmF0aXZlRWwuZm9yRWFjaCgobmF0aXZlT3B0aW9uT3JHcm91cCwgb3B0aW9uT3JHcm91cCkgPT4ge1xuICAgICAgaWYgKGlzT3B0aW9uKG9wdGlvbk9yR3JvdXApICYmIG5hdGl2ZU9wdGlvbk9yR3JvdXAgPT09IG5hdGl2ZU9wdGlvbikge1xuICAgICAgICBvcHRpb25Pckdyb3VwLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZnV0dXJlU2VsZWN0ZWQgPSBvcHRpb25Pckdyb3VwO1xuICAgICAgICB0aGlzLmRlc2VsZWN0QWxsRXhjZXB0KG9wdGlvbk9yR3JvdXApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmdXR1cmVTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3RlZE9wdGlvbiA9IGZ1dHVyZVNlbGVjdGVkO1xuICAgIH1cbiAgfVxuICB0b05hdGl2ZUVsZW1lbnQob3B0aW9uT3JHcm91cCkge1xuICAgIGlmIChpc09wdGlvbihvcHRpb25Pckdyb3VwKSkge1xuICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIHRoaXMudXBkYXRlTmF0aXZlRWxlbWVudChvcHRpb25Pckdyb3VwLCBvcHRpb24pO1xuICAgICAgdGhpcy5jb21wb25lbnRUb05hdGl2ZUVsLnNldChvcHRpb25Pckdyb3VwLCBvcHRpb24pO1xuICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICB9XG4gICAgaWYgKGlzT3B0aW9uR3JvdXAob3B0aW9uT3JHcm91cCkpIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGdyb3VwXCIpO1xuICAgICAgdGhpcy51cGRhdGVOYXRpdmVFbGVtZW50KG9wdGlvbk9yR3JvdXAsIGdyb3VwKTtcbiAgICAgIEFycmF5LmZyb20ob3B0aW9uT3JHcm91cC5jaGlsZHJlbikuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZU9wdGlvbiA9IHRoaXMudG9OYXRpdmVFbGVtZW50KG9wdGlvbik7XG4gICAgICAgIGdyb3VwLmFwcGVuZChuYXRpdmVPcHRpb24pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFRvTmF0aXZlRWwuc2V0KG9wdGlvbk9yR3JvdXAsIG5hdGl2ZU9wdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29tcG9uZW50VG9OYXRpdmVFbC5zZXQob3B0aW9uT3JHcm91cCwgZ3JvdXApO1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBlbGVtZW50IGNoaWxkIHByb3ZpZGVkXCIpO1xuICB9XG4gIGRlc2VsZWN0QWxsRXhjZXB0KGV4Y2VwdCkge1xuICAgIHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtb3B0aW9uXCIpLmZvckVhY2goKG9wdGlvbikgPT4ge1xuICAgICAgaWYgKG9wdGlvbiA9PT0gZXhjZXB0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlciBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyQ2hldnJvbigpIHtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuaWNvbkNvbnRhaW5lciB9LCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgY2xhc3M6IENTUyQxLmljb24sIGljb246IFwiY2hldnJvbi1kb3duXCIsIHNjYWxlOiB0aGlzLnNjYWxlID09PSBcImxcIiA/IFwibVwiIDogXCJzXCIgfSkpKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLCBoKFwic2VsZWN0XCIsIHsgXCJhcmlhLWxhYmVsXCI6IHRoaXMubGFiZWwsIGNsYXNzOiBDU1MkMS5zZWxlY3QsIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLCBvbkNoYW5nZTogdGhpcy5oYW5kbGVJbnRlcm5hbFNlbGVjdENoYW5nZSwgcmVmOiB0aGlzLnN0b3JlU2VsZWN0UmVmIH0sIGgoXCJzbG90XCIsIG51bGwpKSwgdGhpcy5yZW5kZXJDaGV2cm9uKCksIGgoSGlkZGVuRm9ybUlucHV0U2xvdCwgeyBjb21wb25lbnQ6IHRoaXMgfSkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJ2YWx1ZVwiOiBbXCJ2YWx1ZUhhbmRsZXJcIl0sXG4gICAgXCJzZWxlY3RlZE9wdGlvblwiOiBbXCJzZWxlY3RlZE9wdGlvbkhhbmRsZXJcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gc2VsZWN0Q3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLXNlbGVjdFwiLCB7XG4gICAgXCJkaXNhYmxlZFwiOiBbNTE2XSxcbiAgICBcImxhYmVsXCI6IFsxXSxcbiAgICBcIm5hbWVcIjogWzUxM10sXG4gICAgXCJyZXF1aXJlZFwiOiBbNTE2XSxcbiAgICBcInNjYWxlXCI6IFs1MTNdLFxuICAgIFwidmFsdWVcIjogWzEwMjVdLFxuICAgIFwic2VsZWN0ZWRPcHRpb25cIjogWzEwNDBdLFxuICAgIFwid2lkdGhcIjogWzUxM10sXG4gICAgXCJzZXRGb2N1c1wiOiBbNjRdXG4gIH0sIFtbMCwgXCJjYWxjaXRlSW50ZXJuYWxPcHRpb25DaGFuZ2VcIiwgXCJoYW5kbGVPcHRpb25Pckdyb3VwQ2hhbmdlXCJdLCBbMCwgXCJjYWxjaXRlSW50ZXJuYWxPcHRpb25Hcm91cENoYW5nZVwiLCBcImhhbmRsZU9wdGlvbk9yR3JvdXBDaGFuZ2VcIl1dXSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50JDEkMigpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiY2FsY2l0ZS1zZWxlY3RcIiwgXCJjYWxjaXRlLWljb25cIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtc2VsZWN0XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgU2VsZWN0KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjYWxjaXRlLWljb25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQkOCgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5kZWZpbmVDdXN0b21FbGVtZW50JDEkMigpO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG5jb25zdCBvcHRpb25Dc3MgPSBcIkBrZXlmcmFtZXMgaW57MCV7b3BhY2l0eTowfTEwMCV7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGluLWRvd257MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAtNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tdXB7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCA1cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi1zY2FsZXswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM0QoMC45NSwgMC45NSwgMSl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM0QoMSwgMSwgMSl9fTpyb290ey0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nOmNhbGMoMTUwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6dmFyKC0tY2FsY2l0ZS1kdXJhdGlvbi1mYWN0b3IsIDEpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3Q6Y2FsYygxMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtOmNhbGMoMjAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3c6Y2FsYygzMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSl9LmNhbGNpdGUtYW5pbWF0ZXtvcGFjaXR5OjA7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO2FuaW1hdGlvbi1kdXJhdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpfS5jYWxjaXRlLWFuaW1hdGVfX2lue2FuaW1hdGlvbi1uYW1lOmlufS5jYWxjaXRlLWFuaW1hdGVfX2luLWRvd257YW5pbWF0aW9uLW5hbWU6aW4tZG93bn0uY2FsY2l0ZS1hbmltYXRlX19pbi11cHthbmltYXRpb24tbmFtZTppbi11cH0uY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZXthbmltYXRpb24tbmFtZTppbi1zY2FsZX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7OnJvb3R7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcjowfX06cm9vdHstLWNhbGNpdGUtZmxvYXRpbmctdWktdHJhbnNpdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpOy0tY2FsY2l0ZS1mbG9hdGluZy11aS16LWluZGV4OjYwMH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfTpob3N0e2Rpc3BsYXk6YmxvY2t9XCI7XG5cbmNvbnN0IE9wdGlvbiA9IC8qQF9fUFVSRV9fKi8gcHJveHlDdXN0b21FbGVtZW50KGNsYXNzIGV4dGVuZHMgSCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbE9wdGlvbkNoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2FsY2l0ZUludGVybmFsT3B0aW9uQ2hhbmdlXCIsIDYpO1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKFwibXV0YXRpb25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5lbnN1cmVUZXh0Q29udGVudERlcGVuZGVudFByb3BzKCk7XG4gICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbE9wdGlvbkNoYW5nZS5lbWl0KCk7XG4gICAgfSk7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGhhbmRsZVByb3BDaGFuZ2UoX25ld1ZhbHVlLCBfb2xkVmFsdWUsIHByb3BOYW1lKSB7XG4gICAgaWYgKHByb3BOYW1lID09PSBcImxhYmVsXCIgfHwgcHJvcE5hbWUgPT09IFwidmFsdWVcIikge1xuICAgICAgdGhpcy5lbnN1cmVUZXh0Q29udGVudERlcGVuZGVudFByb3BzKCk7XG4gICAgfVxuICAgIHRoaXMuY2FsY2l0ZUludGVybmFsT3B0aW9uQ2hhbmdlLmVtaXQoKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBlbnN1cmVUZXh0Q29udGVudERlcGVuZGVudFByb3BzKCkge1xuICAgIGNvbnN0IHsgZWw6IHsgdGV4dENvbnRlbnQgfSB9ID0gdGhpcztcbiAgICBpZiAoIXRoaXMubGFiZWwgfHwgdGhpcy5sYWJlbCA9PT0gdGhpcy5pbnRlcm5hbGx5U2V0TGFiZWwpIHtcbiAgICAgIHRoaXMubGFiZWwgPSB0ZXh0Q29udGVudDtcbiAgICAgIHRoaXMuaW50ZXJuYWxseVNldExhYmVsID0gdGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIGlmICghdGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSB0aGlzLmludGVybmFsbHlTZXRWYWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgICAgdGhpcy5pbnRlcm5hbGx5U2V0VmFsdWUgPSB0ZXh0Q29udGVudDtcbiAgICB9XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5lbnN1cmVUZXh0Q29udGVudERlcGVuZGVudFByb3BzKCk7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyPy5vYnNlcnZlKHRoaXMuZWwsIHtcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wibGFiZWxcIiwgXCJ2YWx1ZVwiXSxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGgoXCJzbG90XCIsIG51bGwsIHRoaXMubGFiZWwpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcImRpc2FibGVkXCI6IFtcImhhbmRsZVByb3BDaGFuZ2VcIl0sXG4gICAgXCJsYWJlbFwiOiBbXCJoYW5kbGVQcm9wQ2hhbmdlXCJdLFxuICAgIFwic2VsZWN0ZWRcIjogW1wiaGFuZGxlUHJvcENoYW5nZVwiXSxcbiAgICBcInZhbHVlXCI6IFtcImhhbmRsZVByb3BDaGFuZ2VcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gb3B0aW9uQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLW9wdGlvblwiLCB7XG4gICAgXCJkaXNhYmxlZFwiOiBbNTE2XSxcbiAgICBcImxhYmVsXCI6IFsxMDI1XSxcbiAgICBcInNlbGVjdGVkXCI6IFs1MTZdLFxuICAgIFwidmFsdWVcIjogWzEwMzJdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSQxKCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJjYWxjaXRlLW9wdGlvblwiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiY2FsY2l0ZS1vcHRpb25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBPcHRpb24pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5kZWZpbmVDdXN0b21FbGVtZW50JDEkMSgpO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuY29uc3QgZGVjaW1hbFBsYWNlcyA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IChcIlwiICsgdmFsdWUpLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KDAsIFxuICAvLyBOdW1iZXIgb2YgZGlnaXRzIHJpZ2h0IG9mIGRlY2ltYWwgcG9pbnQuXG4gIChtYXRjaFsxXSA/IG1hdGNoWzFdLmxlbmd0aCA6IDApIC1cbiAgICAvLyBBZGp1c3QgZm9yIHNjaWVudGlmaWMgbm90YXRpb24uXG4gICAgKG1hdGNoWzJdID8gK21hdGNoWzJdIDogMCkpO1xufTtcblxuLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cblxuY29uc3QgcHJvZ3Jlc3NDc3MgPSBcIkBrZXlmcmFtZXMgaW57MCV7b3BhY2l0eTowfTEwMCV7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIGluLWRvd257MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAtNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tdXB7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCA1cHgsIDApfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGUzRCgwLCAwLCAwKX19QGtleWZyYW1lcyBpbi1zY2FsZXswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM0QoMC45NSwgMC45NSwgMSl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM0QoMSwgMSwgMSl9fTpyb290ey0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nOmNhbGMoMTUwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6dmFyKC0tY2FsY2l0ZS1kdXJhdGlvbi1mYWN0b3IsIDEpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLWZhc3Q6Y2FsYygxMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSk7LS1jYWxjaXRlLWludGVybmFsLWFuaW1hdGlvbi10aW1pbmctbWVkaXVtOmNhbGMoMjAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLXNsb3c6Y2FsYygzMDBtcyAqIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yKSl9LmNhbGNpdGUtYW5pbWF0ZXtvcGFjaXR5OjA7YW5pbWF0aW9uLWZpbGwtbW9kZTpib3RoO2FuaW1hdGlvbi1kdXJhdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpfS5jYWxjaXRlLWFuaW1hdGVfX2lue2FuaW1hdGlvbi1uYW1lOmlufS5jYWxjaXRlLWFuaW1hdGVfX2luLWRvd257YW5pbWF0aW9uLW5hbWU6aW4tZG93bn0uY2FsY2l0ZS1hbmltYXRlX19pbi11cHthbmltYXRpb24tbmFtZTppbi11cH0uY2FsY2l0ZS1hbmltYXRlX19pbi1zY2FsZXthbmltYXRpb24tbmFtZTppbi1zY2FsZX1AbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSl7OnJvb3R7LS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcjowfX06cm9vdHstLWNhbGNpdGUtZmxvYXRpbmctdWktdHJhbnNpdGlvbjp2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpOy0tY2FsY2l0ZS1mbG9hdGluZy11aS16LWluZGV4OjYwMH06aG9zdChbaGlkZGVuXSl7ZGlzcGxheTpub25lfTpob3N0e3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7aW5saW5lLXNpemU6MTAwJX0udHJhY2ssLmJhcntwb3NpdGlvbjphYnNvbHV0ZTtpbnNldC1ibG9jay1zdGFydDowcHg7YmxvY2stc2l6ZToycHh9LnRyYWNre3otaW5kZXg6MTtpbmxpbmUtc2l6ZToxMDAlO292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kOnZhcigtLWNhbGNpdGUtdWktYm9yZGVyLTMpfS5iYXJ7ei1pbmRleDoxO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1icmFuZCl9QG1lZGlhIChmb3JjZWQtY29sb3JzOiBhY3RpdmUpey50cmFja3tiYWNrZ3JvdW5kLWNvbG9yOmhpZ2hsaWdodFRleHR9LmJhcntiYWNrZ3JvdW5kLWNvbG9yOmxpbmtUZXh0fX0uaW5kZXRlcm1pbmF0ZXtpbmxpbmUtc2l6ZToyMCU7YW5pbWF0aW9uOmxvb3BpbmctcHJvZ3Jlc3MtYmFyLWFuaSBjYWxjKHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1tZWRpdW0pICogMTEpIGxpbmVhciBpbmZpbml0ZX0ucmV2ZXJzZWR7YW5pbWF0aW9uLWRpcmVjdGlvbjpyZXZlcnNlfS50ZXh0e3BhZGRpbmctaW5saW5lOjBweDtwYWRkaW5nLWJsb2NrOjFyZW0gMHB4O3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMik7bGluZS1oZWlnaHQ6MXJlbTtmb250LXdlaWdodDp2YXIoLS1jYWxjaXRlLWZvbnQtd2VpZ2h0LW1lZGl1bSk7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTIpfUBrZXlmcmFtZXMgbG9vcGluZy1wcm9ncmVzcy1iYXItYW5pezAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCl9NTAle2lubGluZS1zaXplOjQwJX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGUzZCg2MDAlLCAwLCAwKX19XCI7XG5cbmNvbnN0IFByb2dyZXNzID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMudHlwZSA9IFwiZGV0ZXJtaW5hdGVcIjtcbiAgICB0aGlzLnZhbHVlID0gMDtcbiAgICB0aGlzLmxhYmVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJldmVyc2VkID0gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGlzRGV0ZXJtaW5hdGUgPSB0aGlzLnR5cGUgPT09IFwiZGV0ZXJtaW5hdGVcIjtcbiAgICBjb25zdCBiYXJTdHlsZXMgPSBpc0RldGVybWluYXRlID8geyB3aWR0aDogYCR7dGhpcy52YWx1ZSAqIDEwMH0lYCB9IDoge307XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsXCI6IHRoaXMubGFiZWwgfHwgdGhpcy50ZXh0LCBcImFyaWEtdmFsdWVtYXhcIjogMSwgXCJhcmlhLXZhbHVlbWluXCI6IDAsIFwiYXJpYS12YWx1ZW5vd1wiOiB0aGlzLnZhbHVlLCByb2xlOiBcInByb2dyZXNzYmFyXCIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInRyYWNrXCIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiB7XG4gICAgICAgIGJhcjogdHJ1ZSxcbiAgICAgICAgaW5kZXRlcm1pbmF0ZTogdGhpcy50eXBlID09PSBcImluZGV0ZXJtaW5hdGVcIixcbiAgICAgICAgcmV2ZXJzZWQ6IHRoaXMucmV2ZXJzZWRcbiAgICAgIH0sIHN0eWxlOiBiYXJTdHlsZXMgfSkpLCB0aGlzLnRleHQgPyBoKFwiZGl2XCIsIHsgY2xhc3M6IFwidGV4dFwiIH0sIHRoaXMudGV4dCkgOiBudWxsKSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gcHJvZ3Jlc3NDc3M7IH1cbn0sIFsxLCBcImNhbGNpdGUtcHJvZ3Jlc3NcIiwge1xuICAgIFwidHlwZVwiOiBbNTEzXSxcbiAgICBcInZhbHVlXCI6IFsyXSxcbiAgICBcImxhYmVsXCI6IFsxXSxcbiAgICBcInRleHRcIjogWzFdLFxuICAgIFwicmV2ZXJzZWRcIjogWzUxNl1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiY2FsY2l0ZS1wcm9ncmVzc1wiXTtcbiAgY29tcG9uZW50cy5mb3JFYWNoKHRhZ05hbWUgPT4geyBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiY2FsY2l0ZS1wcm9ncmVzc1wiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIFByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuXG5jb25zdCBDU1MgPSB7XG4gIGxvYWRlcjogXCJsb2FkZXJcIixcbiAgY2xlYXJCdXR0b246IFwiY2xlYXItYnV0dG9uXCIsXG4gIGVkaXRpbmdFbmFibGVkOiBcImVkaXRpbmctZW5hYmxlZFwiLFxuICBpbmxpbmVDaGlsZDogXCJpbmxpbmUtY2hpbGRcIixcbiAgaW5wdXRJY29uOiBcImljb25cIixcbiAgcHJlZml4OiBcInByZWZpeFwiLFxuICBzdWZmaXg6IFwic3VmZml4XCIsXG4gIG51bWJlckJ1dHRvbldyYXBwZXI6IFwibnVtYmVyLWJ1dHRvbi13cmFwcGVyXCIsXG4gIGJ1dHRvbkl0ZW1Ib3Jpem9udGFsOiBcIm51bWJlci1idXR0b24taXRlbS0taG9yaXpvbnRhbFwiLFxuICB3cmFwcGVyOiBcImVsZW1lbnQtd3JhcHBlclwiLFxuICBpbnB1dFdyYXBwZXI6IFwid3JhcHBlclwiLFxuICBhY3Rpb25XcmFwcGVyOiBcImFjdGlvbi13cmFwcGVyXCIsXG4gIHJlc2l6ZUljb25XcmFwcGVyOiBcInJlc2l6ZS1pY29uLXdyYXBwZXJcIixcbiAgbnVtYmVyQnV0dG9uSXRlbTogXCJudW1iZXItYnV0dG9uLWl0ZW1cIlxufTtcbmNvbnN0IFNMT1RTID0ge1xuICBhY3Rpb246IFwiYWN0aW9uXCJcbn07XG5cbmNvbnN0IGlucHV0TnVtYmVyQ3NzID0gXCJAa2V5ZnJhbWVzIGluezAle29wYWNpdHk6MH0xMDAle29wYWNpdHk6MX19QGtleWZyYW1lcyBpbi1kb3duezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgLTVweCwgMCl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDAsIDApfX1Aa2V5ZnJhbWVzIGluLXVwezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tc2NhbGV7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNEKDAuOTUsIDAuOTUsIDEpfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNEKDEsIDEsIDEpfX06cm9vdHstLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZzpjYWxjKDE1MG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yOnZhcigtLWNhbGNpdGUtZHVyYXRpb24tZmFjdG9yLCAxKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1mYXN0OmNhbGMoMTAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLW1lZGl1bTpjYWxjKDIwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1zbG93OmNhbGMoMzAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpfS5jYWxjaXRlLWFuaW1hdGV7b3BhY2l0eTowO2FuaW1hdGlvbi1maWxsLW1vZGU6Ym90aDthbmltYXRpb24tZHVyYXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKX0uY2FsY2l0ZS1hbmltYXRlX19pbnthbmltYXRpb24tbmFtZTppbn0uY2FsY2l0ZS1hbmltYXRlX19pbi1kb3due2FuaW1hdGlvbi1uYW1lOmluLWRvd259LmNhbGNpdGUtYW5pbWF0ZV9faW4tdXB7YW5pbWF0aW9uLW5hbWU6aW4tdXB9LmNhbGNpdGUtYW5pbWF0ZV9faW4tc2NhbGV7YW5pbWF0aW9uLW5hbWU6aW4tc2NhbGV9QG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2Upezpyb290ey0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6MH19OnJvb3R7LS1jYWxjaXRlLWZsb2F0aW5nLXVpLXRyYW5zaXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKTstLWNhbGNpdGUtZmxvYXRpbmctdWktei1pbmRleDo2MDB9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX06aG9zdChbZGlzYWJsZWRdKXtwb2ludGVyLWV2ZW50czpub25lO2N1cnNvcjpkZWZhdWx0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO29wYWNpdHk6dmFyKC0tY2FsY2l0ZS11aS1vcGFjaXR5LWRpc2FibGVkKX06aG9zdHtkaXNwbGF5OmJsb2NrfTpob3N0KFtzY2FsZT1zXSkgaW5wdXQsOmhvc3QoW3NjYWxlPXNdKSAucHJlZml4LDpob3N0KFtzY2FsZT1zXSkgLnN1ZmZpeHtibG9jay1zaXplOjEuNXJlbTtwYWRkaW5nLWlubGluZTowLjVyZW07Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtsaW5lLWhlaWdodDoxcmVtfTpob3N0KFtzY2FsZT1zXSkgLm51bWJlci1idXR0b24td3JhcHBlciw6aG9zdChbc2NhbGU9c10pIC5hY3Rpb24td3JhcHBlciBjYWxjaXRlLWJ1dHRvbiw6aG9zdChbc2NhbGU9c10pIC5hY3Rpb24td3JhcHBlciBjYWxjaXRlLWJ1dHRvbiBidXR0b257YmxvY2stc2l6ZToxLjVyZW19Omhvc3QoW3NjYWxlPXNdKSAuY2xlYXItYnV0dG9ue21pbi1ibG9jay1zaXplOjEuNXJlbTttaW4taW5saW5lLXNpemU6MS41cmVtfTpob3N0KFtzY2FsZT1tXSkgaW5wdXQsOmhvc3QoW3NjYWxlPW1dKSAucHJlZml4LDpob3N0KFtzY2FsZT1tXSkgLnN1ZmZpeHtibG9jay1zaXplOjJyZW07cGFkZGluZy1pbmxpbmU6MC43NXJlbTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTEpO2xpbmUtaGVpZ2h0OjFyZW19Omhvc3QoW3NjYWxlPW1dKSAubnVtYmVyLWJ1dHRvbi13cmFwcGVyLDpob3N0KFtzY2FsZT1tXSkgLmFjdGlvbi13cmFwcGVyIGNhbGNpdGUtYnV0dG9uLDpob3N0KFtzY2FsZT1tXSkgLmFjdGlvbi13cmFwcGVyIGNhbGNpdGUtYnV0dG9uIGJ1dHRvbntibG9jay1zaXplOjJyZW19Omhvc3QoW3NjYWxlPW1dKSAuY2xlYXItYnV0dG9ue21pbi1ibG9jay1zaXplOjJyZW07bWluLWlubGluZS1zaXplOjJyZW19Omhvc3QoW3NjYWxlPWxdKSBpbnB1dCw6aG9zdChbc2NhbGU9bF0pIC5wcmVmaXgsOmhvc3QoW3NjYWxlPWxdKSAuc3VmZml4e2Jsb2NrLXNpemU6Mi43NXJlbTtwYWRkaW5nLWlubGluZToxcmVtO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0wKTtsaW5lLWhlaWdodDoxLjI1cmVtfTpob3N0KFtzY2FsZT1sXSkgLm51bWJlci1idXR0b24td3JhcHBlciw6aG9zdChbc2NhbGU9bF0pIC5hY3Rpb24td3JhcHBlciBjYWxjaXRlLWJ1dHRvbiw6aG9zdChbc2NhbGU9bF0pIC5hY3Rpb24td3JhcHBlciBjYWxjaXRlLWJ1dHRvbiBidXR0b257YmxvY2stc2l6ZToyLjc1cmVtfTpob3N0KFtzY2FsZT1sXSkgLmNsZWFyLWJ1dHRvbnttaW4tYmxvY2stc2l6ZToyLjc1cmVtO21pbi1pbmxpbmUtc2l6ZToyLjc1cmVtfTpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRdKSw6aG9zdChbZGlzYWJsZWRdKSBbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRde29wYWNpdHk6MX06aG9zdCBpbnB1dHt0cmFuc2l0aW9uOnZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZyksIGJsb2NrLXNpemUgMCwgb3V0bGluZS1vZmZzZXQgMHM7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luOjBweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O21heC1ibG9jay1zaXplOjEwMCU7aW5saW5lLXNpemU6MTAwJTttYXgtaW5saW5lLXNpemU6MTAwJTtmbGV4OjEgMSAwJTtib3JkZXItcmFkaXVzOjBweDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKTtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtd2VpZ2h0OnZhcigtLWNhbGNpdGUtZm9udC13ZWlnaHQtbm9ybWFsKTtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItaW5wdXQpO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKX06aG9zdCBpbnB1dDo6cGxhY2Vob2xkZXIsOmhvc3QgaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyLDpob3N0IGlucHV0OjotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Zm9udC13ZWlnaHQ6dmFyKC0tY2FsY2l0ZS1mb250LXdlaWdodC1ub3JtYWwpO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0zKX06aG9zdCBpbnB1dDpmb2N1c3tib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpfTpob3N0IGlucHV0W3JlYWRvbmx5XXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktYmFja2dyb3VuZCk7Zm9udC13ZWlnaHQ6dmFyKC0tY2FsY2l0ZS1mb250LXdlaWdodC1tZWRpdW0pfTpob3N0IGlucHV0W3JlYWRvbmx5XTpmb2N1c3tjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMSl9Omhvc3QgY2FsY2l0ZS1pY29ue2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0zKX06aG9zdCBpbnB1dHtvdXRsaW5lLWNvbG9yOnRyYW5zcGFyZW50fTpob3N0IGlucHV0OmZvY3Vze291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO291dGxpbmUtb2Zmc2V0Oi0ycHh9Omhvc3QoW3N0YXR1cz1pbnZhbGlkXSkgaW5wdXR7Ym9yZGVyLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZGFuZ2VyKX06aG9zdChbc3RhdHVzPWludmFsaWRdKSBpbnB1dDpmb2N1c3tvdXRsaW5lOjJweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWRhbmdlcik7b3V0bGluZS1vZmZzZXQ6LTJweH06aG9zdChbc2NhbGU9c10pIC5pY29ue2luc2V0LWlubGluZS1zdGFydDowLjVyZW19Omhvc3QoW3NjYWxlPW1dKSAuaWNvbntpbnNldC1pbmxpbmUtc3RhcnQ6MC43NXJlbX06aG9zdChbc2NhbGU9bF0pIC5pY29ue2luc2V0LWlubGluZS1zdGFydDoxcmVtfTpob3N0KFtpY29uXVtzY2FsZT1zXSkgaW5wdXR7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MnJlbX06aG9zdChbaWNvbl1bc2NhbGU9bV0pIGlucHV0e3BhZGRpbmctaW5saW5lLXN0YXJ0OjIuNXJlbX06aG9zdChbaWNvbl1bc2NhbGU9bF0pIGlucHV0e3BhZGRpbmctaW5saW5lLXN0YXJ0OjMuNXJlbX0uZWxlbWVudC13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO29yZGVyOjM7ZGlzcGxheTppbmxpbmUtZmxleDtmbGV4OjEgMSAwJTthbGlnbi1pdGVtczpjZW50ZXJ9Lmljb257cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7ZGlzcGxheTpibG9jazt0cmFuc2l0aW9uOmFsbCB2YXIoLS1jYWxjaXRlLWFuaW1hdGlvbi10aW1pbmcpIGVhc2UtaW4tb3V0IDBzLCBvdXRsaW5lIDBzLCBvdXRsaW5lLW9mZnNldCAwc30uY2xlYXItYnV0dG9ue3BvaW50ZXItZXZlbnRzOmluaXRpYWw7b3JkZXI6NDttYXJnaW46MHB4O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmZsZXg7bWluLWJsb2NrLXNpemU6MTAwJTtjdXJzb3I6cG9pbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1zZWxmOnN0cmV0Y2g7Ym9yZGVyLXdpZHRoOjFweDtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktYm9yZGVyLWlucHV0KTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xKTtvdXRsaW5lLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1pbmxpbmUtc3RhcnQtd2lkdGg6MHB4fS5jbGVhci1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMik7dHJhbnNpdGlvbjphbGwgdmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKSBlYXNlLWluLW91dCAwcywgb3V0bGluZSAwcywgb3V0bGluZS1vZmZzZXQgMHN9LmNsZWFyLWJ1dHRvbjpob3ZlciBjYWxjaXRlLWljb257Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpO3RyYW5zaXRpb246YWxsIHZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZykgZWFzZS1pbi1vdXQgMHMsIG91dGxpbmUgMHMsIG91dGxpbmUtb2Zmc2V0IDBzfS5jbGVhci1idXR0b246YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTMpfS5jbGVhci1idXR0b246YWN0aXZlIGNhbGNpdGUtaWNvbntjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMSl9LmNsZWFyLWJ1dHRvbjpmb2N1c3tvdXRsaW5lOjJweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJyYW5kKTtvdXRsaW5lLW9mZnNldDotMnB4fS5jbGVhci1idXR0b246ZGlzYWJsZWR7b3BhY2l0eTp2YXIoLS1jYWxjaXRlLXVpLW9wYWNpdHktZGlzYWJsZWQpfS5sb2FkZXJ7aW5zZXQtYmxvY2stc3RhcnQ6MXB4O2luc2V0LWlubGluZToxcHg7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrfS5hY3Rpb24td3JhcHBlcntvcmRlcjo3O2Rpc3BsYXk6ZmxleH0ucHJlZml4LC5zdWZmaXh7Ym94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6ZmxleDtibG9jay1zaXplOmF1dG87bWluLWJsb2NrLXNpemU6MTAwJTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTthbGlnbi1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO2JvcmRlci13aWR0aDoxcHg7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci1pbnB1dCk7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJhY2tncm91bmQpO2ZvbnQtd2VpZ2h0OnZhcigtLWNhbGNpdGUtZm9udC13ZWlnaHQtbWVkaXVtKTtsaW5lLWhlaWdodDoxO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0yKX0ucHJlZml4e29yZGVyOjI7Ym9yZGVyLWlubGluZS1lbmQtd2lkdGg6MHB4fS5zdWZmaXh7b3JkZXI6NTtib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoOjBweH06aG9zdChbYWxpZ25tZW50PXN0YXJ0XSkgaW5wdXR7dGV4dC1hbGlnbjpzdGFydH06aG9zdChbYWxpZ25tZW50PWVuZF0pIGlucHV0e3RleHQtYWxpZ246ZW5kfS5udW1iZXItYnV0dG9uLXdyYXBwZXJ7cG9pbnRlci1ldmVudHM6bm9uZTtvcmRlcjo2O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3RyYW5zaXRpb246YWxsIHZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZykgZWFzZS1pbi1vdXQgMHMsIG91dGxpbmUgMHMsIG91dGxpbmUtb2Zmc2V0IDBzfTpob3N0KFtudW1iZXItYnV0dG9uLXR5cGU9dmVydGljYWxdKSAud3JhcHBlcntmbGV4LWRpcmVjdGlvbjpyb3c7ZGlzcGxheTpmbGV4fTpob3N0KFtudW1iZXItYnV0dG9uLXR5cGU9dmVydGljYWxdKSBpbnB1dHtvcmRlcjoyfTpob3N0KFtudW1iZXItYnV0dG9uLXR5cGU9aG9yaXpvbnRhbF0pIC5jYWxjaXRlLS1ydGwgLm51bWJlci1idXR0b24taXRlbVtkYXRhLWFkanVzdG1lbnQ9ZG93bl0gY2FsY2l0ZS1pY29ue3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKX06aG9zdChbbnVtYmVyLWJ1dHRvbi10eXBlPWhvcml6b250YWxdKSAuY2FsY2l0ZS0tcnRsIC5udW1iZXItYnV0dG9uLWl0ZW1bZGF0YS1hZGp1c3RtZW50PXVwXSBjYWxjaXRlLWljb257dHJhbnNmb3JtOnJvdGF0ZSgtOTBkZWcpfS5udW1iZXItYnV0dG9uLWl0ZW0ubnVtYmVyLWJ1dHRvbi1pdGVtLS1ob3Jpem9udGFsW2RhdGEtYWRqdXN0bWVudD1kb3duXSwubnVtYmVyLWJ1dHRvbi1pdGVtLm51bWJlci1idXR0b24taXRlbS0taG9yaXpvbnRhbFtkYXRhLWFkanVzdG1lbnQ9dXBde29yZGVyOjE7bWF4LWJsb2NrLXNpemU6MTAwJTttaW4tYmxvY2stc2l6ZToxMDAlO2FsaWduLXNlbGY6c3RyZXRjaH0ubnVtYmVyLWJ1dHRvbi1pdGVtLm51bWJlci1idXR0b24taXRlbS0taG9yaXpvbnRhbFtkYXRhLWFkanVzdG1lbnQ9ZG93bl0gY2FsY2l0ZS1pY29uLC5udW1iZXItYnV0dG9uLWl0ZW0ubnVtYmVyLWJ1dHRvbi1pdGVtLS1ob3Jpem9udGFsW2RhdGEtYWRqdXN0bWVudD11cF0gY2FsY2l0ZS1pY29ue3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfS5udW1iZXItYnV0dG9uLWl0ZW0ubnVtYmVyLWJ1dHRvbi1pdGVtLS1ob3Jpem9udGFsW2RhdGEtYWRqdXN0bWVudD1kb3duXXtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItaW5wdXQpO2JvcmRlci1pbmxpbmUtZW5kLXdpZHRoOjBweH0ubnVtYmVyLWJ1dHRvbi1pdGVtLm51bWJlci1idXR0b24taXRlbS0taG9yaXpvbnRhbFtkYXRhLWFkanVzdG1lbnQ9ZG93bl06aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMil9Lm51bWJlci1idXR0b24taXRlbS5udW1iZXItYnV0dG9uLWl0ZW0tLWhvcml6b250YWxbZGF0YS1hZGp1c3RtZW50PWRvd25dOmhvdmVyIGNhbGNpdGUtaWNvbntjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMSl9Lm51bWJlci1idXR0b24taXRlbS5udW1iZXItYnV0dG9uLWl0ZW0tLWhvcml6b250YWxbZGF0YS1hZGp1c3RtZW50PXVwXXtvcmRlcjo1fS5udW1iZXItYnV0dG9uLWl0ZW0ubnVtYmVyLWJ1dHRvbi1pdGVtLS1ob3Jpem9udGFsW2RhdGEtYWRqdXN0bWVudD11cF06aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMil9Lm51bWJlci1idXR0b24taXRlbS5udW1iZXItYnV0dG9uLWl0ZW0tLWhvcml6b250YWxbZGF0YS1hZGp1c3RtZW50PXVwXTpob3ZlciBjYWxjaXRlLWljb257Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTEpfTpob3N0KFtudW1iZXItYnV0dG9uLXR5cGU9dmVydGljYWxdKSAubnVtYmVyLWJ1dHRvbi1pdGVtW2RhdGEtYWRqdXN0bWVudD1kb3duXTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0yKX06aG9zdChbbnVtYmVyLWJ1dHRvbi10eXBlPXZlcnRpY2FsXSkgLm51bWJlci1idXR0b24taXRlbVtkYXRhLWFkanVzdG1lbnQ9ZG93bl06aG92ZXIgY2FsY2l0ZS1pY29ue2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKX06aG9zdChbbnVtYmVyLWJ1dHRvbi10eXBlPXZlcnRpY2FsXSkgLm51bWJlci1idXR0b24taXRlbVtkYXRhLWFkanVzdG1lbnQ9dXBdOmhvdmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTIpfTpob3N0KFtudW1iZXItYnV0dG9uLXR5cGU9dmVydGljYWxdKSAubnVtYmVyLWJ1dHRvbi1pdGVtW2RhdGEtYWRqdXN0bWVudD11cF06aG92ZXIgY2FsY2l0ZS1pY29ue2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKX06aG9zdChbbnVtYmVyLWJ1dHRvbi10eXBlPXZlcnRpY2FsXSkgLm51bWJlci1idXR0b24taXRlbVtkYXRhLWFkanVzdG1lbnQ9ZG93bl17Ym9yZGVyLWJsb2NrLXN0YXJ0LXdpZHRoOjBweH0ubnVtYmVyLWJ1dHRvbi1pdGVte21heC1ibG9jay1zaXplOjUwJTttaW4tYmxvY2stc2l6ZTo1MCU7cG9pbnRlci1ldmVudHM6aW5pdGlhbDttYXJnaW46MHB4O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmZsZXg7Y3Vyc29yOnBvaW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2FsaWduLXNlbGY6Y2VudGVyO2JvcmRlci13aWR0aDoxcHg7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci1pbnB1dCk7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMSk7cGFkZGluZy1ibG9jazowcHg7cGFkZGluZy1pbmxpbmU6MC41cmVtO3RyYW5zaXRpb246YWxsIHZhcigtLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZykgZWFzZS1pbi1vdXQgMHMsIG91dGxpbmUgMHMsIG91dGxpbmUtb2Zmc2V0IDBzO2JvcmRlci1pbmxpbmUtc3RhcnQtd2lkdGg6MHB4fS5udW1iZXItYnV0dG9uLWl0ZW0gY2FsY2l0ZS1pY29ue3BvaW50ZXItZXZlbnRzOm5vbmU7dHJhbnNpdGlvbjphbGwgdmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKSBlYXNlLWluLW91dCAwcywgb3V0bGluZSAwcywgb3V0bGluZS1vZmZzZXQgMHN9Lm51bWJlci1idXR0b24taXRlbTpmb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0yKX0ubnVtYmVyLWJ1dHRvbi1pdGVtOmZvY3VzIGNhbGNpdGUtaWNvbntjb2xvcjp2YXIoLS1jYWxjaXRlLXVpLXRleHQtMSl9Lm51bWJlci1idXR0b24taXRlbTphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMyl9Lm51bWJlci1idXR0b24taXRlbTpkaXNhYmxlZHtwb2ludGVyLWV2ZW50czpub25lfS53cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7YWxpZ24taXRlbXM6Y2VudGVyfTpob3N0KC5uby1ib3R0b20tYm9yZGVyKSBpbnB1dHtib3JkZXItYmxvY2stZW5kLXdpZHRoOjBweH06aG9zdCguYm9yZGVyLXRvcC1jb2xvci1vbmUpIGlucHV0e2JvcmRlci1ibG9jay1zdGFydC1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0xKX06aG9zdCAuaW5saW5lLWNoaWxke2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7dHJhbnNpdGlvbjphbGwgdmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKSBlYXNlLWluLW91dCAwcywgb3V0bGluZSAwcywgb3V0bGluZS1vZmZzZXQgMHN9Omhvc3QgLmlubGluZS1jaGlsZCAuZWRpdGluZy1lbmFibGVke2JhY2tncm91bmQtY29sb3I6aW5oZXJpdH06aG9zdCAuaW5saW5lLWNoaWxkOm5vdCguZWRpdGluZy1lbmFibGVkKXtkaXNwbGF5OmZsZXg7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O3BhZGRpbmctaW5saW5lLXN0YXJ0OjB9OjpzbG90dGVkKGlucHV0W3Nsb3Q9aGlkZGVuLWZvcm0taW5wdXRdKXttYXJnaW46MCAhaW1wb3J0YW50O29wYWNpdHk6MCAhaW1wb3J0YW50O291dGxpbmU6bm9uZSAhaW1wb3J0YW50O3BhZGRpbmc6MCAhaW1wb3J0YW50O3Bvc2l0aW9uOmFic29sdXRlICFpbXBvcnRhbnQ7aW5zZXQ6MCAhaW1wb3J0YW50O3RyYW5zZm9ybTpub25lICFpbXBvcnRhbnQ7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmUgIWltcG9ydGFudDt6LWluZGV4Oi0xICFpbXBvcnRhbnR9XCI7XG5cbmNvbnN0IElucHV0TnVtYmVyID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuY2FsY2l0ZUludGVybmFsSW5wdXROdW1iZXJGb2N1cyA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2FsY2l0ZUludGVybmFsSW5wdXROdW1iZXJGb2N1c1wiLCA2KTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbElucHV0TnVtYmVyQmx1ciA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2FsY2l0ZUludGVybmFsSW5wdXROdW1iZXJCbHVyXCIsIDYpO1xuICAgIHRoaXMuY2FsY2l0ZUlucHV0TnVtYmVySW5wdXQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVJbnB1dE51bWJlcklucHV0XCIsIDcpO1xuICAgIHRoaXMuY2FsY2l0ZUlucHV0TnVtYmVyQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlSW5wdXROdW1iZXJDaGFuZ2VcIiwgNik7XG4gICAgdGhpcy5wcmV2aW91c1ZhbHVlT3JpZ2luID0gXCJpbml0aWFsXCI7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIoXCJtdXRhdGlvblwiLCAoKSA9PiB0aGlzLnNldERpc2FibGVkQWN0aW9uKCkpO1xuICAgIHRoaXMudXNlckNoYW5nZWRWYWx1ZSA9IGZhbHNlO1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLmtleURvd25IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFkT25seSB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2xlYXJhYmxlICYmIGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICB0aGlzLmNsZWFySW5wdXRWYWx1ZShldmVudCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgaWYgKHN1Ym1pdEZvcm0odGhpcykpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNsZWFySW5wdXRWYWx1ZSA9IChuYXRpdmVFdmVudCkgPT4ge1xuICAgICAgdGhpcy5zZXROdW1iZXJWYWx1ZSh7XG4gICAgICAgIGNvbW1pdHRpbmc6IHRydWUsXG4gICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICBvcmlnaW46IFwidXNlclwiLFxuICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmVtaXRDaGFuZ2VJZlVzZXJNb2RpZmllZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnByZXZpb3VzVmFsdWVPcmlnaW4gPT09IFwidXNlclwiICYmIHRoaXMudmFsdWUgIT09IHRoaXMucHJldmlvdXNFbWl0dGVkTnVtYmVyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWxjaXRlSW5wdXROdW1iZXJDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB0aGlzLnNldFByZXZpb3VzRW1pdHRlZE51bWJlclZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnB1dE51bWJlckJsdXJIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxJbnB1dE51bWJlckJsdXIuZW1pdCgpO1xuICAgICAgdGhpcy5lbWl0Q2hhbmdlSWZVc2VyTW9kaWZpZWQoKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBzbG90dGVkQWN0aW9uRWwgPSBnZXRTbG90dGVkKHRoaXMuZWwsIFwiYWN0aW9uXCIpO1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gc2xvdHRlZEFjdGlvbkVsKSB7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaW5wdXROdW1iZXJGb2N1c0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbElucHV0TnVtYmVyRm9jdXMuZW1pdCgpO1xuICAgIH07XG4gICAgdGhpcy5pbnB1dE51bWJlcklucHV0SGFuZGxlciA9IChuYXRpdmVFdmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkT25seSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgIG51bWJlclN0cmluZ0Zvcm1hdHRlci5udW1iZXJGb3JtYXRPcHRpb25zID0ge1xuICAgICAgICBsb2NhbGU6IHRoaXMuZWZmZWN0aXZlTG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICB1c2VHcm91cGluZzogdGhpcy5ncm91cFNlcGFyYXRvclxuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlbG9jYWxpemVkVmFsdWUgPSBudW1iZXJTdHJpbmdGb3JtYXR0ZXIuZGVsb2NhbGl6ZSh2YWx1ZSk7XG4gICAgICBpZiAobmF0aXZlRXZlbnQuaW5wdXRUeXBlID09PSBcImluc2VydEZyb21QYXN0ZVwiKSB7XG4gICAgICAgIGlmICghaXNWYWxpZE51bWJlcihkZWxvY2FsaXplZFZhbHVlKSkge1xuICAgICAgICAgIG5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXROdW1iZXJWYWx1ZSh7XG4gICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgb3JpZ2luOiBcInVzZXJcIixcbiAgICAgICAgICB2YWx1ZTogcGFyc2VOdW1iZXJTdHJpbmcoZGVsb2NhbGl6ZWRWYWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hpbGROdW1iZXJFbC52YWx1ZSA9IHRoaXMubG9jYWxpemVkVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXROdW1iZXJWYWx1ZSh7XG4gICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgb3JpZ2luOiBcInVzZXJcIixcbiAgICAgICAgICB2YWx1ZTogZGVsb2NhbGl6ZWRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaW5wdXROdW1iZXJLZXlEb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkT25seSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikge1xuICAgICAgICAvKiBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb2YgbW92aW5nIGN1cnNvciB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dCB3aGVuIGhvbGRpbmcgZG93biBBcnJvd1VwICovXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubnVkZ2VOdW1iZXJWYWx1ZShcInVwXCIsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0Rvd25cIikge1xuICAgICAgICB0aGlzLm51ZGdlTnVtYmVyVmFsdWUoXCJkb3duXCIsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VwcG9ydGVkS2V5cyA9IFtcbiAgICAgICAgLi4ubnVtYmVyS2V5cyxcbiAgICAgICAgXCJBcnJvd0xlZnRcIixcbiAgICAgICAgXCJBcnJvd1JpZ2h0XCIsXG4gICAgICAgIFwiQmFja3NwYWNlXCIsXG4gICAgICAgIFwiRGVsZXRlXCIsXG4gICAgICAgIFwiRW50ZXJcIixcbiAgICAgICAgXCJFc2NhcGVcIixcbiAgICAgICAgXCJUYWJcIlxuICAgICAgXTtcbiAgICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU2hpZnRUYWJFdmVudCA9IGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSA9PT0gXCJUYWJcIjtcbiAgICAgIGlmIChzdXBwb3J0ZWRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgKCFldmVudC5zaGlmdEtleSB8fCBpc1NoaWZ0VGFiRXZlbnQpKSB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIHRoaXMuZW1pdENoYW5nZUlmVXNlck1vZGlmaWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbnVtYmVyU3RyaW5nRm9ybWF0dGVyLm51bWJlckZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICAgIGxvY2FsZTogdGhpcy5lZmZlY3RpdmVMb2NhbGUsXG4gICAgICAgIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIHVzZUdyb3VwaW5nOiB0aGlzLmdyb3VwU2VwYXJhdG9yXG4gICAgICB9O1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gbnVtYmVyU3RyaW5nRm9ybWF0dGVyLmRlY2ltYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlICYmICF0aGlzLmNoaWxkTnVtYmVyRWwudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgJiYgdGhpcy5jaGlsZE51bWJlckVsLnZhbHVlLmluZGV4T2YobnVtYmVyU3RyaW5nRm9ybWF0dGVyLmRlY2ltYWwpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKC9bZUVdLy50ZXN0KGV2ZW50LmtleSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlICYmICF0aGlzLmNoaWxkTnVtYmVyRWwudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgJiYgIS9bZUVdLy50ZXN0KHRoaXMuY2hpbGROdW1iZXJFbC52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXkgPT09IFwiLVwiKSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSAmJiAhdGhpcy5jaGlsZE51bWJlckVsLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICYmIHRoaXMuY2hpbGROdW1iZXJFbC52YWx1ZS5zcGxpdChcIi1cIikubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICB0aGlzLm51ZGdlTnVtYmVyVmFsdWUgPSAoZGlyZWN0aW9uLCBuYXRpdmVFdmVudCkgPT4ge1xuICAgICAgaWYgKG5hdGl2ZUV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCAmJiBuYXRpdmVFdmVudC5yZXBlYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRNYXggPSB0aGlzLm1heFN0cmluZyA/IHBhcnNlRmxvYXQodGhpcy5tYXhTdHJpbmcpIDogbnVsbDtcbiAgICAgIGNvbnN0IGlucHV0TWluID0gdGhpcy5taW5TdHJpbmcgPyBwYXJzZUZsb2F0KHRoaXMubWluU3RyaW5nKSA6IG51bGw7XG4gICAgICBjb25zdCB2YWx1ZU51ZGdlRGVsYXlJbk1zID0gMTUwO1xuICAgICAgdGhpcy5pbmNyZW1lbnRPckRlY3JlbWVudE51bWJlclZhbHVlKGRpcmVjdGlvbiwgaW5wdXRNYXgsIGlucHV0TWluLCBuYXRpdmVFdmVudCk7XG4gICAgICBpZiAodGhpcy5udWRnZU51bWJlclZhbHVlSW50ZXJ2YWxJZCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLm51ZGdlTnVtYmVyVmFsdWVJbnRlcnZhbElkKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaXJzdFZhbHVlTnVkZ2UgPSB0cnVlO1xuICAgICAgdGhpcy5udWRnZU51bWJlclZhbHVlSW50ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmIChmaXJzdFZhbHVlTnVkZ2UpIHtcbiAgICAgICAgICBmaXJzdFZhbHVlTnVkZ2UgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmNyZW1lbnRPckRlY3JlbWVudE51bWJlclZhbHVlKGRpcmVjdGlvbiwgaW5wdXRNYXgsIGlucHV0TWluLCBuYXRpdmVFdmVudCk7XG4gICAgICB9LCB2YWx1ZU51ZGdlRGVsYXlJbk1zKTtcbiAgICB9O1xuICAgIHRoaXMubnVkZ2VCdXR0b25Qb2ludGVyVXBBbmRPdXRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzUHJpbWFyeVBvaW50ZXJCdXR0b24oZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMubnVkZ2VOdW1iZXJWYWx1ZUludGVydmFsSWQpO1xuICAgIH07XG4gICAgdGhpcy5udWRnZUJ1dHRvblBvaW50ZXJEb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCFpc1ByaW1hcnlQb2ludGVyQnV0dG9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZXZlbnQudGFyZ2V0LmRhdGFzZXQuYWRqdXN0bWVudDtcbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLm51ZGdlTnVtYmVyVmFsdWUoZGlyZWN0aW9uLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhpZGRlbklucHV0Q2hhbmdlSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldC5uYW1lID09PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgdGhpcy5zZXROdW1iZXJWYWx1ZSh7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZSxcbiAgICAgICAgICBvcmlnaW46IFwiZGlyZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0Q2hpbGROdW1iZXJFbFJlZiA9IChlbCkgPT4ge1xuICAgICAgdGhpcy5jaGlsZE51bWJlckVsID0gZWw7XG4gICAgfTtcbiAgICB0aGlzLnNldElucHV0TnVtYmVyVmFsdWUgPSAobmV3SW5wdXRWYWx1ZSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNoaWxkTnVtYmVyRWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZE51bWJlckVsLnZhbHVlID0gbmV3SW5wdXRWYWx1ZTtcbiAgICB9O1xuICAgIHRoaXMuc2V0UHJldmlvdXNFbWl0dGVkTnVtYmVyVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICAgIHRoaXMucHJldmlvdXNFbWl0dGVkTnVtYmVyVmFsdWUgPSB0aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0UHJldmlvdXNOdW1iZXJWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gdGhpcy5ub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldE51bWJlclZhbHVlID0gKHsgY29tbWl0dGluZyA9IGZhbHNlLCBuYXRpdmVFdmVudCwgb3JpZ2luLCBwcmV2aW91c1ZhbHVlLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBudW1iZXJTdHJpbmdGb3JtYXR0ZXIubnVtYmVyRm9ybWF0T3B0aW9ucyA9IHtcbiAgICAgICAgbG9jYWxlOiB0aGlzLmVmZmVjdGl2ZUxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgdXNlR3JvdXBpbmc6IHRoaXMuZ3JvdXBTZXBhcmF0b3JcbiAgICAgIH07XG4gICAgICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IHNhbml0aXplTnVtYmVyU3RyaW5nKFxuICAgICAgLy8gbm8gbmVlZCB0byBkZWxvY2FsaXplIGEgc3RyaW5nIHRoYXQgaWEgYWxyZWFkeSBpbiBsYXRuIG51bWVyYWxzXG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gJiYgdGhpcy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB8fCBkZWZhdWx0TnVtYmVyaW5nU3lzdGVtICE9PSBcImxhdG5cIlxuICAgICAgICA/IG51bWJlclN0cmluZ0Zvcm1hdHRlci5kZWxvY2FsaXplKHZhbHVlKVxuICAgICAgICA6IHZhbHVlKTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgJiYgIXNhbml0aXplZFZhbHVlXG4gICAgICAgID8gaXNWYWxpZE51bWJlcih0aGlzLnByZXZpb3VzVmFsdWUpXG4gICAgICAgICAgPyB0aGlzLnByZXZpb3VzVmFsdWVcbiAgICAgICAgICA6IFwiXCJcbiAgICAgICAgOiBzYW5pdGl6ZWRWYWx1ZTtcbiAgICAgIGNvbnN0IG5ld0xvY2FsaXplZFZhbHVlID0gbnVtYmVyU3RyaW5nRm9ybWF0dGVyLmxvY2FsaXplKG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMubG9jYWxpemVkVmFsdWUgPSBuZXdMb2NhbGl6ZWRWYWx1ZTtcbiAgICAgIHRoaXMuc2V0UHJldmlvdXNOdW1iZXJWYWx1ZShwcmV2aW91c1ZhbHVlID8/IHRoaXMudmFsdWUpO1xuICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlT3JpZ2luID0gb3JpZ2luO1xuICAgICAgdGhpcy51c2VyQ2hhbmdlZFZhbHVlID0gb3JpZ2luID09PSBcInVzZXJcIiAmJiB0aGlzLnZhbHVlICE9PSBuZXdWYWx1ZTtcbiAgICAgIC8vIGRvbid0IHNhbml0aXplIHRoZSBzdGFydCBvZiBuZWdhdGl2ZS9kZWNpbWFsIG51bWJlcnMsIGJ1dFxuICAgICAgLy8gZG9uJ3Qgc2V0IHZhbHVlIHRvIGFuIGludmFsaWQgbnVtYmVyXG4gICAgICB0aGlzLnZhbHVlID0gW1wiLVwiLCBcIi5cIl0uaW5jbHVkZXMobmV3VmFsdWUpID8gXCJcIiA6IG5ld1ZhbHVlO1xuICAgICAgaWYgKG9yaWdpbiA9PT0gXCJkaXJlY3RcIikge1xuICAgICAgICB0aGlzLnNldElucHV0TnVtYmVyVmFsdWUobmV3TG9jYWxpemVkVmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByZXZpb3VzRW1pdHRlZE51bWJlclZhbHVlKG5ld0xvY2FsaXplZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXRpdmVFdmVudCkge1xuICAgICAgICBjb25zdCBjYWxjaXRlSW5wdXROdW1iZXJJbnB1dEV2ZW50ID0gdGhpcy5jYWxjaXRlSW5wdXROdW1iZXJJbnB1dC5lbWl0KCk7XG4gICAgICAgIGlmIChjYWxjaXRlSW5wdXROdW1iZXJJbnB1dEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5wcmV2aW91c1ZhbHVlO1xuICAgICAgICAgIHRoaXMubG9jYWxpemVkVmFsdWUgPSBudW1iZXJTdHJpbmdGb3JtYXR0ZXIubG9jYWxpemUodGhpcy5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21taXR0aW5nKSB7XG4gICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlSWZVc2VyTW9kaWZpZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnB1dE51bWJlcktleVVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMubnVkZ2VOdW1iZXJWYWx1ZUludGVydmFsSWQpO1xuICAgIH07XG4gICAgdGhpcy5hbGlnbm1lbnQgPSBcInN0YXJ0XCI7XG4gICAgdGhpcy5hdXRvZm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmdyb3VwU2VwYXJhdG9yID0gZmFsc2U7XG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICB0aGlzLmljb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pY29uRmxpcFJ0bCA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2NhbGVGb3JtYXQgPSBmYWxzZTtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heExlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbkxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5hbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5udW1iZXJCdXR0b25UeXBlID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIHRoaXMucGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wcmVmaXhUZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICB0aGlzLnJlcXVpcmVkID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsZSA9IFwibVwiO1xuICAgIHRoaXMuc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgdGhpcy5zdGVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXV0b2NvbXBsZXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5wdXRNb2RlID0gXCJkZWNpbWFsXCI7XG4gICAgdGhpcy5lbnRlcktleUhpbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdWZmaXhUZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZWRpdGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICB0aGlzLm1lc3NhZ2VzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVzc2FnZU92ZXJyaWRlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVmZmVjdGl2ZUxvY2FsZSA9IFwiXCI7XG4gICAgdGhpcy5kZWZhdWx0TWVzc2FnZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2NhbGl6ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNsb3R0ZWRBY3Rpb25FbERpc2FibGVkSW50ZXJuYWxseSA9IGZhbHNlO1xuICB9XG4gIGRpc2FibGVkV2F0Y2hlcigpIHtcbiAgICB0aGlzLnNldERpc2FibGVkQWN0aW9uKCk7XG4gIH1cbiAgLyoqIHdhdGNoZXIgdG8gdXBkYXRlIG51bWJlci10by1zdHJpbmcgZm9yIG1heCAqL1xuICBtYXhXYXRjaGVyKCkge1xuICAgIHRoaXMubWF4U3RyaW5nID0gdGhpcy5tYXg/LnRvU3RyaW5nKCkgfHwgbnVsbDtcbiAgfVxuICAvKiogd2F0Y2hlciB0byB1cGRhdGUgbnVtYmVyLXRvLXN0cmluZyBmb3IgbWluICovXG4gIG1pbldhdGNoZXIoKSB7XG4gICAgdGhpcy5taW5TdHJpbmcgPSB0aGlzLm1pbj8udG9TdHJpbmcoKSB8fCBudWxsO1xuICB9XG4gIG9uTWVzc2FnZXNDaGFuZ2UoKSB7XG4gICAgLyogd2lyZWQgdXAgYnkgdDluIHV0aWwgKi9cbiAgfVxuICB2YWx1ZVdhdGNoZXIobmV3VmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcbiAgICBpZiAoIXRoaXMudXNlckNoYW5nZWRWYWx1ZSkge1xuICAgICAgdGhpcy5zZXROdW1iZXJWYWx1ZSh7XG4gICAgICAgIG9yaWdpbjogXCJkaXJlY3RcIixcbiAgICAgICAgcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgdmFsdWU6IG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT0gXCJcIlxuICAgICAgICAgID8gXCJcIlxuICAgICAgICAgIDogaXNWYWxpZE51bWJlcihuZXdWYWx1ZSlcbiAgICAgICAgICAgID8gbmV3VmFsdWVcbiAgICAgICAgICAgIDogdGhpcy5wcmV2aW91c1ZhbHVlIHx8IFwiXCJcbiAgICAgIH0pO1xuICAgICAgdGhpcy53YXJuQWJvdXRJbnZhbGlkTnVtYmVyVmFsdWUobmV3VmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLnVzZXJDaGFuZ2VkVmFsdWUgPSBmYWxzZTtcbiAgfVxuICB1cGRhdGVSZXF1ZXN0ZWRJY29uKCkge1xuICAgIHRoaXMucmVxdWVzdGVkSWNvbiA9IHNldFJlcXVlc3RlZEljb24oe30sIHRoaXMuaWNvbiwgXCJudW1iZXJcIik7XG4gIH1cbiAgZ2V0IGlzQ2xlYXJhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmNsZWFyYWJsZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCA+IDA7XG4gIH1cbiAgZWZmZWN0aXZlTG9jYWxlV2F0Y2hlcihsb2NhbGUpIHtcbiAgICB1cGRhdGVNZXNzYWdlcyh0aGlzLCB0aGlzLmVmZmVjdGl2ZUxvY2FsZSk7XG4gICAgbnVtYmVyU3RyaW5nRm9ybWF0dGVyLm51bWJlckZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICBsb2NhbGUsXG4gICAgICBudW1iZXJpbmdTeXN0ZW06IHRoaXMubnVtYmVyaW5nU3lzdGVtLFxuICAgICAgdXNlR3JvdXBpbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25uZWN0TG9jYWxpemVkKHRoaXMpO1xuICAgIGNvbm5lY3RNZXNzYWdlcyh0aGlzKTtcbiAgICB0aGlzLnNjYWxlID0gZ2V0RWxlbWVudFByb3AodGhpcy5lbCwgXCJzY2FsZVwiLCB0aGlzLnNjYWxlKTtcbiAgICB0aGlzLmlubGluZUVkaXRhYmxlRWwgPSB0aGlzLmVsLmNsb3Nlc3QoXCJjYWxjaXRlLWlubGluZS1lZGl0YWJsZVwiKTtcbiAgICBpZiAodGhpcy5pbmxpbmVFZGl0YWJsZUVsKSB7XG4gICAgICB0aGlzLmVkaXRpbmdFbmFibGVkID0gdGhpcy5pbmxpbmVFZGl0YWJsZUVsLmVkaXRpbmdFbmFibGVkIHx8IGZhbHNlO1xuICAgIH1cbiAgICBjb25uZWN0TGFiZWwodGhpcyk7XG4gICAgY29ubmVjdEZvcm0odGhpcyk7XG4gICAgdGhpcy5zZXRQcmV2aW91c0VtaXR0ZWROdW1iZXJWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICB0aGlzLnNldFByZXZpb3VzTnVtYmVyVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgdGhpcy53YXJuQWJvdXRJbnZhbGlkTnVtYmVyVmFsdWUodGhpcy52YWx1ZSk7XG4gICAgdGhpcy5zZXROdW1iZXJWYWx1ZSh7XG4gICAgICBvcmlnaW46IFwiY29ubmVjdGVkXCIsXG4gICAgICB2YWx1ZTogaXNWYWxpZE51bWJlcih0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUgOiBcIlwiXG4gICAgfSk7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyPy5vYnNlcnZlKHRoaXMuZWwsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgIHRoaXMuc2V0RGlzYWJsZWRBY3Rpb24oKTtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjYWxjaXRlSW50ZXJuYWxIaWRkZW5JbnB1dENoYW5nZVwiLCB0aGlzLmhpZGRlbklucHV0Q2hhbmdlSGFuZGxlcik7XG4gIH1cbiAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICBzZXRDb21wb25lbnRMb2FkZWQodGhpcyk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgZGlzY29ubmVjdExhYmVsKHRoaXMpO1xuICAgIGRpc2Nvbm5lY3RGb3JtKHRoaXMpO1xuICAgIGRpc2Nvbm5lY3RMb2NhbGl6ZWQodGhpcyk7XG4gICAgZGlzY29ubmVjdE1lc3NhZ2VzKHRoaXMpO1xuICAgIHRoaXMubXV0YXRpb25PYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbGNpdGVJbnRlcm5hbEhpZGRlbklucHV0Q2hhbmdlXCIsIHRoaXMuaGlkZGVuSW5wdXRDaGFuZ2VIYW5kbGVyKTtcbiAgfVxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBzZXRVcExvYWRhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIHRoaXMubWF4U3RyaW5nID0gdGhpcy5tYXg/LnRvU3RyaW5nKCk7XG4gICAgdGhpcy5taW5TdHJpbmcgPSB0aGlzLm1pbj8udG9TdHJpbmcoKTtcbiAgICB0aGlzLnJlcXVlc3RlZEljb24gPSBzZXRSZXF1ZXN0ZWRJY29uKHt9LCB0aGlzLmljb24sIFwibnVtYmVyXCIpO1xuICAgIGF3YWl0IHNldFVwTWVzc2FnZXModGhpcyk7XG4gIH1cbiAgY29tcG9uZW50U2hvdWxkVXBkYXRlKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09IFwidmFsdWVcIiAmJiBuZXdWYWx1ZSAmJiAhaXNWYWxpZE51bWJlcihuZXdWYWx1ZSkpIHtcbiAgICAgIHRoaXMuc2V0TnVtYmVyVmFsdWUoe1xuICAgICAgICBvcmlnaW46IFwicmVzZXRcIixcbiAgICAgICAgdmFsdWU6IG9sZFZhbHVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29tcG9uZW50RGlkUmVuZGVyKCkge1xuICAgIHVwZGF0ZUhvc3RJbnRlcmFjdGlvbih0aGlzKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQdWJsaWMgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKiBTZXRzIGZvY3VzIG9uIHRoZSBjb21wb25lbnQuICovXG4gIGFzeW5jIHNldEZvY3VzKCkge1xuICAgIGF3YWl0IGNvbXBvbmVudExvYWRlZCh0aGlzKTtcbiAgICB0aGlzLmNoaWxkTnVtYmVyRWw/LmZvY3VzKCk7XG4gIH1cbiAgLyoqIFNlbGVjdHMgYWxsIHRleHQgb2YgdGhlIGNvbXBvbmVudCdzIGB2YWx1ZWAuICovXG4gIGFzeW5jIHNlbGVjdFRleHQoKSB7XG4gICAgdGhpcy5jaGlsZE51bWJlckVsPy5zZWxlY3QoKTtcbiAgfVxuICBvbkxhYmVsQ2xpY2soKSB7XG4gICAgdGhpcy5zZXRGb2N1cygpO1xuICB9XG4gIGluY3JlbWVudE9yRGVjcmVtZW50TnVtYmVyVmFsdWUoZGlyZWN0aW9uLCBpbnB1dE1heCwgaW5wdXRNaW4sIG5hdGl2ZUV2ZW50KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gdGhpcztcbiAgICBjb25zdCBpbnB1dFN0ZXAgPSB0aGlzLnN0ZXAgPT09IFwiYW55XCIgPyAxIDogTWF0aC5hYnModGhpcy5zdGVwIHx8IDEpO1xuICAgIGNvbnN0IGlucHV0VmFsID0gdmFsdWUgJiYgdmFsdWUgIT09IFwiXCIgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IDA7XG4gICAgY29uc3QgYWRqdXN0bWVudCA9IGRpcmVjdGlvbiA9PT0gXCJ1cFwiID8gMSA6IC0xO1xuICAgIGNvbnN0IG51ZGdlZFZhbHVlID0gaW5wdXRWYWwgKyBpbnB1dFN0ZXAgKiBhZGp1c3RtZW50O1xuICAgIGNvbnN0IGZpbmFsVmFsdWUgPSB0eXBlb2YgaW5wdXRNaW4gPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKGlucHV0TWluKSAmJiBudWRnZWRWYWx1ZSA8IGlucHV0TWluXG4gICAgICA/IGlucHV0TWluXG4gICAgICA6IHR5cGVvZiBpbnB1dE1heCA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oaW5wdXRNYXgpICYmIG51ZGdlZFZhbHVlID4gaW5wdXRNYXhcbiAgICAgICAgPyBpbnB1dE1heFxuICAgICAgICA6IG51ZGdlZFZhbHVlO1xuICAgIGNvbnN0IGlucHV0VmFsUGxhY2VzID0gZGVjaW1hbFBsYWNlcyhpbnB1dFZhbCk7XG4gICAgY29uc3QgaW5wdXRTdGVwUGxhY2VzID0gZGVjaW1hbFBsYWNlcyhpbnB1dFN0ZXApO1xuICAgIHRoaXMuc2V0TnVtYmVyVmFsdWUoe1xuICAgICAgY29tbWl0dGluZzogdHJ1ZSxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgb3JpZ2luOiBcInVzZXJcIixcbiAgICAgIHZhbHVlOiBmaW5hbFZhbHVlLnRvRml4ZWQoTWF0aC5tYXgoaW5wdXRWYWxQbGFjZXMsIGlucHV0U3RlcFBsYWNlcykpXG4gICAgfSk7XG4gIH1cbiAgb25Gb3JtUmVzZXQoKSB7XG4gICAgdGhpcy5zZXROdW1iZXJWYWx1ZSh7XG4gICAgICBvcmlnaW46IFwicmVzZXRcIixcbiAgICAgIHZhbHVlOiB0aGlzLmRlZmF1bHRWYWx1ZVxuICAgIH0pO1xuICB9XG4gIHN5bmNIaWRkZW5Gb3JtSW5wdXQoaW5wdXQpIHtcbiAgICBpbnB1dC50eXBlID0gXCJudW1iZXJcIjtcbiAgICBpbnB1dC5taW4gPSB0aGlzLm1pbj8udG9TdHJpbmcoMTApID8/IFwiXCI7XG4gICAgaW5wdXQubWF4ID0gdGhpcy5tYXg/LnRvU3RyaW5nKDEwKSA/PyBcIlwiO1xuICB9XG4gIHNldERpc2FibGVkQWN0aW9uKCkge1xuICAgIGNvbnN0IHNsb3R0ZWRBY3Rpb25FbCA9IGdldFNsb3R0ZWQodGhpcy5lbCwgXCJhY3Rpb25cIik7XG4gICAgaWYgKCFzbG90dGVkQWN0aW9uRWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIGlmIChzbG90dGVkQWN0aW9uRWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNsb3R0ZWRBY3Rpb25FbERpc2FibGVkSW50ZXJuYWxseSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzbG90dGVkQWN0aW9uRWwuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2xvdHRlZEFjdGlvbkVsRGlzYWJsZWRJbnRlcm5hbGx5KSB7XG4gICAgICBzbG90dGVkQWN0aW9uRWwucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICB0aGlzLnNsb3R0ZWRBY3Rpb25FbERpc2FibGVkSW50ZXJuYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1ZhbGlkTnVtYmVyKHZhbHVlKSA/IHZhbHVlIDogXCJcIjtcbiAgfVxuICB3YXJuQWJvdXRJbnZhbGlkTnVtYmVyVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgIWlzVmFsaWROdW1iZXIodmFsdWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBzcGVjaWZpZWQgdmFsdWUgXCIke3ZhbHVlfVwiIGNhbm5vdCBiZSBwYXJzZWQsIG9yIGlzIG91dCBvZiByYW5nZS5gKTtcbiAgICB9XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlciBNZXRob2RzXG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKHRoaXMuZWwpO1xuICAgIGNvbnN0IGxvYWRlciA9IChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5sb2FkZXIgfSwgaChcImNhbGNpdGUtcHJvZ3Jlc3NcIiwgeyBsYWJlbDogdGhpcy5tZXNzYWdlcy5sb2FkaW5nLCB0eXBlOiBcImluZGV0ZXJtaW5hdGVcIiB9KSkpO1xuICAgIGNvbnN0IGlucHV0Q2xlYXJCdXR0b24gPSAoaChcImJ1dHRvblwiLCB7IFwiYXJpYS1sYWJlbFwiOiB0aGlzLm1lc3NhZ2VzLmNsZWFyLCBjbGFzczogQ1NTLmNsZWFyQnV0dG9uLCBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCB8fCB0aGlzLnJlYWRPbmx5LCBvbkNsaWNrOiB0aGlzLmNsZWFySW5wdXRWYWx1ZSwgdGFiSW5kZXg6IC0xLCB0eXBlOiBcImJ1dHRvblwiIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBpY29uOiBcInhcIiwgc2NhbGU6IHRoaXMuc2NhbGUgPT09IFwibFwiID8gXCJtXCIgOiBcInNcIiB9KSkpO1xuICAgIGNvbnN0IGljb25FbCA9IChoKFwiY2FsY2l0ZS1pY29uXCIsIHsgY2xhc3M6IENTUy5pbnB1dEljb24sIGZsaXBSdGw6IHRoaXMuaWNvbkZsaXBSdGwsIGljb246IHRoaXMucmVxdWVzdGVkSWNvbiwgc2NhbGU6IHRoaXMuc2NhbGUgPT09IFwibFwiID8gXCJtXCIgOiBcInNcIiB9KSk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsTnVtYmVyQnV0dG9uID0gdGhpcy5udW1iZXJCdXR0b25UeXBlID09PSBcImhvcml6b250YWxcIjtcbiAgICBjb25zdCBudW1iZXJCdXR0b25zSG9yaXpvbnRhbFVwID0gKGgoXCJidXR0b25cIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjbGFzczoge1xuICAgICAgICBbQ1NTLm51bWJlckJ1dHRvbkl0ZW1dOiB0cnVlLFxuICAgICAgICBbQ1NTLmJ1dHRvbkl0ZW1Ib3Jpem9udGFsXTogaXNIb3Jpem9udGFsTnVtYmVyQnV0dG9uXG4gICAgICB9LCBcImRhdGEtYWRqdXN0bWVudFwiOiBcInVwXCIsIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZE9ubHksIG9uUG9pbnRlckRvd246IHRoaXMubnVkZ2VCdXR0b25Qb2ludGVyRG93bkhhbmRsZXIsIG9uUG9pbnRlck91dDogdGhpcy5udWRnZUJ1dHRvblBvaW50ZXJVcEFuZE91dEhhbmRsZXIsIG9uUG9pbnRlclVwOiB0aGlzLm51ZGdlQnV0dG9uUG9pbnRlclVwQW5kT3V0SGFuZGxlciwgdGFiSW5kZXg6IC0xLCB0eXBlOiBcImJ1dHRvblwiIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBpY29uOiBcImNoZXZyb24tdXBcIiwgc2NhbGU6IHRoaXMuc2NhbGUgPT09IFwibFwiID8gXCJtXCIgOiBcInNcIiB9KSkpO1xuICAgIGNvbnN0IG51bWJlckJ1dHRvbnNIb3Jpem9udGFsRG93biA9IChoKFwiYnV0dG9uXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgY2xhc3M6IHtcbiAgICAgICAgW0NTUy5udW1iZXJCdXR0b25JdGVtXTogdHJ1ZSxcbiAgICAgICAgW0NTUy5idXR0b25JdGVtSG9yaXpvbnRhbF06IGlzSG9yaXpvbnRhbE51bWJlckJ1dHRvblxuICAgICAgfSwgXCJkYXRhLWFkanVzdG1lbnRcIjogXCJkb3duXCIsIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZE9ubHksIG9uUG9pbnRlckRvd246IHRoaXMubnVkZ2VCdXR0b25Qb2ludGVyRG93bkhhbmRsZXIsIG9uUG9pbnRlck91dDogdGhpcy5udWRnZUJ1dHRvblBvaW50ZXJVcEFuZE91dEhhbmRsZXIsIG9uUG9pbnRlclVwOiB0aGlzLm51ZGdlQnV0dG9uUG9pbnRlclVwQW5kT3V0SGFuZGxlciwgdGFiSW5kZXg6IC0xLCB0eXBlOiBcImJ1dHRvblwiIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBpY29uOiBcImNoZXZyb24tZG93blwiLCBzY2FsZTogdGhpcy5zY2FsZSA9PT0gXCJsXCIgPyBcIm1cIiA6IFwic1wiIH0pKSk7XG4gICAgY29uc3QgbnVtYmVyQnV0dG9uc1ZlcnRpY2FsID0gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLm51bWJlckJ1dHRvbldyYXBwZXIgfSwgbnVtYmVyQnV0dG9uc0hvcml6b250YWxVcCwgbnVtYmVyQnV0dG9uc0hvcml6b250YWxEb3duKSk7XG4gICAgY29uc3QgcHJlZml4VGV4dCA9IGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnByZWZpeCB9LCB0aGlzLnByZWZpeFRleHQpO1xuICAgIGNvbnN0IHN1ZmZpeFRleHQgPSBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5zdWZmaXggfSwgdGhpcy5zdWZmaXhUZXh0KTtcbiAgICBjb25zdCBjaGlsZEVsID0gKGgoXCJpbnB1dFwiLCB7IFwiYXJpYS1sYWJlbFwiOiBnZXRMYWJlbFRleHQodGhpcyksIGF1dG9jb21wbGV0ZTogdGhpcy5hdXRvY29tcGxldGUsIGF1dG9mb2N1czogdGhpcy5hdXRvZm9jdXMgPyB0cnVlIDogbnVsbCwgZGVmYXVsdFZhbHVlOiB0aGlzLmRlZmF1bHRWYWx1ZSwgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQgPyB0cnVlIDogbnVsbCwgZW50ZXJLZXlIaW50OiB0aGlzLmVudGVyS2V5SGludCwgaW5wdXRNb2RlOiB0aGlzLmlucHV0TW9kZSwga2V5OiBcImxvY2FsaXplZC1pbnB1dFwiLCBtYXhMZW5ndGg6IHRoaXMubWF4TGVuZ3RoLCBtaW5MZW5ndGg6IHRoaXMubWluTGVuZ3RoLCBuYW1lOiB1bmRlZmluZWQsIG9uQmx1cjogdGhpcy5pbnB1dE51bWJlckJsdXJIYW5kbGVyLCBvbkZvY3VzOiB0aGlzLmlucHV0TnVtYmVyRm9jdXNIYW5kbGVyLCBvbklucHV0OiB0aGlzLmlucHV0TnVtYmVySW5wdXRIYW5kbGVyLCBvbktleURvd246IHRoaXMuaW5wdXROdW1iZXJLZXlEb3duSGFuZGxlciwgb25LZXlVcDogdGhpcy5pbnB1dE51bWJlcktleVVwSGFuZGxlciwgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXIgfHwgXCJcIiwgcmVhZE9ubHk6IHRoaXMucmVhZE9ubHksIHJlZjogdGhpcy5zZXRDaGlsZE51bWJlckVsUmVmLCB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHRoaXMubG9jYWxpemVkVmFsdWUgfSkpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IG9uQ2xpY2s6IHRoaXMuY2xpY2tIYW5kbGVyLCBvbktleURvd246IHRoaXMua2V5RG93bkhhbmRsZXIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiB7IFtDU1MuaW5wdXRXcmFwcGVyXTogdHJ1ZSwgW0NTU19VVElMSVRZLnJ0bF06IGRpciA9PT0gXCJydGxcIiB9IH0sIHRoaXMubnVtYmVyQnV0dG9uVHlwZSA9PT0gXCJob3Jpem9udGFsXCIgJiYgIXRoaXMucmVhZE9ubHlcbiAgICAgID8gbnVtYmVyQnV0dG9uc0hvcml6b250YWxEb3duXG4gICAgICA6IG51bGwsIHRoaXMucHJlZml4VGV4dCA/IHByZWZpeFRleHQgOiBudWxsLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy53cmFwcGVyIH0sIGNoaWxkRWwsIHRoaXMuaXNDbGVhcmFibGUgPyBpbnB1dENsZWFyQnV0dG9uIDogbnVsbCwgdGhpcy5yZXF1ZXN0ZWRJY29uID8gaWNvbkVsIDogbnVsbCwgdGhpcy5sb2FkaW5nID8gbG9hZGVyIDogbnVsbCksIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmFjdGlvbldyYXBwZXIgfSwgaChcInNsb3RcIiwgeyBuYW1lOiBTTE9UUy5hY3Rpb24gfSkpLCB0aGlzLm51bWJlckJ1dHRvblR5cGUgPT09IFwidmVydGljYWxcIiAmJiAhdGhpcy5yZWFkT25seSA/IG51bWJlckJ1dHRvbnNWZXJ0aWNhbCA6IG51bGwsIHRoaXMuc3VmZml4VGV4dCA/IHN1ZmZpeFRleHQgOiBudWxsLCB0aGlzLm51bWJlckJ1dHRvblR5cGUgPT09IFwiaG9yaXpvbnRhbFwiICYmICF0aGlzLnJlYWRPbmx5XG4gICAgICA/IG51bWJlckJ1dHRvbnNIb3Jpem9udGFsVXBcbiAgICAgIDogbnVsbCwgaChIaWRkZW5Gb3JtSW5wdXRTbG90LCB7IGNvbXBvbmVudDogdGhpcyB9KSkpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGFzc2V0c0RpcnMoKSB7IHJldHVybiBbXCJhc3NldHNcIl07IH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwiZGlzYWJsZWRcIjogW1wiZGlzYWJsZWRXYXRjaGVyXCJdLFxuICAgIFwibWF4XCI6IFtcIm1heFdhdGNoZXJcIl0sXG4gICAgXCJtaW5cIjogW1wibWluV2F0Y2hlclwiXSxcbiAgICBcIm1lc3NhZ2VPdmVycmlkZXNcIjogW1wib25NZXNzYWdlc0NoYW5nZVwiXSxcbiAgICBcInZhbHVlXCI6IFtcInZhbHVlV2F0Y2hlclwiXSxcbiAgICBcImljb25cIjogW1widXBkYXRlUmVxdWVzdGVkSWNvblwiXSxcbiAgICBcImVmZmVjdGl2ZUxvY2FsZVwiOiBbXCJlZmZlY3RpdmVMb2NhbGVXYXRjaGVyXCJdXG4gIH07IH1cbiAgc3RhdGljIGdldCBzdHlsZSgpIHsgcmV0dXJuIGlucHV0TnVtYmVyQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLWlucHV0LW51bWJlclwiLCB7XG4gICAgXCJhbGlnbm1lbnRcIjogWzUxM10sXG4gICAgXCJhdXRvZm9jdXNcIjogWzUxNl0sXG4gICAgXCJjbGVhcmFibGVcIjogWzUxNl0sXG4gICAgXCJkaXNhYmxlZFwiOiBbNTE2XSxcbiAgICBcImdyb3VwU2VwYXJhdG9yXCI6IFs1MTYsIFwiZ3JvdXAtc2VwYXJhdG9yXCJdLFxuICAgIFwiaGlkZGVuXCI6IFs1MTZdLFxuICAgIFwiaWNvblwiOiBbNTIwXSxcbiAgICBcImljb25GbGlwUnRsXCI6IFs1MTYsIFwiaWNvbi1mbGlwLXJ0bFwiXSxcbiAgICBcImxhYmVsXCI6IFsxXSxcbiAgICBcImxvYWRpbmdcIjogWzUxNl0sXG4gICAgXCJudW1iZXJpbmdTeXN0ZW1cIjogWzUxMywgXCJudW1iZXJpbmctc3lzdGVtXCJdLFxuICAgIFwibG9jYWxlRm9ybWF0XCI6IFs0LCBcImxvY2FsZS1mb3JtYXRcIl0sXG4gICAgXCJtYXhcIjogWzUxNF0sXG4gICAgXCJtaW5cIjogWzUxNF0sXG4gICAgXCJtYXhMZW5ndGhcIjogWzUxNCwgXCJtYXgtbGVuZ3RoXCJdLFxuICAgIFwibWluTGVuZ3RoXCI6IFs1MTQsIFwibWluLWxlbmd0aFwiXSxcbiAgICBcIm5hbWVcIjogWzUxM10sXG4gICAgXCJudW1iZXJCdXR0b25UeXBlXCI6IFs1MTMsIFwibnVtYmVyLWJ1dHRvbi10eXBlXCJdLFxuICAgIFwicGxhY2Vob2xkZXJcIjogWzFdLFxuICAgIFwicHJlZml4VGV4dFwiOiBbMSwgXCJwcmVmaXgtdGV4dFwiXSxcbiAgICBcInJlYWRPbmx5XCI6IFs1MTYsIFwicmVhZC1vbmx5XCJdLFxuICAgIFwicmVxdWlyZWRcIjogWzUxNl0sXG4gICAgXCJzY2FsZVwiOiBbMTUzN10sXG4gICAgXCJzdGF0dXNcIjogWzE1MzddLFxuICAgIFwic3RlcFwiOiBbNTIwXSxcbiAgICBcImF1dG9jb21wbGV0ZVwiOiBbMV0sXG4gICAgXCJpbnB1dE1vZGVcIjogWzEsIFwiaW5wdXQtbW9kZVwiXSxcbiAgICBcImVudGVyS2V5SGludFwiOiBbMSwgXCJlbnRlci1rZXktaGludFwiXSxcbiAgICBcInN1ZmZpeFRleHRcIjogWzEsIFwic3VmZml4LXRleHRcIl0sXG4gICAgXCJlZGl0aW5nRW5hYmxlZFwiOiBbMTU0MCwgXCJlZGl0aW5nLWVuYWJsZWRcIl0sXG4gICAgXCJ2YWx1ZVwiOiBbMTAyNV0sXG4gICAgXCJtZXNzYWdlc1wiOiBbMTA0MF0sXG4gICAgXCJtZXNzYWdlT3ZlcnJpZGVzXCI6IFsxMDQwXSxcbiAgICBcImVmZmVjdGl2ZUxvY2FsZVwiOiBbMzJdLFxuICAgIFwiZGVmYXVsdE1lc3NhZ2VzXCI6IFszMl0sXG4gICAgXCJsb2NhbGl6ZWRWYWx1ZVwiOiBbMzJdLFxuICAgIFwic2xvdHRlZEFjdGlvbkVsRGlzYWJsZWRJbnRlcm5hbGx5XCI6IFszMl0sXG4gICAgXCJzZXRGb2N1c1wiOiBbNjRdLFxuICAgIFwic2VsZWN0VGV4dFwiOiBbNjRdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiY2FsY2l0ZS1pbnB1dC1udW1iZXJcIiwgXCJjYWxjaXRlLWljb25cIiwgXCJjYWxjaXRlLXByb2dyZXNzXCJdO1xuICBjb21wb25lbnRzLmZvckVhY2godGFnTmFtZSA9PiB7IHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJjYWxjaXRlLWlucHV0LW51bWJlclwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIElucHV0TnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjYWxjaXRlLWljb25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQkOCgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhbGNpdGUtcHJvZ3Jlc3NcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuZGVmaW5lQ3VzdG9tRWxlbWVudCQxKCk7XG5cbmNvbnN0IGJ1ZmZlcnNTdGVwQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmJsb2NrfS5mbGV4LWdyaWR7ZGlzcGxheTpmbGV4fS5mbGV4LWdyaWQgLmNvbHtmbGV4OjE7cGFkZGluZy1pbmxpbmU6dW5zZXR9LmZsZXgtZ3JpZC1maWZ0aHN7ZGlzcGxheTpmbGV4O21heC13aWR0aDo0MDBweDttaW4td2lkdGg6Mjc1cHh9LmZsZXgtZ3JpZC1maWZ0aHMgLmNvbHtwYWRkaW5nOjAgM3B4O2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmxleC1ncmlkLWZpZnRocyAuY29sOmZpcnN0LWNoaWxke2ZsZXgtZ3JvdzowfS5mbGV4LWdyaWQtZmlmdGhzIC5jb2w6bm90KDpmaXJzdC1jaGlsZCl7ZmxleC1ncm93OjE7d2lkdGg6MH0uZmxleC1ncmlkLWZpZnRocyAuY29sOm50aC1jaGlsZCg1KXttaW4td2lkdGg6MTEwcHg7d2lkdGg6MTEwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDQwMHB4KXsuZmxleC1ncmlkLC5mbGV4LWdyaWQtZmlmdGhze2Rpc3BsYXk6YmxvY2t9LmZsZXgtZ3JpZCAuY29sLC5mbGV4LWdyaWQtZmlmdGhzIC5jb2x7d2lkdGg6MTAwJTttYXJnaW46MCAwIDVweCAwO3BhZGRpbmc6MH19LmFyY2dpc0J1ZmZlcnNTdGVwRGVzY3JpcHRpb257bWFyZ2luLWJvdHRvbTo4cHh9XCI7XG5cbmNvbnN0IEJ1ZmZlcnNTdGVwID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcclxuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XHJcbiAgICB0aGlzLmJ1ZmZlclR5cGVDaGFuZ2VkID0gY3JlYXRlRXZlbnQkMSh0aGlzLCBcImJ1ZmZlclR5cGVDaGFuZ2VkXCIsIDcpO1xyXG4gICAgdGhpcy5idWZmZXJWYWxzQ2hhbmdlZCA9IGNyZWF0ZUV2ZW50JDEodGhpcywgXCJidWZmZXJWYWxzQ2hhbmdlZFwiLCA3KTtcclxuICAgIHRoaXMuYnVmZmVyVW5pdENoYW5nZWQgPSBjcmVhdGVFdmVudCQxKHRoaXMsIFwiYnVmZmVyVW5pdENoYW5nZWRcIiwgNyk7XHJcbiAgICB0aGlzLl9pZFByZWZpeCA9ICdidWZmZXJzLXN0ZXAtJztcclxuICAgIHRoaXMuX2RiZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5jdXJyZW50QnVmZmVyVHlwZSA9IEJ1ZmZlclR5cGVzVmFsdWVzLnJpbmc7XHJcbiAgICB0aGlzLmJ1ZmZlckRhdGEgPSB7XHJcbiAgICAgIFtCdWZmZXJUeXBlc1ZhbHVlcy5yaW5nXTogeyBidWZmZXJWYWxzOiBbMSwgMywgNV0sIGJ1ZmZlclVuaXQ6ICdtaWxlcycgfSxcclxuICAgICAgW0J1ZmZlclR5cGVzVmFsdWVzLmRyaXZldGltZV06IHsgYnVmZmVyVmFsczogWzUsIDEwLCAxNV0sIGJ1ZmZlclVuaXQ6ICdtaW51dGVzJyB9LFxyXG4gICAgICBbQnVmZmVyVHlwZXNWYWx1ZXMud2Fsa3RpbWVdOiB7IGJ1ZmZlclZhbHM6IFs1LCAxMCwgMTVdLCBidWZmZXJVbml0OiAnbWludXRlcycgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuYmFzZUNvbmZpZyA9IG5ldyBCYXNlVXRpbCgnYnVmZmVycy1zdGVwJywgdGhpcywgdGhpcy5vblVwZGF0ZVVJKTtcclxuICB9XHJcbiAgLy9cclxuICAvLyBVcGRhdGUgUHJvcHMvU3RhdGVzIHdoZW4gdGhlIG1haW4gY29uZmlnIGNoYW5nZXNcclxuICBvbkNvbmZpZ0NoYW5nZShuZXdDb25maWcsIG9sZENvbmZpZykge1xyXG4gICAgaWYgKCFuZXdDb25maWcgfHwgdHlwZW9mIG5ld0NvbmZpZyAhPSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoQUNMVXRpbHMuaGFzVGV4dChuZXdDb25maWcpKSB7XHJcbiAgICAgIGNvbnN0IG5ld0NmZyA9IEpTT04ucGFyc2UobmV3Q29uZmlnKTtcclxuICAgICAgY29uc3Qgb2xkQ2ZnID0gKG9sZENvbmZpZyAmJiBBQ0xVdGlscy5oYXNUZXh0KG9sZENvbmZpZykpID8gSlNPTi5wYXJzZShvbGRDb25maWcpIDogbnVsbDtcclxuICAgICAgLy9cclxuICAgICAgLy8gQ09MT1JTOlxyXG4gICAgICAvLyBkZWZpbmUgYSB0ZW1wIGNvbG9yIG9iamVjdCBzbyB0aGF0IHdlIHVwZGF0ZSB0aGUgJ2NvbG9ycycgUHJvcCBvbmUgdGltZVxyXG4gICAgICB0aGlzLmJhc2VDb25maWcudXBkYXRlQ29uZmlnKG5ld0NmZywgb2xkQ2ZnKTtcclxuICAgICAgaWYgKCFvbGRDZmcgfHwgdGhpcy5faXNCdWZmZXJEYXRhQ2hhbmdlZChuZXdDZmcsIG9sZENmZykpIHtcclxuICAgICAgICB0aGlzLl9zZXRCdWZmZXJEYXRhRnJvbUNvbmZpZygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIG9uVGhlbWVDaGFuZ2VkKCkge1xyXG4gICAgdGhpcy5zdFRoZW1lID0gdGhpcy50aGVtZTtcclxuICAgIHRoaXMuYmFzZUNvbmZpZy5zZXRUaGVtZSh0aGlzLnRoZW1lKTtcclxuICB9XHJcbiAgb25CdWZmZXJUeXBlQ2hhbmdlKCkge1xyXG4gICAgdGhpcy5taW5CdWZmZXIgPSB0aGlzLmdldE1pbkJ1ZmZlcigpO1xyXG4gICAgdGhpcy5tYXhCdWZmZXIgPSB0aGlzLmdldE1heEJ1ZmZlcigpO1xyXG4gIH1cclxuICBzZXRMb2NhbGVTdHJpbmdzKCkge1xyXG4gICAgLy8gVE9ETzogaW5pdGlhbGl6ZSBsb2NhbGUgc3RyaW5ncyBmb3IgdGhpcyBjb21wb25lbnRcclxuICB9XHJcbiAgX2xvYWRJbnN0YW5jZXMoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2luc3RhbmNlSWQpXHJcbiAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBFbGVtZW50SWRzLmdlbmVyYXRlSWQodGhpcy5faWRQcmVmaXgpLmlkO1xyXG4gIH1cclxuICBfaXNCdWZmZXJEYXRhQ2hhbmdlZChuZXdDZmcsIG9sZENmZykge1xyXG4gICAgLy8gUmluZ3NcclxuICAgIGlmIChuZXdDZmcud29ya2Zsb3dSaW5nc0J1ZmZlcjEgIT09IG9sZENmZy53b3JrZmxvd1JpbmdzQnVmZmVyMSB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dSaW5nc0J1ZmZlcjIgIT09IG9sZENmZy53b3JrZmxvd1JpbmdzQnVmZmVyMiB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dSaW5nc0J1ZmZlcjMgIT09IG9sZENmZy53b3JrZmxvd1JpbmdzQnVmZmVyMyB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dSaW5nc0J1ZmZlclVuaXQgIT09IG9sZENmZy53b3JrZmxvd1JpbmdzQnVmZmVyVW5pdCB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dBdmFpbGFibGVCdWZmZXJSaW5ncyAhPT0gb2xkQ2ZnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyUmluZ3MpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBEcml2ZXRpbWVcclxuICAgIGlmIChuZXdDZmcud29ya2Zsb3dEcml2ZXRpbWVCdWZmZXIxICE9PSBvbGRDZmcud29ya2Zsb3dEcml2ZXRpbWVCdWZmZXIxIHx8XHJcbiAgICAgIG5ld0NmZy53b3JrZmxvd0RyaXZldGltZUJ1ZmZlcjIgIT09IG9sZENmZy53b3JrZmxvd0RyaXZldGltZUJ1ZmZlcjIgfHxcclxuICAgICAgbmV3Q2ZnLndvcmtmbG93RHJpdmV0aW1lQnVmZmVyMyAhPT0gb2xkQ2ZnLndvcmtmbG93RHJpdmV0aW1lQnVmZmVyMyB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dEcml2ZXRpbWVCdWZmZXJVbml0ICE9PSBvbGRDZmcud29ya2Zsb3dEcml2ZXRpbWVCdWZmZXJVbml0IHx8XHJcbiAgICAgIG5ld0NmZy53b3JrZmxvd0F2YWlsYWJsZUJ1ZmZlckRyaXZldGltZSAhPT0gb2xkQ2ZnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyRHJpdmV0aW1lKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gV2Fsa3RpbWVcclxuICAgIGlmIChuZXdDZmcud29ya2Zsb3dXYWxrdGltZUJ1ZmZlcjEgIT09IG9sZENmZy53b3JrZmxvd1dhbGt0aW1lQnVmZmVyMSB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dXYWxrdGltZUJ1ZmZlcjIgIT09IG9sZENmZy53b3JrZmxvd1dhbGt0aW1lQnVmZmVyMiB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dXYWxrdGltZUJ1ZmZlcjMgIT09IG9sZENmZy53b3JrZmxvd1dhbGt0aW1lQnVmZmVyMyB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dXYWxrdGltZUJ1ZmZlclVuaXQgIT09IG9sZENmZy53b3JrZmxvd1dhbGt0aW1lQnVmZmVyVW5pdCB8fFxyXG4gICAgICBuZXdDZmcud29ya2Zsb3dBdmFpbGFibGVCdWZmZXJXYWxrdGltZSAhPT0gb2xkQ2ZnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyV2Fsa3RpbWUpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIF9zZXRCdWZmZXJEYXRhRnJvbUNvbmZpZygpIHtcclxuICAgIGNvbnN0IGNmZyA9IHRoaXMuYmFzZUNvbmZpZy5jb25maWc7XHJcbiAgICB0aGlzLmJ1ZmZlckRhdGFbQnVmZmVyVHlwZXNWYWx1ZXMucmluZ10gPSB7IGJ1ZmZlclZhbHM6IFtjZmcud29ya2Zsb3dSaW5nc0J1ZmZlcjEsIGNmZy53b3JrZmxvd1JpbmdzQnVmZmVyMiwgY2ZnLndvcmtmbG93UmluZ3NCdWZmZXIzXSwgYnVmZmVyVW5pdDogY2ZnLndvcmtmbG93UmluZ3NCdWZmZXJVbml0IH07XHJcbiAgICB0aGlzLmJ1ZmZlckRhdGFbQnVmZmVyVHlwZXNWYWx1ZXMuZHJpdmV0aW1lXSA9IHsgYnVmZmVyVmFsczogW2NmZy53b3JrZmxvd0RyaXZldGltZUJ1ZmZlcjEsIGNmZy53b3JrZmxvd0RyaXZldGltZUJ1ZmZlcjIsIGNmZy53b3JrZmxvd0RyaXZldGltZUJ1ZmZlcjNdLCBidWZmZXJVbml0OiBjZmcud29ya2Zsb3dEcml2ZXRpbWVCdWZmZXJVbml0IH07XHJcbiAgICB0aGlzLmJ1ZmZlckRhdGFbQnVmZmVyVHlwZXNWYWx1ZXMud2Fsa3RpbWVdID0geyBidWZmZXJWYWxzOiBbY2ZnLndvcmtmbG93V2Fsa3RpbWVCdWZmZXIxLCBjZmcud29ya2Zsb3dXYWxrdGltZUJ1ZmZlcjIsIGNmZy53b3JrZmxvd1dhbGt0aW1lQnVmZmVyM10sIGJ1ZmZlclVuaXQ6IGNmZy53b3JrZmxvd1dhbGt0aW1lQnVmZmVyVW5pdCB9O1xyXG4gICAgLy8gSGFuZGxlIGN1cnJlbnQgYnVmZmVyIHR5cGUgbm90IGF2YWlsYWJsZVxyXG4gICAgaWYgKHRoaXMuY3VycmVudEJ1ZmZlclR5cGUgPT09IEJ1ZmZlclR5cGVzVmFsdWVzLnJpbmcgJiYgIWNmZy53b3JrZmxvd0F2YWlsYWJsZUJ1ZmZlclJpbmdzKSB7XHJcbiAgICAgIGlmIChjZmcud29ya2Zsb3dBdmFpbGFibGVCdWZmZXJEcml2ZXRpbWUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCdWZmZXJUeXBlID0gQnVmZmVyVHlwZXNWYWx1ZXMuZHJpdmV0aW1lO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJ1ZmZlclR5cGUgPSBCdWZmZXJUeXBlc1ZhbHVlcy53YWxrdGltZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5jdXJyZW50QnVmZmVyVHlwZSA9PT0gQnVmZmVyVHlwZXNWYWx1ZXMuZHJpdmV0aW1lICYmICFjZmcud29ya2Zsb3dBdmFpbGFibGVCdWZmZXJEcml2ZXRpbWUpIHtcclxuICAgICAgaWYgKGNmZy53b3JrZmxvd0F2YWlsYWJsZUJ1ZmZlclJpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVmZmVyVHlwZSA9IEJ1ZmZlclR5cGVzVmFsdWVzLnJpbmc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVmZmVyVHlwZSA9IEJ1ZmZlclR5cGVzVmFsdWVzLndhbGt0aW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnRCdWZmZXJUeXBlID09PSBCdWZmZXJUeXBlc1ZhbHVlcy53YWxrdGltZSAmJiAhY2ZnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyV2Fsa3RpbWUpIHtcclxuICAgICAgaWYgKGNmZy53b3JrZmxvd0F2YWlsYWJsZUJ1ZmZlclJpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVmZmVyVHlwZSA9IEJ1ZmZlclR5cGVzVmFsdWVzLnJpbmc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVmZmVyVHlwZSA9IEJ1ZmZlclR5cGVzVmFsdWVzLmRyaXZldGltZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5idWZmZXJUeXBlQ2hhbmdlZC5lbWl0KHRoaXMuY3VycmVudEJ1ZmZlclR5cGUpO1xyXG4gICAgdGhpcy5idWZmZXJWYWxzQ2hhbmdlZC5lbWl0KHRoaXMuYnVmZmVyRGF0YVt0aGlzLmN1cnJlbnRCdWZmZXJUeXBlXS5idWZmZXJWYWxzKTtcclxuICAgIHRoaXMuYnVmZmVyVW5pdENoYW5nZWQuZW1pdCh0aGlzLmJ1ZmZlckRhdGFbdGhpcy5jdXJyZW50QnVmZmVyVHlwZV0uYnVmZmVyVW5pdCk7XHJcbiAgfVxyXG4gIG9uVXBkYXRlVUkoKSB7XHJcbiAgICB0aGlzLmFwcGx5U3R5bGVzKCk7XHJcbiAgfVxyXG4gIGFwcGx5U3R5bGVzKCkge1xyXG4gICAgaWYgKHRoaXMuYmFzZUNvbmZpZz8uY29uZmlnPy5jb2xvcnMgJiYgT2JqZWN0LmtleXModGhpcy5iYXNlQ29uZmlnLmNvbmZpZy5jb2xvcnMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgYyA9IHRoaXMuYmFzZUNvbmZpZy5jb25maWcuY29sb3JzO1xyXG4gICAgICBjb25zdCBjYWxjaXRlVGFic091dGVyID0gQUNMVXRpbHMucXVlcnlFbGVtZW50LmNhbGwodGhpcy5lbCwgJ2NhbGNpdGUtdGFicycpO1xyXG4gICAgICBpZiAoY2FsY2l0ZVRhYnNPdXRlciAmJiAnc3R5bGUnIGluIGNhbGNpdGVUYWJzT3V0ZXIpIHtcclxuICAgICAgICBjYWxjaXRlVGFic091dGVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1jYWxjaXRlLXVpLWJvcmRlci1pbnB1dFwiLCAndW5zZXQnKTtcclxuICAgICAgICBjYWxjaXRlVGFic091dGVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1jYWxjaXRlLXVpLWZvcmVncm91bmQtMVwiLCBjLmZvcmVncm91bmQpO1xyXG4gICAgICAgIGNhbGNpdGVUYWJzT3V0ZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLWNhbGNpdGUtdWktYnJhbmRcIiwgYy5icmFuZCk7XHJcbiAgICAgICAgLy8gY29uc3QgY2FsY2l0ZVRhYnMgPSBBQ0xVdGlscy5xdWVyeUVsZW1lbnQuY2FsbCh0aGlzLmVsLCAnY2FsY2l0ZS10YWJzJyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NhbGNpdGVUYWJzJyxjYWxjaXRlVGFicylcclxuICAgICAgICAvLyBpZiAoY2FsY2l0ZVRhYnMpe1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNhbGNpdGVUYWJzT3V0ZXIpXHJcbiAgICAgICAgLy8gY2FsY2l0ZVRhYnNPdXRlci5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS10YWJcIikuZm9yRWFjaCh0YWIgPT4ge1xyXG4gICAgICAgIC8vICAgaWYgKHRhYi5zaGFkb3dSb290KSB7XHJcbiAgICAgICAgLy8gICAgIGNvbnN0IGJ1ZmZlclJvdyA9IHRhYi5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJkaXYuZmxleC1ncmlkLWZpZnRoc1wiKTtcclxuICAgICAgICAvLyAgICAgaWYgKGJ1ZmZlclJvdykge1xyXG4gICAgICAgIC8vICAgICAgIGNvbnN0IGNhbGNpdGVTZWxlY3QgPSBidWZmZXJSb3cucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2VsZWN0XCIpO1xyXG4gICAgICAgIC8vICAgICAgIGlmIChjYWxjaXRlU2VsZWN0LnNoYWRvd1Jvb3Qpe1xyXG4gICAgICAgIC8vICAgICAgICAgY29uc3Qgc2VsZWN0ID0gIGNhbGNpdGVTZWxlY3Quc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1zZWxlY3RcIilcclxuICAgICAgICAvLyAgICAgICAgIGlmIChzZWxlY3QgJiYgJ3N0eWxlJyBpbiBzZWxlY3QpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgKHNlbGVjdCBhcyBIVE1MRWxlbWVudCkuc3R5bGUuc2V0UHJvcGVydHkoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsICd0cmFuc3BhcmVudCcpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAoc2VsZWN0IGFzIEhUTUxFbGVtZW50KS5zdHlsZS5zZXRQcm9wZXJ0eShcImJvcmRlclwiLCAnbm9uZScpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAoc2VsZWN0IGFzIEhUTUxFbGVtZW50KS5zdHlsZS5zZXRQcm9wZXJ0eShcInBhZGRpbmdcIiwgJzBweCcpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAoc2VsZWN0IGFzIEhUTUxFbGVtZW50KS5zdHlsZS5zZXRQcm9wZXJ0eShcIm1hcmdpblwiLCAnMHB4Jyk7XHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgfVxyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICB9XHJcbiAgICAgICAgLy8gfSlcclxuICAgICAgICAvL31cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZykge1xyXG4gICAgICB0aGlzLm9uQ29uZmlnQ2hhbmdlKHRoaXMuY29uZmlnLCAnJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy50aGVtZSkge1xyXG4gICAgICB0aGlzLmJhc2VDb25maWcuc2V0VGhlbWUodGhpcy50aGVtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5iYXNlQ29uZmlnLnNldFRoZW1lKCdsaWdodCcpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5taW5CdWZmZXIgPSB0aGlzLmdldE1pbkJ1ZmZlcigpO1xyXG4gICAgdGhpcy5tYXhCdWZmZXIgPSB0aGlzLmdldE1heEJ1ZmZlcigpO1xyXG4gICAgdGhpcy5fbG9hZEluc3RhbmNlcygpO1xyXG4gIH1cclxuICAvLyBTdGVuY2lsIGxpZmVjeWNsZSAtIGNhbGxlZCBqdXN0IGFmdGVyIGNvbXBvbmVudCB1cGRhdGVzLCBidXQgbm90IGNhbGxlZCBkdXJpbmcgZmlyc3QgcmVuZGVyKClcclxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICBpZiAodGhpcy5iYXNlQ29uZmlnKSB7XHJcbiAgICAgIHRoaXMuYmFzZUNvbmZpZy5vbkNvbXBvbmVudEhhc1JlbmRlcmVkKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIFN0ZW5jaWwgbGlmZWN5Y2xlIC0gY2FsbGVkIG9uY2UgYWZ0ZXIgY29tcG9uZW50IGlzIGZ1bGx5IGxvYWRlZCBhbmQgMXN0IHJlbmRlciBvY2N1cnJlZFxyXG4gIGNvbXBvbmVudERpZExvYWQoKSB7XHJcbiAgICB0aGlzLl9sb2FkSW5zdGFuY2VzKCk7XHJcbiAgICBpZiAodGhpcy5iYXNlQ29uZmlnKSB7XHJcbiAgICAgIHRoaXMuYmFzZUNvbmZpZy5vbkNvbXBvbmVudEhhc1JlbmRlcmVkKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNsZWFuQXJyYXkoaW5wdXRBcnIpIHtcclxuICAgIGxldCBvdXRwdXRBcnJheSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIWlzTmFOKGlucHV0QXJyW2ldKSkge1xyXG4gICAgICAgIG91dHB1dEFycmF5LnB1c2goaW5wdXRBcnJbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0QXJyYXk7XHJcbiAgfVxyXG4gIGhhbmRsZUJ1ZmZlclZhbHNDaGFuZ2UoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICBjb25zdCB7IGJ1ZmZlckRhdGEsIGN1cnJlbnRCdWZmZXJUeXBlLCBtaW5CdWZmZXIgfSA9IHRoaXM7XHJcbiAgICBjb25zdCBidWZmZXJWYWxzID0gYnVmZmVyRGF0YVtjdXJyZW50QnVmZmVyVHlwZV0uYnVmZmVyVmFscztcclxuICAgIGlmICh0aGlzLl9kYmcpIHtcclxuICAgICAgY29uc29sZS5sb2coJ2J1ZmZlcnMtc3RlcCBkYXRhLCB2YWxzJywgYnVmZmVyRGF0YSwgYnVmZmVyVmFscyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBudW1OdWxsVmFsdWVzID0gYnVmZmVyVmFscy5yZWR1Y2UoKGNvdW50LCB2YWwpID0+IHtcclxuICAgICAgcmV0dXJuIGlzTmFOKHZhbCkgPyBjb3VudCArIDEgOiBjb3VudDtcclxuICAgIH0sIDApO1xyXG4gICAgaWYgKHRoaXMuX2RiZykge1xyXG4gICAgICBjb25zb2xlLmxvZygnYnVmZmVycy1zdGVwICBudWxsIHZhbHVlcycsIG51bU51bGxWYWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgIGJ1ZmZlclZhbHNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAobnVtTnVsbFZhbHVlcyA9PT0gMykge1xyXG4gICAgICBidWZmZXJWYWxzWzBdID0gbWluQnVmZmVyO1xyXG4gICAgfVxyXG4gICAgdGhpcy5idWZmZXJWYWxzQ2hhbmdlZC5lbWl0KHRoaXMuY2xlYW5BcnJheShidWZmZXJWYWxzKSk7XHJcbiAgfVxyXG4gIGhhbmRsZUJ1ZmZlclVuaXRDaGFuZ2UodmFsdWUpIHtcclxuICAgIHRoaXMuYnVmZmVyRGF0YVt0aGlzLmN1cnJlbnRCdWZmZXJUeXBlXS5idWZmZXJVbml0ID0gdmFsdWU7XHJcbiAgICB0aGlzLmJ1ZmZlclVuaXRDaGFuZ2VkLmVtaXQodmFsdWUpO1xyXG4gICAgLy8gVXBkYXRlIG1heEJ1ZmZlciBiYXNlZCBvbiB0aGUgY3VycmVudCBidWZmZXIgdHlwZSBhbmQgdW5pdFxyXG4gICAgdGhpcy5tYXhCdWZmZXIgPSB0aGlzLmdldE1heEJ1ZmZlcigpO1xyXG4gICAgaWYgKHRoaXMuX2RiZykge1xyXG4gICAgICBjb25zb2xlLmxvZygnYnVmZmVycy1zdGVwICBtYXhCdWZmZXInLCB0aGlzLm1heEJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICAvLyBjb25zdCBjYWxjaXRlVGFicyA9IEFDTFV0aWxzLnF1ZXJ5RWxlbWVudC5jYWxsKHRoaXMsICdjYWxjaXRlLXRhYnMnKTtcclxuICAgIC8vIGlmIChjYWxjaXRlVGFicyl7XHJcbiAgICAvLyAgIGNvbnN0IHRhYnNTaGFkb3dSb290ID0gY2FsY2l0ZVRhYnMuc2hhZG93Um9vdDtcclxuICAgIC8vICAgdGFic1NoYWRvd1Jvb3QuZm9yRWFjaCgoY2FsY2l0ZVRhYikgPT4ge1xyXG4gICAgLy8gICAgIGNvbnN0IHRhYlNoYWRvd1Jvb3QgPSBjYWxjaXRlVGFiLnNoYWRvd1Jvb3Q7XHJcbiAgICAvLyAgICAgaWYgKHRhYlNoYWRvd1Jvb3QpIHtcclxuICAgIC8vICAgICAgIGNvbnN0IGlucHV0RWxlbWVudHMgPSB0YWJTaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NhbGNpdGUtaW5wdXQtbnVtYmVyJyk7XHJcbiAgICAvLyAgICAgICBpbnB1dEVsZW1lbnRzLmZvckVhY2goKGlucHV0RWxlbWVudDogYW55KSA9PiB7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQoaW5wdXRFbGVtZW50LnZhbHVlKTtcclxuICAgIC8vICAgICAgICAgaWYgKCFpc05hTihjdXJyZW50VmFsdWUpICYmIGN1cnJlbnRWYWx1ZSA+IHRoaXMubWF4QnVmZmVyKSB7XHJcbiAgICAvLyAgICAgICAgICAgaW5wdXRFbGVtZW50LnZhbHVlID0gdGhpcy5tYXhCdWZmZXIudG9TdHJpbmcoKTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgICAgfSk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICB9KTtcclxuICAgIC8vIH1cclxuICB9XHJcbiAgaGFuZGxlVGFiQ2xpY2soYnVmZmVyVHlwZSkge1xyXG4gICAgdGhpcy5jdXJyZW50QnVmZmVyVHlwZSA9IGJ1ZmZlclR5cGU7XHJcbiAgICB0aGlzLmJ1ZmZlclR5cGVDaGFuZ2VkLmVtaXQoYnVmZmVyVHlwZSk7XHJcbiAgICB0aGlzLmJ1ZmZlclZhbHNDaGFuZ2VkLmVtaXQodGhpcy5idWZmZXJEYXRhW2J1ZmZlclR5cGVdLmJ1ZmZlclZhbHMpO1xyXG4gICAgdGhpcy5idWZmZXJVbml0Q2hhbmdlZC5lbWl0KHRoaXMuYnVmZmVyRGF0YVtidWZmZXJUeXBlXS5idWZmZXJVbml0KTtcclxuICB9XHJcbiAgZ2V0TWF4QnVmZmVyKCkge1xyXG4gICAgY29uc3QgeyBidWZmZXJEYXRhLCBjdXJyZW50QnVmZmVyVHlwZSB9ID0gdGhpcztcclxuICAgIGNvbnN0IGJ1ZmZlclVuaXQgPSBidWZmZXJEYXRhW2N1cnJlbnRCdWZmZXJUeXBlXT8uYnVmZmVyVW5pdDtcclxuICAgIHN3aXRjaCAoY3VycmVudEJ1ZmZlclR5cGUpIHtcclxuICAgICAgY2FzZSBCdWZmZXJUeXBlc1ZhbHVlcy5yaW5nOlxyXG4gICAgICAgIHJldHVybiBNYXhCdWZmZXJzLlJpbmdzO1xyXG4gICAgICBjYXNlIEJ1ZmZlclR5cGVzVmFsdWVzLmRyaXZldGltZTpcclxuICAgICAgICBpZiAoYnVmZmVyVW5pdCA9PT0gQnVmZmVyVW5pdHNWYWx1ZXMubWludXRlcykge1xyXG4gICAgICAgICAgcmV0dXJuIE1heEJ1ZmZlcnMuRHJpdmVNaW51dGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChidWZmZXJVbml0ID09PSBCdWZmZXJVbml0c1ZhbHVlcy5taWxlcykge1xyXG4gICAgICAgICAgcmV0dXJuIE1heEJ1ZmZlcnMuRHJpdmVNaWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChidWZmZXJVbml0ID09PSBCdWZmZXJVbml0c1ZhbHVlcy5raWxvbWV0ZXJzKSB7XHJcbiAgICAgICAgICByZXR1cm4gTWF4QnVmZmVycy5Ecml2ZUttO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBCdWZmZXJUeXBlc1ZhbHVlcy53YWxrdGltZTpcclxuICAgICAgICBpZiAoYnVmZmVyVW5pdCA9PT0gQnVmZmVyVW5pdHNWYWx1ZXMubWludXRlcykge1xyXG4gICAgICAgICAgcmV0dXJuIE1heEJ1ZmZlcnMuV2Fsa01pbnV0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJ1ZmZlclVuaXQgPT09IEJ1ZmZlclVuaXRzVmFsdWVzLm1pbGVzKSB7XHJcbiAgICAgICAgICByZXR1cm4gTWF4QnVmZmVycy5XYWxrTWlsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYnVmZmVyVW5pdCA9PT0gQnVmZmVyVW5pdHNWYWx1ZXMua2lsb21ldGVycykge1xyXG4gICAgICAgICAgcmV0dXJuIE1heEJ1ZmZlcnMuV2Fsa0ttO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gMzAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDMwMDtcclxuICB9XHJcbiAgZ2V0TWluQnVmZmVyKCkge1xyXG4gICAgc3dpdGNoICh0aGlzLmN1cnJlbnRCdWZmZXJUeXBlKSB7XHJcbiAgICAgIGNhc2UgQnVmZmVyVHlwZXNWYWx1ZXMucmluZzpcclxuICAgICAgICByZXR1cm4gTWluQnVmZmVycy5SaW5ncztcclxuICAgICAgY2FzZSBCdWZmZXJUeXBlc1ZhbHVlcy5kcml2ZXRpbWU6XHJcbiAgICAgICAgcmV0dXJuIE1pbkJ1ZmZlcnMuRHJpdmU7XHJcbiAgICAgIGNhc2UgQnVmZmVyVHlwZXNWYWx1ZXMud2Fsa3RpbWU6XHJcbiAgICAgICAgcmV0dXJuIE1pbkJ1ZmZlcnMuV2FsaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICB9XHJcbiAgZW5mb3JjZU1pbk1heFZhbHVlcyhlLCBtaW4sIG1heCwgaW5kZXgpIHtcclxuICAgIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpO1xyXG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XHJcbiAgICAgICAgdmFsdWUgPSBtaW47IC8vIEVuZm9yY2UgdGhlIG1pbmltdW0gdmFsdWVcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh2YWx1ZSA+IG1heCkge1xyXG4gICAgICAgIHZhbHVlID0gbWF4OyAvLyBFbmZvcmNlIHRoZSBtYXhpbXVtIHZhbHVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGUudGFyZ2V0LnZhbHVlID0gdmFsdWU7XHJcbiAgICB0aGlzLmhhbmRsZUJ1ZmZlclZhbHNDaGFuZ2UoaW5kZXgsIHZhbHVlKTtcclxuICB9XHJcbiAgZ2V0Q2FsY2l0ZVRhYihidWZmZXJUeXBlLCBidWZmZXJMYWJlbCwgdGFiKSB7XHJcbiAgICBCYVJlcG9ydHNMYW5ndWFnZS5faW5pdGlhbGl6ZSh0aGlzLmxhbmdDb2RlKTtcclxuICAgIHJldHVybiAoaCQxKFwiZGl2XCIsIHsgY2xhc3M6ICdmbGV4LWdyaWQtZmlmdGhzJyB9LCBoJDEoXCJkaXZcIiwgeyBjbGFzczogJ2NvbCcsIHN0eWxlOiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicgfSB9LCBidWZmZXJMYWJlbCksIEFycmF5KDMpLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiB7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlclZhbCA9IHRoaXMubWF4QnVmZmVyIDwgdGhpcy5idWZmZXJEYXRhW3RhYl0uYnVmZmVyVmFsc1tpXSA/IHRoaXMubWF4QnVmZmVyIDogIWlzTmFOKHRoaXMuYnVmZmVyRGF0YVt0YWJdLmJ1ZmZlclZhbHNbaV0pID8gdGhpcy5idWZmZXJEYXRhW3RhYl0uYnVmZmVyVmFsc1tpXSA6IG51bGw7XHJcbiAgICAgIHJldHVybiAoaCQxKFwiZGl2XCIsIHsgY2xhc3M6IFwiY29sXCIgfSwgaCQxKFwiY2FsY2l0ZS1pbnB1dC1udW1iZXJcIiwgeyBudW1iZXJCdXR0b25UeXBlOiBcIm5vbmVcIiwgbWF4OiB0aGlzLm1heEJ1ZmZlciwgbWluOiB0aGlzLm1pbkJ1ZmZlciwgdmFsdWU6IGJ1ZmZlclZhbCwgb25JbnB1dDogKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodGFyZ2V0LnZhbHVlKTtcclxuICAgICAgICAgIGlmICh2YWx1ZSA+PSB0aGlzLm1pbkJ1ZmZlciAmJiB2YWx1ZSA8PSB0aGlzLm1heEJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJ1ZmZlclZhbHNDaGFuZ2UoaSwgdmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIG9uQmx1cjogKGUpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KHRhcmdldC52YWx1ZSk7XHJcbiAgICAgICAgICBjb25zdCB7IGJ1ZmZlckRhdGEsIGN1cnJlbnRCdWZmZXJUeXBlLCBtaW5CdWZmZXIgfSA9IHRoaXM7XHJcbiAgICAgICAgICBjb25zdCBidWZmZXJWYWxzID0gYnVmZmVyRGF0YVtjdXJyZW50QnVmZmVyVHlwZV0uYnVmZmVyVmFscztcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHR3byB2YWx1ZXMgaW4gYnVmZmVyVmFscyBhcmUgTmFOXHJcbiAgICAgICAgICBjb25zdCBudW1OYU4gPSBidWZmZXJWYWxzLmZpbHRlcih2YWwgPT4gaXNOYU4odmFsKSkubGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSAmJiBudW1OYU4gPT09IDIpIHtcclxuICAgICAgICAgICAgLy8gSWYgdHdvIHZhbHVlcyBpbiBidWZmZXJWYWxzIGFyZSBOYU4gYW5kIHRhcmdldC52YWx1ZSBpcyBOYU4sIHNldCBidWZmZXJWYWxzWzBdIHRvIG1pbkJ1ZmZlclxyXG4gICAgICAgICAgICBidWZmZXJWYWxzWzBdID0gbWluQnVmZmVyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gRW5zdXJlIHRoZSBtaW5pbXVtIHZhbHVlIGlzIGVuZm9yY2VkIGZvciB0aGUgY3VycmVudCBmaWVsZFxyXG4gICAgICAgICAgdGhpcy5lbmZvcmNlTWluTWF4VmFsdWVzKGUsIHRoaXMubWluQnVmZmVyLCB0aGlzLm1heEJ1ZmZlciwgaSk7XHJcbiAgICAgICAgfSB9KSkpO1xyXG4gICAgfSksIGgkMShcImRpdlwiLCB7IGNsYXNzOiBcImNvbFwiIH0sIGgkMShcImNhbGNpdGUtc2VsZWN0XCIsIHsgb25DYWxjaXRlU2VsZWN0Q2hhbmdlOiAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXQudmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVCdWZmZXJVbml0Q2hhbmdlKHZhbHVlKTtcclxuICAgICAgfSB9LCBidWZmZXJUeXBlID09PSAndGltZScgJiYgKGgkMShcImNhbGNpdGUtb3B0aW9uXCIsIHsgdmFsdWU6IFwibWludXRlc1wiLCBzZWxlY3RlZDogdGhpcy5idWZmZXJEYXRhW3RhYl0uYnVmZmVyVW5pdCA9PT0gJ21pbnV0ZXMnIH0sIEJhUmVwb3J0c0xhbmd1YWdlLmkxOG4oJ21pbnV0ZXMnKSkpLCBoJDEoXCJjYWxjaXRlLW9wdGlvblwiLCB7IHZhbHVlOiBcIm1pbGVzXCIsIHNlbGVjdGVkOiB0aGlzLmJ1ZmZlckRhdGFbdGFiXS5idWZmZXJVbml0ID09PSAnbWlsZXMnIH0sIEJhUmVwb3J0c0xhbmd1YWdlLmkxOG4oJ21pbGVzTG93ZXJjYXNlJykpLCBoJDEoXCJjYWxjaXRlLW9wdGlvblwiLCB7IHZhbHVlOiBcImtpbG9tZXRlcnNcIiwgc2VsZWN0ZWQ6IHRoaXMuYnVmZmVyRGF0YVt0YWJdLmJ1ZmZlclVuaXQgPT09ICdraWxvbWV0ZXJzJyB9LCBCYVJlcG9ydHNMYW5ndWFnZS5pMThuKCdraWxvbWV0ZXJBYmJyZXZpYXRpb24nKSkpKSkpO1xyXG4gIH1cclxuICByZW5kZXIoKSB7XHJcbiAgICBjb25zdCBpbnRyb1RleHQgPSAodGhpcy5iYXNlQ29uZmlnLmNvbmZpZykgPyB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93SW50cm9UZXh0QnVmZmVycyA6ICcnOyAvLyBjb25zdCB7d29ya2Zsb3dJbnRyb1RleHRCdWZmZXJzfSA9IHRoaXMuX2Jhc2UuY29uZmlnO1xyXG4gICAgY29uc3QgYWN0aXZlVGFiID0gdGhpcy5iYXNlQ29uZmlnLmNvbmZpZy53b3JrZmxvd0F2YWlsYWJsZUJ1ZmZlclJpbmdzID8gXCJyaW5nc1wiIDogdGhpcy5iYXNlQ29uZmlnLmNvbmZpZy53b3JrZmxvd0F2YWlsYWJsZUJ1ZmZlckRyaXZldGltZSA/IFwiZHRcIiA6IFwid3RcIjtcclxuICAgIEJhUmVwb3J0c0xhbmd1YWdlLl9pbml0aWFsaXplKHRoaXMubGFuZ0NvZGUpO1xyXG4gICAgcmV0dXJuIChoJDEoXCJkaXZcIiwgbnVsbCwgaCQxKFwiZGl2XCIsIHsgY2xhc3M6ICdmbGV4LWdyaWQnIH0sIHRoaXMuYmFzZUNvbmZpZy5jb25maWcud29ya2Zsb3dJbnRyb1RleHRCdWZmZXJzQ2hlY2tib3ggJiZcclxuICAgICAgaCQxKFwiZGl2XCIsIHsgY2xhc3M6IFwiYXJjZ2lzQnVmZmVyc1N0ZXBEZXNjcmlwdGlvblwiIH0sIGludHJvVGV4dCkpLCBoJDEoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXgtZ3JpZCcgfSwgaCQxKFwiZGl2XCIsIHsgY2xhc3M6IFwiY29sXCIgfSwgaCQxKFwiY2FsY2l0ZS10YWJzXCIsIG51bGwsIGgkMShcImNhbGNpdGUtdGFiLW5hdlwiLCB7IHNsb3Q6IFwidGl0bGUtZ3JvdXBcIiB9LCB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyUmluZ3MgJiZcclxuICAgICAgaCQxKFwiY2FsY2l0ZS10YWItdGl0bGVcIiwgeyBhY3RpdmU6IGFjdGl2ZVRhYiA9PT0gXCJyaW5nc1wiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmhhbmRsZVRhYkNsaWNrKEJ1ZmZlclR5cGVzVmFsdWVzLnJpbmcpIH0sIEJhUmVwb3J0c0xhbmd1YWdlLmkxOG4oJ3JpbmdzJykpLCB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyRHJpdmV0aW1lICYmXHJcbiAgICAgIGgkMShcImNhbGNpdGUtdGFiLXRpdGxlXCIsIHsgYWN0aXZlOiBhY3RpdmVUYWIgPT09IFwiZHRcIiwgb25DbGljazogKCkgPT4gdGhpcy5oYW5kbGVUYWJDbGljayhCdWZmZXJUeXBlc1ZhbHVlcy5kcml2ZXRpbWUpIH0sIEJhUmVwb3J0c0xhbmd1YWdlLmkxOG4oJ2RyaXZldGltZScpKSwgdGhpcy5iYXNlQ29uZmlnLmNvbmZpZy53b3JrZmxvd0F2YWlsYWJsZUJ1ZmZlcldhbGt0aW1lICYmXHJcbiAgICAgIGgkMShcImNhbGNpdGUtdGFiLXRpdGxlXCIsIHsgYWN0aXZlOiBhY3RpdmVUYWIgPT09IFwid3RcIiwgb25DbGljazogKCkgPT4gdGhpcy5oYW5kbGVUYWJDbGljayhCdWZmZXJUeXBlc1ZhbHVlcy53YWxrdGltZSkgfSwgQmFSZXBvcnRzTGFuZ3VhZ2UuaTE4bignd2Fsa3RpbWUnKSkpLCB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyUmluZ3MgJiZcclxuICAgICAgaCQxKFwiY2FsY2l0ZS10YWJcIiwgeyBhY3RpdmU6IGFjdGl2ZVRhYiA9PT0gXCJyaW5nc1wiLCBzZWxlY3RlZDogYWN0aXZlVGFiID09PSBcInJpbmdzXCIgfSwgdGhpcy5nZXRDYWxjaXRlVGFiKCdyYWRpdXMnLCBCYVJlcG9ydHNMYW5ndWFnZS5pMThuKCdyYWRpdXMnKSwgQnVmZmVyVHlwZXNWYWx1ZXMucmluZykpLCB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93QXZhaWxhYmxlQnVmZmVyRHJpdmV0aW1lICYmXHJcbiAgICAgIGgkMShcImNhbGNpdGUtdGFiXCIsIHsgYWN0aXZlOiBhY3RpdmVUYWIgPT09IFwiZHRcIiwgc2VsZWN0ZWQ6IGFjdGl2ZVRhYiA9PT0gXCJkdFwiIH0sIHRoaXMuZ2V0Q2FsY2l0ZVRhYigndGltZScsIEJhUmVwb3J0c0xhbmd1YWdlLmkxOG4oJ3RpbWUnKSwgQnVmZmVyVHlwZXNWYWx1ZXMuZHJpdmV0aW1lKSksIHRoaXMuYmFzZUNvbmZpZy5jb25maWcud29ya2Zsb3dBdmFpbGFibGVCdWZmZXJXYWxrdGltZSAmJlxyXG4gICAgICBoJDEoXCJjYWxjaXRlLXRhYlwiLCB7IGFjdGl2ZTogYWN0aXZlVGFiID09PSBcInd0XCIsIHNlbGVjdGVkOiBhY3RpdmVUYWIgPT09IFwid3RcIiB9LCB0aGlzLmdldENhbGNpdGVUYWIoJ3RpbWUnLCBCYVJlcG9ydHNMYW5ndWFnZS5pMThuKCd0aW1lJyksIEJ1ZmZlclR5cGVzVmFsdWVzLndhbGt0aW1lKSkpKSkpKTtcclxuICB9XHJcbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCQxKHRoaXMpOyB9XHJcbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcclxuICAgIFwiY29uZmlnXCI6IFtcIm9uQ29uZmlnQ2hhbmdlXCJdLFxyXG4gICAgXCJ0aGVtZVwiOiBbXCJvblRoZW1lQ2hhbmdlZFwiXSxcclxuICAgIFwiY3VycmVudEJ1ZmZlclR5cGVcIjogW1wib25CdWZmZXJUeXBlQ2hhbmdlXCJdXHJcbiAgfTsgfVxyXG59O1xyXG5CdWZmZXJzU3RlcC5zdHlsZSA9IGJ1ZmZlcnNTdGVwQ3NzO1xuXG5jb25zdCBpbmZvZ3JhcGhpY3NTdGVwQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmJsb2NrfS5mbGV4LWdyaWR7ZGlzcGxheTpmbGV4fS5mbGV4LWdyaWQgLmNvbHtmbGV4OjF9LndmLWluZm9ncmFwaGljLXNlbGVjdG9ye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOmNhbGMoMTAwJSAtIDEwcHgpO2hlaWdodDo0MHB4fS5hcmNnaXNJbmZvZ3JhcGhpY3NTdGVwRGVzY3JpcHRpb257bWFyZ2luLWJvdHRvbTo4cHh9XCI7XG5cbmNvbnN0IEluZm9ncmFwaGljc1N0ZXAgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xyXG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcclxuICAgIHRoaXMuX2lkUHJlZml4ID0gJ2luZm9ncmFwaGljcy1zdGVwLSc7XHJcbiAgICB0aGlzLl9pZFByZWZpeFJlcG9ydHMgPSAnaW5mb2dyYXBoaWNzLXN0ZXAtY29tcC0nO1xyXG4gICAgdGhpcy5faWRQcmVmaXhSZXBvcnRzQ29udCA9ICdpbmZvZ3JhcGhpY3MtcmVwb3J0LWNvbnQtJztcclxuICAgIHRoaXMuYmFzZUNvbmZpZyA9IG5ldyBCYXNlVXRpbCgnaW5mb2dyYXBoaWNzLXN0ZXAnLCB0aGlzLCB0aGlzLm9uVXBkYXRlVUkpO1xyXG4gIH1cclxuICAvL1xyXG4gIC8vIFVwZGF0ZSBQcm9wcy9TdGF0ZXMgd2hlbiB0aGUgbWFpbiBjb25maWcgY2hhbmdlc1xyXG4gIG9uQ29uZmlnQ2hhbmdlKG5ld0NvbmZpZywgb2xkQ29uZmlnKSB7XHJcbiAgICBpZiAoIW5ld0NvbmZpZyB8fCB0eXBlb2YgbmV3Q29uZmlnICE9ICdzdHJpbmcnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChBQ0xVdGlscy5oYXNUZXh0KG5ld0NvbmZpZykpIHtcclxuICAgICAgY29uc3QgbmV3Q2ZnID0gSlNPTi5wYXJzZShuZXdDb25maWcpO1xyXG4gICAgICBjb25zdCBvbGRDZmcgPSAob2xkQ29uZmlnICYmIEFDTFV0aWxzLmhhc1RleHQob2xkQ29uZmlnKSkgPyBKU09OLnBhcnNlKG9sZENvbmZpZykgOiBudWxsO1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBDT0xPUlM6XHJcbiAgICAgIC8vIGRlZmluZSBhIHRlbXAgY29sb3Igb2JqZWN0IHNvIHRoYXQgd2UgdXBkYXRlIHRoZSAnY29sb3JzJyBQcm9wIG9uZSB0aW1lXHJcbiAgICAgIHRoaXMuYmFzZUNvbmZpZy51cGRhdGVDb25maWcobmV3Q2ZnLCBvbGRDZmcpO1xyXG4gICAgfVxyXG4gIH1cclxuICBvblRoZW1lQ2hhbmdlZCgpIHtcclxuICAgIHRoaXMuc3RUaGVtZSA9IHRoaXMudGhlbWU7XHJcbiAgICB0aGlzLmJhc2VDb25maWcuc2V0VGhlbWUodGhpcy50aGVtZSk7XHJcbiAgfVxyXG4gIHNldExvY2FsZVN0cmluZ3MoKSB7XHJcbiAgICAvLyBUT0RPOiBpbml0aWFsaXplIGxvY2FsZSBzdHJpbmdzIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gIH1cclxuICBfbG9hZEluc3RhbmNlcygpIHtcclxuICAgIGlmICghdGhpcy5faW5zdGFuY2VJZClcclxuICAgICAgdGhpcy5faW5zdGFuY2VJZCA9IEVsZW1lbnRJZHMuZ2VuZXJhdGVJZCh0aGlzLl9pZFByZWZpeCkuaWQ7XHJcbiAgICBpZiAoIXRoaXMuX3JlcG9ydHNJZClcclxuICAgICAgdGhpcy5fcmVwb3J0c0lkID0gRWxlbWVudElkcy5nZW5lcmF0ZUlkKHRoaXMuX2lkUHJlZml4UmVwb3J0cykuaWQ7XHJcbiAgICBpZiAoIXRoaXMuX3JlcG9ydHNDb250SWQpXHJcbiAgICAgIHRoaXMuX3JlcG9ydHNDb250SWQgPSBFbGVtZW50SWRzLmdlbmVyYXRlSWQodGhpcy5faWRQcmVmaXhSZXBvcnRzQ29udCkuaWQ7XHJcbiAgfVxyXG4gIG9uVXBkYXRlVUkoKSB7XHJcbiAgICB0aGlzLmFwcGx5U3R5bGVzKCk7XHJcbiAgfVxyXG4gIGFwcGx5U3R5bGVzKCkge1xyXG4gICAgaWYgKHRoaXMuYmFzZUNvbmZpZz8uY29uZmlnPy5jb2xvcnMgJiYgT2JqZWN0LmtleXModGhpcy5iYXNlQ29uZmlnLmNvbmZpZy5jb2xvcnMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgYyA9IHRoaXMuYmFzZUNvbmZpZy5jb25maWcuY29sb3JzO1xyXG4gICAgICBjb25zdCBpbmZvZ3JhcGhpY1NlbGVjdG9yID0gQUNMVXRpbHMucXVlcnlFbGVtZW50LmNhbGwodGhpcy5lbCwgJ2FyY2dpcy1pbmZvZ3JhcGhpYy1zZWxlY3RvcicpO1xyXG4gICAgICBpZiAoaW5mb2dyYXBoaWNTZWxlY3RvciAmJiBpbmZvZ3JhcGhpY1NlbGVjdG9yLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGluZm9ncmFwaGljU2VsZWN0b3Iuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiZGl2LmluZm9ncmFwaGljU2VsZWN0b3JPdXRlclwiKTtcclxuICAgICAgICBpZiAoc2VsZWN0b3IgJiYgJ3N0eWxlJyBpbiBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgc2VsZWN0b3Iuc3R5bGUuc2V0UHJvcGVydHkoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGMuZm9yZWdyb3VuZCk7XHJcbiAgICAgICAgICBzZWxlY3Rvci5zdHlsZS5zZXRQcm9wZXJ0eShcImJvcmRlclwiLCAnc29saWQgMXB4ICcgKyBjLmJvcmRlcik7XHJcbiAgICAgICAgICBjb25zdCBwb3BvdmVyID0gaW5mb2dyYXBoaWNTZWxlY3Rvci5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLXBvcG92ZXJcIik7XHJcbiAgICAgICAgICBpZiAocG9wb3ZlciAmJiAnc3R5bGUnIGluIHBvcG92ZXIpIHtcclxuICAgICAgICAgICAgcG9wb3Zlci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tY2FsY2l0ZS11aS1ib3JkZXItaW5wdXRcIiwgJ3Vuc2V0Jyk7XHJcbiAgICAgICAgICAgIHBvcG92ZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLWNhbGNpdGUtdWktZm9yZWdyb3VuZC0xXCIsIGMuZm9yZWdyb3VuZCk7XHJcbiAgICAgICAgICAgIHBvcG92ZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLWNhbGNpdGUtdWktYnJhbmRcIiwgYy5icmFuZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xyXG4gICAgLy8gY29uc29sZS5sb2coJyVjIGluZm9ncmFwaGljcy1zdGVwIHdpbGxMb2FkJywgJ2ZvbnQtc2l6ZTo4cHQ7Y29sb3I6b3JhbmdlOycpXHJcbiAgICBpZiAodGhpcy5jb25maWcgJiYgdHlwZW9mIHRoaXMuY29uZmlnID09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRoaXMub25Db25maWdDaGFuZ2UodGhpcy5jb25maWcsICcnKTtcclxuICAgIH1cclxuICAgIC8vIGlmICh0aGlzLnRoZW1lKSB7XHJcbiAgICAvLyAgIHRoaXMuYmFzZUNvbmZpZy5zZXRUaGVtZSh0aGlzLnRoZW1lKVxyXG4gICAgLy8gfSBlbHNlIHtcclxuICAgIC8vICAgdGhpcy5iYXNlQ29uZmlnLnNldFRoZW1lKCdsaWdodCcpXHJcbiAgICAvLyB9XHJcbiAgICB0aGlzLl9sb2FkSW5zdGFuY2VzKCk7XHJcbiAgfVxyXG4gIC8vIFN0ZW5jaWwgbGlmZWN5Y2xlIC0gY2FsbGVkIG9uY2UgYWZ0ZXIgY29tcG9uZW50IGlzIGZ1bGx5IGxvYWRlZCBhbmQgMXN0IHJlbmRlciBvY2N1cnJlZFxyXG4gIGNvbXBvbmVudERpZExvYWQoKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZygnJWMgaW5mb2dyYXBoaWNzLXN0ZXAgZGlkVXBkYXRlJywgJ2ZvbnQtc2l6ZTo4cHQ7Y29sb3I6b3JhbmdlOycpXHJcbiAgICB0aGlzLl9sb2FkSW5zdGFuY2VzKCk7XHJcbiAgICAvLyBjb25zdCB7IHVzZXJuYW1lLCB0b2tlbiwgZW52LCBzb3VyY2VDb3VudHJ5LCBsYW5nQ29kZSwgcmVwb3J0TGlzdCB9ID0gdGhpcy5jb25maWdPYmo7XHJcbiAgICBjb25zdCByZXBvcnRzRWxlbSA9ICh0aGlzLl9yZXBvcnRzSWQpID8gdGhpcy5lbC5zaGFkb3dSb290Py5xdWVyeVNlbGVjdG9yKGAjJHt0aGlzLl9yZXBvcnRzSWR9YCkgOiBudWxsO1xyXG4gICAgaWYgKHJlcG9ydHNFbGVtKSB7XHJcbiAgICAgIGNvbnN0IGIgPSB0aGlzLmJhc2VDb25maWcuY29uZmlnO1xyXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgIHJlcG9ydHNFbGVtLmluaXRpYWxpemUoYi51c2VybmFtZSwgYi50b2tlbiwgYi5lbnYsIGIuc291cmNlQ291bnRyeSwgYi5sYW5nQ29kZSwgSlNPTi5zdHJpbmdpZnkoYi5yZXBvcnRMaXN0KSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5iYXNlQ29uZmlnKSB7XHJcbiAgICAgIHRoaXMuYmFzZUNvbmZpZy5vbkNvbXBvbmVudEhhc1JlbmRlcmVkKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIFN0ZW5jaWwgbGlmZWN5Y2xlIC0gY2FsbGVkIGp1c3QgYWZ0ZXIgY29tcG9uZW50IHVwZGF0ZXMsIGJ1dCBub3QgY2FsbGVkIGR1cmluZyBmaXJzdCByZW5kZXIoKVxyXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcclxuICAgIGlmICh0aGlzLmJhc2VDb25maWcpIHtcclxuICAgICAgdGhpcy5iYXNlQ29uZmlnLm9uQ29tcG9uZW50SGFzUmVuZGVyZWQoKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3QgdXNlciA9IHRoaXMuYmFzZUNvbmZpZy5jb25maWcudXNlcm5hbWU7XHJcbiAgICBjb25zdCBlbnYgPSB0aGlzLmJhc2VDb25maWcuY29uZmlnLmVudjtcclxuICAgIGNvbnN0IHRva2VuID0gdGhpcy5iYXNlQ29uZmlnLmNvbmZpZy50b2tlbjtcclxuICAgIGNvbnN0IGdVcmwgPSB0aGlzLmJhc2VDb25maWcuY29uZmlnLmdlb2VucmljaG1lbnRVcmw7XHJcbiAgICBjb25zdCBjb3VudHJ5ID0gdGhpcy5iYXNlQ29uZmlnLmNvbmZpZy5zZWxlY3RlZENvdW50cnk7XHJcbiAgICBjb25zdCByZXBvcnRzID0gdGhpcy5iYXNlQ29uZmlnLmNvbmZpZy5yZXBvcnRMaXN0O1xyXG4gICAgY29uc3QgbGFuZyA9IHRoaXMuYmFzZUNvbmZpZy5jb25maWcubGFuZ0NvZGU7XHJcbiAgICBjb25zdCBpbnRyb1RleHRDaGsgPSB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93SW50cm9UZXh0UmVwb3J0Q2hlY2tib3g7XHJcbiAgICBjb25zdCBpbnRyb1RleHRSZXAgPSB0aGlzLmJhc2VDb25maWcuY29uZmlnLndvcmtmbG93SW50cm9UZXh0UmVwb3J0cztcclxuICAgIGNvbnN0IGNmZyA9IHtcclxuICAgICAgZW52OiBlbnYsXHJcbiAgICAgIHVzZXJuYW1lOiB1c2VyLFxyXG4gICAgICB0b2tlbjogdG9rZW4sXHJcbiAgICAgIGdlb2VucmljaG1lbnRVcmw6IGdVcmwsXHJcbiAgICAgIHNvdXJjZUNvdW50cnk6IGNvdW50cnksXHJcbiAgICAgIGxhbmdDb2RlOiBsYW5nLFxyXG4gICAgICBzZWxlY3RlZFJlcG9ydElkOiB0aGlzLnNlbGVjdGVkUmVwb3J0LFxyXG4gICAgICByZXBvcnRMaXN0OiBKU09OLnN0cmluZ2lmeShyZXBvcnRzKSxcclxuICAgICAgX3BhcmVudENvbmZpZ0lkOiB0aGlzLmJhc2VDb25maWcuY29uZmlnSW5zdGFuY2VJZFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNDZmcgPSBKU09OLnN0cmluZ2lmeShjZmcpO1xyXG4gICAgcmV0dXJuIChoJDEoSG9zdCQxLCBudWxsLCBoJDEoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXgtZ3JpZCcgfSwgaW50cm9UZXh0Q2hrICYmXHJcbiAgICAgIGgkMShcImRpdlwiLCB7IGNsYXNzOiAnYXJjZ2lzSW5mb2dyYXBoaWNzU3RlcERlc2NyaXB0aW9uJyB9LCBpbnRyb1RleHRSZXApKSwgaCQxKFwiZGl2XCIsIHsgY2xhc3M6ICdmbGV4LWdyaWQnIH0sIGgkMShcImRpdlwiLCB7IGNsYXNzOiAnY29sJywgaWQ6IHRoaXMuX3JlcG9ydHNDb250SWQgfSwgaCQxKFwiZGl2XCIsIHsgY2xhc3M6IFwidHJlZS1jb250YWluZXJcIiB9LCBoJDEoXCJhcmNnaXMtaW5mb2dyYXBoaWMtc2VsZWN0b3JcIiwgeyBpZDogdGhpcy5fcmVwb3J0c0lkLCBwb3J0YWxPbmxpbmVHRVByb3h5OiB0aGlzLnBvcnRhbE9ubGluZUdFUHJveHksIGNvbmZpZzogc0NmZywgY2xhc3M6IFwid2YtaW5mb2dyYXBoaWMtc2VsZWN0b3JcIiB9KSkpKSkpO1xyXG4gIH1cclxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50JDEodGhpcyk7IH1cclxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xyXG4gICAgXCJjb25maWdcIjogW1wib25Db25maWdDaGFuZ2VcIl0sXHJcbiAgICBcInRoZW1lXCI6IFtcIm9uVGhlbWVDaGFuZ2VkXCJdXHJcbiAgfTsgfVxyXG59O1xyXG5JbmZvZ3JhcGhpY3NTdGVwLnN0eWxlID0gaW5mb2dyYXBoaWNzU3RlcENzcztcblxuZXhwb3J0IHsgdXBkYXRlTWVzc2FnZXMgYXMgQSwgQnVmZmVyVHlwZXNWYWx1ZXMgYXMgQiwgQnVmZmVyVW5pdHNWYWx1ZXMgYXMgQywgQnVmZmVyc1N0ZXAgYXMgRCwgU2VhcmNoU3RlcCBhcyBFLCBILCBJbmZvZ3JhcGhpY3NTdGVwIGFzIEksIFN0ZXBWYWx1ZXMgYXMgUywgY29ubmVjdExvY2FsaXplZCBhcyBhLCBzZXRDb21wb25lbnRMb2FkZWQgYXMgYiwgY3JlYXRlRXZlbnQgYXMgYywgZGVmaW5lQ3VzdG9tRWxlbWVudCQ4IGFzIGQsIGRpc2Nvbm5lY3RMb2NhbGl6ZWQgYXMgZSwgZm9jdXNFbGVtZW50SW5Hcm91cCBhcyBmLCBnZXRFbGVtZW50UHJvcCBhcyBnLCBoLCBIb3N0IGFzIGksIGNvbXBvbmVudExvYWRlZCBhcyBqLCBkZWZpbmVDdXN0b21FbGVtZW50JDcgYXMgaywgY3JlYXRlT2JzZXJ2ZXIgYXMgbCwgc3VibWl0Rm9ybSBhcyBtLCBudW1iZXJTdHJpbmdGb3JtYXR0ZXIgYXMgbiwgY29ubmVjdE1lc3NhZ2VzIGFzIG8sIHByb3h5Q3VzdG9tRWxlbWVudCBhcyBwLCBjb25uZWN0TGFiZWwgYXMgcSwgcmVzZXRGb3JtIGFzIHIsIHNldFVwTG9hZGFibGVDb21wb25lbnQgYXMgcywgdG9BcmlhQm9vbGVhbiBhcyB0LCB1cGRhdGVIb3N0SW50ZXJhY3Rpb24gYXMgdSwgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IGFzIHYsIGRpc2Nvbm5lY3RMYWJlbCBhcyB3LCBkaXNjb25uZWN0TWVzc2FnZXMgYXMgeCwgc2V0VXBNZXNzYWdlcyBhcyB5LCBnZXRMYWJlbFRleHQgYXMgeiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZvZ3JhcGhpY3Mtc3RlcC05ZTdmZmI4ZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=