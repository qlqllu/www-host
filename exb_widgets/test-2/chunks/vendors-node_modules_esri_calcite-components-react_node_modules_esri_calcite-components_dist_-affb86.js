"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_esri_calcite-components-react_node_modules_esri_calcite-components_dist_-affb86"],{

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/avatar.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/avatar.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Avatar),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/dom.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/utils.js");
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/icon.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */





/**
 * Convert a string to a valid hex by hashing its contents
 * and using the hash as a seed for three distinct color values
 *
 * @param str
 */
function stringToHex(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  let hex = "#";
  for (let j = 0; j < 3; j++) {
    const value = (hash >> (j * 8)) & 0xff;
    hex += ("00" + value.toString(16)).substr(-2);
  }
  return hex;
}
/**
 * Find the hue of a color given the separate RGB color channels
 *
 * @param rgb
 */
function rgbToHue(rgb) {
  let { r, g, b } = rgb;
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const delta = max - min;
  if (max === min) {
    return 0;
  }
  let hue = (max + min) / 2;
  switch (max) {
    case r:
      hue = (g - b) / delta + (g < b ? 6 : 0);
      break;
    case g:
      hue = (b - r) / delta + 2;
      break;
    case b:
      hue = (r - g) / delta + 4;
      break;
  }
  return Math.round(hue * 60);
}
/**
 * For a hex color, find the hue
 *
 * @param hex {string} - form of "#------"
 */
function hexToHue(hex) {
  return rgbToHue((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.g)(hex));
}

const avatarCss = ":host{display:inline-block;overflow:hidden;border-radius:50%}:host([scale=s]){block-size:1.5rem;inline-size:1.5rem;font-size:var(--calcite-font-size--3)}:host([scale=m]){block-size:2rem;inline-size:2rem;font-size:var(--calcite-font-size--2)}:host([scale=l]){block-size:2.75rem;inline-size:2.75rem;font-size:var(--calcite-font-size-0)}.icon{display:flex}.background{display:flex;block-size:100%;inline-size:100%;align-items:center;justify-content:center;border-radius:50%}.initials{font-weight:var(--calcite-font-weight-bold);text-transform:uppercase;color:var(--calcite-ui-text-2)}.thumbnail{block-size:100%;inline-size:100%;border-radius:50%}:host([hidden]){display:none}[hidden]{display:none}";

const Avatar = /*@__PURE__*/ (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_3__.proxyCustomElement)(class extends _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_3__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.scale = "m";
    this.thumbnail = undefined;
    this.fullName = undefined;
    this.username = undefined;
    this.userId = undefined;
    this.label = undefined;
    this.thumbnailFailedToLoad = false;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    return this.determineContent();
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  determineContent() {
    if (this.thumbnail && !this.thumbnailFailedToLoad) {
      return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_3__.h)("img", { alt: this.label || "", class: "thumbnail", onError: () => (this.thumbnailFailedToLoad = true), src: this.thumbnail }));
    }
    const initials = this.generateInitials();
    const backgroundColor = this.generateFillColor();
    return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_3__.h)("span", { "aria-label": this.label || this.fullName, class: "background", role: "figure", style: { backgroundColor } }, initials ? ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_3__.h)("span", { "aria-hidden": "true", class: "initials" }, initials)) : ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-icon", { class: "icon", icon: "user", scale: this.scale }))));
  }
  /**
   * Generate a valid background color that is consistent and unique to this user
   */
  generateFillColor() {
    const { userId, username, fullName, el } = this;
    const theme = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.r)(el);
    const id = userId && `#${userId.substr(userId.length - 6)}`;
    const name = username || fullName || "";
    const hex = id && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.i)(id) ? id : stringToHex(name);
    // if there is not unique information, or an invalid hex is produced, return a default
    if ((!userId && !name) || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.i)(hex)) {
      return `var(--calcite-ui-foreground-2)`;
    }
    const hue = hexToHue(hex);
    const l = theme === "dark" ? 20 : 90;
    return `hsl(${hue}, 60%, ${l}%)`;
  }
  /**
   * Use fullName or username to generate initials
   */
  generateInitials() {
    const { fullName, username } = this;
    if (fullName) {
      return fullName
        .trim()
        .split(" ")
        .map((name) => name.substring(0, 1))
        .join("");
    }
    else if (username) {
      return username.substring(0, 2);
    }
    return false;
  }
  get el() { return this; }
  static get style() { return avatarCss; }
}, [1, "calcite-avatar", {
    "scale": [513],
    "thumbnail": [513],
    "fullName": [513, "full-name"],
    "username": [513],
    "userId": [513, "user-id"],
    "label": [1],
    "thumbnailFailedToLoad": [32]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-avatar", "calcite-icon"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-avatar":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Avatar);
      }
      break;
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        (0,_icon_js__WEBPACK_IMPORTED_MODULE_2__.d)();
      }
      break;
  } });
}
defineCustomElement();




/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/icon.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/icon.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ Icon),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/index.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/dom.js");
/* harmony import */ var _observers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observers.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/observers.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */




const CSS = {
  icon: "icon",
  flipRtl: "flip-rtl",
};

/**
 * Icon data cache.
 * Exported for testing purposes.
 *
 * @private
 */
const iconCache = {};
/**
 * Icon request cache.
 * Exported for testing purposes.
 *
 * @private
 */
const requestCache = {};
const scaleToPx = {
  s: 16,
  m: 24,
  l: 32,
};
async function fetchIcon({ icon, scale }) {
  const size = scaleToPx[scale];
  const name = normalizeIconName(icon);
  const filled = name.charAt(name.length - 1) === "F";
  const iconName = filled ? name.substring(0, name.length - 1) : name;
  const id = `${iconName}${size}${filled ? "F" : ""}`;
  if (iconCache[id]) {
    return iconCache[id];
  }
  if (!requestCache[id]) {
    requestCache[id] = fetch((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.getAssetPath)(`./assets/icon/${id}.json`))
      .then((resp) => resp.json())
      .catch(() => {
      console.error(`"${id}" is not a valid calcite-ui-icon name`);
      return "";
    });
  }
  const path = await requestCache[id];
  iconCache[id] = path;
  return path;
}
/**
 * Normalize the icon name to match the path data module exports.
 * Exported for testing purposes.
 *
 * @param name â€“ an icon name that can be either kebab or camel-cased
 * @private
 */
function normalizeIconName(name) {
  const numberLeadingName = !isNaN(Number(name.charAt(0)));
  const parts = name.split("-");
  const kebabCased = parts.length > 0;
  if (kebabCased) {
    const firstNonDigitInPartPattern = /[a-z]/i;
    name = parts
      .map((part, partIndex) => {
      return part.replace(firstNonDigitInPartPattern, function replacer(match, offset) {
        const isFirstCharInName = partIndex === 0 && offset === 0;
        if (isFirstCharInName) {
          return match;
        }
        return match.toUpperCase();
      });
    })
      .join("");
  }
  return numberLeadingName ? `i${name}` : name;
}

const iconCss = ":host{display:inline-flex;color:var(--calcite-ui-icon-color)}:host([scale=s]){inline-size:16px;block-size:16px;min-inline-size:16px;min-block-size:16px}:host([scale=m]){inline-size:24px;block-size:24px;min-inline-size:24px;min-block-size:24px}:host([scale=l]){inline-size:32px;block-size:32px;min-inline-size:32px;min-block-size:32px}.flip-rtl{transform:scaleX(-1)}.svg{display:block}:host([hidden]){display:none}[hidden]{display:none}";

const Icon = /*@__PURE__*/ (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class extends _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.icon = null;
    this.flipRtl = false;
    this.scale = "m";
    this.textLabel = undefined;
    this.pathData = undefined;
    this.visible = false;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.waitUntilVisible(() => {
      this.visible = true;
      this.loadIconPathData();
    });
  }
  disconnectedCallback() {
    this.intersectionObserver?.disconnect();
    this.intersectionObserver = null;
  }
  async componentWillLoad() {
    this.loadIconPathData();
  }
  render() {
    const { el, flipRtl, pathData, scale, textLabel } = this;
    const dir = (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.b)(el);
    const size = scaleToPx[scale];
    const semantic = !!textLabel;
    const paths = [].concat(pathData || "");
    return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.Host, { "aria-hidden": (0,_dom_js__WEBPACK_IMPORTED_MODULE_0__.t)(!semantic), "aria-label": semantic ? textLabel : null, role: semantic ? "img" : null }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("svg", { "aria-hidden": "true", class: {
        [CSS.flipRtl]: dir === "rtl" && flipRtl,
        svg: true,
      }, fill: "currentColor", height: "100%", viewBox: `0 0 ${size} ${size}`, width: "100%", xmlns: "http://www.w3.org/2000/svg" }, paths.map((path) => typeof path === "string" ? ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { d: path })) : ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { d: path.d, opacity: "opacity" in path ? path.opacity : 1 }))))));
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  async loadIconPathData() {
    const { icon, scale, visible } = this;
    if (!_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.Build.isBrowser || !icon || !visible) {
      return;
    }
    const pathData = await fetchIcon({ icon, scale });
    // While the fetchIcon method is awaiting response, the icon requested can change. This check is to verify the response received belongs to the current icon.
    if (icon !== this.icon) {
      return;
    }
    this.pathData = pathData;
  }
  waitUntilVisible(callback) {
    this.intersectionObserver = (0,_observers_js__WEBPACK_IMPORTED_MODULE_1__.c)("intersection", (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.intersectionObserver.disconnect();
          this.intersectionObserver = null;
          callback();
        }
      });
    }, { rootMargin: "50px" });
    if (!this.intersectionObserver) {
      callback();
      return;
    }
    this.intersectionObserver.observe(this.el);
  }
  static get assetsDirs() { return ["assets"]; }
  get el() { return this; }
  static get watchers() { return {
    "icon": ["loadIconPathData"],
    "scale": ["loadIconPathData"]
  }; }
  static get style() { return iconCss; }
}, [1, "calcite-icon", {
    "icon": [513],
    "flipRtl": [516, "flip-rtl"],
    "scale": [513],
    "textLabel": [1, "text-label"],
    "pathData": [32],
    "visible": [32]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-icon"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-icon":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Icon);
      }
      break;
  } });
}
defineCustomElement();




/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/observers.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/observers.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createObserver)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/index.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */


/**
 * This utility ensures observers are created only for browser contexts.
 *
 * @param type - the type of observer to create
 * @param callback - the observer callback
 * @param options - the observer options
 */
function createObserver(type, callback, options) {
  if (!_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__.Build.isBrowser) {
    return undefined;
  }
  const Observer = getObserver(type);
  return new Observer(callback, options);
}
function getObserver(type) {
  // based on https://github.com/whatwg/dom/issues/126#issuecomment-1049814948
  class ExtendedMutationObserver extends window.MutationObserver {
    constructor(callback) {
      super(callback);
      this.observedEntry = [];
      this.callback = callback;
    }
    observe(target, options) {
      this.observedEntry.push({ target, options });
      return super.observe(target, options);
    }
    unobserve(target) {
      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);
      this.observedEntry = [];
      this.callback(super.takeRecords(), this);
      this.disconnect();
      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));
    }
  }
  return (function () {
    return (type === "intersection"
      ? window.IntersectionObserver
      : type === "mutation"
        ? ExtendedMutationObserver
        : window.ResizeObserver);
  })();
}




/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/utils.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/utils.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSSColorMode),
/* harmony export */   a: () => (/* binding */ alphaCompatible),
/* harmony export */   b: () => (/* binding */ alphaToOpacity),
/* harmony export */   c: () => (/* binding */ colorEqual),
/* harmony export */   d: () => (/* binding */ normalizeAlpha),
/* harmony export */   e: () => (/* binding */ normalizeColor),
/* harmony export */   f: () => (/* binding */ toAlphaMode),
/* harmony export */   g: () => (/* binding */ hexToRGB),
/* harmony export */   h: () => (/* binding */ hexify),
/* harmony export */   i: () => (/* binding */ isValidHex),
/* harmony export */   j: () => (/* binding */ isLonghandHex),
/* harmony export */   k: () => (/* binding */ hexChar),
/* harmony export */   n: () => (/* binding */ normalizeHex),
/* harmony export */   o: () => (/* binding */ opacityToAlpha),
/* harmony export */   p: () => (/* binding */ parseMode),
/* harmony export */   r: () => (/* binding */ rgbToHex),
/* harmony export */   t: () => (/* binding */ toNonAlphaMode)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */
const hexChar = /^[0-9A-F]$/i;
const shorthandHex = /^#[0-9A-F]{3}$/i;
const longhandHex = /^#[0-9A-F]{6}$/i;
const shorthandHexWithAlpha = /^#[0-9A-F]{4}$/i;
const longhandHexWithAlpha = /^#[0-9A-F]{8}$/i;
const alphaToOpacity = (alpha) => Number((alpha * 100).toFixed());
const opacityToAlpha = (opacity) => Number((opacity / 100).toFixed(2));
function isValidHex(hex, hasAlpha = false) {
  return isShorthandHex(hex, hasAlpha) || isLonghandHex(hex, hasAlpha);
}
function evaluateHex(hex, length, pattern) {
  if (!hex) {
    return false;
  }
  return hex.length === length && pattern.test(hex);
}
function isShorthandHex(hex, hasAlpha = false) {
  const hexLength = hasAlpha ? 5 : 4;
  const hexPattern = hasAlpha ? shorthandHexWithAlpha : shorthandHex;
  return evaluateHex(hex, hexLength, hexPattern);
}
function isLonghandHex(hex, hasAlpha = false) {
  const hexLength = hasAlpha ? 9 : 7;
  const hexPattern = hasAlpha ? longhandHexWithAlpha : longhandHex;
  return evaluateHex(hex, hexLength, hexPattern);
}
function normalizeHex(hex, hasAlpha = false, convertFromHexToHexa = false) {
  hex = hex.toLowerCase();
  if (!hex.startsWith("#")) {
    hex = `#${hex}`;
  }
  if (isShorthandHex(hex, hasAlpha)) {
    return rgbToHex(hexToRGB(hex, hasAlpha));
  }
  if (hasAlpha && convertFromHexToHexa && isValidHex(hex, false /* we only care about RGB hex for conversion */)) {
    const isShorthand = isShorthandHex(hex, false);
    return rgbToHex(hexToRGB(`${hex}${isShorthand ? "f" : "ff"}`, true));
  }
  return hex;
}
function hexify(color, hasAlpha = false) {
  return hasAlpha ? color.hexa() : color.hex();
}
function rgbToHex(color) {
  const { r, g, b } = color;
  const rChars = numToHex(r);
  const gChars = numToHex(g);
  const bChars = numToHex(b);
  const alphaChars = "a" in color ? numToHex(color.a * 255) : "";
  return `#${rChars}${gChars}${bChars}${alphaChars}`.toLowerCase();
}
function numToHex(num) {
  return num.toString(16).padStart(2, "0");
}
function normalizeAlpha(colorObject) {
  const normalized = { ...colorObject, a: colorObject.alpha ?? 1 /* Color() will omit alpha if 1 */ };
  delete normalized.alpha;
  return normalized;
}
function normalizeColor(alphaColorObject) {
  const normalized = { ...alphaColorObject, alpha: alphaColorObject.a ?? 1 };
  delete normalized.a;
  return normalized;
}
function hexToRGB(hex, hasAlpha = false) {
  if (!isValidHex(hex, hasAlpha)) {
    return null;
  }
  hex = hex.replace("#", "");
  let r;
  let g;
  let b;
  let a;
  const isShorthand = hex.length === 3 || hex.length === 4;
  if (isShorthand) {
    const [first, second, third, fourth] = hex.split("");
    r = parseInt(`${first}${first}`, 16);
    g = parseInt(`${second}${second}`, 16);
    b = parseInt(`${third}${third}`, 16);
    a = parseInt(`${fourth}${fourth}`, 16) / 255;
  }
  else {
    r = parseInt(hex.slice(0, 2), 16);
    g = parseInt(hex.slice(2, 4), 16);
    b = parseInt(hex.slice(4, 6), 16);
    a = parseInt(hex.slice(6, 8), 16) / 255;
  }
  return isNaN(a) ? { r, g, b } : { r, g, b, a };
}
// these utils allow users to pass enum values as strings without having to access the enum
// based on the approach suggested by https://github.com/microsoft/TypeScript/issues/17690#issuecomment-321365759,
const enumify = (x) => x;
const CSSColorMode = enumify({
  HEX: "hex",
  HEXA: "hexa",
  RGB_CSS: "rgb-css",
  RGBA_CSS: "rgba-css",
  HSL_CSS: "hsl-css",
  HSLA_CSS: "hsla-css",
});
const ObjectColorMode = enumify({
  RGB: "rgb",
  RGBA: "rgba",
  HSL: "hsl",
  HSLA: "hsla",
  HSV: "hsv",
  HSVA: "hsva",
});
function parseMode(colorValue) {
  if (typeof colorValue === "string") {
    if (colorValue.startsWith("#")) {
      const { length } = colorValue;
      if (length === 4 || length === 7) {
        return CSSColorMode.HEX;
      }
      if (length === 5 || length === 9) {
        return CSSColorMode.HEXA;
      }
    }
    if (colorValue.startsWith("rgba(")) {
      return CSSColorMode.RGBA_CSS;
    }
    if (colorValue.startsWith("rgb(")) {
      return CSSColorMode.RGB_CSS;
    }
    if (colorValue.startsWith("hsl(")) {
      return CSSColorMode.HSL_CSS;
    }
    if (colorValue.startsWith("hsla(")) {
      return CSSColorMode.HSLA_CSS;
    }
  }
  if (typeof colorValue === "object") {
    if (hasChannels(colorValue, "r", "g", "b")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.RGBA : ObjectColorMode.RGB;
    }
    if (hasChannels(colorValue, "h", "s", "l")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSLA : ObjectColorMode.HSL;
    }
    if (hasChannels(colorValue, "h", "s", "v")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSVA : ObjectColorMode.HSV;
    }
  }
  return null;
}
function hasChannels(colorObject, ...channels) {
  return channels.every((channel) => channel && colorObject && `${channel}` in colorObject);
}
function colorEqual(value1, value2) {
  return value1?.rgb().array().toString() === value2?.rgb().array().toString();
}
function alphaCompatible(mode) {
  return (mode === CSSColorMode.HEXA ||
    mode === CSSColorMode.RGBA_CSS ||
    mode === CSSColorMode.HSLA_CSS ||
    mode === ObjectColorMode.RGBA ||
    mode === ObjectColorMode.HSLA ||
    mode === ObjectColorMode.HSVA);
}
function toAlphaMode(mode) {
  const alphaMode = mode === CSSColorMode.HEX
    ? CSSColorMode.HEXA
    : mode === CSSColorMode.RGB_CSS
      ? CSSColorMode.RGBA_CSS
      : mode === CSSColorMode.HSL_CSS
        ? CSSColorMode.HSLA_CSS
        : mode === ObjectColorMode.RGB
          ? ObjectColorMode.RGBA
          : mode === ObjectColorMode.HSL
            ? ObjectColorMode.HSLA
            : mode === ObjectColorMode.HSV
              ? ObjectColorMode.HSVA
              : mode;
  return alphaMode;
}
function toNonAlphaMode(mode) {
  const nonAlphaMode = mode === CSSColorMode.HEXA
    ? CSSColorMode.HEX
    : mode === CSSColorMode.RGBA_CSS
      ? CSSColorMode.RGB_CSS
      : mode === CSSColorMode.HSLA_CSS
        ? CSSColorMode.HSL_CSS
        : mode === ObjectColorMode.RGBA
          ? ObjectColorMode.RGB
          : mode === ObjectColorMode.HSLA
            ? ObjectColorMode.HSL
            : mode === ObjectColorMode.HSVA
              ? ObjectColorMode.HSV
              : mode;
  return nonAlphaMode;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHMtcmVhY3Rfbm9kZV9tb2R1bGVzX2VzcmlfY2FsY2l0ZS1jb21wb25lbnRzX2Rpc3RfLWFmZmI4Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRGO0FBQ2hEO0FBQ2dCO0FBQ0w7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFRO0FBQzFCOztBQUVBLHlCQUF5QixxQkFBcUIsZ0JBQWdCLGtCQUFrQixpQkFBaUIsa0JBQWtCLG1CQUFtQixzQ0FBc0MsaUJBQWlCLGdCQUFnQixpQkFBaUIsc0NBQXNDLGlCQUFpQixtQkFBbUIsb0JBQW9CLHFDQUFxQyxNQUFNLGFBQWEsWUFBWSxhQUFhLGdCQUFnQixpQkFBaUIsbUJBQW1CLHVCQUF1QixrQkFBa0IsVUFBVSw0Q0FBNEMseUJBQXlCLCtCQUErQixXQUFXLGdCQUFnQixpQkFBaUIsa0JBQWtCLGdCQUFnQixhQUFhLFNBQVMsYUFBYTs7QUFFenNCLDZCQUE2QiwwRkFBa0IsZUFBZSwrRUFBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlFQUFDLFVBQVUsb0hBQW9IO0FBQzdJO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUVBQUMsV0FBVyx5RkFBeUYsbUJBQW1CLGNBQWMseUVBQUMsV0FBVywwQ0FBMEMsZ0JBQWdCLHlFQUFDLG1CQUFtQixnREFBZ0Q7QUFDNVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLGtCQUFrQiwwQ0FBVztBQUM3Qiw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0Esc0JBQXNCLDRDQUFVO0FBQ2hDO0FBQ0EsK0JBQStCLDRDQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUksU0FBUyxFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBcUI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVpRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hLakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1SDtBQUNyRDtBQUNiOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsRUFBRSxLQUFLLEVBQUUsa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9GQUFZLGtCQUFrQixHQUFHO0FBQzlEO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7O0FBRUEsdUJBQXVCLG9CQUFvQixtQ0FBbUMsaUJBQWlCLGlCQUFpQixnQkFBZ0IscUJBQXFCLG9CQUFvQixpQkFBaUIsaUJBQWlCLGdCQUFnQixxQkFBcUIsb0JBQW9CLGlCQUFpQixpQkFBaUIsZ0JBQWdCLHFCQUFxQixvQkFBb0IsVUFBVSxxQkFBcUIsS0FBSyxjQUFjLGdCQUFnQixhQUFhLFNBQVMsYUFBYTs7QUFFcGMsMkJBQTJCLDBGQUFrQixlQUFlLCtFQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQsZ0JBQWdCLDBDQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUVBQUMsQ0FBQyx3RUFBSSxJQUFJLGVBQWUsMENBQWEsdUZBQXVGLEVBQUUseUVBQUMsVUFBVTtBQUN0SjtBQUNBO0FBQ0EsT0FBTyx3REFBd0QsTUFBTSxFQUFFLEtBQUssdURBQXVELGtEQUFrRCx5RUFBQyxXQUFXLFNBQVMsTUFBTSx5RUFBQyxXQUFXLDBEQUEwRDtBQUN0UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFNBQVMseUVBQUs7QUFDZDtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssSUFBSSxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRStDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUwvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytEOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx5RUFBSztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEVBQUU7QUFDbkMsZ0NBQWdDLEVBQUU7QUFDbEMsMENBQTBDLEVBQUU7QUFDNUMseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLEVBQUUseUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU0sRUFBRSxNQUFNO0FBQ2xDLG9CQUFvQixPQUFPLEVBQUUsT0FBTztBQUNwQyxvQkFBb0IsTUFBTSxFQUFFLE1BQU07QUFDbEMsb0JBQW9CLE9BQU8sRUFBRSxPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVUsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMtcmVhY3Qvbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NvbXBvbmVudHMvYXZhdGFyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2ljb24uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMtcmVhY3Qvbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NvbXBvbmVudHMvb2JzZXJ2ZXJzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9tYWluL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4xMS4wXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGggfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyc7XG5pbXBvcnQgeyByIGFzIGdldE1vZGVOYW1lIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgZyBhcyBoZXhUb1JHQiwgaSBhcyBpc1ZhbGlkSGV4IH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMSB9IGZyb20gJy4vaWNvbi5qcyc7XG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0byBhIHZhbGlkIGhleCBieSBoYXNoaW5nIGl0cyBjb250ZW50c1xuICogYW5kIHVzaW5nIHRoZSBoYXNoIGFzIGEgc2VlZCBmb3IgdGhyZWUgZGlzdGluY3QgY29sb3IgdmFsdWVzXG4gKlxuICogQHBhcmFtIHN0clxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0hleChzdHIpIHtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGhhc2ggPSBzdHIuY2hhckNvZGVBdChpKSArICgoaGFzaCA8PCA1KSAtIGhhc2gpO1xuICB9XG4gIGxldCBoZXggPSBcIiNcIjtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IChoYXNoID4+IChqICogOCkpICYgMHhmZjtcbiAgICBoZXggKz0gKFwiMDBcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKTtcbiAgfVxuICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBodWUgb2YgYSBjb2xvciBnaXZlbiB0aGUgc2VwYXJhdGUgUkdCIGNvbG9yIGNoYW5uZWxzXG4gKlxuICogQHBhcmFtIHJnYlxuICovXG5mdW5jdGlvbiByZ2JUb0h1ZShyZ2IpIHtcbiAgbGV0IHsgciwgZywgYiB9ID0gcmdiO1xuICByIC89IDI1NTtcbiAgZyAvPSAyNTU7XG4gIGIgLz0gMjU1O1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgaHVlID0gKG1heCArIG1pbikgLyAyO1xuICBzd2l0Y2ggKG1heCkge1xuICAgIGNhc2UgcjpcbiAgICAgIGh1ZSA9IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZzpcbiAgICAgIGh1ZSA9IChiIC0gcikgLyBkZWx0YSArIDI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGI6XG4gICAgICBodWUgPSAociAtIGcpIC8gZGVsdGEgKyA0O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQoaHVlICogNjApO1xufVxuLyoqXG4gKiBGb3IgYSBoZXggY29sb3IsIGZpbmQgdGhlIGh1ZVxuICpcbiAqIEBwYXJhbSBoZXgge3N0cmluZ30gLSBmb3JtIG9mIFwiIy0tLS0tLVwiXG4gKi9cbmZ1bmN0aW9uIGhleFRvSHVlKGhleCkge1xuICByZXR1cm4gcmdiVG9IdWUoaGV4VG9SR0IoaGV4KSk7XG59XG5cbmNvbnN0IGF2YXRhckNzcyA9IFwiOmhvc3R7ZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1yYWRpdXM6NTAlfTpob3N0KFtzY2FsZT1zXSl7YmxvY2stc2l6ZToxLjVyZW07aW5saW5lLXNpemU6MS41cmVtO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMyl9Omhvc3QoW3NjYWxlPW1dKXtibG9jay1zaXplOjJyZW07aW5saW5lLXNpemU6MnJlbTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTIpfTpob3N0KFtzY2FsZT1sXSl7YmxvY2stc2l6ZToyLjc1cmVtO2lubGluZS1zaXplOjIuNzVyZW07Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLTApfS5pY29ue2Rpc3BsYXk6ZmxleH0uYmFja2dyb3VuZHtkaXNwbGF5OmZsZXg7YmxvY2stc2l6ZToxMDAlO2lubGluZS1zaXplOjEwMCU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Ym9yZGVyLXJhZGl1czo1MCV9LmluaXRpYWxze2ZvbnQtd2VpZ2h0OnZhcigtLWNhbGNpdGUtZm9udC13ZWlnaHQtYm9sZCk7dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0yKX0udGh1bWJuYWlse2Jsb2NrLXNpemU6MTAwJTtpbmxpbmUtc2l6ZToxMDAlO2JvcmRlci1yYWRpdXM6NTAlfTpob3N0KFtoaWRkZW5dKXtkaXNwbGF5Om5vbmV9W2hpZGRlbl17ZGlzcGxheTpub25lfVwiO1xuXG5jb25zdCBBdmF0YXIgPSAvKkBfX1BVUkVfXyovIHByb3h5Q3VzdG9tRWxlbWVudChjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVnaXN0ZXJIb3N0KCk7XG4gICAgdGhpcy5fX2F0dGFjaFNoYWRvdygpO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgICB0aGlzLnRodW1ibmFpbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxOYW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudXNlcm5hbWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy51c2VySWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRodW1ibmFpbEZhaWxlZFRvTG9hZCA9IGZhbHNlO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kZXRlcm1pbmVDb250ZW50KCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZGV0ZXJtaW5lQ29udGVudCgpIHtcbiAgICBpZiAodGhpcy50aHVtYm5haWwgJiYgIXRoaXMudGh1bWJuYWlsRmFpbGVkVG9Mb2FkKSB7XG4gICAgICByZXR1cm4gKGgoXCJpbWdcIiwgeyBhbHQ6IHRoaXMubGFiZWwgfHwgXCJcIiwgY2xhc3M6IFwidGh1bWJuYWlsXCIsIG9uRXJyb3I6ICgpID0+ICh0aGlzLnRodW1ibmFpbEZhaWxlZFRvTG9hZCA9IHRydWUpLCBzcmM6IHRoaXMudGh1bWJuYWlsIH0pKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbHMgPSB0aGlzLmdlbmVyYXRlSW5pdGlhbHMoKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdlbmVyYXRlRmlsbENvbG9yKCk7XG4gICAgcmV0dXJuIChoKFwic3BhblwiLCB7IFwiYXJpYS1sYWJlbFwiOiB0aGlzLmxhYmVsIHx8IHRoaXMuZnVsbE5hbWUsIGNsYXNzOiBcImJhY2tncm91bmRcIiwgcm9sZTogXCJmaWd1cmVcIiwgc3R5bGU6IHsgYmFja2dyb3VuZENvbG9yIH0gfSwgaW5pdGlhbHMgPyAoaChcInNwYW5cIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjbGFzczogXCJpbml0aWFsc1wiIH0sIGluaXRpYWxzKSkgOiAoaChcImNhbGNpdGUtaWNvblwiLCB7IGNsYXNzOiBcImljb25cIiwgaWNvbjogXCJ1c2VyXCIsIHNjYWxlOiB0aGlzLnNjYWxlIH0pKSkpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHZhbGlkIGJhY2tncm91bmQgY29sb3IgdGhhdCBpcyBjb25zaXN0ZW50IGFuZCB1bmlxdWUgdG8gdGhpcyB1c2VyXG4gICAqL1xuICBnZW5lcmF0ZUZpbGxDb2xvcigpIHtcbiAgICBjb25zdCB7IHVzZXJJZCwgdXNlcm5hbWUsIGZ1bGxOYW1lLCBlbCB9ID0gdGhpcztcbiAgICBjb25zdCB0aGVtZSA9IGdldE1vZGVOYW1lKGVsKTtcbiAgICBjb25zdCBpZCA9IHVzZXJJZCAmJiBgIyR7dXNlcklkLnN1YnN0cih1c2VySWQubGVuZ3RoIC0gNil9YDtcbiAgICBjb25zdCBuYW1lID0gdXNlcm5hbWUgfHwgZnVsbE5hbWUgfHwgXCJcIjtcbiAgICBjb25zdCBoZXggPSBpZCAmJiBpc1ZhbGlkSGV4KGlkKSA/IGlkIDogc3RyaW5nVG9IZXgobmFtZSk7XG4gICAgLy8gaWYgdGhlcmUgaXMgbm90IHVuaXF1ZSBpbmZvcm1hdGlvbiwgb3IgYW4gaW52YWxpZCBoZXggaXMgcHJvZHVjZWQsIHJldHVybiBhIGRlZmF1bHRcbiAgICBpZiAoKCF1c2VySWQgJiYgIW5hbWUpIHx8ICFpc1ZhbGlkSGV4KGhleCkpIHtcbiAgICAgIHJldHVybiBgdmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTIpYDtcbiAgICB9XG4gICAgY29uc3QgaHVlID0gaGV4VG9IdWUoaGV4KTtcbiAgICBjb25zdCBsID0gdGhlbWUgPT09IFwiZGFya1wiID8gMjAgOiA5MDtcbiAgICByZXR1cm4gYGhzbCgke2h1ZX0sIDYwJSwgJHtsfSUpYDtcbiAgfVxuICAvKipcbiAgICogVXNlIGZ1bGxOYW1lIG9yIHVzZXJuYW1lIHRvIGdlbmVyYXRlIGluaXRpYWxzXG4gICAqL1xuICBnZW5lcmF0ZUluaXRpYWxzKCkge1xuICAgIGNvbnN0IHsgZnVsbE5hbWUsIHVzZXJuYW1lIH0gPSB0aGlzO1xuICAgIGlmIChmdWxsTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bGxOYW1lXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnNwbGl0KFwiIFwiKVxuICAgICAgICAubWFwKChuYW1lKSA9PiBuYW1lLnN1YnN0cmluZygwLCAxKSlcbiAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVzZXJuYW1lKSB7XG4gICAgICByZXR1cm4gdXNlcm5hbWUuc3Vic3RyaW5nKDAsIDIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gYXZhdGFyQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLWF2YXRhclwiLCB7XG4gICAgXCJzY2FsZVwiOiBbNTEzXSxcbiAgICBcInRodW1ibmFpbFwiOiBbNTEzXSxcbiAgICBcImZ1bGxOYW1lXCI6IFs1MTMsIFwiZnVsbC1uYW1lXCJdLFxuICAgIFwidXNlcm5hbWVcIjogWzUxM10sXG4gICAgXCJ1c2VySWRcIjogWzUxMywgXCJ1c2VyLWlkXCJdLFxuICAgIFwibGFiZWxcIjogWzFdLFxuICAgIFwidGh1bWJuYWlsRmFpbGVkVG9Mb2FkXCI6IFszMl1cbiAgfV0pO1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCgpIHtcbiAgaWYgKHR5cGVvZiBjdXN0b21FbGVtZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gW1wiY2FsY2l0ZS1hdmF0YXJcIiwgXCJjYWxjaXRlLWljb25cIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtYXZhdGFyXCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgQXZhdGFyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjYWxjaXRlLWljb25cIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGRlZmluZUN1c3RvbUVsZW1lbnQkMSgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5kZWZpbmVDdXN0b21FbGVtZW50KCk7XG5cbmV4cG9ydCB7IEF2YXRhciBhcyBBLCBkZWZpbmVDdXN0b21FbGVtZW50IGFzIGQgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9tYWluL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4xMS4wXG4gKi9cbmltcG9ydCB7IGdldEFzc2V0UGF0aCwgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgaCwgSG9zdCwgQnVpbGQgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyc7XG5pbXBvcnQgeyBiIGFzIGdldEVsZW1lbnREaXIsIHQgYXMgdG9BcmlhQm9vbGVhbiB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlT2JzZXJ2ZXIgfSBmcm9tICcuL29ic2VydmVycy5qcyc7XG5cbmNvbnN0IENTUyA9IHtcbiAgaWNvbjogXCJpY29uXCIsXG4gIGZsaXBSdGw6IFwiZmxpcC1ydGxcIixcbn07XG5cbi8qKlxuICogSWNvbiBkYXRhIGNhY2hlLlxuICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWNvbkNhY2hlID0ge307XG4vKipcbiAqIEljb24gcmVxdWVzdCBjYWNoZS5cbiAqIEV4cG9ydGVkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHJlcXVlc3RDYWNoZSA9IHt9O1xuY29uc3Qgc2NhbGVUb1B4ID0ge1xuICBzOiAxNixcbiAgbTogMjQsXG4gIGw6IDMyLFxufTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoSWNvbih7IGljb24sIHNjYWxlIH0pIHtcbiAgY29uc3Qgc2l6ZSA9IHNjYWxlVG9QeFtzY2FsZV07XG4gIGNvbnN0IG5hbWUgPSBub3JtYWxpemVJY29uTmFtZShpY29uKTtcbiAgY29uc3QgZmlsbGVkID0gbmFtZS5jaGFyQXQobmFtZS5sZW5ndGggLSAxKSA9PT0gXCJGXCI7XG4gIGNvbnN0IGljb25OYW1lID0gZmlsbGVkID8gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKSA6IG5hbWU7XG4gIGNvbnN0IGlkID0gYCR7aWNvbk5hbWV9JHtzaXplfSR7ZmlsbGVkID8gXCJGXCIgOiBcIlwifWA7XG4gIGlmIChpY29uQ2FjaGVbaWRdKSB7XG4gICAgcmV0dXJuIGljb25DYWNoZVtpZF07XG4gIH1cbiAgaWYgKCFyZXF1ZXN0Q2FjaGVbaWRdKSB7XG4gICAgcmVxdWVzdENhY2hlW2lkXSA9IGZldGNoKGdldEFzc2V0UGF0aChgLi9hc3NldHMvaWNvbi8ke2lkfS5qc29uYCkpXG4gICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5qc29uKCkpXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihgXCIke2lkfVwiIGlzIG5vdCBhIHZhbGlkIGNhbGNpdGUtdWktaWNvbiBuYW1lYCk7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwYXRoID0gYXdhaXQgcmVxdWVzdENhY2hlW2lkXTtcbiAgaWNvbkNhY2hlW2lkXSA9IHBhdGg7XG4gIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGljb24gbmFtZSB0byBtYXRjaCB0aGUgcGF0aCBkYXRhIG1vZHVsZSBleHBvcnRzLlxuICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHBhcmFtIG5hbWUg4oCTIGFuIGljb24gbmFtZSB0aGF0IGNhbiBiZSBlaXRoZXIga2ViYWIgb3IgY2FtZWwtY2FzZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUljb25OYW1lKG5hbWUpIHtcbiAgY29uc3QgbnVtYmVyTGVhZGluZ05hbWUgPSAhaXNOYU4oTnVtYmVyKG5hbWUuY2hhckF0KDApKSk7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdChcIi1cIik7XG4gIGNvbnN0IGtlYmFiQ2FzZWQgPSBwYXJ0cy5sZW5ndGggPiAwO1xuICBpZiAoa2ViYWJDYXNlZCkge1xuICAgIGNvbnN0IGZpcnN0Tm9uRGlnaXRJblBhcnRQYXR0ZXJuID0gL1thLXpdL2k7XG4gICAgbmFtZSA9IHBhcnRzXG4gICAgICAubWFwKChwYXJ0LCBwYXJ0SW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBwYXJ0LnJlcGxhY2UoZmlyc3ROb25EaWdpdEluUGFydFBhdHRlcm4sIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdENoYXJJbk5hbWUgPSBwYXJ0SW5kZXggPT09IDAgJiYgb2Zmc2V0ID09PSAwO1xuICAgICAgICBpZiAoaXNGaXJzdENoYXJJbk5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9KVxuICAgICAgLmpvaW4oXCJcIik7XG4gIH1cbiAgcmV0dXJuIG51bWJlckxlYWRpbmdOYW1lID8gYGkke25hbWV9YCA6IG5hbWU7XG59XG5cbmNvbnN0IGljb25Dc3MgPSBcIjpob3N0e2Rpc3BsYXk6aW5saW5lLWZsZXg7Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS1pY29uLWNvbG9yKX06aG9zdChbc2NhbGU9c10pe2lubGluZS1zaXplOjE2cHg7YmxvY2stc2l6ZToxNnB4O21pbi1pbmxpbmUtc2l6ZToxNnB4O21pbi1ibG9jay1zaXplOjE2cHh9Omhvc3QoW3NjYWxlPW1dKXtpbmxpbmUtc2l6ZToyNHB4O2Jsb2NrLXNpemU6MjRweDttaW4taW5saW5lLXNpemU6MjRweDttaW4tYmxvY2stc2l6ZToyNHB4fTpob3N0KFtzY2FsZT1sXSl7aW5saW5lLXNpemU6MzJweDtibG9jay1zaXplOjMycHg7bWluLWlubGluZS1zaXplOjMycHg7bWluLWJsb2NrLXNpemU6MzJweH0uZmxpcC1ydGx7dHJhbnNmb3JtOnNjYWxlWCgtMSl9LnN2Z3tkaXNwbGF5OmJsb2NrfTpob3N0KFtoaWRkZW5dKXtkaXNwbGF5Om5vbmV9W2hpZGRlbl17ZGlzcGxheTpub25lfVwiO1xuXG5jb25zdCBJY29uID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmljb24gPSBudWxsO1xuICAgIHRoaXMuZmxpcFJ0bCA9IGZhbHNlO1xuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcbiAgICB0aGlzLnRleHRMYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhdGhEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMud2FpdFVudGlsVmlzaWJsZSgoKSA9PiB7XG4gICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5sb2FkSWNvblBhdGhEYXRhKCk7XG4gICAgfSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuICB9XG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIHRoaXMubG9hZEljb25QYXRoRGF0YSgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGVsLCBmbGlwUnRsLCBwYXRoRGF0YSwgc2NhbGUsIHRleHRMYWJlbCB9ID0gdGhpcztcbiAgICBjb25zdCBkaXIgPSBnZXRFbGVtZW50RGlyKGVsKTtcbiAgICBjb25zdCBzaXplID0gc2NhbGVUb1B4W3NjYWxlXTtcbiAgICBjb25zdCBzZW1hbnRpYyA9ICEhdGV4dExhYmVsO1xuICAgIGNvbnN0IHBhdGhzID0gW10uY29uY2F0KHBhdGhEYXRhIHx8IFwiXCIpO1xuICAgIHJldHVybiAoaChIb3N0LCB7IFwiYXJpYS1oaWRkZW5cIjogdG9BcmlhQm9vbGVhbighc2VtYW50aWMpLCBcImFyaWEtbGFiZWxcIjogc2VtYW50aWMgPyB0ZXh0TGFiZWwgOiBudWxsLCByb2xlOiBzZW1hbnRpYyA/IFwiaW1nXCIgOiBudWxsIH0sIGgoXCJzdmdcIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjbGFzczoge1xuICAgICAgICBbQ1NTLmZsaXBSdGxdOiBkaXIgPT09IFwicnRsXCIgJiYgZmxpcFJ0bCxcbiAgICAgICAgc3ZnOiB0cnVlLFxuICAgICAgfSwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgdmlld0JveDogYDAgMCAke3NpemV9ICR7c2l6ZX1gLCB3aWR0aDogXCIxMDAlXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSwgcGF0aHMubWFwKChwYXRoKSA9PiB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IChoKFwicGF0aFwiLCB7IGQ6IHBhdGggfSkpIDogKGgoXCJwYXRoXCIsIHsgZDogcGF0aC5kLCBvcGFjaXR5OiBcIm9wYWNpdHlcIiBpbiBwYXRoID8gcGF0aC5vcGFjaXR5IDogMSB9KSkpKSkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGxvYWRJY29uUGF0aERhdGEoKSB7XG4gICAgY29uc3QgeyBpY29uLCBzY2FsZSwgdmlzaWJsZSB9ID0gdGhpcztcbiAgICBpZiAoIUJ1aWxkLmlzQnJvd3NlciB8fCAhaWNvbiB8fCAhdmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXRoRGF0YSA9IGF3YWl0IGZldGNoSWNvbih7IGljb24sIHNjYWxlIH0pO1xuICAgIC8vIFdoaWxlIHRoZSBmZXRjaEljb24gbWV0aG9kIGlzIGF3YWl0aW5nIHJlc3BvbnNlLCB0aGUgaWNvbiByZXF1ZXN0ZWQgY2FuIGNoYW5nZS4gVGhpcyBjaGVjayBpcyB0byB2ZXJpZnkgdGhlIHJlc3BvbnNlIHJlY2VpdmVkIGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgaWNvbi5cbiAgICBpZiAoaWNvbiAhPT0gdGhpcy5pY29uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGF0aERhdGEgPSBwYXRoRGF0YTtcbiAgfVxuICB3YWl0VW50aWxWaXNpYmxlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKFwiaW50ZXJzZWN0aW9uXCIsIChlbnRyaWVzKSA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHsgcm9vdE1hcmdpbjogXCI1MHB4XCIgfSk7XG4gICAgaWYgKCF0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5lbCk7XG4gIH1cbiAgc3RhdGljIGdldCBhc3NldHNEaXJzKCkgeyByZXR1cm4gW1wiYXNzZXRzXCJdOyB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcImljb25cIjogW1wibG9hZEljb25QYXRoRGF0YVwiXSxcbiAgICBcInNjYWxlXCI6IFtcImxvYWRJY29uUGF0aERhdGFcIl1cbiAgfTsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gaWNvbkNzczsgfVxufSwgWzEsIFwiY2FsY2l0ZS1pY29uXCIsIHtcbiAgICBcImljb25cIjogWzUxM10sXG4gICAgXCJmbGlwUnRsXCI6IFs1MTYsIFwiZmxpcC1ydGxcIl0sXG4gICAgXCJzY2FsZVwiOiBbNTEzXSxcbiAgICBcInRleHRMYWJlbFwiOiBbMSwgXCJ0ZXh0LWxhYmVsXCJdLFxuICAgIFwicGF0aERhdGFcIjogWzMyXSxcbiAgICBcInZpc2libGVcIjogWzMyXVxuICB9XSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJjYWxjaXRlLWljb25cIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtaWNvblwiOlxuICAgICAgaWYgKCFjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIEljb24pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH0gfSk7XG59XG5kZWZpbmVDdXN0b21FbGVtZW50KCk7XG5cbmV4cG9ydCB7IEljb24gYXMgSSwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMTEuMFxuICovXG5pbXBvcnQgeyBCdWlsZCB9IGZyb20gJ0BzdGVuY2lsL2NvcmUvaW50ZXJuYWwvY2xpZW50L2luZGV4LmpzJztcblxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgZW5zdXJlcyBvYnNlcnZlcnMgYXJlIGNyZWF0ZWQgb25seSBmb3IgYnJvd3NlciBjb250ZXh0cy5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIG9ic2VydmVyIHRvIGNyZWF0ZVxuICogQHBhcmFtIGNhbGxiYWNrIC0gdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvYnNlcnZlciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGlmICghQnVpbGQuaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBPYnNlcnZlciA9IGdldE9ic2VydmVyKHR5cGUpO1xuICByZXR1cm4gbmV3IE9ic2VydmVyKGNhbGxiYWNrLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyKHR5cGUpIHtcbiAgLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9kb20vaXNzdWVzLzEyNiNpc3N1ZWNvbW1lbnQtMTA0OTgxNDk0OFxuICBjbGFzcyBFeHRlbmRlZE11dGF0aW9uT2JzZXJ2ZXIgZXh0ZW5kcyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgIHN1cGVyKGNhbGxiYWNrKTtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeSA9IFtdO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBvYnNlcnZlKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5vYnNlcnZlZEVudHJ5LnB1c2goeyB0YXJnZXQsIG9wdGlvbnMgfSk7XG4gICAgICByZXR1cm4gc3VwZXIub2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB1bm9ic2VydmUodGFyZ2V0KSB7XG4gICAgICBjb25zdCBuZXdPYnNlcnZlZEVudHJpZXMgPSB0aGlzLm9ic2VydmVkRW50cnkuZmlsdGVyKChvYnNlcnZlZCkgPT4gb2JzZXJ2ZWQudGFyZ2V0ICE9PSB0YXJnZXQpO1xuICAgICAgdGhpcy5vYnNlcnZlZEVudHJ5ID0gW107XG4gICAgICB0aGlzLmNhbGxiYWNrKHN1cGVyLnRha2VSZWNvcmRzKCksIHRoaXMpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBuZXdPYnNlcnZlZEVudHJpZXMuZm9yRWFjaCgob2JzZXJ2ZWQpID0+IHRoaXMub2JzZXJ2ZShvYnNlcnZlZC50YXJnZXQsIG9ic2VydmVkLm9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSBcImludGVyc2VjdGlvblwiXG4gICAgICA/IHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgOiB0eXBlID09PSBcIm11dGF0aW9uXCJcbiAgICAgICAgPyBFeHRlbmRlZE11dGF0aW9uT2JzZXJ2ZXJcbiAgICAgICAgOiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpO1xuICB9KSgpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVPYnNlcnZlciBhcyBjIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMTEuMFxuICovXG5jb25zdCBoZXhDaGFyID0gL15bMC05QS1GXSQvaTtcbmNvbnN0IHNob3J0aGFuZEhleCA9IC9eI1swLTlBLUZdezN9JC9pO1xuY29uc3QgbG9uZ2hhbmRIZXggPSAvXiNbMC05QS1GXXs2fSQvaTtcbmNvbnN0IHNob3J0aGFuZEhleFdpdGhBbHBoYSA9IC9eI1swLTlBLUZdezR9JC9pO1xuY29uc3QgbG9uZ2hhbmRIZXhXaXRoQWxwaGEgPSAvXiNbMC05QS1GXXs4fSQvaTtcbmNvbnN0IGFscGhhVG9PcGFjaXR5ID0gKGFscGhhKSA9PiBOdW1iZXIoKGFscGhhICogMTAwKS50b0ZpeGVkKCkpO1xuY29uc3Qgb3BhY2l0eVRvQWxwaGEgPSAob3BhY2l0eSkgPT4gTnVtYmVyKChvcGFjaXR5IC8gMTAwKS50b0ZpeGVkKDIpKTtcbmZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4LCBoYXNBbHBoYSA9IGZhbHNlKSB7XG4gIHJldHVybiBpc1Nob3J0aGFuZEhleChoZXgsIGhhc0FscGhhKSB8fCBpc0xvbmdoYW5kSGV4KGhleCwgaGFzQWxwaGEpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVIZXgoaGV4LCBsZW5ndGgsIHBhdHRlcm4pIHtcbiAgaWYgKCFoZXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IGxlbmd0aCAmJiBwYXR0ZXJuLnRlc3QoaGV4KTtcbn1cbmZ1bmN0aW9uIGlzU2hvcnRoYW5kSGV4KGhleCwgaGFzQWxwaGEgPSBmYWxzZSkge1xuICBjb25zdCBoZXhMZW5ndGggPSBoYXNBbHBoYSA/IDUgOiA0O1xuICBjb25zdCBoZXhQYXR0ZXJuID0gaGFzQWxwaGEgPyBzaG9ydGhhbmRIZXhXaXRoQWxwaGEgOiBzaG9ydGhhbmRIZXg7XG4gIHJldHVybiBldmFsdWF0ZUhleChoZXgsIGhleExlbmd0aCwgaGV4UGF0dGVybik7XG59XG5mdW5jdGlvbiBpc0xvbmdoYW5kSGV4KGhleCwgaGFzQWxwaGEgPSBmYWxzZSkge1xuICBjb25zdCBoZXhMZW5ndGggPSBoYXNBbHBoYSA/IDkgOiA3O1xuICBjb25zdCBoZXhQYXR0ZXJuID0gaGFzQWxwaGEgPyBsb25naGFuZEhleFdpdGhBbHBoYSA6IGxvbmdoYW5kSGV4O1xuICByZXR1cm4gZXZhbHVhdGVIZXgoaGV4LCBoZXhMZW5ndGgsIGhleFBhdHRlcm4pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSGV4KGhleCwgaGFzQWxwaGEgPSBmYWxzZSwgY29udmVydEZyb21IZXhUb0hleGEgPSBmYWxzZSkge1xuICBoZXggPSBoZXgudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFoZXguc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBoZXggPSBgIyR7aGV4fWA7XG4gIH1cbiAgaWYgKGlzU2hvcnRoYW5kSGV4KGhleCwgaGFzQWxwaGEpKSB7XG4gICAgcmV0dXJuIHJnYlRvSGV4KGhleFRvUkdCKGhleCwgaGFzQWxwaGEpKTtcbiAgfVxuICBpZiAoaGFzQWxwaGEgJiYgY29udmVydEZyb21IZXhUb0hleGEgJiYgaXNWYWxpZEhleChoZXgsIGZhbHNlIC8qIHdlIG9ubHkgY2FyZSBhYm91dCBSR0IgaGV4IGZvciBjb252ZXJzaW9uICovKSkge1xuICAgIGNvbnN0IGlzU2hvcnRoYW5kID0gaXNTaG9ydGhhbmRIZXgoaGV4LCBmYWxzZSk7XG4gICAgcmV0dXJuIHJnYlRvSGV4KGhleFRvUkdCKGAke2hleH0ke2lzU2hvcnRoYW5kID8gXCJmXCIgOiBcImZmXCJ9YCwgdHJ1ZSkpO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBoZXhpZnkoY29sb3IsIGhhc0FscGhhID0gZmFsc2UpIHtcbiAgcmV0dXJuIGhhc0FscGhhID8gY29sb3IuaGV4YSgpIDogY29sb3IuaGV4KCk7XG59XG5mdW5jdGlvbiByZ2JUb0hleChjb2xvcikge1xuICBjb25zdCB7IHIsIGcsIGIgfSA9IGNvbG9yO1xuICBjb25zdCByQ2hhcnMgPSBudW1Ub0hleChyKTtcbiAgY29uc3QgZ0NoYXJzID0gbnVtVG9IZXgoZyk7XG4gIGNvbnN0IGJDaGFycyA9IG51bVRvSGV4KGIpO1xuICBjb25zdCBhbHBoYUNoYXJzID0gXCJhXCIgaW4gY29sb3IgPyBudW1Ub0hleChjb2xvci5hICogMjU1KSA6IFwiXCI7XG4gIHJldHVybiBgIyR7ckNoYXJzfSR7Z0NoYXJzfSR7YkNoYXJzfSR7YWxwaGFDaGFyc31gLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBudW1Ub0hleChudW0pIHtcbiAgcmV0dXJuIG51bS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQWxwaGEoY29sb3JPYmplY3QpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHsgLi4uY29sb3JPYmplY3QsIGE6IGNvbG9yT2JqZWN0LmFscGhhID8/IDEgLyogQ29sb3IoKSB3aWxsIG9taXQgYWxwaGEgaWYgMSAqLyB9O1xuICBkZWxldGUgbm9ybWFsaXplZC5hbHBoYTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihhbHBoYUNvbG9yT2JqZWN0KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB7IC4uLmFscGhhQ29sb3JPYmplY3QsIGFscGhhOiBhbHBoYUNvbG9yT2JqZWN0LmEgPz8gMSB9O1xuICBkZWxldGUgbm9ybWFsaXplZC5hO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGhleFRvUkdCKGhleCwgaGFzQWxwaGEgPSBmYWxzZSkge1xuICBpZiAoIWlzVmFsaWRIZXgoaGV4LCBoYXNBbHBoYSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBoZXggPSBoZXgucmVwbGFjZShcIiNcIiwgXCJcIik7XG4gIGxldCByO1xuICBsZXQgZztcbiAgbGV0IGI7XG4gIGxldCBhO1xuICBjb25zdCBpc1Nob3J0aGFuZCA9IGhleC5sZW5ndGggPT09IDMgfHwgaGV4Lmxlbmd0aCA9PT0gNDtcbiAgaWYgKGlzU2hvcnRoYW5kKSB7XG4gICAgY29uc3QgW2ZpcnN0LCBzZWNvbmQsIHRoaXJkLCBmb3VydGhdID0gaGV4LnNwbGl0KFwiXCIpO1xuICAgIHIgPSBwYXJzZUludChgJHtmaXJzdH0ke2ZpcnN0fWAsIDE2KTtcbiAgICBnID0gcGFyc2VJbnQoYCR7c2Vjb25kfSR7c2Vjb25kfWAsIDE2KTtcbiAgICBiID0gcGFyc2VJbnQoYCR7dGhpcmR9JHt0aGlyZH1gLCAxNik7XG4gICAgYSA9IHBhcnNlSW50KGAke2ZvdXJ0aH0ke2ZvdXJ0aH1gLCAxNikgLyAyNTU7XG4gIH1cbiAgZWxzZSB7XG4gICAgciA9IHBhcnNlSW50KGhleC5zbGljZSgwLCAyKSwgMTYpO1xuICAgIGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KTtcbiAgICBiID0gcGFyc2VJbnQoaGV4LnNsaWNlKDQsIDYpLCAxNik7XG4gICAgYSA9IHBhcnNlSW50KGhleC5zbGljZSg2LCA4KSwgMTYpIC8gMjU1O1xuICB9XG4gIHJldHVybiBpc05hTihhKSA/IHsgciwgZywgYiB9IDogeyByLCBnLCBiLCBhIH07XG59XG4vLyB0aGVzZSB1dGlscyBhbGxvdyB1c2VycyB0byBwYXNzIGVudW0gdmFsdWVzIGFzIHN0cmluZ3Mgd2l0aG91dCBoYXZpbmcgdG8gYWNjZXNzIHRoZSBlbnVtXG4vLyBiYXNlZCBvbiB0aGUgYXBwcm9hY2ggc3VnZ2VzdGVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTc2OTAjaXNzdWVjb21tZW50LTMyMTM2NTc1OSxcbmNvbnN0IGVudW1pZnkgPSAoeCkgPT4geDtcbmNvbnN0IENTU0NvbG9yTW9kZSA9IGVudW1pZnkoe1xuICBIRVg6IFwiaGV4XCIsXG4gIEhFWEE6IFwiaGV4YVwiLFxuICBSR0JfQ1NTOiBcInJnYi1jc3NcIixcbiAgUkdCQV9DU1M6IFwicmdiYS1jc3NcIixcbiAgSFNMX0NTUzogXCJoc2wtY3NzXCIsXG4gIEhTTEFfQ1NTOiBcImhzbGEtY3NzXCIsXG59KTtcbmNvbnN0IE9iamVjdENvbG9yTW9kZSA9IGVudW1pZnkoe1xuICBSR0I6IFwicmdiXCIsXG4gIFJHQkE6IFwicmdiYVwiLFxuICBIU0w6IFwiaHNsXCIsXG4gIEhTTEE6IFwiaHNsYVwiLFxuICBIU1Y6IFwiaHN2XCIsXG4gIEhTVkE6IFwiaHN2YVwiLFxufSk7XG5mdW5jdGlvbiBwYXJzZU1vZGUoY29sb3JWYWx1ZSkge1xuICBpZiAodHlwZW9mIGNvbG9yVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoY29sb3JWYWx1ZS5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGNvbG9yVmFsdWU7XG4gICAgICBpZiAobGVuZ3RoID09PSA0IHx8IGxlbmd0aCA9PT0gNykge1xuICAgICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLkhFWDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPT09IDUgfHwgbGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuSEVYQTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbG9yVmFsdWUuc3RhcnRzV2l0aChcInJnYmEoXCIpKSB7XG4gICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLlJHQkFfQ1NTO1xuICAgIH1cbiAgICBpZiAoY29sb3JWYWx1ZS5zdGFydHNXaXRoKFwicmdiKFwiKSkge1xuICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5SR0JfQ1NTO1xuICAgIH1cbiAgICBpZiAoY29sb3JWYWx1ZS5zdGFydHNXaXRoKFwiaHNsKFwiKSkge1xuICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5IU0xfQ1NTO1xuICAgIH1cbiAgICBpZiAoY29sb3JWYWx1ZS5zdGFydHNXaXRoKFwiaHNsYShcIikpIHtcbiAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuSFNMQV9DU1M7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgY29sb3JWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcInJcIiwgXCJnXCIsIFwiYlwiKSkge1xuICAgICAgcmV0dXJuIGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiYVwiKSA/IE9iamVjdENvbG9yTW9kZS5SR0JBIDogT2JqZWN0Q29sb3JNb2RlLlJHQjtcbiAgICB9XG4gICAgaWYgKGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiaFwiLCBcInNcIiwgXCJsXCIpKSB7XG4gICAgICByZXR1cm4gaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJhXCIpID8gT2JqZWN0Q29sb3JNb2RlLkhTTEEgOiBPYmplY3RDb2xvck1vZGUuSFNMO1xuICAgIH1cbiAgICBpZiAoaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJoXCIsIFwic1wiLCBcInZcIikpIHtcbiAgICAgIHJldHVybiBoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcImFcIikgPyBPYmplY3RDb2xvck1vZGUuSFNWQSA6IE9iamVjdENvbG9yTW9kZS5IU1Y7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaGFzQ2hhbm5lbHMoY29sb3JPYmplY3QsIC4uLmNoYW5uZWxzKSB7XG4gIHJldHVybiBjaGFubmVscy5ldmVyeSgoY2hhbm5lbCkgPT4gY2hhbm5lbCAmJiBjb2xvck9iamVjdCAmJiBgJHtjaGFubmVsfWAgaW4gY29sb3JPYmplY3QpO1xufVxuZnVuY3Rpb24gY29sb3JFcXVhbCh2YWx1ZTEsIHZhbHVlMikge1xuICByZXR1cm4gdmFsdWUxPy5yZ2IoKS5hcnJheSgpLnRvU3RyaW5nKCkgPT09IHZhbHVlMj8ucmdiKCkuYXJyYXkoKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gYWxwaGFDb21wYXRpYmxlKG1vZGUpIHtcbiAgcmV0dXJuIChtb2RlID09PSBDU1NDb2xvck1vZGUuSEVYQSB8fFxuICAgIG1vZGUgPT09IENTU0NvbG9yTW9kZS5SR0JBX0NTUyB8fFxuICAgIG1vZGUgPT09IENTU0NvbG9yTW9kZS5IU0xBX0NTUyB8fFxuICAgIG1vZGUgPT09IE9iamVjdENvbG9yTW9kZS5SR0JBIHx8XG4gICAgbW9kZSA9PT0gT2JqZWN0Q29sb3JNb2RlLkhTTEEgfHxcbiAgICBtb2RlID09PSBPYmplY3RDb2xvck1vZGUuSFNWQSk7XG59XG5mdW5jdGlvbiB0b0FscGhhTW9kZShtb2RlKSB7XG4gIGNvbnN0IGFscGhhTW9kZSA9IG1vZGUgPT09IENTU0NvbG9yTW9kZS5IRVhcbiAgICA/IENTU0NvbG9yTW9kZS5IRVhBXG4gICAgOiBtb2RlID09PSBDU1NDb2xvck1vZGUuUkdCX0NTU1xuICAgICAgPyBDU1NDb2xvck1vZGUuUkdCQV9DU1NcbiAgICAgIDogbW9kZSA9PT0gQ1NTQ29sb3JNb2RlLkhTTF9DU1NcbiAgICAgICAgPyBDU1NDb2xvck1vZGUuSFNMQV9DU1NcbiAgICAgICAgOiBtb2RlID09PSBPYmplY3RDb2xvck1vZGUuUkdCXG4gICAgICAgICAgPyBPYmplY3RDb2xvck1vZGUuUkdCQVxuICAgICAgICAgIDogbW9kZSA9PT0gT2JqZWN0Q29sb3JNb2RlLkhTTFxuICAgICAgICAgICAgPyBPYmplY3RDb2xvck1vZGUuSFNMQVxuICAgICAgICAgICAgOiBtb2RlID09PSBPYmplY3RDb2xvck1vZGUuSFNWXG4gICAgICAgICAgICAgID8gT2JqZWN0Q29sb3JNb2RlLkhTVkFcbiAgICAgICAgICAgICAgOiBtb2RlO1xuICByZXR1cm4gYWxwaGFNb2RlO1xufVxuZnVuY3Rpb24gdG9Ob25BbHBoYU1vZGUobW9kZSkge1xuICBjb25zdCBub25BbHBoYU1vZGUgPSBtb2RlID09PSBDU1NDb2xvck1vZGUuSEVYQVxuICAgID8gQ1NTQ29sb3JNb2RlLkhFWFxuICAgIDogbW9kZSA9PT0gQ1NTQ29sb3JNb2RlLlJHQkFfQ1NTXG4gICAgICA/IENTU0NvbG9yTW9kZS5SR0JfQ1NTXG4gICAgICA6IG1vZGUgPT09IENTU0NvbG9yTW9kZS5IU0xBX0NTU1xuICAgICAgICA/IENTU0NvbG9yTW9kZS5IU0xfQ1NTXG4gICAgICAgIDogbW9kZSA9PT0gT2JqZWN0Q29sb3JNb2RlLlJHQkFcbiAgICAgICAgICA/IE9iamVjdENvbG9yTW9kZS5SR0JcbiAgICAgICAgICA6IG1vZGUgPT09IE9iamVjdENvbG9yTW9kZS5IU0xBXG4gICAgICAgICAgICA/IE9iamVjdENvbG9yTW9kZS5IU0xcbiAgICAgICAgICAgIDogbW9kZSA9PT0gT2JqZWN0Q29sb3JNb2RlLkhTVkFcbiAgICAgICAgICAgICAgPyBPYmplY3RDb2xvck1vZGUuSFNWXG4gICAgICAgICAgICAgIDogbW9kZTtcbiAgcmV0dXJuIG5vbkFscGhhTW9kZTtcbn1cblxuZXhwb3J0IHsgQ1NTQ29sb3JNb2RlIGFzIEMsIGFscGhhQ29tcGF0aWJsZSBhcyBhLCBhbHBoYVRvT3BhY2l0eSBhcyBiLCBjb2xvckVxdWFsIGFzIGMsIG5vcm1hbGl6ZUFscGhhIGFzIGQsIG5vcm1hbGl6ZUNvbG9yIGFzIGUsIHRvQWxwaGFNb2RlIGFzIGYsIGhleFRvUkdCIGFzIGcsIGhleGlmeSBhcyBoLCBpc1ZhbGlkSGV4IGFzIGksIGlzTG9uZ2hhbmRIZXggYXMgaiwgaGV4Q2hhciBhcyBrLCBub3JtYWxpemVIZXggYXMgbiwgb3BhY2l0eVRvQWxwaGEgYXMgbywgcGFyc2VNb2RlIGFzIHAsIHJnYlRvSGV4IGFzIHIsIHRvTm9uQWxwaGFNb2RlIGFzIHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==