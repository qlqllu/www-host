"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-a82dc6"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional-info.entry.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional-info.entry.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_raster_multidimensional_info: () => (/* binding */ ArcgisRasterMultidimensionalInfo)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multidimensional-279ffd6e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-279ffd6e.js");
/* harmony import */ var _localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./localStorage-f63100ef.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-f63100ef.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./commonFunctions-5262b094.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-5262b094.js");
/* harmony import */ var _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commonEnums-f98a323c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-f98a323c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */










const arcgisRasterMultidimensionalInfoCss = ":host{display:flex;flex:1 1 auto}.info{width:100%}.info-content{height:var(--calcite-loader-size, 64px)}.default-variable{font-size:var(--calcite-font-size--2)}.notice{margin-bottom:10px}";

const ArcgisRasterMultidimensionalInfo = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.keepActiveDimension = true;
    this.showFilterLength = 10;
    this.showRawSourceInfo = true;
    this.layer = undefined;
    this.open = true;
    this.showStatistics = false;
    this.useTable = true;
    this.multidimensionalInfo = undefined;
    this.selectedVariableNames = [];
  }
  watchLayer(newValue, _oldValue) {
    this.closePopover();
    this.multidimensionalInfo = null;
    this.selectedVariableNames = [];
    this.initLayer(newValue);
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    [this.strings] = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement);
    this.initLayer(this.layer);
  }
  disconnectedCallback() {
    this.closePopover();
  }
  // --------------------------------------------------------------------------
  //
  //  public methods
  //
  // --------------------------------------------------------------------------
  async done() {
    this.closePopover();
  }
  // --------------------------------------------------------------------------
  //
  //  Render methods
  //
  // --------------------------------------------------------------------------
  render() {
    var _a, _b, _c;
    const { layer, multidimensionalInfo, strings } = this;
    if (!multidimensionalInfo) {
      const loading = !(layer === null || layer === void 0 ? void 0 : layer.loaded);
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { class: "info", heading: strings.multidimensionalInfo.info, collapsible: true, open: !!this.open, loading: loading }, loading ? (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info-content" }) : (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, strings.general.unsupported))));
    }
    const { variables } = multidimensionalInfo;
    const rasterInfo = layer.type === "imagery" ? layer.serviceRasterInfo : layer.rasterInfo;
    const defaultVariable = (_b = (_a = rasterInfo.keyProperties) === null || _a === void 0 ? void 0 : _a["DefaultVariable"]) !== null && _b !== void 0 ? _b : variables[0].name;
    const allDimensions = [];
    variables.forEach(({ dimensions }) => dimensions.forEach((dimension) => {
      if (!allDimensions.some((existingDimension) => existingDimension.name === dimension.name)) {
        allDimensions.push(dimension);
      }
    }));
    const dimensionDesc = allDimensions
      .map(({ name, values }) => {
      const dimName = name === "StdTime"
        ? strings.multidimensionalInfo.timeValues
        : name === "StdZ"
          ? strings.multidimensionalInfo.zValues
          : strings.multidimensionalInfo.generalValues.replace("${dimensionName}", name);
      const length = values === null || values === void 0 ? void 0 : values.length;
      return length ? `${dimName}: ${length}` : dimName;
    })
      .join("; ");
    const searchItems = variables.map(({ name, dimensions }) => ({
      name,
      dimensionNames: dimensions.map((dimensionInfo) => dimensionInfo.name)
    }));
    const selectedVariables = ((_c = this.selectedVariableNames) === null || _c === void 0 ? void 0 : _c.length)
      ? variables.filter(({ name }) => this.selectedVariableNames.includes(name))
      : variables;
    const filterBox = variables.length >= this.showFilterLength && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-filter", { items: searchItems, messageOverrides: {
        clear: strings.general.clear,
        label: strings.multidimensionalInfo.searchVariables
      }, placeholder: strings.multidimensionalInfo.searchVariables, onCalciteFilterChange: (event) => {
        const filteredItems = event.target.filteredItems;
        this.selectedVariableNames = filteredItems.map(({ name }) => name);
      } }));
    const variableSelect = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: (el) => (this.variableEL = el) }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, `${strings.multidimensionalInfo.variables}: ${variables.length}; ${dimensionDesc}`), filterBox, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", null, selectedVariables.map((variableInfo) => this.renderVariableListItem(variableInfo, variableInfo.name === defaultVariable)))));
    const isTipNeeded = !(0,_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_3__.g)(_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_3__.l.ARCGIS_COMPONENT_NOTIFICATIONS, _localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_3__.a.MULTIDIMENSIONAL_INFO_TIP_DISMISSED);
    const message = isTipNeeded && ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { open: true, closable: true, icon: true, scale: "s", class: "notice", onCalciteNoticeClose: () => {
        (0,_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_3__.s)(_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_3__.l.ARCGIS_COMPONENT_NOTIFICATIONS, {
          key: _localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_3__.a.MULTIDIMENSIONAL_INFO_TIP_DISMISSED,
          value: "true"
        });
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, " ", strings.multidimensionalInfo.tip)));
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { class: "info", heading: strings.multidimensionalInfo.info, collapsible: true, open: !!this.open, onCalciteBlockToggle: (evt) => !evt.target.open && this.closePopover() }, message, variableSelect, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null))));
  }
  renderVariableListItem(variableInfo, isDefaultVariable) {
    const { name, unit, description } = variableInfo;
    const label = unit ? `${name} (${unit})` : `${name}`;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { label: label, description: description, key: name, onClick: () => this.renderPickListPopover(variableInfo) }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "information", scale: "s", text: this.strings.general.close, slot: "actions-start", onClick: () => this.renderPickListPopover(variableInfo) }), isDefaultVariable ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { slot: "actions-end", value: undefined }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "default-variable" }, this.strings.general.default))) : null));
  }
  renderPickListPopover(variableInfo) {
    if (this.popOver) {
      this.popOver.keepActiveDimension = this.keepActiveDimension;
      this.popOver.variableInfo = variableInfo;
      this.popOver.setFocus("dismiss-button");
      return;
    }
    const popOver = document.createElement("arcgis-raster-multidimensional-variable-info");
    popOver.keepActiveDimension = this.keepActiveDimension;
    popOver.variableInfo = variableInfo;
    popOver.showStatistics = this.showStatistics;
    popOver.useTable = this.useTable;
    popOver.strings = this.strings;
    let offsetSkidding = 0;
    if (this.variableEL) {
      offsetSkidding =
        this.variableEL.getBoundingClientRect().top - this.hostElement.getBoundingClientRect().top;
    }
    popOver.popoverProps = {
      refElement: this.hostElement,
      placement: "leading-start",
      offsetDistance: 0,
      offsetSkidding,
      popoverWidth: 100
    };
    popOver.addEventListener("arcgisRasterMultidimensionalVariableInfoDismiss", (_evt) => {
      this.closePopover();
    });
    document.body.appendChild(popOver);
    popOver.componentOnReady().then(() => {
      // yield execution to DOM
      // according to Stencil doc, this is fired right after sync execution of componentDidMount, but apparently DOM rendering is not fired yet.
      // calcite-button impl depends on actual dom which in turn requires dom renderer to happen first.
      // https://github.com/Esri/calcite-components/blob/c07dd561d1e78601b3b2f92154d448c36c1c9c06/src/components/button/button.tsx#L222
      // this is probably fixable by Calcite, or turn into some sort of utility function
      requestAnimationFrame(() => popOver.setFocus("dismiss-button"));
    });
    this.popOver = popOver;
  }
  // --------------------------------------------------------------------------
  //
  //  Private methods
  //
  // --------------------------------------------------------------------------
  closePopover() {
    if (this.popOver) {
      document.body.removeChild(this.popOver);
      this.popOver = null;
    }
  }
  async initLayer(layer) {
    if (!layer) {
      return;
    }
    if (!layer.loaded) {
      await layer.load();
    }
    this.multidimensionalInfo = await (0,_multidimensional_279ffd6e_js__WEBPACK_IMPORTED_MODULE_2__.a)(layer, this.showRawSourceInfo);
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "layer": ["watchLayer"]
  }; }
};
ArcgisRasterMultidimensionalInfo.style = arcgisRasterMultidimensionalInfoCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-f63100ef.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-f63100ef.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arcgisComponentNotificationsKeys),
/* harmony export */   g: () => (/* binding */ getSingleObjectLocalStorage),
/* harmony export */   l: () => (/* binding */ localStorageKeys),
/* harmony export */   s: () => (/* binding */ setSingleObjectLocalStorage)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
var localStorageKeys;
(function (localStorageKeys) {
  localStorageKeys["ARCGIS_COMPONENT_NOTIFICATIONS"] = "arcgisComponent_notifications";
})(localStorageKeys || (localStorageKeys = {}));
var arcgisComponentNotificationsKeys;
(function (arcgisComponentNotificationsKeys) {
  arcgisComponentNotificationsKeys["FEATURE_REDUCTION_WARNING_DISMISSED"] = "arcgis_feature_reduction_warning_dismissed";
  arcgisComponentNotificationsKeys["POPUP_WARNING_DISMISSED"] = "arcgis_popup_warning_dismissed";
  arcgisComponentNotificationsKeys["INCOMPATIBLE_VECTOR_SYMBOLS_DISMISSED"] = "arcgis_symbol_styler_incompatible_vector_symbols_dismissed";
  arcgisComponentNotificationsKeys["EFFECTS_TIP_DISMISSED"] = "arcgis_effects_tip_dismissed";
  arcgisComponentNotificationsKeys["LAYER_VIEW_DEFINITION_DISMISSED"] = "arcgis_layer_view_definition_dismissed";
  arcgisComponentNotificationsKeys["LAYER_OVERRIDE_STATUS_TIP_DISMISSED"] = "arcgis_layer_override_status_tip_dismissed";
  arcgisComponentNotificationsKeys["LAYER_VIEW_JOIN_TIP_DISMISSED"] = "arcgis_layer_view_join_tip_dismissed";
  arcgisComponentNotificationsKeys["MULTIDIMENSIONAL_INFO_TIP_DISMISSED"] = "arcgis_multidimensional_info_tip_dismissed";
})(arcgisComponentNotificationsKeys || (arcgisComponentNotificationsKeys = {}));
const getLocalStorage = (localStorageKey) => {
  return localStorage.getItem(localStorageKey);
};
const setLocalStorage = (localStorageKey, value) => {
  localStorage.setItem(localStorageKey, value);
};
const getObjectLocalStorage = (localStorageKey) => {
  return JSON.parse(getLocalStorage(localStorageKey)) || {};
};
const setSingleObjectLocalStorage = (localStorageKey, keyValueObject) => {
  const setLocalStorageVal = getObjectLocalStorage(localStorageKey);
  setLocalStorageVal[keyValueObject.key] = keyValueObject.value;
  setLocalStorage(localStorageKey, JSON.stringify(setLocalStorageVal));
};
const getSingleObjectLocalStorage = (localStorageKey, objectKey) => {
  const getLocalStorageVal = getObjectLocalStorage(localStorageKey);
  if (getLocalStorageVal === null || getLocalStorageVal === void 0 ? void 0 : getLocalStorageVal.hasOwnProperty(objectKey)) {
    return getLocalStorageVal[objectKey];
  }
  else {
    return null;
  }
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-279ffd6e.js":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-279ffd6e.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getMultidimensionalInfo),
/* harmony export */   b: () => (/* binding */ getDefaultDimensionSliceValue),
/* harmony export */   c: () => (/* binding */ getMultidimensionalDefinition),
/* harmony export */   f: () => (/* binding */ formatDimensionValue),
/* harmony export */   g: () => (/* binding */ getClippedDimensionInfo),
/* harmony export */   i: () => (/* binding */ isTimeDimension),
/* harmony export */   m: () => (/* binding */ minVersionRFTMultidimensionalInfo),
/* harmony export */   u: () => (/* binding */ updateDimensionalDefinition)
/* harmony export */ });
/* harmony import */ var _commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonFunctions-5262b094.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-5262b094.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const minVersionRFTMultidimensionalInfo = 10.9;
function formatTime(value, options) {
  const date = new Date(value);
  const { useFriendlyISOFormat, intl, format } = options;
  if (useFriendlyISOFormat && intl) {
    return intl.formatDate(date, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(format !== null && format !== void 0 ? format : "short-date-long-time")), { timeZone: "UTC" }));
  }
  let isoTimeString = new Date(value).toISOString();
  isoTimeString = isoTimeString.slice(0, isoTimeString.indexOf(".")) + "Z";
  return isoTimeString;
}
function formatMonth(value_base1, intl, format = "long") {
  // using an arbitrary date (the day the code was written) to avoid side effects of setMonth near the end of the month
  // setMonth will move the date to the next month when new month doesn't have current date (e.g. 9/31, 2/30)
  // date = new Date(2002, 9, 31); date.setMonth(8); console.log(date.toLocaleDateString())
  const date = new Date(2022, 9, 10);
  date.setMonth(value_base1 - 1);
  return intl.formatDate(date, { month: format });
}
function formatQuarter(value_base1, intl) {
  const startMonth = formatMonth((value_base1 - 1) * 3 + 1, intl, "short");
  const endMonth = formatMonth(value_base1 * 3, intl, "short");
  return `${startMonth} - ${endMonth}`;
}
function formatDimensionValue(value, dimensionInfo, options = {}) {
  var _a, _b, _c, _d;
  if (value == null) {
    return "";
  }
  const { intl, useRecurringTimeLabel } = options;
  if (useRecurringTimeLabel && intl && !Array.isArray(value)) {
    const intervalUnit = (_a = dimensionInfo.intervalUnit) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim();
    // weekly and daily are not supported yet
    const canUseRecurringTimeLabel = isRecurringTimeDimension(dimensionInfo) && (intervalUnit === "months" || intervalUnit === "quarters");
    if (canUseRecurringTimeLabel) {
      return intervalUnit === "months" ? formatMonth(value, intl) : formatQuarter(value, intl);
    }
  }
  // this is prefered when labeling a slider alike control
  const lastElement = (_b = dimensionInfo.values) === null || _b === void 0 ? void 0 : _b[dimensionInfo.values.length - 1];
  if (options.useStartOrEndForRangedValue && Array.isArray(value) && value.length === 2 && Array.isArray(lastElement)) {
    const isLastElement = value.join("-") === lastElement.join("-");
    value = isLastElement ? value[1] : value[0];
  }
  const isTime = isTimeDimension(dimensionInfo);
  if (!isTime) {
    return Array.isArray(value)
      ? value.map((element) => { var _a; return (_a = intl === null || intl === void 0 ? void 0 : intl.formatNumber(element)) !== null && _a !== void 0 ? _a : String(element); }).join(" - ")
      : (_c = intl === null || intl === void 0 ? void 0 : intl.formatNumber(value)) !== null && _c !== void 0 ? _c : String(value);
  }
  if (options.useFriendlyISOFormat && !options.format) {
    let resolution = (_d = dimensionInfo.intervalUnit) === null || _d === void 0 ? void 0 : _d.toLowerCase().trim();
    let { interval, extent } = dimensionInfo;
    if (resolution === "months") {
      if (interval > 11) {
        resolution = "year";
      }
    }
    else if (resolution === "days") {
      if (interval > 364) {
        resolution = "year";
      }
      else if (interval > 27) {
        resolution = "months";
      }
    }
    else if (resolution === "hours") {
      resolution = "days";
    }
    if (!["years", "months", "days"].includes(resolution) && (extent === null || extent === void 0 ? void 0 : extent.length)) {
      const interval = (extent[1] - extent[0]) / dimensionInfo.values.length;
      const day = 86400000;
      if (interval >= 365 * day) {
        resolution = "years";
      }
      else if (interval >= 28 * day) {
        resolution = "months";
      }
    }
    const format = resolution === "years" ? "year" : resolution === "months" ? "short-month-year" : "short-date";
    options = Object.assign({ format }, options);
  }
  return Array.isArray(value)
    ? value.map((element) => formatTime(element, options)).join(" - ")
    : formatTime(value, options);
}
function getClippedDimensionInfo(dimensionInfo, multidimensionalSubset) {
  var _a;
  const constraint = (_a = multidimensionalSubset === null || multidimensionalSubset === void 0 ? void 0 : multidimensionalSubset.dimensions) === null || _a === void 0 ? void 0 : _a.find(({ name }) => name === dimensionInfo.name);
  if (!(constraint === null || constraint === void 0 ? void 0 : constraint.extent)) {
    return dimensionInfo;
  }
  const extent = [...constraint.extent];
  const values = dimensionInfo.values.filter((value) => {
    // must be contained, intersection is not sufficient
    if (Array.isArray(value)) {
      if (!(0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_0__.i)(extent[1]) || extent[0] === extent[1]) {
        return value[0] === extent[0];
      }
      return value[0] >= extent[0] && value[0] <= extent[1] && value[1] >= extent[0] && value[1] <= extent[1];
    }
    return value >= extent[0] && value <= extent[1];
  });
  // this is a special case, when last slice of a ranged dimension series is used
  if (values.length === 0) {
    const lastValue = dimensionInfo.values[dimensionInfo.values.length - 1];
    if (Array.isArray(lastValue) && lastValue[1] === extent[0]) {
      values.push(lastValue);
    }
  }
  return Object.assign(Object.assign({}, dimensionInfo), { extent, values });
}
function getDefaultDimensionSliceValue(dimensionInfo) {
  var _a;
  const { values, extent, name } = dimensionInfo;
  let value = (_a = values === null || values === void 0 ? void 0 : values[0]) !== null && _a !== void 0 ? _a : extent[0];
  if (name.toLowerCase() === "stdz" &&
    !dimensionInfo.hasRanges &&
    Math.abs(extent[1]) <= Math.abs(extent[0])) {
    if (values === null || values === void 0 ? void 0 : values.length) {
      value = values[values.length - 1];
    }
    else {
      value = extent[1];
    }
  }
  return value;
}
function getMultidimensionalDefinition(layer) {
  var _a, _b;
  return layer.type === "imagery-tile"
    ? layer.multidimensionalDefinition
    : (_b = ((_a = layer.mosaicRule) !== null && _a !== void 0 ? _a : layer._defaultServiceMosaicRule)) === null || _b === void 0 ? void 0 : _b.multidimensionalDefinition;
}
async function getMultidimensionalInfo(layer, useRawSourceInfo) {
  var _a, _b;
  if (layer.type === "imagery-tile") {
    return layer.rasterInfo.multidimensionalInfo;
  }
  const { rasterFunction, version } = layer;
  if (useRawSourceInfo ||
    version <= minVersionRFTMultidimensionalInfo ||
    !rasterFunction ||
    ((_a = rasterFunction.functionName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "none") {
    return layer.serviceRasterInfo.multidimensionalInfo;
  }
  const rasterInfo = (_b = (await layer.generateRasterInfo(layer.rasterFunction))) !== null && _b !== void 0 ? _b : layer.serviceRasterInfo;
  return rasterInfo.multidimensionalInfo;
}
function isTimeDimension(dimensionInfo, ignoreRecuring = false) {
  return dimensionInfo.name === "StdTime" && (ignoreRecuring || !dimensionInfo.recurring);
}
function isRecurringTimeDimension(dimensionInfo) {
  return dimensionInfo.name === "StdTime" && !!dimensionInfo.recurring;
}
function updateDimensionalDefinition(def, dimensionInfo, activeMultidimensionalSubset) {
  dimensionInfo = getClippedDimensionInfo(dimensionInfo, activeMultidimensionalSubset);
  const originalFormattedValue = formatDimensionValue(def.values[0], dimensionInfo);
  const hasOriginalFormattedValue = dimensionInfo.values.some((val) => originalFormattedValue === formatDimensionValue(val, dimensionInfo));
  if (!hasOriginalFormattedValue) {
    // get default slice value when def.values is invalid
    const value = getDefaultDimensionSliceValue(dimensionInfo);
    def.values = [value];
  }
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWE4MmRjNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDMkY7QUFDckI7QUFDUTtBQUNnRztBQUNuSjtBQUNTO0FBQ0Q7QUFDSTtBQUNKOztBQUVuQyxtREFBbUQsYUFBYSxjQUFjLE1BQU0sV0FBVyxjQUFjLHdDQUF3QyxrQkFBa0Isc0NBQXNDLFFBQVEsbUJBQW1COztBQUV4TztBQUNBO0FBQ0EsSUFBSSxxREFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0EsY0FBYyxxREFBQyxDQUFDLGlEQUFJLFFBQVEscURBQUMsb0JBQW9CLG1IQUFtSCxZQUFZLHFEQUFDLFVBQVUsdUJBQXVCLElBQUkscURBQUM7QUFDdk47QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGNBQWM7QUFDaEY7QUFDQSx5QkFBeUIsUUFBUSxJQUFJLE9BQU87QUFDNUMsS0FBSztBQUNMLGVBQWU7QUFDZix5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQixnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLXJhc3Rlci1tdWx0aWRpbWVuc2lvbmFsLWluZm8uZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxTdG9yYWdlLWY2MzEwMGVmLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0xM2UwMGE3NS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9tdWx0aWRpbWVuc2lvbmFsLTI3OWZmZDZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMTNlMDBhNzUuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyB9IGZyb20gJy4vbXVsdGlkaW1lbnNpb25hbC0yNzlmZmQ2ZS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSwgcyBhcyBzZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UsIGEgYXMgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMsIGwgYXMgbG9jYWxTdG9yYWdlS2V5cyB9IGZyb20gJy4vbG9jYWxTdG9yYWdlLWY2MzEwMGVmLmpzJztcbmltcG9ydCAnLi9kb20tMTNmNWIwMGMuanMnO1xuaW1wb3J0ICcuL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYWFmMzBiZDYuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkZ1bmN0aW9ucy01MjYyYjA5NC5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZjk4YTMyM2MuanMnO1xuXG5jb25zdCBhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsSW5mb0NzcyA9IFwiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXg6MSAxIGF1dG99LmluZm97d2lkdGg6MTAwJX0uaW5mby1jb250ZW50e2hlaWdodDp2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplLCA2NHB4KX0uZGVmYXVsdC12YXJpYWJsZXtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTIpfS5ub3RpY2V7bWFyZ2luLWJvdHRvbToxMHB4fVwiO1xuXG5jb25zdCBBcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsSW5mbyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5rZWVwQWN0aXZlRGltZW5zaW9uID0gdHJ1ZTtcbiAgICB0aGlzLnNob3dGaWx0ZXJMZW5ndGggPSAxMDtcbiAgICB0aGlzLnNob3dSYXdTb3VyY2VJbmZvID0gdHJ1ZTtcbiAgICB0aGlzLmxheWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgdGhpcy5zaG93U3RhdGlzdGljcyA9IGZhbHNlO1xuICAgIHRoaXMudXNlVGFibGUgPSB0cnVlO1xuICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWxlY3RlZFZhcmlhYmxlTmFtZXMgPSBbXTtcbiAgfVxuICB3YXRjaExheWVyKG5ld1ZhbHVlLCBfb2xkVmFsdWUpIHtcbiAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8gPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0ZWRWYXJpYWJsZU5hbWVzID0gW107XG4gICAgdGhpcy5pbml0TGF5ZXIobmV3VmFsdWUpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIFt0aGlzLnN0cmluZ3NdID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICB0aGlzLmluaXRMYXllcih0aGlzLmxheWVyKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBwdWJsaWMgbWV0aG9kc1xuICAvL1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBkb25lKCkge1xuICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlciBtZXRob2RzXG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IGxheWVyLCBtdWx0aWRpbWVuc2lvbmFsSW5mbywgc3RyaW5ncyB9ID0gdGhpcztcbiAgICBpZiAoIW11bHRpZGltZW5zaW9uYWxJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkaW5nID0gIShsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubG9hZGVkKTtcbiAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiY2FsY2l0ZS1ibG9ja1wiLCB7IGNsYXNzOiBcImluZm9cIiwgaGVhZGluZzogc3RyaW5ncy5tdWx0aWRpbWVuc2lvbmFsSW5mby5pbmZvLCBjb2xsYXBzaWJsZTogdHJ1ZSwgb3BlbjogISF0aGlzLm9wZW4sIGxvYWRpbmc6IGxvYWRpbmcgfSwgbG9hZGluZyA/IGgoXCJkaXZcIiwgeyBjbGFzczogXCJpbmZvLWNvbnRlbnRcIiB9KSA6IGgoXCJkaXZcIiwgbnVsbCwgc3RyaW5ncy5nZW5lcmFsLnVuc3VwcG9ydGVkKSkpKTtcbiAgICB9XG4gICAgY29uc3QgeyB2YXJpYWJsZXMgfSA9IG11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgIGNvbnN0IHJhc3RlckluZm8gPSBsYXllci50eXBlID09PSBcImltYWdlcnlcIiA/IGxheWVyLnNlcnZpY2VSYXN0ZXJJbmZvIDogbGF5ZXIucmFzdGVySW5mbztcbiAgICBjb25zdCBkZWZhdWx0VmFyaWFibGUgPSAoX2IgPSAoX2EgPSByYXN0ZXJJbmZvLmtleVByb3BlcnRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtcIkRlZmF1bHRWYXJpYWJsZVwiXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdmFyaWFibGVzWzBdLm5hbWU7XG4gICAgY29uc3QgYWxsRGltZW5zaW9ucyA9IFtdO1xuICAgIHZhcmlhYmxlcy5mb3JFYWNoKCh7IGRpbWVuc2lvbnMgfSkgPT4gZGltZW5zaW9ucy5mb3JFYWNoKChkaW1lbnNpb24pID0+IHtcbiAgICAgIGlmICghYWxsRGltZW5zaW9ucy5zb21lKChleGlzdGluZ0RpbWVuc2lvbikgPT4gZXhpc3RpbmdEaW1lbnNpb24ubmFtZSA9PT0gZGltZW5zaW9uLm5hbWUpKSB7XG4gICAgICAgIGFsbERpbWVuc2lvbnMucHVzaChkaW1lbnNpb24pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBkaW1lbnNpb25EZXNjID0gYWxsRGltZW5zaW9uc1xuICAgICAgLm1hcCgoeyBuYW1lLCB2YWx1ZXMgfSkgPT4ge1xuICAgICAgY29uc3QgZGltTmFtZSA9IG5hbWUgPT09IFwiU3RkVGltZVwiXG4gICAgICAgID8gc3RyaW5ncy5tdWx0aWRpbWVuc2lvbmFsSW5mby50aW1lVmFsdWVzXG4gICAgICAgIDogbmFtZSA9PT0gXCJTdGRaXCJcbiAgICAgICAgICA/IHN0cmluZ3MubXVsdGlkaW1lbnNpb25hbEluZm8uelZhbHVlc1xuICAgICAgICAgIDogc3RyaW5ncy5tdWx0aWRpbWVuc2lvbmFsSW5mby5nZW5lcmFsVmFsdWVzLnJlcGxhY2UoXCIke2RpbWVuc2lvbk5hbWV9XCIsIG5hbWUpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBgJHtkaW1OYW1lfTogJHtsZW5ndGh9YCA6IGRpbU5hbWU7XG4gICAgfSlcbiAgICAgIC5qb2luKFwiOyBcIik7XG4gICAgY29uc3Qgc2VhcmNoSXRlbXMgPSB2YXJpYWJsZXMubWFwKCh7IG5hbWUsIGRpbWVuc2lvbnMgfSkgPT4gKHtcbiAgICAgIG5hbWUsXG4gICAgICBkaW1lbnNpb25OYW1lczogZGltZW5zaW9ucy5tYXAoKGRpbWVuc2lvbkluZm8pID0+IGRpbWVuc2lvbkluZm8ubmFtZSlcbiAgICB9KSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRWYXJpYWJsZXMgPSAoKF9jID0gdGhpcy5zZWxlY3RlZFZhcmlhYmxlTmFtZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpXG4gICAgICA/IHZhcmlhYmxlcy5maWx0ZXIoKHsgbmFtZSB9KSA9PiB0aGlzLnNlbGVjdGVkVmFyaWFibGVOYW1lcy5pbmNsdWRlcyhuYW1lKSlcbiAgICAgIDogdmFyaWFibGVzO1xuICAgIGNvbnN0IGZpbHRlckJveCA9IHZhcmlhYmxlcy5sZW5ndGggPj0gdGhpcy5zaG93RmlsdGVyTGVuZ3RoICYmIChoKFwiY2FsY2l0ZS1maWx0ZXJcIiwgeyBpdGVtczogc2VhcmNoSXRlbXMsIG1lc3NhZ2VPdmVycmlkZXM6IHtcbiAgICAgICAgY2xlYXI6IHN0cmluZ3MuZ2VuZXJhbC5jbGVhcixcbiAgICAgICAgbGFiZWw6IHN0cmluZ3MubXVsdGlkaW1lbnNpb25hbEluZm8uc2VhcmNoVmFyaWFibGVzXG4gICAgICB9LCBwbGFjZWhvbGRlcjogc3RyaW5ncy5tdWx0aWRpbWVuc2lvbmFsSW5mby5zZWFyY2hWYXJpYWJsZXMsIG9uQ2FsY2l0ZUZpbHRlckNoYW5nZTogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkSXRlbXMgPSBldmVudC50YXJnZXQuZmlsdGVyZWRJdGVtcztcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhcmlhYmxlTmFtZXMgPSBmaWx0ZXJlZEl0ZW1zLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpO1xuICAgICAgfSB9KSk7XG4gICAgY29uc3QgdmFyaWFibGVTZWxlY3QgPSAoaChcImRpdlwiLCB7IHJlZjogKGVsKSA9PiAodGhpcy52YXJpYWJsZUVMID0gZWwpIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIGAke3N0cmluZ3MubXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzfTogJHt2YXJpYWJsZXMubGVuZ3RofTsgJHtkaW1lbnNpb25EZXNjfWApLCBmaWx0ZXJCb3gsIGgoXCJjYWxjaXRlLWxpc3RcIiwgbnVsbCwgc2VsZWN0ZWRWYXJpYWJsZXMubWFwKCh2YXJpYWJsZUluZm8pID0+IHRoaXMucmVuZGVyVmFyaWFibGVMaXN0SXRlbSh2YXJpYWJsZUluZm8sIHZhcmlhYmxlSW5mby5uYW1lID09PSBkZWZhdWx0VmFyaWFibGUpKSkpKTtcbiAgICBjb25zdCBpc1RpcE5lZWRlZCA9ICFnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5cy5BUkNHSVNfQ09NUE9ORU5UX05PVElGSUNBVElPTlMsIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLk1VTFRJRElNRU5TSU9OQUxfSU5GT19USVBfRElTTUlTU0VEKTtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNUaXBOZWVkZWQgJiYgKGgoXCJjYWxjaXRlLW5vdGljZVwiLCB7IG9wZW46IHRydWUsIGNsb3NhYmxlOiB0cnVlLCBpY29uOiB0cnVlLCBzY2FsZTogXCJzXCIsIGNsYXNzOiBcIm5vdGljZVwiLCBvbkNhbGNpdGVOb3RpY2VDbG9zZTogKCkgPT4ge1xuICAgICAgICBzZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5cy5BUkNHSVNfQ09NUE9ORU5UX05PVElGSUNBVElPTlMsIHtcbiAgICAgICAgICBrZXk6IGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLk1VTFRJRElNRU5TSU9OQUxfSU5GT19USVBfRElTTUlTU0VELFxuICAgICAgICAgIHZhbHVlOiBcInRydWVcIlxuICAgICAgICB9KTtcbiAgICAgIH0gfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIFwiIFwiLCBzdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvLnRpcCkpKTtcbiAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtYmxvY2tcIiwgeyBjbGFzczogXCJpbmZvXCIsIGhlYWRpbmc6IHN0cmluZ3MubXVsdGlkaW1lbnNpb25hbEluZm8uaW5mbywgY29sbGFwc2libGU6IHRydWUsIG9wZW46ICEhdGhpcy5vcGVuLCBvbkNhbGNpdGVCbG9ja1RvZ2dsZTogKGV2dCkgPT4gIWV2dC50YXJnZXQub3BlbiAmJiB0aGlzLmNsb3NlUG9wb3ZlcigpIH0sIG1lc3NhZ2UsIHZhcmlhYmxlU2VsZWN0LCBoKFwic2xvdFwiLCBudWxsKSkpKTtcbiAgfVxuICByZW5kZXJWYXJpYWJsZUxpc3RJdGVtKHZhcmlhYmxlSW5mbywgaXNEZWZhdWx0VmFyaWFibGUpIHtcbiAgICBjb25zdCB7IG5hbWUsIHVuaXQsIGRlc2NyaXB0aW9uIH0gPSB2YXJpYWJsZUluZm87XG4gICAgY29uc3QgbGFiZWwgPSB1bml0ID8gYCR7bmFtZX0gKCR7dW5pdH0pYCA6IGAke25hbWV9YDtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxpc3QtaXRlbVwiLCB7IGxhYmVsOiBsYWJlbCwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBrZXk6IG5hbWUsIG9uQ2xpY2s6ICgpID0+IHRoaXMucmVuZGVyUGlja0xpc3RQb3BvdmVyKHZhcmlhYmxlSW5mbykgfSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgaWNvbjogXCJpbmZvcm1hdGlvblwiLCBzY2FsZTogXCJzXCIsIHRleHQ6IHRoaXMuc3RyaW5ncy5nZW5lcmFsLmNsb3NlLCBzbG90OiBcImFjdGlvbnMtc3RhcnRcIiwgb25DbGljazogKCkgPT4gdGhpcy5yZW5kZXJQaWNrTGlzdFBvcG92ZXIodmFyaWFibGVJbmZvKSB9KSwgaXNEZWZhdWx0VmFyaWFibGUgPyAoaChcImNhbGNpdGUtY2hpcFwiLCB7IHNsb3Q6IFwiYWN0aW9ucy1lbmRcIiwgdmFsdWU6IHVuZGVmaW5lZCB9LCBoKFwic3BhblwiLCB7IGNsYXNzOiBcImRlZmF1bHQtdmFyaWFibGVcIiB9LCB0aGlzLnN0cmluZ3MuZ2VuZXJhbC5kZWZhdWx0KSkpIDogbnVsbCkpO1xuICB9XG4gIHJlbmRlclBpY2tMaXN0UG9wb3Zlcih2YXJpYWJsZUluZm8pIHtcbiAgICBpZiAodGhpcy5wb3BPdmVyKSB7XG4gICAgICB0aGlzLnBvcE92ZXIua2VlcEFjdGl2ZURpbWVuc2lvbiA9IHRoaXMua2VlcEFjdGl2ZURpbWVuc2lvbjtcbiAgICAgIHRoaXMucG9wT3Zlci52YXJpYWJsZUluZm8gPSB2YXJpYWJsZUluZm87XG4gICAgICB0aGlzLnBvcE92ZXIuc2V0Rm9jdXMoXCJkaXNtaXNzLWJ1dHRvblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9wT3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtcmFzdGVyLW11bHRpZGltZW5zaW9uYWwtdmFyaWFibGUtaW5mb1wiKTtcbiAgICBwb3BPdmVyLmtlZXBBY3RpdmVEaW1lbnNpb24gPSB0aGlzLmtlZXBBY3RpdmVEaW1lbnNpb247XG4gICAgcG9wT3Zlci52YXJpYWJsZUluZm8gPSB2YXJpYWJsZUluZm87XG4gICAgcG9wT3Zlci5zaG93U3RhdGlzdGljcyA9IHRoaXMuc2hvd1N0YXRpc3RpY3M7XG4gICAgcG9wT3Zlci51c2VUYWJsZSA9IHRoaXMudXNlVGFibGU7XG4gICAgcG9wT3Zlci5zdHJpbmdzID0gdGhpcy5zdHJpbmdzO1xuICAgIGxldCBvZmZzZXRTa2lkZGluZyA9IDA7XG4gICAgaWYgKHRoaXMudmFyaWFibGVFTCkge1xuICAgICAgb2Zmc2V0U2tpZGRpbmcgPVxuICAgICAgICB0aGlzLnZhcmlhYmxlRUwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy5ob3N0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuICAgIHBvcE92ZXIucG9wb3ZlclByb3BzID0ge1xuICAgICAgcmVmRWxlbWVudDogdGhpcy5ob3N0RWxlbWVudCxcbiAgICAgIHBsYWNlbWVudDogXCJsZWFkaW5nLXN0YXJ0XCIsXG4gICAgICBvZmZzZXREaXN0YW5jZTogMCxcbiAgICAgIG9mZnNldFNraWRkaW5nLFxuICAgICAgcG9wb3ZlcldpZHRoOiAxMDBcbiAgICB9O1xuICAgIHBvcE92ZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxWYXJpYWJsZUluZm9EaXNtaXNzXCIsIChfZXZ0KSA9PiB7XG4gICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9wT3Zlcik7XG4gICAgcG9wT3Zlci5jb21wb25lbnRPblJlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgICAvLyB5aWVsZCBleGVjdXRpb24gdG8gRE9NXG4gICAgICAvLyBhY2NvcmRpbmcgdG8gU3RlbmNpbCBkb2MsIHRoaXMgaXMgZmlyZWQgcmlnaHQgYWZ0ZXIgc3luYyBleGVjdXRpb24gb2YgY29tcG9uZW50RGlkTW91bnQsIGJ1dCBhcHBhcmVudGx5IERPTSByZW5kZXJpbmcgaXMgbm90IGZpcmVkIHlldC5cbiAgICAgIC8vIGNhbGNpdGUtYnV0dG9uIGltcGwgZGVwZW5kcyBvbiBhY3R1YWwgZG9tIHdoaWNoIGluIHR1cm4gcmVxdWlyZXMgZG9tIHJlbmRlcmVyIHRvIGhhcHBlbiBmaXJzdC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL2MwN2RkNTYxZDFlNzg2MDFiM2IyZjkyMTU0ZDQ0OGMzNmMxYzljMDYvc3JjL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi50c3gjTDIyMlxuICAgICAgLy8gdGhpcyBpcyBwcm9iYWJseSBmaXhhYmxlIGJ5IENhbGNpdGUsIG9yIHR1cm4gaW50byBzb21lIHNvcnQgb2YgdXRpbGl0eSBmdW5jdGlvblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHBvcE92ZXIuc2V0Rm9jdXMoXCJkaXNtaXNzLWJ1dHRvblwiKSk7XG4gICAgfSk7XG4gICAgdGhpcy5wb3BPdmVyID0gcG9wT3ZlcjtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gIC8vXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNsb3NlUG9wb3ZlcigpIHtcbiAgICBpZiAodGhpcy5wb3BPdmVyKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucG9wT3Zlcik7XG4gICAgICB0aGlzLnBvcE92ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBpbml0TGF5ZXIobGF5ZXIpIHtcbiAgICBpZiAoIWxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbGF5ZXIubG9hZGVkKSB7XG4gICAgICBhd2FpdCBsYXllci5sb2FkKCk7XG4gICAgfVxuICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8gPSBhd2FpdCBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyhsYXllciwgdGhpcy5zaG93UmF3U291cmNlSW5mbyk7XG4gIH1cbiAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgIFwibGF5ZXJcIjogW1wid2F0Y2hMYXllclwiXVxuICB9OyB9XG59O1xuQXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbEluZm8uc3R5bGUgPSBhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsSW5mb0NzcztcblxuZXhwb3J0IHsgQXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbEluZm8gYXMgYXJjZ2lzX3Jhc3Rlcl9tdWx0aWRpbWVuc2lvbmFsX2luZm8gfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xudmFyIGxvY2FsU3RvcmFnZUtleXM7XG4oZnVuY3Rpb24gKGxvY2FsU3RvcmFnZUtleXMpIHtcbiAgbG9jYWxTdG9yYWdlS2V5c1tcIkFSQ0dJU19DT01QT05FTlRfTk9USUZJQ0FUSU9OU1wiXSA9IFwiYXJjZ2lzQ29tcG9uZW50X25vdGlmaWNhdGlvbnNcIjtcbn0pKGxvY2FsU3RvcmFnZUtleXMgfHwgKGxvY2FsU3RvcmFnZUtleXMgPSB7fSkpO1xudmFyIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzO1xuKGZ1bmN0aW9uIChhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cykge1xuICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkZFQVRVUkVfUkVEVUNUSU9OX1dBUk5JTkdfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfZmVhdHVyZV9yZWR1Y3Rpb25fd2FybmluZ19kaXNtaXNzZWRcIjtcbiAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJQT1BVUF9XQVJOSU5HX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX3BvcHVwX3dhcm5pbmdfZGlzbWlzc2VkXCI7XG4gIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiSU5DT01QQVRJQkxFX1ZFQ1RPUl9TWU1CT0xTX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX3N5bWJvbF9zdHlsZXJfaW5jb21wYXRpYmxlX3ZlY3Rvcl9zeW1ib2xzX2Rpc21pc3NlZFwiO1xuICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkVGRkVDVFNfVElQX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2VmZmVjdHNfdGlwX2Rpc21pc3NlZFwiO1xuICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX1ZJRVdfREVGSU5JVElPTl9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19sYXllcl92aWV3X2RlZmluaXRpb25fZGlzbWlzc2VkXCI7XG4gIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiTEFZRVJfT1ZFUlJJREVfU1RBVFVTX1RJUF9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19sYXllcl9vdmVycmlkZV9zdGF0dXNfdGlwX2Rpc21pc3NlZFwiO1xuICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX1ZJRVdfSk9JTl9USVBfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbGF5ZXJfdmlld19qb2luX3RpcF9kaXNtaXNzZWRcIjtcbiAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJNVUxUSURJTUVOU0lPTkFMX0lORk9fVElQX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX211bHRpZGltZW5zaW9uYWxfaW5mb190aXBfZGlzbWlzc2VkXCI7XG59KShhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cyB8fCAoYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMgPSB7fSkpO1xuY29uc3QgZ2V0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSkgPT4ge1xuICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlS2V5KTtcbn07XG5jb25zdCBzZXRMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5LCB2YWx1ZSkgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VLZXksIHZhbHVlKTtcbn07XG5jb25zdCBnZXRPYmplY3RMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5KSA9PiB7XG4gIHJldHVybiBKU09OLnBhcnNlKGdldExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXkpKSB8fCB7fTtcbn07XG5jb25zdCBzZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5LCBrZXlWYWx1ZU9iamVjdCkgPT4ge1xuICBjb25zdCBzZXRMb2NhbFN0b3JhZ2VWYWwgPSBnZXRPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KTtcbiAgc2V0TG9jYWxTdG9yYWdlVmFsW2tleVZhbHVlT2JqZWN0LmtleV0gPSBrZXlWYWx1ZU9iamVjdC52YWx1ZTtcbiAgc2V0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkoc2V0TG9jYWxTdG9yYWdlVmFsKSk7XG59O1xuY29uc3QgZ2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSwgb2JqZWN0S2V5KSA9PiB7XG4gIGNvbnN0IGdldExvY2FsU3RvcmFnZVZhbCA9IGdldE9iamVjdExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXkpO1xuICBpZiAoZ2V0TG9jYWxTdG9yYWdlVmFsID09PSBudWxsIHx8IGdldExvY2FsU3RvcmFnZVZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0TG9jYWxTdG9yYWdlVmFsLmhhc093blByb3BlcnR5KG9iamVjdEtleSkpIHtcbiAgICByZXR1cm4gZ2V0TG9jYWxTdG9yYWdlVmFsW29iamVjdEtleV07XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzIGFzIGEsIGdldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSBhcyBnLCBsb2NhbFN0b3JhZ2VLZXlzIGFzIGwsIHNldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSBhcyBzIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tMTNmNWIwMGMuanMnO1xuaW1wb3J0IHsgbCBhcyBsYW5ndWFnZU1hcCB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLTIyMjU4YzkwLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9zdGVuY2lsLXRyaWNrcy9pbXBsZW1lbnRpbmctaW50ZXJuYXRpb25hbGlzYXRpb24taTE4bi13aXRoLXN0ZW5jaWwtNWU2NTU5NTU0MTE3XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcuc2xpY2UoMCwgMikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBcImVuXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIC8vIGl0J3MgT0sgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgNCBsZXR0ZXIgbGFuZ3VhZ2UgZmlsZSBmb3IgaXRcbiAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgIC8vIHdlIHN1cHBvcnQgdGhlIDIgbGV0dGVyIGNvZGVkIGxhbmd1YWdlXG4gICAgICAvLyBlLmcuIGl0LUNIIHZzIGl0XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoKGdldEFzc2V0UGF0aChgLi4vYXJjZ2lzLWFwcC1hc3NldHMvaTE4bi8ke2NvbXBvbmVudE5hbWV9LmkxOG4uJHtsb2NhbGV9Lmpzb25gKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0Lm9rKVxuICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgZWxzZVxuICAgICAgICByZWplY3QoKTtcbiAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gIH0pO1xufVxuY29uc3Qgc3RyaW5nQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgY29uc3QgaWQgPSBgJHtjb21wb25lbnROYW1lfSR7bG9jYWxlfWA7XG4gIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgc3RyaW5nQ2FjaGVbaWRdID0gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ0NhY2hlW2lkXTtcbn1cbi8qKlxuICogR2V0IHN0cmluZ3MgYW5kIGxhbmd1YWdlIGNvZGVzLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyAyIGxhbmd1YWdlIGNvZGVzLlxuICogVGhlIGZpcnN0IG9uZSByZXR1cm5zIGEgY29kZSB0aGF0J3MgYWxzbyBzdXBwb3J0ZWQgYXMgYSBsYW5ndWFnZSBmaWxlLlxuICogVGhlIHNlY29uZCBvbmUgcmV0dXJucyBhIGNvZGUgd2hlcmUgdGhlcmUgaXMgc3VwcG9ydCBmb3IgdGhlIGZpcnN0IDIgbGV0dGVycyBvZiB0aGUgY29kZSBhcyBwYXJ0IG9mIGEgbGFuZ3VhZ2UgZmlsZSxcbiAqIGJ1dCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgNCBsZXR0ZXIgY29kZSBmcm9tIHRoZSBwYWdlLlxuICogRS5nLiBGb3IgXCJpdC1jaFwiIGl0IHdpbGwgcmV0dXJuIFwiaXRcIiBhcyB0aGUgZmlyc3QgbGFuZ3VhZ2UgY29kZSBhbmQgXCJpdC1jaFwiIGFzIHRoZSBzZWNvbmQuXG4gKiBUaGUgc2Vjb25kIG9uZSBpcyByZXF1aXJlZCBmb3IgZXNyaS5pbnRsLnNldExvY2FsZSgpIHRvIGdldCB0aGUgY29ycmVjdCBmb3JtYXR0aW5nLlxuICpcbiAqIElmIGEgdGFnTmFtZSBpcyBwcm92aWRlZCBpdCB3aWxsIG92ZXJ3aXRlIHRoZSBlbGVtZW50J3MgdGFnTmFtZVxuICpcbiAqICBAcmV0dXJuIFsgc3RyaW5ncywgZmlyc3QgbGFuZ3VhZ2UgY29kZSwgc2Vjb25kIGxhbmd1YWdlIGNvZGVdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MoZWxlbWVudCwgdGFnTmFtZSkge1xuICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlSW50bCA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCk7XG4gIGxldCBzdHJpbmdzO1xuICB0cnkge1xuICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50TGFuZ3VhZ2UpO1xuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgXCJlblwiKTtcbiAgfVxuICByZXR1cm4gW3N0cmluZ3MsIGNvbXBvbmVudExhbmd1YWdlLCBjb21wb25lbnRMYW5ndWFnZUludGxdO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgYXMgYSwgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyBhcyBnIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGkgYXMgaXNEZWZpbmVkIH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtNTI2MmIwOTQuanMnO1xuXG5jb25zdCBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8gPSAxMC45O1xuZnVuY3Rpb24gZm9ybWF0VGltZSh2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICBjb25zdCB7IHVzZUZyaWVuZGx5SVNPRm9ybWF0LCBpbnRsLCBmb3JtYXQgfSA9IG9wdGlvbnM7XG4gIGlmICh1c2VGcmllbmRseUlTT0Zvcm1hdCAmJiBpbnRsKSB7XG4gICAgcmV0dXJuIGludGwuZm9ybWF0RGF0ZShkYXRlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKGZvcm1hdCAhPT0gbnVsbCAmJiBmb3JtYXQgIT09IHZvaWQgMCA/IGZvcm1hdCA6IFwic2hvcnQtZGF0ZS1sb25nLXRpbWVcIikpLCB7IHRpbWVab25lOiBcIlVUQ1wiIH0pKTtcbiAgfVxuICBsZXQgaXNvVGltZVN0cmluZyA9IG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpO1xuICBpc29UaW1lU3RyaW5nID0gaXNvVGltZVN0cmluZy5zbGljZSgwLCBpc29UaW1lU3RyaW5nLmluZGV4T2YoXCIuXCIpKSArIFwiWlwiO1xuICByZXR1cm4gaXNvVGltZVN0cmluZztcbn1cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoKHZhbHVlX2Jhc2UxLCBpbnRsLCBmb3JtYXQgPSBcImxvbmdcIikge1xuICAvLyB1c2luZyBhbiBhcmJpdHJhcnkgZGF0ZSAodGhlIGRheSB0aGUgY29kZSB3YXMgd3JpdHRlbikgdG8gYXZvaWQgc2lkZSBlZmZlY3RzIG9mIHNldE1vbnRoIG5lYXIgdGhlIGVuZCBvZiB0aGUgbW9udGhcbiAgLy8gc2V0TW9udGggd2lsbCBtb3ZlIHRoZSBkYXRlIHRvIHRoZSBuZXh0IG1vbnRoIHdoZW4gbmV3IG1vbnRoIGRvZXNuJ3QgaGF2ZSBjdXJyZW50IGRhdGUgKGUuZy4gOS8zMSwgMi8zMClcbiAgLy8gZGF0ZSA9IG5ldyBEYXRlKDIwMDIsIDksIDMxKTsgZGF0ZS5zZXRNb250aCg4KTsgY29uc29sZS5sb2coZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKSlcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDIwMjIsIDksIDEwKTtcbiAgZGF0ZS5zZXRNb250aCh2YWx1ZV9iYXNlMSAtIDEpO1xuICByZXR1cm4gaW50bC5mb3JtYXREYXRlKGRhdGUsIHsgbW9udGg6IGZvcm1hdCB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFF1YXJ0ZXIodmFsdWVfYmFzZTEsIGludGwpIHtcbiAgY29uc3Qgc3RhcnRNb250aCA9IGZvcm1hdE1vbnRoKCh2YWx1ZV9iYXNlMSAtIDEpICogMyArIDEsIGludGwsIFwic2hvcnRcIik7XG4gIGNvbnN0IGVuZE1vbnRoID0gZm9ybWF0TW9udGgodmFsdWVfYmFzZTEgKiAzLCBpbnRsLCBcInNob3J0XCIpO1xuICByZXR1cm4gYCR7c3RhcnRNb250aH0gLSAke2VuZE1vbnRofWA7XG59XG5mdW5jdGlvbiBmb3JtYXREaW1lbnNpb25WYWx1ZSh2YWx1ZSwgZGltZW5zaW9uSW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBjb25zdCB7IGludGwsIHVzZVJlY3VycmluZ1RpbWVMYWJlbCB9ID0gb3B0aW9ucztcbiAgaWYgKHVzZVJlY3VycmluZ1RpbWVMYWJlbCAmJiBpbnRsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGludGVydmFsVW5pdCA9IChfYSA9IGRpbWVuc2lvbkluZm8uaW50ZXJ2YWxVbml0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgLy8gd2Vla2x5IGFuZCBkYWlseSBhcmUgbm90IHN1cHBvcnRlZCB5ZXRcbiAgICBjb25zdCBjYW5Vc2VSZWN1cnJpbmdUaW1lTGFiZWwgPSBpc1JlY3VycmluZ1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbykgJiYgKGludGVydmFsVW5pdCA9PT0gXCJtb250aHNcIiB8fCBpbnRlcnZhbFVuaXQgPT09IFwicXVhcnRlcnNcIik7XG4gICAgaWYgKGNhblVzZVJlY3VycmluZ1RpbWVMYWJlbCkge1xuICAgICAgcmV0dXJuIGludGVydmFsVW5pdCA9PT0gXCJtb250aHNcIiA/IGZvcm1hdE1vbnRoKHZhbHVlLCBpbnRsKSA6IGZvcm1hdFF1YXJ0ZXIodmFsdWUsIGludGwpO1xuICAgIH1cbiAgfVxuICAvLyB0aGlzIGlzIHByZWZlcmVkIHdoZW4gbGFiZWxpbmcgYSBzbGlkZXIgYWxpa2UgY29udHJvbFxuICBjb25zdCBsYXN0RWxlbWVudCA9IChfYiA9IGRpbWVuc2lvbkluZm8udmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gIGlmIChvcHRpb25zLnVzZVN0YXJ0T3JFbmRGb3JSYW5nZWRWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgQXJyYXkuaXNBcnJheShsYXN0RWxlbWVudCkpIHtcbiAgICBjb25zdCBpc0xhc3RFbGVtZW50ID0gdmFsdWUuam9pbihcIi1cIikgPT09IGxhc3RFbGVtZW50LmpvaW4oXCItXCIpO1xuICAgIHZhbHVlID0gaXNMYXN0RWxlbWVudCA/IHZhbHVlWzFdIDogdmFsdWVbMF07XG4gIH1cbiAgY29uc3QgaXNUaW1lID0gaXNUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pO1xuICBpZiAoIWlzVGltZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgPyB2YWx1ZS5tYXAoKGVsZW1lbnQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gaW50bCA9PT0gbnVsbCB8fCBpbnRsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRsLmZvcm1hdE51bWJlcihlbGVtZW50KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyaW5nKGVsZW1lbnQpOyB9KS5qb2luKFwiIC0gXCIpXG4gICAgICA6IChfYyA9IGludGwgPT09IG51bGwgfHwgaW50bCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50bC5mb3JtYXROdW1iZXIodmFsdWUpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBTdHJpbmcodmFsdWUpO1xuICB9XG4gIGlmIChvcHRpb25zLnVzZUZyaWVuZGx5SVNPRm9ybWF0ICYmICFvcHRpb25zLmZvcm1hdCkge1xuICAgIGxldCByZXNvbHV0aW9uID0gKF9kID0gZGltZW5zaW9uSW5mby5pbnRlcnZhbFVuaXQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBsZXQgeyBpbnRlcnZhbCwgZXh0ZW50IH0gPSBkaW1lbnNpb25JbmZvO1xuICAgIGlmIChyZXNvbHV0aW9uID09PSBcIm1vbnRoc1wiKSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgPiAxMSkge1xuICAgICAgICByZXNvbHV0aW9uID0gXCJ5ZWFyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc29sdXRpb24gPT09IFwiZGF5c1wiKSB7XG4gICAgICBpZiAoaW50ZXJ2YWwgPiAzNjQpIHtcbiAgICAgICAgcmVzb2x1dGlvbiA9IFwieWVhclwiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaW50ZXJ2YWwgPiAyNykge1xuICAgICAgICByZXNvbHV0aW9uID0gXCJtb250aHNcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzb2x1dGlvbiA9PT0gXCJob3Vyc1wiKSB7XG4gICAgICByZXNvbHV0aW9uID0gXCJkYXlzXCI7XG4gICAgfVxuICAgIGlmICghW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLmluY2x1ZGVzKHJlc29sdXRpb24pICYmIChleHRlbnQgPT09IG51bGwgfHwgZXh0ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnQubGVuZ3RoKSkge1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKSAvIGRpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGRheSA9IDg2NDAwMDAwO1xuICAgICAgaWYgKGludGVydmFsID49IDM2NSAqIGRheSkge1xuICAgICAgICByZXNvbHV0aW9uID0gXCJ5ZWFyc1wiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaW50ZXJ2YWwgPj0gMjggKiBkYXkpIHtcbiAgICAgICAgcmVzb2x1dGlvbiA9IFwibW9udGhzXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IHJlc29sdXRpb24gPT09IFwieWVhcnNcIiA/IFwieWVhclwiIDogcmVzb2x1dGlvbiA9PT0gXCJtb250aHNcIiA/IFwic2hvcnQtbW9udGgteWVhclwiIDogXCJzaG9ydC1kYXRlXCI7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBmb3JtYXQgfSwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgPyB2YWx1ZS5tYXAoKGVsZW1lbnQpID0+IGZvcm1hdFRpbWUoZWxlbWVudCwgb3B0aW9ucykpLmpvaW4oXCIgLSBcIilcbiAgICA6IGZvcm1hdFRpbWUodmFsdWUsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8oZGltZW5zaW9uSW5mbywgbXVsdGlkaW1lbnNpb25hbFN1YnNldCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGNvbnN0cmFpbnQgPSAoX2EgPSBtdWx0aWRpbWVuc2lvbmFsU3Vic2V0ID09PSBudWxsIHx8IG11bHRpZGltZW5zaW9uYWxTdWJzZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG11bHRpZGltZW5zaW9uYWxTdWJzZXQuZGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkaW1lbnNpb25JbmZvLm5hbWUpO1xuICBpZiAoIShjb25zdHJhaW50ID09PSBudWxsIHx8IGNvbnN0cmFpbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnN0cmFpbnQuZXh0ZW50KSkge1xuICAgIHJldHVybiBkaW1lbnNpb25JbmZvO1xuICB9XG4gIGNvbnN0IGV4dGVudCA9IFsuLi5jb25zdHJhaW50LmV4dGVudF07XG4gIGNvbnN0IHZhbHVlcyA9IGRpbWVuc2lvbkluZm8udmFsdWVzLmZpbHRlcigodmFsdWUpID0+IHtcbiAgICAvLyBtdXN0IGJlIGNvbnRhaW5lZCwgaW50ZXJzZWN0aW9uIGlzIG5vdCBzdWZmaWNpZW50XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoIWlzRGVmaW5lZChleHRlbnRbMV0pIHx8IGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVswXSA9PT0gZXh0ZW50WzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlWzBdID49IGV4dGVudFswXSAmJiB2YWx1ZVswXSA8PSBleHRlbnRbMV0gJiYgdmFsdWVbMV0gPj0gZXh0ZW50WzBdICYmIHZhbHVlWzFdIDw9IGV4dGVudFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID49IGV4dGVudFswXSAmJiB2YWx1ZSA8PSBleHRlbnRbMV07XG4gIH0pO1xuICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlLCB3aGVuIGxhc3Qgc2xpY2Ugb2YgYSByYW5nZWQgZGltZW5zaW9uIHNlcmllcyBpcyB1c2VkXG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgbGFzdFZhbHVlID0gZGltZW5zaW9uSW5mby52YWx1ZXNbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGFzdFZhbHVlKSAmJiBsYXN0VmFsdWVbMV0gPT09IGV4dGVudFswXSkge1xuICAgICAgdmFsdWVzLnB1c2gobGFzdFZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGltZW5zaW9uSW5mbyksIHsgZXh0ZW50LCB2YWx1ZXMgfSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZShkaW1lbnNpb25JbmZvKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyB2YWx1ZXMsIGV4dGVudCwgbmFtZSB9ID0gZGltZW5zaW9uSW5mbztcbiAgbGV0IHZhbHVlID0gKF9hID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleHRlbnRbMF07XG4gIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3RkelwiICYmXG4gICAgIWRpbWVuc2lvbkluZm8uaGFzUmFuZ2VzICYmXG4gICAgTWF0aC5hYnMoZXh0ZW50WzFdKSA8PSBNYXRoLmFicyhleHRlbnRbMF0pKSB7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YWx1ZSA9IGV4dGVudFsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCJcbiAgICA/IGxheWVyLm11bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uXG4gICAgOiAoX2IgPSAoKF9hID0gbGF5ZXIubW9zYWljUnVsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGF5ZXIuX2RlZmF1bHRTZXJ2aWNlTW9zYWljUnVsZSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE11bHRpZGltZW5zaW9uYWxJbmZvKGxheWVyLCB1c2VSYXdTb3VyY2VJbmZvKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmIChsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiKSB7XG4gICAgcmV0dXJuIGxheWVyLnJhc3RlckluZm8ubXVsdGlkaW1lbnNpb25hbEluZm87XG4gIH1cbiAgY29uc3QgeyByYXN0ZXJGdW5jdGlvbiwgdmVyc2lvbiB9ID0gbGF5ZXI7XG4gIGlmICh1c2VSYXdTb3VyY2VJbmZvIHx8XG4gICAgdmVyc2lvbiA8PSBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8gfHxcbiAgICAhcmFzdGVyRnVuY3Rpb24gfHxcbiAgICAoKF9hID0gcmFzdGVyRnVuY3Rpb24uZnVuY3Rpb25OYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGxheWVyLnNlcnZpY2VSYXN0ZXJJbmZvLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICB9XG4gIGNvbnN0IHJhc3RlckluZm8gPSAoX2IgPSAoYXdhaXQgbGF5ZXIuZ2VuZXJhdGVSYXN0ZXJJbmZvKGxheWVyLnJhc3RlckZ1bmN0aW9uKSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxheWVyLnNlcnZpY2VSYXN0ZXJJbmZvO1xuICByZXR1cm4gcmFzdGVySW5mby5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbn1cbmZ1bmN0aW9uIGlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCBpZ25vcmVSZWN1cmluZyA9IGZhbHNlKSB7XG4gIHJldHVybiBkaW1lbnNpb25JbmZvLm5hbWUgPT09IFwiU3RkVGltZVwiICYmIChpZ25vcmVSZWN1cmluZyB8fCAhZGltZW5zaW9uSW5mby5yZWN1cnJpbmcpO1xufVxuZnVuY3Rpb24gaXNSZWN1cnJpbmdUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pIHtcbiAgcmV0dXJuIGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRUaW1lXCIgJiYgISFkaW1lbnNpb25JbmZvLnJlY3VycmluZztcbn1cbmZ1bmN0aW9uIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbihkZWYsIGRpbWVuc2lvbkluZm8sIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQpIHtcbiAgZGltZW5zaW9uSW5mbyA9IGdldENsaXBwZWREaW1lbnNpb25JbmZvKGRpbWVuc2lvbkluZm8sIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQpO1xuICBjb25zdCBvcmlnaW5hbEZvcm1hdHRlZFZhbHVlID0gZm9ybWF0RGltZW5zaW9uVmFsdWUoZGVmLnZhbHVlc1swXSwgZGltZW5zaW9uSW5mbyk7XG4gIGNvbnN0IGhhc09yaWdpbmFsRm9ybWF0dGVkVmFsdWUgPSBkaW1lbnNpb25JbmZvLnZhbHVlcy5zb21lKCh2YWwpID0+IG9yaWdpbmFsRm9ybWF0dGVkVmFsdWUgPT09IGZvcm1hdERpbWVuc2lvblZhbHVlKHZhbCwgZGltZW5zaW9uSW5mbykpO1xuICBpZiAoIWhhc09yaWdpbmFsRm9ybWF0dGVkVmFsdWUpIHtcbiAgICAvLyBnZXQgZGVmYXVsdCBzbGljZSB2YWx1ZSB3aGVuIGRlZi52YWx1ZXMgaXMgaW52YWxpZFxuICAgIGNvbnN0IHZhbHVlID0gZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUoZGltZW5zaW9uSW5mbyk7XG4gICAgZGVmLnZhbHVlcyA9IFt2YWx1ZV07XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8gYXMgYSwgZ2V0RGVmYXVsdERpbWVuc2lvblNsaWNlVmFsdWUgYXMgYiwgZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24gYXMgYywgZm9ybWF0RGltZW5zaW9uVmFsdWUgYXMgZiwgZ2V0Q2xpcHBlZERpbWVuc2lvbkluZm8gYXMgZywgaXNUaW1lRGltZW5zaW9uIGFzIGksIG1pblZlcnNpb25SRlRNdWx0aWRpbWVuc2lvbmFsSW5mbyBhcyBtLCB1cGRhdGVEaW1lbnNpb25hbERlZmluaXRpb24gYXMgdSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9