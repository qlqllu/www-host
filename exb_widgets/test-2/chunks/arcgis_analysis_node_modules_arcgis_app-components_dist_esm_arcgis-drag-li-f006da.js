"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-drag-li-f006da"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-drag-list.entry.js":
/*!*******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-drag-list.entry.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_drag_list: () => (/* binding */ ArcgisDragNDropContainer)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const ArcgisDragNDropContainer = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisDragUpdate = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisDragUpdate", 7);
    this.arcgisDragOrderChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisDragOrderChange", 7);
    this.getNewItemListOrder = (eventValue, interactValue, type) => {
      const newOrderValueList = this._getItemListOrder();
      if (!this.autoReorder) {
        const modifier = type === "before" ? 1 : -1;
        newOrderValueList.splice(newOrderValueList.indexOf(eventValue), 1);
        newOrderValueList.splice(newOrderValueList.indexOf(interactValue) + modifier, 0, eventValue);
      }
      return newOrderValueList;
    };
    this.emitNewOrder = (newOrderList) => {
      this.arcgisDragOrderChange.emit(newOrderList !== null && newOrderList !== void 0 ? newOrderList : this._getItemListOrder());
    };
    this.changeNodeOrderOn = "dragenter";
    this.dragImage = undefined;
    this.autoReorder = true;
  }
  _getItemListOrder() {
    const itemList = Array.from(this.ele.querySelectorAll("arcgis-drag-list-item"));
    return itemList.map((item) => item.value);
  }
  async getItemListOrder() {
    return this._getItemListOrder();
  }
  handleHandlerDragEvent(event) {
    var _a;
    event.stopPropagation();
    const { event: dragEvent, eventType, eventTarget } = event.detail;
    if (eventType === "dragstart") {
      this.draggingItem = Object.assign({}, eventTarget);
    }
    else if (eventType === "dragend") {
      this.draggingItem = null;
    }
    dragEvent.dataTransfer.setDragImage((_a = this.dragImage) !== null && _a !== void 0 ? _a : eventTarget.ele, 0, 0);
    this.arcgisDragUpdate.emit({ eventType, event: dragEvent, eventTarget });
  }
  handleItemDragEvent(event) {
    event.stopPropagation();
    const { draggingItem, changeNodeOrderOn, emitNewOrder, arcgisDragUpdate: arcgisDragEvent, autoReorder, getNewItemListOrder } = this;
    const { event: dragEvent, eventType, eventTarget } = event.detail;
    if ((eventType === "dragenter" || eventType === "dragleave") &&
      this.draggingItem.ele === eventTarget.ele) {
      // Prevent duplication
      return;
    }
    const interactTarget = draggingItem;
    const intereactEle = draggingItem.ele;
    const eventEle = eventTarget.ele;
    if (intereactEle !== eventEle) {
      if (eventType === changeNodeOrderOn) {
        // Swap element order
        // https://stackoverflow.com/questions/56680928/compare-order-of-two-html-elements/56681103
        // The idea is to detect whether we are dragging the element above or below
        const type = intereactEle.compareDocumentPosition(eventEle) & Node.DOCUMENT_POSITION_FOLLOWING
          ? "after"
          : "before";
        if (autoReorder) {
          eventEle[type](intereactEle);
        }
        emitNewOrder(getNewItemListOrder(intereactEle.value, eventEle.value, type));
      }
      arcgisDragEvent.emit({ eventType, event: dragEvent, eventTarget, interactTarget });
    }
  }
  handleHandlerNavigationEvent(event) {
    const { closestItem, direction, handlerEle, event: keyboardEvent } = event.detail;
    const { ele, emitNewOrder, autoReorder } = this;
    const children = Array.from(ele.children);
    // ! This assumes there is no inner container that contains MORE THAN 1 of the arcgis drag n drop item
    /** e.g.: this will fail
     * arcgis-drag-list
     * --- inner-container
     * ----- arcgis-drag-list-item
     * ----- arcgis-drag-list-item
     * ----- arcgis-drag-list-item
     *
     * but this works
     * arcgis-drag-list
     * --- inner-container
     * ----- arcgis-drag-list-item
     * --- inner-container
     * ----- arcgis-drag-list-item
     * --- inner-container
     * ----- arcgis-drag-list-item
     */
    const itemIndex = children.findIndex((child) => child.contains(closestItem));
    if (itemIndex <= -1) {
      console.warn("The handler is hidden very sneakily...");
      return;
    }
    // Prevent other event such as overflow scroll
    keyboardEvent.preventDefault();
    const modifier = direction === "up" ? -1 : 1;
    const swapTargetIndex = (itemIndex + modifier + children.length) % children.length;
    const swapTargetChild = children[swapTargetIndex];
    const type = swapTargetIndex > itemIndex ? "after" : "before";
    if (autoReorder) {
      swapTargetChild[type](closestItem);
    }
    const swapTargetItem = swapTargetChild.tagName.toLowerCase() === "arcgis-drag-list-item"
      ? swapTargetChild
      : swapTargetChild.querySelector("arcgis-drag-list-item");
    emitNewOrder(this.getNewItemListOrder(closestItem.value, swapTargetItem.value, type));
    handlerEle.activateHandler();
  }
  render() {
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null)));
  }
  get ele() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWRyYWctbGktZjAwNmRhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7O0FBRTdHO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQiw0QkFBNEIscURBQVc7QUFDdkMsaUNBQWlDLHFEQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUEwQztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFIQUFxSDtBQUNqSSxZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMERBQTBEO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkRBQTJEO0FBQ3ZFLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQUMsQ0FBQyxpREFBSSxRQUFRLHFEQUFDO0FBQzNCO0FBQ0EsY0FBYyxPQUFPLHFEQUFVO0FBQy9COztBQUV3RCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1kcmFnLWxpc3QuZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIEggYXMgSG9zdCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5cbmNvbnN0IEFyY2dpc0RyYWdORHJvcENvbnRhaW5lciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5hcmNnaXNEcmFnVXBkYXRlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNEcmFnVXBkYXRlXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzRHJhZ09yZGVyQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNEcmFnT3JkZXJDaGFuZ2VcIiwgNyk7XG4gICAgdGhpcy5nZXROZXdJdGVtTGlzdE9yZGVyID0gKGV2ZW50VmFsdWUsIGludGVyYWN0VmFsdWUsIHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IG5ld09yZGVyVmFsdWVMaXN0ID0gdGhpcy5fZ2V0SXRlbUxpc3RPcmRlcigpO1xuICAgICAgaWYgKCF0aGlzLmF1dG9SZW9yZGVyKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gdHlwZSA9PT0gXCJiZWZvcmVcIiA/IDEgOiAtMTtcbiAgICAgICAgbmV3T3JkZXJWYWx1ZUxpc3Quc3BsaWNlKG5ld09yZGVyVmFsdWVMaXN0LmluZGV4T2YoZXZlbnRWYWx1ZSksIDEpO1xuICAgICAgICBuZXdPcmRlclZhbHVlTGlzdC5zcGxpY2UobmV3T3JkZXJWYWx1ZUxpc3QuaW5kZXhPZihpbnRlcmFjdFZhbHVlKSArIG1vZGlmaWVyLCAwLCBldmVudFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPcmRlclZhbHVlTGlzdDtcbiAgICB9O1xuICAgIHRoaXMuZW1pdE5ld09yZGVyID0gKG5ld09yZGVyTGlzdCkgPT4ge1xuICAgICAgdGhpcy5hcmNnaXNEcmFnT3JkZXJDaGFuZ2UuZW1pdChuZXdPcmRlckxpc3QgIT09IG51bGwgJiYgbmV3T3JkZXJMaXN0ICE9PSB2b2lkIDAgPyBuZXdPcmRlckxpc3QgOiB0aGlzLl9nZXRJdGVtTGlzdE9yZGVyKCkpO1xuICAgIH07XG4gICAgdGhpcy5jaGFuZ2VOb2RlT3JkZXJPbiA9IFwiZHJhZ2VudGVyXCI7XG4gICAgdGhpcy5kcmFnSW1hZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hdXRvUmVvcmRlciA9IHRydWU7XG4gIH1cbiAgX2dldEl0ZW1MaXN0T3JkZXIoKSB7XG4gICAgY29uc3QgaXRlbUxpc3QgPSBBcnJheS5mcm9tKHRoaXMuZWxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhcmNnaXMtZHJhZy1saXN0LWl0ZW1cIikpO1xuICAgIHJldHVybiBpdGVtTGlzdC5tYXAoKGl0ZW0pID0+IGl0ZW0udmFsdWUpO1xuICB9XG4gIGFzeW5jIGdldEl0ZW1MaXN0T3JkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEl0ZW1MaXN0T3JkZXIoKTtcbiAgfVxuICBoYW5kbGVIYW5kbGVyRHJhZ0V2ZW50KGV2ZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGNvbnN0IHsgZXZlbnQ6IGRyYWdFdmVudCwgZXZlbnRUeXBlLCBldmVudFRhcmdldCB9ID0gZXZlbnQuZGV0YWlsO1xuICAgIGlmIChldmVudFR5cGUgPT09IFwiZHJhZ3N0YXJ0XCIpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdJdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRUYXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudFR5cGUgPT09IFwiZHJhZ2VuZFwiKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nSXRlbSA9IG51bGw7XG4gICAgfVxuICAgIGRyYWdFdmVudC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKChfYSA9IHRoaXMuZHJhZ0ltYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBldmVudFRhcmdldC5lbGUsIDAsIDApO1xuICAgIHRoaXMuYXJjZ2lzRHJhZ1VwZGF0ZS5lbWl0KHsgZXZlbnRUeXBlLCBldmVudDogZHJhZ0V2ZW50LCBldmVudFRhcmdldCB9KTtcbiAgfVxuICBoYW5kbGVJdGVtRHJhZ0V2ZW50KGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgeyBkcmFnZ2luZ0l0ZW0sIGNoYW5nZU5vZGVPcmRlck9uLCBlbWl0TmV3T3JkZXIsIGFyY2dpc0RyYWdVcGRhdGU6IGFyY2dpc0RyYWdFdmVudCwgYXV0b1Jlb3JkZXIsIGdldE5ld0l0ZW1MaXN0T3JkZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBldmVudDogZHJhZ0V2ZW50LCBldmVudFR5cGUsIGV2ZW50VGFyZ2V0IH0gPSBldmVudC5kZXRhaWw7XG4gICAgaWYgKChldmVudFR5cGUgPT09IFwiZHJhZ2VudGVyXCIgfHwgZXZlbnRUeXBlID09PSBcImRyYWdsZWF2ZVwiKSAmJlxuICAgICAgdGhpcy5kcmFnZ2luZ0l0ZW0uZWxlID09PSBldmVudFRhcmdldC5lbGUpIHtcbiAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJhY3RUYXJnZXQgPSBkcmFnZ2luZ0l0ZW07XG4gICAgY29uc3QgaW50ZXJlYWN0RWxlID0gZHJhZ2dpbmdJdGVtLmVsZTtcbiAgICBjb25zdCBldmVudEVsZSA9IGV2ZW50VGFyZ2V0LmVsZTtcbiAgICBpZiAoaW50ZXJlYWN0RWxlICE9PSBldmVudEVsZSkge1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gY2hhbmdlTm9kZU9yZGVyT24pIHtcbiAgICAgICAgLy8gU3dhcCBlbGVtZW50IG9yZGVyXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2NjgwOTI4L2NvbXBhcmUtb3JkZXItb2YtdHdvLWh0bWwtZWxlbWVudHMvNTY2ODExMDNcbiAgICAgICAgLy8gVGhlIGlkZWEgaXMgdG8gZGV0ZWN0IHdoZXRoZXIgd2UgYXJlIGRyYWdnaW5nIHRoZSBlbGVtZW50IGFib3ZlIG9yIGJlbG93XG4gICAgICAgIGNvbnN0IHR5cGUgPSBpbnRlcmVhY3RFbGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZXZlbnRFbGUpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkdcbiAgICAgICAgICA/IFwiYWZ0ZXJcIlxuICAgICAgICAgIDogXCJiZWZvcmVcIjtcbiAgICAgICAgaWYgKGF1dG9SZW9yZGVyKSB7XG4gICAgICAgICAgZXZlbnRFbGVbdHlwZV0oaW50ZXJlYWN0RWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbWl0TmV3T3JkZXIoZ2V0TmV3SXRlbUxpc3RPcmRlcihpbnRlcmVhY3RFbGUudmFsdWUsIGV2ZW50RWxlLnZhbHVlLCB0eXBlKSk7XG4gICAgICB9XG4gICAgICBhcmNnaXNEcmFnRXZlbnQuZW1pdCh7IGV2ZW50VHlwZSwgZXZlbnQ6IGRyYWdFdmVudCwgZXZlbnRUYXJnZXQsIGludGVyYWN0VGFyZ2V0IH0pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVIYW5kbGVyTmF2aWdhdGlvbkV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyBjbG9zZXN0SXRlbSwgZGlyZWN0aW9uLCBoYW5kbGVyRWxlLCBldmVudDoga2V5Ym9hcmRFdmVudCB9ID0gZXZlbnQuZGV0YWlsO1xuICAgIGNvbnN0IHsgZWxlLCBlbWl0TmV3T3JkZXIsIGF1dG9SZW9yZGVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbGUuY2hpbGRyZW4pO1xuICAgIC8vICEgVGhpcyBhc3N1bWVzIHRoZXJlIGlzIG5vIGlubmVyIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIE1PUkUgVEhBTiAxIG9mIHRoZSBhcmNnaXMgZHJhZyBuIGRyb3AgaXRlbVxuICAgIC8qKiBlLmcuOiB0aGlzIHdpbGwgZmFpbFxuICAgICAqIGFyY2dpcy1kcmFnLWxpc3RcbiAgICAgKiAtLS0gaW5uZXItY29udGFpbmVyXG4gICAgICogLS0tLS0gYXJjZ2lzLWRyYWctbGlzdC1pdGVtXG4gICAgICogLS0tLS0gYXJjZ2lzLWRyYWctbGlzdC1pdGVtXG4gICAgICogLS0tLS0gYXJjZ2lzLWRyYWctbGlzdC1pdGVtXG4gICAgICpcbiAgICAgKiBidXQgdGhpcyB3b3Jrc1xuICAgICAqIGFyY2dpcy1kcmFnLWxpc3RcbiAgICAgKiAtLS0gaW5uZXItY29udGFpbmVyXG4gICAgICogLS0tLS0gYXJjZ2lzLWRyYWctbGlzdC1pdGVtXG4gICAgICogLS0tIGlubmVyLWNvbnRhaW5lclxuICAgICAqIC0tLS0tIGFyY2dpcy1kcmFnLWxpc3QtaXRlbVxuICAgICAqIC0tLSBpbm5lci1jb250YWluZXJcbiAgICAgKiAtLS0tLSBhcmNnaXMtZHJhZy1saXN0LWl0ZW1cbiAgICAgKi9cbiAgICBjb25zdCBpdGVtSW5kZXggPSBjaGlsZHJlbi5maW5kSW5kZXgoKGNoaWxkKSA9PiBjaGlsZC5jb250YWlucyhjbG9zZXN0SXRlbSkpO1xuICAgIGlmIChpdGVtSW5kZXggPD0gLTEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRoZSBoYW5kbGVyIGlzIGhpZGRlbiB2ZXJ5IHNuZWFraWx5Li4uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBQcmV2ZW50IG90aGVyIGV2ZW50IHN1Y2ggYXMgb3ZlcmZsb3cgc2Nyb2xsXG4gICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IG1vZGlmaWVyID0gZGlyZWN0aW9uID09PSBcInVwXCIgPyAtMSA6IDE7XG4gICAgY29uc3Qgc3dhcFRhcmdldEluZGV4ID0gKGl0ZW1JbmRleCArIG1vZGlmaWVyICsgY2hpbGRyZW4ubGVuZ3RoKSAlIGNoaWxkcmVuLmxlbmd0aDtcbiAgICBjb25zdCBzd2FwVGFyZ2V0Q2hpbGQgPSBjaGlsZHJlbltzd2FwVGFyZ2V0SW5kZXhdO1xuICAgIGNvbnN0IHR5cGUgPSBzd2FwVGFyZ2V0SW5kZXggPiBpdGVtSW5kZXggPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgIGlmIChhdXRvUmVvcmRlcikge1xuICAgICAgc3dhcFRhcmdldENoaWxkW3R5cGVdKGNsb3Nlc3RJdGVtKTtcbiAgICB9XG4gICAgY29uc3Qgc3dhcFRhcmdldEl0ZW0gPSBzd2FwVGFyZ2V0Q2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImFyY2dpcy1kcmFnLWxpc3QtaXRlbVwiXG4gICAgICA/IHN3YXBUYXJnZXRDaGlsZFxuICAgICAgOiBzd2FwVGFyZ2V0Q2hpbGQucXVlcnlTZWxlY3RvcihcImFyY2dpcy1kcmFnLWxpc3QtaXRlbVwiKTtcbiAgICBlbWl0TmV3T3JkZXIodGhpcy5nZXROZXdJdGVtTGlzdE9yZGVyKGNsb3Nlc3RJdGVtLnZhbHVlLCBzd2FwVGFyZ2V0SXRlbS52YWx1ZSwgdHlwZSkpO1xuICAgIGhhbmRsZXJFbGUuYWN0aXZhdGVIYW5kbGVyKCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwic2xvdFwiLCBudWxsKSkpO1xuICB9XG4gIGdldCBlbGUoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuXG5leHBvcnQgeyBBcmNnaXNEcmFnTkRyb3BDb250YWluZXIgYXMgYXJjZ2lzX2RyYWdfbGlzdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9