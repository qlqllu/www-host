"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-item-pa-2fb63a"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-item-palette.entry.js":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-item-palette.entry.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_item_palette: () => (/* binding */ ArcgisItemPalette)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const arcgisItemPaletteCss = ".sc-arcgis-item-palette-h{display:flex;flex-wrap:wrap;width:100%}.palette.sc-arcgis-item-palette{display:grid;justify-content:space-between;-moz-column-gap:4px;column-gap:4px;row-gap:4px;width:100%}.palette.sc-arcgis-item-palette:focus-within .item--active.sc-arcgis-item-palette:not(.item--selected){border-color:#ccc}.item.sc-arcgis-item-palette{display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid transparent;outline:none}.item--selected.sc-arcgis-item-palette{border-color:#0079c1;font-weight:bolder}.marker-item.sc-arcgis-item-palette>div.sc-arcgis-item-palette>img.sc-arcgis-item-palette{width:100%}";

const ItemPaletteCSS = {
  palette: "palette",
  item: "item",
  itemActive: "item--active",
  itemSelected: "item--selected"
};
const indexToXY = (index, width) => {
  const x = index % width;
  const y = Math.floor(index / width);
  return { x, y };
};
const xyToIndex = (x, y, width) => x + width * y;
function ensureItemIsInView(scrollerContainer, blockOrSection) {
  if (!scrollerContainer) {
    return;
  }
  const scrollerRect = scrollerContainer.getBoundingClientRect();
  const blockOrSectionRect = blockOrSection.getBoundingClientRect();
  const blockOrSectionHeight = blockOrSectionRect.top + blockOrSectionRect.height;
  const scrollerHeight = scrollerRect.top + scrollerRect.height;
  const needToScrollDown = blockOrSectionHeight > scrollerHeight;
  if (needToScrollDown) {
    const scrollAmount = Math.abs(scrollerHeight - blockOrSectionHeight);
    scrollerContainer.scrollTop += scrollAmount;
    return;
  }
  const needToScrollUp = blockOrSectionRect.top < scrollerRect.top;
  if (needToScrollUp) {
    const scrollAmount = Math.abs(blockOrSectionRect.top - scrollerRect.top);
    scrollerContainer.scrollTop -= scrollAmount;
  }
}
const ArcgisItemPalette = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisItemSelect = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisItemSelect", 7);
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.handleFocus = () => {
      const { items, selected } = this;
      const selectedItemIndex = items.findIndex((item) => typeof selected === "function"
        ? selected(item)
        : item === selected);
      this.selectedItemIndex = selectedItemIndex;
      this.activeItemIndex = selectedItemIndex < 0 ? 0 : selectedItemIndex;
    };
    this.handleKeyDown = (event) => {
      const { key } = event;
      const { el, itemsPerRow, items } = this;
      const NAVIGATION_KEYS = [" ", "Enter", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp"];
      if (NAVIGATION_KEYS.indexOf(key) === -1) {
        return;
      }
      if (key === "ArrowLeft") {
        this.activeItemIndex = this.moveItemIndex("left", itemsPerRow);
      }
      else if (key === "ArrowRight") {
        this.activeItemIndex = this.moveItemIndex("right", itemsPerRow);
      }
      else if (key === "ArrowUp") {
        this.activeItemIndex = this.moveItemIndex("up", itemsPerRow);
      }
      else if (key === "ArrowDown") {
        this.activeItemIndex = this.moveItemIndex("down", itemsPerRow);
      }
      else if (key === "Enter" || key === " ") {
        this.selectItem(items[this.activeItemIndex]);
      }
      const activeItem = el.querySelectorAll(`.${ItemPaletteCSS.item}`)[this.activeItemIndex];
      ensureItemIsInView(el.parentElement, activeItem);
      event.preventDefault();
      event.stopPropagation();
    };
    this.moveItemIndex = (direction, itemsPerRow) => {
      const currentIndex = this.activeItemIndex;
      const totalItems = this.items.length;
      let { x, y } = indexToXY(currentIndex, itemsPerRow);
      const origX = x;
      const origY = y;
      if (direction === "left") {
        x -= 1;
      }
      else if (direction === "right") {
        x += 1;
      }
      if (x < 0) {
        x = 0;
      }
      else if (x > itemsPerRow - 1) {
        x = itemsPerRow - 1;
      }
      else if (direction === "up") {
        y -= 1;
      }
      else if (direction === "down") {
        y += 1;
      }
      const rows = Math.ceil(totalItems / itemsPerRow);
      if (y < 0) {
        y = 0;
      }
      else if (y > rows - 1) {
        y = rows - 1;
      }
      const futureIndex = x + itemsPerRow * y;
      if (futureIndex > totalItems - 1) {
        return xyToIndex(origX, origY, itemsPerRow);
      }
      return xyToIndex(x, y, itemsPerRow);
    };
    this.handleClick = (event) => {
      const node = event.currentTarget;
      const itemIndex = Number(node.getAttribute("data-index"));
      this.selectItem(this.items[itemIndex]);
    };
    this.selectItem = (item) => {
      const { items, arcgisItemSelect } = this;
      const itemIndex = items.indexOf(item);
      this.selectedItemIndex = itemIndex;
      this.activeItemIndex = itemIndex;
      arcgisItemSelect.emit(item);
    };
    this.extraItemProps = undefined;
    this.ItemRenderer = undefined;
    this.items = undefined;
    this.itemsPerRow = 5;
    this.itemProperty = undefined;
    this.selected = undefined;
    this.activeItemIndex = 0;
    this.selectedItemIndex = 0;
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Set focus on selected item, e.g. when item gets selected without a mouse click
   */
  async setFocus() {
    var _a;
    this.handleFocus();
    (_a = this.el.querySelector(`.${ItemPaletteCSS.itemSelected}`)) === null || _a === void 0 ? void 0 : _a.focus();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    var _a;
    const { items, ItemRenderer, extraItemProps, itemProperty, selected, itemsPerRow } = this;
    const itemWrappers = [];
    const totalRows = Math.ceil(items.length / itemsPerRow);
    const gridTemplateColumns = Array(itemsPerRow).fill("auto").join(" ");
    for (let y = 0; y < totalRows; y++) {
      for (let x = 0, index = xyToIndex(x, y, itemsPerRow); x < itemsPerRow; x++, index = xyToIndex(x, y, itemsPerRow)) {
        const item = items[index];
        if (index >= items.length) {
          break;
        }
        itemWrappers.push((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: {
            [ItemPaletteCSS.item]: true,
            [ItemPaletteCSS.itemActive]: index === this.activeItemIndex,
            [ItemPaletteCSS.itemSelected]: typeof selected === "function"
              ? selected(item)
              : item === selected
          }, "data-index": index, key: index, onClick: this.handleClick, tabIndex: -1, "aria-label": ((_a = item.item) === null || _a === void 0 ? void 0 : _a.data) ? (item.item.data.title || item.item.data.name) : item.name }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(ItemRenderer, Object.assign({}, Object.assign(Object.assign({}, (itemProperty ? { [itemProperty]: item } : item)), extraItemProps)))));
      }
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: ItemPaletteCSS.palette, "data-row-size": itemsPerRow, onFocus: this.handleFocus, onKeyDown: this.handleKeyDown, tabIndex: 0, style: { gridTemplateColumns } }, itemWrappers));
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisItemPalette.style = arcgisItemPaletteCss;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWl0ZW0tcGEtMmZiNjNhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDa0c7O0FBRWxHLHdEQUF3RCxhQUFhLGVBQWUsV0FBVyxnQ0FBZ0MsYUFBYSw4QkFBOEIsb0JBQW9CLGVBQWUsWUFBWSxXQUFXLHVHQUF1RyxrQkFBa0IsNkJBQTZCLGFBQWEsbUJBQW1CLHVCQUF1QixlQUFlLDZCQUE2QixhQUFhLHVDQUF1QyxxQkFBcUIsbUJBQW1CLDBGQUEwRixXQUFXOztBQUU5cEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCLDRCQUE0QixxREFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQkFBb0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJFQUEyRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFDLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdU5BQXVOLEVBQUUscURBQUMsK0JBQStCLGdDQUFnQyxvQkFBb0IsdUJBQXVCO0FBQy9VO0FBQ0E7QUFDQSxZQUFZLHFEQUFDLFVBQVUsNklBQTZJLHVCQUF1QjtBQUMzTDtBQUNBLGFBQWEsT0FBTyxxREFBVTtBQUM5QjtBQUNBOztBQUVvRCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1pdGVtLXBhbGV0dGUuZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuXG5jb25zdCBhcmNnaXNJdGVtUGFsZXR0ZUNzcyA9IFwiLnNjLWFyY2dpcy1pdGVtLXBhbGV0dGUtaHtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOndyYXA7d2lkdGg6MTAwJX0ucGFsZXR0ZS5zYy1hcmNnaXMtaXRlbS1wYWxldHRle2Rpc3BsYXk6Z3JpZDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjstbW96LWNvbHVtbi1nYXA6NHB4O2NvbHVtbi1nYXA6NHB4O3Jvdy1nYXA6NHB4O3dpZHRoOjEwMCV9LnBhbGV0dGUuc2MtYXJjZ2lzLWl0ZW0tcGFsZXR0ZTpmb2N1cy13aXRoaW4gLml0ZW0tLWFjdGl2ZS5zYy1hcmNnaXMtaXRlbS1wYWxldHRlOm5vdCguaXRlbS0tc2VsZWN0ZWQpe2JvcmRlci1jb2xvcjojY2NjfS5pdGVtLnNjLWFyY2dpcy1pdGVtLXBhbGV0dGV7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2N1cnNvcjpwb2ludGVyO2JvcmRlcjoycHggc29saWQgdHJhbnNwYXJlbnQ7b3V0bGluZTpub25lfS5pdGVtLS1zZWxlY3RlZC5zYy1hcmNnaXMtaXRlbS1wYWxldHRle2JvcmRlci1jb2xvcjojMDA3OWMxO2ZvbnQtd2VpZ2h0OmJvbGRlcn0ubWFya2VyLWl0ZW0uc2MtYXJjZ2lzLWl0ZW0tcGFsZXR0ZT5kaXYuc2MtYXJjZ2lzLWl0ZW0tcGFsZXR0ZT5pbWcuc2MtYXJjZ2lzLWl0ZW0tcGFsZXR0ZXt3aWR0aDoxMDAlfVwiO1xuXG5jb25zdCBJdGVtUGFsZXR0ZUNTUyA9IHtcbiAgcGFsZXR0ZTogXCJwYWxldHRlXCIsXG4gIGl0ZW06IFwiaXRlbVwiLFxuICBpdGVtQWN0aXZlOiBcIml0ZW0tLWFjdGl2ZVwiLFxuICBpdGVtU2VsZWN0ZWQ6IFwiaXRlbS0tc2VsZWN0ZWRcIlxufTtcbmNvbnN0IGluZGV4VG9YWSA9IChpbmRleCwgd2lkdGgpID0+IHtcbiAgY29uc3QgeCA9IGluZGV4ICUgd2lkdGg7XG4gIGNvbnN0IHkgPSBNYXRoLmZsb29yKGluZGV4IC8gd2lkdGgpO1xuICByZXR1cm4geyB4LCB5IH07XG59O1xuY29uc3QgeHlUb0luZGV4ID0gKHgsIHksIHdpZHRoKSA9PiB4ICsgd2lkdGggKiB5O1xuZnVuY3Rpb24gZW5zdXJlSXRlbUlzSW5WaWV3KHNjcm9sbGVyQ29udGFpbmVyLCBibG9ja09yU2VjdGlvbikge1xuICBpZiAoIXNjcm9sbGVyQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNjcm9sbGVyUmVjdCA9IHNjcm9sbGVyQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBibG9ja09yU2VjdGlvblJlY3QgPSBibG9ja09yU2VjdGlvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgYmxvY2tPclNlY3Rpb25IZWlnaHQgPSBibG9ja09yU2VjdGlvblJlY3QudG9wICsgYmxvY2tPclNlY3Rpb25SZWN0LmhlaWdodDtcbiAgY29uc3Qgc2Nyb2xsZXJIZWlnaHQgPSBzY3JvbGxlclJlY3QudG9wICsgc2Nyb2xsZXJSZWN0LmhlaWdodDtcbiAgY29uc3QgbmVlZFRvU2Nyb2xsRG93biA9IGJsb2NrT3JTZWN0aW9uSGVpZ2h0ID4gc2Nyb2xsZXJIZWlnaHQ7XG4gIGlmIChuZWVkVG9TY3JvbGxEb3duKSB7XG4gICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5hYnMoc2Nyb2xsZXJIZWlnaHQgLSBibG9ja09yU2VjdGlvbkhlaWdodCk7XG4gICAgc2Nyb2xsZXJDb250YWluZXIuc2Nyb2xsVG9wICs9IHNjcm9sbEFtb3VudDtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmVlZFRvU2Nyb2xsVXAgPSBibG9ja09yU2VjdGlvblJlY3QudG9wIDwgc2Nyb2xsZXJSZWN0LnRvcDtcbiAgaWYgKG5lZWRUb1Njcm9sbFVwKSB7XG4gICAgY29uc3Qgc2Nyb2xsQW1vdW50ID0gTWF0aC5hYnMoYmxvY2tPclNlY3Rpb25SZWN0LnRvcCAtIHNjcm9sbGVyUmVjdC50b3ApO1xuICAgIHNjcm9sbGVyQ29udGFpbmVyLnNjcm9sbFRvcCAtPSBzY3JvbGxBbW91bnQ7XG4gIH1cbn1cbmNvbnN0IEFyY2dpc0l0ZW1QYWxldHRlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFyY2dpc0l0ZW1TZWxlY3QgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0l0ZW1TZWxlY3RcIiwgNyk7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMuaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGl0ZW1zLCBzZWxlY3RlZCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNlbGVjdGVkSXRlbUluZGV4ID0gaXRlbXMuZmluZEluZGV4KChpdGVtKSA9PiB0eXBlb2Ygc2VsZWN0ZWQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHNlbGVjdGVkKGl0ZW0pXG4gICAgICAgIDogaXRlbSA9PT0gc2VsZWN0ZWQpO1xuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1JbmRleCA9IHNlbGVjdGVkSXRlbUluZGV4O1xuICAgICAgdGhpcy5hY3RpdmVJdGVtSW5kZXggPSBzZWxlY3RlZEl0ZW1JbmRleCA8IDAgPyAwIDogc2VsZWN0ZWRJdGVtSW5kZXg7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUtleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsga2V5IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IHsgZWwsIGl0ZW1zUGVyUm93LCBpdGVtcyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IE5BVklHQVRJT05fS0VZUyA9IFtcIiBcIiwgXCJFbnRlclwiLCBcIkFycm93RG93blwiLCBcIkFycm93TGVmdFwiLCBcIkFycm93UmlnaHRcIiwgXCJBcnJvd1VwXCJdO1xuICAgICAgaWYgKE5BVklHQVRJT05fS0VZUy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtSW5kZXggPSB0aGlzLm1vdmVJdGVtSW5kZXgoXCJsZWZ0XCIsIGl0ZW1zUGVyUm93KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJBcnJvd1JpZ2h0XCIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtSW5kZXggPSB0aGlzLm1vdmVJdGVtSW5kZXgoXCJyaWdodFwiLCBpdGVtc1BlclJvdyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbUluZGV4ID0gdGhpcy5tb3ZlSXRlbUluZGV4KFwidXBcIiwgaXRlbXNQZXJSb3cpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIkFycm93RG93blwiKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbUluZGV4ID0gdGhpcy5tb3ZlSXRlbUluZGV4KFwiZG93blwiLCBpdGVtc1BlclJvdyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0SXRlbShpdGVtc1t0aGlzLmFjdGl2ZUl0ZW1JbmRleF0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlSXRlbSA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0l0ZW1QYWxldHRlQ1NTLml0ZW19YClbdGhpcy5hY3RpdmVJdGVtSW5kZXhdO1xuICAgICAgZW5zdXJlSXRlbUlzSW5WaWV3KGVsLnBhcmVudEVsZW1lbnQsIGFjdGl2ZUl0ZW0pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5tb3ZlSXRlbUluZGV4ID0gKGRpcmVjdGlvbiwgaXRlbXNQZXJSb3cpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuYWN0aXZlSXRlbUluZGV4O1xuICAgICAgY29uc3QgdG90YWxJdGVtcyA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgbGV0IHsgeCwgeSB9ID0gaW5kZXhUb1hZKGN1cnJlbnRJbmRleCwgaXRlbXNQZXJSb3cpO1xuICAgICAgY29uc3Qgb3JpZ1ggPSB4O1xuICAgICAgY29uc3Qgb3JpZ1kgPSB5O1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgeCAtPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgeCArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoeCA+IGl0ZW1zUGVyUm93IC0gMSkge1xuICAgICAgICB4ID0gaXRlbXNQZXJSb3cgLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIpIHtcbiAgICAgICAgeSAtPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImRvd25cIikge1xuICAgICAgICB5ICs9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5jZWlsKHRvdGFsSXRlbXMgLyBpdGVtc1BlclJvdyk7XG4gICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgeSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh5ID4gcm93cyAtIDEpIHtcbiAgICAgICAgeSA9IHJvd3MgLSAxO1xuICAgICAgfVxuICAgICAgY29uc3QgZnV0dXJlSW5kZXggPSB4ICsgaXRlbXNQZXJSb3cgKiB5O1xuICAgICAgaWYgKGZ1dHVyZUluZGV4ID4gdG90YWxJdGVtcyAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHh5VG9JbmRleChvcmlnWCwgb3JpZ1ksIGl0ZW1zUGVyUm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4eVRvSW5kZXgoeCwgeSwgaXRlbXNQZXJSb3cpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBpdGVtSW5kZXggPSBOdW1iZXIobm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluZGV4XCIpKTtcbiAgICAgIHRoaXMuc2VsZWN0SXRlbSh0aGlzLml0ZW1zW2l0ZW1JbmRleF0pO1xuICAgIH07XG4gICAgdGhpcy5zZWxlY3RJdGVtID0gKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHsgaXRlbXMsIGFyY2dpc0l0ZW1TZWxlY3QgfSA9IHRoaXM7XG4gICAgICBjb25zdCBpdGVtSW5kZXggPSBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1JbmRleCA9IGl0ZW1JbmRleDtcbiAgICAgIHRoaXMuYWN0aXZlSXRlbUluZGV4ID0gaXRlbUluZGV4O1xuICAgICAgYXJjZ2lzSXRlbVNlbGVjdC5lbWl0KGl0ZW0pO1xuICAgIH07XG4gICAgdGhpcy5leHRyYUl0ZW1Qcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLkl0ZW1SZW5kZXJlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLml0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXRlbXNQZXJSb3cgPSA1O1xuICAgIHRoaXMuaXRlbVByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hY3RpdmVJdGVtSW5kZXggPSAwO1xuICAgIHRoaXMuc2VsZWN0ZWRJdGVtSW5kZXggPSAwO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFB1YmxpYyBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIFNldCBmb2N1cyBvbiBzZWxlY3RlZCBpdGVtLCBlLmcuIHdoZW4gaXRlbSBnZXRzIHNlbGVjdGVkIHdpdGhvdXQgYSBtb3VzZSBjbGlja1xuICAgKi9cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuaGFuZGxlRm9jdXMoKTtcbiAgICAoX2EgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoYC4ke0l0ZW1QYWxldHRlQ1NTLml0ZW1TZWxlY3RlZH1gKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGl0ZW1zLCBJdGVtUmVuZGVyZXIsIGV4dHJhSXRlbVByb3BzLCBpdGVtUHJvcGVydHksIHNlbGVjdGVkLCBpdGVtc1BlclJvdyB9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtV3JhcHBlcnMgPSBbXTtcbiAgICBjb25zdCB0b3RhbFJvd3MgPSBNYXRoLmNlaWwoaXRlbXMubGVuZ3RoIC8gaXRlbXNQZXJSb3cpO1xuICAgIGNvbnN0IGdyaWRUZW1wbGF0ZUNvbHVtbnMgPSBBcnJheShpdGVtc1BlclJvdykuZmlsbChcImF1dG9cIikuam9pbihcIiBcIik7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0b3RhbFJvd3M7IHkrKykge1xuICAgICAgZm9yIChsZXQgeCA9IDAsIGluZGV4ID0geHlUb0luZGV4KHgsIHksIGl0ZW1zUGVyUm93KTsgeCA8IGl0ZW1zUGVyUm93OyB4KyssIGluZGV4ID0geHlUb0luZGV4KHgsIHksIGl0ZW1zUGVyUm93KSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbVdyYXBwZXJzLnB1c2goaChcImRpdlwiLCB7IGNsYXNzOiB7XG4gICAgICAgICAgICBbSXRlbVBhbGV0dGVDU1MuaXRlbV06IHRydWUsXG4gICAgICAgICAgICBbSXRlbVBhbGV0dGVDU1MuaXRlbUFjdGl2ZV06IGluZGV4ID09PSB0aGlzLmFjdGl2ZUl0ZW1JbmRleCxcbiAgICAgICAgICAgIFtJdGVtUGFsZXR0ZUNTUy5pdGVtU2VsZWN0ZWRdOiB0eXBlb2Ygc2VsZWN0ZWQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICA/IHNlbGVjdGVkKGl0ZW0pXG4gICAgICAgICAgICAgIDogaXRlbSA9PT0gc2VsZWN0ZWRcbiAgICAgICAgICB9LCBcImRhdGEtaW5kZXhcIjogaW5kZXgsIGtleTogaW5kZXgsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssIHRhYkluZGV4OiAtMSwgXCJhcmlhLWxhYmVsXCI6ICgoX2EgPSBpdGVtLml0ZW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSA/IChpdGVtLml0ZW0uZGF0YS50aXRsZSB8fCBpdGVtLml0ZW0uZGF0YS5uYW1lKSA6IGl0ZW0ubmFtZSB9LCBoKEl0ZW1SZW5kZXJlciwgT2JqZWN0LmFzc2lnbih7fSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoaXRlbVByb3BlcnR5ID8geyBbaXRlbVByb3BlcnR5XTogaXRlbSB9IDogaXRlbSkpLCBleHRyYUl0ZW1Qcm9wcykpKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogSXRlbVBhbGV0dGVDU1MucGFsZXR0ZSwgXCJkYXRhLXJvdy1zaXplXCI6IGl0ZW1zUGVyUm93LCBvbkZvY3VzOiB0aGlzLmhhbmRsZUZvY3VzLCBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93biwgdGFiSW5kZXg6IDAsIHN0eWxlOiB7IGdyaWRUZW1wbGF0ZUNvbHVtbnMgfSB9LCBpdGVtV3JhcHBlcnMpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzSXRlbVBhbGV0dGUuc3R5bGUgPSBhcmNnaXNJdGVtUGFsZXR0ZUNzcztcblxuZXhwb3J0IHsgQXJjZ2lzSXRlbVBhbGV0dGUgYXMgYXJjZ2lzX2l0ZW1fcGFsZXR0ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9