"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_esri_calcite-components-react_node_modules_esri_calcite-components_dist_-49959e"],{

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/calcite-graph.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/calcite-graph.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CalciteGraph: () => (/* binding */ CalciteGraph),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/graph.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */


const CalciteGraph = _graph_js__WEBPACK_IMPORTED_MODULE_0__.G;
const defineCustomElement = _graph_js__WEBPACK_IMPORTED_MODULE_0__.d;




/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/graph.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/graph.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ Graph),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/index.js");
/* harmony import */ var _guid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./guid.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/guid.js");
/* harmony import */ var _observers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observers.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/observers.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */




/**
 * Calculate slope of the tangents
 * uses Steffen interpolation as it's monotonic
 * http://jrwalsh1.github.io/posts/interpolations/
 *
 * @param p0
 * @param p1
 * @param p2
 */
function slope(p0, p1, p2) {
  const dx = p1[0] - p0[0];
  const dx1 = p2[0] - p1[0];
  const dy = p1[1] - p0[1];
  const dy1 = p2[1] - p1[1];
  const m = dy / (dx || (dx1 < 0 && 0));
  const m1 = dy1 / (dx1 || (dx < 0 && 0));
  const p = (m * dx1 + m1 * dx) / (dx + dx1);
  return (Math.sign(m) + Math.sign(m1)) * Math.min(Math.abs(m), Math.abs(m1), 0.5 * Math.abs(p)) || 0;
}
/**
 * Calculate slope for just one tangent (single-sided)
 *
 * @param p0
 * @param p1
 * @param m
 */
function slopeSingle(p0, p1, m) {
  const dx = p1[0] - p0[0];
  const dy = p1[1] - p0[1];
  return dx ? ((3 * dy) / dx - m) / 2 : m;
}
/**
 * Given two points and their tangent slopes,
 * calculate the bezier handle coordinates and return draw command.
 *
 * Translates Hermite Spline to BÃ©zier curve:
 * https://stackoverflow.com/questions/42574940/
 *
 * @param p0
 * @param p1
 * @param m0
 * @param m1
 * @param t
 */
function bezier(p0, p1, m0, m1, t) {
  const [x0, y0] = p0;
  const [x1, y1] = p1;
  const dx = (x1 - x0) / 3;
  const h1 = t([x0 + dx, y0 + dx * m0]).join(",");
  const h2 = t([x1 - dx, y1 - dx * m1]).join(",");
  const p = t([x1, y1]).join(",");
  return `C ${h1} ${h2} ${p}`;
}
/**
 * Generate a function which will translate a point
 * from the data coordinate space to svg viewbox oriented pixels
 *
 * @param root0
 * @param root0.width
 * @param root0.height
 * @param root0.min
 * @param root0.max
 */
function translate({ width, height, min, max }) {
  const rangeX = max[0] - min[0];
  const rangeY = max[1] - min[1];
  return (point) => {
    const x = ((point[0] - min[0]) / rangeX) * width;
    const y = height - (point[1] / rangeY) * height;
    return [x, y];
  };
}
/**
 * Get the min and max values from the dataset
 *
 * @param data
 */
function range(data) {
  const [startX, startY] = data[0];
  const min = [startX, startY];
  const max = [startX, startY];
  return data.reduce(({ min, max }, [x, y]) => ({
    min: [Math.min(min[0], x), Math.min(min[1], y)],
    max: [Math.max(max[0], x), Math.max(max[1], y)],
  }), { min, max });
}
/**
 * Generate drawing commands for an area graph
 * returns a string can can be passed directly to a path element's `d` attribute
 *
 * @param root0
 * @param root0.data
 * @param root0.min
 * @param root0.max
 * @param root0.t
 */
function area({ data, min, max, t }) {
  if (data.length === 0) {
    return "";
  }
  // important points for beginning and ending the path
  const [startX, startY] = t(data[0]);
  const [minX, minY] = t(min);
  const [maxX] = t(max);
  // keep track of previous slope/points
  let m;
  let p0;
  let p1;
  // iterate over data points, calculating command for each
  const commands = data.reduce((acc, point, i) => {
    p0 = data[i - 2];
    p1 = data[i - 1];
    if (i > 1) {
      const m1 = slope(p0, p1, point);
      const m0 = m === undefined ? slopeSingle(p0, p1, m1) : m;
      const command = bezier(p0, p1, m0, m1, t);
      m = m1;
      return `${acc} ${command}`;
    }
    return acc;
  }, `M ${minX},${minY} L ${minX},${startY} L ${startX},${startY}`);
  // close the path
  const last = data[data.length - 1];
  const end = bezier(p1, last, m, slopeSingle(p1, last, m), t);
  return `${commands} ${end} L ${maxX},${minY} Z`;
}

const graphCss = ":host{display:block;block-size:100%}.svg{fill:currentColor;stroke:transparent;margin:0px;display:block;block-size:100%;inline-size:100%;padding:0px}.svg .graph-path--highlight{fill:var(--calcite-ui-brand);opacity:0.5}:host([hidden]){display:none}[hidden]{display:none}";

const Graph = /*@__PURE__*/ (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class extends _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.graphId = `calcite-graph-${(0,_guid_js__WEBPACK_IMPORTED_MODULE_0__.g)()}`;
    this.resizeObserver = (0,_observers_js__WEBPACK_IMPORTED_MODULE_1__.c)("resize", () => (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.forceUpdate)(this));
    this.data = [];
    this.colorStops = undefined;
    this.highlightMin = undefined;
    this.highlightMax = undefined;
    this.min = undefined;
    this.max = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  connectedCallback() {
    this.resizeObserver?.observe(this.el);
  }
  disconnectedCallback() {
    this.resizeObserver?.disconnect();
  }
  render() {
    const { data, colorStops, el, highlightMax, highlightMin, min, max } = this;
    const id = this.graphId;
    const { clientHeight: height, clientWidth: width } = el;
    // if we have no data, return empty svg
    if (!data || data.length === 0) {
      return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("svg", { "aria-hidden": "true", class: "svg", height: height, preserveAspectRatio: "none", viewBox: `0 0 ${width} ${height}`, width: width }));
    }
    const { min: rangeMin, max: rangeMax } = range(data);
    let currentMin = rangeMin;
    let currentMax = rangeMax;
    if (min < rangeMin[0] || min > rangeMin[0]) {
      currentMin = [min, 0];
    }
    if (max > rangeMax[0] || max < rangeMax[0]) {
      currentMax = [max, rangeMax[1]];
    }
    const t = translate({ min: currentMin, max: currentMax, width, height });
    const [hMinX] = t([highlightMin, currentMax[1]]);
    const [hMaxX] = t([highlightMax, currentMax[1]]);
    const areaPath = area({ data, min: rangeMin, max: rangeMax, t });
    const fill = colorStops ? `url(#linear-gradient-${id})` : undefined;
    return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("svg", { "aria-hidden": "true", class: "svg", height: height, preserveAspectRatio: "none", viewBox: `0 0 ${width} ${height}`, width: width }, colorStops ? ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("defs", null, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("linearGradient", { id: `linear-gradient-${id}`, x1: "0", x2: "1", y1: "0", y2: "0" }, colorStops.map(({ offset, color, opacity }) => ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("stop", { offset: `${offset * 100}%`, "stop-color": color, "stop-opacity": opacity })))))) : null, highlightMin !== undefined ? ([
      (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("mask", { height: "100%", id: `${id}1`, width: "100%", x: "0%", y: "0%" }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { d: `
            M 0,0
            L ${hMinX - 1},0
            L ${hMinX - 1},${height}
            L 0,${height}
            Z
          `, fill: "white" })),
      (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("mask", { height: "100%", id: `${id}2`, width: "100%", x: "0%", y: "0%" }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { d: `
            M ${hMinX + 1},0
            L ${hMaxX - 1},0
            L ${hMaxX - 1},${height}
            L ${hMinX + 1}, ${height}
            Z
          `, fill: "white" })),
      (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("mask", { height: "100%", id: `${id}3`, width: "100%", x: "0%", y: "0%" }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { d: `
                M ${hMaxX + 1},0
                L ${width},0
                L ${width},${height}
                L ${hMaxX + 1}, ${height}
                Z
              `, fill: "white" })),
      (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { class: "graph-path", d: areaPath, fill: fill, mask: `url(#${id}1)` }),
      (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { class: "graph-path--highlight", d: areaPath, fill: fill, mask: `url(#${id}2)` }),
      (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { class: "graph-path", d: areaPath, fill: fill, mask: `url(#${id}3)` }),
    ]) : ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("path", { class: "graph-path", d: areaPath, fill: fill }))));
  }
  get el() { return this; }
  static get style() { return graphCss; }
}, [1, "calcite-graph", {
    "data": [16],
    "colorStops": [16],
    "highlightMin": [2, "highlight-min"],
    "highlightMax": [2, "highlight-max"],
    "min": [514],
    "max": [514]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-graph"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-graph":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, Graph);
      }
      break;
  } });
}
defineCustomElement();




/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/guid.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/guid.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */
function gen(counts) {
  return counts
    .map((count) => {
    let out = "";
    for (let i = 0; i < count; i++) {
      out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    return out;
  })
    .join("-");
}
const guid = () => gen([2, 1, 1, 1, 3]);




/***/ }),

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/observers.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/observers.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createObserver)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/index.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */


/**
 * This utility ensures observers are created only for browser contexts.
 *
 * @param type - the type of observer to create
 * @param callback - the observer callback
 * @param options - the observer options
 */
function createObserver(type, callback, options) {
  if (!_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_0__.Build.isBrowser) {
    return undefined;
  }
  const Observer = getObserver(type);
  return new Observer(callback, options);
}
function getObserver(type) {
  // based on https://github.com/whatwg/dom/issues/126#issuecomment-1049814948
  class ExtendedMutationObserver extends window.MutationObserver {
    constructor(callback) {
      super(callback);
      this.observedEntry = [];
      this.callback = callback;
    }
    observe(target, options) {
      this.observedEntry.push({ target, options });
      return super.observe(target, options);
    }
    unobserve(target) {
      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);
      this.observedEntry = [];
      this.callback(super.takeRecords(), this);
      this.disconnect();
      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));
    }
  }
  return (function () {
    return (type === "intersection"
      ? window.IntersectionObserver
      : type === "mutation"
        ? ExtendedMutationObserver
        : window.ResizeObserver);
  })();
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHMtcmVhY3Rfbm9kZV9tb2R1bGVzX2VzcmlfY2FsY2l0ZS1jb21wb25lbnRzX2Rpc3RfLTQ5OTU5ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29FOztBQUVwRSxxQkFBcUIsd0NBQUs7QUFDMUIsNEJBQTRCLHdDQUFxQjs7QUFFSjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1Y3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lHO0FBQ25FO0FBQ2U7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0EsR0FBRyxLQUFLLFVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FB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L0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFcUI7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlFQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMtcmVhY3Qvbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2NvbXBvbmVudHMvY2FsY2l0ZS1ncmFwaC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy1yZWFjdC9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvY29tcG9uZW50cy9ncmFwaC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy1yZWFjdC9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvY29tcG9uZW50cy9ndWlkLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL29ic2VydmVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMTEuMFxuICovXG5pbXBvcnQgeyBHIGFzIEdyYXBoLCBkIGFzIGRlZmluZUN1c3RvbUVsZW1lbnQkMSB9IGZyb20gJy4vZ3JhcGguanMnO1xuXG5jb25zdCBDYWxjaXRlR3JhcGggPSBHcmFwaDtcbmNvbnN0IGRlZmluZUN1c3RvbUVsZW1lbnQgPSBkZWZpbmVDdXN0b21FbGVtZW50JDE7XG5cbmV4cG9ydCB7IENhbGNpdGVHcmFwaCwgZGVmaW5lQ3VzdG9tRWxlbWVudCB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL21haW4vTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjExLjBcbiAqL1xuaW1wb3J0IHsgcHJveHlDdXN0b21FbGVtZW50LCBIVE1MRWxlbWVudCwgZm9yY2VVcGRhdGUsIGggfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyc7XG5pbXBvcnQgeyBnIGFzIGd1aWQgfSBmcm9tICcuL2d1aWQuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVPYnNlcnZlciB9IGZyb20gJy4vb2JzZXJ2ZXJzLmpzJztcblxuLyoqXG4gKiBDYWxjdWxhdGUgc2xvcGUgb2YgdGhlIHRhbmdlbnRzXG4gKiB1c2VzIFN0ZWZmZW4gaW50ZXJwb2xhdGlvbiBhcyBpdCdzIG1vbm90b25pY1xuICogaHR0cDovL2pyd2Fsc2gxLmdpdGh1Yi5pby9wb3N0cy9pbnRlcnBvbGF0aW9ucy9cbiAqXG4gKiBAcGFyYW0gcDBcbiAqIEBwYXJhbSBwMVxuICogQHBhcmFtIHAyXG4gKi9cbmZ1bmN0aW9uIHNsb3BlKHAwLCBwMSwgcDIpIHtcbiAgY29uc3QgZHggPSBwMVswXSAtIHAwWzBdO1xuICBjb25zdCBkeDEgPSBwMlswXSAtIHAxWzBdO1xuICBjb25zdCBkeSA9IHAxWzFdIC0gcDBbMV07XG4gIGNvbnN0IGR5MSA9IHAyWzFdIC0gcDFbMV07XG4gIGNvbnN0IG0gPSBkeSAvIChkeCB8fCAoZHgxIDwgMCAmJiAwKSk7XG4gIGNvbnN0IG0xID0gZHkxIC8gKGR4MSB8fCAoZHggPCAwICYmIDApKTtcbiAgY29uc3QgcCA9IChtICogZHgxICsgbTEgKiBkeCkgLyAoZHggKyBkeDEpO1xuICByZXR1cm4gKE1hdGguc2lnbihtKSArIE1hdGguc2lnbihtMSkpICogTWF0aC5taW4oTWF0aC5hYnMobSksIE1hdGguYWJzKG0xKSwgMC41ICogTWF0aC5hYnMocCkpIHx8IDA7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBzbG9wZSBmb3IganVzdCBvbmUgdGFuZ2VudCAoc2luZ2xlLXNpZGVkKVxuICpcbiAqIEBwYXJhbSBwMFxuICogQHBhcmFtIHAxXG4gKiBAcGFyYW0gbVxuICovXG5mdW5jdGlvbiBzbG9wZVNpbmdsZShwMCwgcDEsIG0pIHtcbiAgY29uc3QgZHggPSBwMVswXSAtIHAwWzBdO1xuICBjb25zdCBkeSA9IHAxWzFdIC0gcDBbMV07XG4gIHJldHVybiBkeCA/ICgoMyAqIGR5KSAvIGR4IC0gbSkgLyAyIDogbTtcbn1cbi8qKlxuICogR2l2ZW4gdHdvIHBvaW50cyBhbmQgdGhlaXIgdGFuZ2VudCBzbG9wZXMsXG4gKiBjYWxjdWxhdGUgdGhlIGJlemllciBoYW5kbGUgY29vcmRpbmF0ZXMgYW5kIHJldHVybiBkcmF3IGNvbW1hbmQuXG4gKlxuICogVHJhbnNsYXRlcyBIZXJtaXRlIFNwbGluZSB0byBCw6l6aWVyIGN1cnZlOlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDI1NzQ5NDAvXG4gKlxuICogQHBhcmFtIHAwXG4gKiBAcGFyYW0gcDFcbiAqIEBwYXJhbSBtMFxuICogQHBhcmFtIG0xXG4gKiBAcGFyYW0gdFxuICovXG5mdW5jdGlvbiBiZXppZXIocDAsIHAxLCBtMCwgbTEsIHQpIHtcbiAgY29uc3QgW3gwLCB5MF0gPSBwMDtcbiAgY29uc3QgW3gxLCB5MV0gPSBwMTtcbiAgY29uc3QgZHggPSAoeDEgLSB4MCkgLyAzO1xuICBjb25zdCBoMSA9IHQoW3gwICsgZHgsIHkwICsgZHggKiBtMF0pLmpvaW4oXCIsXCIpO1xuICBjb25zdCBoMiA9IHQoW3gxIC0gZHgsIHkxIC0gZHggKiBtMV0pLmpvaW4oXCIsXCIpO1xuICBjb25zdCBwID0gdChbeDEsIHkxXSkuam9pbihcIixcIik7XG4gIHJldHVybiBgQyAke2gxfSAke2gyfSAke3B9YDtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBmdW5jdGlvbiB3aGljaCB3aWxsIHRyYW5zbGF0ZSBhIHBvaW50XG4gKiBmcm9tIHRoZSBkYXRhIGNvb3JkaW5hdGUgc3BhY2UgdG8gc3ZnIHZpZXdib3ggb3JpZW50ZWQgcGl4ZWxzXG4gKlxuICogQHBhcmFtIHJvb3QwXG4gKiBAcGFyYW0gcm9vdDAud2lkdGhcbiAqIEBwYXJhbSByb290MC5oZWlnaHRcbiAqIEBwYXJhbSByb290MC5taW5cbiAqIEBwYXJhbSByb290MC5tYXhcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKHsgd2lkdGgsIGhlaWdodCwgbWluLCBtYXggfSkge1xuICBjb25zdCByYW5nZVggPSBtYXhbMF0gLSBtaW5bMF07XG4gIGNvbnN0IHJhbmdlWSA9IG1heFsxXSAtIG1pblsxXTtcbiAgcmV0dXJuIChwb2ludCkgPT4ge1xuICAgIGNvbnN0IHggPSAoKHBvaW50WzBdIC0gbWluWzBdKSAvIHJhbmdlWCkgKiB3aWR0aDtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC0gKHBvaW50WzFdIC8gcmFuZ2VZKSAqIGhlaWdodDtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyBmcm9tIHRoZSBkYXRhc2V0XG4gKlxuICogQHBhcmFtIGRhdGFcbiAqL1xuZnVuY3Rpb24gcmFuZ2UoZGF0YSkge1xuICBjb25zdCBbc3RhcnRYLCBzdGFydFldID0gZGF0YVswXTtcbiAgY29uc3QgbWluID0gW3N0YXJ0WCwgc3RhcnRZXTtcbiAgY29uc3QgbWF4ID0gW3N0YXJ0WCwgc3RhcnRZXTtcbiAgcmV0dXJuIGRhdGEucmVkdWNlKCh7IG1pbiwgbWF4IH0sIFt4LCB5XSkgPT4gKHtcbiAgICBtaW46IFtNYXRoLm1pbihtaW5bMF0sIHgpLCBNYXRoLm1pbihtaW5bMV0sIHkpXSxcbiAgICBtYXg6IFtNYXRoLm1heChtYXhbMF0sIHgpLCBNYXRoLm1heChtYXhbMV0sIHkpXSxcbiAgfSksIHsgbWluLCBtYXggfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGRyYXdpbmcgY29tbWFuZHMgZm9yIGFuIGFyZWEgZ3JhcGhcbiAqIHJldHVybnMgYSBzdHJpbmcgY2FuIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gYSBwYXRoIGVsZW1lbnQncyBgZGAgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHJvb3QwXG4gKiBAcGFyYW0gcm9vdDAuZGF0YVxuICogQHBhcmFtIHJvb3QwLm1pblxuICogQHBhcmFtIHJvb3QwLm1heFxuICogQHBhcmFtIHJvb3QwLnRcbiAqL1xuZnVuY3Rpb24gYXJlYSh7IGRhdGEsIG1pbiwgbWF4LCB0IH0pIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgLy8gaW1wb3J0YW50IHBvaW50cyBmb3IgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdGhlIHBhdGhcbiAgY29uc3QgW3N0YXJ0WCwgc3RhcnRZXSA9IHQoZGF0YVswXSk7XG4gIGNvbnN0IFttaW5YLCBtaW5ZXSA9IHQobWluKTtcbiAgY29uc3QgW21heFhdID0gdChtYXgpO1xuICAvLyBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHNsb3BlL3BvaW50c1xuICBsZXQgbTtcbiAgbGV0IHAwO1xuICBsZXQgcDE7XG4gIC8vIGl0ZXJhdGUgb3ZlciBkYXRhIHBvaW50cywgY2FsY3VsYXRpbmcgY29tbWFuZCBmb3IgZWFjaFxuICBjb25zdCBjb21tYW5kcyA9IGRhdGEucmVkdWNlKChhY2MsIHBvaW50LCBpKSA9PiB7XG4gICAgcDAgPSBkYXRhW2kgLSAyXTtcbiAgICBwMSA9IGRhdGFbaSAtIDFdO1xuICAgIGlmIChpID4gMSkge1xuICAgICAgY29uc3QgbTEgPSBzbG9wZShwMCwgcDEsIHBvaW50KTtcbiAgICAgIGNvbnN0IG0wID0gbSA9PT0gdW5kZWZpbmVkID8gc2xvcGVTaW5nbGUocDAsIHAxLCBtMSkgOiBtO1xuICAgICAgY29uc3QgY29tbWFuZCA9IGJlemllcihwMCwgcDEsIG0wLCBtMSwgdCk7XG4gICAgICBtID0gbTE7XG4gICAgICByZXR1cm4gYCR7YWNjfSAke2NvbW1hbmR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgYE0gJHttaW5YfSwke21pbll9IEwgJHttaW5YfSwke3N0YXJ0WX0gTCAke3N0YXJ0WH0sJHtzdGFydFl9YCk7XG4gIC8vIGNsb3NlIHRoZSBwYXRoXG4gIGNvbnN0IGxhc3QgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGVuZCA9IGJlemllcihwMSwgbGFzdCwgbSwgc2xvcGVTaW5nbGUocDEsIGxhc3QsIG0pLCB0KTtcbiAgcmV0dXJuIGAke2NvbW1hbmRzfSAke2VuZH0gTCAke21heFh9LCR7bWluWX0gWmA7XG59XG5cbmNvbnN0IGdyYXBoQ3NzID0gXCI6aG9zdHtkaXNwbGF5OmJsb2NrO2Jsb2NrLXNpemU6MTAwJX0uc3Zne2ZpbGw6Y3VycmVudENvbG9yO3N0cm9rZTp0cmFuc3BhcmVudDttYXJnaW46MHB4O2Rpc3BsYXk6YmxvY2s7YmxvY2stc2l6ZToxMDAlO2lubGluZS1zaXplOjEwMCU7cGFkZGluZzowcHh9LnN2ZyAuZ3JhcGgtcGF0aC0taGlnaGxpZ2h0e2ZpbGw6dmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7b3BhY2l0eTowLjV9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX1baGlkZGVuXXtkaXNwbGF5Om5vbmV9XCI7XG5cbmNvbnN0IEdyYXBoID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmdyYXBoSWQgPSBgY2FsY2l0ZS1ncmFwaC0ke2d1aWQoKX1gO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcihcInJlc2l6ZVwiLCAoKSA9PiBmb3JjZVVwZGF0ZSh0aGlzKSk7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5jb2xvclN0b3BzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGlnaGxpZ2h0TWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGlnaGxpZ2h0TWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUodGhpcy5lbCk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRhdGEsIGNvbG9yU3RvcHMsIGVsLCBoaWdobGlnaHRNYXgsIGhpZ2hsaWdodE1pbiwgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdyYXBoSWQ7XG4gICAgY29uc3QgeyBjbGllbnRIZWlnaHQ6IGhlaWdodCwgY2xpZW50V2lkdGg6IHdpZHRoIH0gPSBlbDtcbiAgICAvLyBpZiB3ZSBoYXZlIG5vIGRhdGEsIHJldHVybiBlbXB0eSBzdmdcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAoaChcInN2Z1wiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNsYXNzOiBcInN2Z1wiLCBoZWlnaHQ6IGhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsIHZpZXdCb3g6IGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCwgd2lkdGg6IHdpZHRoIH0pKTtcbiAgICB9XG4gICAgY29uc3QgeyBtaW46IHJhbmdlTWluLCBtYXg6IHJhbmdlTWF4IH0gPSByYW5nZShkYXRhKTtcbiAgICBsZXQgY3VycmVudE1pbiA9IHJhbmdlTWluO1xuICAgIGxldCBjdXJyZW50TWF4ID0gcmFuZ2VNYXg7XG4gICAgaWYgKG1pbiA8IHJhbmdlTWluWzBdIHx8IG1pbiA+IHJhbmdlTWluWzBdKSB7XG4gICAgICBjdXJyZW50TWluID0gW21pbiwgMF07XG4gICAgfVxuICAgIGlmIChtYXggPiByYW5nZU1heFswXSB8fCBtYXggPCByYW5nZU1heFswXSkge1xuICAgICAgY3VycmVudE1heCA9IFttYXgsIHJhbmdlTWF4WzFdXTtcbiAgICB9XG4gICAgY29uc3QgdCA9IHRyYW5zbGF0ZSh7IG1pbjogY3VycmVudE1pbiwgbWF4OiBjdXJyZW50TWF4LCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIGNvbnN0IFtoTWluWF0gPSB0KFtoaWdobGlnaHRNaW4sIGN1cnJlbnRNYXhbMV1dKTtcbiAgICBjb25zdCBbaE1heFhdID0gdChbaGlnaGxpZ2h0TWF4LCBjdXJyZW50TWF4WzFdXSk7XG4gICAgY29uc3QgYXJlYVBhdGggPSBhcmVhKHsgZGF0YSwgbWluOiByYW5nZU1pbiwgbWF4OiByYW5nZU1heCwgdCB9KTtcbiAgICBjb25zdCBmaWxsID0gY29sb3JTdG9wcyA/IGB1cmwoI2xpbmVhci1ncmFkaWVudC0ke2lkfSlgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiAoaChcInN2Z1wiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsIGNsYXNzOiBcInN2Z1wiLCBoZWlnaHQ6IGhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIsIHZpZXdCb3g6IGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCwgd2lkdGg6IHdpZHRoIH0sIGNvbG9yU3RvcHMgPyAoaChcImRlZnNcIiwgbnVsbCwgaChcImxpbmVhckdyYWRpZW50XCIsIHsgaWQ6IGBsaW5lYXItZ3JhZGllbnQtJHtpZH1gLCB4MTogXCIwXCIsIHgyOiBcIjFcIiwgeTE6IFwiMFwiLCB5MjogXCIwXCIgfSwgY29sb3JTdG9wcy5tYXAoKHsgb2Zmc2V0LCBjb2xvciwgb3BhY2l0eSB9KSA9PiAoaChcInN0b3BcIiwgeyBvZmZzZXQ6IGAke29mZnNldCAqIDEwMH0lYCwgXCJzdG9wLWNvbG9yXCI6IGNvbG9yLCBcInN0b3Atb3BhY2l0eVwiOiBvcGFjaXR5IH0pKSkpKSkgOiBudWxsLCBoaWdobGlnaHRNaW4gIT09IHVuZGVmaW5lZCA/IChbXG4gICAgICBoKFwibWFza1wiLCB7IGhlaWdodDogXCIxMDAlXCIsIGlkOiBgJHtpZH0xYCwgd2lkdGg6IFwiMTAwJVwiLCB4OiBcIjAlXCIsIHk6IFwiMCVcIiB9LCBoKFwicGF0aFwiLCB7IGQ6IGBcbiAgICAgICAgICAgIE0gMCwwXG4gICAgICAgICAgICBMICR7aE1pblggLSAxfSwwXG4gICAgICAgICAgICBMICR7aE1pblggLSAxfSwke2hlaWdodH1cbiAgICAgICAgICAgIEwgMCwke2hlaWdodH1cbiAgICAgICAgICAgIFpcbiAgICAgICAgICBgLCBmaWxsOiBcIndoaXRlXCIgfSkpLFxuICAgICAgaChcIm1hc2tcIiwgeyBoZWlnaHQ6IFwiMTAwJVwiLCBpZDogYCR7aWR9MmAsIHdpZHRoOiBcIjEwMCVcIiwgeDogXCIwJVwiLCB5OiBcIjAlXCIgfSwgaChcInBhdGhcIiwgeyBkOiBgXG4gICAgICAgICAgICBNICR7aE1pblggKyAxfSwwXG4gICAgICAgICAgICBMICR7aE1heFggLSAxfSwwXG4gICAgICAgICAgICBMICR7aE1heFggLSAxfSwke2hlaWdodH1cbiAgICAgICAgICAgIEwgJHtoTWluWCArIDF9LCAke2hlaWdodH1cbiAgICAgICAgICAgIFpcbiAgICAgICAgICBgLCBmaWxsOiBcIndoaXRlXCIgfSkpLFxuICAgICAgaChcIm1hc2tcIiwgeyBoZWlnaHQ6IFwiMTAwJVwiLCBpZDogYCR7aWR9M2AsIHdpZHRoOiBcIjEwMCVcIiwgeDogXCIwJVwiLCB5OiBcIjAlXCIgfSwgaChcInBhdGhcIiwgeyBkOiBgXG4gICAgICAgICAgICAgICAgTSAke2hNYXhYICsgMX0sMFxuICAgICAgICAgICAgICAgIEwgJHt3aWR0aH0sMFxuICAgICAgICAgICAgICAgIEwgJHt3aWR0aH0sJHtoZWlnaHR9XG4gICAgICAgICAgICAgICAgTCAke2hNYXhYICsgMX0sICR7aGVpZ2h0fVxuICAgICAgICAgICAgICAgIFpcbiAgICAgICAgICAgICAgYCwgZmlsbDogXCJ3aGl0ZVwiIH0pKSxcbiAgICAgIGgoXCJwYXRoXCIsIHsgY2xhc3M6IFwiZ3JhcGgtcGF0aFwiLCBkOiBhcmVhUGF0aCwgZmlsbDogZmlsbCwgbWFzazogYHVybCgjJHtpZH0xKWAgfSksXG4gICAgICBoKFwicGF0aFwiLCB7IGNsYXNzOiBcImdyYXBoLXBhdGgtLWhpZ2hsaWdodFwiLCBkOiBhcmVhUGF0aCwgZmlsbDogZmlsbCwgbWFzazogYHVybCgjJHtpZH0yKWAgfSksXG4gICAgICBoKFwicGF0aFwiLCB7IGNsYXNzOiBcImdyYXBoLXBhdGhcIiwgZDogYXJlYVBhdGgsIGZpbGw6IGZpbGwsIG1hc2s6IGB1cmwoIyR7aWR9MylgIH0pLFxuICAgIF0pIDogKGgoXCJwYXRoXCIsIHsgY2xhc3M6IFwiZ3JhcGgtcGF0aFwiLCBkOiBhcmVhUGF0aCwgZmlsbDogZmlsbCB9KSkpKTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzOyB9XG4gIHN0YXRpYyBnZXQgc3R5bGUoKSB7IHJldHVybiBncmFwaENzczsgfVxufSwgWzEsIFwiY2FsY2l0ZS1ncmFwaFwiLCB7XG4gICAgXCJkYXRhXCI6IFsxNl0sXG4gICAgXCJjb2xvclN0b3BzXCI6IFsxNl0sXG4gICAgXCJoaWdobGlnaHRNaW5cIjogWzIsIFwiaGlnaGxpZ2h0LW1pblwiXSxcbiAgICBcImhpZ2hsaWdodE1heFwiOiBbMiwgXCJoaWdobGlnaHQtbWF4XCJdLFxuICAgIFwibWluXCI6IFs1MTRdLFxuICAgIFwibWF4XCI6IFs1MTRdXG4gIH1dKTtcbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQoKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29tcG9uZW50cyA9IFtcImNhbGNpdGUtZ3JhcGhcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtZ3JhcGhcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBHcmFwaCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfSB9KTtcbn1cbmRlZmluZUN1c3RvbUVsZW1lbnQoKTtcblxuZXhwb3J0IHsgR3JhcGggYXMgRywgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2Jsb2IvbWFpbi9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMTEuMFxuICovXG5mdW5jdGlvbiBnZW4oY291bnRzKSB7XG4gIHJldHVybiBjb3VudHNcbiAgICAubWFwKChjb3VudCkgPT4ge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgb3V0ICs9ICgoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfSlcbiAgICAuam9pbihcIi1cIik7XG59XG5jb25zdCBndWlkID0gKCkgPT4gZ2VuKFsyLCAxLCAxLCAxLCAzXSk7XG5cbmV4cG9ydCB7IGd1aWQgYXMgZyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL21haW4vTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjExLjBcbiAqL1xuaW1wb3J0IHsgQnVpbGQgfSBmcm9tICdAc3RlbmNpbC9jb3JlL2ludGVybmFsL2NsaWVudC9pbmRleC5qcyc7XG5cbi8qKlxuICogVGhpcyB1dGlsaXR5IGVuc3VyZXMgb2JzZXJ2ZXJzIGFyZSBjcmVhdGVkIG9ubHkgZm9yIGJyb3dzZXIgY29udGV4dHMuXG4gKlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiBvYnNlcnZlciB0byBjcmVhdGVcbiAqIEBwYXJhbSBjYWxsYmFjayAtIHRoZSBvYnNlcnZlciBjYWxsYmFja1xuICogQHBhcmFtIG9wdGlvbnMgLSB0aGUgb2JzZXJ2ZXIgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAoIUJ1aWxkLmlzQnJvd3Nlcikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgT2JzZXJ2ZXIgPSBnZXRPYnNlcnZlcih0eXBlKTtcbiAgcmV0dXJuIG5ldyBPYnNlcnZlcihjYWxsYmFjaywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlcih0eXBlKSB7XG4gIC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZG9tL2lzc3Vlcy8xMjYjaXNzdWVjb21tZW50LTEwNDk4MTQ5NDhcbiAgY2xhc3MgRXh0ZW5kZWRNdXRhdGlvbk9ic2VydmVyIGV4dGVuZHMgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgICBzdXBlcihjYWxsYmFjayk7XG4gICAgICB0aGlzLm9ic2VydmVkRW50cnkgPSBbXTtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeS5wdXNoKHsgdGFyZ2V0LCBvcHRpb25zIH0pO1xuICAgICAgcmV0dXJuIHN1cGVyLm9ic2VydmUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgdW5vYnNlcnZlKHRhcmdldCkge1xuICAgICAgY29uc3QgbmV3T2JzZXJ2ZWRFbnRyaWVzID0gdGhpcy5vYnNlcnZlZEVudHJ5LmZpbHRlcigob2JzZXJ2ZWQpID0+IG9ic2VydmVkLnRhcmdldCAhPT0gdGFyZ2V0KTtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeSA9IFtdO1xuICAgICAgdGhpcy5jYWxsYmFjayhzdXBlci50YWtlUmVjb3JkcygpLCB0aGlzKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgbmV3T2JzZXJ2ZWRFbnRyaWVzLmZvckVhY2goKG9ic2VydmVkKSA9PiB0aGlzLm9ic2VydmUob2JzZXJ2ZWQudGFyZ2V0LCBvYnNlcnZlZC5vcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIlxuICAgICAgPyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgIDogdHlwZSA9PT0gXCJtdXRhdGlvblwiXG4gICAgICAgID8gRXh0ZW5kZWRNdXRhdGlvbk9ic2VydmVyXG4gICAgICAgIDogd2luZG93LlJlc2l6ZU9ic2VydmVyKTtcbiAgfSkoKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlT2JzZXJ2ZXIgYXMgYyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9