"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_featur-9beed7"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-38cdae87.js":
/*!*******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-38cdae87.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ getSecuredAGSServiceInfo),
/* harmony export */   M: () => (/* binding */ MULTI_PART_UPLOAD_MINIMUM_SIZE),
/* harmony export */   a: () => (/* binding */ addSecureAGSUrl),
/* harmony export */   b: () => (/* binding */ addApplication),
/* harmony export */   c: () => (/* binding */ addFeatureLayer),
/* harmony export */   d: () => (/* binding */ addCloudProviderResource),
/* harmony export */   e: () => (/* binding */ addFile),
/* harmony export */   f: () => (/* binding */ fetchApplicationManifest),
/* harmony export */   g: () => (/* binding */ getServiceAndLayerInfo),
/* harmony export */   h: () => (/* binding */ handleAddUrl),
/* harmony export */   i: () => (/* binding */ isHybridImageService),
/* harmony export */   j: () => (/* binding */ isAppComponentError),
/* harmony export */   k: () => (/* binding */ isBackendError),
/* harmony export */   l: () => (/* binding */ addFileFromDataUrl),
/* harmony export */   m: () => (/* binding */ selectOGCFeatureLayer),
/* harmony export */   n: () => (/* binding */ formatCustomParameters),
/* harmony export */   o: () => (/* binding */ getUrlServiceInfo),
/* harmony export */   p: () => (/* binding */ processPostAddKML),
/* harmony export */   q: () => (/* binding */ isFolderRoot),
/* harmony export */   r: () => (/* binding */ removeParameter),
/* harmony export */   s: () => (/* binding */ subscriptionState),
/* harmony export */   t: () => (/* binding */ addItem),
/* harmony export */   u: () => (/* binding */ findTemplateServiceInfo),
/* harmony export */   v: () => (/* binding */ createService),
/* harmony export */   w: () => (/* binding */ getItemStatus),
/* harmony export */   x: () => (/* binding */ uploadFile),
/* harmony export */   y: () => (/* binding */ registerApplication),
/* harmony export */   z: () => (/* binding */ getLayerItemData)
/* harmony export */ });
/* harmony import */ var _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config-eb5f7dc2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-eb5f7dc2.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./privileges-ccd5f37d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js");
/* harmony import */ var _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./item-properties-e6412a9a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-properties-e6412a9a.js");
/* harmony import */ var _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./add-item-97d577a9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-97d577a9.js");
/* harmony import */ var _feature_layer_d33ea114_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature-layer-d33ea114.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-d33ea114.js");
/* harmony import */ var _functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./functional-9f648bee.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-9f648bee.js");
/* harmony import */ var _server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./server-item-f12153e6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/server-item-f12153e6.js");
/* harmony import */ var _portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./portal-79caaeff.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-79caaeff.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _ags_68d4ae20_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ags-68d4ae20.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ags-68d4ae20.js");
/* harmony import */ var _url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./url-f3b82cc7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-f3b82cc7.js");
/* harmony import */ var _file_f36193e9_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./file-f36193e9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-f36193e9.js");
/* harmony import */ var _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./item-types-b4fe86ad.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-b4fe86ad.js");
/* harmony import */ var _guid_4f4176ba_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./guid-4f4176ba.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-4f4176ba.js");
/* harmony import */ var _store_3210b604_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./store-3210b604.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-3210b604.js");
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


















function isFolderRoot(folder) {
  return (folder === null || folder === void 0 ? void 0 : folder.id) === (folder === null || folder === void 0 ? void 0 : folder.username);
}

/**
 * for AGS and OGC Feature Services urls, formatted params will be used for the service Info requests
 */
function addParameters(url) {
  const { customParameters: parameters } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  const delimiter = url.includes("?") ? "&" : "?";
  const customParameters = (parameters === null || parameters === void 0 ? void 0 : parameters.map(({ parameter, value }) => `${parameter || ""}${parameter || value ? "=" : ""}${value || ""}`).join("&")) || "";
  if (!customParameters) {
    return url;
  }
  return `${url}${delimiter}${customParameters}`;
}
function removeParameter(url, { value, parameter }) {
  const paramStr = `${parameter}=${value}`;
  const resultUrl = url.replace(url[url.indexOf(paramStr) - 1] === "&" ? `&${paramStr}` : paramStr, "");
  return resultUrl[resultUrl.length - 1] === "?" ? resultUrl.replace("?", "") : resultUrl;
}

const errorCodeList = [
  "appExtensionError",
  "forbiddenCredential",
  "disabledSubscription",
  "unauthorized",
  "timeout",
  // --- Item error code
  "itemExists",
  "exceedsFileSize",
  "fileExists",
  "emptyFile",
  "unavailableGeocoder",
  "dataNotAvailable",
  "invalidShapefile",
  "invalidFileGeodatabase",
  "providePath",
  "useSameFileName",
  "invalidExtension",
  "tokenRequired",
  // --- Item properties error code
  "serviceNameInvalid",
  "titleInvalid",
  "titleRequired",
  "titleInUseService",
  "summaryInvalid",
  "missingUserOrPortal",
  "dataStoreTitleInvalid",
  // --- Services
  "serviceNameExists",
  // --- AGS, WMF, WMS, WFS, etc
  "serviceNotExist",
  "unsupportedWFSVersion",
  "invalidWMTS",
  "invalidSpatialRef",
  "emptyFeatureLayer",
  // --- Feature layer,
  "invalidFeatureLayerUrl",
  "invalidUrl",
  "httpWarning",
  // --- User error
  "flowAborted",
  // --- CSV error
  "duplicateFieldNames",
  "failToFetchText",
  // --- Tile layer
  "mapServiceError",
  "noTilingSchemeFound",
  "noMatchSpatialRef",
  // --- Datastore
  "invalidDataStorePublishType",
  "noRegisteredServersForDataStore",
  "noContentInDataStore",
  "failToPublishFromDataStore",
  "failToListDataStoreContents",
  "invalidUsernameOrPassword",
  "invalidJSON",
  // --- Internal error
  "unknownAGSType",
  "unhandledError",
  // -- Append errors
  "incompatibleGeometries",
  "multiPatchRestriction"
];
// * Utils
const isAppComponentError = (error) => errorCodeList.includes(error === null || error === void 0 ? void 0 : error.code);
const isBackendError = (error) => error &&
  error.hasOwnProperty("code") &&
  error.hasOwnProperty("message") &&
  error.hasOwnProperty("details") &&
  (!error.details || Array.isArray(error.details));

const unsubscribe = async (id) => {
  const subscriber = subscriptionState.subscribers[id];
  try {
    await (subscriber === null || subscriber === void 0 ? void 0 : subscriber.unsubscribe());
  }
  catch (error) {
    console.error(`Fail to call unsubscribe for ${subscriber.name}: ${error}`);
  }
};
const removeSubscriber = async (id) => {
  delete subscriptionState.subscribers[id];
};
const unsubscribeAll = async () => {
  await Promise.all(Object.keys(subscriptionState.subscribers).map(unsubscribe));
  subscriptionStore.reset();
};
const addSubscriber = (name, unsubscribe) => {
  const id = `${name}---${(0,_guid_4f4176ba_js__WEBPACK_IMPORTED_MODULE_14__.g)()}`;
  subscriptionState.subscribers[id] = { name, unsubscribe };
  return id;
};
const isSubscriberValid = (subscriptionId) => !!subscriptionState.subscribers[subscriptionId];
/** Used to keep track and handle all the long running job like polling and upload multi-part file */
const subscriptionStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_16__.c)({
  subscribers: {},
  unsubscribeAll,
  addSubscriber,
  unsubscribe,
  removeSubscriber,
  isSubscriberValid
});
const subscriptionState = subscriptionStore.state;

// File size constants
const MULTI_PART_UPLOAD_BATCH_SIZE = 26214400; // 25mb
const MULTI_PART_UPLOAD_MINIMUM_SIZE = 78643200; // 75mb
const MULTI_PART_UPLOAD_RETRIES = 5;
const MULTI_PART_UPLOAD_MAX_PARTS = 10000;
const MULTI_PART_UPLOAD_INITIAL_BATCH_SIZE = 3;
const MULTI_PART_UPLOAD_MAX_BATCH_SIZE = 10;

// The shape of customParamters in the component is different than how it needs to be formatted in the URLS, so we do that here.
function formatCustomParameters(customParams) {
  if (!customParams) {
    return null;
  }
  let appendAll = true;
  let customParameters = {};
  let customLayerParameters = {};
  // WMS and WMTS can have custom Paramters that only apply to the specific layer not the whole serviceInfo request - thats what were doing here.
  customParams.forEach(({ append, parameter, value }) => {
    if (append === "layer") {
      appendAll = false;
      customLayerParameters[parameter] = value;
    }
    else {
      customParameters[parameter] = value;
    }
  });
  return appendAll ? { customParameters } : { customParameters, customLayerParameters };
}

async function addApplication(item, restBaseUrl, appInfo) {
  if (item.type === "Desktop Application") {
    return addFile();
  }
  const response = await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.c)(item);
  if (item.type === "Application" || item.type === "API Key") {
    await registerApplication(response.id, restBaseUrl, appInfo);
  }
  return response;
}
async function registerApplication(itemId, restBaseUrl, appInfo) {
  const url = `${restBaseUrl}oauth2/registerApp`;
  let requestParam = {
    itemId,
    appType: "multiple",
    redirect_uris: JSON.stringify(["urn:ietf:wg:oauth:2.0:oob"])
  };
  const redirectUrlString = JSON.stringify(appInfo.redirect_uris);
  if (appInfo) {
    requestParam =
      appInfo.appType === "apikey"
        ? {
          itemId,
          appType: "apikey",
          redirect_uris: redirectUrlString,
          httpReferrers: JSON.stringify(appInfo.httpReferrers),
          privileges: JSON.stringify(appInfo.privileges)
        }
        : { itemId, appType: appInfo.appType, redirect_uris: redirectUrlString, url: appInfo.url };
  }
  try {
    return { result: await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, requestParam, {}, "post") };
  }
  catch (error) {
    console.error("error:", error);
    return { error: { code: "unhandledError" } };
  }
}
async function fetchApplicationManifest(manifestUrl) {
  try {
    return { result: await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(manifestUrl, {}, { addTokenManually: false }), error: null };
  }
  catch (error) {
    console.error("error:", error);
    return { result: null, error: { code: "appExtensionError" } };
  }
}

const HIDDEN_MAP_DIV_ID = "hiddenMapDiv";
const destroyHiddenMapDiv = () => {
  const hiddenMapDiv = document.getElementById(HIDDEN_MAP_DIV_ID);
  if (hiddenMapDiv) {
    hiddenMapDiv.parentNode.removeChild(hiddenMapDiv);
  }
};
/** Return the id of the hidden map */
const createHiddenMapDiv = (width = 200, height = 130) => {
  let hiddenMapDiv = document.getElementById(HIDDEN_MAP_DIV_ID);
  if (!hiddenMapDiv) {
    hiddenMapDiv = document.createElement("div");
    hiddenMapDiv.id = HIDDEN_MAP_DIV_ID;
    hiddenMapDiv.style.position = "absolute";
    hiddenMapDiv.style.left = "-1000px";
    hiddenMapDiv.style.top = "-1000px";
    hiddenMapDiv.style.width = `${width}px`;
    hiddenMapDiv.style.height = `${height}px`;
    document.body.appendChild(hiddenMapDiv);
  }
  const hiddenMap = document.createElement("div");
  const hiddenMapId = "hiddenMap";
  hiddenMap.id = hiddenMapId;
  hiddenMap.style.width = `${width}px`;
  hiddenMap.style.height = `${height}px`;
  hiddenMapDiv.appendChild(hiddenMap);
  return hiddenMapId;
};

async function createThumbnailImage(map, config) {
  const [PrintTemplate, PrintParameters, PrintTask, esriConfig] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    "esri/tasks/PrintTemplate",
    "esri/tasks/PrintParameters",
    "esri/tasks/PrintTask",
    "esri/config"
  ]);
  const thumbnailWidth = 600;
  const thumbnailHeight = 400;
  const template = new PrintTemplate();
  template.layout = "MAP_ONLY";
  template.format = "png32";
  template.preserveScale = false;
  template.showAttribution = false;
  template.showLabels = false;
  template.exportOptions = {
    width: thumbnailWidth,
    height: thumbnailHeight,
    dpi: 96
  };
  const printTask = new PrintTask(config.self.helperServices.printTask.url, {});
  const params = new PrintParameters();
  params.map = map;
  params.template = template;
  esriConfig.defaults.io.timeout = 120000;
  // TODO: Some feature services need to be projected to WGS84 to generate correctly
  // Can set extent to geographicExtent here but should fix within PrintParameters
  return new Promise((resolve, reject) => {
    printTask.execute(params, (result) => {
      esriConfig.defaults.io.timeout = 60000;
      destroyHiddenMap(map);
      resolve(result.url);
    }, (err) => {
      esriConfig.defaults.io.timeout = 60000;
      reject(err);
    });
  });
}
async function createHiddenMap(webMapData, gcsExtentAsList) {
  const { config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const itemInfo = { item: { extent: gcsExtentAsList }, itemData: webMapData };
  try {
    const [arcgisUtils] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/arcgis/utils"]);
    // Need to set this so "createMap" uses the correct portalUrl, in the future
    // "createMap" should really be improved to use the portal API, or a portalUrl parameter
    // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/14819
    arcgisUtils.arcgisUrl = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.g)()}content/items`;
    const hiddenMapId = createHiddenMapDiv();
    const response = await arcgisUtils.createMap(itemInfo, hiddenMapId, {
      mapOptions: {
        nav: false
      },
      bingMapsKey: config.self.bingKey,
      geometryServiceURL: _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.portal.helperServices.geometry.url
    });
    const waitForHeatmapImageLayer = function (layer) {
      return new Promise((resolve) => {
        if (layer._heatmapManager) {
          layer._heatmapManager.on("recalculateHeatmap", resolve);
        }
        else {
          // layer might be out of scale
          resolve();
        }
      });
    };
    const waitForWFSFeatures = (layer) => {
      // there is no event...
      const count = [0];
      return new Promise((resolve) => {
        const intHndl = setInterval((layer, count) => {
          var _a;
          if ((_a = layer.graphics) === null || _a === void 0 ? void 0 : _a.length) {
            clearInterval(intHndl);
            resolve();
          }
          else if (count[0] > 10) {
            clearInterval(intHndl);
            resolve();
          }
          else {
            count[0] = count[0] + 1;
          }
        }, 500, layer, count);
      });
    };
    const waitForUpdateStart = (layer) => {
      return new Promise((resolve) => {
        if (layer.declaredClass === "esri.layers.VectorTileLayer") {
          // bug, doesn't call onUpdateStart sometimes
          setTimeout(resolve, 5000);
        }
        layer.on("update-start", () => {
          waitForUpdateEnd(layer).then(resolve);
        });
      });
    };
    const waitForUpdateEnd = function (layer) {
      return new Promise((resolve) => {
        if (!layer.updating) {
          return resolve();
        }
        if (layer.declaredClass === "esri.layers.VectorTileLayer") {
          // bug, doesn't call onUpdateEnd if there are no tiles in the view
          setTimeout(resolve, 10000);
        }
        layer.on("update-end", resolve);
      });
    };
    const { map } = response;
    const promises = [];
    map.graphicsLayerIds.forEach((layerId) => {
      var _a;
      const layer = map.getLayer(layerId);
      if (((_a = layer.renderer) === null || _a === void 0 ? void 0 : _a.type) === "heatmap") {
        promises.push(waitForHeatmapImageLayer(layer));
      }
      else if (layer.declaredClass === "esri.layers.WFSLayer") {
        promises.push(waitForWFSFeatures(layer));
      }
      else if (layer.updating) {
        promises.push(waitForUpdateEnd(layer));
      }
    });
    map.layerIds.forEach((layerId) => {
      const lyr = response.map.getLayer(layerId);
      if (lyr.updating) {
        promises.push(waitForUpdateEnd(lyr));
      }
      else if (lyr.declaredClass === "esri.layers.VectorTileLayer") {
        // this is not working correctly in VTL; viewer should not have to wait for update start
        promises.push(waitForUpdateStart(lyr));
      }
    });
    if (promises.length) {
      await Promise.all(promises);
      // we need to wait a little longer
      return new Promise((resolve) => {
        setTimeout(async () => {
          resolve(await createThumbnailImage(response.map, config));
        }, 1000);
      });
    }
    else {
      return await createThumbnailImage(response.map, config);
    }
  }
  catch (error) {
    throw new Error(`Map creation failed: ${JSON.stringify(error)}`);
  }
}

async function buildThumbnailURLFromItemWebMap(webMap, gcsExtentAsList, spatialReference) {
  var _a;
  // TODO: remove this dependency
  const api = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api;
  // does not support heatmap renderer
  const [Geoprocessor] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([api === 3 ? "esri/tasks/Geoprocessor" : "esri/rest/geoprocessor"]);
  const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  ((_a = webMap.baseMap.baseMapLayers) !== null && _a !== void 0 ? _a : []).forEach((baseMapLayer) => {
    delete baseMapLayer.resourceInfo;
  });
  webMap.mapOptions = {
    showAttribution: false,
    extent: {
      xmin: gcsExtentAsList[0][0],
      ymin: gcsExtentAsList[0][1],
      xmax: gcsExtentAsList[1][0],
      ymax: gcsExtentAsList[1][1],
      spatialReference: {
        wkid: 4326
      }
    },
    spatialReference: spatialReference
  };
  webMap.exportOptions = {
    dpi: 96,
    outputSize: [600, 400]
  };
  webMap.layoutOptions = {};
  const params = {
    Web_Map_as_JSON: JSON.stringify(webMap),
    Format: "PNG32",
    Layout_Template: "MAP_ONLY"
  };
  if (api === 3) {
    const gp = new Geoprocessor(portal.helperServices.printTask.url);
    return new Promise((resolve, reject) => {
      gp.execute(params).then((response) => {
        if (response) {
          let found = false;
          for (let i = 0; i < response.length; i++) {
            if (response[i].paramName === "Output_File") {
              resolve(response[i].value.url);
              found = true;
              break;
            }
          }
          if (!found) {
            reject();
          }
        }
      });
    });
  }
  const { results } = await Geoprocessor.execute(portal.helperServices.printTask.url, params);
  const url = results.find((result) => result.dataType === "data-file" && result).value.url;
  if (!url) {
    // TODO: refactor this error to the new system
    throw new Error("Failed to create thumbnail");
  }
  return url;
}
function destroyHiddenMap(map) {
  var _a;
  map.destroy();
  (_a = document.getElementById("hiddenMapDiv")) === null || _a === void 0 ? void 0 : _a.removeChild(document.getElementById("hiddenMap"));
}
async function buildThumbnailURLFromWebMap(webMap, gcsExtentAsList) {
  return await createHiddenMap(webMap, gcsExtentAsList);
}

async function buildThumbnailURLFromKMLItem(item) {
  var _a;
  const [SpatialReference] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
  ]);
  const { config, portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const webMap = {};
  webMap.baseMap = config.defaultBasemap || portal.defaultBasemap;
  webMap.baseMap.title = "basemap";
  webMap.operationalLayers = [];
  let url = item.url;
  if (!url && item.type === "KML") {
    // loaded from a file KML
    url = config.restBaseUrl + "content/items/" + item.id + "/data";
  }
  // we don't have ID manager
  const restDomain = new URL(config.restBaseUrl).hostname;
  if (url.indexOf(restDomain) > -1) {
    const token = (_a = config === null || config === void 0 ? void 0 : config.userInfo) === null || _a === void 0 ? void 0 : _a.token;
    if (token) {
      url += "?token=" + token;
    }
  }
  webMap.operationalLayers.push({
    url,
    id: "KML_" + Math.random(),
    opacity: 1,
    title: item.title,
    visibility: true,
    type: "KML"
  });
  let ext = [];
  if (typeof item.extent === "string") {
    const e = item.extent.split(",");
    ext = [
      [parseFloat(e[0]), parseFloat(e[1])],
      [parseFloat(e[2]), parseFloat(e[3])]
    ];
  }
  else {
    if (item.extent && item.extent.length > 0) {
      ext = item.extent;
    }
    else {
      ext = [
        [-180, -90],
        [180, 90]
      ];
    }
  }
  return buildThumbnailURLFromItemWebMap(webMap, ext, new SpatialReference({ wkid: 4326 }));
}

const worldExtentInfo = {
  xmax: 20000000,
  xmin: -20000000,
  ymax: 20000000,
  ymin: -20000000,
  spatialReference: {
    wkid: 102100
  }
};
function wrapAround(wkid, geom) {
  const VALID_EXTENTS = {
    "102113": [-20037508.342788905, 20037508.342788905],
    "102100": [-20037508.342788905, 20037508.342788905],
    "3785": [-20037508.342788905, 20037508.342788905],
    "3857": [-20037508.342788905, 20037508.342788905],
    "4326": [-180, 180]
  };
  const valid = VALID_EXTENTS[wkid];
  if (valid) {
    if (geom.xmin > geom.xmax) {
      // wrap around
      const dif1 = valid[1] - geom.xmin;
      const dif2 = geom.xmax - valid[0];
      if (dif1 > dif2) {
        geom.xmax = valid[1] + dif2;
      }
      else {
        geom.xmin = valid[0] - dif1;
      }
    }
  }
}
function getSpatialReference(serviceInfo, agsType) {
  var _a, _b;
  const spatialReference = agsType !== "ImageServer" ? serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.spatialReference : (_a = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.extent) === null || _a === void 0 ? void 0 : _a.spatialReference;
  if (!spatialReference) {
    return null;
  }
  else if (spatialReference.wkid) {
    return spatialReference.wkid;
  }
  else if (((_b = spatialReference.wkt) === null || _b === void 0 ? void 0 : _b.search(/^PROJCS/i)) !== -1) {
    return /^PROJCS\["[A-Za-z0-9_]*/i.exec(spatialReference.wkt)[0].split("[")[1];
  }
  return null;
}
async function projectExtentToWGS84(extent) {
  var _a, _b;
  const [SpatialReference] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
  ]);
  const hasSR = ((_a = extent === null || extent === void 0 ? void 0 : extent.spatialReference) === null || _a === void 0 ? void 0 : _a.wkid) || ((_b = extent === null || extent === void 0 ? void 0 : extent.spatialReference) === null || _b === void 0 ? void 0 : _b.wkt);
  const GCS_WGS_1984 = new SpatialReference({ wkid: 4326 });
  const sameSpatialRef = await sameSpatialReference(GCS_WGS_1984, extent === null || extent === void 0 ? void 0 : extent.spatialReference);
  return hasSR && !sameSpatialRef ? await project(extent, GCS_WGS_1984) : extent;
}
async function projectExtentToWGS84FromItem(item) {
  const { extent } = item;
  item.extent = extentToString(await projectExtentToWGS84(extent));
  return item;
}
async function projectExtent(geometry, outSR) {
  const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const [mercatorUtils, GeometryService] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4
    ? ["esri/geometry/support/webMercatorUtils", "esri/rest/geometryService"]
    : ["esri/geometry/webMercatorUtils", "esri/tasks/GeometryService"]);
  const mercator = [102113, 102100, 3857];
  const wkid = geometry.spatialReference.wkid;
  // we only have 1 geometry anyway
  if (wkid === outSR.wkid) {
    return [geometry];
  }
  let geom;
  // going from GCS_WGS_1984 to mercator
  if (wkid === 4326 && mercator.indexOf(outSR.wkid) > -1) {
    // clip it, so it's not going to Infinity
    geometry.ymin = Math.max(geometry.ymin, -89.99);
    geometry.ymax = Math.min(geometry.ymax, 89.99);
    geom = mercatorUtils.geographicToWebMercator(geometry);
    wrapAround(outSR.wkid, geom);
    // geographicToWebMercator returns 102100; make sure it's what we want
    geom.spatialReference.wkid = outSR.wkid;
    return [geom];
  }
  if (mercator.indexOf(wkid) > -1 && outSR.wkid === 4326) {
    geom = mercatorUtils.webMercatorToGeographic(geometry);
    wrapAround(outSR.wkid, geom);
    return [geom];
  }
  else {
    return new Promise(async (resolve, reject) => {
      const geometryService = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? GeometryService : new GeometryService(portal.helperServices.geometry.url);
      const firstHandler = (result) => {
        // check if response is valid
        const first = result === null || result === void 0 ? void 0 : result[0];
        if ((first === null || first === void 0 ? void 0 : first.type) === "extent" &&
          !isNaN(result[0].xmin) &&
          !isNaN(result[0].ymin) &&
          !isNaN(result[0].xmax) &&
          !isNaN(result[0].ymax)) {
          resolve(result);
        }
        else if ((first === null || first === void 0 ? void 0 : first.type) === "point" && !isNaN(result[0].x) && !isNaN(result[0].y)) {
          resolve(result);
        }
        else {
          throw new Error();
        }
      };
      if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
        try {
          const [_ProjectParameters] = (await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/rest/support/ProjectParameters"]));
          const projectParameters = new _ProjectParameters({ geometries: [geometry], outSpatialReference: outSR });
          firstHandler(await geometryService.project(portal.helperServices.geometry.url, projectParameters));
        }
        catch (error) {
          throw new Error(error);
        }
      }
      else {
        geometryService.project([geometry], outSR, firstHandler, (err) => {
          reject(err);
        });
      }
    });
  }
}
async function project(extent, toExtent) {
  var _a;
  const [Extent] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/geometry/Extent"]);
  const worldExtent = new Extent(worldExtentInfo);
  const fullExtent = new Extent(extent);
  const result = await projectExtent(fullExtent, toExtent);
  return ((_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.type) === "extent" ? result[0] : worldExtent;
}
async function sameSpatialReference(sp1, sp2) {
  const mercator = [102113, 102100, 3857];
  if (((sp1 === null || sp1 === void 0 ? void 0 : sp1.wkt) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkt) && ((sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid) || ((0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.i)(sp1.latestWkid) && (sp1 === null || sp1 === void 0 ? void 0 : sp1.latestWkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid)))) ||
    ((0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.i)(sp2 === null || sp2 === void 0 ? void 0 : sp2.latestWkid) && (sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.latestWkid)) ||
    ((0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.i)(sp1 === null || sp1 === void 0 ? void 0 : sp1.latestWkid) && (sp1 === null || sp1 === void 0 ? void 0 : sp1.latestWkid) == (sp2 === null || sp2 === void 0 ? void 0 : sp2.latestWkid))) {
    return true;
  }
  else if ((sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) && (sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid) && mercator.includes(sp1 === null || sp1 === void 0 ? void 0 : sp1.wkid) && mercator.includes(sp2 === null || sp2 === void 0 ? void 0 : sp2.wkid)) {
    return true;
  }
  return false;
}
async function getExtentWithFeatures(layer, extentAsList) {
  const { api } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const [SpatialReference] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
  ]);
  const [FeatureLayer, StreamLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/FeatureLayer", "esri/layers/StreamLayer"]);
  if (!layer || !(layer instanceof FeatureLayer) || layer instanceof StreamLayer) {
    return extentAsList;
  }
  if (api === 3) {
    // we want to zoom to where we see features
    await layer.addPlugin("esri/plugins/FeatureLayerStatistics");
    const info = await layer.statisticsPlugin.getSuggestedScaleRange();
    const { minScale, center, relaxedMinScale } = info;
    if (center) {
      // we need to use the width the scale is calculated with and then shrink down the map
      let extent = await getExtentFromCenter(center, 1280, minScale);
      if (info.relaxedMinScale > 0) {
        // are we still in the scale of the layer for a 200 width map?
        let scale = getScaleForExtent(extent, 200);
        let width = 800;
        while (scale > relaxedMinScale) {
          extent = getExtentFromCenter(center, width, minScale);
          scale = getScaleForExtent(extent, 200);
          width -= 200;
          if (width <= 0) {
            // that's it, we can't do more. Thumbnail might look empty now.
            break;
          }
        }
      }
      try {
        const result = await projectExtent(extent, new SpatialReference({ wkid: 4326 }));
        extentAsList = [
          [result[0].xmin, result[0].ymin],
          [result[0].xmax, result[0].ymax]
        ];
        return extentAsList;
      }
      catch (_a) {
        return extentAsList;
      }
    }
    else {
      return extentAsList;
    }
  }
  // TODO: use esri/smartMapping/heuristics/scaleRange to zoom to features.
  return extentAsList;
}
async function getScaleForExtent(extent, width) {
  const [esriConfig, WKIDUnitConversion] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config", "esri/WKIDUnitConversion"]);
  const INCHES_PER_METER = 39.37;
  const DEC_DEG_TO_METERS = 20015077.0 / 180.0;
  const spatialRef = extent.spatialReference;
  const wkid = spatialRef === null || spatialRef === void 0 ? void 0 : spatialRef.wkid;
  const wkt = spatialRef === null || spatialRef === void 0 ? void 0 : spatialRef.wkt;
  let unitValue = null;
  if (wkid) {
    unitValue = WKIDUnitConversion.values[WKIDUnitConversion[wkid]];
  }
  else if ((wkt === null || wkt === void 0 ? void 0 : wkt.search(/^PROJCS/i)) !== -1) {
    // well known text is PROJCS
    const result = /UNIT\[([^\]]+)\]\]$/i.exec(wkt);
    if (result === null || result === void 0 ? void 0 : result[1]) {
      unitValue = parseFloat(result[1].split(",")[1]);
    }
  }
  // else assumed to be in degrees
  return ((extent.getWidth() / width) * (unitValue || DEC_DEG_TO_METERS) * INCHES_PER_METER * esriConfig.defaults.screenDPI);
}
async function getExtentFromCenter(point, width, scale) {
  const [Extent] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/geometry/Extent"]);
  const extent = new Extent(point.x - 1, point.y - 0.5, point.x + 1, point.y + 0.5, point.spatialReference);
  return getExtentForScale(extent, width, scale);
}
async function getExtentForScale(extent, width, scale) {
  const [esriConfig, WKIDUnitConversion] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config", "esri/WKIDUnitConversion"]);
  const INCHES_PER_METER = 39.37, DEC_DEG_TO_METERS = 20015077.0 / 180.0, lookup = WKIDUnitConversion;
  let wkid, wkt, sr = extent.spatialReference;
  if (sr) {
    wkid = sr.wkid;
    wkt = sr.wkt;
  }
  let unitValue = null;
  if (wkid) {
    unitValue = lookup.values[lookup[wkid]];
  }
  else if (wkt && wkt.search(/^PROJCS/i) !== -1) {
    const result = /UNIT\[([^\]]+)\]\]$/i.exec(wkt);
    if (result === null || result === void 0 ? void 0 : result[1]) {
      unitValue = parseFloat(result[1].split(",")[1]);
    }
  }
  // else assumed to be in degrees
  const newExtent = extent.expand((scale * width) /
    ((unitValue || DEC_DEG_TO_METERS) * INCHES_PER_METER * esriConfig.defaults.screenDPI) /
    extent.getWidth());
  return newExtent;
}
const isValidWGS84Extent = (extent) => {
  // Taken from Define Extent.js
  const inRange = (value, min, max) => value >= min && value <= max;
  return (inRange(extent.ymax, -90, 90) && // -90 <= maxy <= 90
    inRange(extent.ymin, -90, 90) && // -90 <= miny <= 90
    inRange(extent.xmax, -180, 180) && // -180 <= maxx <= 180
    inRange(extent.xmin, -180, 180) && // -180 <= minx <= 180
    extent.ymax > extent.ymin && // maxy > miny
    extent.xmax > extent.xmin // maxx > minx
  );
};
function extentToString(extent, places = 4) {
  if (!extent) {
    return extentToString(worldExtentInfo);
  }
  if (typeof extent === "string") {
    return extent;
  }
  if (Array.isArray(extent)) {
    if (Array.isArray(extent[0]) && Array.isArray(extent[1])) {
      let mins;
      let maxs;
      if (extent[0].length === 2) {
        mins = extent[0];
        maxs = extent[1];
      }
      // Refer to OGCExtent's bbox type
      if (extent[0].length === 4 || extent[0].length === 6) {
        mins = [extent[0][0], extent[0][1]];
        maxs = [extent[0][2], extent[0][3]];
        if (extent[0].length === 6) {
          maxs = [extent[0][3], extent[0][4]];
        }
      }
      return `${mins.join(",")},${maxs.join(",")}`;
    }
    return extent.join(",");
  }
  const xmin = extent.xmin.toFixed(places);
  const ymin = extent.ymin.toFixed(places);
  const xmax = extent.xmax.toFixed(places);
  const ymax = extent.ymax.toFixed(places);
  return `${xmin},${ymin},${xmax},${ymax}`;
}

async function addKMLUrl(itemProperties, config, api) {
  try {
    const [extent, thumbnailURL] = await Promise.all([
      setKmlExtent(itemProperties.url, config, api),
      buildThumbnailURLFromKMLItem(itemProperties)
    ]);
    return await addUrl(Object.assign(Object.assign({}, itemProperties), { extent, thumbnailURL }));
  }
  catch (error) {
    throw error;
  }
}
async function setKmlExtent(url, config, api) {
  const [esriConfig, KMLLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config", "esri/layers/KMLLayer"]);
  if (api === 3) {
    esriConfig.defaults.kmlService = config.kmlService;
  }
  else {
    esriConfig.kmlServiceUrl = config.kmlService;
  }
  if (api === 4) {
    const kmlLayer = new KMLLayer({ url });
    await kmlLayer.load();
    const kmlExtent = kmlLayer.fullExtent;
    const extent = extentToString(kmlExtent);
    return extent;
  }
  const kmlLayer = new KMLLayer(url);
  return new Promise((resolve, reject) => {
    kmlLayer.on("load", async () => {
      const kmlExtent = await getKmlExtent(kmlLayer);
      resolve(kmlExtent ? extentToString(kmlExtent) : undefined);
    });
    kmlLayer.on("error", reject);
  });
}
async function getKmlExtent(kmlLayer) {
  const [graphicsUtils] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/graphicsUtils"]);
  const kmlLayers = kmlLayer.getLayers();
  let kmlExtent;
  kmlLayers.forEach((layer) => {
    var _a;
    if (((_a = layer.graphics) === null || _a === void 0 ? void 0 : _a.length) > 0) {
      const layerExtent = graphicsUtils.graphicsExtent(layer.graphics);
      kmlExtent = !kmlExtent ? layerExtent : kmlExtent.union(layerExtent);
    }
  });
  return kmlExtent;
}
const processPostAddKML = async (itemId, portal, restBaseUrl, config, api) => {
  try {
    const baseUrl = portal.isPortal ? restBaseUrl : `https://${portal.portalHostname}/sharing/rest`;
    const url = portal.portalHostname ? `${baseUrl}/content/items/${itemId}/data` : `${(0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.g)(itemId)}/data`;
    const extent = await setKmlExtent(url, config, api);
    // TODO: Double check result type on URL refactor
    const result = await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.e)(itemId, { url, extent });
    return { result };
  }
  catch (error) {
    console.error(error);
    return { error: { code: "unhandledError" } };
  }
};

/** True if x doesn't hold a value. */
function isNone(x) {
  return x == null;
}

async function isTiledImageServiceLayer(layer) {
  if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
    return layer.type == "imagery-tile";
  }
  const [RasterXLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/RasterXLayer"]);
  return layer instanceof RasterXLayer;
}
async function isImageServiceLayer(layer) {
  if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
    return layer.type === "imagery";
  }
  const [ArcGISImageServiceLayer, ArcGISImageServiceVectorLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    "esri/layers/ArcGISImageServiceLayer",
    "esri/layers/ArcGISImageServiceVectorLayer"
  ]);
  return layer instanceof ArcGISImageServiceLayer || layer instanceof ArcGISImageServiceVectorLayer;
}
async function getDefaultPopupInfo(layerInfo, layer) {
  var _a, _b;
  const displayField = layerInfo.displayField;
  const title = layerInfo.name + ((displayField === null || displayField === void 0 ? void 0 : displayField.length) ? `: {${displayField}}` : "");
  let fields = layerInfo.fields;
  let isMosaicDatasetService = false;
  let isVectorMosaicDatasetService = false;
  let isIntegerImageService = false;
  const isImageService = await isImageServiceLayer(layer);
  const isTiledImageService = await isTiledImageServiceLayer(layer);
  if (isImageService || isTiledImageService) {
    const options = { rasterAttributeTableFieldPrefix: "Raster." };
    fields = (_a = layer.getCustomRasterFields) === null || _a === void 0 ? void 0 : _a.call(layer, options);
    isIntegerImageService = ["F32", "F64"].indexOf(layer.pixelType) < 0;
    //checking for single dataset image service
    if (layer === null || layer === void 0 ? void 0 : layer.capabilities) {
      isMosaicDatasetService = (layer === null || layer === void 0 ? void 0 : layer.capabilities.toLowerCase().indexOf("catalog")) > -1 || ((_b = layer.fields) === null || _b === void 0 ? void 0 : _b.length) > 0;
      isVectorMosaicDatasetService =
        isMosaicDatasetService &&
          (layer.serviceDataType === "esriImageServiceDataTypeVector-UV" ||
            layer.serviceDataType === "esriImageServiceDataTypeVector-MagDir");
    }
  }
  const decimal = {
    esriFieldTypeDouble: 1,
    esriFieldTypeSingle: 1
  };
  const integer = {
    esriFieldTypeInteger: 1,
    esriFieldTypeSmallInteger: 1
  };
  const dt = {
    esriFieldTypeDate: 1
  };
  // hide editor tracking fields
  let editTrackingFields = ",";
  if (layerInfo.editFieldsInfo) {
    if (layerInfo.editFieldsInfo.creatorField) {
      editTrackingFields += `${layerInfo.editFieldsInfo.creatorField},`;
    }
    if (layerInfo.editFieldsInfo.creationDateField) {
      editTrackingFields += `${layerInfo.editFieldsInfo.creationDateField},`;
    }
    if (layerInfo.editFieldsInfo.editorField) {
      editTrackingFields += `${layerInfo.editFieldsInfo.editorField},`;
    }
    if (layerInfo.editFieldsInfo.editDateField) {
      editTrackingFields += `${layerInfo.editFieldsInfo.editDateField},`;
    }
    editTrackingFields = editTrackingFields.toLowerCase();
  }
  const fieldInfos = fields.map((item) => {
    let visible = item.type !== "esriFieldTypeOID" &&
      item.type !== "esriFieldTypeGlobalID" &&
      item.type !== "esriFieldTypeGeometry";
    let format = null;
    let isEditable = item.editable && item.type !== "esriFieldTypeOID" && item.type !== "esriFieldTypeGlobalID";
    if (visible) {
      let f = item.name.toLowerCase();
      let hideFieldsStr = `${editTrackingFields}stretched value,fnode_,tnode_,lpoly_,rpoly_,poly_,subclass,subclass_,rings_ok,rings_nok,`;
      if (isMosaicDatasetService) {
        hideFieldsStr = `${hideFieldsStr}raster.itempixelvalue,`;
        if (isVectorMosaicDatasetService) {
          hideFieldsStr = `${hideFieldsStr}raster.magnitude,raster.direction,`;
        }
      }
      if (hideFieldsStr.indexOf(`,${f},`) > -1 ||
        //f.indexOf("area") > -1 ||
        //f.indexOf("length") > -1 ||
        f.indexOf("shape") > -1 ||
        f.indexOf("perimeter") > -1 ||
        f.indexOf("objectid") > -1 ||
        f.indexOf("raster.servicepixelvalue.") > -1 ||
        //f.indexOf("_") == f.length - 1 ||
        f.indexOf("_i") == f.length - 2) {
        visible = false;
      }
      if (item.type in integer) {
        format = {
          places: 0,
          digitSeparator: true
        };
      }
      else if (item.type in decimal) {
        var rasterPixelValueField = isIntegerImageService &&
          (f.indexOf("raster.servicepixelvalue") > -1 || f.indexOf("raster.itempixelvalue") > -1);
        format = {
          places: rasterPixelValueField ? 0 : 2,
          digitSeparator: true
        };
      }
      else if (item.type in dt && (layerInfo.currentVersion >= 10 || (layer === null || layer === void 0 ? void 0 : layer.version) >= 10)) {
        format = {
          dateFormat: "longMonthDayYear"
        };
      }
    }
    isEditable = isEditable ? editTrackingFields.indexOf(`,${item.name.toLowerCase()},`) === -1 : isEditable;
    return {
      fieldName: item.name,
      label: item.alias,
      isEditable,
      tooltip: "",
      visible,
      format,
      stringFieldOption: "textbox"
    };
  });
  const popupInfo = {
    title: title,
    fieldInfos: fieldInfos,
    description: null,
    showAttachments: true,
    mediaInfos: [],
    layerOptions: undefined
  };
  if (isImageServiceLayer(layer)) {
    popupInfo.layerOptions = {};
    popupInfo.layerOptions.showNoDataRecords = true;
    popupInfo.layerOptions.returnTopmostRaster = true;
  }
  else if (isTiledImageServiceLayer(layer)) {
    popupInfo.layerOptions = {};
    popupInfo.layerOptions.showNoDataRecords = true;
  }
  return popupInfo;
}

const pointJson = {
  type: "esriSMS",
  style: "esriSMSCircle",
  color: [34, 114, 162, 128],
  size: 6,
  outline: {
    color: [34, 114, 162, 255],
    width: 1
  }
};
const lineJson = {
  type: "esriSLS",
  style: "esriSLSSolid",
  color: [77, 77, 77, 255],
  width: 1.5
};
const polygonJson = {
  type: "esriSFS",
  style: "esriSFSSolid",
  color: [227, 139, 79, 204],
  outline: {
    type: "esriSLS",
    style: "esriSLSSolid",
    color: [255, 255, 255, 255],
    width: 0.75
  }
};
async function getRendererAsJson(geometryType) {
  const [SimpleRenderer, esriJsonUtil] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    "esri/renderers/SimpleRenderer",
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/support/jsonUtils" : "esri/symbols/jsonUtils"
  ]);
  switch (geometryType) {
    case "esriGeometryPoint":
      return new SimpleRenderer(esriJsonUtil.fromJson(pointJson)).toJson();
    case "esriGeometryPolyline":
      return new SimpleRenderer(esriJsonUtil.fromJson(lineJson)).toJson();
    case "esriGeometryPolygon":
      return new SimpleRenderer(esriJsonUtil.fromJson(polygonJson)).toJson();
  }
}
async function getPopupInfo(wfsLayer) {
  const { fields, selectedLayer } = wfsLayer;
  if (fields === null || fields === void 0 ? void 0 : fields.length) {
    const nonGeomFields = fields.filter((field) => field.type !== "esriFieldTypeGeometry");
    if (nonGeomFields === null || nonGeomFields === void 0 ? void 0 : nonGeomFields.length) {
      return getDefaultPopupInfo({
        name: (selectedLayer === null || selectedLayer === void 0 ? void 0 : selectedLayer.title) || "",
        fields: fields
      }, wfsLayer);
    }
  }
}
async function getWfsConfig(wfsLayer) {
  const { layerNamespace, getFeatureUrl, spatialReferences, fields } = wfsLayer;
  const { maxFeatures, geometryType: addItemGeometryType } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  let url;
  let mode;
  let version;
  let name;
  if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3) {
    const data = wfsLayer.toJson();
    url = data.url;
    mode = data.mode;
    version = data.version;
    name = data.name;
  }
  else {
    const v4WFS = wfsLayer;
    url = v4WFS.url;
    // mode = v4WFS.mode;
    version = "2.0.0";
    name = v4WFS.name;
  }
  const geometryType = addItemGeometryType || wfsLayer.geometryType || "esriGeometryComplex";
  return {
    url,
    mode,
    wfsInfo: {
      version,
      name,
      wfsNamespace: layerNamespace,
      featureUrl: getFeatureUrl,
      supportedSpatialReferences: spatialReferences,
      customParameters: wfsLayer.customParameters || {},
      maxFeatures: maxFeatures || wfsLayer.maxFeatures || 3000
    },
    layerDefinition: {
      geometryType: geometryType,
      drawingInfo: {
        renderer: await getRendererAsJson(geometryType)
      },
      spatialReference: {
        wkid: 4326
      },
      fields
    },
    popupInfo: await getPopupInfo(wfsLayer)
  };
}
async function buildThumbnailURLFromWFSItem(extent) {
  const { config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const webMap = {
    baseMap: config.defaultBasemap || config.self.defaultBasemap,
    operationalLayers: []
  };
  const { baseMapLayers } = webMap.baseMap;
  // we need only one basemap layer and we hide it - use layerSet bool to check if one has been set already
  let layerSet = false;
  baseMapLayers.forEach((layer) => {
    if (!layer.isReference && !layerSet) {
      // we need only one basemap layer and we hide it
      if ((config.allSSL || location.protocol == "https:") &&
        ((0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.a)(layer.url) || (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.b)(layer.url))) {
        layer.url = layer.url.replace("http:", "https:");
      }
      layer.visibility = false;
      layerSet = true;
      webMap.baseMap.baseMapLayers = [layer];
    }
  });
  const operationalLayer = {
    type: "WFS",
    layerType: "WFS",
    opacity: 1,
    visibility: true,
    id: "wfs_xxx",
    wfsInfo: {
      maxFeatures: 100
    }
  };
  webMap.operationalLayers.push(operationalLayer);
  return buildThumbnailURLFromItemWebMap(webMap, extent);
}
async function getWMTSConfig(wmtsLayer) {
  var _a;
  const is4xAPI = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4;
  function getTileInfoAsJson(selectedTileInfo) {
    const { tileInfo } = selectedTileInfo;
    if ((tileInfo === null || tileInfo === void 0 ? void 0 : tileInfo.dpi) !== 96) {
      tileInfo.lods.forEach((lod) => {
        lod.scale = (lod.scale * 96) / tileInfo.dpi;
      });
      tileInfo.dpi = 96;
    }
    return is4xAPI ? tileInfo : tileInfo.toJson();
  }
  function getCopyright(copyright) {
    if ((copyright === null || copyright === void 0 ? void 0 : copyright.toLowerCase()) !== "none") {
      return (copyright === null || copyright === void 0 ? void 0 : copyright.length) > 180 ? `${copyright.substring(0, 180)}..` : "";
    }
    else {
      return copyright;
    }
  }
  try {
    const [SpatialReference] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
      is4xAPI ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
    ]);
    const { selectedLayer, selectedTileInfo, copyright } = wmtsLayer;
    const sr = (selectedTileInfo === null || selectedTileInfo === void 0 ? void 0 : selectedTileInfo.fullExtent.spatialReference) || new SpatialReference({ wkid: 4326 });
    const fullExtent = await projectExtent(selectedLayer === null || selectedLayer === void 0 ? void 0 : selectedLayer[is4xAPI ? "fullExtent" : "gcsExtent"], sr).then((result) => { var _a; return ((_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.type) === "extent" ? (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? result[0] : result[0].toJson()) : null; });
    const format = selectedLayer[is4xAPI ? "imageFormat" : "formats"].indexOf("image/png") > -1
      ? "image/png"
      : selectedLayer.formats[0];
    wmtsLayer.resourceUrls = selectedLayer.resourceUrls;
    let templateUrl;
    if (is4xAPI) {
      templateUrl = wmtsLayer.getUrlTemplate(selectedLayer.id, selectedTileInfo.id, format, selectedLayer.styleId);
    }
    else {
      templateUrl = wmtsLayer.getTileUrlTemplate({
        identifier: selectedLayer.identifier,
        tileMatrixSet: selectedTileInfo.tileMatrixSet,
        format
      });
    }
    const wmtsConfig = {
      templateUrl,
      copyright: getCopyright(copyright),
      fullExtent: fullExtent || wmtsLayer.selectedTileInfo.fullExtent,
      tileInfo: getTileInfoAsJson(selectedTileInfo),
      wmtsInfo: {
        url: (_a = wmtsLayer.wmtsUrl) !== null && _a !== void 0 ? _a : wmtsLayer.url,
        layerIdentifier: selectedLayer.identifier,
        tileMatrixSet: selectedTileInfo.tileMatrixSet,
        customParameters: wmtsLayer.customParameters || {},
        customLayerParameters: wmtsLayer.customLayerParameters || {}
      }
    };
    return Promise.resolve({ wmtsConfig: wmtsConfig, fullExtent: fullExtent });
  }
  catch (error) {
    console.error(error);
    throw error; // TODO: refactor this to our error system
  }
}
/** HAZARD WARNING! Return a URL to the hosted image in 3.x case and base64 data url in 4.x case*/
async function buildThumbnailURLFromWMTSItem(item, newExtent) {
  if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3) {
    const baseMapLayerOpts = {
      opacity: 1,
      visibility: true,
      layerType: "WebTiledLayer",
      type: "WebTiledLayer"
    };
    const webMap = {
      baseMap: {
        title: "basemap",
        baseMapLayers: [],
        operationalLayers: []
      }
    };
    if (item.id) {
      const response = await getItemData(item.id);
      webMap.baseMap.baseMapLayers.push(Object.assign(Object.assign({}, response), baseMapLayerOpts));
    }
    else {
      webMap.baseMap.baseMapLayers.push(baseMapLayerOpts);
    }
    return buildThumbnailURLFromWebMap(webMap, newExtent || item.extent);
  }
  else {
    const [WMTSLayer, Map, MapView, reactiveUtils] = (await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
      "esri/layers/WMTSLayer",
      "esri/Map",
      "esri/views/MapView",
      "esri/core/reactiveUtils"
    ]));
    const wmtsLayer = new WMTSLayer({
      portalItem: {
        id: item.id,
        // @ts-ignore --- User.role is different in 3x
        portal: _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.portal
      }
    });
    const map = new Map({ layers: [wmtsLayer] });
    const hiddenMapId = createHiddenMapDiv();
    const view = new MapView({ container: hiddenMapId, map });
    await reactiveUtils.whenOnce(() => !view.updating);
    await view.goTo(wmtsLayer.fullExtent);
    const screenshot = await view.takeScreenshot({
      width: view.width,
      height: view.height,
      format: "png"
    });
    return screenshot.dataUrl;
  }
}
async function getItemData(id) {
  const { config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const url = `${config.restBaseUrl}content/items/${id}/data`;
  try {
    const result = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, null, {
      disableIdentityLookup: true
    });
    if (result && ((result === null || result === void 0 ? void 0 : result.wfsInfo) || result.wmtsInfo)) {
      return result;
    }
    else if (result === null || result === void 0 ? void 0 : result.layers) {
      return result.layers;
    }
    return {};
  }
  catch (error) {
    return error;
  }
}

function getStaticImagesUrl(portal) {
  var _a;
  return ((_a = portal === null || portal === void 0 ? void 0 : portal.staticImagesUrl) === null || _a === void 0 ? void 0 : _a.replace("http:", "https:")) || "";
}
const checkThumbnailURL = (item) => {
  var _a;
  const portal = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.portal;
  if (item.thumbnailURL) {
    item.thumbnailURL = getStaticImagesUrl(portal) + item.thumbnailURL;
  }
  if (portal.isPortal && ((_a = item.thumbnailURL) === null || _a === void 0 ? void 0 : _a.indexOf("http")) !== 0) {
    // staticImagesUrl is relative
    item.thumbnailURL = window.location.protocol + "//" + window.location.host + item.thumbnailURL;
  }
  return item;
};

const stripParameters = (url, blackList) => {
  const [base, search] = url.split("?");
  const whitelisted = (search === null || search === void 0 ? void 0 : search.split("&").reduce((acc, section) => {
    const [key] = section.split("=");
    if (blackList.indexOf(key.toLowerCase()) === -1) {
      return `${acc}${acc ? "&" : "?"}${section}`;
    }
    return acc;
  }, "")) || "";
  return `${base}${whitelisted}`;
};
const getWMSServiceInfo = async (item) => {
  var _a;
  const [WMSLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/WMSLayer"]);
  const { customParameters } = item;
  const formattedParams = formatCustomParameters(customParameters);
  // Remove these parameters from the url since the JSAPI will set them automatically
  const wmsUrl = stripParameters(item.url, [
    "service",
    "request",
    "bbox",
    "format",
    "height",
    "width",
    "layers",
    "srs",
    "crs",
    "styles",
    "transparent",
    "bgcolor",
    "exceptions",
    "time",
    "elevation",
    "sld",
    "wfs"
  ]);
  try {
    if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
      const wmsLayer = new WMSLayer({
        url: wmsUrl,
        customParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {},
        customLayerParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}
      });
      try {
        const loadedLayer = await wmsLayer.load();
        item.type = "WMS";
        return { result: Object.assign(Object.assign({}, item), { type: "WMS", serviceInfo: loadedLayer }) };
      }
      catch (err) {
        return {
          error: {
            code: err.message ? "unhandledError" : "serviceNotExist",
            message: (_a = err.message) !== null && _a !== void 0 ? _a : err.message
          }
        };
      }
    }
    // --- v3 ---
    await checkCORS(wmsUrl);
    const wmsLayer = new WMSLayer(wmsUrl, {
      customParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {},
      customLayerParameters: Object.assign({}, formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}
    });
    const result = await new Promise((resolve, reject) => {
      wmsLayer.on("load", () => {
        item.type = "WMS";
        resolve(Object.assign(Object.assign({}, item), { type: "WMS", serviceInfo: wmsLayer }));
      });
      wmsLayer.on("error", (err) => {
        var _a;
        const { error } = err;
        const serviceNotExist = !(error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.status) === 404;
        reject({
          code: serviceNotExist ? "serviceNotExist" : "unhandledError",
          message: (_a = error.message) !== null && _a !== void 0 ? _a : err.message
        });
      });
    });
    return { result };
  }
  catch (error) {
    console.error(error);
    return { error };
  }
};
// this will correctly format the layers from the service info to be used in the bulk layer select component
const loadWMSLayers = async (serviceInfo) => {
  const loadedServiceInfo = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? await serviceInfo.load() : serviceInfo;
  const { layerInfos, title, allSublayers } = loadedServiceInfo;
  const layers = getWMSLayerTree(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? allSublayers.items : layerInfos);
  // TODO: move title to base serviceInfo fetch, only return layers here
  return { title, layers };
};
function getWMSLayerTree(layers) {
  return layers.map((layer) => ({
    name: layer.name,
    visible: false,
    title: layer.title.replace(/ /g, String.fromCharCode(160)),
    extent: layer.extent,
    legendURL: layer.legendURL,
    queryable: layer.queryable,
    subLayers: layer.subLayers || []
  }));
}
function flattenLayerAndRemoveIds(flattenedLayers = [], layer) {
  delete layer.id;
  if (!layer.subLayers || !layer.subLayers.length) {
    return [...flattenedLayers, layer];
  }
  else {
    return layer.subLayers.reduce(flattenLayerAndRemoveIds, flattenedLayers);
  }
}
const addWMSUrl = async (item) => {
  const [SpatialReference] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "esri/geometry/SpatialReference" : "esri/SpatialReference"
  ]);
  const { layers } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  if (!item || !(item === null || item === void 0 ? void 0 : item.serviceInfo)) {
    return Promise.reject(new Error("serviceNotExist"));
  }
  const itemInfo = checkThumbnailURL(item);
  const { serviceInfo } = itemInfo;
  const visibleLayers = [];
  let fullExtent;
  const flattenedLayers = layers.reduce(flattenLayerAndRemoveIds, []);
  const selectedLayers = flattenedLayers.map((layer) => {
    fullExtent = !fullExtent ? layer.extent : layer.extent ? fullExtent.union(layer.extent) : fullExtent;
    visibleLayers.push(layer.name);
    const obj = { name: layer.name, title: layer.title, legendURL: "", queryable: layer.queryable };
    if (layer.legendURL) {
      obj.legendURL = layer.legendURL;
    }
    return obj;
  });
  serviceInfo.setVisibleLayers(visibleLayers);
  fullExtent = fullExtent || serviceInfo.fullExtent;
  const isGCS = !serviceInfo.spatialReferences.some((sr) => sr === fullExtent.spatialReference.wkid);
  const updatedItem = {
    type: item.type,
    url: serviceInfo.url,
    description: serviceInfo.description || "",
    accessInformation: serviceInfo.copyright || "",
    text: getWMSData(serviceInfo, selectedLayers),
    extent: fullExtent
  };
  if (isGCS) {
    project(fullExtent, new SpatialReference({ wkid: serviceInfo.spatialReferences[0] })).then((extent) => (updatedItem.extent = extent));
  }
  const itemToAdd = await getWMSImageUrl(updatedItem, serviceInfo);
  return addUrl(itemToAdd);
};
const getWMSImageUrl = (item, wmsLayer) => {
  return new Promise((resolve) => {
    const handler = (imageUrl) => {
      resolve(Object.assign(Object.assign({}, item), { thumbnailURL: imageUrl || item.thumbnailURL, extent: extentToString(item.extent) }));
    };
    wmsLayer.getImageUrl(item.extent, 800, 532, handler, handler);
  });
};
const getWMSData = (wmsLayer, selectedLayers) => {
  return JSON.stringify({
    title: wmsLayer.title || "",
    url: wmsLayer.url,
    mapUrl: wmsLayer.getMapURL,
    version: wmsLayer.version,
    layers: selectedLayers,
    copyright: wmsLayer.copyright || "",
    maxHeight: wmsLayer.maxHeight,
    maxWidth: wmsLayer.maxWidth,
    spatialReferences: wmsLayer.spatialReferences,
    format: wmsLayer.getImageFormat() !== "png" ? wmsLayer.getImageFormat() : null,
    featureInfoUrl: wmsLayer.getFeatureInfoURL,
    featureInfoFormat: wmsLayer.featureInfoFormat,
    customParameters: wmsLayer.customParameters || {},
    customLayerParameters: wmsLayer.customLayerParameters || {}
  });
};
const getWFSVersionFromUrl = async (url) => {
  const { query: queryObject } = await (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.c)(url);
  return (queryObject === null || queryObject === void 0 ? void 0 : queryObject.version) || "2.0.0";
};
/**
 * Fetch a url and add to the trusted domains list if it supports CORS
 */
async function checkCORS(url) {
  var _a, _b, _c;
  try {
    const testReponse = await fetch(url);
    if (testReponse.type === "cors" && testReponse.status === 200) {
      const domain = new URL(url).hostname;
      const [esriConfig] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/config"]);
      (_c = (_b = (_a = esriConfig === null || esriConfig === void 0 ? void 0 : esriConfig.defaults) === null || _a === void 0 ? void 0 : _a.io) === null || _b === void 0 ? void 0 : _b.corsEnabledServers) === null || _c === void 0 ? void 0 : _c.push(domain);
    }
  }
  catch (error) { }
}
const getWFSServiceInfo = async (item, options) => {
  const [WFSLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/WFSLayer"]);
  const { customParameters } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  const { url } = item;
  const wfsUrl = stripParameters(url, ["version", "service", "request", "layer", "typename"]);
  const formattedParams = formatCustomParameters(customParameters);
  const wfsVersion = await getWFSVersionFromUrl(url);
  const wfsLayerOptions = options || {
    version: wfsVersion,
    url: wfsUrl,
    customParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {}
  };
  try {
    // V4 only supports 2.0.0 version
    if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
      if (wfsVersion !== "2.0.0") {
        return { error: { code: "unsupportedWFSVersion" } };
      }
      // v4 version is read-only
      delete wfsLayerOptions.version;
      // and we don't need the url
      delete wfsLayerOptions.url;
      const [wfsUtils] = (await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/ogc/wfsUtils"]));
      const capabilities = await wfsUtils.getCapabilities(wfsUrl, wfsLayerOptions);
      const layers = capabilities.featureTypes;
      if (!layers || !layers.length) {
        return { error: { code: "emptyFeatureLayer" } };
      }
      else {
        const layerInfo = await wfsUtils.getWFSLayerInfo(capabilities);
        const wfsLayer = WFSLayer.fromWFSLayerInfo(layerInfo);
        wfsLayer.layers = layers;
        wfsLayer.url = wfsUrl;
        wfsLayer.isComplex = wfsLayer.geometryType === "esriGeometryComplex";
        return { result: Object.assign(Object.assign({}, item), { type: "WFS", serviceInfo: wfsLayer }) };
      }
    }
    // --- v3 ---
    const wfsLayer = new WFSLayer(wfsLayerOptions);
    await checkCORS(wfsUrl);
    const result = await new Promise((resolve, reject) => {
      wfsLayer.initialize(wfsLayerOptions, (layers) => {
        if (!layers || !layers.length) {
          reject({ code: "emptyFeatureLayer" });
        }
        else {
          wfsLayer.layers = layers;
          wfsLayer.url = wfsUrl;
          wfsLayer.isComplex = wfsLayer.geometryType === "esriGeometryComplex";
          resolve(Object.assign(Object.assign({}, item), { type: "WFS", serviceInfo: wfsLayer }));
        }
      });
      // WFS layers can throw an error if not using the correct version - so we can try with different versions from newest version to oldest
      wfsLayer.on("error", async () => {
        if (wfsLayer.toJson().version === "2.0.0") {
          const { result, error } = await getWFSServiceInfo(item, { version: "1.1.0", url });
          if (error) {
            reject(error);
          }
          resolve(result);
        }
        else if (wfsLayer.toJson().version === "1.1.0") {
          const { result, error } = await getWFSServiceInfo(item, { version: "1.0.0", url });
          if (error) {
            reject(error);
          }
          resolve(result);
        }
        else {
          reject({ code: "serviceNotExist" });
        }
      });
    });
    return { result };
  }
  catch (error) {
    console.error(error);
    return { error };
  }
};
const addWFSUrl = async (item) => {
  var _a;
  if (!item || !(item === null || item === void 0 ? void 0 : item.serviceInfo)) {
    return Promise.reject(new Error("serviceNotExist"));
  }
  const { serviceInfo: wfsLayer } = item;
  const fullExtent = ((_a = wfsLayer.selectedLayer) === null || _a === void 0 ? void 0 : _a.fullExtent) || [[], []];
  const stringExtent = extentToString(fullExtent);
  const arrExtent = stringExtent.split(",").map(Number);
  if (!wfsLayer.geometryType || wfsLayer.geometryType === "none") {
    return Promise.reject(new Error("missingGeometry"));
  }
  const formattedItem = { type: item.type, url: item.url, thumbnailURL: item.thumbnailURL };
  const wfsConfig = await getWfsConfig(wfsLayer);
  const itemInfo = Object.assign(Object.assign({}, checkThumbnailURL(formattedItem)), { text: JSON.stringify(wfsConfig), extent: stringExtent });
  const response = await addUrl(itemInfo);
  const updatedItem = Object.assign(Object.assign(Object.assign({}, itemInfo), response), { extent: [
      [arrExtent[0], arrExtent[1]],
      [arrExtent[2], arrExtent[3]]
    ] });
  // TODO: you know - looking at this - i think we need to actually call updateItem on WFS items since it looks like the thumbnail url isn't actually being set on the Item. Oops!
  try {
    const thumbnailUrl = await buildThumbnailURLFromWFSItem(updatedItem.extent);
    return Object.assign(Object.assign({}, updatedItem), { thumbnailUrl });
  }
  catch (error) {
    return updatedItem;
  }
};
async function getWMTSOptions(url) {
  var _a, _b;
  // before we strip parameters see if it's a KVP capabilities URL. Then we use that one first.
  const urlObj = await (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.c)(url);
  const servicekey = ((_a = urlObj.query) === null || _a === void 0 ? void 0 : _a["service"]) || "";
  const requestKey = ((_b = urlObj.query) === null || _b === void 0 ? void 0 : _b["request"]) || "";
  if ((servicekey.toLowerCase() === "wmts" && requestKey.toLowerCase() === "getcapabilities") ||
    url.toLowerCase().indexOf("/1.0.0/wmtscapabilities.xml") > -1) {
    return { serviceMode: "KVP" };
  }
  else {
    return {};
  }
}
async function getWMTSServiceInfo(item, options) {
  const [WMTSLayer] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)(["esri/layers/WMTSLayer"]);
  const { customParameters, url } = item;
  const formattedParams = formatCustomParameters(customParameters);
  const wmtsOptions = Object.assign(Object.assign({}, options), { customLayerParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}, customParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {} }) ||
    (await Object.assign(Object.assign({}, getWMTSOptions(url)), { customLayerParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customLayerParameters) || {}, customParameters: (formattedParams === null || formattedParams === void 0 ? void 0 : formattedParams.customParameters) || {} }));
  const wmtsUrl = stripParameters(url, [
    "version",
    "service",
    "request",
    "layer",
    "style",
    "format",
    "tilematrixset",
    "tilematrix",
    "tilerow",
    "tilecol"
  ]);
  const newWmtsUrl = wmtsUrl.replace(/\/1.0.0\/wmtscapabilities.xml/i, "");
  try {
    if (_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4) {
      const wmtsLayer = new WMTSLayer(newWmtsUrl, wmtsOptions);
      const v4Layer = wmtsLayer;
      await v4Layer.load();
      const layers = v4Layer.sublayers.toArray();
      if (!layers || !layers.length) {
        return { error: { code: `serviceNotExist` } };
      }
      else {
        wmtsLayer.layers = layers;
        return { result: Object.assign(Object.assign({}, item), { type: "WMTS", serviceInfo: wmtsLayer }) };
      }
    }
    // --- v3 ---
    await checkCORS(wmtsUrl);
    const wmtsLayer = new WMTSLayer(newWmtsUrl, wmtsOptions);
    let layers;
    const result = await new Promise((resolve, reject) => {
      wmtsLayer.on("load", ({ layer: wmtsInfo }) => {
        layers = wmtsInfo.layers;
        if (!layers || !layers.length) {
          reject(new Error(`serviceNotExist`));
        }
        else {
          wmtsLayer.layers = layers;
          resolve(Object.assign(Object.assign({}, item), { type: "WMTS", serviceInfo: wmtsLayer }));
        }
      });
      wmtsLayer.on("error", (err) => {
        var _a;
        if (!wmtsOptions.serviceMode) {
          getWMTSServiceInfo(item, { serviceMode: "KVP" }).then(({ result, error }) => {
            if (error) {
              reject(error);
            }
            resolve(result);
          }, reject);
        }
        else {
          if (((_a = err.error) === null || _a === void 0 ? void 0 : _a.message) === "The WMTS capabilities XML is not valid") {
            reject({ code: "invalidWMTS" });
          }
          reject({ code: "serviceNotExist" });
        }
      });
    });
    return { result };
  }
  catch (error) {
    console.error(error);
    return { error };
  }
}
async function addWMTSUrl(item) {
  if (!item) {
    return Promise.reject("serviceNotExist");
  }
  const { serviceInfo: wmtsLayer, selectedLayer, selectedTileInfo } = item;
  if (!selectedLayer) {
    return Promise.reject(new Error("layerNotSelected"));
  }
  if (!selectedTileInfo) {
    return Promise.reject(new Error("missingGeometry"));
  }
  wmtsLayer.selectedTileInfo = selectedTileInfo;
  const { wmtsConfig, fullExtent: configExtent } = await getWMTSConfig(wmtsLayer).catch((error) => {
    console.error("Error getting WMTS config", error);
    throw error;
  });
  const gcsExtent = wmtsLayer.selectedLayer[_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? "fullExtent" : "gcsExtent"];
  const fullExtent = configExtent ? gcsExtent : { xmin: -180, ymin: -90, xmax: 180, ymax: 90 };
  const formattedItem = { type: item.type, url: item.url, thumbnailURL: item.thumbnailURL };
  const itemInfo = Object.assign(Object.assign({}, checkThumbnailURL(formattedItem)), { url: wmtsConfig.wmtsInfo.url, text: JSON.stringify(wmtsConfig), extent: `${fullExtent.xmin},${fullExtent.ymin},${fullExtent.xmax},${fullExtent.ymax}` });
  const response = await addUrl(itemInfo);
  const updatedItem = Object.assign(Object.assign(Object.assign({}, itemInfo), response), { extent: [
      [fullExtent.xmin, fullExtent.ymin],
      [fullExtent.xmax, fullExtent.ymax]
    ] });
  try {
    const thumbnailData = await buildThumbnailURLFromWMTSItem(updatedItem);
    const requestData = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 4 ? { type: "base64", data: thumbnailData } : { type: "url", url: thumbnailData };
    const itemWithThumbnail = await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.i)(response.id, requestData);
    return Object.assign(Object.assign({}, updatedItem), itemWithThumbnail);
  }
  catch (error) {
    console.error("Error when adding WMTS URL:", error);
    return updatedItem;
  }
}
async function getOGCFeatureLayerServiceInfo(item) {
  var _a, _b, _c, _d;
  const { url } = item;
  /** this is the first call from the MapViewer  - it will get the landing page in the form of "application/json - and then get the collection from it. */
  //   // @ 9.3 Will need to set the trustedServer stuff before this call
  //   // in case the service needs credentials
  const landingPageOptions = { addTokenManually: false, headers: { accept: "application/json" } };
  try {
    const getDataWithJSONRetry = async (func, failCallback) => {
      var _a, _b, _c;
      try {
        return await func();
      }
      catch (error) {
        const message = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : "";
        if (message.includes("unexpected token") || message.includes("expected expression")) {
          return failCallback();
        }
        else {
          throw { result: null, error: { code: "unhandledError", message: JSON.stringify(error) } };
        }
      }
    };
    const landingPage = await getDataWithJSONRetry(() => (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, {}, landingPageOptions, "auto", { excludeJson: true }), () => (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, {}, landingPageOptions));
    const serviceInfo = await getDataWithJSONRetry(() => getServerCollections(landingPage), () => getServerCollections(landingPage, {}, false));
    return {
      result: Object.assign(Object.assign({}, item), { extent: extentToString((_d = (_c = (_b = (_a = serviceInfo.collections) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.extent) === null || _c === void 0 ? void 0 : _c.spatial) === null || _d === void 0 ? void 0 : _d.bbox), type: "OGCFeatureServer", serviceInfo, layers: serviceInfo.collections }),
      error: null
    };
  }
  catch (error) {
    console.error("get OGC feature layer:", error);
    // TODO: handle error transformation here
    return { result: null, error: { code: "unhandledError", message: JSON.stringify(error) } };
  }
}
function selectOGCFeatureLayer(selectedLayer) {
  var _a, _b;
  if (!selectedLayer) {
    return;
  }
  const { title, description } = selectedLayer;
  _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.title = (_a = title !== null && title !== void 0 ? title : _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.title) !== null && _a !== void 0 ? _a : "";
  _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.snippet = (_b = description !== null && description !== void 0 ? description : _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.snippet) !== null && _b !== void 0 ? _b : "";
  _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.selectedLayer = selectedLayer;
}
async function getServerCollections(landingPage, options = {}, excludeJson = true) {
  const { links } = landingPage;
  const link = getLink(links, "data", "application/json") ||
    getLink(links, "http://www.opengis.net/def/rel/ogc/1.0/data", "application/json");
  if (isNone(link)) {
    throw new Error("Missing collections url");
  }
  return _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3
    ? (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(addParameters(link.href), {}, Object.assign(Object.assign({}, options), { addTokenManually: false }), "auto", {
      v3Request: { headers: { accept: "application/json" } },
      excludeJson
    })
    : (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(addParameters(link.href), {}, Object.assign(Object.assign({}, options), { addTokenManually: false, headers: { accept: "application/json" } }), "auto", {
      excludeJson
    });
}
function getLink(links, relation, type) {
  return (links.find((link) => link.rel === relation && link.type === type) ||
    links.find((link) => link.rel === relation && !link.type));
}
async function addOGCFeatureService(item) {
  const { serviceInfo, customParameters } = item;
  if (!serviceInfo) {
    return Promise.reject(new Error("serviceNotExist"));
  }
  // This will need to be updated based on how metadata needs to be formatted.
  if (customParameters.length > 0) {
    item.text = JSON.stringify({ customParameters: formatCustomParameters(customParameters).customParameters });
  }
  return addUrl(item);
}

// function to navigate to the correct "addItem" requests
const addItem = (item, restBaseUrl) => {
  const { newItemMode, typeKeywords, tags, extent, selectedServiceInfoLayersNames, addFeatureLayerType } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  const title = _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.title;
  if ((title === null || title === void 0 ? void 0 : title.length) > 250) {
    _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.title = title.substring(0, 250);
  }
  switch (newItemMode) {
    case "application":
      return addApplication(item, restBaseUrl);
    case "file":
      // TODO: Pass in item properties/item request here instead of grabbing from the store again
      return addFile();
    case "url":
      // TODO: refactor the passed configState out of this
      return handleAddUrl(item, _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.config, _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api);
    case "featureLayer":
      return addFeatureLayer({
        serviceInfo: item.serviceInfo,
        typeKeywords,
        tags,
        extent,
        selectedServiceInfoLayersNames,
        addFeatureLayerType
      });
    default:
      return (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.c)(Object.assign({}, item));
  }
};
const uploadFile = async () => {
  try {
    const addItemRequest = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.c; // { ...addItemStore.state };
    const response = (await addItem(addItemRequest, ""));
    _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.id = response.id;
    const jobStatus = await getItemStatus(_add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.id, { success: response.success });
    if (jobStatus.status === "failed") {
      throw jobStatus.statusMessage;
    }
    return {};
  }
  catch (error) {
    console.error(error);
    const errorMessage = (error === null || error === void 0 ? void 0 : error.statusMessage) || error || "";
    switch (true) {
      case errorMessage.includes("Invalid File Geodatabase"):
        return { error: { code: "invalidFileGeodatabase" } };
      case errorMessage.includes("Invalid Shapefile"):
        return { error: { code: "invalidShapefile" } };
      case errorMessage.includes("The request size is greater than the max allowed of 1024MB"):
        return { error: { code: "exceedsFileSize" } };
      default:
        return { error: { code: "unhandledError" } };
    }
  }
};
const addFile = async (props) => {
  const file = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.file;
  const dataUrl = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.dataUrl;
  if (!file && dataUrl) {
    return addFileFromDataUrl(props);
  }
  // TODO: remove this ECD workaround when backend fixes filename creation (WebGIS/arcgis-portal-app#41068)
  if ((file === null || file === void 0 ? void 0 : file.size) > MULTI_PART_UPLOAD_MINIMUM_SIZE || _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.type === "Esri Classifier Definition") {
    return addFileMultiPart();
  }
  return addFileSingle();
};
const addFileFromDataUrl = async (props) => {
  var _a;
  const url = (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.n)(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.user, _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
  const { fileName, dataUrl, extension } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  const addItemParams = (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.j)(_item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i, _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a);
  const overwrite = !!_add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.overwrite; //could be undefined
  // in the case where we're adding geojson from a url referencing a feature service,
  // make a unique file name so that the file isn't the query WebGIS/arcgis-portal-app#42403
  const isGeoJSONFromFeatureServer = (dataUrl === null || dataUrl === void 0 ? void 0 : dataUrl.includes("/query?")) && (fileName === null || fileName === void 0 ? void 0 : fileName.includes("query")) && (extension === null || extension === void 0 ? void 0 : extension.includes("json"));
  const geojsonProperties = isGeoJSONFromFeatureServer
    ? {
      filename: (0,_guid_4f4176ba_js__WEBPACK_IMPORTED_MODULE_14__.g)(),
      dataUrl
    }
    : {};
  const params = Object.assign(Object.assign(Object.assign({}, addItemParams), { async: true, filename: (_a = props === null || props === void 0 ? void 0 : props.filename) !== null && _a !== void 0 ? _a : fileName, title: props === null || props === void 0 ? void 0 : props.title, overwrite }), geojsonProperties);
  return (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, params, {}, "post");
};
async function addFileSingle() {
  const url = (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.n)(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.user, _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
  const form = (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.k)(_item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i, _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a);
  try {
    return await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.e)(url, form, {}, "post");
  }
  catch (error) {
    throw (error === null || error === void 0 ? void 0 : error.message) || error;
  }
}
async function addPart(part, itemId, attempts = 0) {
  const user = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.user;
  // Keep attempting to add the part, only throwing an error after multiple retries
  try {
    const { partData, formData } = part;
    const parameters = `?streamdata=true&size=${partData.size}&partNum=${partData.partNum}&f=json`;
    const url = `${user.userContentUrl}/items/${itemId}/addPart${parameters}`;
    const response = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.e)(url, formData, {
      "X-Esri-Authorization": `Bearer ${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.h)(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.portal)}`
    }, "post");
    return { response, attempts, partSize: partData.size };
  }
  catch (_a) {
    if (!_add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.id) {
      throw "cancelled";
    }
    attempts++;
    if (attempts > MULTI_PART_UPLOAD_RETRIES) {
      // TODO: Update error message
      throw new Error("Upload failed - too many attempts");
    }
    else {
      return addPart(part, itemId, attempts);
    }
  }
}
function* generatePart() {
  const file = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.file;
  const { name, size } = file;
  let partSize = MULTI_PART_UPLOAD_BATCH_SIZE;
  let totalParts = Math.ceil(size / partSize);
  let part = 0;
  // Max number of parts is 10,000, so we increase the chunk size if the file is bigger than the threshold
  if (totalParts > MULTI_PART_UPLOAD_MAX_PARTS) {
    partSize = Math.ceil(size / MULTI_PART_UPLOAD_MAX_PARTS);
    totalParts = Math.ceil(size / partSize);
  }
  while (part < totalParts) {
    const formData = new FormData();
    const offset = part * partSize;
    const blob = file.slice(offset, offset + partSize);
    part++;
    const partData = {
      partNum: part,
      size: blob.size
    };
    formData.append("partNum", String(partData.partNum));
    formData.append("streamdata", "true");
    formData.append("f", "json");
    formData.append("token", (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.h)(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.portal));
    formData.append("file", blob, name);
    yield { partData, formData };
  }
  return null;
}
const addFileMultiPart = async () => {
  var _a, _b, _c, _d;
  let doUpload = true;
  const cancelUpload = () => {
    if (_add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.id) {
      doUpload = false;
      const itemId = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.id;
      _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.id = null;
      return (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.o)(itemId);
    }
  };
  const multiPartSubscriber = subscriptionState.addSubscriber("addFileMultiPart", cancelUpload);
  const config = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.config;
  const url = (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.n)(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.user, _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
  const { fileName, file } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  let partsPerBatch = (_a = config.multiPartBatchSize) !== null && _a !== void 0 ? _a : MULTI_PART_UPLOAD_INITIAL_BATCH_SIZE;
  let numConsecutiveSuccess = 0;
  let itemId;
  try {
    const itemResponse = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, { multipart: true, fileName, async: true }, {}, "post");
    itemId = (_b = itemResponse.id) !== null && _b !== void 0 ? _b : itemResponse.itemId;
    _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.id = itemId;
    // TODO: Factor uploadProgress out of addItemState
    _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.uploadProgress = 0;
    _store_3210b604_js__WEBPACK_IMPORTED_MODULE_15__.w.uploadProgress = 0;
    let bytesUploaded = 0;
    // Initialize dynamic batch generator
    const partGenerator = generatePart();
    await (0,_functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_6__.s)(() => {
      const { value, done } = partGenerator.next();
      return done ? null : addPart(value, itemId);
    }, {
      getBatchSize: () => partsPerBatch,
      onPromiseCompleted: (addPartResult) => {
        const { attempts, partSize } = addPartResult;
        // If a part only succeeded after one or more failures/retries, flag the batch to be reduced next time
        if (attempts > 0) {
          partsPerBatch = Math.max(1, Math.ceil(partsPerBatch / 2));
          numConsecutiveSuccess = 0;
        }
        else {
          numConsecutiveSuccess++;
          if (numConsecutiveSuccess >= partsPerBatch) {
            partsPerBatch = Math.min(partsPerBatch + 1, MULTI_PART_UPLOAD_MAX_BATCH_SIZE);
            numConsecutiveSuccess = 0;
          }
        }
        bytesUploaded += partSize;
        const progress = Math.floor((bytesUploaded / file.size) * 100);
        // TODO: Factor uploadProgress out of addItemState
        _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.uploadProgress = progress;
        _store_3210b604_js__WEBPACK_IMPORTED_MODULE_15__.w.uploadProgress = progress;
      },
      onPromiseThrow() {
        doUpload = false;
      },
      shouldContinue: () => doUpload && subscriptionState.isSubscriberValid(multiPartSubscriber)
    });
    subscriptionState.removeSubscriber(multiPartSubscriber);
    const { type, extension, enablePublishing, properties } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
    return await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.l)(itemId, {
      file,
      type,
      extension,
      enablePublishing,
      properties
    });
  }
  catch (error) {
    // If an item was partially uploaded, cancel it before throwing error
    await cancelUpload();
    console.error((_c = error === null || error === void 0 ? void 0 : error.message) !== null && _c !== void 0 ? _c : error);
    throw (_d = error === null || error === void 0 ? void 0 : error.message) !== null && _d !== void 0 ? _d : error;
  }
};
// --- URL
const handleAddUrl = (item, config, api) => {
  if (item.agsType) {
    return addSecureAGSUrl(item);
  }
  switch (item.type) {
    case "KML":
      return addKMLUrl(item, config, api);
    case "WMS":
      return addWMSUrl(item);
    case "WFS":
      return addWFSUrl(item);
    case "WMTS":
      return addWMTSUrl(item);
    case "OGCFeatureServer":
      return addOGCFeatureService(item);
    default:
      return addUrl(item);
  }
};
const getTypeKeywords = (item) => {
  var _a;
  const { type, agsType } = item;
  const generatedTypes = ((_a = _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_13__.a[agsType !== null && agsType !== void 0 ? agsType : type]) === null || _a === void 0 ? void 0 : _a.typeKeywords) || [];
  return [...generatedTypes, ...(item.typeKeywords || [])];
};
const addUrl = async (item) => {
  const { customParameters: customParams, agsType } = item;
  const { type } = (0,_file_f36193e9_js__WEBPACK_IMPORTED_MODULE_12__.g)(item.type);
  const content = Object.assign(Object.assign({}, item), { typeKeywords: getTypeKeywords(item), type });
  if ((customParams === null || customParams === void 0 ? void 0 : customParams.length) >= 1 && !!agsType) {
    const { customParameters } = formatCustomParameters(customParams);
    content.text = JSON.stringify({ customParameters });
  }
  return (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.c)(content);
};
// --- Other
async function getItemStatus(id, options = {}, statusUrl) {
  var _a;
  try {
    const user = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.user;
    const url = statusUrl !== null && statusUrl !== void 0 ? statusUrl : `${user.userContentUrl}/items/${id}/status`;
    const requestParams = (options === null || options === void 0 ? void 0 : options.jobId) ? { jobId: options.jobId } : {};
    // Need to await here so it will catch related error below
    const jobStatus = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.p)(url, { requestParams });
    return jobStatus;
  }
  catch (error) {
    if (!((_a = error.statusMessage) === null || _a === void 0 ? void 0 : _a.includes("Item status doesn't exist")) || !options.success) {
      console.error(error);
      throw error;
    }
    return { itemId: id, status: "status-not-found", lastUpdatedTime: 0, submissionTime: 0, recordCount: 0 };
  }
}
async function addResource(owner, id, folder, params) {
  const { config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const folderPath = folder.id && folder.id !== "/" && folder.id !== owner ? `/${folder.id}` : "";
  const url = `${config.restBaseUrl}content/users/${owner}${folderPath}/items/${id}/addResources`;
  return (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, params, {}, "post");
}
async function addCloudProviderResource(resource, id) {
  const folder = _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.folder;
  const { user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  // add cloud info to resource
  return addResource(user.username, id, folder, {
    fileName: "cloudProvider.json",
    text: JSON.stringify(resource),
    access: "private"
  });
}

async function getAGSThumbnail(item) {
  const { url, thumbnailURL, serviceInfo, extent } = item;
  if (thumbnailURL) {
    return thumbnailURL;
  }
  if (!["Map Service", "Feature Service", "Image Service"].includes(item.type)) {
    return null;
  }
  if (["Map Service", "Image Service"].includes(item.type) || url.indexOf("MapServer") !== -1) {
    const extentString = extentToString(extent);
    // make thumbnail in service spatial reference
    const exportCallOpts = { serviceUrl: url, extent: extentString, size: "800,532", format: "image", serviceInfo };
    return extent ? buildExportCall(exportCallOpts) : null;
  }
  const { result, error } = await buildThumbnailURLFromFSItem(item);
  if (error) {
    // Ideally the thumbnail generation process shouldn't stop the other process in case of failing
    console.error("Error generating thumbnail", error);
    return "";
  }
  return result;
}
function buildExportCall(exportCallOpts) {
  var _a;
  let { visibleLayers, serviceUrl, serviceInfo, size, extent, bboxSR, imageSR, format } = exportCallOpts;
  let position;
  if (!serviceInfo) {
    return "";
  }
  let isMap = serviceUrl.indexOf("/MapServer") > -1;
  if (!visibleLayers && isMap) {
    let layerId;
    // it's just one layer of a map service
    position = serviceUrl.indexOf("/MapServer");
    const queryPosition = serviceUrl.indexOf("?");
    if (queryPosition > -1) {
      layerId = serviceUrl.substring(position + 11, queryPosition);
      serviceUrl = serviceUrl.substring(0, position + 10) + serviceUrl.substring(queryPosition);
      visibleLayers = layerId;
    }
    else {
      layerId = serviceUrl.substring(position + 11);
      serviceUrl = serviceUrl.substring(0, position + 10);
      visibleLayers = layerId;
    }
  }
  if (!isMap && serviceInfo) {
    // if we have a proxy service ending in /service
    if (serviceInfo.capabilities) {
      isMap = serviceInfo.capabilities.toLowerCase().indexOf("map") > -1;
    }
    else {
      // older servers
      isMap = serviceInfo.supportedImageFormatTypes;
    }
  }
  let url = serviceUrl;
  position = url.indexOf("?");
  if (position === -1) {
    if (isMap) {
      url += "/export?";
    }
    else if (typeof serviceInfo.currentVersion !== "undefined" && serviceInfo.currentVersion >= 10.1) {
      url += "/info/thumbnail";
      return url;
    }
    else {
      url += "/exportImage?";
    }
  }
  else {
    if (isMap) {
      url = `${url.substring(0, position)}/export${url.substring(position, url.length)}&`;
    }
    else if (typeof serviceInfo.currentVersion !== "undefined" && serviceInfo.currentVersion >= 10.1) {
      url = `${url.substring(0, position)}/info/thumbnail${url.substring(position, url.length)}`;
      return url;
    }
    else {
      url = `${url.substring(0, position)}/exportImage${url.substring(position, url.length)}&`;
    }
  }
  url += `size=${size}&bbox=${extent}`;
  if ((bboxSR === null || bboxSR === void 0 ? void 0 : bboxSR.length) > 0) {
    url += `&bboxSR=${bboxSR}`;
  }
  if ((imageSR === null || imageSR === void 0 ? void 0 : imageSR.length) > 0) {
    url += `&imageSR=${imageSR}`;
  }
  if (isMap && ((_a = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.supportedImageFormatTypes) === null || _a === void 0 ? void 0 : _a.indexOf("PNG32")) > -1) {
    url += `&format=png32&f=${format}`;
  }
  else if (isMap) {
    url += `&format=png24&f=${format}`;
  }
  else {
    url += `&format=jpgpng&f=${format}`;
  }
  if (isMap) {
    if ((visibleLayers === null || visibleLayers === void 0 ? void 0 : visibleLayers.length) > 0) {
      url += `&layers=show:${visibleLayers}`;
    }
  }
  else {
    url += "&interpolation=RSP_NearestNeighbor&bandIds=null";
  }
  return url;
}
async function buildThumbnailForFSItem4x(id, portal) {
  var _a, _b, _c;
  const [Map, MapView, FeatureLayer, Basemap, print, PrintTemplate, PrintParameters, scaleRange] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    "esri/Map",
    "esri/views/MapView",
    "esri/layers/FeatureLayer",
    "esri/Basemap",
    "esri/rest/print",
    "esri/rest/support/PrintTemplate",
    "esri/rest/support/PrintParameters",
    "esri/smartMapping/heuristics/scaleRange"
  ]);
  try {
    const container = createHiddenMapDiv(800, 532);
    const knownBasemapId = portal.defaultBasemap.id.includes("basemap");
    const layer = new FeatureLayer({
      portalItem: {
        id,
        portal
      }
    });
    const map = new Map({
      basemap: knownBasemapId
        ? "topo-vector"
        : new Basemap({
          portalItem: {
            id: portal.defaultBasemap.id,
            portal
          }
        })
    });
    const view = new MapView({
      map,
      container
    });
    await map.watch("loaded");
    let minScale = 0;
    let maxScale = 0;
    if (!knownBasemapId) {
      ({ minScale, maxScale } = await scaleRange({
        layer,
        view
      }));
    }
    const extentResponse = await layer.queryExtent();
    view.goTo(extentResponse.extent);
    layer.minScale = minScale;
    layer.maxScale = maxScale;
    view.map.add(layer);
    view.scale = maxScale;
    await (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.t)(2000);
    // url to the print service
    const url = (_c = (_b = (_a = portal.helperServices) === null || _a === void 0 ? void 0 : _a.printTask) === null || _b === void 0 ? void 0 : _b.url) !== null && _c !== void 0 ? _c : "https://utility.arcgisonline.com/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task";
    const template = new PrintTemplate({
      format: "png32",
      exportOptions: {
        dpi: 96,
        width: 800,
        height: 532
      },
      layout: "map-only",
      showLabels: false,
      attributionVisible: false
    });
    const params = new PrintParameters({
      view: view,
      template
    });
    const printResult = await print.execute(url, params);
    destroyHiddenMapDiv();
    return printResult.url;
  }
  catch (error) {
    destroyHiddenMapDiv();
    return null;
  }
}
async function buildThumbnailURLFromFSItem(item) {
  var _a;
  const { config, portal, api } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  if (api === 4) {
    return { result: await buildThumbnailForFSItem4x(item.id, portal) };
  }
  const [esriId, FeatureLayer, Extent] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    "esri/IdentityManager",
    "esri/layers/FeatureLayer",
    "esri/geometry/Extent"
  ]);
  const { serviceInfo, proxyUrl } = item;
  // from item properties page or viewer 'save layer' (not for feature collection)
  // newExtent and layers overwrites for the item are optional
  // 1. get item /data to get overwrites
  // 2. make service info request to get layers
  // 3. build webMap object
  // 4. call Geoprocessor task
  const webMap = {
    baseMap: config.defaultBasemap || config.self.defaultBasemap,
    operationalLayers: []
  };
  webMap.baseMap.title = "basemap";
  const len = webMap.baseMap.baseMapLayers.length;
  for (let i = 0; i < len; i++) {
    let layer = webMap.baseMap.baseMapLayers[i];
    if (!layer.isReference) {
      // we need only one basemap layer and we hide it
      if ((config.allSSL || location.protocol == "https:") &&
        ((0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.a)(layer.url) || (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.b)(layer.url))) {
        layer.url = layer.url.replace("http:", "https:");
      }
      layer.visibility = false;
      webMap.baseMap.baseMapLayers = [layer];
      break;
    }
  }
  if (!serviceInfo) {
    return { result: "" };
  }
  const layers = serviceInfo.layers || [];
  const itemUrl = proxyUrl || item.url;
  const urlObject = await (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.c)(itemUrl);
  const credentials = esriId.findCredential(urlObject.path);
  layers.reverse().forEach(async (layer) => {
    const operationalLayer = {
      url: `${itemUrl}/${layer.id}${credentials ? `?token=${credentials.token}` : ""}`,
      id: `${item.id || Math.random()}_${layer.id}`,
      opacity: 1,
      title: `${item.title || "title"}_${layer.id}`,
      visibility: true,
      layerDefinition: undefined
    };
    let found = false;
    layers.forEach((lyr) => {
      if (lyr.id === layer.id && !found) {
        found = true;
        operationalLayer.layerDefinition = lyr.layerDefinition;
      }
    });
    if (!layers.length || (layers.length && found)) {
      webMap.operationalLayers.push(operationalLayer);
    }
  });
  let extent = [
    [-180, -90],
    [180, 90]
  ];
  if (typeof item.extent === "string") {
    const e = item.extent.split(",");
    extent = [
      [parseFloat(e[0]), parseFloat(e[1])],
      [parseFloat(e[2]), parseFloat(e[3])]
    ];
  }
  else if (((_a = item.extent) === null || _a === void 0 ? void 0 : _a.length) > 0) {
    extent = item.extent;
  }
  if (webMap.operationalLayers.length === 1) {
    let featureLayer = new FeatureLayer(webMap.operationalLayers[0].url);
    return new Promise((resolve) => {
      featureLayer.on("load", async (featLayer) => {
        if (featLayer === null || featLayer === void 0 ? void 0 : featLayer.layer) {
          featureLayer = featLayer.layer;
        }
        const extentAsList = await getExtentWithFeatures(featureLayer, extent);
        try {
          const thumbnailUrl = await buildThumbnailURLFromWebMap(webMap, extentAsList);
          resolve({ result: thumbnailUrl });
        }
        catch (error) {
          resolve({ error: { code: "unhandledError", message: error } });
        }
      });
    });
  }
  else {
    // check if at least one layer is in scale
    const extentAsList = item.extent;
    const ext = new Extent(extentAsList[0][0], extentAsList[0][1], extentAsList[1][0], extentAsList[1][1]);
    const thumbnailScale = getScaleForExtent(ext, 200);
    const opLayers = [];
    const featureLayers = [];
    const promises = [];
    webMap.operationalLayers.forEach((opLayer) => {
      const featureLayer = new FeatureLayer(opLayer.url);
      const promise = new Promise((resolve) => {
        featureLayer.on("load", (layer) => {
          opLayers.push(opLayer);
          featureLayers.push(layer);
          if (layer.minScale <= thumbnailScale && layer.maxScale > thumbnailScale) {
            resolve(true);
          }
          else {
            resolve(false);
          }
        });
        featureLayer.on("error", () => {
          resolve(false);
        });
      });
      promises.push(promise);
    });
    const responses = await Promise.all(promises);
    // clean out layers that didn't load from the webmap
    webMap.operationalLayers = opLayers;
    const found = responses.filter((res) => res).length > 0;
    try {
      if (!found && featureLayers.length > 0) {
        // saving thumbnail with item extent will be blank
        // zoom to features instead; use first working layer
        const extentWithFeatures = await getExtentWithFeatures(featureLayers[0], extentAsList);
        return { result: await buildThumbnailURLFromWebMap(webMap, extentWithFeatures) };
      }
      else {
        return { result: await buildThumbnailURLFromWebMap(webMap, extentAsList) };
      }
    }
    catch (error) {
      return { error: { code: "unhandledError", message: error } };
    }
  }
}

async function isFederatedWithWebTierAuth(itemInfo, checkUrlResponse, checkAuth) {
  var _a, _b;
  //If a service is federated with another portal, and is secured with web tier authentication
  //it will still report back that its secured with token security ("499"), even though it uses web tier authentication ("401")
  //it does this because its federated with another portal, unfortunately.  If secured with web tier, there
  //isn't a reason to store the credentials so lets hide that box, but the only way to check that is to call
  //checkUrl with the generateToken endpoint, and see if that returns 401
  //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/3791
  if ((checkUrlResponse === null || checkUrlResponse === void 0 ? void 0 : checkUrlResponse.httpStatusCode) === 499) {
    const [esriId] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
      _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager"
    ]);
    const { url, password, username } = itemInfo;
    const tokenServiceUrl = await esriId._getTokenSvcUrl(url);
    let generateTokenUrl = (_a = tokenServiceUrl.authInfo) === null || _a === void 0 ? void 0 : _a.tokenServicesUrl;
    if (generateTokenUrl) {
      // Add a trailing slash if it doesn't exist
      if (generateTokenUrl[generateTokenUrl.length - 1] !== "/") {
        generateTokenUrl += "/";
      }
      try {
        const result = await getIsSecured({ password, username }, generateTokenUrl !== null && generateTokenUrl !== void 0 ? generateTokenUrl : "", (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.g)(), checkAuth);
        return (result === null || result === void 0 ? void 0 : result.secured) && (result === null || result === void 0 ? void 0 : result.httpStatusCode) === 401;
      }
      catch (error) {
        return ((_b = error === null || error === void 0 ? void 0 : error.message) === null || _b === void 0 ? void 0 : _b.indexOf("Http StatusCode: -1")) > -1 ? -1 : false;
      }
    }
  }
  return false;
}
function parseAGSTitle(url) {
  return (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.p)((0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.d)(url)).serverName;
}
function parseAGSType(url) {
  const formattedUrl = (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.d)(url);
  const serverTypeAndLayerIndex = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.p)(url);
  const containsAGS = formattedUrl.replace(_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.v, "").match(_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.r);
  let agsType = serverTypeAndLayerIndex === null || serverTypeAndLayerIndex === void 0 ? void 0 : serverTypeAndLayerIndex.serverType;
  let soeType = serverTypeAndLayerIndex === null || serverTypeAndLayerIndex === void 0 ? void 0 : serverTypeAndLayerIndex.index;
  const caseCorrected = {
    mapserver: "MapServer",
    geocodeserver: "GeocodeServer",
    gpserver: "GPServer",
    geometryserver: "GeometryServer",
    geoenrichmentserver: "GeoenrichmentServer",
    imageserver: "ImageServer",
    naserver: "NAServer",
    featureserver: "FeatureServer",
    geodataserver: "GeoDataServer",
    globeserver: "GlobeServer",
    wmserver: "WMServer",
    sceneserver: "SceneServer",
    vectortileserver: "VectorTileServer",
    streamserver: "StreamServer",
    videoserver: "VideoServer"
  };
  if (agsType && caseCorrected[agsType.toLowerCase()]) {
    agsType = caseCorrected[agsType.toLowerCase()];
  }
  // TODO: Fix this mapping earlier, maybe remove this whole function? The original url parser might may be able to handle this up front
  if (agsType === "ags" || (!agsType && containsAGS)) {
    agsType = "MapServer";
  }
  if (agsType === "MapServer" && soeType !== null) {
    // Layer within a mapserver - CR260845
    return "FeatureServer";
  }
  return agsType;
}
async function getSecuredAGSServiceInfo(item) {
  var _a;
  // TODO: Pass in what we need from configState as args
  const { config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const { checkAuth, storeAuth, username, password } = item;
  item.title = parseAGSTitle(item.url);
  const agsType = parseAGSType(item.url);
  if (!agsType || (agsType === "SceneServer" && !config.sceneViewerEnabled)) {
    return { error: { code: "unknownAGSType" } };
  }
  let itemType = (_a = _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_13__.a[agsType]) === null || _a === void 0 ? void 0 : _a.type;
  if (!itemType) {
    console.warn(`Unknown AGS Type ${agsType}`);
    // TODO: Can we reach this point? And if so will an item be created?
  }
  item.type = itemType;
  item.agsType = agsType;
  try {
    if (!_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.user) {
      return { result: await getAGSServiceInfo(item) };
    }
    const result = await getIsSecured({ username, password }, item.url, (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.g)(_config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.portal), checkAuth);
    const checkUrlAllowStoredAuth = result === null || result === void 0 ? void 0 : result.allowStoredAuth;
    if (checkUrlAllowStoredAuth === false) {
      // This means /checkUrl fails for some reason
      item.allowStoredAuth = false;
    }
    if (result.secured) {
      item.isSecured = Object.assign({}, result);
      item.allowStoredAuth = false;
      //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/3791
      const isFederatedWithWebTier = await isFederatedWithWebTierAuth({ username: item.username, password: item.password, url: item.url }, result, checkAuth);
      if (!isFederatedWithWebTier && result.httpStatusCode !== 401) {
        item.isSecured = Object.assign(Object.assign({}, result), { isFederatedWithWebTierAuth: isFederatedWithWebTier });
        // Only allow to toggle auth if `/checkUrl` determine the URL can be reached
        if (checkUrlAllowStoredAuth !== false) {
          item.allowStoredAuth = true;
        }
        if (result.isOverride) {
          // #29916, arcgis-portal-services-design #153 - Geoenrichment servers are able to have a proxy created without
          // prompting for credentials. In this case don't disallow the storeAuth option and pass createAsServiceProxy
          // through to the /addItem request
          if (agsType === "GeoenrichmentServer" && !item.storeAuth) {
            item.createAsServiceProxy = true;
          }
          else {
            item.storeAuth = true;
          }
        }
        if (checkAuth && !storeAuth) {
          return { result: await getAGSServiceInfo(item) };
        }
        return { result: item };
      }
      else if (isFederatedWithWebTier === -1) {
        //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/1900
        //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/4765
        // -1 means the proxy does not trust the ssl cert for the isFederatedWithWebTierAuth request from above
        const updatedItem = Object.assign(Object.assign({}, item), { isSecured: null, checkUrlError: true, storeAuth: false });
        return { result: await getAGSServiceInfo(updatedItem) };
      }
      else {
        const updatedItem = Object.assign(Object.assign({}, item), { isSecured: { httpStatusCode: 401, isFederatedWithWebTierAuth: isFederatedWithWebTier } });
        return { result: await getAGSServiceInfo(updatedItem) };
      }
    }
    else {
      return { result: await getAGSServiceInfo(item) };
    }
  }
  catch (error) {
    // If the user aborted the flow, don't try to fetch again
    // Also prevent re-request if it's known that an api key is missing (code "unauthorized")
    if (isAppComponentError(error)) {
      const code = error.code;
      if (code === "flowAborted" || code === "unauthorized" || code === "invalidSpatialRef") {
        return { error };
      }
    }
    try {
      //https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/1900
      const updatedItem = Object.assign(Object.assign({}, item), { isSecured: item.isSecured || null, checkUrlError: error, storeAuth: false });
      return { result: await getAGSServiceInfo(updatedItem) };
    }
    catch (error) {
      if (isAppComponentError(error)) {
        return { error };
      }
      return {
        error: { code: "unhandledError", message: JSON.stringify(error) }
      };
    }
  }
}
const MAX_RETRY = 3; // TODO: Determine a better number
async function getAGSServiceInfo(item, url = item.url, retry = 0) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const [esriId] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager"
  ]);
  const { username, password, checkAuth, agsType } = item;
  const { tags: itemTags = [] } = _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i || {};
  const secureService = [499, 498];
  const serviceUrl = (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.d)(url);
  if (!item.isSecured ||
    (((_a = item.isSecured) === null || _a === void 0 ? void 0 : _a.httpStatusCode) !== 401 && checkAuth) ||
    (((_b = item.checkUrlError) === null || _b === void 0 ? void 0 : _b.message) && !!item.isSecured && !!(0,_ags_68d4ae20_js__WEBPACK_IMPORTED_MODULE_10__.i)(item.type))) {
    try {
      const serviceInfo = await getServiceInfo({ username, password }, serviceUrl, {
        isSecure: item.isSecured,
        isVideoService: item.type === "Video Service",
        checkAuth
      });
      // Image service with LERC format tiles, create new elevation service
      if (item.type === "Image Service" && serviceInfo.tileInfo) {
        if (serviceInfo.tileInfo.format === "LERC" || ((_c = serviceInfo.cacheType) === null || _c === void 0 ? void 0 : _c.toLowerCase()) === "elevation") {
          item.agsType = "ElevationServer";
        }
        else if (((_d = serviceInfo.cacheType) === null || _d === void 0 ? void 0 : _d.toLowerCase()) === "raster") {
          item.agsType = "TiledImageServer";
          if (isHybridImageService(url, serviceInfo) && _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.hybridImageServiceSetting !== "TiledImageServer") {
            item.agsType = "ImageServer";
          }
        }
      }
      const credential = serviceInfo.credential || esriId.findCredential(url);
      const documentInfo = serviceInfo.documentInfo;
      const keywords = ((documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Keywords) || "").split(",");
      const serviceTitle = (_e = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Title) !== null && _e !== void 0 ? _e : serviceInfo.name;
      item.tags = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.b)([...keywords, ...itemTags]).filter((tag) => tag);
      // Keep parsed title if service is nullish or an empty string
      if ((serviceTitle === null || serviceTitle === void 0 ? void 0 : serviceTitle.length) > 0) {
        item.title = serviceTitle;
      }
      item.description = (_g = (_f = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Comments) !== null && _f !== void 0 ? _f : serviceInfo.description) !== null && _g !== void 0 ? _g : "";
      item.snippet = (_j = (_h = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Subject) !== null && _h !== void 0 ? _h : serviceInfo.serviceDescription) !== null && _j !== void 0 ? _j : "";
      item = Object.assign(Object.assign({}, item), { thumbnailToken: (credential === null || credential === void 0 ? void 0 : credential.token) || null, extent: item.extent || serviceInfo.fullExtent || serviceInfo.extent, serviceInfo: Object.assign(Object.assign({}, serviceInfo), { isSecure: checkAuth ? true : false, userInfo: { username, password } }) });
      return Object.assign({}, item);
    }
    catch (error) {
      if (((_k = error === null || error === void 0 ? void 0 : error.message) === null || _k === void 0 ? void 0 : _k.toLowerCase().includes("aborted")) || (error === null || error === void 0 ? void 0 : error.message) === "Error: json") {
        // user cancelled when prompted for login
        throw {
          code: "flowAborted",
          message: JSON.stringify(error.message.message)
        };
      }
      // Unfortunately the idManager throws an error AND calls back on the setProtocolErrorHandler when
      // an ago service needs to be accessed over ssl,  so set this flag to distunguish a typical error
      // vs the setProtocolError
      if (secureService.includes((_l = error === null || error === void 0 ? void 0 : error.code) !== null && _l !== void 0 ? _l : (_m = error === null || error === void 0 ? void 0 : error.details) === null || _m === void 0 ? void 0 : _m.httpStatus)) {
        if (item.allowStoredAuth !== false) {
          item.allowStoredAuth = !item.checkUrlError;
        }
        return Object.assign(Object.assign({}, item), { isSecured: { secured: true }, serviceInfo: { isSecure: true }, 
          // If we already determine that we can't store auth via `checkUrl`, just set it to false
          allowStoredAuth: item.allowStoredAuth === false ? false : _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.allowStoredAuth });
      }
      else if ((error === null || error === void 0 ? void 0 : error.code) === 403) {
        item.serviceInfo = { isSecure: true };
        item.isSecured = { secured: true };
        throw {
          code: "forbiddenCredential",
          message: JSON.stringify(error)
        };
      }
      else if (error && ((_o = item.checkUrlError) === null || _o === void 0 ? void 0 : _o.message)) {
        // TODO: Handle error here using our standard form
        if ((_r = (_q = (_p = item.checkUrlError) === null || _p === void 0 ? void 0 : _p.message) === null || _q === void 0 ? void 0 : _q.includes) === null || _r === void 0 ? void 0 : _r.call(_q, "was not found")) {
          throw {
            code: "serviceNotExist",
            message: JSON.stringify(item.checkUrlError.message)
          };
        }
        throw {
          code: "unhandledError",
          message: JSON.stringify(item.checkUrlError.message)
        };
      }
      else if ((!!agsType && agsType !== "FeatureServer") ||
        (typeof error === "string" && error.includes("not found"))) {
        throw { code: "serviceNotExist", message: JSON.stringify(error) };
      }
      else if (isBackendError(error) &&
        error.details[0] === "The input spatial reference must be either a geographic or projected coordinate system") {
        throw {
          code: "invalidSpatialRef",
          message: JSON.stringify(error)
        };
      }
      else if (retry < MAX_RETRY) {
        return getAGSServiceInfo(item, url, retry + 1);
      }
    }
  }
  else if (((_s = item.isSecured) === null || _s === void 0 ? void 0 : _s.isFederatedWithWebTierAuth) || ((_t = item.isSecured) === null || _t === void 0 ? void 0 : _t.httpStatusCode) === 401) {
    try {
      const { title } = item;
      const serviceInfo = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(item.url, {}, { addTokenManually: false });
      const documentInfo = serviceInfo.documentInfo;
      const keywords = (documentInfo.Keywords || "").split(",");
      const tags = [...(0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.b)([...keywords, ...itemTags])];
      item = Object.assign(Object.assign({}, item), { extent: serviceInfo.fullExtent || serviceInfo.extent, serviceInfo });
      return Object.assign(Object.assign({}, item), { title, tags });
    }
    catch (error) {
      if (error.status === 401) {
        throw { code: "unauthorized" };
      }
      throw { code: "serviceNotExist", message: JSON.stringify(error) };
    }
  }
}
async function addSecureAGSUrl(itemProperties) {
  const { serviceInfo, username, password, isSecured, storeAuth, type } = itemProperties;
  const { user, portal, config } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const itemType = type;
  const userInfo = { username, password };
  const { thumbnailURL } = (0,_file_f36193e9_js__WEBPACK_IMPORTED_MODULE_12__.g)(itemType);
  const item = Object.assign(Object.assign({}, itemProperties), { thumbnailURL: thumbnailURL || itemProperties.thumbnailURL });
  if (((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.isSecure) && !serviceInfo.userInfo) ||
    ((isSecured === null || isSecured === void 0 ? void 0 : isSecured.isOverride) && !userInfo) ||
    ((isSecured === null || isSecured === void 0 ? void 0 : isSecured.httpStatusCode) !== 401 && !userInfo) ||
    (storeAuth && !userInfo)) {
    throw new Error("invalidCredentials");
  }
  if (isSecured) {
    if (storeAuth) {
      if (!portal.isPortal || (portal.isPortal && (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.e)())) {
        item.serviceUsername = username;
        item.servicePassword = password;
      }
      else {
        throw new Error();
      }
      if (isSecured.httpStatusCode === 401) {
        const result = await addItem(item, config === null || config === void 0 ? void 0 : config.restBaseUrl).then(({ id }) => (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(`${user.userContentUrl}/items/${id}`, {}, {}, "post"));
        const updatedItem = Object.assign(Object.assign({}, item), { id: result.item.id, url: result.item.url, sourceUrl: result.item.sourceUrl });
        return addAGSService(updatedItem, true);
      }
      else if ((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.isSecure) && !(serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.userInfo)) {
        throw new Error("invalidCredentials");
      }
    }
  }
  return addAGSService(item);
}
async function addAGSService(itemProperties, update = false) {
  var _a, _b, _c, _d;
  const { url, serviceInfo, type, storeAuth, hybridImageServiceSetting } = itemProperties;
  let singlelayer = { StreamServer: 1, ImageServer: 1, WorkspaceServer: 1 }, serviceLayers;
  if (!serviceInfo && !storeAuth) {
    throw new Error("serviceNotExist");
  }
  if (storeAuth && !serviceInfo) {
    // For proxied secure AGS services, we'll need to delete the item after creating it to:
    // 1. remove the item to not have duplicate items with titles
    // 2. we will need to get service info again to get the correct thumbnail / service info
    // 3. We create the item here so we can get initial serviceInfo so that we can append the correct itemKeywords
    const { response, updatedProperties } = await retrieveProxyServiceInfo(itemProperties);
    await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.d)(response.id, { permanentDelete: true });
    // WebGIS/arcgis-portal-app#35615 - wait for the deleted item to be removed from the search index
    await (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.t)(3000);
    return updatedProperties;
  }
  const updatedItem = Object.assign(Object.assign({}, itemProperties), { description: (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.description) || ((_a = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.documentInfo) === null || _a === void 0 ? void 0 : _a.Comments) || "", accessInformation: (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.copyrightText) || ((_b = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.documentInfo) === null || _b === void 0 ? void 0 : _b.Credits) || "", spatialReference: getSpatialReference(itemProperties.serviceInfo, itemProperties.agsType) });
  //For icon purposes we can update the
  //typeKeywords to show different icons
  if ((type === null || type === void 0 ? void 0 : type.toLowerCase()) === "map service") {
    updatedItem.typeKeywords.push((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.singleFusedMapCache) ? "Tiled" : "Dynamic");
  }
  if ((type === "Image Service" && hybridImageServiceSetting === "TiledImageServer") ||
    isTilesOnlyImageService(url, serviceInfo)) {
    updatedItem.typeKeywords = _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_13__.a.TiledImageServer.typeKeywords;
  }
  if ((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.type) === "Table") {
    updatedItem.typeKeywords = [...updatedItem.typeKeywords, "Table", "Singlelayer"];
  }
  if (type in singlelayer) {
    updatedItem.typeKeywords.push("Singlelayer");
  }
  else if ((serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.layers) || (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.tables)) {
    if ((!serviceInfo.layers || !((_c = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.layers) === null || _c === void 0 ? void 0 : _c.length)) && (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.tables.length)) {
      //Check if "Table" was added above, dont want to add it twice
      if (updatedItem.typeKeywords.findIndex((type) => type === "Table") === -1) {
        updatedItem.typeKeywords.push("Table");
      }
      updatedItem.typeKeywords.push(serviceInfo.tables.length > 1 ? "Multilayer" : "Singlelayer");
    }
    else {
      serviceLayers = [...(serviceInfo.layers || []), ...(serviceInfo.tables || [])];
      updatedItem.typeKeywords.push(serviceLayers.length > 1 ? "Multilayer" : "Singlelayer");
    }
  }
  //For icon purposes we need to update the typeKeywords for a SceneServer added by reference
  if ((type === null || type === void 0 ? void 0 : type.toLowerCase()) === "sceneserver") {
    const { layers } = serviceInfo;
    const layerType = ((_d = layers === null || layers === void 0 ? void 0 : layers[0]) === null || _d === void 0 ? void 0 : _d.layerType) || (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.layerType);
    layerType && updatedItem.typeKeywords.push(layerType);
  }
  try {
    const { extent: wgsExtent } = await projectExtentToWGS84FromItem(Object.assign({}, updatedItem));
    const item = updatedItem;
    const itemInfo = (0,_file_f36193e9_js__WEBPACK_IMPORTED_MODULE_12__.g)(item.type);
    item.type = itemInfo.type;
    item.typeKeywords = [...(item.typeKeywords || []), ...(itemInfo.typeKeywords || [])];
    if (!storeAuth) {
      // TODO: unify extent formatting, thumbnail generation between here and updateProxyService
      const extentAsString = extentToString(item.extent);
      const e = extentAsString.split(",");
      const formattedExtent = [
        [parseFloat(e[0]), parseFloat(e[1])],
        [parseFloat(e[2]), parseFloat(e[3])]
      ];
      item.extent = formattedExtent;
      const thumbnailURL = await getAGSThumbnail(item);
      item.thumbnailURL = thumbnailURL;
      if (item.thumbnailURL && item.thumbnailToken) {
        item.thumbnailURL += `${item.thumbnailURL.indexOf("?") > -1 ? "&" : "?"}${item.thumbnailToken}`;
      }
      item.extent = extentToString(item.type === "Feature Service" ? wgsExtent : item.extent);
    }
    if (storeAuth) {
      return updateProxyService(item);
    }
    if (update) {
      return (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.e)(item.id, Object.assign(Object.assign({}, item), { url: item.sourceUrl }));
    }
    else {
      return addUrl(item);
    }
  }
  catch (error) {
    if (storeAuth) {
      throw error;
    }
    return addUrl(itemProperties);
  }
}
async function updateProxyService(itemProperties) {
  const { user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const { exportTilesAllowed } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  const createdItem = await addUrl(itemProperties);
  const requestUrl = `${user.userContentUrl}/items/${createdItem.id}`;
  const { item } = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(requestUrl, {}, {}, "post");
  const serviceInfoUrl = exportTilesAllowed ? itemProperties.url : item.url;
  const updatedItem = await getAGSServiceInfo(Object.assign(Object.assign({}, itemProperties), { type: _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.type }), serviceInfoUrl);
  const { typeKeywords, thumbnailToken, spatialReference, extent, description } = updatedItem;
  itemProperties.id = createdItem.id;
  itemProperties.proxyUrl = item.url;
  itemProperties.typeKeywords = typeKeywords;
  itemProperties.thumbnailToken = thumbnailToken;
  itemProperties.spatialReference = spatialReference;
  itemProperties.extent = extent;
  itemProperties.description = description;
  // INC1055397 - On its own, a failed thumbnail shouldn't derail the whole upload process (?)
  // TODO: If needed, throw a more specific error in the catch block
  try {
    const extentAsString = extentToString(updatedItem.extent);
    const e = extentAsString.split(",");
    const formattedExtent = [
      [parseFloat(e[0]), parseFloat(e[1])],
      [parseFloat(e[2]), parseFloat(e[3])]
    ];
    itemProperties.extent = formattedExtent;
    const thumbnailURL = await getAGSThumbnail(itemProperties);
    item.thumbnailURL = thumbnailURL;
    if (item.thumbnailURL && item.thumbnailToken) {
      item.thumbnailURL += `${item.thumbnailURL.indexOf("?") > -1 ? "&" : "?"}${item.thumbnailToken}`;
    }
  }
  catch (error) {
    console.error(error);
  }
  await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.e)(createdItem.id, { thumbnailURL: item.thumbnailURL });
  return createdItem;
}
async function retrieveProxyServiceInfo(itemProperties) {
  var _a, _b, _c, _d, _e, _f;
  const { user } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const { type, exportTilesAllowed } = itemProperties;
  const addedItem = await addUrl(itemProperties);
  const { id } = addedItem;
  const url = `${user.userContentUrl}/items/${id}`;
  const { item } = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, {}, {}, "post");
  // For vectorTile services where the root url is not secured, but exportTilesAllowed = true, may have the "exporTiles" endpoint secured. So when requesting service info we should use the entered url, not the url generated from the proxied item generation
  const serviceInfoUrl = exportTilesAllowed ? itemProperties.url : item.url;
  const updatedItem = (await getAGSServiceInfo(Object.assign(Object.assign({}, itemProperties), { type }), serviceInfoUrl)) || {};
  const documentInfo = (_b = (_a = updatedItem.serviceInfo) === null || _a === void 0 ? void 0 : _a.documentInfo) !== null && _b !== void 0 ? _b : {};
  const { tags, serviceUsername, servicePassword, serviceInfo, spatialReference, extent, thumbnailToken } = updatedItem;
  let storeUpdates = {};
  storeUpdates.title = (_c = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Title) !== null && _c !== void 0 ? _c : "";
  storeUpdates.description = (_d = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.description) !== null && _d !== void 0 ? _d : "";
  storeUpdates.snippet = (_f = (_e = documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.Subject) !== null && _e !== void 0 ? _e : documentInfo === null || documentInfo === void 0 ? void 0 : documentInfo.serviceDescription) !== null && _f !== void 0 ? _f : "";
  storeUpdates.tags = tags;
  storeUpdates.proxyUrl = item.url;
  storeUpdates.serviceUsername = serviceUsername;
  storeUpdates.servicePassword = servicePassword;
  storeUpdates.serviceInfo = serviceInfo;
  storeUpdates.spatialReference = spatialReference;
  storeUpdates.extent = extent;
  storeUpdates.thumbnailToken = thumbnailToken;
  return { response: addedItem, updatedProperties: storeUpdates };
}

const overrideUrls = [
  "geocode.arcgis.com",
  "geocodedev.arcgis.com",
  "geocodeqa.arcgis.com",
  "route.arcgis.com",
  "routedev.arcgis.com",
  "routeqa.arcgis.com",
  "geoenrich.arcgis.com",
  "geoenrichqa.arcgis.com",
  "geoenrichddev.arcgis.com"
];
async function getIsSecured(userInfo, serviceUrl, restBaseUrl, checkAuth) {
  // the /checkURL call will respond whether a service needs authentication or not.
  const url = serviceUrl.split("?")[0];
  const securedURL = `${restBaseUrl}portals/checkurl`;
  const isOverrideUrl = overrideUrls.some((url) => serviceUrl.indexOf(url) !== -1);
  if (isOverrideUrl) {
    return { secured: true, isOverride: true };
  }
  else {
    const isVectorTileService = !isOverrideUrl && serviceUrl.indexOf("/VectorTileServer") > -1;
    const requestUrl = `${securedURL}?url=${encodeURIComponent(`${addParameters(`${url}?f=json`)}`)}`;
    try {
      const result = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(requestUrl, {}, { addTokenManually: false });
      const { httpStatusCode } = result;
      if (result.secured) {
        if (httpStatusCode === 403) {
          //See https://devtopia/WebGIS/arcgis-portal-app/issues/51 403 considered not-secure
          result.secured = false;
        }
        else if (httpStatusCode === 401) {
          // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/35981 web tier auth doesn't allow storing credentials
          result.allowStoredAuth = false;
        }
      }
      else if (isVectorTileService) {
        // For vectorTile services where the root url is not secured, but exportTilesAllowed = true, may have the "exporTiles" endpoint secured,
        // we need to check that here, if it is secured then we need to prompt for credentials https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/19510
        const serviceInfo = await getServiceInfo({ username: userInfo.username, password: userInfo.password }, serviceUrl, { isVideoService: false, checkAuth });
        _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.exportTilesAllowed = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.exportTilesAllowed;
        if (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.exportTilesAllowed) {
          return getIsSecured(userInfo, `${serviceUrl}/exportTiles`, restBaseUrl, checkAuth);
        }
      }
      return Object.assign(Object.assign({}, result), { isOverride: false });
    }
    catch (error) {
      const { message, code } = error;
      if (message === "Error checking resource") {
        // Internal service URL detected
        // checkUrl shouldn't be handling this --- Check with Chris Whitmore for detail
        return {
          secured: false,
          url: serviceUrl,
          httpResponse: "",
          httpStatusCode: code,
          httpStatusMessage: message,
          isOverride: false,
          allowStoredAuth: false // This is the key point, we just want to hide the toggle
        };
      }
      return {
        allowStoredAuth: false,
        url: serviceUrl,
        httpResponse: "",
        httpStatusCode: code,
        httpStatusMessage: message,
        isOverride: false
      };
    }
  }
}
function isEsriHostedService(url) {
  // esri hosted service: https://dev0011211.esri.com/server/rest/services/Hosted/California/FeatureServer
  return url.indexOf(".esri.com/server/rest/services") > -1 ? true : false;
}
function isHybridImageService(url, serviceInfo) {
  var _a;
  return (url.toLowerCase().indexOf("/imageserver") > -1 &&
    (serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.cacheType) === "Raster" &&
    ((_a = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.capabilities) === null || _a === void 0 ? void 0 : _a.toLowerCase().indexOf("tilesonly")) === -1);
}
function isTilesOnlyImageService(url, serviceInfo) {
  var _a, _b;
  return ((_a = url.toLowerCase()) === null || _a === void 0 ? void 0 : _a.includes("/imageserver")) && ((_b = serviceInfo === null || serviceInfo === void 0 ? void 0 : serviceInfo.capabilities) === null || _b === void 0 ? void 0 : _b.toLowerCase().includes("tilesonly"));
}
async function getServiceInfo(userInfo, svcUrl, options) {
  const config = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.config;
  const [esriId] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager"
  ]);
  const { forceAddToken, isSecure, checkAuth } = options;
  const { username, password } = userInfo;
  const method = "auto";
  const isHosted = (0,_url_f3b82cc7_js__WEBPACK_IMPORTED_MODULE_11__.a)(svcUrl);
  const isESRI = isEsriHostedService(svcUrl);
  const hostedService = isHosted || isESRI;
  const isOverrideUrl = overrideUrls.some((url) => svcUrl.indexOf(url) !== -1);
  const requestOptions = {
    useProxy: false,
    timeout: config.isMultiTenant === false ? 60000 : 5000,
    addSSL: hostedService,
    addTokenManually: (isSecure && hostedService && !!config.isMultiTenant) || forceAddToken || false,
    disableIdentityLookup: null
  };
  if (checkAuth) {
    svcUrl = svcUrl.split("?")[0];
    if (isOverrideUrl) {
      await signIn(svcUrl, { username, password });
      return serviceInfoRequest(svcUrl, requestOptions, method);
    }
    else {
      // Video Service URL doesn't accept POST method
      const result = await serviceInfoRequest(svcUrl, requestOptions, method);
      result.credential = esriId.findCredential(svcUrl);
      if (result.credential) {
        esriId.registerToken({
          server: svcUrl,
          token: result.credential.token,
          userId: result.credential.userId,
          expires: result.credential.expires,
          ssl: result.credential.ssl
        });
      }
      return result;
    }
  }
  else {
    // `disableIdentityLookup` will override the Id manager in ESRIRequest so that it doesnt render the auth window - which has been a pain point for certain urls - if you have an issue with authentication and the ID manager check here first.
    requestOptions.disableIdentityLookup = true;
    return await serviceInfoRequest(svcUrl, requestOptions, method);
  }
}
async function signIn(svcUrl, userInfo) {
  const [esriId, Credential] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager",
    "esri/Credential"
  ]);
  if (userInfo.username && userInfo.password) {
    const serverInfo = await findServerInfo(svcUrl);
    if (esriId._checkProtocol(svcUrl, serverInfo, (error) => console.error(error))) {
      try {
        const response = await esriId.generateToken(serverInfo, userInfo);
        const expires = response.expires ? Number(response.expires) : null;
        const ssl = !!response.ssl;
        const cred = new Credential({
          userId: userInfo.username,
          server: serverInfo.server,
          token: response.token,
          expires,
          ssl,
          validity: serverInfo.shortLivedTokenValidity,
          resources: [svcUrl],
          scope: "server"
        });
        if (esriId.credentials.indexOf(cred) === -1) {
          esriId.credentials.push(cred);
        }
        return userInfo;
      }
      catch (error) {
        error.code = 403;
        throw error;
      }
    }
    else {
      return null;
    }
  }
}
async function findServerInfo(serviceUrl) {
  const [esriId, ServerInfo] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_9__.l)([
    _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.api === 3 ? "esri/IdentityManager" : "esri/identity/IdentityManager",
    "esri/ServerInfo"
  ]);
  let serverInfo = await esriId.findServerInfo(serviceUrl);
  if (!serverInfo) {
    serverInfo = new ServerInfo();
    serverInfo.server = await esriId._getOrigin(serviceUrl);
    const response = await esriId._getTokenSvcUrl(serviceUrl);
    const { authInfo, tokenServiceUrl, currentVersion } = response;
    serverInfo.tokenServiceUrl = (authInfo === null || authInfo === void 0 ? void 0 : authInfo.tokenServicesUrl) || (authInfo === null || authInfo === void 0 ? void 0 : authInfo.tokenServiceUrl) || tokenServiceUrl;
    serverInfo.currentVersion = currentVersion;
    serverInfo.hasServer = true;
    esriId.registerServers([serverInfo]);
    return serverInfo;
  }
  else {
    return serverInfo;
  }
}
async function serviceInfoRequest(serviceUrl, options, method = "post") {
  try {
    return await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(addParameters(serviceUrl), {}, Object.assign({}, options), method);
  }
  catch (error) {
    throw error;
  }
}
async function getUrlServiceInfo(item) {
  var _a, _b;
  let urlServiceInfo = {};
  if ((0,_ags_68d4ae20_js__WEBPACK_IMPORTED_MODULE_10__.i)(item.type)) {
    urlServiceInfo = await getSecuredAGSServiceInfo(item);
  }
  else {
    switch (item.type) {
      case "OGCFeatureServer":
        urlServiceInfo = await getOGCFeatureLayerServiceInfo(item);
        break;
      case "WMS":
        const { result, error } = await getWMSServiceInfo(item);
        if (error) {
          urlServiceInfo.error = error;
        }
        else {
          const wmsLayers = await loadWMSLayers(result.serviceInfo);
          urlServiceInfo.result = Object.assign(Object.assign({}, result), wmsLayers);
        }
        break;
      case "WFS":
        urlServiceInfo = await getWFSServiceInfo(item);
        if (urlServiceInfo.result) {
          urlServiceInfo.result.layers = urlServiceInfo.result.serviceInfo.layers;
          urlServiceInfo.result.title = (_a = urlServiceInfo.result.serviceInfo.title) !== null && _a !== void 0 ? _a : "";
          urlServiceInfo.result.isComplex = urlServiceInfo.result.serviceInfo.isComplex === "esriGeometryComplex";
        }
        break;
      case "WMTS":
        urlServiceInfo = await getWMTSServiceInfo(item);
        if (urlServiceInfo.result) {
          urlServiceInfo.result.layers = urlServiceInfo.result.serviceInfo.layers;
          urlServiceInfo.result.title = (_b = urlServiceInfo.result.serviceInfo.title) !== null && _b !== void 0 ? _b : "";
        }
        break;
      default:
        urlServiceInfo = { result: Object.assign({}, item) };
        break;
    }
  }
  return urlServiceInfo;
}
// We need to send layer's relationship in a separate /addToDefinition call
// https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/4319
// So this function should NOT accept layers/tables with relationships
async function createService(service, options) {
  var _a, _b;
  // Spread to avoid manipulating the original content
  const copiedService = Object.assign({}, service);
  const { config, user, asyncAddToDefinition = true } = options;
  const addToDefinitionContent = {
    layers: (_a = copiedService.layers) !== null && _a !== void 0 ? _a : [],
    tables: (_b = copiedService.tables) !== null && _b !== void 0 ? _b : []
  };
  const addToDefinitionRequestContent = JSON.stringify(addToDefinitionContent);
  // Create service fails if passing layers, tables
  delete copiedService.layers;
  delete copiedService.tables;
  delete copiedService.initialExtent;
  delete copiedService.fullExtent;
  delete copiedService._ssl;
  const createServiceContent = { createParameters: JSON.stringify(copiedService), targetType: "featureService" };
  const url = `${config.restBaseUrl}content/users/${user.username}/createService`;
  const createServiceResponse = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, createServiceContent, {}, "post");
  try {
    await addToDefinition(addToDefinitionRequestContent, createServiceResponse.encodedServiceURL, asyncAddToDefinition);
    return { createServiceResponse, addToDefinitionResponse: addToDefinitionContent };
  }
  catch (err) {
    // if there were errors adding to the definition, clean up after ourselves and delete the service
    const deleteUrl = `${user.userContentUrl}/items/${createServiceResponse.itemId}/delete`;
    await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(deleteUrl, {}, {}, "post");
    console.error(err);
    throw err;
  }
}
async function addToDefinition(params, encodedServiceURL, async = true) {
  if (params) {
    const adminUrl = encodedServiceURL.replace("rest/services", "rest/admin/services");
    const url = `${adminUrl}/addToDefinition`;
    try {
      const result = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url, { addToDefinition: params, async }, {}, "post");
      return async ? await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.p)(result.statusURL) : result;
    }
    catch (error) {
      if (async) {
        // TODO: handle error gracefully
        // TODO: remove this once the backend shows meaningful errors on `async: true`
        // `async: true` doesn't show a meaningful error.
        //    so we do this to get the actual error for debugging purposes
        await addToDefinition(params, encodedServiceURL, false);
      }
      throw error;
    }
  }
  return null;
}
function getLayerItemData(item, portal) {
  // TODO: refactor this to use getItemData from server-item.ts
  const url = `${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.g)(portal)}content/items/${item.id}/data`;
  return (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(url);
}
/**
 * Fetch an item of type "Layer Template" used by the org to create new attachment layers
 */
async function findTemplateServiceInfo(portal) {
  var _a, _b;
  const groupResponse = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.q)({ q: 'title: "Esri Layer Templates" AND owner: "esri_en"', num: 1 });
  const group = (_a = groupResponse.results) === null || _a === void 0 ? void 0 : _a[0];
  if (!group) {
    return null;
  }
  const templateResponse = await (0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.r)(`${(0,_portal_79caaeff_js__WEBPACK_IMPORTED_MODULE_8__.g)(portal)}/search`, {
    q: `title:"Points" group:"${group.id}" AND type:"Layer Template" -type:"Attachment"`,
    num: 1
  });
  const template = (_b = templateResponse.results) === null || _b === void 0 ? void 0 : _b[0];
  return template ? getLayerItemData(template, portal) : null;
}

var __rest = ( false) || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
const defaultTemplateServiceInfo = {
  currentVersion: 10.51,
  hasVersionedData: false,
  supportsDisconnectedEditing: false,
  hasStaticData: false,
  maxRecordCount: 2000,
  supportedQueryFormats: "JSON",
  supportsVCSProjection: false,
  capabilities: "Query,Editing,Create,Update,Delete,Sync",
  description: "",
  copyrightText: "",
  allowGeometryUpdates: true,
  units: "esriMeters",
  supportsAppend: true,
  syncEnabled: false,
  supportsApplyEditsWithGlobalIds: false,
  editorTrackingInfo: {
    allowAnonymousToDelete: true,
    allowAnonymousToQuery: true,
    allowAnonymousToUpdate: true,
    allowOthersToDelete: false,
    allowOthersToQuery: true,
    allowOthersToUpdate: true,
    enableEditorTracking: false,
    enableOwnershipAccessControl: false
  },
  xssPreventionInfo: { xssPreventionEnabled: true, xssPreventionRule: "InputOnly", xssInputRule: "rejectInvalid" },
  _ssl: true
};
const addFeatureLayer = async (requestParams) => {
  var _a, _b, _c;
  const { tags, serviceInfo, typeKeywords: storeTypeKeywords, extent: storeExtent, selectedServiceInfoLayersNames, addFeatureLayerType } = requestParams;
  const { portal } = _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c;
  const isEnterprise = portal.isPortal;
  if (!serviceInfo) {
    // TODO: have a better error message here
    throw new Error("No service info found.");
  }
  try {
    // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/37255#issuecomment-3186564
    let presetServiceInfo = defaultTemplateServiceInfo;
    try {
      presetServiceInfo = (_a = (await findTemplateServiceInfo(portal))) !== null && _a !== void 0 ? _a : defaultTemplateServiceInfo;
      presetServiceInfo.capabilities = "Query,Editing,Create,Update,Delete";
      // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/38966
      presetServiceInfo.hasStaticData = false;
    }
    catch (error) {
      console.warn(`Could not fetch template ${JSON.stringify(error)}`);
    }
    const featureLayerServiceInfo = serviceInfo;
    let baseLayer = (_b = featureLayerServiceInfo.layers) !== null && _b !== void 0 ? _b : [];
    let baseTables = (_c = featureLayerServiceInfo.tables) !== null && _c !== void 0 ? _c : [];
    // * Filter selected layers
    // ! Make sure this is done before extractAndCleanRelationshipParam because the `relationship`
    // !   depends on it!
    // Build from scratch flow will automatically be filter at the end of its page
    if (addFeatureLayerType !== "build" && selectedServiceInfoLayersNames) {
      const checkSelected = (layer) => selectedServiceInfoLayersNames[layer.name];
      baseLayer = baseLayer.filter(checkSelected);
      baseTables = baseTables.filter(checkSelected);
    }
    // * Filter unique index
    // ! Sometimes the backend returns template layers with duplicate indexes,
    // !  we need to make it unique until the problem got fixed
    // ? Note that this might be a bug in the /addToDefinition backend because
    // ?  https://developers.arcgis.com/rest/services-reference/online/add-to-definition-feature-service-.htm
    // ?  example seems to allow duplicate fields
    const { layers: uniqueIndexLayers, tables: uniqueIndexTables } = extractUniqueIndex(baseLayer, baseTables);
    // * Fix ids
    //  Some template returns noncontinuous id, which is bad
    //  => we also need to fix ids that case
    const { layers, tables } = fixIds(uniqueIndexLayers, uniqueIndexTables);
    // * Form parameters
    const createParameters = Object.assign(Object.assign(Object.assign({}, presetServiceInfo), serviceInfo), { name: featureLayerServiceInfo.name || _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.title, layers,
      tables });
    // * Clean parameters
    // We need to send layer's relationship in a separate /addToDefinition call
    // https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/4319
    // There are also some case where layers depend on each other (hence the `relationship`)
    //  but some of the layers are deselected so we need to make sure the bad relationship doesn't go the backend
    // => extract and clean
    const { cleanedCreateParameters, relationshipParameters } = extractAndCleanRelationshipParam(createParameters);
    // *   the rest of the properties
    const cherryPickProps = [
      "serviceDescription",
      "hasStaticData",
      "maxRecordCount",
      "supportedQueryFormats",
      "capabilities",
      "description",
      "copyrightText",
      "spatialReference",
      "initialExtent",
      "fullExtent",
      "_ssl",
      "allowGeometryUpdates",
      "units",
      "xssPreventionInfo"
    ];
    cherryPickProps.forEach((key) => {
      const value = featureLayerServiceInfo[key];
      value != null && (cleanedCreateParameters[key] = value);
    });
    cleanedCreateParameters.name = (0,_functional_9f648bee_js__WEBPACK_IMPORTED_MODULE_6__.a)(cleanedCreateParameters.name);
    if (addFeatureLayerType === "template") {
      cleanedCreateParameters.syncEnabled = true;
      cleanedCreateParameters.capabilities = "Query,Editing,Create,Update,Delete,Sync";
    }
    // * Send requests
    const { createServiceResponse } = await createService(cleanedCreateParameters, {
      asyncAddToDefinition: !isEnterprise,
      config: _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.config,
      user: _config_eb5f7dc2_js__WEBPACK_IMPORTED_MODULE_0__.c.user
    });
    const { itemId, success } = createServiceResponse;
    const { typeKeywords: itemTypeKeywords } = (await (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.a)(itemId)).result;
    const typeKeywords = [...storeTypeKeywords, ...itemTypeKeywords];
    if (serviceInfo.captureGPS) {
      typeKeywords.push("gpsMetadataEnabled");
    }
    try {
      // number taken from the old UI's "/update" endpoint
      const extent = portal.defaultExtent || serviceInfo.fullExtent || serviceInfo.extent || storeExtent;
      const spatialReference = extent.spatialReference.wkid || extent.spatialReference.wkt || "4326";
      const extentString = extentToString(isValidWGS84Extent(extent) || spatialReference !== "4326" ? extent : await projectExtentToWGS84(extent));
      const thumbnailURL = `https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/export?size=800,532&format=png24&bboxSR=${spatialReference}&bbox=${extentString}&f=image`;
      const isInRoot = isFolderRoot(_item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.folder);
      await Promise.all([
        (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.e)(itemId, {
          title: _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.title,
          typeKeywords: typeKeywords.join(","),
          tags: (tags !== null && tags !== void 0 ? tags : _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.tags).join(","),
          extent: extentString,
          snippet: _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.snippet,
          description: _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a.description
        }),
        relationshipParameters.layers || relationshipParameters.tables
          ? addToDefinition(JSON.stringify(relationshipParameters), createServiceResponse.encodedServiceURL, !isEnterprise)
          : undefined,
        !isInRoot && (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.m)(itemId, _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.folder.id)
      ]);
      // No await, just leave it be
      (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.e)(itemId, { thumbnailURL }).catch(console.error);
      return { success, id: itemId, folder: _item_properties_e6412a9a_js__WEBPACK_IMPORTED_MODULE_3__.i.folder.id };
    }
    catch (error) {
      (0,_server_item_f12153e6_js__WEBPACK_IMPORTED_MODULE_7__.d)(itemId);
      console.error(error);
      throw error;
    }
  }
  catch (error) {
    console.error(error);
    throw error;
  }
};
const getServiceAndLayerInfo = async (serviceUrl, restBaseUrl, forceAddToken, isSecure
// TODO: refactor this to new error system
) => {
  var _a;
  const { username, password, checkAuth } = _add_item_97d577a9_js__WEBPACK_IMPORTED_MODULE_4__.a;
  try {
    const getServiceInfoWrapper = (url) => getServiceInfo({ username, password }, url, {
      forceAddToken,
      isSecure,
      // Add the time of writing, only feature layer and tile layer use this method, so they're not a video service
      isVideoService: false,
      checkAuth
    });
    const extractedServiceInfo = (0,_privileges_ccd5f37d_js__WEBPACK_IMPORTED_MODULE_2__.p)(serviceUrl);
    if (!extractedServiceInfo) {
      console.warn("invalid service info");
      return null;
    }
    const { baseServerUrl, index } = extractedServiceInfo;
    const serviceInfo = (await getServiceInfoWrapper(baseServerUrl));
    const layers = (await Promise.all((serviceInfo.layers || [])
      .filter((layer) => index === null || layer.id === index)
      .map((layer) => getServiceInfoWrapper(`${baseServerUrl}/${layer.id}`))));
    const tables = (await Promise.all((serviceInfo.tables || [])
      .filter((table) => index === null || table.id === index)
      .map((table) => getServiceInfoWrapper(`${baseServerUrl}/${table.id}`))));
    return { serviceInfo, layers, tables };
  }
  catch (error) {
    console.error(error);
    if (((_a = error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "token required") {
      try {
        const { secured } = await getIsSecured({ username, password }, serviceUrl, restBaseUrl, checkAuth);
        return await getServiceAndLayerInfo(serviceUrl, restBaseUrl, secured);
      }
      catch (error) {
        throw error;
      }
    }
    throw error;
  }
};
const extractAndCleanRelationshipParam = (createParameters) => {
  const lookupMap = {};
  const setupLookupMap = (relationship) => (lookupMap[relationship.id] = true);
  createParameters.layers.forEach(setupLookupMap);
  createParameters.tables.forEach(setupLookupMap);
  // * Extract relationship
  // ! Do not delete layer.relationships here or it will break when
  // !  the user go Back then Next in the case item creation failed
  const filterMissingRelationship = (relationship) => lookupMap[relationship.relatedTableId];
  const extractRelationship = (layer) => ({
    relationships: layer.relationships.filter(filterMissingRelationship),
    id: layer.id
  });
  const filterEmptyRelationship = (layer) => { var _a; return ((_a = layer.relationships) === null || _a === void 0 ? void 0 : _a.length) > 0; };
  const layerRelationships = createParameters.layers.map(extractRelationship).filter(filterEmptyRelationship);
  const tableRelationships = createParameters.tables.map(extractRelationship).filter(filterEmptyRelationship);
  const relationshipParameters = { layers: layerRelationships, tables: tableRelationships };
  if (relationshipParameters.layers.length === 0) {
    delete relationshipParameters.layers;
  }
  if (relationshipParameters.tables.length === 0) {
    delete relationshipParameters.tables;
  }
  // * Create new createParameters without relationship
  const layers = createParameters.layers.map((_a) => {
    var layers = __rest(_a, ["relationships"]);
    return layers;
  });
  const tables = createParameters.tables.map((_a) => {
    var tables = __rest(_a, ["relationships"]);
    return tables;
  });
  const cleanedCreateParameters = Object.assign(Object.assign({}, createParameters), { layers, tables });
  return { relationshipParameters, cleanedCreateParameters };
};
const extractUniqueIndex = (layers, tables) => {
  const getUniqueIndexLayer = (layer) => (Object.assign(Object.assign({}, layer), { indexes: (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_1__.u)(layer.indexes, (item) => item.name) }));
  return {
    layers: layers.map(getUniqueIndexLayer),
    tables: tables.map(getUniqueIndexLayer)
  };
};
/** Fix ids for both layers and relationships */
const fixIds = (layers, tables) => {
  // https://devtopia.esri.com/WebGIS/arcgis-portal-app/blob/master/src/js/arcgisonline/sharing/dijit/dialog/PublishWizard.js#L1450-L1483
  let layerInfos = (0,_feature_layer_d33ea114_js__WEBPACK_IMPORTED_MODULE_5__.c)(layers, tables);
  // * Fix layers ids
  /** Record<old id, new id> */
  const oldLayerIds = {};
  layerInfos = layerInfos.map((layerInfo, index) => {
    oldLayerIds[layerInfo.id] = index;
    const newLayer = Object.assign(Object.assign({}, layerInfo), { id: index });
    return newLayer;
  });
  // * Fix relationshipIds
  layerInfos.forEach((layerInfo) => {
    var _a;
    layerInfo.relationships = ((_a = layerInfo.relationships) !== null && _a !== void 0 ? _a : []).map((relationship) => {
      const oldRelatedId = relationship.relatedTableId;
      const newRelatedId = oldLayerIds[oldRelatedId];
      const newRelationship = Object.assign(Object.assign({}, relationship), { relatedTableId: newRelatedId });
      return newRelationship;
    });
  });
  return layerInfos.reduce((result, curInfo) => {
    curInfo.type === "Table" ? result.tables.push(curInfo) : result.layers.push(curInfo);
    return result;
  }, { layers: [], tables: [] });
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-f36193e9.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/file-f36193e9.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ sanitizeFileName),
/* harmony export */   f: () => (/* binding */ formatFileSize),
/* harmony export */   g: () => (/* binding */ getItemInfoByType),
/* harmony export */   s: () => (/* binding */ sanitizeFileInput),
/* harmony export */   v: () => (/* binding */ validateOverwriteFileName)
/* harmony export */ });
/* harmony import */ var _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./item-types-b4fe86ad.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-types-b4fe86ad.js");
/* harmony import */ var _guid_4f4176ba_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./guid-4f4176ba.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/guid-4f4176ba.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */



function sanitizeFileName(name, addGUID) {
  //TODO: add new param to spec file.
  const expression = /(?:\.([^.]+))?$/;
  const invalidTitleCharacters = /\.|-/g;
  let fileName = name.replace(/^.*(\\|\/|:)/, "");
  let extension = (fileName && expression.exec(fileName)[1] ? expression.exec(fileName)[1].toLowerCase() : "");
  let title = "";
  if (fileName.indexOf(".rft.") > -1) {
    const [name, suffix] = fileName.split(".rft.");
    extension = `rft.${suffix}`;
    title = name;
  }
  if (fileName && !title) {
    title = fileName.lastIndexOf(".") === -1 ? fileName : fileName.substring(0, fileName.lastIndexOf("."));
  }
  // Replace any invalid characters with an underscore
  title = title.replace(invalidTitleCharacters, "_");
  // Allow file upload of existing item's file name // currently used in append
  if (addGUID) {
    title = makeUniqueFileName(title);
    fileName = `${title}.${extension}`;
  }
  return { title, fileName, extension };
}
// Helper method that takes in a file & returns the cleaned up file name as is and in title form, and the detected file extension
function sanitizeFileInput(file, addGUID) {
  return sanitizeFileName(file.name, !!addGUID);
}
function makeUniqueFileName(name) {
  return `${name}_${(0,_guid_4f4176ba_js__WEBPACK_IMPORTED_MODULE_1__.g)()}`;
}
function validateOverwriteFileName(uploadedFileName, sourceFileName) {
  let fileName = uploadedFileName;
  const position = uploadedFileName.lastIndexOf("\\");
  if (position > -1) {
    fileName = fileName.substring(position + 1, fileName.length);
  }
  return fileName.replace(/\ /g, "_") === sourceFileName.replace(/\ /g, "_");
}
function getItemInfoByType(type) {
  if (_item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_0__.a[type]) {
    return _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_0__.a[type];
  }
  else {
    return _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_0__.a[Object.keys(_item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_0__.a).find((fileType) => _item_types_b4fe86ad_js__WEBPACK_IMPORTED_MODULE_0__.a[fileType].type === type)];
  }
}
function formatFileSize(size) {
  if (!size) {
    return "0 B";
  }
  const i = Math.floor(Math.log(size) / Math.log(1024));
  const adjustedSize = Math.round(size / Math.pow(1024, i));
  const unit = ["B", "KB", "MB", "GB", "TB"][i];
  return `${adjustedSize} ${unit}`;
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-3210b604.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/store-3210b604.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ workflowState)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const workflowStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  portal: null,
  user: null,
  i18n: null,
  scale: "m",
  api: 4,
  nextText: null,
  uploadProgress: 0
});
const workflowState = workflowStore.state;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZmVhdHVyLTliZWVkNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RDtBQUM0QztBQUNnQjtBQUMzQztBQUNZO0FBQ1Q7QUFDUTtBQUMyTDtBQUMvSDtBQUNuRjtBQUNkO0FBQ3VGO0FBQzFFO0FBQ087QUFDcEI7QUFDVTtBQUNGOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQixFQUFFLG9EQUFZO0FBQ3ZEO0FBQ0Esc0dBQXNHLGtCQUFrQixRQUFRLGdCQUFnQixFQUFFLDhCQUE4QixFQUFFLFlBQVk7QUFDOUw7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJLEVBQUUsVUFBVSxFQUFFLGlCQUFpQjtBQUMvQztBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQsc0JBQXNCLFVBQVUsR0FBRyxNQUFNO0FBQ3pDLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFrQjtBQUN4QixXQUFXLHNEQUFrQjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxzREFBa0IsYUFBYSxzREFBa0IscUJBQXFCLHNEQUFrQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWMsRUFBRSxLQUFLO0FBQ2pDOztBQUVzSTs7Ozs7Ozs7Ozs7Ozs7OztBQ2hFdEk7QUFDQTtBQUNBO0FBQ0E7QUFDdUQ7O0FBRXZELHNCQUFzQixxREFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9mZWF0dXJlLWxheWVyLTM4Y2RhZTg3LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2ZpbGUtZjM2MTkzZTkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc3RvcmUtMzIxMGI2MDQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNvbmZpZ1N0YXRlIH0gZnJvbSAnLi9jb25maWctZWI1ZjdkYzIuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0RlZmluZWQsIHQgYXMgdGltZW91dCwgYiBhcyB1bmlxdWUsIHUgYXMgdW5pcXVlQnkgfSBmcm9tICcuL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMnO1xuaW1wb3J0IHsgcCBhcyBwYXJzZUFHU1NlcnZlckluZm8sIHYgYXMgdmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGgsIHIgYXMgYWdzUmVnRXhwIH0gZnJvbSAnLi9wcml2aWxlZ2VzLWNjZDVmMzdkLmpzJztcbmltcG9ydCB7IGkgYXMgaXRlbVByb3BlcnRpZXNTdGF0ZSB9IGZyb20gJy4vaXRlbS1wcm9wZXJ0aWVzLWU2NDEyYTlhLmpzJztcbmltcG9ydCB7IGEgYXMgYWRkSXRlbVN0YXRlLCBjIGFzIGFkZEl0ZW1SZXF1ZXN0U3RhdGUgfSBmcm9tICcuL2FkZC1pdGVtLTk3ZDU3N2E5LmpzJztcbmltcG9ydCB7IGMgYXMgY29tYmluZUZlYXR1cmVMYXllckluZm9zIH0gZnJvbSAnLi9mZWF0dXJlLWxheWVyLWQzM2VhMTE0LmpzJztcbmltcG9ydCB7IHMgYXMgc3RyZWFtUHJvbWlzZXMsIGEgYXMgZm9ybWF0RmlsZU5hbWUgfSBmcm9tICcuL2Z1bmN0aW9uYWwtOWY2NDhiZWUuanMnO1xuaW1wb3J0IHsgYyBhcyBzZW5kQWRkSXRlbVJlcXVlc3QsIGcgYXMgZ2V0SXRlbVVybCwgZSBhcyB1cGRhdGVJdGVtLCBpIGFzIGFkZFRodW1ibmFpbFRvSXRlbSwgaiBhcyBnZXRBZGRJdGVtUGFyYW1ldGVycywgayBhcyBjcmVhdGVGb3JtLCBsIGFzIGNvbW1pdEl0ZW0sIG4gYXMgZ2V0QWRkSXRlbVVybCwgbyBhcyBjYW5jZWxJdGVtLCBkIGFzIGRlbGV0ZUl0ZW0sIGEgYXMgZ2V0SXRlbSwgbSBhcyBtb3ZlSXRlbSB9IGZyb20gJy4vc2VydmVyLWl0ZW0tZjEyMTUzZTYuanMnO1xuaW1wb3J0IHsgciBhcyByZXF1ZXN0LCBnIGFzIGdldFJlc3RCYXNlVXJsLCBlIGFzIGZvcm1SZXF1ZXN0LCBwIGFzIHBvbGxGb3JTdGF0dXMsIGggYXMgZ2V0VG9rZW4sIHEgYXMgcXVlcnlHcm91cHMgfSBmcm9tICcuL3BvcnRhbC03OWNhYWVmZi5qcyc7XG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1hYWYzMGJkNi5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzQUdTIH0gZnJvbSAnLi9hZ3MtNjhkNGFlMjAuanMnO1xuaW1wb3J0IHsgYSBhcyBpc0hvc3RlZFNlcnZpY2UsIGIgYXMgc3VwcG9ydHNIdHRwcywgYyBhcyB1cmxUb09iamVjdCwgZCBhcyBmb3JtYXRHSVNVcmwsIGUgYXMgY2hlY2tQcm90b2NvbCB9IGZyb20gJy4vdXJsLWYzYjgyY2M3LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0SXRlbUluZm9CeVR5cGUgfSBmcm9tICcuL2ZpbGUtZjM2MTkzZTkuanMnO1xuaW1wb3J0IHsgYSBhcyBhZGRDcmVhdGVJdGVtVHlwZXMgfSBmcm9tICcuL2l0ZW0tdHlwZXMtYjRmZTg2YWQuanMnO1xuaW1wb3J0IHsgZyBhcyBndWlkIH0gZnJvbSAnLi9ndWlkLTRmNDE3NmJhLmpzJztcbmltcG9ydCB7IHcgYXMgd29ya2Zsb3dTdGF0ZSB9IGZyb20gJy4vc3RvcmUtMzIxMGI2MDQuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVTdG9yZSB9IGZyb20gJy4vaW5kZXgtODFkNTQ4YjcuanMnO1xuXG5mdW5jdGlvbiBpc0ZvbGRlclJvb3QoZm9sZGVyKSB7XG4gIHJldHVybiAoZm9sZGVyID09PSBudWxsIHx8IGZvbGRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9sZGVyLmlkKSA9PT0gKGZvbGRlciA9PT0gbnVsbCB8fCBmb2xkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvbGRlci51c2VybmFtZSk7XG59XG5cbi8qKlxuICogZm9yIEFHUyBhbmQgT0dDIEZlYXR1cmUgU2VydmljZXMgdXJscywgZm9ybWF0dGVkIHBhcmFtcyB3aWxsIGJlIHVzZWQgZm9yIHRoZSBzZXJ2aWNlIEluZm8gcmVxdWVzdHNcbiAqL1xuZnVuY3Rpb24gYWRkUGFyYW1ldGVycyh1cmwpIHtcbiAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzIH0gPSBhZGRJdGVtU3RhdGU7XG4gIGNvbnN0IGRlbGltaXRlciA9IHVybC5pbmNsdWRlcyhcIj9cIikgPyBcIiZcIiA6IFwiP1wiO1xuICBjb25zdCBjdXN0b21QYXJhbWV0ZXJzID0gKHBhcmFtZXRlcnMgPT09IG51bGwgfHwgcGFyYW1ldGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1ldGVycy5tYXAoKHsgcGFyYW1ldGVyLCB2YWx1ZSB9KSA9PiBgJHtwYXJhbWV0ZXIgfHwgXCJcIn0ke3BhcmFtZXRlciB8fCB2YWx1ZSA/IFwiPVwiIDogXCJcIn0ke3ZhbHVlIHx8IFwiXCJ9YCkuam9pbihcIiZcIikpIHx8IFwiXCI7XG4gIGlmICghY3VzdG9tUGFyYW1ldGVycykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgcmV0dXJuIGAke3VybH0ke2RlbGltaXRlcn0ke2N1c3RvbVBhcmFtZXRlcnN9YDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVBhcmFtZXRlcih1cmwsIHsgdmFsdWUsIHBhcmFtZXRlciB9KSB7XG4gIGNvbnN0IHBhcmFtU3RyID0gYCR7cGFyYW1ldGVyfT0ke3ZhbHVlfWA7XG4gIGNvbnN0IHJlc3VsdFVybCA9IHVybC5yZXBsYWNlKHVybFt1cmwuaW5kZXhPZihwYXJhbVN0cikgLSAxXSA9PT0gXCImXCIgPyBgJiR7cGFyYW1TdHJ9YCA6IHBhcmFtU3RyLCBcIlwiKTtcbiAgcmV0dXJuIHJlc3VsdFVybFtyZXN1bHRVcmwubGVuZ3RoIC0gMV0gPT09IFwiP1wiID8gcmVzdWx0VXJsLnJlcGxhY2UoXCI/XCIsIFwiXCIpIDogcmVzdWx0VXJsO1xufVxuXG5jb25zdCBlcnJvckNvZGVMaXN0ID0gW1xuICBcImFwcEV4dGVuc2lvbkVycm9yXCIsXG4gIFwiZm9yYmlkZGVuQ3JlZGVudGlhbFwiLFxuICBcImRpc2FibGVkU3Vic2NyaXB0aW9uXCIsXG4gIFwidW5hdXRob3JpemVkXCIsXG4gIFwidGltZW91dFwiLFxuICAvLyAtLS0gSXRlbSBlcnJvciBjb2RlXG4gIFwiaXRlbUV4aXN0c1wiLFxuICBcImV4Y2VlZHNGaWxlU2l6ZVwiLFxuICBcImZpbGVFeGlzdHNcIixcbiAgXCJlbXB0eUZpbGVcIixcbiAgXCJ1bmF2YWlsYWJsZUdlb2NvZGVyXCIsXG4gIFwiZGF0YU5vdEF2YWlsYWJsZVwiLFxuICBcImludmFsaWRTaGFwZWZpbGVcIixcbiAgXCJpbnZhbGlkRmlsZUdlb2RhdGFiYXNlXCIsXG4gIFwicHJvdmlkZVBhdGhcIixcbiAgXCJ1c2VTYW1lRmlsZU5hbWVcIixcbiAgXCJpbnZhbGlkRXh0ZW5zaW9uXCIsXG4gIFwidG9rZW5SZXF1aXJlZFwiLFxuICAvLyAtLS0gSXRlbSBwcm9wZXJ0aWVzIGVycm9yIGNvZGVcbiAgXCJzZXJ2aWNlTmFtZUludmFsaWRcIixcbiAgXCJ0aXRsZUludmFsaWRcIixcbiAgXCJ0aXRsZVJlcXVpcmVkXCIsXG4gIFwidGl0bGVJblVzZVNlcnZpY2VcIixcbiAgXCJzdW1tYXJ5SW52YWxpZFwiLFxuICBcIm1pc3NpbmdVc2VyT3JQb3J0YWxcIixcbiAgXCJkYXRhU3RvcmVUaXRsZUludmFsaWRcIixcbiAgLy8gLS0tIFNlcnZpY2VzXG4gIFwic2VydmljZU5hbWVFeGlzdHNcIixcbiAgLy8gLS0tIEFHUywgV01GLCBXTVMsIFdGUywgZXRjXG4gIFwic2VydmljZU5vdEV4aXN0XCIsXG4gIFwidW5zdXBwb3J0ZWRXRlNWZXJzaW9uXCIsXG4gIFwiaW52YWxpZFdNVFNcIixcbiAgXCJpbnZhbGlkU3BhdGlhbFJlZlwiLFxuICBcImVtcHR5RmVhdHVyZUxheWVyXCIsXG4gIC8vIC0tLSBGZWF0dXJlIGxheWVyLFxuICBcImludmFsaWRGZWF0dXJlTGF5ZXJVcmxcIixcbiAgXCJpbnZhbGlkVXJsXCIsXG4gIFwiaHR0cFdhcm5pbmdcIixcbiAgLy8gLS0tIFVzZXIgZXJyb3JcbiAgXCJmbG93QWJvcnRlZFwiLFxuICAvLyAtLS0gQ1NWIGVycm9yXG4gIFwiZHVwbGljYXRlRmllbGROYW1lc1wiLFxuICBcImZhaWxUb0ZldGNoVGV4dFwiLFxuICAvLyAtLS0gVGlsZSBsYXllclxuICBcIm1hcFNlcnZpY2VFcnJvclwiLFxuICBcIm5vVGlsaW5nU2NoZW1lRm91bmRcIixcbiAgXCJub01hdGNoU3BhdGlhbFJlZlwiLFxuICAvLyAtLS0gRGF0YXN0b3JlXG4gIFwiaW52YWxpZERhdGFTdG9yZVB1Ymxpc2hUeXBlXCIsXG4gIFwibm9SZWdpc3RlcmVkU2VydmVyc0ZvckRhdGFTdG9yZVwiLFxuICBcIm5vQ29udGVudEluRGF0YVN0b3JlXCIsXG4gIFwiZmFpbFRvUHVibGlzaEZyb21EYXRhU3RvcmVcIixcbiAgXCJmYWlsVG9MaXN0RGF0YVN0b3JlQ29udGVudHNcIixcbiAgXCJpbnZhbGlkVXNlcm5hbWVPclBhc3N3b3JkXCIsXG4gIFwiaW52YWxpZEpTT05cIixcbiAgLy8gLS0tIEludGVybmFsIGVycm9yXG4gIFwidW5rbm93bkFHU1R5cGVcIixcbiAgXCJ1bmhhbmRsZWRFcnJvclwiLFxuICAvLyAtLSBBcHBlbmQgZXJyb3JzXG4gIFwiaW5jb21wYXRpYmxlR2VvbWV0cmllc1wiLFxuICBcIm11bHRpUGF0Y2hSZXN0cmljdGlvblwiXG5dO1xuLy8gKiBVdGlsc1xuY29uc3QgaXNBcHBDb21wb25lbnRFcnJvciA9IChlcnJvcikgPT4gZXJyb3JDb2RlTGlzdC5pbmNsdWRlcyhlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSk7XG5jb25zdCBpc0JhY2tlbmRFcnJvciA9IChlcnJvcikgPT4gZXJyb3IgJiZcbiAgZXJyb3IuaGFzT3duUHJvcGVydHkoXCJjb2RlXCIpICYmXG4gIGVycm9yLmhhc093blByb3BlcnR5KFwibWVzc2FnZVwiKSAmJlxuICBlcnJvci5oYXNPd25Qcm9wZXJ0eShcImRldGFpbHNcIikgJiZcbiAgKCFlcnJvci5kZXRhaWxzIHx8IEFycmF5LmlzQXJyYXkoZXJyb3IuZGV0YWlscykpO1xuXG5jb25zdCB1bnN1YnNjcmliZSA9IGFzeW5jIChpZCkgPT4ge1xuICBjb25zdCBzdWJzY3JpYmVyID0gc3Vic2NyaXB0aW9uU3RhdGUuc3Vic2NyaWJlcnNbaWRdO1xuICB0cnkge1xuICAgIGF3YWl0IChzdWJzY3JpYmVyID09PSBudWxsIHx8IHN1YnNjcmliZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRmFpbCB0byBjYWxsIHVuc3Vic2NyaWJlIGZvciAke3N1YnNjcmliZXIubmFtZX06ICR7ZXJyb3J9YCk7XG4gIH1cbn07XG5jb25zdCByZW1vdmVTdWJzY3JpYmVyID0gYXN5bmMgKGlkKSA9PiB7XG4gIGRlbGV0ZSBzdWJzY3JpcHRpb25TdGF0ZS5zdWJzY3JpYmVyc1tpZF07XG59O1xuY29uc3QgdW5zdWJzY3JpYmVBbGwgPSBhc3luYyAoKSA9PiB7XG4gIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvblN0YXRlLnN1YnNjcmliZXJzKS5tYXAodW5zdWJzY3JpYmUpKTtcbiAgc3Vic2NyaXB0aW9uU3RvcmUucmVzZXQoKTtcbn07XG5jb25zdCBhZGRTdWJzY3JpYmVyID0gKG5hbWUsIHVuc3Vic2NyaWJlKSA9PiB7XG4gIGNvbnN0IGlkID0gYCR7bmFtZX0tLS0ke2d1aWQoKX1gO1xuICBzdWJzY3JpcHRpb25TdGF0ZS5zdWJzY3JpYmVyc1tpZF0gPSB7IG5hbWUsIHVuc3Vic2NyaWJlIH07XG4gIHJldHVybiBpZDtcbn07XG5jb25zdCBpc1N1YnNjcmliZXJWYWxpZCA9IChzdWJzY3JpcHRpb25JZCkgPT4gISFzdWJzY3JpcHRpb25TdGF0ZS5zdWJzY3JpYmVyc1tzdWJzY3JpcHRpb25JZF07XG4vKiogVXNlZCB0byBrZWVwIHRyYWNrIGFuZCBoYW5kbGUgYWxsIHRoZSBsb25nIHJ1bm5pbmcgam9iIGxpa2UgcG9sbGluZyBhbmQgdXBsb2FkIG11bHRpLXBhcnQgZmlsZSAqL1xuY29uc3Qgc3Vic2NyaXB0aW9uU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gIHN1YnNjcmliZXJzOiB7fSxcbiAgdW5zdWJzY3JpYmVBbGwsXG4gIGFkZFN1YnNjcmliZXIsXG4gIHVuc3Vic2NyaWJlLFxuICByZW1vdmVTdWJzY3JpYmVyLFxuICBpc1N1YnNjcmliZXJWYWxpZFxufSk7XG5jb25zdCBzdWJzY3JpcHRpb25TdGF0ZSA9IHN1YnNjcmlwdGlvblN0b3JlLnN0YXRlO1xuXG4vLyBGaWxlIHNpemUgY29uc3RhbnRzXG5jb25zdCBNVUxUSV9QQVJUX1VQTE9BRF9CQVRDSF9TSVpFID0gMjYyMTQ0MDA7IC8vIDI1bWJcbmNvbnN0IE1VTFRJX1BBUlRfVVBMT0FEX01JTklNVU1fU0laRSA9IDc4NjQzMjAwOyAvLyA3NW1iXG5jb25zdCBNVUxUSV9QQVJUX1VQTE9BRF9SRVRSSUVTID0gNTtcbmNvbnN0IE1VTFRJX1BBUlRfVVBMT0FEX01BWF9QQVJUUyA9IDEwMDAwO1xuY29uc3QgTVVMVElfUEFSVF9VUExPQURfSU5JVElBTF9CQVRDSF9TSVpFID0gMztcbmNvbnN0IE1VTFRJX1BBUlRfVVBMT0FEX01BWF9CQVRDSF9TSVpFID0gMTA7XG5cbi8vIFRoZSBzaGFwZSBvZiBjdXN0b21QYXJhbXRlcnMgaW4gdGhlIGNvbXBvbmVudCBpcyBkaWZmZXJlbnQgdGhhbiBob3cgaXQgbmVlZHMgdG8gYmUgZm9ybWF0dGVkIGluIHRoZSBVUkxTLCBzbyB3ZSBkbyB0aGF0IGhlcmUuXG5mdW5jdGlvbiBmb3JtYXRDdXN0b21QYXJhbWV0ZXJzKGN1c3RvbVBhcmFtcykge1xuICBpZiAoIWN1c3RvbVBhcmFtcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBhcHBlbmRBbGwgPSB0cnVlO1xuICBsZXQgY3VzdG9tUGFyYW1ldGVycyA9IHt9O1xuICBsZXQgY3VzdG9tTGF5ZXJQYXJhbWV0ZXJzID0ge307XG4gIC8vIFdNUyBhbmQgV01UUyBjYW4gaGF2ZSBjdXN0b20gUGFyYW10ZXJzIHRoYXQgb25seSBhcHBseSB0byB0aGUgc3BlY2lmaWMgbGF5ZXIgbm90IHRoZSB3aG9sZSBzZXJ2aWNlSW5mbyByZXF1ZXN0IC0gdGhhdHMgd2hhdCB3ZXJlIGRvaW5nIGhlcmUuXG4gIGN1c3RvbVBhcmFtcy5mb3JFYWNoKCh7IGFwcGVuZCwgcGFyYW1ldGVyLCB2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKGFwcGVuZCA9PT0gXCJsYXllclwiKSB7XG4gICAgICBhcHBlbmRBbGwgPSBmYWxzZTtcbiAgICAgIGN1c3RvbUxheWVyUGFyYW1ldGVyc1twYXJhbWV0ZXJdID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY3VzdG9tUGFyYW1ldGVyc1twYXJhbWV0ZXJdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFwcGVuZEFsbCA/IHsgY3VzdG9tUGFyYW1ldGVycyB9IDogeyBjdXN0b21QYXJhbWV0ZXJzLCBjdXN0b21MYXllclBhcmFtZXRlcnMgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYWRkQXBwbGljYXRpb24oaXRlbSwgcmVzdEJhc2VVcmwsIGFwcEluZm8pIHtcbiAgaWYgKGl0ZW0udHlwZSA9PT0gXCJEZXNrdG9wIEFwcGxpY2F0aW9uXCIpIHtcbiAgICByZXR1cm4gYWRkRmlsZSgpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VuZEFkZEl0ZW1SZXF1ZXN0KGl0ZW0pO1xuICBpZiAoaXRlbS50eXBlID09PSBcIkFwcGxpY2F0aW9uXCIgfHwgaXRlbS50eXBlID09PSBcIkFQSSBLZXlcIikge1xuICAgIGF3YWl0IHJlZ2lzdGVyQXBwbGljYXRpb24ocmVzcG9uc2UuaWQsIHJlc3RCYXNlVXJsLCBhcHBJbmZvKTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5hc3luYyBmdW5jdGlvbiByZWdpc3RlckFwcGxpY2F0aW9uKGl0ZW1JZCwgcmVzdEJhc2VVcmwsIGFwcEluZm8pIHtcbiAgY29uc3QgdXJsID0gYCR7cmVzdEJhc2VVcmx9b2F1dGgyL3JlZ2lzdGVyQXBwYDtcbiAgbGV0IHJlcXVlc3RQYXJhbSA9IHtcbiAgICBpdGVtSWQsXG4gICAgYXBwVHlwZTogXCJtdWx0aXBsZVwiLFxuICAgIHJlZGlyZWN0X3VyaXM6IEpTT04uc3RyaW5naWZ5KFtcInVybjppZXRmOndnOm9hdXRoOjIuMDpvb2JcIl0pXG4gIH07XG4gIGNvbnN0IHJlZGlyZWN0VXJsU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoYXBwSW5mby5yZWRpcmVjdF91cmlzKTtcbiAgaWYgKGFwcEluZm8pIHtcbiAgICByZXF1ZXN0UGFyYW0gPVxuICAgICAgYXBwSW5mby5hcHBUeXBlID09PSBcImFwaWtleVwiXG4gICAgICAgID8ge1xuICAgICAgICAgIGl0ZW1JZCxcbiAgICAgICAgICBhcHBUeXBlOiBcImFwaWtleVwiLFxuICAgICAgICAgIHJlZGlyZWN0X3VyaXM6IHJlZGlyZWN0VXJsU3RyaW5nLFxuICAgICAgICAgIGh0dHBSZWZlcnJlcnM6IEpTT04uc3RyaW5naWZ5KGFwcEluZm8uaHR0cFJlZmVycmVycyksXG4gICAgICAgICAgcHJpdmlsZWdlczogSlNPTi5zdHJpbmdpZnkoYXBwSW5mby5wcml2aWxlZ2VzKVxuICAgICAgICB9XG4gICAgICAgIDogeyBpdGVtSWQsIGFwcFR5cGU6IGFwcEluZm8uYXBwVHlwZSwgcmVkaXJlY3RfdXJpczogcmVkaXJlY3RVcmxTdHJpbmcsIHVybDogYXBwSW5mby51cmwgfTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgcmVxdWVzdCh1cmwsIHJlcXVlc3RQYXJhbSwge30sIFwicG9zdFwiKSB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvcjpcIiwgZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQXBwbGljYXRpb25NYW5pZmVzdChtYW5pZmVzdFVybCkge1xuICB0cnkge1xuICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgcmVxdWVzdChtYW5pZmVzdFVybCwge30sIHsgYWRkVG9rZW5NYW51YWxseTogZmFsc2UgfSksIGVycm9yOiBudWxsIH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcImVycm9yOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiBudWxsLCBlcnJvcjogeyBjb2RlOiBcImFwcEV4dGVuc2lvbkVycm9yXCIgfSB9O1xuICB9XG59XG5cbmNvbnN0IEhJRERFTl9NQVBfRElWX0lEID0gXCJoaWRkZW5NYXBEaXZcIjtcbmNvbnN0IGRlc3Ryb3lIaWRkZW5NYXBEaXYgPSAoKSA9PiB7XG4gIGNvbnN0IGhpZGRlbk1hcERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKEhJRERFTl9NQVBfRElWX0lEKTtcbiAgaWYgKGhpZGRlbk1hcERpdikge1xuICAgIGhpZGRlbk1hcERpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhpZGRlbk1hcERpdik7XG4gIH1cbn07XG4vKiogUmV0dXJuIHRoZSBpZCBvZiB0aGUgaGlkZGVuIG1hcCAqL1xuY29uc3QgY3JlYXRlSGlkZGVuTWFwRGl2ID0gKHdpZHRoID0gMjAwLCBoZWlnaHQgPSAxMzApID0+IHtcbiAgbGV0IGhpZGRlbk1hcERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKEhJRERFTl9NQVBfRElWX0lEKTtcbiAgaWYgKCFoaWRkZW5NYXBEaXYpIHtcbiAgICBoaWRkZW5NYXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGhpZGRlbk1hcERpdi5pZCA9IEhJRERFTl9NQVBfRElWX0lEO1xuICAgIGhpZGRlbk1hcERpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBoaWRkZW5NYXBEaXYuc3R5bGUubGVmdCA9IFwiLTEwMDBweFwiO1xuICAgIGhpZGRlbk1hcERpdi5zdHlsZS50b3AgPSBcIi0xMDAwcHhcIjtcbiAgICBoaWRkZW5NYXBEaXYuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgaGlkZGVuTWFwRGl2LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoaWRkZW5NYXBEaXYpO1xuICB9XG4gIGNvbnN0IGhpZGRlbk1hcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IGhpZGRlbk1hcElkID0gXCJoaWRkZW5NYXBcIjtcbiAgaGlkZGVuTWFwLmlkID0gaGlkZGVuTWFwSWQ7XG4gIGhpZGRlbk1hcC5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDtcbiAgaGlkZGVuTWFwLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gIGhpZGRlbk1hcERpdi5hcHBlbmRDaGlsZChoaWRkZW5NYXApO1xuICByZXR1cm4gaGlkZGVuTWFwSWQ7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVUaHVtYm5haWxJbWFnZShtYXAsIGNvbmZpZykge1xuICBjb25zdCBbUHJpbnRUZW1wbGF0ZSwgUHJpbnRQYXJhbWV0ZXJzLCBQcmludFRhc2ssIGVzcmlDb25maWddID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgIFwiZXNyaS90YXNrcy9QcmludFRlbXBsYXRlXCIsXG4gICAgXCJlc3JpL3Rhc2tzL1ByaW50UGFyYW1ldGVyc1wiLFxuICAgIFwiZXNyaS90YXNrcy9QcmludFRhc2tcIixcbiAgICBcImVzcmkvY29uZmlnXCJcbiAgXSk7XG4gIGNvbnN0IHRodW1ibmFpbFdpZHRoID0gNjAwO1xuICBjb25zdCB0aHVtYm5haWxIZWlnaHQgPSA0MDA7XG4gIGNvbnN0IHRlbXBsYXRlID0gbmV3IFByaW50VGVtcGxhdGUoKTtcbiAgdGVtcGxhdGUubGF5b3V0ID0gXCJNQVBfT05MWVwiO1xuICB0ZW1wbGF0ZS5mb3JtYXQgPSBcInBuZzMyXCI7XG4gIHRlbXBsYXRlLnByZXNlcnZlU2NhbGUgPSBmYWxzZTtcbiAgdGVtcGxhdGUuc2hvd0F0dHJpYnV0aW9uID0gZmFsc2U7XG4gIHRlbXBsYXRlLnNob3dMYWJlbHMgPSBmYWxzZTtcbiAgdGVtcGxhdGUuZXhwb3J0T3B0aW9ucyA9IHtcbiAgICB3aWR0aDogdGh1bWJuYWlsV2lkdGgsXG4gICAgaGVpZ2h0OiB0aHVtYm5haWxIZWlnaHQsXG4gICAgZHBpOiA5NlxuICB9O1xuICBjb25zdCBwcmludFRhc2sgPSBuZXcgUHJpbnRUYXNrKGNvbmZpZy5zZWxmLmhlbHBlclNlcnZpY2VzLnByaW50VGFzay51cmwsIHt9KTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFByaW50UGFyYW1ldGVycygpO1xuICBwYXJhbXMubWFwID0gbWFwO1xuICBwYXJhbXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgZXNyaUNvbmZpZy5kZWZhdWx0cy5pby50aW1lb3V0ID0gMTIwMDAwO1xuICAvLyBUT0RPOiBTb21lIGZlYXR1cmUgc2VydmljZXMgbmVlZCB0byBiZSBwcm9qZWN0ZWQgdG8gV0dTODQgdG8gZ2VuZXJhdGUgY29ycmVjdGx5XG4gIC8vIENhbiBzZXQgZXh0ZW50IHRvIGdlb2dyYXBoaWNFeHRlbnQgaGVyZSBidXQgc2hvdWxkIGZpeCB3aXRoaW4gUHJpbnRQYXJhbWV0ZXJzXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcHJpbnRUYXNrLmV4ZWN1dGUocGFyYW1zLCAocmVzdWx0KSA9PiB7XG4gICAgICBlc3JpQ29uZmlnLmRlZmF1bHRzLmlvLnRpbWVvdXQgPSA2MDAwMDtcbiAgICAgIGRlc3Ryb3lIaWRkZW5NYXAobWFwKTtcbiAgICAgIHJlc29sdmUocmVzdWx0LnVybCk7XG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgZXNyaUNvbmZpZy5kZWZhdWx0cy5pby50aW1lb3V0ID0gNjAwMDA7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVIaWRkZW5NYXAod2ViTWFwRGF0YSwgZ2NzRXh0ZW50QXNMaXN0KSB7XG4gIGNvbnN0IHsgY29uZmlnIH0gPSBjb25maWdTdGF0ZTtcbiAgY29uc3QgaXRlbUluZm8gPSB7IGl0ZW06IHsgZXh0ZW50OiBnY3NFeHRlbnRBc0xpc3QgfSwgaXRlbURhdGE6IHdlYk1hcERhdGEgfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBbYXJjZ2lzVXRpbHNdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9hcmNnaXMvdXRpbHNcIl0pO1xuICAgIC8vIE5lZWQgdG8gc2V0IHRoaXMgc28gXCJjcmVhdGVNYXBcIiB1c2VzIHRoZSBjb3JyZWN0IHBvcnRhbFVybCwgaW4gdGhlIGZ1dHVyZVxuICAgIC8vIFwiY3JlYXRlTWFwXCIgc2hvdWxkIHJlYWxseSBiZSBpbXByb3ZlZCB0byB1c2UgdGhlIHBvcnRhbCBBUEksIG9yIGEgcG9ydGFsVXJsIHBhcmFtZXRlclxuICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8xNDgxOVxuICAgIGFyY2dpc1V0aWxzLmFyY2dpc1VybCA9IGAke2dldFJlc3RCYXNlVXJsKCl9Y29udGVudC9pdGVtc2A7XG4gICAgY29uc3QgaGlkZGVuTWFwSWQgPSBjcmVhdGVIaWRkZW5NYXBEaXYoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFyY2dpc1V0aWxzLmNyZWF0ZU1hcChpdGVtSW5mbywgaGlkZGVuTWFwSWQsIHtcbiAgICAgIG1hcE9wdGlvbnM6IHtcbiAgICAgICAgbmF2OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJpbmdNYXBzS2V5OiBjb25maWcuc2VsZi5iaW5nS2V5LFxuICAgICAgZ2VvbWV0cnlTZXJ2aWNlVVJMOiBjb25maWdTdGF0ZS5wb3J0YWwuaGVscGVyU2VydmljZXMuZ2VvbWV0cnkudXJsXG4gICAgfSk7XG4gICAgY29uc3Qgd2FpdEZvckhlYXRtYXBJbWFnZUxheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKGxheWVyLl9oZWF0bWFwTWFuYWdlcikge1xuICAgICAgICAgIGxheWVyLl9oZWF0bWFwTWFuYWdlci5vbihcInJlY2FsY3VsYXRlSGVhdG1hcFwiLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBsYXllciBtaWdodCBiZSBvdXQgb2Ygc2NhbGVcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgd2FpdEZvcldGU0ZlYXR1cmVzID0gKGxheWVyKSA9PiB7XG4gICAgICAvLyB0aGVyZSBpcyBubyBldmVudC4uLlxuICAgICAgY29uc3QgY291bnQgPSBbMF07XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgaW50SG5kbCA9IHNldEludGVydmFsKChsYXllciwgY291bnQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgaWYgKChfYSA9IGxheWVyLmdyYXBoaWNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludEhuZGwpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjb3VudFswXSA+IDEwKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludEhuZGwpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50WzBdID0gY291bnRbMF0gKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwLCBsYXllciwgY291bnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB3YWl0Rm9yVXBkYXRlU3RhcnQgPSAobGF5ZXIpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAobGF5ZXIuZGVjbGFyZWRDbGFzcyA9PT0gXCJlc3JpLmxheWVycy5WZWN0b3JUaWxlTGF5ZXJcIikge1xuICAgICAgICAgIC8vIGJ1ZywgZG9lc24ndCBjYWxsIG9uVXBkYXRlU3RhcnQgc29tZXRpbWVzXG4gICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKTtcbiAgICAgICAgfVxuICAgICAgICBsYXllci5vbihcInVwZGF0ZS1zdGFydFwiLCAoKSA9PiB7XG4gICAgICAgICAgd2FpdEZvclVwZGF0ZUVuZChsYXllcikudGhlbihyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHdhaXRGb3JVcGRhdGVFbmQgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAoIWxheWVyLnVwZGF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXIuZGVjbGFyZWRDbGFzcyA9PT0gXCJlc3JpLmxheWVycy5WZWN0b3JUaWxlTGF5ZXJcIikge1xuICAgICAgICAgIC8vIGJ1ZywgZG9lc24ndCBjYWxsIG9uVXBkYXRlRW5kIGlmIHRoZXJlIGFyZSBubyB0aWxlcyBpbiB0aGUgdmlld1xuICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMDApO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLm9uKFwidXBkYXRlLWVuZFwiLCByZXNvbHZlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgeyBtYXAgfSA9IHJlc3BvbnNlO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgbWFwLmdyYXBoaWNzTGF5ZXJJZHMuZm9yRWFjaCgobGF5ZXJJZCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgbGF5ZXIgPSBtYXAuZ2V0TGF5ZXIobGF5ZXJJZCk7XG4gICAgICBpZiAoKChfYSA9IGxheWVyLnJlbmRlcmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiaGVhdG1hcFwiKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2god2FpdEZvckhlYXRtYXBJbWFnZUxheWVyKGxheWVyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsYXllci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLldGU0xheWVyXCIpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh3YWl0Rm9yV0ZTRmVhdHVyZXMobGF5ZXIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxheWVyLnVwZGF0aW5nKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2god2FpdEZvclVwZGF0ZUVuZChsYXllcikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1hcC5sYXllcklkcy5mb3JFYWNoKChsYXllcklkKSA9PiB7XG4gICAgICBjb25zdCBseXIgPSByZXNwb25zZS5tYXAuZ2V0TGF5ZXIobGF5ZXJJZCk7XG4gICAgICBpZiAobHlyLnVwZGF0aW5nKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2god2FpdEZvclVwZGF0ZUVuZChseXIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGx5ci5kZWNsYXJlZENsYXNzID09PSBcImVzcmkubGF5ZXJzLlZlY3RvclRpbGVMYXllclwiKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHdvcmtpbmcgY29ycmVjdGx5IGluIFZUTDsgdmlld2VyIHNob3VsZCBub3QgaGF2ZSB0byB3YWl0IGZvciB1cGRhdGUgc3RhcnRcbiAgICAgICAgcHJvbWlzZXMucHVzaCh3YWl0Rm9yVXBkYXRlU3RhcnQobHlyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGEgbGl0dGxlIGxvbmdlclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoYXdhaXQgY3JlYXRlVGh1bWJuYWlsSW1hZ2UocmVzcG9uc2UubWFwLCBjb25maWcpKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgY3JlYXRlVGh1bWJuYWlsSW1hZ2UocmVzcG9uc2UubWFwLCBjb25maWcpO1xuICAgIH1cbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcCBjcmVhdGlvbiBmYWlsZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVGh1bWJuYWlsVVJMRnJvbUl0ZW1XZWJNYXAod2ViTWFwLCBnY3NFeHRlbnRBc0xpc3QsIHNwYXRpYWxSZWZlcmVuY2UpIHtcbiAgdmFyIF9hO1xuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBkZXBlbmRlbmN5XG4gIGNvbnN0IGFwaSA9IGNvbmZpZ1N0YXRlLmFwaTtcbiAgLy8gZG9lcyBub3Qgc3VwcG9ydCBoZWF0bWFwIHJlbmRlcmVyXG4gIGNvbnN0IFtHZW9wcm9jZXNzb3JdID0gYXdhaXQgbG9hZE1vZHVsZXMoW2FwaSA9PT0gMyA/IFwiZXNyaS90YXNrcy9HZW9wcm9jZXNzb3JcIiA6IFwiZXNyaS9yZXN0L2dlb3Byb2Nlc3NvclwiXSk7XG4gIGNvbnN0IHsgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgKChfYSA9IHdlYk1hcC5iYXNlTWFwLmJhc2VNYXBMYXllcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5mb3JFYWNoKChiYXNlTWFwTGF5ZXIpID0+IHtcbiAgICBkZWxldGUgYmFzZU1hcExheWVyLnJlc291cmNlSW5mbztcbiAgfSk7XG4gIHdlYk1hcC5tYXBPcHRpb25zID0ge1xuICAgIHNob3dBdHRyaWJ1dGlvbjogZmFsc2UsXG4gICAgZXh0ZW50OiB7XG4gICAgICB4bWluOiBnY3NFeHRlbnRBc0xpc3RbMF1bMF0sXG4gICAgICB5bWluOiBnY3NFeHRlbnRBc0xpc3RbMF1bMV0sXG4gICAgICB4bWF4OiBnY3NFeHRlbnRBc0xpc3RbMV1bMF0sXG4gICAgICB5bWF4OiBnY3NFeHRlbnRBc0xpc3RbMV1bMV0sXG4gICAgICBzcGF0aWFsUmVmZXJlbmNlOiB7XG4gICAgICAgIHdraWQ6IDQzMjZcbiAgICAgIH1cbiAgICB9LFxuICAgIHNwYXRpYWxSZWZlcmVuY2U6IHNwYXRpYWxSZWZlcmVuY2VcbiAgfTtcbiAgd2ViTWFwLmV4cG9ydE9wdGlvbnMgPSB7XG4gICAgZHBpOiA5NixcbiAgICBvdXRwdXRTaXplOiBbNjAwLCA0MDBdXG4gIH07XG4gIHdlYk1hcC5sYXlvdXRPcHRpb25zID0ge307XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBXZWJfTWFwX2FzX0pTT046IEpTT04uc3RyaW5naWZ5KHdlYk1hcCksXG4gICAgRm9ybWF0OiBcIlBORzMyXCIsXG4gICAgTGF5b3V0X1RlbXBsYXRlOiBcIk1BUF9PTkxZXCJcbiAgfTtcbiAgaWYgKGFwaSA9PT0gMykge1xuICAgIGNvbnN0IGdwID0gbmV3IEdlb3Byb2Nlc3Nvcihwb3J0YWwuaGVscGVyU2VydmljZXMucHJpbnRUYXNrLnVybCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGdwLmV4ZWN1dGUocGFyYW1zKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbaV0ucGFyYW1OYW1lID09PSBcIk91dHB1dF9GaWxlXCIpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZVtpXS52YWx1ZS51cmwpO1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHsgcmVzdWx0cyB9ID0gYXdhaXQgR2VvcHJvY2Vzc29yLmV4ZWN1dGUocG9ydGFsLmhlbHBlclNlcnZpY2VzLnByaW50VGFzay51cmwsIHBhcmFtcyk7XG4gIGNvbnN0IHVybCA9IHJlc3VsdHMuZmluZCgocmVzdWx0KSA9PiByZXN1bHQuZGF0YVR5cGUgPT09IFwiZGF0YS1maWxlXCIgJiYgcmVzdWx0KS52YWx1ZS51cmw7XG4gIGlmICghdXJsKSB7XG4gICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyBlcnJvciB0byB0aGUgbmV3IHN5c3RlbVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgdGh1bWJuYWlsXCIpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBkZXN0cm95SGlkZGVuTWFwKG1hcCkge1xuICB2YXIgX2E7XG4gIG1hcC5kZXN0cm95KCk7XG4gIChfYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaGlkZGVuTWFwRGl2XCIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoaWRkZW5NYXBcIikpO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHVtYm5haWxVUkxGcm9tV2ViTWFwKHdlYk1hcCwgZ2NzRXh0ZW50QXNMaXN0KSB7XG4gIHJldHVybiBhd2FpdCBjcmVhdGVIaWRkZW5NYXAod2ViTWFwLCBnY3NFeHRlbnRBc0xpc3QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBidWlsZFRodW1ibmFpbFVSTEZyb21LTUxJdGVtKGl0ZW0pIHtcbiAgdmFyIF9hO1xuICBjb25zdCBbU3BhdGlhbFJlZmVyZW5jZV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgY29uZmlnU3RhdGUuYXBpID09PSA0ID8gXCJlc3JpL2dlb21ldHJ5L1NwYXRpYWxSZWZlcmVuY2VcIiA6IFwiZXNyaS9TcGF0aWFsUmVmZXJlbmNlXCJcbiAgXSk7XG4gIGNvbnN0IHsgY29uZmlnLCBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCB3ZWJNYXAgPSB7fTtcbiAgd2ViTWFwLmJhc2VNYXAgPSBjb25maWcuZGVmYXVsdEJhc2VtYXAgfHwgcG9ydGFsLmRlZmF1bHRCYXNlbWFwO1xuICB3ZWJNYXAuYmFzZU1hcC50aXRsZSA9IFwiYmFzZW1hcFwiO1xuICB3ZWJNYXAub3BlcmF0aW9uYWxMYXllcnMgPSBbXTtcbiAgbGV0IHVybCA9IGl0ZW0udXJsO1xuICBpZiAoIXVybCAmJiBpdGVtLnR5cGUgPT09IFwiS01MXCIpIHtcbiAgICAvLyBsb2FkZWQgZnJvbSBhIGZpbGUgS01MXG4gICAgdXJsID0gY29uZmlnLnJlc3RCYXNlVXJsICsgXCJjb250ZW50L2l0ZW1zL1wiICsgaXRlbS5pZCArIFwiL2RhdGFcIjtcbiAgfVxuICAvLyB3ZSBkb24ndCBoYXZlIElEIG1hbmFnZXJcbiAgY29uc3QgcmVzdERvbWFpbiA9IG5ldyBVUkwoY29uZmlnLnJlc3RCYXNlVXJsKS5ob3N0bmFtZTtcbiAgaWYgKHVybC5pbmRleE9mKHJlc3REb21haW4pID4gLTEpIHtcbiAgICBjb25zdCB0b2tlbiA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy51c2VySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRva2VuO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgdXJsICs9IFwiP3Rva2VuPVwiICsgdG9rZW47XG4gICAgfVxuICB9XG4gIHdlYk1hcC5vcGVyYXRpb25hbExheWVycy5wdXNoKHtcbiAgICB1cmwsXG4gICAgaWQ6IFwiS01MX1wiICsgTWF0aC5yYW5kb20oKSxcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxuICAgIHZpc2liaWxpdHk6IHRydWUsXG4gICAgdHlwZTogXCJLTUxcIlxuICB9KTtcbiAgbGV0IGV4dCA9IFtdO1xuICBpZiAodHlwZW9mIGl0ZW0uZXh0ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgZSA9IGl0ZW0uZXh0ZW50LnNwbGl0KFwiLFwiKTtcbiAgICBleHQgPSBbXG4gICAgICBbcGFyc2VGbG9hdChlWzBdKSwgcGFyc2VGbG9hdChlWzFdKV0sXG4gICAgICBbcGFyc2VGbG9hdChlWzJdKSwgcGFyc2VGbG9hdChlWzNdKV1cbiAgICBdO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChpdGVtLmV4dGVudCAmJiBpdGVtLmV4dGVudC5sZW5ndGggPiAwKSB7XG4gICAgICBleHQgPSBpdGVtLmV4dGVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBleHQgPSBbXG4gICAgICAgIFstMTgwLCAtOTBdLFxuICAgICAgICBbMTgwLCA5MF1cbiAgICAgIF07XG4gICAgfVxuICB9XG4gIHJldHVybiBidWlsZFRodW1ibmFpbFVSTEZyb21JdGVtV2ViTWFwKHdlYk1hcCwgZXh0LCBuZXcgU3BhdGlhbFJlZmVyZW5jZSh7IHdraWQ6IDQzMjYgfSkpO1xufVxuXG5jb25zdCB3b3JsZEV4dGVudEluZm8gPSB7XG4gIHhtYXg6IDIwMDAwMDAwLFxuICB4bWluOiAtMjAwMDAwMDAsXG4gIHltYXg6IDIwMDAwMDAwLFxuICB5bWluOiAtMjAwMDAwMDAsXG4gIHNwYXRpYWxSZWZlcmVuY2U6IHtcbiAgICB3a2lkOiAxMDIxMDBcbiAgfVxufTtcbmZ1bmN0aW9uIHdyYXBBcm91bmQod2tpZCwgZ2VvbSkge1xuICBjb25zdCBWQUxJRF9FWFRFTlRTID0ge1xuICAgIFwiMTAyMTEzXCI6IFstMjAwMzc1MDguMzQyNzg4OTA1LCAyMDAzNzUwOC4zNDI3ODg5MDVdLFxuICAgIFwiMTAyMTAwXCI6IFstMjAwMzc1MDguMzQyNzg4OTA1LCAyMDAzNzUwOC4zNDI3ODg5MDVdLFxuICAgIFwiMzc4NVwiOiBbLTIwMDM3NTA4LjM0Mjc4ODkwNSwgMjAwMzc1MDguMzQyNzg4OTA1XSxcbiAgICBcIjM4NTdcIjogWy0yMDAzNzUwOC4zNDI3ODg5MDUsIDIwMDM3NTA4LjM0Mjc4ODkwNV0sXG4gICAgXCI0MzI2XCI6IFstMTgwLCAxODBdXG4gIH07XG4gIGNvbnN0IHZhbGlkID0gVkFMSURfRVhURU5UU1t3a2lkXTtcbiAgaWYgKHZhbGlkKSB7XG4gICAgaWYgKGdlb20ueG1pbiA+IGdlb20ueG1heCkge1xuICAgICAgLy8gd3JhcCBhcm91bmRcbiAgICAgIGNvbnN0IGRpZjEgPSB2YWxpZFsxXSAtIGdlb20ueG1pbjtcbiAgICAgIGNvbnN0IGRpZjIgPSBnZW9tLnhtYXggLSB2YWxpZFswXTtcbiAgICAgIGlmIChkaWYxID4gZGlmMikge1xuICAgICAgICBnZW9tLnhtYXggPSB2YWxpZFsxXSArIGRpZjI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZ2VvbS54bWluID0gdmFsaWRbMF0gLSBkaWYxO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3BhdGlhbFJlZmVyZW5jZShzZXJ2aWNlSW5mbywgYWdzVHlwZSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBzcGF0aWFsUmVmZXJlbmNlID0gYWdzVHlwZSAhPT0gXCJJbWFnZVNlcnZlclwiID8gc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLnNwYXRpYWxSZWZlcmVuY2UgOiAoX2EgPSBzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8uZXh0ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BhdGlhbFJlZmVyZW5jZTtcbiAgaWYgKCFzcGF0aWFsUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoc3BhdGlhbFJlZmVyZW5jZS53a2lkKSB7XG4gICAgcmV0dXJuIHNwYXRpYWxSZWZlcmVuY2Uud2tpZDtcbiAgfVxuICBlbHNlIGlmICgoKF9iID0gc3BhdGlhbFJlZmVyZW5jZS53a3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZWFyY2goL15QUk9KQ1MvaSkpICE9PSAtMSkge1xuICAgIHJldHVybiAvXlBST0pDU1xcW1wiW0EtWmEtejAtOV9dKi9pLmV4ZWMoc3BhdGlhbFJlZmVyZW5jZS53a3QpWzBdLnNwbGl0KFwiW1wiKVsxXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2plY3RFeHRlbnRUb1dHUzg0KGV4dGVudCkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBbU3BhdGlhbFJlZmVyZW5jZV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgY29uZmlnU3RhdGUuYXBpID09PSA0ID8gXCJlc3JpL2dlb21ldHJ5L1NwYXRpYWxSZWZlcmVuY2VcIiA6IFwiZXNyaS9TcGF0aWFsUmVmZXJlbmNlXCJcbiAgXSk7XG4gIGNvbnN0IGhhc1NSID0gKChfYSA9IGV4dGVudCA9PT0gbnVsbCB8fCBleHRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2tpZCkgfHwgKChfYiA9IGV4dGVudCA9PT0gbnVsbCB8fCBleHRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2t0KTtcbiAgY29uc3QgR0NTX1dHU18xOTg0ID0gbmV3IFNwYXRpYWxSZWZlcmVuY2UoeyB3a2lkOiA0MzI2IH0pO1xuICBjb25zdCBzYW1lU3BhdGlhbFJlZiA9IGF3YWl0IHNhbWVTcGF0aWFsUmVmZXJlbmNlKEdDU19XR1NfMTk4NCwgZXh0ZW50ID09PSBudWxsIHx8IGV4dGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2UpO1xuICByZXR1cm4gaGFzU1IgJiYgIXNhbWVTcGF0aWFsUmVmID8gYXdhaXQgcHJvamVjdChleHRlbnQsIEdDU19XR1NfMTk4NCkgOiBleHRlbnQ7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9qZWN0RXh0ZW50VG9XR1M4NEZyb21JdGVtKGl0ZW0pIHtcbiAgY29uc3QgeyBleHRlbnQgfSA9IGl0ZW07XG4gIGl0ZW0uZXh0ZW50ID0gZXh0ZW50VG9TdHJpbmcoYXdhaXQgcHJvamVjdEV4dGVudFRvV0dTODQoZXh0ZW50KSk7XG4gIHJldHVybiBpdGVtO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvamVjdEV4dGVudChnZW9tZXRyeSwgb3V0U1IpIHtcbiAgY29uc3QgeyBwb3J0YWwgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCBbbWVyY2F0b3JVdGlscywgR2VvbWV0cnlTZXJ2aWNlXSA9IGF3YWl0IGxvYWRNb2R1bGVzKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNFxuICAgID8gW1wiZXNyaS9nZW9tZXRyeS9zdXBwb3J0L3dlYk1lcmNhdG9yVXRpbHNcIiwgXCJlc3JpL3Jlc3QvZ2VvbWV0cnlTZXJ2aWNlXCJdXG4gICAgOiBbXCJlc3JpL2dlb21ldHJ5L3dlYk1lcmNhdG9yVXRpbHNcIiwgXCJlc3JpL3Rhc2tzL0dlb21ldHJ5U2VydmljZVwiXSk7XG4gIGNvbnN0IG1lcmNhdG9yID0gWzEwMjExMywgMTAyMTAwLCAzODU3XTtcbiAgY29uc3Qgd2tpZCA9IGdlb21ldHJ5LnNwYXRpYWxSZWZlcmVuY2Uud2tpZDtcbiAgLy8gd2Ugb25seSBoYXZlIDEgZ2VvbWV0cnkgYW55d2F5XG4gIGlmICh3a2lkID09PSBvdXRTUi53a2lkKSB7XG4gICAgcmV0dXJuIFtnZW9tZXRyeV07XG4gIH1cbiAgbGV0IGdlb207XG4gIC8vIGdvaW5nIGZyb20gR0NTX1dHU18xOTg0IHRvIG1lcmNhdG9yXG4gIGlmICh3a2lkID09PSA0MzI2ICYmIG1lcmNhdG9yLmluZGV4T2Yob3V0U1Iud2tpZCkgPiAtMSkge1xuICAgIC8vIGNsaXAgaXQsIHNvIGl0J3Mgbm90IGdvaW5nIHRvIEluZmluaXR5XG4gICAgZ2VvbWV0cnkueW1pbiA9IE1hdGgubWF4KGdlb21ldHJ5LnltaW4sIC04OS45OSk7XG4gICAgZ2VvbWV0cnkueW1heCA9IE1hdGgubWluKGdlb21ldHJ5LnltYXgsIDg5Ljk5KTtcbiAgICBnZW9tID0gbWVyY2F0b3JVdGlscy5nZW9ncmFwaGljVG9XZWJNZXJjYXRvcihnZW9tZXRyeSk7XG4gICAgd3JhcEFyb3VuZChvdXRTUi53a2lkLCBnZW9tKTtcbiAgICAvLyBnZW9ncmFwaGljVG9XZWJNZXJjYXRvciByZXR1cm5zIDEwMjEwMDsgbWFrZSBzdXJlIGl0J3Mgd2hhdCB3ZSB3YW50XG4gICAgZ2VvbS5zcGF0aWFsUmVmZXJlbmNlLndraWQgPSBvdXRTUi53a2lkO1xuICAgIHJldHVybiBbZ2VvbV07XG4gIH1cbiAgaWYgKG1lcmNhdG9yLmluZGV4T2Yod2tpZCkgPiAtMSAmJiBvdXRTUi53a2lkID09PSA0MzI2KSB7XG4gICAgZ2VvbSA9IG1lcmNhdG9yVXRpbHMud2ViTWVyY2F0b3JUb0dlb2dyYXBoaWMoZ2VvbWV0cnkpO1xuICAgIHdyYXBBcm91bmQob3V0U1Iud2tpZCwgZ2VvbSk7XG4gICAgcmV0dXJuIFtnZW9tXTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZ2VvbWV0cnlTZXJ2aWNlID0gY29uZmlnU3RhdGUuYXBpID09PSA0ID8gR2VvbWV0cnlTZXJ2aWNlIDogbmV3IEdlb21ldHJ5U2VydmljZShwb3J0YWwuaGVscGVyU2VydmljZXMuZ2VvbWV0cnkudXJsKTtcbiAgICAgIGNvbnN0IGZpcnN0SGFuZGxlciA9IChyZXN1bHQpID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgcmVzcG9uc2UgaXMgdmFsaWRcbiAgICAgICAgY29uc3QgZmlyc3QgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHRbMF07XG4gICAgICAgIGlmICgoZmlyc3QgPT09IG51bGwgfHwgZmlyc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0LnR5cGUpID09PSBcImV4dGVudFwiICYmXG4gICAgICAgICAgIWlzTmFOKHJlc3VsdFswXS54bWluKSAmJlxuICAgICAgICAgICFpc05hTihyZXN1bHRbMF0ueW1pbikgJiZcbiAgICAgICAgICAhaXNOYU4ocmVzdWx0WzBdLnhtYXgpICYmXG4gICAgICAgICAgIWlzTmFOKHJlc3VsdFswXS55bWF4KSkge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZmlyc3QgPT09IG51bGwgfHwgZmlyc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0LnR5cGUpID09PSBcInBvaW50XCIgJiYgIWlzTmFOKHJlc3VsdFswXS54KSAmJiAhaXNOYU4ocmVzdWx0WzBdLnkpKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFtfUHJvamVjdFBhcmFtZXRlcnNdID0gKGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvcmVzdC9zdXBwb3J0L1Byb2plY3RQYXJhbWV0ZXJzXCJdKSk7XG4gICAgICAgICAgY29uc3QgcHJvamVjdFBhcmFtZXRlcnMgPSBuZXcgX1Byb2plY3RQYXJhbWV0ZXJzKHsgZ2VvbWV0cmllczogW2dlb21ldHJ5XSwgb3V0U3BhdGlhbFJlZmVyZW5jZTogb3V0U1IgfSk7XG4gICAgICAgICAgZmlyc3RIYW5kbGVyKGF3YWl0IGdlb21ldHJ5U2VydmljZS5wcm9qZWN0KHBvcnRhbC5oZWxwZXJTZXJ2aWNlcy5nZW9tZXRyeS51cmwsIHByb2plY3RQYXJhbWV0ZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGdlb21ldHJ5U2VydmljZS5wcm9qZWN0KFtnZW9tZXRyeV0sIG91dFNSLCBmaXJzdEhhbmRsZXIsIChlcnIpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2plY3QoZXh0ZW50LCB0b0V4dGVudCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IFtFeHRlbnRdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9nZW9tZXRyeS9FeHRlbnRcIl0pO1xuICBjb25zdCB3b3JsZEV4dGVudCA9IG5ldyBFeHRlbnQod29ybGRFeHRlbnRJbmZvKTtcbiAgY29uc3QgZnVsbEV4dGVudCA9IG5ldyBFeHRlbnQoZXh0ZW50KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvamVjdEV4dGVudChmdWxsRXh0ZW50LCB0b0V4dGVudCk7XG4gIHJldHVybiAoKF9hID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0WzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiZXh0ZW50XCIgPyByZXN1bHRbMF0gOiB3b3JsZEV4dGVudDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNhbWVTcGF0aWFsUmVmZXJlbmNlKHNwMSwgc3AyKSB7XG4gIGNvbnN0IG1lcmNhdG9yID0gWzEwMjExMywgMTAyMTAwLCAzODU3XTtcbiAgaWYgKCgoc3AxID09PSBudWxsIHx8IHNwMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AxLndrdCkgPT0gKHNwMiA9PT0gbnVsbCB8fCBzcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMi53a3QpICYmICgoc3AxID09PSBudWxsIHx8IHNwMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AxLndraWQpID09IChzcDIgPT09IG51bGwgfHwgc3AyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDIud2tpZCkgfHwgKGlzRGVmaW5lZChzcDEubGF0ZXN0V2tpZCkgJiYgKHNwMSA9PT0gbnVsbCB8fCBzcDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMS5sYXRlc3RXa2lkKSA9PSAoc3AyID09PSBudWxsIHx8IHNwMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AyLndraWQpKSkpIHx8XG4gICAgKGlzRGVmaW5lZChzcDIgPT09IG51bGwgfHwgc3AyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDIubGF0ZXN0V2tpZCkgJiYgKHNwMSA9PT0gbnVsbCB8fCBzcDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMS53a2lkKSA9PSAoc3AyID09PSBudWxsIHx8IHNwMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AyLmxhdGVzdFdraWQpKSB8fFxuICAgIChpc0RlZmluZWQoc3AxID09PSBudWxsIHx8IHNwMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AxLmxhdGVzdFdraWQpICYmIChzcDEgPT09IG51bGwgfHwgc3AxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDEubGF0ZXN0V2tpZCkgPT0gKHNwMiA9PT0gbnVsbCB8fCBzcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMi5sYXRlc3RXa2lkKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIGlmICgoc3AxID09PSBudWxsIHx8IHNwMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AxLndraWQpICYmIChzcDIgPT09IG51bGwgfHwgc3AyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcDIud2tpZCkgJiYgbWVyY2F0b3IuaW5jbHVkZXMoc3AxID09PSBudWxsIHx8IHNwMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3AxLndraWQpICYmIG1lcmNhdG9yLmluY2x1ZGVzKHNwMiA9PT0gbnVsbCB8fCBzcDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwMi53a2lkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEV4dGVudFdpdGhGZWF0dXJlcyhsYXllciwgZXh0ZW50QXNMaXN0KSB7XG4gIGNvbnN0IHsgYXBpIH0gPSBjb25maWdTdGF0ZTtcbiAgY29uc3QgW1NwYXRpYWxSZWZlcmVuY2VdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgIGFwaSA9PT0gNCA/IFwiZXNyaS9nZW9tZXRyeS9TcGF0aWFsUmVmZXJlbmNlXCIgOiBcImVzcmkvU3BhdGlhbFJlZmVyZW5jZVwiXG4gIF0pO1xuICBjb25zdCBbRmVhdHVyZUxheWVyLCBTdHJlYW1MYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9GZWF0dXJlTGF5ZXJcIiwgXCJlc3JpL2xheWVycy9TdHJlYW1MYXllclwiXSk7XG4gIGlmICghbGF5ZXIgfHwgIShsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVMYXllcikgfHwgbGF5ZXIgaW5zdGFuY2VvZiBTdHJlYW1MYXllcikge1xuICAgIHJldHVybiBleHRlbnRBc0xpc3Q7XG4gIH1cbiAgaWYgKGFwaSA9PT0gMykge1xuICAgIC8vIHdlIHdhbnQgdG8gem9vbSB0byB3aGVyZSB3ZSBzZWUgZmVhdHVyZXNcbiAgICBhd2FpdCBsYXllci5hZGRQbHVnaW4oXCJlc3JpL3BsdWdpbnMvRmVhdHVyZUxheWVyU3RhdGlzdGljc1wiKTtcbiAgICBjb25zdCBpbmZvID0gYXdhaXQgbGF5ZXIuc3RhdGlzdGljc1BsdWdpbi5nZXRTdWdnZXN0ZWRTY2FsZVJhbmdlKCk7XG4gICAgY29uc3QgeyBtaW5TY2FsZSwgY2VudGVyLCByZWxheGVkTWluU2NhbGUgfSA9IGluZm87XG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgLy8gd2UgbmVlZCB0byB1c2UgdGhlIHdpZHRoIHRoZSBzY2FsZSBpcyBjYWxjdWxhdGVkIHdpdGggYW5kIHRoZW4gc2hyaW5rIGRvd24gdGhlIG1hcFxuICAgICAgbGV0IGV4dGVudCA9IGF3YWl0IGdldEV4dGVudEZyb21DZW50ZXIoY2VudGVyLCAxMjgwLCBtaW5TY2FsZSk7XG4gICAgICBpZiAoaW5mby5yZWxheGVkTWluU2NhbGUgPiAwKSB7XG4gICAgICAgIC8vIGFyZSB3ZSBzdGlsbCBpbiB0aGUgc2NhbGUgb2YgdGhlIGxheWVyIGZvciBhIDIwMCB3aWR0aCBtYXA/XG4gICAgICAgIGxldCBzY2FsZSA9IGdldFNjYWxlRm9yRXh0ZW50KGV4dGVudCwgMjAwKTtcbiAgICAgICAgbGV0IHdpZHRoID0gODAwO1xuICAgICAgICB3aGlsZSAoc2NhbGUgPiByZWxheGVkTWluU2NhbGUpIHtcbiAgICAgICAgICBleHRlbnQgPSBnZXRFeHRlbnRGcm9tQ2VudGVyKGNlbnRlciwgd2lkdGgsIG1pblNjYWxlKTtcbiAgICAgICAgICBzY2FsZSA9IGdldFNjYWxlRm9yRXh0ZW50KGV4dGVudCwgMjAwKTtcbiAgICAgICAgICB3aWR0aCAtPSAyMDA7XG4gICAgICAgICAgaWYgKHdpZHRoIDw9IDApIHtcbiAgICAgICAgICAgIC8vIHRoYXQncyBpdCwgd2UgY2FuJ3QgZG8gbW9yZS4gVGh1bWJuYWlsIG1pZ2h0IGxvb2sgZW1wdHkgbm93LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9qZWN0RXh0ZW50KGV4dGVudCwgbmV3IFNwYXRpYWxSZWZlcmVuY2UoeyB3a2lkOiA0MzI2IH0pKTtcbiAgICAgICAgZXh0ZW50QXNMaXN0ID0gW1xuICAgICAgICAgIFtyZXN1bHRbMF0ueG1pbiwgcmVzdWx0WzBdLnltaW5dLFxuICAgICAgICAgIFtyZXN1bHRbMF0ueG1heCwgcmVzdWx0WzBdLnltYXhdXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBleHRlbnRBc0xpc3Q7XG4gICAgICB9XG4gICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVudEFzTGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZXh0ZW50QXNMaXN0O1xuICAgIH1cbiAgfVxuICAvLyBUT0RPOiB1c2UgZXNyaS9zbWFydE1hcHBpbmcvaGV1cmlzdGljcy9zY2FsZVJhbmdlIHRvIHpvb20gdG8gZmVhdHVyZXMuXG4gIHJldHVybiBleHRlbnRBc0xpc3Q7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTY2FsZUZvckV4dGVudChleHRlbnQsIHdpZHRoKSB7XG4gIGNvbnN0IFtlc3JpQ29uZmlnLCBXS0lEVW5pdENvbnZlcnNpb25dID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb25maWdcIiwgXCJlc3JpL1dLSURVbml0Q29udmVyc2lvblwiXSk7XG4gIGNvbnN0IElOQ0hFU19QRVJfTUVURVIgPSAzOS4zNztcbiAgY29uc3QgREVDX0RFR19UT19NRVRFUlMgPSAyMDAxNTA3Ny4wIC8gMTgwLjA7XG4gIGNvbnN0IHNwYXRpYWxSZWYgPSBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZTtcbiAgY29uc3Qgd2tpZCA9IHNwYXRpYWxSZWYgPT09IG51bGwgfHwgc3BhdGlhbFJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BhdGlhbFJlZi53a2lkO1xuICBjb25zdCB3a3QgPSBzcGF0aWFsUmVmID09PSBudWxsIHx8IHNwYXRpYWxSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNwYXRpYWxSZWYud2t0O1xuICBsZXQgdW5pdFZhbHVlID0gbnVsbDtcbiAgaWYgKHdraWQpIHtcbiAgICB1bml0VmFsdWUgPSBXS0lEVW5pdENvbnZlcnNpb24udmFsdWVzW1dLSURVbml0Q29udmVyc2lvblt3a2lkXV07XG4gIH1cbiAgZWxzZSBpZiAoKHdrdCA9PT0gbnVsbCB8fCB3a3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdrdC5zZWFyY2goL15QUk9KQ1MvaSkpICE9PSAtMSkge1xuICAgIC8vIHdlbGwga25vd24gdGV4dCBpcyBQUk9KQ1NcbiAgICBjb25zdCByZXN1bHQgPSAvVU5JVFxcWyhbXlxcXV0rKVxcXVxcXSQvaS5leGVjKHdrdCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdFsxXSkge1xuICAgICAgdW5pdFZhbHVlID0gcGFyc2VGbG9hdChyZXN1bHRbMV0uc3BsaXQoXCIsXCIpWzFdKTtcbiAgICB9XG4gIH1cbiAgLy8gZWxzZSBhc3N1bWVkIHRvIGJlIGluIGRlZ3JlZXNcbiAgcmV0dXJuICgoZXh0ZW50LmdldFdpZHRoKCkgLyB3aWR0aCkgKiAodW5pdFZhbHVlIHx8IERFQ19ERUdfVE9fTUVURVJTKSAqIElOQ0hFU19QRVJfTUVURVIgKiBlc3JpQ29uZmlnLmRlZmF1bHRzLnNjcmVlbkRQSSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRFeHRlbnRGcm9tQ2VudGVyKHBvaW50LCB3aWR0aCwgc2NhbGUpIHtcbiAgY29uc3QgW0V4dGVudF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2dlb21ldHJ5L0V4dGVudFwiXSk7XG4gIGNvbnN0IGV4dGVudCA9IG5ldyBFeHRlbnQocG9pbnQueCAtIDEsIHBvaW50LnkgLSAwLjUsIHBvaW50LnggKyAxLCBwb2ludC55ICsgMC41LCBwb2ludC5zcGF0aWFsUmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldEV4dGVudEZvclNjYWxlKGV4dGVudCwgd2lkdGgsIHNjYWxlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEV4dGVudEZvclNjYWxlKGV4dGVudCwgd2lkdGgsIHNjYWxlKSB7XG4gIGNvbnN0IFtlc3JpQ29uZmlnLCBXS0lEVW5pdENvbnZlcnNpb25dID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9jb25maWdcIiwgXCJlc3JpL1dLSURVbml0Q29udmVyc2lvblwiXSk7XG4gIGNvbnN0IElOQ0hFU19QRVJfTUVURVIgPSAzOS4zNywgREVDX0RFR19UT19NRVRFUlMgPSAyMDAxNTA3Ny4wIC8gMTgwLjAsIGxvb2t1cCA9IFdLSURVbml0Q29udmVyc2lvbjtcbiAgbGV0IHdraWQsIHdrdCwgc3IgPSBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZTtcbiAgaWYgKHNyKSB7XG4gICAgd2tpZCA9IHNyLndraWQ7XG4gICAgd2t0ID0gc3Iud2t0O1xuICB9XG4gIGxldCB1bml0VmFsdWUgPSBudWxsO1xuICBpZiAod2tpZCkge1xuICAgIHVuaXRWYWx1ZSA9IGxvb2t1cC52YWx1ZXNbbG9va3VwW3draWRdXTtcbiAgfVxuICBlbHNlIGlmICh3a3QgJiYgd2t0LnNlYXJjaCgvXlBST0pDUy9pKSAhPT0gLTEpIHtcbiAgICBjb25zdCByZXN1bHQgPSAvVU5JVFxcWyhbXlxcXV0rKVxcXVxcXSQvaS5leGVjKHdrdCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdFsxXSkge1xuICAgICAgdW5pdFZhbHVlID0gcGFyc2VGbG9hdChyZXN1bHRbMV0uc3BsaXQoXCIsXCIpWzFdKTtcbiAgICB9XG4gIH1cbiAgLy8gZWxzZSBhc3N1bWVkIHRvIGJlIGluIGRlZ3JlZXNcbiAgY29uc3QgbmV3RXh0ZW50ID0gZXh0ZW50LmV4cGFuZCgoc2NhbGUgKiB3aWR0aCkgL1xuICAgICgodW5pdFZhbHVlIHx8IERFQ19ERUdfVE9fTUVURVJTKSAqIElOQ0hFU19QRVJfTUVURVIgKiBlc3JpQ29uZmlnLmRlZmF1bHRzLnNjcmVlbkRQSSkgL1xuICAgIGV4dGVudC5nZXRXaWR0aCgpKTtcbiAgcmV0dXJuIG5ld0V4dGVudDtcbn1cbmNvbnN0IGlzVmFsaWRXR1M4NEV4dGVudCA9IChleHRlbnQpID0+IHtcbiAgLy8gVGFrZW4gZnJvbSBEZWZpbmUgRXh0ZW50LmpzXG4gIGNvbnN0IGluUmFuZ2UgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4O1xuICByZXR1cm4gKGluUmFuZ2UoZXh0ZW50LnltYXgsIC05MCwgOTApICYmIC8vIC05MCA8PSBtYXh5IDw9IDkwXG4gICAgaW5SYW5nZShleHRlbnQueW1pbiwgLTkwLCA5MCkgJiYgLy8gLTkwIDw9IG1pbnkgPD0gOTBcbiAgICBpblJhbmdlKGV4dGVudC54bWF4LCAtMTgwLCAxODApICYmIC8vIC0xODAgPD0gbWF4eCA8PSAxODBcbiAgICBpblJhbmdlKGV4dGVudC54bWluLCAtMTgwLCAxODApICYmIC8vIC0xODAgPD0gbWlueCA8PSAxODBcbiAgICBleHRlbnQueW1heCA+IGV4dGVudC55bWluICYmIC8vIG1heHkgPiBtaW55XG4gICAgZXh0ZW50LnhtYXggPiBleHRlbnQueG1pbiAvLyBtYXh4ID4gbWlueFxuICApO1xufTtcbmZ1bmN0aW9uIGV4dGVudFRvU3RyaW5nKGV4dGVudCwgcGxhY2VzID0gNCkge1xuICBpZiAoIWV4dGVudCkge1xuICAgIHJldHVybiBleHRlbnRUb1N0cmluZyh3b3JsZEV4dGVudEluZm8pO1xuICB9XG4gIGlmICh0eXBlb2YgZXh0ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShleHRlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0ZW50WzBdKSAmJiBBcnJheS5pc0FycmF5KGV4dGVudFsxXSkpIHtcbiAgICAgIGxldCBtaW5zO1xuICAgICAgbGV0IG1heHM7XG4gICAgICBpZiAoZXh0ZW50WzBdLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtaW5zID0gZXh0ZW50WzBdO1xuICAgICAgICBtYXhzID0gZXh0ZW50WzFdO1xuICAgICAgfVxuICAgICAgLy8gUmVmZXIgdG8gT0dDRXh0ZW50J3MgYmJveCB0eXBlXG4gICAgICBpZiAoZXh0ZW50WzBdLmxlbmd0aCA9PT0gNCB8fCBleHRlbnRbMF0ubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIG1pbnMgPSBbZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV1dO1xuICAgICAgICBtYXhzID0gW2V4dGVudFswXVsyXSwgZXh0ZW50WzBdWzNdXTtcbiAgICAgICAgaWYgKGV4dGVudFswXS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICBtYXhzID0gW2V4dGVudFswXVszXSwgZXh0ZW50WzBdWzRdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGAke21pbnMuam9pbihcIixcIil9LCR7bWF4cy5qb2luKFwiLFwiKX1gO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW50LmpvaW4oXCIsXCIpO1xuICB9XG4gIGNvbnN0IHhtaW4gPSBleHRlbnQueG1pbi50b0ZpeGVkKHBsYWNlcyk7XG4gIGNvbnN0IHltaW4gPSBleHRlbnQueW1pbi50b0ZpeGVkKHBsYWNlcyk7XG4gIGNvbnN0IHhtYXggPSBleHRlbnQueG1heC50b0ZpeGVkKHBsYWNlcyk7XG4gIGNvbnN0IHltYXggPSBleHRlbnQueW1heC50b0ZpeGVkKHBsYWNlcyk7XG4gIHJldHVybiBgJHt4bWlufSwke3ltaW59LCR7eG1heH0sJHt5bWF4fWA7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFkZEtNTFVybChpdGVtUHJvcGVydGllcywgY29uZmlnLCBhcGkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbZXh0ZW50LCB0aHVtYm5haWxVUkxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgc2V0S21sRXh0ZW50KGl0ZW1Qcm9wZXJ0aWVzLnVybCwgY29uZmlnLCBhcGkpLFxuICAgICAgYnVpbGRUaHVtYm5haWxVUkxGcm9tS01MSXRlbShpdGVtUHJvcGVydGllcylcbiAgICBdKTtcbiAgICByZXR1cm4gYXdhaXQgYWRkVXJsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbVByb3BlcnRpZXMpLCB7IGV4dGVudCwgdGh1bWJuYWlsVVJMIH0pKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2V0S21sRXh0ZW50KHVybCwgY29uZmlnLCBhcGkpIHtcbiAgY29uc3QgW2VzcmlDb25maWcsIEtNTExheWVyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvY29uZmlnXCIsIFwiZXNyaS9sYXllcnMvS01MTGF5ZXJcIl0pO1xuICBpZiAoYXBpID09PSAzKSB7XG4gICAgZXNyaUNvbmZpZy5kZWZhdWx0cy5rbWxTZXJ2aWNlID0gY29uZmlnLmttbFNlcnZpY2U7XG4gIH1cbiAgZWxzZSB7XG4gICAgZXNyaUNvbmZpZy5rbWxTZXJ2aWNlVXJsID0gY29uZmlnLmttbFNlcnZpY2U7XG4gIH1cbiAgaWYgKGFwaSA9PT0gNCkge1xuICAgIGNvbnN0IGttbExheWVyID0gbmV3IEtNTExheWVyKHsgdXJsIH0pO1xuICAgIGF3YWl0IGttbExheWVyLmxvYWQoKTtcbiAgICBjb25zdCBrbWxFeHRlbnQgPSBrbWxMYXllci5mdWxsRXh0ZW50O1xuICAgIGNvbnN0IGV4dGVudCA9IGV4dGVudFRvU3RyaW5nKGttbEV4dGVudCk7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxuICBjb25zdCBrbWxMYXllciA9IG5ldyBLTUxMYXllcih1cmwpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGttbExheWVyLm9uKFwibG9hZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBrbWxFeHRlbnQgPSBhd2FpdCBnZXRLbWxFeHRlbnQoa21sTGF5ZXIpO1xuICAgICAgcmVzb2x2ZShrbWxFeHRlbnQgPyBleHRlbnRUb1N0cmluZyhrbWxFeHRlbnQpIDogdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBrbWxMYXllci5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0S21sRXh0ZW50KGttbExheWVyKSB7XG4gIGNvbnN0IFtncmFwaGljc1V0aWxzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvZ3JhcGhpY3NVdGlsc1wiXSk7XG4gIGNvbnN0IGttbExheWVycyA9IGttbExheWVyLmdldExheWVycygpO1xuICBsZXQga21sRXh0ZW50O1xuICBrbWxMYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgoX2EgPSBsYXllci5ncmFwaGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwKSB7XG4gICAgICBjb25zdCBsYXllckV4dGVudCA9IGdyYXBoaWNzVXRpbHMuZ3JhcGhpY3NFeHRlbnQobGF5ZXIuZ3JhcGhpY3MpO1xuICAgICAga21sRXh0ZW50ID0gIWttbEV4dGVudCA/IGxheWVyRXh0ZW50IDoga21sRXh0ZW50LnVuaW9uKGxheWVyRXh0ZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ga21sRXh0ZW50O1xufVxuY29uc3QgcHJvY2Vzc1Bvc3RBZGRLTUwgPSBhc3luYyAoaXRlbUlkLCBwb3J0YWwsIHJlc3RCYXNlVXJsLCBjb25maWcsIGFwaSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBwb3J0YWwuaXNQb3J0YWwgPyByZXN0QmFzZVVybCA6IGBodHRwczovLyR7cG9ydGFsLnBvcnRhbEhvc3RuYW1lfS9zaGFyaW5nL3Jlc3RgO1xuICAgIGNvbnN0IHVybCA9IHBvcnRhbC5wb3J0YWxIb3N0bmFtZSA/IGAke2Jhc2VVcmx9L2NvbnRlbnQvaXRlbXMvJHtpdGVtSWR9L2RhdGFgIDogYCR7Z2V0SXRlbVVybChpdGVtSWQpfS9kYXRhYDtcbiAgICBjb25zdCBleHRlbnQgPSBhd2FpdCBzZXRLbWxFeHRlbnQodXJsLCBjb25maWcsIGFwaSk7XG4gICAgLy8gVE9ETzogRG91YmxlIGNoZWNrIHJlc3VsdCB0eXBlIG9uIFVSTCByZWZhY3RvclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZUl0ZW0oaXRlbUlkLCB7IHVybCwgZXh0ZW50IH0pO1xuICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gIH1cbn07XG5cbi8qKiBUcnVlIGlmIHggZG9lc24ndCBob2xkIGEgdmFsdWUuICovXG5mdW5jdGlvbiBpc05vbmUoeCkge1xuICByZXR1cm4geCA9PSBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc1RpbGVkSW1hZ2VTZXJ2aWNlTGF5ZXIobGF5ZXIpIHtcbiAgaWYgKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCkge1xuICAgIHJldHVybiBsYXllci50eXBlID09IFwiaW1hZ2VyeS10aWxlXCI7XG4gIH1cbiAgY29uc3QgW1Jhc3RlclhMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9SYXN0ZXJYTGF5ZXJcIl0pO1xuICByZXR1cm4gbGF5ZXIgaW5zdGFuY2VvZiBSYXN0ZXJYTGF5ZXI7XG59XG5hc3luYyBmdW5jdGlvbiBpc0ltYWdlU2VydmljZUxheWVyKGxheWVyKSB7XG4gIGlmIChjb25maWdTdGF0ZS5hcGkgPT09IDQpIHtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCI7XG4gIH1cbiAgY29uc3QgW0FyY0dJU0ltYWdlU2VydmljZUxheWVyLCBBcmNHSVNJbWFnZVNlcnZpY2VWZWN0b3JMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgXCJlc3JpL2xheWVycy9BcmNHSVNJbWFnZVNlcnZpY2VMYXllclwiLFxuICAgIFwiZXNyaS9sYXllcnMvQXJjR0lTSW1hZ2VTZXJ2aWNlVmVjdG9yTGF5ZXJcIlxuICBdKTtcbiAgcmV0dXJuIGxheWVyIGluc3RhbmNlb2YgQXJjR0lTSW1hZ2VTZXJ2aWNlTGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBBcmNHSVNJbWFnZVNlcnZpY2VWZWN0b3JMYXllcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldERlZmF1bHRQb3B1cEluZm8obGF5ZXJJbmZvLCBsYXllcikge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBkaXNwbGF5RmllbGQgPSBsYXllckluZm8uZGlzcGxheUZpZWxkO1xuICBjb25zdCB0aXRsZSA9IGxheWVySW5mby5uYW1lICsgKChkaXNwbGF5RmllbGQgPT09IG51bGwgfHwgZGlzcGxheUZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXNwbGF5RmllbGQubGVuZ3RoKSA/IGA6IHske2Rpc3BsYXlGaWVsZH19YCA6IFwiXCIpO1xuICBsZXQgZmllbGRzID0gbGF5ZXJJbmZvLmZpZWxkcztcbiAgbGV0IGlzTW9zYWljRGF0YXNldFNlcnZpY2UgPSBmYWxzZTtcbiAgbGV0IGlzVmVjdG9yTW9zYWljRGF0YXNldFNlcnZpY2UgPSBmYWxzZTtcbiAgbGV0IGlzSW50ZWdlckltYWdlU2VydmljZSA9IGZhbHNlO1xuICBjb25zdCBpc0ltYWdlU2VydmljZSA9IGF3YWl0IGlzSW1hZ2VTZXJ2aWNlTGF5ZXIobGF5ZXIpO1xuICBjb25zdCBpc1RpbGVkSW1hZ2VTZXJ2aWNlID0gYXdhaXQgaXNUaWxlZEltYWdlU2VydmljZUxheWVyKGxheWVyKTtcbiAgaWYgKGlzSW1hZ2VTZXJ2aWNlIHx8IGlzVGlsZWRJbWFnZVNlcnZpY2UpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyByYXN0ZXJBdHRyaWJ1dGVUYWJsZUZpZWxkUHJlZml4OiBcIlJhc3Rlci5cIiB9O1xuICAgIGZpZWxkcyA9IChfYSA9IGxheWVyLmdldEN1c3RvbVJhc3RlckZpZWxkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGF5ZXIsIG9wdGlvbnMpO1xuICAgIGlzSW50ZWdlckltYWdlU2VydmljZSA9IFtcIkYzMlwiLCBcIkY2NFwiXS5pbmRleE9mKGxheWVyLnBpeGVsVHlwZSkgPCAwO1xuICAgIC8vY2hlY2tpbmcgZm9yIHNpbmdsZSBkYXRhc2V0IGltYWdlIHNlcnZpY2VcbiAgICBpZiAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmNhcGFiaWxpdGllcykge1xuICAgICAgaXNNb3NhaWNEYXRhc2V0U2VydmljZSA9IChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIuY2FwYWJpbGl0aWVzLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNhdGFsb2dcIikpID4gLTEgfHwgKChfYiA9IGxheWVyLmZpZWxkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkgPiAwO1xuICAgICAgaXNWZWN0b3JNb3NhaWNEYXRhc2V0U2VydmljZSA9XG4gICAgICAgIGlzTW9zYWljRGF0YXNldFNlcnZpY2UgJiZcbiAgICAgICAgICAobGF5ZXIuc2VydmljZURhdGFUeXBlID09PSBcImVzcmlJbWFnZVNlcnZpY2VEYXRhVHlwZVZlY3Rvci1VVlwiIHx8XG4gICAgICAgICAgICBsYXllci5zZXJ2aWNlRGF0YVR5cGUgPT09IFwiZXNyaUltYWdlU2VydmljZURhdGFUeXBlVmVjdG9yLU1hZ0RpclwiKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbCA9IHtcbiAgICBlc3JpRmllbGRUeXBlRG91YmxlOiAxLFxuICAgIGVzcmlGaWVsZFR5cGVTaW5nbGU6IDFcbiAgfTtcbiAgY29uc3QgaW50ZWdlciA9IHtcbiAgICBlc3JpRmllbGRUeXBlSW50ZWdlcjogMSxcbiAgICBlc3JpRmllbGRUeXBlU21hbGxJbnRlZ2VyOiAxXG4gIH07XG4gIGNvbnN0IGR0ID0ge1xuICAgIGVzcmlGaWVsZFR5cGVEYXRlOiAxXG4gIH07XG4gIC8vIGhpZGUgZWRpdG9yIHRyYWNraW5nIGZpZWxkc1xuICBsZXQgZWRpdFRyYWNraW5nRmllbGRzID0gXCIsXCI7XG4gIGlmIChsYXllckluZm8uZWRpdEZpZWxkc0luZm8pIHtcbiAgICBpZiAobGF5ZXJJbmZvLmVkaXRGaWVsZHNJbmZvLmNyZWF0b3JGaWVsZCkge1xuICAgICAgZWRpdFRyYWNraW5nRmllbGRzICs9IGAke2xheWVySW5mby5lZGl0RmllbGRzSW5mby5jcmVhdG9yRmllbGR9LGA7XG4gICAgfVxuICAgIGlmIChsYXllckluZm8uZWRpdEZpZWxkc0luZm8uY3JlYXRpb25EYXRlRmllbGQpIHtcbiAgICAgIGVkaXRUcmFja2luZ0ZpZWxkcyArPSBgJHtsYXllckluZm8uZWRpdEZpZWxkc0luZm8uY3JlYXRpb25EYXRlRmllbGR9LGA7XG4gICAgfVxuICAgIGlmIChsYXllckluZm8uZWRpdEZpZWxkc0luZm8uZWRpdG9yRmllbGQpIHtcbiAgICAgIGVkaXRUcmFja2luZ0ZpZWxkcyArPSBgJHtsYXllckluZm8uZWRpdEZpZWxkc0luZm8uZWRpdG9yRmllbGR9LGA7XG4gICAgfVxuICAgIGlmIChsYXllckluZm8uZWRpdEZpZWxkc0luZm8uZWRpdERhdGVGaWVsZCkge1xuICAgICAgZWRpdFRyYWNraW5nRmllbGRzICs9IGAke2xheWVySW5mby5lZGl0RmllbGRzSW5mby5lZGl0RGF0ZUZpZWxkfSxgO1xuICAgIH1cbiAgICBlZGl0VHJhY2tpbmdGaWVsZHMgPSBlZGl0VHJhY2tpbmdGaWVsZHMudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBjb25zdCBmaWVsZEluZm9zID0gZmllbGRzLm1hcCgoaXRlbSkgPT4ge1xuICAgIGxldCB2aXNpYmxlID0gaXRlbS50eXBlICE9PSBcImVzcmlGaWVsZFR5cGVPSURcIiAmJlxuICAgICAgaXRlbS50eXBlICE9PSBcImVzcmlGaWVsZFR5cGVHbG9iYWxJRFwiICYmXG4gICAgICBpdGVtLnR5cGUgIT09IFwiZXNyaUZpZWxkVHlwZUdlb21ldHJ5XCI7XG4gICAgbGV0IGZvcm1hdCA9IG51bGw7XG4gICAgbGV0IGlzRWRpdGFibGUgPSBpdGVtLmVkaXRhYmxlICYmIGl0ZW0udHlwZSAhPT0gXCJlc3JpRmllbGRUeXBlT0lEXCIgJiYgaXRlbS50eXBlICE9PSBcImVzcmlGaWVsZFR5cGVHbG9iYWxJRFwiO1xuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICBsZXQgZiA9IGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbGV0IGhpZGVGaWVsZHNTdHIgPSBgJHtlZGl0VHJhY2tpbmdGaWVsZHN9c3RyZXRjaGVkIHZhbHVlLGZub2RlXyx0bm9kZV8sbHBvbHlfLHJwb2x5Xyxwb2x5XyxzdWJjbGFzcyxzdWJjbGFzc18scmluZ3Nfb2sscmluZ3Nfbm9rLGA7XG4gICAgICBpZiAoaXNNb3NhaWNEYXRhc2V0U2VydmljZSkge1xuICAgICAgICBoaWRlRmllbGRzU3RyID0gYCR7aGlkZUZpZWxkc1N0cn1yYXN0ZXIuaXRlbXBpeGVsdmFsdWUsYDtcbiAgICAgICAgaWYgKGlzVmVjdG9yTW9zYWljRGF0YXNldFNlcnZpY2UpIHtcbiAgICAgICAgICBoaWRlRmllbGRzU3RyID0gYCR7aGlkZUZpZWxkc1N0cn1yYXN0ZXIubWFnbml0dWRlLHJhc3Rlci5kaXJlY3Rpb24sYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhpZGVGaWVsZHNTdHIuaW5kZXhPZihgLCR7Zn0sYCkgPiAtMSB8fFxuICAgICAgICAvL2YuaW5kZXhPZihcImFyZWFcIikgPiAtMSB8fFxuICAgICAgICAvL2YuaW5kZXhPZihcImxlbmd0aFwiKSA+IC0xIHx8XG4gICAgICAgIGYuaW5kZXhPZihcInNoYXBlXCIpID4gLTEgfHxcbiAgICAgICAgZi5pbmRleE9mKFwicGVyaW1ldGVyXCIpID4gLTEgfHxcbiAgICAgICAgZi5pbmRleE9mKFwib2JqZWN0aWRcIikgPiAtMSB8fFxuICAgICAgICBmLmluZGV4T2YoXCJyYXN0ZXIuc2VydmljZXBpeGVsdmFsdWUuXCIpID4gLTEgfHxcbiAgICAgICAgLy9mLmluZGV4T2YoXCJfXCIpID09IGYubGVuZ3RoIC0gMSB8fFxuICAgICAgICBmLmluZGV4T2YoXCJfaVwiKSA9PSBmLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0udHlwZSBpbiBpbnRlZ2VyKSB7XG4gICAgICAgIGZvcm1hdCA9IHtcbiAgICAgICAgICBwbGFjZXM6IDAsXG4gICAgICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGl0ZW0udHlwZSBpbiBkZWNpbWFsKSB7XG4gICAgICAgIHZhciByYXN0ZXJQaXhlbFZhbHVlRmllbGQgPSBpc0ludGVnZXJJbWFnZVNlcnZpY2UgJiZcbiAgICAgICAgICAoZi5pbmRleE9mKFwicmFzdGVyLnNlcnZpY2VwaXhlbHZhbHVlXCIpID4gLTEgfHwgZi5pbmRleE9mKFwicmFzdGVyLml0ZW1waXhlbHZhbHVlXCIpID4gLTEpO1xuICAgICAgICBmb3JtYXQgPSB7XG4gICAgICAgICAgcGxhY2VzOiByYXN0ZXJQaXhlbFZhbHVlRmllbGQgPyAwIDogMixcbiAgICAgICAgICBkaWdpdFNlcGFyYXRvcjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXRlbS50eXBlIGluIGR0ICYmIChsYXllckluZm8uY3VycmVudFZlcnNpb24gPj0gMTAgfHwgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci52ZXJzaW9uKSA+PSAxMCkpIHtcbiAgICAgICAgZm9ybWF0ID0ge1xuICAgICAgICAgIGRhdGVGb3JtYXQ6IFwibG9uZ01vbnRoRGF5WWVhclwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlzRWRpdGFibGUgPSBpc0VkaXRhYmxlID8gZWRpdFRyYWNraW5nRmllbGRzLmluZGV4T2YoYCwke2l0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpfSxgKSA9PT0gLTEgOiBpc0VkaXRhYmxlO1xuICAgIHJldHVybiB7XG4gICAgICBmaWVsZE5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgIGxhYmVsOiBpdGVtLmFsaWFzLFxuICAgICAgaXNFZGl0YWJsZSxcbiAgICAgIHRvb2x0aXA6IFwiXCIsXG4gICAgICB2aXNpYmxlLFxuICAgICAgZm9ybWF0LFxuICAgICAgc3RyaW5nRmllbGRPcHRpb246IFwidGV4dGJveFwiXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHBvcHVwSW5mbyA9IHtcbiAgICB0aXRsZTogdGl0bGUsXG4gICAgZmllbGRJbmZvczogZmllbGRJbmZvcyxcbiAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICBzaG93QXR0YWNobWVudHM6IHRydWUsXG4gICAgbWVkaWFJbmZvczogW10sXG4gICAgbGF5ZXJPcHRpb25zOiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGlzSW1hZ2VTZXJ2aWNlTGF5ZXIobGF5ZXIpKSB7XG4gICAgcG9wdXBJbmZvLmxheWVyT3B0aW9ucyA9IHt9O1xuICAgIHBvcHVwSW5mby5sYXllck9wdGlvbnMuc2hvd05vRGF0YVJlY29yZHMgPSB0cnVlO1xuICAgIHBvcHVwSW5mby5sYXllck9wdGlvbnMucmV0dXJuVG9wbW9zdFJhc3RlciA9IHRydWU7XG4gIH1cbiAgZWxzZSBpZiAoaXNUaWxlZEltYWdlU2VydmljZUxheWVyKGxheWVyKSkge1xuICAgIHBvcHVwSW5mby5sYXllck9wdGlvbnMgPSB7fTtcbiAgICBwb3B1cEluZm8ubGF5ZXJPcHRpb25zLnNob3dOb0RhdGFSZWNvcmRzID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcG9wdXBJbmZvO1xufVxuXG5jb25zdCBwb2ludEpzb24gPSB7XG4gIHR5cGU6IFwiZXNyaVNNU1wiLFxuICBzdHlsZTogXCJlc3JpU01TQ2lyY2xlXCIsXG4gIGNvbG9yOiBbMzQsIDExNCwgMTYyLCAxMjhdLFxuICBzaXplOiA2LFxuICBvdXRsaW5lOiB7XG4gICAgY29sb3I6IFszNCwgMTE0LCAxNjIsIDI1NV0sXG4gICAgd2lkdGg6IDFcbiAgfVxufTtcbmNvbnN0IGxpbmVKc29uID0ge1xuICB0eXBlOiBcImVzcmlTTFNcIixcbiAgc3R5bGU6IFwiZXNyaVNMU1NvbGlkXCIsXG4gIGNvbG9yOiBbNzcsIDc3LCA3NywgMjU1XSxcbiAgd2lkdGg6IDEuNVxufTtcbmNvbnN0IHBvbHlnb25Kc29uID0ge1xuICB0eXBlOiBcImVzcmlTRlNcIixcbiAgc3R5bGU6IFwiZXNyaVNGU1NvbGlkXCIsXG4gIGNvbG9yOiBbMjI3LCAxMzksIDc5LCAyMDRdLFxuICBvdXRsaW5lOiB7XG4gICAgdHlwZTogXCJlc3JpU0xTXCIsXG4gICAgc3R5bGU6IFwiZXNyaVNMU1NvbGlkXCIsXG4gICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAyNTVdLFxuICAgIHdpZHRoOiAwLjc1XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBnZXRSZW5kZXJlckFzSnNvbihnZW9tZXRyeVR5cGUpIHtcbiAgY29uc3QgW1NpbXBsZVJlbmRlcmVyLCBlc3JpSnNvblV0aWxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgIFwiZXNyaS9yZW5kZXJlcnMvU2ltcGxlUmVuZGVyZXJcIixcbiAgICBjb25maWdTdGF0ZS5hcGkgPT09IDQgPyBcImVzcmkvZ2VvbWV0cnkvc3VwcG9ydC9qc29uVXRpbHNcIiA6IFwiZXNyaS9zeW1ib2xzL2pzb25VdGlsc1wiXG4gIF0pO1xuICBzd2l0Y2ggKGdlb21ldHJ5VHlwZSkge1xuICAgIGNhc2UgXCJlc3JpR2VvbWV0cnlQb2ludFwiOlxuICAgICAgcmV0dXJuIG5ldyBTaW1wbGVSZW5kZXJlcihlc3JpSnNvblV0aWwuZnJvbUpzb24ocG9pbnRKc29uKSkudG9Kc29uKCk7XG4gICAgY2FzZSBcImVzcmlHZW9tZXRyeVBvbHlsaW5lXCI6XG4gICAgICByZXR1cm4gbmV3IFNpbXBsZVJlbmRlcmVyKGVzcmlKc29uVXRpbC5mcm9tSnNvbihsaW5lSnNvbikpLnRvSnNvbigpO1xuICAgIGNhc2UgXCJlc3JpR2VvbWV0cnlQb2x5Z29uXCI6XG4gICAgICByZXR1cm4gbmV3IFNpbXBsZVJlbmRlcmVyKGVzcmlKc29uVXRpbC5mcm9tSnNvbihwb2x5Z29uSnNvbikpLnRvSnNvbigpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQb3B1cEluZm8od2ZzTGF5ZXIpIHtcbiAgY29uc3QgeyBmaWVsZHMsIHNlbGVjdGVkTGF5ZXIgfSA9IHdmc0xheWVyO1xuICBpZiAoZmllbGRzID09PSBudWxsIHx8IGZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRzLmxlbmd0aCkge1xuICAgIGNvbnN0IG5vbkdlb21GaWVsZHMgPSBmaWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQudHlwZSAhPT0gXCJlc3JpRmllbGRUeXBlR2VvbWV0cnlcIik7XG4gICAgaWYgKG5vbkdlb21GaWVsZHMgPT09IG51bGwgfHwgbm9uR2VvbUZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9uR2VvbUZpZWxkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBnZXREZWZhdWx0UG9wdXBJbmZvKHtcbiAgICAgICAgbmFtZTogKHNlbGVjdGVkTGF5ZXIgPT09IG51bGwgfHwgc2VsZWN0ZWRMYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRMYXllci50aXRsZSkgfHwgXCJcIixcbiAgICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICAgIH0sIHdmc0xheWVyKTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdmc0NvbmZpZyh3ZnNMYXllcikge1xuICBjb25zdCB7IGxheWVyTmFtZXNwYWNlLCBnZXRGZWF0dXJlVXJsLCBzcGF0aWFsUmVmZXJlbmNlcywgZmllbGRzIH0gPSB3ZnNMYXllcjtcbiAgY29uc3QgeyBtYXhGZWF0dXJlcywgZ2VvbWV0cnlUeXBlOiBhZGRJdGVtR2VvbWV0cnlUeXBlIH0gPSBhZGRJdGVtU3RhdGU7XG4gIGxldCB1cmw7XG4gIGxldCBtb2RlO1xuICBsZXQgdmVyc2lvbjtcbiAgbGV0IG5hbWU7XG4gIGlmIChjb25maWdTdGF0ZS5hcGkgPT09IDMpIHtcbiAgICBjb25zdCBkYXRhID0gd2ZzTGF5ZXIudG9Kc29uKCk7XG4gICAgdXJsID0gZGF0YS51cmw7XG4gICAgbW9kZSA9IGRhdGEubW9kZTtcbiAgICB2ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuICAgIG5hbWUgPSBkYXRhLm5hbWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgdjRXRlMgPSB3ZnNMYXllcjtcbiAgICB1cmwgPSB2NFdGUy51cmw7XG4gICAgLy8gbW9kZSA9IHY0V0ZTLm1vZGU7XG4gICAgdmVyc2lvbiA9IFwiMi4wLjBcIjtcbiAgICBuYW1lID0gdjRXRlMubmFtZTtcbiAgfVxuICBjb25zdCBnZW9tZXRyeVR5cGUgPSBhZGRJdGVtR2VvbWV0cnlUeXBlIHx8IHdmc0xheWVyLmdlb21ldHJ5VHlwZSB8fCBcImVzcmlHZW9tZXRyeUNvbXBsZXhcIjtcbiAgcmV0dXJuIHtcbiAgICB1cmwsXG4gICAgbW9kZSxcbiAgICB3ZnNJbmZvOiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgbmFtZSxcbiAgICAgIHdmc05hbWVzcGFjZTogbGF5ZXJOYW1lc3BhY2UsXG4gICAgICBmZWF0dXJlVXJsOiBnZXRGZWF0dXJlVXJsLFxuICAgICAgc3VwcG9ydGVkU3BhdGlhbFJlZmVyZW5jZXM6IHNwYXRpYWxSZWZlcmVuY2VzLFxuICAgICAgY3VzdG9tUGFyYW1ldGVyczogd2ZzTGF5ZXIuY3VzdG9tUGFyYW1ldGVycyB8fCB7fSxcbiAgICAgIG1heEZlYXR1cmVzOiBtYXhGZWF0dXJlcyB8fCB3ZnNMYXllci5tYXhGZWF0dXJlcyB8fCAzMDAwXG4gICAgfSxcbiAgICBsYXllckRlZmluaXRpb246IHtcbiAgICAgIGdlb21ldHJ5VHlwZTogZ2VvbWV0cnlUeXBlLFxuICAgICAgZHJhd2luZ0luZm86IHtcbiAgICAgICAgcmVuZGVyZXI6IGF3YWl0IGdldFJlbmRlcmVyQXNKc29uKGdlb21ldHJ5VHlwZSlcbiAgICAgIH0sXG4gICAgICBzcGF0aWFsUmVmZXJlbmNlOiB7XG4gICAgICAgIHdraWQ6IDQzMjZcbiAgICAgIH0sXG4gICAgICBmaWVsZHNcbiAgICB9LFxuICAgIHBvcHVwSW5mbzogYXdhaXQgZ2V0UG9wdXBJbmZvKHdmc0xheWVyKVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHVtYm5haWxVUkxGcm9tV0ZTSXRlbShleHRlbnQpIHtcbiAgY29uc3QgeyBjb25maWcgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCB3ZWJNYXAgPSB7XG4gICAgYmFzZU1hcDogY29uZmlnLmRlZmF1bHRCYXNlbWFwIHx8IGNvbmZpZy5zZWxmLmRlZmF1bHRCYXNlbWFwLFxuICAgIG9wZXJhdGlvbmFsTGF5ZXJzOiBbXVxuICB9O1xuICBjb25zdCB7IGJhc2VNYXBMYXllcnMgfSA9IHdlYk1hcC5iYXNlTWFwO1xuICAvLyB3ZSBuZWVkIG9ubHkgb25lIGJhc2VtYXAgbGF5ZXIgYW5kIHdlIGhpZGUgaXQgLSB1c2UgbGF5ZXJTZXQgYm9vbCB0byBjaGVjayBpZiBvbmUgaGFzIGJlZW4gc2V0IGFscmVhZHlcbiAgbGV0IGxheWVyU2V0ID0gZmFsc2U7XG4gIGJhc2VNYXBMYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICBpZiAoIWxheWVyLmlzUmVmZXJlbmNlICYmICFsYXllclNldCkge1xuICAgICAgLy8gd2UgbmVlZCBvbmx5IG9uZSBiYXNlbWFwIGxheWVyIGFuZCB3ZSBoaWRlIGl0XG4gICAgICBpZiAoKGNvbmZpZy5hbGxTU0wgfHwgbG9jYXRpb24ucHJvdG9jb2wgPT0gXCJodHRwczpcIikgJiZcbiAgICAgICAgKGlzSG9zdGVkU2VydmljZShsYXllci51cmwpIHx8IHN1cHBvcnRzSHR0cHMobGF5ZXIudXJsKSkpIHtcbiAgICAgICAgbGF5ZXIudXJsID0gbGF5ZXIudXJsLnJlcGxhY2UoXCJodHRwOlwiLCBcImh0dHBzOlwiKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLnZpc2liaWxpdHkgPSBmYWxzZTtcbiAgICAgIGxheWVyU2V0ID0gdHJ1ZTtcbiAgICAgIHdlYk1hcC5iYXNlTWFwLmJhc2VNYXBMYXllcnMgPSBbbGF5ZXJdO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG9wZXJhdGlvbmFsTGF5ZXIgPSB7XG4gICAgdHlwZTogXCJXRlNcIixcbiAgICBsYXllclR5cGU6IFwiV0ZTXCIsXG4gICAgb3BhY2l0eTogMSxcbiAgICB2aXNpYmlsaXR5OiB0cnVlLFxuICAgIGlkOiBcIndmc194eHhcIixcbiAgICB3ZnNJbmZvOiB7XG4gICAgICBtYXhGZWF0dXJlczogMTAwXG4gICAgfVxuICB9O1xuICB3ZWJNYXAub3BlcmF0aW9uYWxMYXllcnMucHVzaChvcGVyYXRpb25hbExheWVyKTtcbiAgcmV0dXJuIGJ1aWxkVGh1bWJuYWlsVVJMRnJvbUl0ZW1XZWJNYXAod2ViTWFwLCBleHRlbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V01UU0NvbmZpZyh3bXRzTGF5ZXIpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBpczR4QVBJID0gY29uZmlnU3RhdGUuYXBpID09PSA0O1xuICBmdW5jdGlvbiBnZXRUaWxlSW5mb0FzSnNvbihzZWxlY3RlZFRpbGVJbmZvKSB7XG4gICAgY29uc3QgeyB0aWxlSW5mbyB9ID0gc2VsZWN0ZWRUaWxlSW5mbztcbiAgICBpZiAoKHRpbGVJbmZvID09PSBudWxsIHx8IHRpbGVJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aWxlSW5mby5kcGkpICE9PSA5Nikge1xuICAgICAgdGlsZUluZm8ubG9kcy5mb3JFYWNoKChsb2QpID0+IHtcbiAgICAgICAgbG9kLnNjYWxlID0gKGxvZC5zY2FsZSAqIDk2KSAvIHRpbGVJbmZvLmRwaTtcbiAgICAgIH0pO1xuICAgICAgdGlsZUluZm8uZHBpID0gOTY7XG4gICAgfVxuICAgIHJldHVybiBpczR4QVBJID8gdGlsZUluZm8gOiB0aWxlSW5mby50b0pzb24oKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDb3B5cmlnaHQoY29weXJpZ2h0KSB7XG4gICAgaWYgKChjb3B5cmlnaHQgPT09IG51bGwgfHwgY29weXJpZ2h0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb3B5cmlnaHQudG9Mb3dlckNhc2UoKSkgIT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gKGNvcHlyaWdodCA9PT0gbnVsbCB8fCBjb3B5cmlnaHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvcHlyaWdodC5sZW5ndGgpID4gMTgwID8gYCR7Y29weXJpZ2h0LnN1YnN0cmluZygwLCAxODApfS4uYCA6IFwiXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGNvcHlyaWdodDtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBbU3BhdGlhbFJlZmVyZW5jZV0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICBpczR4QVBJID8gXCJlc3JpL2dlb21ldHJ5L1NwYXRpYWxSZWZlcmVuY2VcIiA6IFwiZXNyaS9TcGF0aWFsUmVmZXJlbmNlXCJcbiAgICBdKTtcbiAgICBjb25zdCB7IHNlbGVjdGVkTGF5ZXIsIHNlbGVjdGVkVGlsZUluZm8sIGNvcHlyaWdodCB9ID0gd210c0xheWVyO1xuICAgIGNvbnN0IHNyID0gKHNlbGVjdGVkVGlsZUluZm8gPT09IG51bGwgfHwgc2VsZWN0ZWRUaWxlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWRUaWxlSW5mby5mdWxsRXh0ZW50LnNwYXRpYWxSZWZlcmVuY2UpIHx8IG5ldyBTcGF0aWFsUmVmZXJlbmNlKHsgd2tpZDogNDMyNiB9KTtcbiAgICBjb25zdCBmdWxsRXh0ZW50ID0gYXdhaXQgcHJvamVjdEV4dGVudChzZWxlY3RlZExheWVyID09PSBudWxsIHx8IHNlbGVjdGVkTGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkTGF5ZXJbaXM0eEFQSSA/IFwiZnVsbEV4dGVudFwiIDogXCJnY3NFeHRlbnRcIl0sIHNyKS50aGVuKChyZXN1bHQpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdFswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcImV4dGVudFwiID8gKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCA/IHJlc3VsdFswXSA6IHJlc3VsdFswXS50b0pzb24oKSkgOiBudWxsOyB9KTtcbiAgICBjb25zdCBmb3JtYXQgPSBzZWxlY3RlZExheWVyW2lzNHhBUEkgPyBcImltYWdlRm9ybWF0XCIgOiBcImZvcm1hdHNcIl0uaW5kZXhPZihcImltYWdlL3BuZ1wiKSA+IC0xXG4gICAgICA/IFwiaW1hZ2UvcG5nXCJcbiAgICAgIDogc2VsZWN0ZWRMYXllci5mb3JtYXRzWzBdO1xuICAgIHdtdHNMYXllci5yZXNvdXJjZVVybHMgPSBzZWxlY3RlZExheWVyLnJlc291cmNlVXJscztcbiAgICBsZXQgdGVtcGxhdGVVcmw7XG4gICAgaWYgKGlzNHhBUEkpIHtcbiAgICAgIHRlbXBsYXRlVXJsID0gd210c0xheWVyLmdldFVybFRlbXBsYXRlKHNlbGVjdGVkTGF5ZXIuaWQsIHNlbGVjdGVkVGlsZUluZm8uaWQsIGZvcm1hdCwgc2VsZWN0ZWRMYXllci5zdHlsZUlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZW1wbGF0ZVVybCA9IHdtdHNMYXllci5nZXRUaWxlVXJsVGVtcGxhdGUoe1xuICAgICAgICBpZGVudGlmaWVyOiBzZWxlY3RlZExheWVyLmlkZW50aWZpZXIsXG4gICAgICAgIHRpbGVNYXRyaXhTZXQ6IHNlbGVjdGVkVGlsZUluZm8udGlsZU1hdHJpeFNldCxcbiAgICAgICAgZm9ybWF0XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgd210c0NvbmZpZyA9IHtcbiAgICAgIHRlbXBsYXRlVXJsLFxuICAgICAgY29weXJpZ2h0OiBnZXRDb3B5cmlnaHQoY29weXJpZ2h0KSxcbiAgICAgIGZ1bGxFeHRlbnQ6IGZ1bGxFeHRlbnQgfHwgd210c0xheWVyLnNlbGVjdGVkVGlsZUluZm8uZnVsbEV4dGVudCxcbiAgICAgIHRpbGVJbmZvOiBnZXRUaWxlSW5mb0FzSnNvbihzZWxlY3RlZFRpbGVJbmZvKSxcbiAgICAgIHdtdHNJbmZvOiB7XG4gICAgICAgIHVybDogKF9hID0gd210c0xheWVyLndtdHNVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdtdHNMYXllci51cmwsXG4gICAgICAgIGxheWVySWRlbnRpZmllcjogc2VsZWN0ZWRMYXllci5pZGVudGlmaWVyLFxuICAgICAgICB0aWxlTWF0cml4U2V0OiBzZWxlY3RlZFRpbGVJbmZvLnRpbGVNYXRyaXhTZXQsXG4gICAgICAgIGN1c3RvbVBhcmFtZXRlcnM6IHdtdHNMYXllci5jdXN0b21QYXJhbWV0ZXJzIHx8IHt9LFxuICAgICAgICBjdXN0b21MYXllclBhcmFtZXRlcnM6IHdtdHNMYXllci5jdXN0b21MYXllclBhcmFtZXRlcnMgfHwge31cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB3bXRzQ29uZmlnOiB3bXRzQ29uZmlnLCBmdWxsRXh0ZW50OiBmdWxsRXh0ZW50IH0pO1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHRocm93IGVycm9yOyAvLyBUT0RPOiByZWZhY3RvciB0aGlzIHRvIG91ciBlcnJvciBzeXN0ZW1cbiAgfVxufVxuLyoqIEhBWkFSRCBXQVJOSU5HISBSZXR1cm4gYSBVUkwgdG8gdGhlIGhvc3RlZCBpbWFnZSBpbiAzLnggY2FzZSBhbmQgYmFzZTY0IGRhdGEgdXJsIGluIDQueCBjYXNlKi9cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVGh1bWJuYWlsVVJMRnJvbVdNVFNJdGVtKGl0ZW0sIG5ld0V4dGVudCkge1xuICBpZiAoY29uZmlnU3RhdGUuYXBpID09PSAzKSB7XG4gICAgY29uc3QgYmFzZU1hcExheWVyT3B0cyA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB2aXNpYmlsaXR5OiB0cnVlLFxuICAgICAgbGF5ZXJUeXBlOiBcIldlYlRpbGVkTGF5ZXJcIixcbiAgICAgIHR5cGU6IFwiV2ViVGlsZWRMYXllclwiXG4gICAgfTtcbiAgICBjb25zdCB3ZWJNYXAgPSB7XG4gICAgICBiYXNlTWFwOiB7XG4gICAgICAgIHRpdGxlOiBcImJhc2VtYXBcIixcbiAgICAgICAgYmFzZU1hcExheWVyczogW10sXG4gICAgICAgIG9wZXJhdGlvbmFsTGF5ZXJzOiBbXVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGl0ZW0uaWQpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0SXRlbURhdGEoaXRlbS5pZCk7XG4gICAgICB3ZWJNYXAuYmFzZU1hcC5iYXNlTWFwTGF5ZXJzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSksIGJhc2VNYXBMYXllck9wdHMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3ZWJNYXAuYmFzZU1hcC5iYXNlTWFwTGF5ZXJzLnB1c2goYmFzZU1hcExheWVyT3B0cyk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZFRodW1ibmFpbFVSTEZyb21XZWJNYXAod2ViTWFwLCBuZXdFeHRlbnQgfHwgaXRlbS5leHRlbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IFtXTVRTTGF5ZXIsIE1hcCwgTWFwVmlldywgcmVhY3RpdmVVdGlsc10gPSAoYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgICAgXCJlc3JpL2xheWVycy9XTVRTTGF5ZXJcIixcbiAgICAgIFwiZXNyaS9NYXBcIixcbiAgICAgIFwiZXNyaS92aWV3cy9NYXBWaWV3XCIsXG4gICAgICBcImVzcmkvY29yZS9yZWFjdGl2ZVV0aWxzXCJcbiAgICBdKSk7XG4gICAgY29uc3Qgd210c0xheWVyID0gbmV3IFdNVFNMYXllcih7XG4gICAgICBwb3J0YWxJdGVtOiB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAvLyBAdHMtaWdub3JlIC0tLSBVc2VyLnJvbGUgaXMgZGlmZmVyZW50IGluIDN4XG4gICAgICAgIHBvcnRhbDogY29uZmlnU3RhdGUucG9ydGFsXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCh7IGxheWVyczogW3dtdHNMYXllcl0gfSk7XG4gICAgY29uc3QgaGlkZGVuTWFwSWQgPSBjcmVhdGVIaWRkZW5NYXBEaXYoKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IE1hcFZpZXcoeyBjb250YWluZXI6IGhpZGRlbk1hcElkLCBtYXAgfSk7XG4gICAgYXdhaXQgcmVhY3RpdmVVdGlscy53aGVuT25jZSgoKSA9PiAhdmlldy51cGRhdGluZyk7XG4gICAgYXdhaXQgdmlldy5nb1RvKHdtdHNMYXllci5mdWxsRXh0ZW50KTtcbiAgICBjb25zdCBzY3JlZW5zaG90ID0gYXdhaXQgdmlldy50YWtlU2NyZWVuc2hvdCh7XG4gICAgICB3aWR0aDogdmlldy53aWR0aCxcbiAgICAgIGhlaWdodDogdmlldy5oZWlnaHQsXG4gICAgICBmb3JtYXQ6IFwicG5nXCJcbiAgICB9KTtcbiAgICByZXR1cm4gc2NyZWVuc2hvdC5kYXRhVXJsO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRJdGVtRGF0YShpZCkge1xuICBjb25zdCB7IGNvbmZpZyB9ID0gY29uZmlnU3RhdGU7XG4gIGNvbnN0IHVybCA9IGAke2NvbmZpZy5yZXN0QmFzZVVybH1jb250ZW50L2l0ZW1zLyR7aWR9L2RhdGFgO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QodXJsLCBudWxsLCB7XG4gICAgICBkaXNhYmxlSWRlbnRpdHlMb29rdXA6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0ICYmICgocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0Lndmc0luZm8pIHx8IHJlc3VsdC53bXRzSW5mbykpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5sYXllcnMpIHtcbiAgICAgIHJldHVybiByZXN1bHQubGF5ZXJzO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRpY0ltYWdlc1VybChwb3J0YWwpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5zdGF0aWNJbWFnZXNVcmwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKFwiaHR0cDpcIiwgXCJodHRwczpcIikpIHx8IFwiXCI7XG59XG5jb25zdCBjaGVja1RodW1ibmFpbFVSTCA9IChpdGVtKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgcG9ydGFsID0gY29uZmlnU3RhdGUucG9ydGFsO1xuICBpZiAoaXRlbS50aHVtYm5haWxVUkwpIHtcbiAgICBpdGVtLnRodW1ibmFpbFVSTCA9IGdldFN0YXRpY0ltYWdlc1VybChwb3J0YWwpICsgaXRlbS50aHVtYm5haWxVUkw7XG4gIH1cbiAgaWYgKHBvcnRhbC5pc1BvcnRhbCAmJiAoKF9hID0gaXRlbS50aHVtYm5haWxVUkwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleE9mKFwiaHR0cFwiKSkgIT09IDApIHtcbiAgICAvLyBzdGF0aWNJbWFnZXNVcmwgaXMgcmVsYXRpdmVcbiAgICBpdGVtLnRodW1ibmFpbFVSTCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgaXRlbS50aHVtYm5haWxVUkw7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5jb25zdCBzdHJpcFBhcmFtZXRlcnMgPSAodXJsLCBibGFja0xpc3QpID0+IHtcbiAgY29uc3QgW2Jhc2UsIHNlYXJjaF0gPSB1cmwuc3BsaXQoXCI/XCIpO1xuICBjb25zdCB3aGl0ZWxpc3RlZCA9IChzZWFyY2ggPT09IG51bGwgfHwgc2VhcmNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2guc3BsaXQoXCImXCIpLnJlZHVjZSgoYWNjLCBzZWN0aW9uKSA9PiB7XG4gICAgY29uc3QgW2tleV0gPSBzZWN0aW9uLnNwbGl0KFwiPVwiKTtcbiAgICBpZiAoYmxhY2tMaXN0LmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGAke2FjY30ke2FjYyA/IFwiJlwiIDogXCI/XCJ9JHtzZWN0aW9ufWA7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIFwiXCIpKSB8fCBcIlwiO1xuICByZXR1cm4gYCR7YmFzZX0ke3doaXRlbGlzdGVkfWA7XG59O1xuY29uc3QgZ2V0V01TU2VydmljZUluZm8gPSBhc3luYyAoaXRlbSkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IFtXTVNMYXllcl0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2xheWVycy9XTVNMYXllclwiXSk7XG4gIGNvbnN0IHsgY3VzdG9tUGFyYW1ldGVycyB9ID0gaXRlbTtcbiAgY29uc3QgZm9ybWF0dGVkUGFyYW1zID0gZm9ybWF0Q3VzdG9tUGFyYW1ldGVycyhjdXN0b21QYXJhbWV0ZXJzKTtcbiAgLy8gUmVtb3ZlIHRoZXNlIHBhcmFtZXRlcnMgZnJvbSB0aGUgdXJsIHNpbmNlIHRoZSBKU0FQSSB3aWxsIHNldCB0aGVtIGF1dG9tYXRpY2FsbHlcbiAgY29uc3Qgd21zVXJsID0gc3RyaXBQYXJhbWV0ZXJzKGl0ZW0udXJsLCBbXG4gICAgXCJzZXJ2aWNlXCIsXG4gICAgXCJyZXF1ZXN0XCIsXG4gICAgXCJiYm94XCIsXG4gICAgXCJmb3JtYXRcIixcbiAgICBcImhlaWdodFwiLFxuICAgIFwid2lkdGhcIixcbiAgICBcImxheWVyc1wiLFxuICAgIFwic3JzXCIsXG4gICAgXCJjcnNcIixcbiAgICBcInN0eWxlc1wiLFxuICAgIFwidHJhbnNwYXJlbnRcIixcbiAgICBcImJnY29sb3JcIixcbiAgICBcImV4Y2VwdGlvbnNcIixcbiAgICBcInRpbWVcIixcbiAgICBcImVsZXZhdGlvblwiLFxuICAgIFwic2xkXCIsXG4gICAgXCJ3ZnNcIlxuICBdKTtcbiAgdHJ5IHtcbiAgICBpZiAoY29uZmlnU3RhdGUuYXBpID09PSA0KSB7XG4gICAgICBjb25zdCB3bXNMYXllciA9IG5ldyBXTVNMYXllcih7XG4gICAgICAgIHVybDogd21zVXJsLFxuICAgICAgICBjdXN0b21QYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBmb3JtYXR0ZWRQYXJhbXMgPT09IG51bGwgfHwgZm9ybWF0dGVkUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXR0ZWRQYXJhbXMuY3VzdG9tUGFyYW1ldGVycykgfHwge30sXG4gICAgICAgIGN1c3RvbUxheWVyUGFyYW1ldGVyczogT2JqZWN0LmFzc2lnbih7fSwgZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbUxheWVyUGFyYW1ldGVycykgfHwge31cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbG9hZGVkTGF5ZXIgPSBhd2FpdCB3bXNMYXllci5sb2FkKCk7XG4gICAgICAgIGl0ZW0udHlwZSA9IFwiV01TXCI7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBcIldNU1wiLCBzZXJ2aWNlSW5mbzogbG9hZGVkTGF5ZXIgfSkgfTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgY29kZTogZXJyLm1lc3NhZ2UgPyBcInVuaGFuZGxlZEVycm9yXCIgOiBcInNlcnZpY2VOb3RFeGlzdFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogKF9hID0gZXJyLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVyci5tZXNzYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0gdjMgLS0tXG4gICAgYXdhaXQgY2hlY2tDT1JTKHdtc1VybCk7XG4gICAgY29uc3Qgd21zTGF5ZXIgPSBuZXcgV01TTGF5ZXIod21zVXJsLCB7XG4gICAgICBjdXN0b21QYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBmb3JtYXR0ZWRQYXJhbXMgPT09IG51bGwgfHwgZm9ybWF0dGVkUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXR0ZWRQYXJhbXMuY3VzdG9tUGFyYW1ldGVycykgfHwge30sXG4gICAgICBjdXN0b21MYXllclBhcmFtZXRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGZvcm1hdHRlZFBhcmFtcyA9PT0gbnVsbCB8fCBmb3JtYXR0ZWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRlZFBhcmFtcy5jdXN0b21MYXllclBhcmFtZXRlcnMpIHx8IHt9XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgd21zTGF5ZXIub24oXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgaXRlbS50eXBlID0gXCJXTVNcIjtcbiAgICAgICAgcmVzb2x2ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IHR5cGU6IFwiV01TXCIsIHNlcnZpY2VJbmZvOiB3bXNMYXllciB9KSk7XG4gICAgICB9KTtcbiAgICAgIHdtc0xheWVyLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGVycjtcbiAgICAgICAgY29uc3Qgc2VydmljZU5vdEV4aXN0ID0gIShlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgfHwgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5zdGF0dXMpID09PSA0MDQ7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgY29kZTogc2VydmljZU5vdEV4aXN0ID8gXCJzZXJ2aWNlTm90RXhpc3RcIiA6IFwidW5oYW5kbGVkRXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiAoX2EgPSBlcnJvci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlcnIubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbn07XG4vLyB0aGlzIHdpbGwgY29ycmVjdGx5IGZvcm1hdCB0aGUgbGF5ZXJzIGZyb20gdGhlIHNlcnZpY2UgaW5mbyB0byBiZSB1c2VkIGluIHRoZSBidWxrIGxheWVyIHNlbGVjdCBjb21wb25lbnRcbmNvbnN0IGxvYWRXTVNMYXllcnMgPSBhc3luYyAoc2VydmljZUluZm8pID0+IHtcbiAgY29uc3QgbG9hZGVkU2VydmljZUluZm8gPSBjb25maWdTdGF0ZS5hcGkgPT09IDQgPyBhd2FpdCBzZXJ2aWNlSW5mby5sb2FkKCkgOiBzZXJ2aWNlSW5mbztcbiAgY29uc3QgeyBsYXllckluZm9zLCB0aXRsZSwgYWxsU3VibGF5ZXJzIH0gPSBsb2FkZWRTZXJ2aWNlSW5mbztcbiAgY29uc3QgbGF5ZXJzID0gZ2V0V01TTGF5ZXJUcmVlKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCA/IGFsbFN1YmxheWVycy5pdGVtcyA6IGxheWVySW5mb3MpO1xuICAvLyBUT0RPOiBtb3ZlIHRpdGxlIHRvIGJhc2Ugc2VydmljZUluZm8gZmV0Y2gsIG9ubHkgcmV0dXJuIGxheWVycyBoZXJlXG4gIHJldHVybiB7IHRpdGxlLCBsYXllcnMgfTtcbn07XG5mdW5jdGlvbiBnZXRXTVNMYXllclRyZWUobGF5ZXJzKSB7XG4gIHJldHVybiBsYXllcnMubWFwKChsYXllcikgPT4gKHtcbiAgICBuYW1lOiBsYXllci5uYW1lLFxuICAgIHZpc2libGU6IGZhbHNlLFxuICAgIHRpdGxlOiBsYXllci50aXRsZS5yZXBsYWNlKC8gL2csIFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSksXG4gICAgZXh0ZW50OiBsYXllci5leHRlbnQsXG4gICAgbGVnZW5kVVJMOiBsYXllci5sZWdlbmRVUkwsXG4gICAgcXVlcnlhYmxlOiBsYXllci5xdWVyeWFibGUsXG4gICAgc3ViTGF5ZXJzOiBsYXllci5zdWJMYXllcnMgfHwgW11cbiAgfSkpO1xufVxuZnVuY3Rpb24gZmxhdHRlbkxheWVyQW5kUmVtb3ZlSWRzKGZsYXR0ZW5lZExheWVycyA9IFtdLCBsYXllcikge1xuICBkZWxldGUgbGF5ZXIuaWQ7XG4gIGlmICghbGF5ZXIuc3ViTGF5ZXJzIHx8ICFsYXllci5zdWJMYXllcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFsuLi5mbGF0dGVuZWRMYXllcnMsIGxheWVyXTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbGF5ZXIuc3ViTGF5ZXJzLnJlZHVjZShmbGF0dGVuTGF5ZXJBbmRSZW1vdmVJZHMsIGZsYXR0ZW5lZExheWVycyk7XG4gIH1cbn1cbmNvbnN0IGFkZFdNU1VybCA9IGFzeW5jIChpdGVtKSA9PiB7XG4gIGNvbnN0IFtTcGF0aWFsUmVmZXJlbmNlXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICBjb25maWdTdGF0ZS5hcGkgPT09IDQgPyBcImVzcmkvZ2VvbWV0cnkvU3BhdGlhbFJlZmVyZW5jZVwiIDogXCJlc3JpL1NwYXRpYWxSZWZlcmVuY2VcIlxuICBdKTtcbiAgY29uc3QgeyBsYXllcnMgfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgaWYgKCFpdGVtIHx8ICEoaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLnNlcnZpY2VJbmZvKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzZXJ2aWNlTm90RXhpc3RcIikpO1xuICB9XG4gIGNvbnN0IGl0ZW1JbmZvID0gY2hlY2tUaHVtYm5haWxVUkwoaXRlbSk7XG4gIGNvbnN0IHsgc2VydmljZUluZm8gfSA9IGl0ZW1JbmZvO1xuICBjb25zdCB2aXNpYmxlTGF5ZXJzID0gW107XG4gIGxldCBmdWxsRXh0ZW50O1xuICBjb25zdCBmbGF0dGVuZWRMYXllcnMgPSBsYXllcnMucmVkdWNlKGZsYXR0ZW5MYXllckFuZFJlbW92ZUlkcywgW10pO1xuICBjb25zdCBzZWxlY3RlZExheWVycyA9IGZsYXR0ZW5lZExheWVycy5tYXAoKGxheWVyKSA9PiB7XG4gICAgZnVsbEV4dGVudCA9ICFmdWxsRXh0ZW50ID8gbGF5ZXIuZXh0ZW50IDogbGF5ZXIuZXh0ZW50ID8gZnVsbEV4dGVudC51bmlvbihsYXllci5leHRlbnQpIDogZnVsbEV4dGVudDtcbiAgICB2aXNpYmxlTGF5ZXJzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgY29uc3Qgb2JqID0geyBuYW1lOiBsYXllci5uYW1lLCB0aXRsZTogbGF5ZXIudGl0bGUsIGxlZ2VuZFVSTDogXCJcIiwgcXVlcnlhYmxlOiBsYXllci5xdWVyeWFibGUgfTtcbiAgICBpZiAobGF5ZXIubGVnZW5kVVJMKSB7XG4gICAgICBvYmoubGVnZW5kVVJMID0gbGF5ZXIubGVnZW5kVVJMO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9KTtcbiAgc2VydmljZUluZm8uc2V0VmlzaWJsZUxheWVycyh2aXNpYmxlTGF5ZXJzKTtcbiAgZnVsbEV4dGVudCA9IGZ1bGxFeHRlbnQgfHwgc2VydmljZUluZm8uZnVsbEV4dGVudDtcbiAgY29uc3QgaXNHQ1MgPSAhc2VydmljZUluZm8uc3BhdGlhbFJlZmVyZW5jZXMuc29tZSgoc3IpID0+IHNyID09PSBmdWxsRXh0ZW50LnNwYXRpYWxSZWZlcmVuY2Uud2tpZCk7XG4gIGNvbnN0IHVwZGF0ZWRJdGVtID0ge1xuICAgIHR5cGU6IGl0ZW0udHlwZSxcbiAgICB1cmw6IHNlcnZpY2VJbmZvLnVybCxcbiAgICBkZXNjcmlwdGlvbjogc2VydmljZUluZm8uZGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICBhY2Nlc3NJbmZvcm1hdGlvbjogc2VydmljZUluZm8uY29weXJpZ2h0IHx8IFwiXCIsXG4gICAgdGV4dDogZ2V0V01TRGF0YShzZXJ2aWNlSW5mbywgc2VsZWN0ZWRMYXllcnMpLFxuICAgIGV4dGVudDogZnVsbEV4dGVudFxuICB9O1xuICBpZiAoaXNHQ1MpIHtcbiAgICBwcm9qZWN0KGZ1bGxFeHRlbnQsIG5ldyBTcGF0aWFsUmVmZXJlbmNlKHsgd2tpZDogc2VydmljZUluZm8uc3BhdGlhbFJlZmVyZW5jZXNbMF0gfSkpLnRoZW4oKGV4dGVudCkgPT4gKHVwZGF0ZWRJdGVtLmV4dGVudCA9IGV4dGVudCkpO1xuICB9XG4gIGNvbnN0IGl0ZW1Ub0FkZCA9IGF3YWl0IGdldFdNU0ltYWdlVXJsKHVwZGF0ZWRJdGVtLCBzZXJ2aWNlSW5mbyk7XG4gIHJldHVybiBhZGRVcmwoaXRlbVRvQWRkKTtcbn07XG5jb25zdCBnZXRXTVNJbWFnZVVybCA9IChpdGVtLCB3bXNMYXllcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gKGltYWdlVXJsKSA9PiB7XG4gICAgICByZXNvbHZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgdGh1bWJuYWlsVVJMOiBpbWFnZVVybCB8fCBpdGVtLnRodW1ibmFpbFVSTCwgZXh0ZW50OiBleHRlbnRUb1N0cmluZyhpdGVtLmV4dGVudCkgfSkpO1xuICAgIH07XG4gICAgd21zTGF5ZXIuZ2V0SW1hZ2VVcmwoaXRlbS5leHRlbnQsIDgwMCwgNTMyLCBoYW5kbGVyLCBoYW5kbGVyKTtcbiAgfSk7XG59O1xuY29uc3QgZ2V0V01TRGF0YSA9ICh3bXNMYXllciwgc2VsZWN0ZWRMYXllcnMpID0+IHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICB0aXRsZTogd21zTGF5ZXIudGl0bGUgfHwgXCJcIixcbiAgICB1cmw6IHdtc0xheWVyLnVybCxcbiAgICBtYXBVcmw6IHdtc0xheWVyLmdldE1hcFVSTCxcbiAgICB2ZXJzaW9uOiB3bXNMYXllci52ZXJzaW9uLFxuICAgIGxheWVyczogc2VsZWN0ZWRMYXllcnMsXG4gICAgY29weXJpZ2h0OiB3bXNMYXllci5jb3B5cmlnaHQgfHwgXCJcIixcbiAgICBtYXhIZWlnaHQ6IHdtc0xheWVyLm1heEhlaWdodCxcbiAgICBtYXhXaWR0aDogd21zTGF5ZXIubWF4V2lkdGgsXG4gICAgc3BhdGlhbFJlZmVyZW5jZXM6IHdtc0xheWVyLnNwYXRpYWxSZWZlcmVuY2VzLFxuICAgIGZvcm1hdDogd21zTGF5ZXIuZ2V0SW1hZ2VGb3JtYXQoKSAhPT0gXCJwbmdcIiA/IHdtc0xheWVyLmdldEltYWdlRm9ybWF0KCkgOiBudWxsLFxuICAgIGZlYXR1cmVJbmZvVXJsOiB3bXNMYXllci5nZXRGZWF0dXJlSW5mb1VSTCxcbiAgICBmZWF0dXJlSW5mb0Zvcm1hdDogd21zTGF5ZXIuZmVhdHVyZUluZm9Gb3JtYXQsXG4gICAgY3VzdG9tUGFyYW1ldGVyczogd21zTGF5ZXIuY3VzdG9tUGFyYW1ldGVycyB8fCB7fSxcbiAgICBjdXN0b21MYXllclBhcmFtZXRlcnM6IHdtc0xheWVyLmN1c3RvbUxheWVyUGFyYW1ldGVycyB8fCB7fVxuICB9KTtcbn07XG5jb25zdCBnZXRXRlNWZXJzaW9uRnJvbVVybCA9IGFzeW5jICh1cmwpID0+IHtcbiAgY29uc3QgeyBxdWVyeTogcXVlcnlPYmplY3QgfSA9IGF3YWl0IHVybFRvT2JqZWN0KHVybCk7XG4gIHJldHVybiAocXVlcnlPYmplY3QgPT09IG51bGwgfHwgcXVlcnlPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHF1ZXJ5T2JqZWN0LnZlcnNpb24pIHx8IFwiMi4wLjBcIjtcbn07XG4vKipcbiAqIEZldGNoIGEgdXJsIGFuZCBhZGQgdG8gdGhlIHRydXN0ZWQgZG9tYWlucyBsaXN0IGlmIGl0IHN1cHBvcnRzIENPUlNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2hlY2tDT1JTKHVybCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXN0UmVwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKHRlc3RSZXBvbnNlLnR5cGUgPT09IFwiY29yc1wiICYmIHRlc3RSZXBvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBjb25zdCBkb21haW4gPSBuZXcgVVJMKHVybCkuaG9zdG5hbWU7XG4gICAgICBjb25zdCBbZXNyaUNvbmZpZ10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXCJlc3JpL2NvbmZpZ1wiXSk7XG4gICAgICAoX2MgPSAoX2IgPSAoX2EgPSBlc3JpQ29uZmlnID09PSBudWxsIHx8IGVzcmlDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVzcmlDb25maWcuZGVmYXVsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvcnNFbmFibGVkU2VydmVycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnB1c2goZG9tYWluKTtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IH1cbn1cbmNvbnN0IGdldFdGU1NlcnZpY2VJbmZvID0gYXN5bmMgKGl0ZW0sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgW1dGU0xheWVyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvbGF5ZXJzL1dGU0xheWVyXCJdKTtcbiAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzIH0gPSBhZGRJdGVtU3RhdGU7XG4gIGNvbnN0IHsgdXJsIH0gPSBpdGVtO1xuICBjb25zdCB3ZnNVcmwgPSBzdHJpcFBhcmFtZXRlcnModXJsLCBbXCJ2ZXJzaW9uXCIsIFwic2VydmljZVwiLCBcInJlcXVlc3RcIiwgXCJsYXllclwiLCBcInR5cGVuYW1lXCJdKTtcbiAgY29uc3QgZm9ybWF0dGVkUGFyYW1zID0gZm9ybWF0Q3VzdG9tUGFyYW1ldGVycyhjdXN0b21QYXJhbWV0ZXJzKTtcbiAgY29uc3Qgd2ZzVmVyc2lvbiA9IGF3YWl0IGdldFdGU1ZlcnNpb25Gcm9tVXJsKHVybCk7XG4gIGNvbnN0IHdmc0xheWVyT3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgIHZlcnNpb246IHdmc1ZlcnNpb24sXG4gICAgdXJsOiB3ZnNVcmwsXG4gICAgY3VzdG9tUGFyYW1ldGVyczogKGZvcm1hdHRlZFBhcmFtcyA9PT0gbnVsbCB8fCBmb3JtYXR0ZWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRlZFBhcmFtcy5jdXN0b21QYXJhbWV0ZXJzKSB8fCB7fVxuICB9O1xuICB0cnkge1xuICAgIC8vIFY0IG9ubHkgc3VwcG9ydHMgMi4wLjAgdmVyc2lvblxuICAgIGlmIChjb25maWdTdGF0ZS5hcGkgPT09IDQpIHtcbiAgICAgIGlmICh3ZnNWZXJzaW9uICE9PSBcIjIuMC4wXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bnN1cHBvcnRlZFdGU1ZlcnNpb25cIiB9IH07XG4gICAgICB9XG4gICAgICAvLyB2NCB2ZXJzaW9uIGlzIHJlYWQtb25seVxuICAgICAgZGVsZXRlIHdmc0xheWVyT3B0aW9ucy52ZXJzaW9uO1xuICAgICAgLy8gYW5kIHdlIGRvbid0IG5lZWQgdGhlIHVybFxuICAgICAgZGVsZXRlIHdmc0xheWVyT3B0aW9ucy51cmw7XG4gICAgICBjb25zdCBbd2ZzVXRpbHNdID0gKGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvbGF5ZXJzL29nYy93ZnNVdGlsc1wiXSkpO1xuICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gYXdhaXQgd2ZzVXRpbHMuZ2V0Q2FwYWJpbGl0aWVzKHdmc1VybCwgd2ZzTGF5ZXJPcHRpb25zKTtcbiAgICAgIGNvbnN0IGxheWVycyA9IGNhcGFiaWxpdGllcy5mZWF0dXJlVHlwZXM7XG4gICAgICBpZiAoIWxheWVycyB8fCAhbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImVtcHR5RmVhdHVyZUxheWVyXCIgfSB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxheWVySW5mbyA9IGF3YWl0IHdmc1V0aWxzLmdldFdGU0xheWVySW5mbyhjYXBhYmlsaXRpZXMpO1xuICAgICAgICBjb25zdCB3ZnNMYXllciA9IFdGU0xheWVyLmZyb21XRlNMYXllckluZm8obGF5ZXJJbmZvKTtcbiAgICAgICAgd2ZzTGF5ZXIubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICB3ZnNMYXllci51cmwgPSB3ZnNVcmw7XG4gICAgICAgIHdmc0xheWVyLmlzQ29tcGxleCA9IHdmc0xheWVyLmdlb21ldHJ5VHlwZSA9PT0gXCJlc3JpR2VvbWV0cnlDb21wbGV4XCI7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBcIldGU1wiLCBzZXJ2aWNlSW5mbzogd2ZzTGF5ZXIgfSkgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tIHYzIC0tLVxuICAgIGNvbnN0IHdmc0xheWVyID0gbmV3IFdGU0xheWVyKHdmc0xheWVyT3B0aW9ucyk7XG4gICAgYXdhaXQgY2hlY2tDT1JTKHdmc1VybCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgd2ZzTGF5ZXIuaW5pdGlhbGl6ZSh3ZnNMYXllck9wdGlvbnMsIChsYXllcnMpID0+IHtcbiAgICAgICAgaWYgKCFsYXllcnMgfHwgIWxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICByZWplY3QoeyBjb2RlOiBcImVtcHR5RmVhdHVyZUxheWVyXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgd2ZzTGF5ZXIubGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgICAgIHdmc0xheWVyLnVybCA9IHdmc1VybDtcbiAgICAgICAgICB3ZnNMYXllci5pc0NvbXBsZXggPSB3ZnNMYXllci5nZW9tZXRyeVR5cGUgPT09IFwiZXNyaUdlb21ldHJ5Q29tcGxleFwiO1xuICAgICAgICAgIHJlc29sdmUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBcIldGU1wiLCBzZXJ2aWNlSW5mbzogd2ZzTGF5ZXIgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIFdGUyBsYXllcnMgY2FuIHRocm93IGFuIGVycm9yIGlmIG5vdCB1c2luZyB0aGUgY29ycmVjdCB2ZXJzaW9uIC0gc28gd2UgY2FuIHRyeSB3aXRoIGRpZmZlcmVudCB2ZXJzaW9ucyBmcm9tIG5ld2VzdCB2ZXJzaW9uIHRvIG9sZGVzdFxuICAgICAgd2ZzTGF5ZXIub24oXCJlcnJvclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh3ZnNMYXllci50b0pzb24oKS52ZXJzaW9uID09PSBcIjIuMC4wXCIpIHtcbiAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IGdldFdGU1NlcnZpY2VJbmZvKGl0ZW0sIHsgdmVyc2lvbjogXCIxLjEuMFwiLCB1cmwgfSk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2ZzTGF5ZXIudG9Kc29uKCkudmVyc2lvbiA9PT0gXCIxLjEuMFwiKSB7XG4gICAgICAgICAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBnZXRXRlNTZXJ2aWNlSW5mbyhpdGVtLCB7IHZlcnNpb246IFwiMS4wLjBcIiwgdXJsIH0pO1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlamVjdCh7IGNvZGU6IFwic2VydmljZU5vdEV4aXN0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbn07XG5jb25zdCBhZGRXRlNVcmwgPSBhc3luYyAoaXRlbSkgPT4ge1xuICB2YXIgX2E7XG4gIGlmICghaXRlbSB8fCAhKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbS5zZXJ2aWNlSW5mbykpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwic2VydmljZU5vdEV4aXN0XCIpKTtcbiAgfVxuICBjb25zdCB7IHNlcnZpY2VJbmZvOiB3ZnNMYXllciB9ID0gaXRlbTtcbiAgY29uc3QgZnVsbEV4dGVudCA9ICgoX2EgPSB3ZnNMYXllci5zZWxlY3RlZExheWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnVsbEV4dGVudCkgfHwgW1tdLCBbXV07XG4gIGNvbnN0IHN0cmluZ0V4dGVudCA9IGV4dGVudFRvU3RyaW5nKGZ1bGxFeHRlbnQpO1xuICBjb25zdCBhcnJFeHRlbnQgPSBzdHJpbmdFeHRlbnQuc3BsaXQoXCIsXCIpLm1hcChOdW1iZXIpO1xuICBpZiAoIXdmc0xheWVyLmdlb21ldHJ5VHlwZSB8fCB3ZnNMYXllci5nZW9tZXRyeVR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3NpbmdHZW9tZXRyeVwiKSk7XG4gIH1cbiAgY29uc3QgZm9ybWF0dGVkSXRlbSA9IHsgdHlwZTogaXRlbS50eXBlLCB1cmw6IGl0ZW0udXJsLCB0aHVtYm5haWxVUkw6IGl0ZW0udGh1bWJuYWlsVVJMIH07XG4gIGNvbnN0IHdmc0NvbmZpZyA9IGF3YWl0IGdldFdmc0NvbmZpZyh3ZnNMYXllcik7XG4gIGNvbnN0IGl0ZW1JbmZvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGVja1RodW1ibmFpbFVSTChmb3JtYXR0ZWRJdGVtKSksIHsgdGV4dDogSlNPTi5zdHJpbmdpZnkod2ZzQ29uZmlnKSwgZXh0ZW50OiBzdHJpbmdFeHRlbnQgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWRkVXJsKGl0ZW1JbmZvKTtcbiAgY29uc3QgdXBkYXRlZEl0ZW0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbUluZm8pLCByZXNwb25zZSksIHsgZXh0ZW50OiBbXG4gICAgICBbYXJyRXh0ZW50WzBdLCBhcnJFeHRlbnRbMV1dLFxuICAgICAgW2FyckV4dGVudFsyXSwgYXJyRXh0ZW50WzNdXVxuICAgIF0gfSk7XG4gIC8vIFRPRE86IHlvdSBrbm93IC0gbG9va2luZyBhdCB0aGlzIC0gaSB0aGluayB3ZSBuZWVkIHRvIGFjdHVhbGx5IGNhbGwgdXBkYXRlSXRlbSBvbiBXRlMgaXRlbXMgc2luY2UgaXQgbG9va3MgbGlrZSB0aGUgdGh1bWJuYWlsIHVybCBpc24ndCBhY3R1YWxseSBiZWluZyBzZXQgb24gdGhlIEl0ZW0uIE9vcHMhXG4gIHRyeSB7XG4gICAgY29uc3QgdGh1bWJuYWlsVXJsID0gYXdhaXQgYnVpbGRUaHVtYm5haWxVUkxGcm9tV0ZTSXRlbSh1cGRhdGVkSXRlbS5leHRlbnQpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVwZGF0ZWRJdGVtKSwgeyB0aHVtYm5haWxVcmwgfSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHVwZGF0ZWRJdGVtO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0V01UU09wdGlvbnModXJsKSB7XG4gIHZhciBfYSwgX2I7XG4gIC8vIGJlZm9yZSB3ZSBzdHJpcCBwYXJhbWV0ZXJzIHNlZSBpZiBpdCdzIGEgS1ZQIGNhcGFiaWxpdGllcyBVUkwuIFRoZW4gd2UgdXNlIHRoYXQgb25lIGZpcnN0LlxuICBjb25zdCB1cmxPYmogPSBhd2FpdCB1cmxUb09iamVjdCh1cmwpO1xuICBjb25zdCBzZXJ2aWNla2V5ID0gKChfYSA9IHVybE9iai5xdWVyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1wic2VydmljZVwiXSkgfHwgXCJcIjtcbiAgY29uc3QgcmVxdWVzdEtleSA9ICgoX2IgPSB1cmxPYmoucXVlcnkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltcInJlcXVlc3RcIl0pIHx8IFwiXCI7XG4gIGlmICgoc2VydmljZWtleS50b0xvd2VyQ2FzZSgpID09PSBcIndtdHNcIiAmJiByZXF1ZXN0S2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0Y2FwYWJpbGl0aWVzXCIpIHx8XG4gICAgdXJsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIi8xLjAuMC93bXRzY2FwYWJpbGl0aWVzLnhtbFwiKSA+IC0xKSB7XG4gICAgcmV0dXJuIHsgc2VydmljZU1vZGU6IFwiS1ZQXCIgfTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdNVFNTZXJ2aWNlSW5mbyhpdGVtLCBvcHRpb25zKSB7XG4gIGNvbnN0IFtXTVRTTGF5ZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9sYXllcnMvV01UU0xheWVyXCJdKTtcbiAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzLCB1cmwgfSA9IGl0ZW07XG4gIGNvbnN0IGZvcm1hdHRlZFBhcmFtcyA9IGZvcm1hdEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tUGFyYW1ldGVycyk7XG4gIGNvbnN0IHdtdHNPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBjdXN0b21MYXllclBhcmFtZXRlcnM6IChmb3JtYXR0ZWRQYXJhbXMgPT09IG51bGwgfHwgZm9ybWF0dGVkUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXR0ZWRQYXJhbXMuY3VzdG9tTGF5ZXJQYXJhbWV0ZXJzKSB8fCB7fSwgY3VzdG9tUGFyYW1ldGVyczogKGZvcm1hdHRlZFBhcmFtcyA9PT0gbnVsbCB8fCBmb3JtYXR0ZWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRlZFBhcmFtcy5jdXN0b21QYXJhbWV0ZXJzKSB8fCB7fSB9KSB8fFxuICAgIChhd2FpdCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldFdNVFNPcHRpb25zKHVybCkpLCB7IGN1c3RvbUxheWVyUGFyYW1ldGVyczogKGZvcm1hdHRlZFBhcmFtcyA9PT0gbnVsbCB8fCBmb3JtYXR0ZWRQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHRlZFBhcmFtcy5jdXN0b21MYXllclBhcmFtZXRlcnMpIHx8IHt9LCBjdXN0b21QYXJhbWV0ZXJzOiAoZm9ybWF0dGVkUGFyYW1zID09PSBudWxsIHx8IGZvcm1hdHRlZFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGVkUGFyYW1zLmN1c3RvbVBhcmFtZXRlcnMpIHx8IHt9IH0pKTtcbiAgY29uc3Qgd210c1VybCA9IHN0cmlwUGFyYW1ldGVycyh1cmwsIFtcbiAgICBcInZlcnNpb25cIixcbiAgICBcInNlcnZpY2VcIixcbiAgICBcInJlcXVlc3RcIixcbiAgICBcImxheWVyXCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgXCJ0aWxlbWF0cml4c2V0XCIsXG4gICAgXCJ0aWxlbWF0cml4XCIsXG4gICAgXCJ0aWxlcm93XCIsXG4gICAgXCJ0aWxlY29sXCJcbiAgXSk7XG4gIGNvbnN0IG5ld1dtdHNVcmwgPSB3bXRzVXJsLnJlcGxhY2UoL1xcLzEuMC4wXFwvd210c2NhcGFiaWxpdGllcy54bWwvaSwgXCJcIik7XG4gIHRyeSB7XG4gICAgaWYgKGNvbmZpZ1N0YXRlLmFwaSA9PT0gNCkge1xuICAgICAgY29uc3Qgd210c0xheWVyID0gbmV3IFdNVFNMYXllcihuZXdXbXRzVXJsLCB3bXRzT3B0aW9ucyk7XG4gICAgICBjb25zdCB2NExheWVyID0gd210c0xheWVyO1xuICAgICAgYXdhaXQgdjRMYXllci5sb2FkKCk7XG4gICAgICBjb25zdCBsYXllcnMgPSB2NExheWVyLnN1YmxheWVycy50b0FycmF5KCk7XG4gICAgICBpZiAoIWxheWVycyB8fCAhbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBgc2VydmljZU5vdEV4aXN0YCB9IH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd210c0xheWVyLmxheWVycyA9IGxheWVycztcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IHR5cGU6IFwiV01UU1wiLCBzZXJ2aWNlSW5mbzogd210c0xheWVyIH0pIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIC0tLSB2MyAtLS1cbiAgICBhd2FpdCBjaGVja0NPUlMod210c1VybCk7XG4gICAgY29uc3Qgd210c0xheWVyID0gbmV3IFdNVFNMYXllcihuZXdXbXRzVXJsLCB3bXRzT3B0aW9ucyk7XG4gICAgbGV0IGxheWVycztcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB3bXRzTGF5ZXIub24oXCJsb2FkXCIsICh7IGxheWVyOiB3bXRzSW5mbyB9KSA9PiB7XG4gICAgICAgIGxheWVycyA9IHdtdHNJbmZvLmxheWVycztcbiAgICAgICAgaWYgKCFsYXllcnMgfHwgIWxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBzZXJ2aWNlTm90RXhpc3RgKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgd210c0xheWVyLmxheWVycyA9IGxheWVycztcbiAgICAgICAgICByZXNvbHZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgdHlwZTogXCJXTVRTXCIsIHNlcnZpY2VJbmZvOiB3bXRzTGF5ZXIgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdtdHNMYXllci5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXdtdHNPcHRpb25zLnNlcnZpY2VNb2RlKSB7XG4gICAgICAgICAgZ2V0V01UU1NlcnZpY2VJbmZvKGl0ZW0sIHsgc2VydmljZU1vZGU6IFwiS1ZQXCIgfSkudGhlbigoeyByZXN1bHQsIGVycm9yIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCgoX2EgPSBlcnIuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSA9PT0gXCJUaGUgV01UUyBjYXBhYmlsaXRpZXMgWE1MIGlzIG5vdCB2YWxpZFwiKSB7XG4gICAgICAgICAgICByZWplY3QoeyBjb2RlOiBcImludmFsaWRXTVRTXCIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlamVjdCh7IGNvZGU6IFwic2VydmljZU5vdEV4aXN0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZFdNVFNVcmwoaXRlbSkge1xuICBpZiAoIWl0ZW0pIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJzZXJ2aWNlTm90RXhpc3RcIik7XG4gIH1cbiAgY29uc3QgeyBzZXJ2aWNlSW5mbzogd210c0xheWVyLCBzZWxlY3RlZExheWVyLCBzZWxlY3RlZFRpbGVJbmZvIH0gPSBpdGVtO1xuICBpZiAoIXNlbGVjdGVkTGF5ZXIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibGF5ZXJOb3RTZWxlY3RlZFwiKSk7XG4gIH1cbiAgaWYgKCFzZWxlY3RlZFRpbGVJbmZvKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3NpbmdHZW9tZXRyeVwiKSk7XG4gIH1cbiAgd210c0xheWVyLnNlbGVjdGVkVGlsZUluZm8gPSBzZWxlY3RlZFRpbGVJbmZvO1xuICBjb25zdCB7IHdtdHNDb25maWcsIGZ1bGxFeHRlbnQ6IGNvbmZpZ0V4dGVudCB9ID0gYXdhaXQgZ2V0V01UU0NvbmZpZyh3bXRzTGF5ZXIpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIFdNVFMgY29uZmlnXCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG4gIGNvbnN0IGdjc0V4dGVudCA9IHdtdHNMYXllci5zZWxlY3RlZExheWVyW2NvbmZpZ1N0YXRlLmFwaSA9PT0gNCA/IFwiZnVsbEV4dGVudFwiIDogXCJnY3NFeHRlbnRcIl07XG4gIGNvbnN0IGZ1bGxFeHRlbnQgPSBjb25maWdFeHRlbnQgPyBnY3NFeHRlbnQgOiB7IHhtaW46IC0xODAsIHltaW46IC05MCwgeG1heDogMTgwLCB5bWF4OiA5MCB9O1xuICBjb25zdCBmb3JtYXR0ZWRJdGVtID0geyB0eXBlOiBpdGVtLnR5cGUsIHVybDogaXRlbS51cmwsIHRodW1ibmFpbFVSTDogaXRlbS50aHVtYm5haWxVUkwgfTtcbiAgY29uc3QgaXRlbUluZm8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoZWNrVGh1bWJuYWlsVVJMKGZvcm1hdHRlZEl0ZW0pKSwgeyB1cmw6IHdtdHNDb25maWcud210c0luZm8udXJsLCB0ZXh0OiBKU09OLnN0cmluZ2lmeSh3bXRzQ29uZmlnKSwgZXh0ZW50OiBgJHtmdWxsRXh0ZW50LnhtaW59LCR7ZnVsbEV4dGVudC55bWlufSwke2Z1bGxFeHRlbnQueG1heH0sJHtmdWxsRXh0ZW50LnltYXh9YCB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZGRVcmwoaXRlbUluZm8pO1xuICBjb25zdCB1cGRhdGVkSXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtSW5mbyksIHJlc3BvbnNlKSwgeyBleHRlbnQ6IFtcbiAgICAgIFtmdWxsRXh0ZW50LnhtaW4sIGZ1bGxFeHRlbnQueW1pbl0sXG4gICAgICBbZnVsbEV4dGVudC54bWF4LCBmdWxsRXh0ZW50LnltYXhdXG4gICAgXSB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0aHVtYm5haWxEYXRhID0gYXdhaXQgYnVpbGRUaHVtYm5haWxVUkxGcm9tV01UU0l0ZW0odXBkYXRlZEl0ZW0pO1xuICAgIGNvbnN0IHJlcXVlc3REYXRhID0gY29uZmlnU3RhdGUuYXBpID09PSA0ID8geyB0eXBlOiBcImJhc2U2NFwiLCBkYXRhOiB0aHVtYm5haWxEYXRhIH0gOiB7IHR5cGU6IFwidXJsXCIsIHVybDogdGh1bWJuYWlsRGF0YSB9O1xuICAgIGNvbnN0IGl0ZW1XaXRoVGh1bWJuYWlsID0gYXdhaXQgYWRkVGh1bWJuYWlsVG9JdGVtKHJlc3BvbnNlLmlkLCByZXF1ZXN0RGF0YSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZEl0ZW0pLCBpdGVtV2l0aFRodW1ibmFpbCk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoZW4gYWRkaW5nIFdNVFMgVVJMOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIHVwZGF0ZWRJdGVtO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRPR0NGZWF0dXJlTGF5ZXJTZXJ2aWNlSW5mbyhpdGVtKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgeyB1cmwgfSA9IGl0ZW07XG4gIC8qKiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIGZyb20gdGhlIE1hcFZpZXdlciAgLSBpdCB3aWxsIGdldCB0aGUgbGFuZGluZyBwYWdlIGluIHRoZSBmb3JtIG9mIFwiYXBwbGljYXRpb24vanNvbiAtIGFuZCB0aGVuIGdldCB0aGUgY29sbGVjdGlvbiBmcm9tIGl0LiAqL1xuICAvLyAgIC8vIEAgOS4zIFdpbGwgbmVlZCB0byBzZXQgdGhlIHRydXN0ZWRTZXJ2ZXIgc3R1ZmYgYmVmb3JlIHRoaXMgY2FsbFxuICAvLyAgIC8vIGluIGNhc2UgdGhlIHNlcnZpY2UgbmVlZHMgY3JlZGVudGlhbHNcbiAgY29uc3QgbGFuZGluZ1BhZ2VPcHRpb25zID0geyBhZGRUb2tlbk1hbnVhbGx5OiBmYWxzZSwgaGVhZGVyczogeyBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0gfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBnZXREYXRhV2l0aEpTT05SZXRyeSA9IGFzeW5jIChmdW5jLCBmYWlsQ2FsbGJhY2spID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZ1bmMoKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKF9jID0gKF9iID0gKF9hID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcyhcInVuZXhwZWN0ZWQgdG9rZW5cIikgfHwgbWVzc2FnZS5pbmNsdWRlcyhcImV4cGVjdGVkIGV4cHJlc3Npb25cIikpIHtcbiAgICAgICAgICByZXR1cm4gZmFpbENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhyb3cgeyByZXN1bHQ6IG51bGwsIGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH0gfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGFuZGluZ1BhZ2UgPSBhd2FpdCBnZXREYXRhV2l0aEpTT05SZXRyeSgoKSA9PiByZXF1ZXN0KHVybCwge30sIGxhbmRpbmdQYWdlT3B0aW9ucywgXCJhdXRvXCIsIHsgZXhjbHVkZUpzb246IHRydWUgfSksICgpID0+IHJlcXVlc3QodXJsLCB7fSwgbGFuZGluZ1BhZ2VPcHRpb25zKSk7XG4gICAgY29uc3Qgc2VydmljZUluZm8gPSBhd2FpdCBnZXREYXRhV2l0aEpTT05SZXRyeSgoKSA9PiBnZXRTZXJ2ZXJDb2xsZWN0aW9ucyhsYW5kaW5nUGFnZSksICgpID0+IGdldFNlcnZlckNvbGxlY3Rpb25zKGxhbmRpbmdQYWdlLCB7fSwgZmFsc2UpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IGV4dGVudDogZXh0ZW50VG9TdHJpbmcoKF9kID0gKF9jID0gKF9iID0gKF9hID0gc2VydmljZUluZm8uY29sbGVjdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4dGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwYXRpYWwpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5iYm94KSwgdHlwZTogXCJPR0NGZWF0dXJlU2VydmVyXCIsIHNlcnZpY2VJbmZvLCBsYXllcnM6IHNlcnZpY2VJbmZvLmNvbGxlY3Rpb25zIH0pLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJnZXQgT0dDIGZlYXR1cmUgbGF5ZXI6XCIsIGVycm9yKTtcbiAgICAvLyBUT0RPOiBoYW5kbGUgZXJyb3IgdHJhbnNmb3JtYXRpb24gaGVyZVxuICAgIHJldHVybiB7IHJlc3VsdDogbnVsbCwgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICB9XG59XG5mdW5jdGlvbiBzZWxlY3RPR0NGZWF0dXJlTGF5ZXIoc2VsZWN0ZWRMYXllcikge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoIXNlbGVjdGVkTGF5ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgeyB0aXRsZSwgZGVzY3JpcHRpb24gfSA9IHNlbGVjdGVkTGF5ZXI7XG4gIGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUgPSAoX2EgPSB0aXRsZSAhPT0gbnVsbCAmJiB0aXRsZSAhPT0gdm9pZCAwID8gdGl0bGUgOiBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICBpdGVtUHJvcGVydGllc1N0YXRlLnNuaXBwZXQgPSAoX2IgPSBkZXNjcmlwdGlvbiAhPT0gbnVsbCAmJiBkZXNjcmlwdGlvbiAhPT0gdm9pZCAwID8gZGVzY3JpcHRpb24gOiBpdGVtUHJvcGVydGllc1N0YXRlLnNuaXBwZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gIGFkZEl0ZW1TdGF0ZS5zZWxlY3RlZExheWVyID0gc2VsZWN0ZWRMYXllcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFNlcnZlckNvbGxlY3Rpb25zKGxhbmRpbmdQYWdlLCBvcHRpb25zID0ge30sIGV4Y2x1ZGVKc29uID0gdHJ1ZSkge1xuICBjb25zdCB7IGxpbmtzIH0gPSBsYW5kaW5nUGFnZTtcbiAgY29uc3QgbGluayA9IGdldExpbmsobGlua3MsIFwiZGF0YVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIikgfHxcbiAgICBnZXRMaW5rKGxpbmtzLCBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL3JlbC9vZ2MvMS4wL2RhdGFcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICBpZiAoaXNOb25lKGxpbmspKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjb2xsZWN0aW9ucyB1cmxcIik7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZ1N0YXRlLmFwaSA9PT0gM1xuICAgID8gcmVxdWVzdChhZGRQYXJhbWV0ZXJzKGxpbmsuaHJlZiksIHt9LCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGFkZFRva2VuTWFudWFsbHk6IGZhbHNlIH0pLCBcImF1dG9cIiwge1xuICAgICAgdjNSZXF1ZXN0OiB7IGhlYWRlcnM6IHsgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9IH0sXG4gICAgICBleGNsdWRlSnNvblxuICAgIH0pXG4gICAgOiByZXF1ZXN0KGFkZFBhcmFtZXRlcnMobGluay5ocmVmKSwge30sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgYWRkVG9rZW5NYW51YWxseTogZmFsc2UsIGhlYWRlcnM6IHsgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9IH0pLCBcImF1dG9cIiwge1xuICAgICAgZXhjbHVkZUpzb25cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldExpbmsobGlua3MsIHJlbGF0aW9uLCB0eXBlKSB7XG4gIHJldHVybiAobGlua3MuZmluZCgobGluaykgPT4gbGluay5yZWwgPT09IHJlbGF0aW9uICYmIGxpbmsudHlwZSA9PT0gdHlwZSkgfHxcbiAgICBsaW5rcy5maW5kKChsaW5rKSA9PiBsaW5rLnJlbCA9PT0gcmVsYXRpb24gJiYgIWxpbmsudHlwZSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gYWRkT0dDRmVhdHVyZVNlcnZpY2UoaXRlbSkge1xuICBjb25zdCB7IHNlcnZpY2VJbmZvLCBjdXN0b21QYXJhbWV0ZXJzIH0gPSBpdGVtO1xuICBpZiAoIXNlcnZpY2VJbmZvKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNlcnZpY2VOb3RFeGlzdFwiKSk7XG4gIH1cbiAgLy8gVGhpcyB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBob3cgbWV0YWRhdGEgbmVlZHMgdG8gYmUgZm9ybWF0dGVkLlxuICBpZiAoY3VzdG9tUGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgaXRlbS50ZXh0ID0gSlNPTi5zdHJpbmdpZnkoeyBjdXN0b21QYXJhbWV0ZXJzOiBmb3JtYXRDdXN0b21QYXJhbWV0ZXJzKGN1c3RvbVBhcmFtZXRlcnMpLmN1c3RvbVBhcmFtZXRlcnMgfSk7XG4gIH1cbiAgcmV0dXJuIGFkZFVybChpdGVtKTtcbn1cblxuLy8gZnVuY3Rpb24gdG8gbmF2aWdhdGUgdG8gdGhlIGNvcnJlY3QgXCJhZGRJdGVtXCIgcmVxdWVzdHNcbmNvbnN0IGFkZEl0ZW0gPSAoaXRlbSwgcmVzdEJhc2VVcmwpID0+IHtcbiAgY29uc3QgeyBuZXdJdGVtTW9kZSwgdHlwZUtleXdvcmRzLCB0YWdzLCBleHRlbnQsIHNlbGVjdGVkU2VydmljZUluZm9MYXllcnNOYW1lcywgYWRkRmVhdHVyZUxheWVyVHlwZSB9ID0gYWRkSXRlbVN0YXRlO1xuICBjb25zdCB0aXRsZSA9IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGU7XG4gIGlmICgodGl0bGUgPT09IG51bGwgfHwgdGl0bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpdGxlLmxlbmd0aCkgPiAyNTApIHtcbiAgICBpdGVtUHJvcGVydGllc1N0YXRlLnRpdGxlID0gdGl0bGUuc3Vic3RyaW5nKDAsIDI1MCk7XG4gIH1cbiAgc3dpdGNoIChuZXdJdGVtTW9kZSkge1xuICAgIGNhc2UgXCJhcHBsaWNhdGlvblwiOlxuICAgICAgcmV0dXJuIGFkZEFwcGxpY2F0aW9uKGl0ZW0sIHJlc3RCYXNlVXJsKTtcbiAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgLy8gVE9ETzogUGFzcyBpbiBpdGVtIHByb3BlcnRpZXMvaXRlbSByZXF1ZXN0IGhlcmUgaW5zdGVhZCBvZiBncmFiYmluZyBmcm9tIHRoZSBzdG9yZSBhZ2FpblxuICAgICAgcmV0dXJuIGFkZEZpbGUoKTtcbiAgICBjYXNlIFwidXJsXCI6XG4gICAgICAvLyBUT0RPOiByZWZhY3RvciB0aGUgcGFzc2VkIGNvbmZpZ1N0YXRlIG91dCBvZiB0aGlzXG4gICAgICByZXR1cm4gaGFuZGxlQWRkVXJsKGl0ZW0sIGNvbmZpZ1N0YXRlLmNvbmZpZywgY29uZmlnU3RhdGUuYXBpKTtcbiAgICBjYXNlIFwiZmVhdHVyZUxheWVyXCI6XG4gICAgICByZXR1cm4gYWRkRmVhdHVyZUxheWVyKHtcbiAgICAgICAgc2VydmljZUluZm86IGl0ZW0uc2VydmljZUluZm8sXG4gICAgICAgIHR5cGVLZXl3b3JkcyxcbiAgICAgICAgdGFncyxcbiAgICAgICAgZXh0ZW50LFxuICAgICAgICBzZWxlY3RlZFNlcnZpY2VJbmZvTGF5ZXJzTmFtZXMsXG4gICAgICAgIGFkZEZlYXR1cmVMYXllclR5cGVcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc2VuZEFkZEl0ZW1SZXF1ZXN0KE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pKTtcbiAgfVxufTtcbmNvbnN0IHVwbG9hZEZpbGUgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWRkSXRlbVJlcXVlc3QgPSBhZGRJdGVtUmVxdWVzdFN0YXRlOyAvLyB7IC4uLmFkZEl0ZW1TdG9yZS5zdGF0ZSB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IGFkZEl0ZW0oYWRkSXRlbVJlcXVlc3QsIFwiXCIpKTtcbiAgICBhZGRJdGVtU3RhdGUuaWQgPSByZXNwb25zZS5pZDtcbiAgICBjb25zdCBqb2JTdGF0dXMgPSBhd2FpdCBnZXRJdGVtU3RhdHVzKGFkZEl0ZW1TdGF0ZS5pZCwgeyBzdWNjZXNzOiByZXNwb25zZS5zdWNjZXNzIH0pO1xuICAgIGlmIChqb2JTdGF0dXMuc3RhdHVzID09PSBcImZhaWxlZFwiKSB7XG4gICAgICB0aHJvdyBqb2JTdGF0dXMuc3RhdHVzTWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3Iuc3RhdHVzTWVzc2FnZSkgfHwgZXJyb3IgfHwgXCJcIjtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiSW52YWxpZCBGaWxlIEdlb2RhdGFiYXNlXCIpOlxuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImludmFsaWRGaWxlR2VvZGF0YWJhc2VcIiB9IH07XG4gICAgICBjYXNlIGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIkludmFsaWQgU2hhcGVmaWxlXCIpOlxuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImludmFsaWRTaGFwZWZpbGVcIiB9IH07XG4gICAgICBjYXNlIGVycm9yTWVzc2FnZS5pbmNsdWRlcyhcIlRoZSByZXF1ZXN0IHNpemUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXggYWxsb3dlZCBvZiAxMDI0TUJcIik6XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwiZXhjZWVkc0ZpbGVTaXplXCIgfSB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBhZGRGaWxlID0gYXN5bmMgKHByb3BzKSA9PiB7XG4gIGNvbnN0IGZpbGUgPSBhZGRJdGVtU3RhdGUuZmlsZTtcbiAgY29uc3QgZGF0YVVybCA9IGFkZEl0ZW1TdGF0ZS5kYXRhVXJsO1xuICBpZiAoIWZpbGUgJiYgZGF0YVVybCkge1xuICAgIHJldHVybiBhZGRGaWxlRnJvbURhdGFVcmwocHJvcHMpO1xuICB9XG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIEVDRCB3b3JrYXJvdW5kIHdoZW4gYmFja2VuZCBmaXhlcyBmaWxlbmFtZSBjcmVhdGlvbiAoV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzQxMDY4KVxuICBpZiAoKGZpbGUgPT09IG51bGwgfHwgZmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZS5zaXplKSA+IE1VTFRJX1BBUlRfVVBMT0FEX01JTklNVU1fU0laRSB8fCBhZGRJdGVtU3RhdGUudHlwZSA9PT0gXCJFc3JpIENsYXNzaWZpZXIgRGVmaW5pdGlvblwiKSB7XG4gICAgcmV0dXJuIGFkZEZpbGVNdWx0aVBhcnQoKTtcbiAgfVxuICByZXR1cm4gYWRkRmlsZVNpbmdsZSgpO1xufTtcbmNvbnN0IGFkZEZpbGVGcm9tRGF0YVVybCA9IGFzeW5jIChwcm9wcykgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHVybCA9IGdldEFkZEl0ZW1VcmwoY29uZmlnU3RhdGUudXNlciwgaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXIpO1xuICBjb25zdCB7IGZpbGVOYW1lLCBkYXRhVXJsLCBleHRlbnNpb24gfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgY29uc3QgYWRkSXRlbVBhcmFtcyA9IGdldEFkZEl0ZW1QYXJhbWV0ZXJzKGl0ZW1Qcm9wZXJ0aWVzU3RhdGUsIGFkZEl0ZW1TdGF0ZSk7XG4gIGNvbnN0IG92ZXJ3cml0ZSA9ICEhYWRkSXRlbVN0YXRlLm92ZXJ3cml0ZTsgLy9jb3VsZCBiZSB1bmRlZmluZWRcbiAgLy8gaW4gdGhlIGNhc2Ugd2hlcmUgd2UncmUgYWRkaW5nIGdlb2pzb24gZnJvbSBhIHVybCByZWZlcmVuY2luZyBhIGZlYXR1cmUgc2VydmljZSxcbiAgLy8gbWFrZSBhIHVuaXF1ZSBmaWxlIG5hbWUgc28gdGhhdCB0aGUgZmlsZSBpc24ndCB0aGUgcXVlcnkgV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzQyNDAzXG4gIGNvbnN0IGlzR2VvSlNPTkZyb21GZWF0dXJlU2VydmVyID0gKGRhdGFVcmwgPT09IG51bGwgfHwgZGF0YVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YVVybC5pbmNsdWRlcyhcIi9xdWVyeT9cIikpICYmIChmaWxlTmFtZSA9PT0gbnVsbCB8fCBmaWxlTmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZU5hbWUuaW5jbHVkZXMoXCJxdWVyeVwiKSkgJiYgKGV4dGVuc2lvbiA9PT0gbnVsbCB8fCBleHRlbnNpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbi5pbmNsdWRlcyhcImpzb25cIikpO1xuICBjb25zdCBnZW9qc29uUHJvcGVydGllcyA9IGlzR2VvSlNPTkZyb21GZWF0dXJlU2VydmVyXG4gICAgPyB7XG4gICAgICBmaWxlbmFtZTogZ3VpZCgpLFxuICAgICAgZGF0YVVybFxuICAgIH1cbiAgICA6IHt9O1xuICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWRkSXRlbVBhcmFtcyksIHsgYXN5bmM6IHRydWUsIGZpbGVuYW1lOiAoX2EgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuZmlsZW5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGVOYW1lLCB0aXRsZTogcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLnRpdGxlLCBvdmVyd3JpdGUgfSksIGdlb2pzb25Qcm9wZXJ0aWVzKTtcbiAgcmV0dXJuIHJlcXVlc3QodXJsLCBwYXJhbXMsIHt9LCBcInBvc3RcIik7XG59O1xuYXN5bmMgZnVuY3Rpb24gYWRkRmlsZVNpbmdsZSgpIHtcbiAgY29uc3QgdXJsID0gZ2V0QWRkSXRlbVVybChjb25maWdTdGF0ZS51c2VyLCBpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlcik7XG4gIGNvbnN0IGZvcm0gPSBjcmVhdGVGb3JtKGl0ZW1Qcm9wZXJ0aWVzU3RhdGUsIGFkZEl0ZW1TdGF0ZSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGZvcm1SZXF1ZXN0KHVybCwgZm9ybSwge30sIFwicG9zdFwiKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpIHx8IGVycm9yO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBhZGRQYXJ0KHBhcnQsIGl0ZW1JZCwgYXR0ZW1wdHMgPSAwKSB7XG4gIGNvbnN0IHVzZXIgPSBjb25maWdTdGF0ZS51c2VyO1xuICAvLyBLZWVwIGF0dGVtcHRpbmcgdG8gYWRkIHRoZSBwYXJ0LCBvbmx5IHRocm93aW5nIGFuIGVycm9yIGFmdGVyIG11bHRpcGxlIHJldHJpZXNcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHBhcnREYXRhLCBmb3JtRGF0YSB9ID0gcGFydDtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gYD9zdHJlYW1kYXRhPXRydWUmc2l6ZT0ke3BhcnREYXRhLnNpemV9JnBhcnROdW09JHtwYXJ0RGF0YS5wYXJ0TnVtfSZmPWpzb25gO1xuICAgIGNvbnN0IHVybCA9IGAke3VzZXIudXNlckNvbnRlbnRVcmx9L2l0ZW1zLyR7aXRlbUlkfS9hZGRQYXJ0JHtwYXJhbWV0ZXJzfWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmb3JtUmVxdWVzdCh1cmwsIGZvcm1EYXRhLCB7XG4gICAgICBcIlgtRXNyaS1BdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHtnZXRUb2tlbihjb25maWdTdGF0ZS5wb3J0YWwpfWBcbiAgICB9LCBcInBvc3RcIik7XG4gICAgcmV0dXJuIHsgcmVzcG9uc2UsIGF0dGVtcHRzLCBwYXJ0U2l6ZTogcGFydERhdGEuc2l6ZSB9O1xuICB9XG4gIGNhdGNoIChfYSkge1xuICAgIGlmICghYWRkSXRlbVN0YXRlLmlkKSB7XG4gICAgICB0aHJvdyBcImNhbmNlbGxlZFwiO1xuICAgIH1cbiAgICBhdHRlbXB0cysrO1xuICAgIGlmIChhdHRlbXB0cyA+IE1VTFRJX1BBUlRfVVBMT0FEX1JFVFJJRVMpIHtcbiAgICAgIC8vIFRPRE86IFVwZGF0ZSBlcnJvciBtZXNzYWdlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcGxvYWQgZmFpbGVkIC0gdG9vIG1hbnkgYXR0ZW1wdHNcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGFkZFBhcnQocGFydCwgaXRlbUlkLCBhdHRlbXB0cyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiogZ2VuZXJhdGVQYXJ0KCkge1xuICBjb25zdCBmaWxlID0gYWRkSXRlbVN0YXRlLmZpbGU7XG4gIGNvbnN0IHsgbmFtZSwgc2l6ZSB9ID0gZmlsZTtcbiAgbGV0IHBhcnRTaXplID0gTVVMVElfUEFSVF9VUExPQURfQkFUQ0hfU0laRTtcbiAgbGV0IHRvdGFsUGFydHMgPSBNYXRoLmNlaWwoc2l6ZSAvIHBhcnRTaXplKTtcbiAgbGV0IHBhcnQgPSAwO1xuICAvLyBNYXggbnVtYmVyIG9mIHBhcnRzIGlzIDEwLDAwMCwgc28gd2UgaW5jcmVhc2UgdGhlIGNodW5rIHNpemUgaWYgdGhlIGZpbGUgaXMgYmlnZ2VyIHRoYW4gdGhlIHRocmVzaG9sZFxuICBpZiAodG90YWxQYXJ0cyA+IE1VTFRJX1BBUlRfVVBMT0FEX01BWF9QQVJUUykge1xuICAgIHBhcnRTaXplID0gTWF0aC5jZWlsKHNpemUgLyBNVUxUSV9QQVJUX1VQTE9BRF9NQVhfUEFSVFMpO1xuICAgIHRvdGFsUGFydHMgPSBNYXRoLmNlaWwoc2l6ZSAvIHBhcnRTaXplKTtcbiAgfVxuICB3aGlsZSAocGFydCA8IHRvdGFsUGFydHMpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IHBhcnQgKiBwYXJ0U2l6ZTtcbiAgICBjb25zdCBibG9iID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIHBhcnRTaXplKTtcbiAgICBwYXJ0Kys7XG4gICAgY29uc3QgcGFydERhdGEgPSB7XG4gICAgICBwYXJ0TnVtOiBwYXJ0LFxuICAgICAgc2l6ZTogYmxvYi5zaXplXG4gICAgfTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJwYXJ0TnVtXCIsIFN0cmluZyhwYXJ0RGF0YS5wYXJ0TnVtKSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwic3RyZWFtZGF0YVwiLCBcInRydWVcIik7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZlwiLCBcImpzb25cIik7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwidG9rZW5cIiwgZ2V0VG9rZW4oY29uZmlnU3RhdGUucG9ydGFsKSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBibG9iLCBuYW1lKTtcbiAgICB5aWVsZCB7IHBhcnREYXRhLCBmb3JtRGF0YSB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgYWRkRmlsZU11bHRpUGFydCA9IGFzeW5jICgpID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBsZXQgZG9VcGxvYWQgPSB0cnVlO1xuICBjb25zdCBjYW5jZWxVcGxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKGFkZEl0ZW1TdGF0ZS5pZCkge1xuICAgICAgZG9VcGxvYWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1JZCA9IGFkZEl0ZW1TdGF0ZS5pZDtcbiAgICAgIGFkZEl0ZW1TdGF0ZS5pZCA9IG51bGw7XG4gICAgICByZXR1cm4gY2FuY2VsSXRlbShpdGVtSWQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbXVsdGlQYXJ0U3Vic2NyaWJlciA9IHN1YnNjcmlwdGlvblN0YXRlLmFkZFN1YnNjcmliZXIoXCJhZGRGaWxlTXVsdGlQYXJ0XCIsIGNhbmNlbFVwbG9hZCk7XG4gIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ1N0YXRlLmNvbmZpZztcbiAgY29uc3QgdXJsID0gZ2V0QWRkSXRlbVVybChjb25maWdTdGF0ZS51c2VyLCBpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlcik7XG4gIGNvbnN0IHsgZmlsZU5hbWUsIGZpbGUgfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgbGV0IHBhcnRzUGVyQmF0Y2ggPSAoX2EgPSBjb25maWcubXVsdGlQYXJ0QmF0Y2hTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBNVUxUSV9QQVJUX1VQTE9BRF9JTklUSUFMX0JBVENIX1NJWkU7XG4gIGxldCBudW1Db25zZWN1dGl2ZVN1Y2Nlc3MgPSAwO1xuICBsZXQgaXRlbUlkO1xuICB0cnkge1xuICAgIGNvbnN0IGl0ZW1SZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QodXJsLCB7IG11bHRpcGFydDogdHJ1ZSwgZmlsZU5hbWUsIGFzeW5jOiB0cnVlIH0sIHt9LCBcInBvc3RcIik7XG4gICAgaXRlbUlkID0gKF9iID0gaXRlbVJlc3BvbnNlLmlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpdGVtUmVzcG9uc2UuaXRlbUlkO1xuICAgIGFkZEl0ZW1TdGF0ZS5pZCA9IGl0ZW1JZDtcbiAgICAvLyBUT0RPOiBGYWN0b3IgdXBsb2FkUHJvZ3Jlc3Mgb3V0IG9mIGFkZEl0ZW1TdGF0ZVxuICAgIGFkZEl0ZW1TdGF0ZS51cGxvYWRQcm9ncmVzcyA9IDA7XG4gICAgd29ya2Zsb3dTdGF0ZS51cGxvYWRQcm9ncmVzcyA9IDA7XG4gICAgbGV0IGJ5dGVzVXBsb2FkZWQgPSAwO1xuICAgIC8vIEluaXRpYWxpemUgZHluYW1pYyBiYXRjaCBnZW5lcmF0b3JcbiAgICBjb25zdCBwYXJ0R2VuZXJhdG9yID0gZ2VuZXJhdGVQYXJ0KCk7XG4gICAgYXdhaXQgc3RyZWFtUHJvbWlzZXMoKCkgPT4ge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gcGFydEdlbmVyYXRvci5uZXh0KCk7XG4gICAgICByZXR1cm4gZG9uZSA/IG51bGwgOiBhZGRQYXJ0KHZhbHVlLCBpdGVtSWQpO1xuICAgIH0sIHtcbiAgICAgIGdldEJhdGNoU2l6ZTogKCkgPT4gcGFydHNQZXJCYXRjaCxcbiAgICAgIG9uUHJvbWlzZUNvbXBsZXRlZDogKGFkZFBhcnRSZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgeyBhdHRlbXB0cywgcGFydFNpemUgfSA9IGFkZFBhcnRSZXN1bHQ7XG4gICAgICAgIC8vIElmIGEgcGFydCBvbmx5IHN1Y2NlZWRlZCBhZnRlciBvbmUgb3IgbW9yZSBmYWlsdXJlcy9yZXRyaWVzLCBmbGFnIHRoZSBiYXRjaCB0byBiZSByZWR1Y2VkIG5leHQgdGltZVxuICAgICAgICBpZiAoYXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgcGFydHNQZXJCYXRjaCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChwYXJ0c1BlckJhdGNoIC8gMikpO1xuICAgICAgICAgIG51bUNvbnNlY3V0aXZlU3VjY2VzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbnVtQ29uc2VjdXRpdmVTdWNjZXNzKys7XG4gICAgICAgICAgaWYgKG51bUNvbnNlY3V0aXZlU3VjY2VzcyA+PSBwYXJ0c1BlckJhdGNoKSB7XG4gICAgICAgICAgICBwYXJ0c1BlckJhdGNoID0gTWF0aC5taW4ocGFydHNQZXJCYXRjaCArIDEsIE1VTFRJX1BBUlRfVVBMT0FEX01BWF9CQVRDSF9TSVpFKTtcbiAgICAgICAgICAgIG51bUNvbnNlY3V0aXZlU3VjY2VzcyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ5dGVzVXBsb2FkZWQgKz0gcGFydFNpemU7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5mbG9vcigoYnl0ZXNVcGxvYWRlZCAvIGZpbGUuc2l6ZSkgKiAxMDApO1xuICAgICAgICAvLyBUT0RPOiBGYWN0b3IgdXBsb2FkUHJvZ3Jlc3Mgb3V0IG9mIGFkZEl0ZW1TdGF0ZVxuICAgICAgICBhZGRJdGVtU3RhdGUudXBsb2FkUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgd29ya2Zsb3dTdGF0ZS51cGxvYWRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgfSxcbiAgICAgIG9uUHJvbWlzZVRocm93KCkge1xuICAgICAgICBkb1VwbG9hZCA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHNob3VsZENvbnRpbnVlOiAoKSA9PiBkb1VwbG9hZCAmJiBzdWJzY3JpcHRpb25TdGF0ZS5pc1N1YnNjcmliZXJWYWxpZChtdWx0aVBhcnRTdWJzY3JpYmVyKVxuICAgIH0pO1xuICAgIHN1YnNjcmlwdGlvblN0YXRlLnJlbW92ZVN1YnNjcmliZXIobXVsdGlQYXJ0U3Vic2NyaWJlcik7XG4gICAgY29uc3QgeyB0eXBlLCBleHRlbnNpb24sIGVuYWJsZVB1Ymxpc2hpbmcsIHByb3BlcnRpZXMgfSA9IGFkZEl0ZW1TdGF0ZTtcbiAgICByZXR1cm4gYXdhaXQgY29tbWl0SXRlbShpdGVtSWQsIHtcbiAgICAgIGZpbGUsXG4gICAgICB0eXBlLFxuICAgICAgZXh0ZW5zaW9uLFxuICAgICAgZW5hYmxlUHVibGlzaGluZyxcbiAgICAgIHByb3BlcnRpZXNcbiAgICB9KTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiBhbiBpdGVtIHdhcyBwYXJ0aWFsbHkgdXBsb2FkZWQsIGNhbmNlbCBpdCBiZWZvcmUgdGhyb3dpbmcgZXJyb3JcbiAgICBhd2FpdCBjYW5jZWxVcGxvYWQoKTtcbiAgICBjb25zb2xlLmVycm9yKChfYyA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBlcnJvcik7XG4gICAgdGhyb3cgKF9kID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGVycm9yO1xuICB9XG59O1xuLy8gLS0tIFVSTFxuY29uc3QgaGFuZGxlQWRkVXJsID0gKGl0ZW0sIGNvbmZpZywgYXBpKSA9PiB7XG4gIGlmIChpdGVtLmFnc1R5cGUpIHtcbiAgICByZXR1cm4gYWRkU2VjdXJlQUdTVXJsKGl0ZW0pO1xuICB9XG4gIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgY2FzZSBcIktNTFwiOlxuICAgICAgcmV0dXJuIGFkZEtNTFVybChpdGVtLCBjb25maWcsIGFwaSk7XG4gICAgY2FzZSBcIldNU1wiOlxuICAgICAgcmV0dXJuIGFkZFdNU1VybChpdGVtKTtcbiAgICBjYXNlIFwiV0ZTXCI6XG4gICAgICByZXR1cm4gYWRkV0ZTVXJsKGl0ZW0pO1xuICAgIGNhc2UgXCJXTVRTXCI6XG4gICAgICByZXR1cm4gYWRkV01UU1VybChpdGVtKTtcbiAgICBjYXNlIFwiT0dDRmVhdHVyZVNlcnZlclwiOlxuICAgICAgcmV0dXJuIGFkZE9HQ0ZlYXR1cmVTZXJ2aWNlKGl0ZW0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYWRkVXJsKGl0ZW0pO1xuICB9XG59O1xuY29uc3QgZ2V0VHlwZUtleXdvcmRzID0gKGl0ZW0pID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHR5cGUsIGFnc1R5cGUgfSA9IGl0ZW07XG4gIGNvbnN0IGdlbmVyYXRlZFR5cGVzID0gKChfYSA9IGFkZENyZWF0ZUl0ZW1UeXBlc1thZ3NUeXBlICE9PSBudWxsICYmIGFnc1R5cGUgIT09IHZvaWQgMCA/IGFnc1R5cGUgOiB0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGVLZXl3b3JkcykgfHwgW107XG4gIHJldHVybiBbLi4uZ2VuZXJhdGVkVHlwZXMsIC4uLihpdGVtLnR5cGVLZXl3b3JkcyB8fCBbXSldO1xufTtcbmNvbnN0IGFkZFVybCA9IGFzeW5jIChpdGVtKSA9PiB7XG4gIGNvbnN0IHsgY3VzdG9tUGFyYW1ldGVyczogY3VzdG9tUGFyYW1zLCBhZ3NUeXBlIH0gPSBpdGVtO1xuICBjb25zdCB7IHR5cGUgfSA9IGdldEl0ZW1JbmZvQnlUeXBlKGl0ZW0udHlwZSk7XG4gIGNvbnN0IGNvbnRlbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IHR5cGVLZXl3b3JkczogZ2V0VHlwZUtleXdvcmRzKGl0ZW0pLCB0eXBlIH0pO1xuICBpZiAoKGN1c3RvbVBhcmFtcyA9PT0gbnVsbCB8fCBjdXN0b21QYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1c3RvbVBhcmFtcy5sZW5ndGgpID49IDEgJiYgISFhZ3NUeXBlKSB7XG4gICAgY29uc3QgeyBjdXN0b21QYXJhbWV0ZXJzIH0gPSBmb3JtYXRDdXN0b21QYXJhbWV0ZXJzKGN1c3RvbVBhcmFtcyk7XG4gICAgY29udGVudC50ZXh0ID0gSlNPTi5zdHJpbmdpZnkoeyBjdXN0b21QYXJhbWV0ZXJzIH0pO1xuICB9XG4gIHJldHVybiBzZW5kQWRkSXRlbVJlcXVlc3QoY29udGVudCk7XG59O1xuLy8gLS0tIE90aGVyXG5hc3luYyBmdW5jdGlvbiBnZXRJdGVtU3RhdHVzKGlkLCBvcHRpb25zID0ge30sIHN0YXR1c1VybCkge1xuICB2YXIgX2E7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGNvbmZpZ1N0YXRlLnVzZXI7XG4gICAgY29uc3QgdXJsID0gc3RhdHVzVXJsICE9PSBudWxsICYmIHN0YXR1c1VybCAhPT0gdm9pZCAwID8gc3RhdHVzVXJsIDogYCR7dXNlci51c2VyQ29udGVudFVybH0vaXRlbXMvJHtpZH0vc3RhdHVzYDtcbiAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5qb2JJZCkgPyB7IGpvYklkOiBvcHRpb25zLmpvYklkIH0gOiB7fTtcbiAgICAvLyBOZWVkIHRvIGF3YWl0IGhlcmUgc28gaXQgd2lsbCBjYXRjaCByZWxhdGVkIGVycm9yIGJlbG93XG4gICAgY29uc3Qgam9iU3RhdHVzID0gYXdhaXQgcG9sbEZvclN0YXR1cyh1cmwsIHsgcmVxdWVzdFBhcmFtcyB9KTtcbiAgICByZXR1cm4gam9iU3RhdHVzO1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGlmICghKChfYSA9IGVycm9yLnN0YXR1c01lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcIkl0ZW0gc3RhdHVzIGRvZXNuJ3QgZXhpc3RcIikpIHx8ICFvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB7IGl0ZW1JZDogaWQsIHN0YXR1czogXCJzdGF0dXMtbm90LWZvdW5kXCIsIGxhc3RVcGRhdGVkVGltZTogMCwgc3VibWlzc2lvblRpbWU6IDAsIHJlY29yZENvdW50OiAwIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZFJlc291cmNlKG93bmVyLCBpZCwgZm9sZGVyLCBwYXJhbXMpIHtcbiAgY29uc3QgeyBjb25maWcgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCBmb2xkZXJQYXRoID0gZm9sZGVyLmlkICYmIGZvbGRlci5pZCAhPT0gXCIvXCIgJiYgZm9sZGVyLmlkICE9PSBvd25lciA/IGAvJHtmb2xkZXIuaWR9YCA6IFwiXCI7XG4gIGNvbnN0IHVybCA9IGAke2NvbmZpZy5yZXN0QmFzZVVybH1jb250ZW50L3VzZXJzLyR7b3duZXJ9JHtmb2xkZXJQYXRofS9pdGVtcy8ke2lkfS9hZGRSZXNvdXJjZXNgO1xuICByZXR1cm4gcmVxdWVzdCh1cmwsIHBhcmFtcywge30sIFwicG9zdFwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZENsb3VkUHJvdmlkZXJSZXNvdXJjZShyZXNvdXJjZSwgaWQpIHtcbiAgY29uc3QgZm9sZGVyID0gaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXI7XG4gIGNvbnN0IHsgdXNlciB9ID0gY29uZmlnU3RhdGU7XG4gIC8vIGFkZCBjbG91ZCBpbmZvIHRvIHJlc291cmNlXG4gIHJldHVybiBhZGRSZXNvdXJjZSh1c2VyLnVzZXJuYW1lLCBpZCwgZm9sZGVyLCB7XG4gICAgZmlsZU5hbWU6IFwiY2xvdWRQcm92aWRlci5qc29uXCIsXG4gICAgdGV4dDogSlNPTi5zdHJpbmdpZnkocmVzb3VyY2UpLFxuICAgIGFjY2VzczogXCJwcml2YXRlXCJcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEFHU1RodW1ibmFpbChpdGVtKSB7XG4gIGNvbnN0IHsgdXJsLCB0aHVtYm5haWxVUkwsIHNlcnZpY2VJbmZvLCBleHRlbnQgfSA9IGl0ZW07XG4gIGlmICh0aHVtYm5haWxVUkwpIHtcbiAgICByZXR1cm4gdGh1bWJuYWlsVVJMO1xuICB9XG4gIGlmICghW1wiTWFwIFNlcnZpY2VcIiwgXCJGZWF0dXJlIFNlcnZpY2VcIiwgXCJJbWFnZSBTZXJ2aWNlXCJdLmluY2x1ZGVzKGl0ZW0udHlwZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoW1wiTWFwIFNlcnZpY2VcIiwgXCJJbWFnZSBTZXJ2aWNlXCJdLmluY2x1ZGVzKGl0ZW0udHlwZSkgfHwgdXJsLmluZGV4T2YoXCJNYXBTZXJ2ZXJcIikgIT09IC0xKSB7XG4gICAgY29uc3QgZXh0ZW50U3RyaW5nID0gZXh0ZW50VG9TdHJpbmcoZXh0ZW50KTtcbiAgICAvLyBtYWtlIHRodW1ibmFpbCBpbiBzZXJ2aWNlIHNwYXRpYWwgcmVmZXJlbmNlXG4gICAgY29uc3QgZXhwb3J0Q2FsbE9wdHMgPSB7IHNlcnZpY2VVcmw6IHVybCwgZXh0ZW50OiBleHRlbnRTdHJpbmcsIHNpemU6IFwiODAwLDUzMlwiLCBmb3JtYXQ6IFwiaW1hZ2VcIiwgc2VydmljZUluZm8gfTtcbiAgICByZXR1cm4gZXh0ZW50ID8gYnVpbGRFeHBvcnRDYWxsKGV4cG9ydENhbGxPcHRzKSA6IG51bGw7XG4gIH1cbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBidWlsZFRodW1ibmFpbFVSTEZyb21GU0l0ZW0oaXRlbSk7XG4gIGlmIChlcnJvcikge1xuICAgIC8vIElkZWFsbHkgdGhlIHRodW1ibmFpbCBnZW5lcmF0aW9uIHByb2Nlc3Mgc2hvdWxkbid0IHN0b3AgdGhlIG90aGVyIHByb2Nlc3MgaW4gY2FzZSBvZiBmYWlsaW5nXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgdGh1bWJuYWlsXCIsIGVycm9yKTtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYnVpbGRFeHBvcnRDYWxsKGV4cG9ydENhbGxPcHRzKSB7XG4gIHZhciBfYTtcbiAgbGV0IHsgdmlzaWJsZUxheWVycywgc2VydmljZVVybCwgc2VydmljZUluZm8sIHNpemUsIGV4dGVudCwgYmJveFNSLCBpbWFnZVNSLCBmb3JtYXQgfSA9IGV4cG9ydENhbGxPcHRzO1xuICBsZXQgcG9zaXRpb247XG4gIGlmICghc2VydmljZUluZm8pIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBsZXQgaXNNYXAgPSBzZXJ2aWNlVXJsLmluZGV4T2YoXCIvTWFwU2VydmVyXCIpID4gLTE7XG4gIGlmICghdmlzaWJsZUxheWVycyAmJiBpc01hcCkge1xuICAgIGxldCBsYXllcklkO1xuICAgIC8vIGl0J3MganVzdCBvbmUgbGF5ZXIgb2YgYSBtYXAgc2VydmljZVxuICAgIHBvc2l0aW9uID0gc2VydmljZVVybC5pbmRleE9mKFwiL01hcFNlcnZlclwiKTtcbiAgICBjb25zdCBxdWVyeVBvc2l0aW9uID0gc2VydmljZVVybC5pbmRleE9mKFwiP1wiKTtcbiAgICBpZiAocXVlcnlQb3NpdGlvbiA+IC0xKSB7XG4gICAgICBsYXllcklkID0gc2VydmljZVVybC5zdWJzdHJpbmcocG9zaXRpb24gKyAxMSwgcXVlcnlQb3NpdGlvbik7XG4gICAgICBzZXJ2aWNlVXJsID0gc2VydmljZVVybC5zdWJzdHJpbmcoMCwgcG9zaXRpb24gKyAxMCkgKyBzZXJ2aWNlVXJsLnN1YnN0cmluZyhxdWVyeVBvc2l0aW9uKTtcbiAgICAgIHZpc2libGVMYXllcnMgPSBsYXllcklkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxheWVySWQgPSBzZXJ2aWNlVXJsLnN1YnN0cmluZyhwb3NpdGlvbiArIDExKTtcbiAgICAgIHNlcnZpY2VVcmwgPSBzZXJ2aWNlVXJsLnN1YnN0cmluZygwLCBwb3NpdGlvbiArIDEwKTtcbiAgICAgIHZpc2libGVMYXllcnMgPSBsYXllcklkO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzTWFwICYmIHNlcnZpY2VJbmZvKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHByb3h5IHNlcnZpY2UgZW5kaW5nIGluIC9zZXJ2aWNlXG4gICAgaWYgKHNlcnZpY2VJbmZvLmNhcGFiaWxpdGllcykge1xuICAgICAgaXNNYXAgPSBzZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibWFwXCIpID4gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gb2xkZXIgc2VydmVyc1xuICAgICAgaXNNYXAgPSBzZXJ2aWNlSW5mby5zdXBwb3J0ZWRJbWFnZUZvcm1hdFR5cGVzO1xuICAgIH1cbiAgfVxuICBsZXQgdXJsID0gc2VydmljZVVybDtcbiAgcG9zaXRpb24gPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gIGlmIChwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICBpZiAoaXNNYXApIHtcbiAgICAgIHVybCArPSBcIi9leHBvcnQ/XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZXJ2aWNlSW5mby5jdXJyZW50VmVyc2lvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZXJ2aWNlSW5mby5jdXJyZW50VmVyc2lvbiA+PSAxMC4xKSB7XG4gICAgICB1cmwgKz0gXCIvaW5mby90aHVtYm5haWxcIjtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXJsICs9IFwiL2V4cG9ydEltYWdlP1wiO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoaXNNYXApIHtcbiAgICAgIHVybCA9IGAke3VybC5zdWJzdHJpbmcoMCwgcG9zaXRpb24pfS9leHBvcnQke3VybC5zdWJzdHJpbmcocG9zaXRpb24sIHVybC5sZW5ndGgpfSZgO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2VydmljZUluZm8uY3VycmVudFZlcnNpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgc2VydmljZUluZm8uY3VycmVudFZlcnNpb24gPj0gMTAuMSkge1xuICAgICAgdXJsID0gYCR7dXJsLnN1YnN0cmluZygwLCBwb3NpdGlvbil9L2luZm8vdGh1bWJuYWlsJHt1cmwuc3Vic3RyaW5nKHBvc2l0aW9uLCB1cmwubGVuZ3RoKX1gO1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1cmwgPSBgJHt1cmwuc3Vic3RyaW5nKDAsIHBvc2l0aW9uKX0vZXhwb3J0SW1hZ2Uke3VybC5zdWJzdHJpbmcocG9zaXRpb24sIHVybC5sZW5ndGgpfSZgO1xuICAgIH1cbiAgfVxuICB1cmwgKz0gYHNpemU9JHtzaXplfSZiYm94PSR7ZXh0ZW50fWA7XG4gIGlmICgoYmJveFNSID09PSBudWxsIHx8IGJib3hTUiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmJveFNSLmxlbmd0aCkgPiAwKSB7XG4gICAgdXJsICs9IGAmYmJveFNSPSR7YmJveFNSfWA7XG4gIH1cbiAgaWYgKChpbWFnZVNSID09PSBudWxsIHx8IGltYWdlU1IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlU1IubGVuZ3RoKSA+IDApIHtcbiAgICB1cmwgKz0gYCZpbWFnZVNSPSR7aW1hZ2VTUn1gO1xuICB9XG4gIGlmIChpc01hcCAmJiAoKF9hID0gc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLnN1cHBvcnRlZEltYWdlRm9ybWF0VHlwZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleE9mKFwiUE5HMzJcIikpID4gLTEpIHtcbiAgICB1cmwgKz0gYCZmb3JtYXQ9cG5nMzImZj0ke2Zvcm1hdH1gO1xuICB9XG4gIGVsc2UgaWYgKGlzTWFwKSB7XG4gICAgdXJsICs9IGAmZm9ybWF0PXBuZzI0JmY9JHtmb3JtYXR9YDtcbiAgfVxuICBlbHNlIHtcbiAgICB1cmwgKz0gYCZmb3JtYXQ9anBncG5nJmY9JHtmb3JtYXR9YDtcbiAgfVxuICBpZiAoaXNNYXApIHtcbiAgICBpZiAoKHZpc2libGVMYXllcnMgPT09IG51bGwgfHwgdmlzaWJsZUxheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzaWJsZUxheWVycy5sZW5ndGgpID4gMCkge1xuICAgICAgdXJsICs9IGAmbGF5ZXJzPXNob3c6JHt2aXNpYmxlTGF5ZXJzfWA7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHVybCArPSBcIiZpbnRlcnBvbGF0aW9uPVJTUF9OZWFyZXN0TmVpZ2hib3ImYmFuZElkcz1udWxsXCI7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVGh1bWJuYWlsRm9yRlNJdGVtNHgoaWQsIHBvcnRhbCkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgW01hcCwgTWFwVmlldywgRmVhdHVyZUxheWVyLCBCYXNlbWFwLCBwcmludCwgUHJpbnRUZW1wbGF0ZSwgUHJpbnRQYXJhbWV0ZXJzLCBzY2FsZVJhbmdlXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICBcImVzcmkvTWFwXCIsXG4gICAgXCJlc3JpL3ZpZXdzL01hcFZpZXdcIixcbiAgICBcImVzcmkvbGF5ZXJzL0ZlYXR1cmVMYXllclwiLFxuICAgIFwiZXNyaS9CYXNlbWFwXCIsXG4gICAgXCJlc3JpL3Jlc3QvcHJpbnRcIixcbiAgICBcImVzcmkvcmVzdC9zdXBwb3J0L1ByaW50VGVtcGxhdGVcIixcbiAgICBcImVzcmkvcmVzdC9zdXBwb3J0L1ByaW50UGFyYW1ldGVyc1wiLFxuICAgIFwiZXNyaS9zbWFydE1hcHBpbmcvaGV1cmlzdGljcy9zY2FsZVJhbmdlXCJcbiAgXSk7XG4gIHRyeSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlSGlkZGVuTWFwRGl2KDgwMCwgNTMyKTtcbiAgICBjb25zdCBrbm93bkJhc2VtYXBJZCA9IHBvcnRhbC5kZWZhdWx0QmFzZW1hcC5pZC5pbmNsdWRlcyhcImJhc2VtYXBcIik7XG4gICAgY29uc3QgbGF5ZXIgPSBuZXcgRmVhdHVyZUxheWVyKHtcbiAgICAgIHBvcnRhbEl0ZW06IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHBvcnRhbFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoe1xuICAgICAgYmFzZW1hcDoga25vd25CYXNlbWFwSWRcbiAgICAgICAgPyBcInRvcG8tdmVjdG9yXCJcbiAgICAgICAgOiBuZXcgQmFzZW1hcCh7XG4gICAgICAgICAgcG9ydGFsSXRlbToge1xuICAgICAgICAgICAgaWQ6IHBvcnRhbC5kZWZhdWx0QmFzZW1hcC5pZCxcbiAgICAgICAgICAgIHBvcnRhbFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IE1hcFZpZXcoe1xuICAgICAgbWFwLFxuICAgICAgY29udGFpbmVyXG4gICAgfSk7XG4gICAgYXdhaXQgbWFwLndhdGNoKFwibG9hZGVkXCIpO1xuICAgIGxldCBtaW5TY2FsZSA9IDA7XG4gICAgbGV0IG1heFNjYWxlID0gMDtcbiAgICBpZiAoIWtub3duQmFzZW1hcElkKSB7XG4gICAgICAoeyBtaW5TY2FsZSwgbWF4U2NhbGUgfSA9IGF3YWl0IHNjYWxlUmFuZ2Uoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgdmlld1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnRSZXNwb25zZSA9IGF3YWl0IGxheWVyLnF1ZXJ5RXh0ZW50KCk7XG4gICAgdmlldy5nb1RvKGV4dGVudFJlc3BvbnNlLmV4dGVudCk7XG4gICAgbGF5ZXIubWluU2NhbGUgPSBtaW5TY2FsZTtcbiAgICBsYXllci5tYXhTY2FsZSA9IG1heFNjYWxlO1xuICAgIHZpZXcubWFwLmFkZChsYXllcik7XG4gICAgdmlldy5zY2FsZSA9IG1heFNjYWxlO1xuICAgIGF3YWl0IHRpbWVvdXQoMjAwMCk7XG4gICAgLy8gdXJsIHRvIHRoZSBwcmludCBzZXJ2aWNlXG4gICAgY29uc3QgdXJsID0gKF9jID0gKF9iID0gKF9hID0gcG9ydGFsLmhlbHBlclNlcnZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJpbnRUYXNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXJsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcImh0dHBzOi8vdXRpbGl0eS5hcmNnaXNvbmxpbmUuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1V0aWxpdGllcy9QcmludGluZ1Rvb2xzL0dQU2VydmVyL0V4cG9ydCUyMFdlYiUyME1hcCUyMFRhc2tcIjtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IG5ldyBQcmludFRlbXBsYXRlKHtcbiAgICAgIGZvcm1hdDogXCJwbmczMlwiLFxuICAgICAgZXhwb3J0T3B0aW9uczoge1xuICAgICAgICBkcGk6IDk2LFxuICAgICAgICB3aWR0aDogODAwLFxuICAgICAgICBoZWlnaHQ6IDUzMlxuICAgICAgfSxcbiAgICAgIGxheW91dDogXCJtYXAtb25seVwiLFxuICAgICAgc2hvd0xhYmVsczogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGlvblZpc2libGU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFByaW50UGFyYW1ldGVycyh7XG4gICAgICB2aWV3OiB2aWV3LFxuICAgICAgdGVtcGxhdGVcbiAgICB9KTtcbiAgICBjb25zdCBwcmludFJlc3VsdCA9IGF3YWl0IHByaW50LmV4ZWN1dGUodXJsLCBwYXJhbXMpO1xuICAgIGRlc3Ryb3lIaWRkZW5NYXBEaXYoKTtcbiAgICByZXR1cm4gcHJpbnRSZXN1bHQudXJsO1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGRlc3Ryb3lIaWRkZW5NYXBEaXYoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRUaHVtYm5haWxVUkxGcm9tRlNJdGVtKGl0ZW0pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IGNvbmZpZywgcG9ydGFsLCBhcGkgfSA9IGNvbmZpZ1N0YXRlO1xuICBpZiAoYXBpID09PSA0KSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiBhd2FpdCBidWlsZFRodW1ibmFpbEZvckZTSXRlbTR4KGl0ZW0uaWQsIHBvcnRhbCkgfTtcbiAgfVxuICBjb25zdCBbZXNyaUlkLCBGZWF0dXJlTGF5ZXIsIEV4dGVudF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgXCJlc3JpL0lkZW50aXR5TWFuYWdlclwiLFxuICAgIFwiZXNyaS9sYXllcnMvRmVhdHVyZUxheWVyXCIsXG4gICAgXCJlc3JpL2dlb21ldHJ5L0V4dGVudFwiXG4gIF0pO1xuICBjb25zdCB7IHNlcnZpY2VJbmZvLCBwcm94eVVybCB9ID0gaXRlbTtcbiAgLy8gZnJvbSBpdGVtIHByb3BlcnRpZXMgcGFnZSBvciB2aWV3ZXIgJ3NhdmUgbGF5ZXInIChub3QgZm9yIGZlYXR1cmUgY29sbGVjdGlvbilcbiAgLy8gbmV3RXh0ZW50IGFuZCBsYXllcnMgb3ZlcndyaXRlcyBmb3IgdGhlIGl0ZW0gYXJlIG9wdGlvbmFsXG4gIC8vIDEuIGdldCBpdGVtIC9kYXRhIHRvIGdldCBvdmVyd3JpdGVzXG4gIC8vIDIuIG1ha2Ugc2VydmljZSBpbmZvIHJlcXVlc3QgdG8gZ2V0IGxheWVyc1xuICAvLyAzLiBidWlsZCB3ZWJNYXAgb2JqZWN0XG4gIC8vIDQuIGNhbGwgR2VvcHJvY2Vzc29yIHRhc2tcbiAgY29uc3Qgd2ViTWFwID0ge1xuICAgIGJhc2VNYXA6IGNvbmZpZy5kZWZhdWx0QmFzZW1hcCB8fCBjb25maWcuc2VsZi5kZWZhdWx0QmFzZW1hcCxcbiAgICBvcGVyYXRpb25hbExheWVyczogW11cbiAgfTtcbiAgd2ViTWFwLmJhc2VNYXAudGl0bGUgPSBcImJhc2VtYXBcIjtcbiAgY29uc3QgbGVuID0gd2ViTWFwLmJhc2VNYXAuYmFzZU1hcExheWVycy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgbGF5ZXIgPSB3ZWJNYXAuYmFzZU1hcC5iYXNlTWFwTGF5ZXJzW2ldO1xuICAgIGlmICghbGF5ZXIuaXNSZWZlcmVuY2UpIHtcbiAgICAgIC8vIHdlIG5lZWQgb25seSBvbmUgYmFzZW1hcCBsYXllciBhbmQgd2UgaGlkZSBpdFxuICAgICAgaWYgKChjb25maWcuYWxsU1NMIHx8IGxvY2F0aW9uLnByb3RvY29sID09IFwiaHR0cHM6XCIpICYmXG4gICAgICAgIChpc0hvc3RlZFNlcnZpY2UobGF5ZXIudXJsKSB8fCBzdXBwb3J0c0h0dHBzKGxheWVyLnVybCkpKSB7XG4gICAgICAgIGxheWVyLnVybCA9IGxheWVyLnVybC5yZXBsYWNlKFwiaHR0cDpcIiwgXCJodHRwczpcIik7XG4gICAgICB9XG4gICAgICBsYXllci52aXNpYmlsaXR5ID0gZmFsc2U7XG4gICAgICB3ZWJNYXAuYmFzZU1hcC5iYXNlTWFwTGF5ZXJzID0gW2xheWVyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIXNlcnZpY2VJbmZvKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0OiBcIlwiIH07XG4gIH1cbiAgY29uc3QgbGF5ZXJzID0gc2VydmljZUluZm8ubGF5ZXJzIHx8IFtdO1xuICBjb25zdCBpdGVtVXJsID0gcHJveHlVcmwgfHwgaXRlbS51cmw7XG4gIGNvbnN0IHVybE9iamVjdCA9IGF3YWl0IHVybFRvT2JqZWN0KGl0ZW1VcmwpO1xuICBjb25zdCBjcmVkZW50aWFscyA9IGVzcmlJZC5maW5kQ3JlZGVudGlhbCh1cmxPYmplY3QucGF0aCk7XG4gIGxheWVycy5yZXZlcnNlKCkuZm9yRWFjaChhc3luYyAobGF5ZXIpID0+IHtcbiAgICBjb25zdCBvcGVyYXRpb25hbExheWVyID0ge1xuICAgICAgdXJsOiBgJHtpdGVtVXJsfS8ke2xheWVyLmlkfSR7Y3JlZGVudGlhbHMgPyBgP3Rva2VuPSR7Y3JlZGVudGlhbHMudG9rZW59YCA6IFwiXCJ9YCxcbiAgICAgIGlkOiBgJHtpdGVtLmlkIHx8IE1hdGgucmFuZG9tKCl9XyR7bGF5ZXIuaWR9YCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0aXRsZTogYCR7aXRlbS50aXRsZSB8fCBcInRpdGxlXCJ9XyR7bGF5ZXIuaWR9YCxcbiAgICAgIHZpc2liaWxpdHk6IHRydWUsXG4gICAgICBsYXllckRlZmluaXRpb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgbGF5ZXJzLmZvckVhY2goKGx5cikgPT4ge1xuICAgICAgaWYgKGx5ci5pZCA9PT0gbGF5ZXIuaWQgJiYgIWZvdW5kKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgb3BlcmF0aW9uYWxMYXllci5sYXllckRlZmluaXRpb24gPSBseXIubGF5ZXJEZWZpbml0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbGF5ZXJzLmxlbmd0aCB8fCAobGF5ZXJzLmxlbmd0aCAmJiBmb3VuZCkpIHtcbiAgICAgIHdlYk1hcC5vcGVyYXRpb25hbExheWVycy5wdXNoKG9wZXJhdGlvbmFsTGF5ZXIpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBleHRlbnQgPSBbXG4gICAgWy0xODAsIC05MF0sXG4gICAgWzE4MCwgOTBdXG4gIF07XG4gIGlmICh0eXBlb2YgaXRlbS5leHRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBlID0gaXRlbS5leHRlbnQuc3BsaXQoXCIsXCIpO1xuICAgIGV4dGVudCA9IFtcbiAgICAgIFtwYXJzZUZsb2F0KGVbMF0pLCBwYXJzZUZsb2F0KGVbMV0pXSxcbiAgICAgIFtwYXJzZUZsb2F0KGVbMl0pLCBwYXJzZUZsb2F0KGVbM10pXVxuICAgIF07XG4gIH1cbiAgZWxzZSBpZiAoKChfYSA9IGl0ZW0uZXh0ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDApIHtcbiAgICBleHRlbnQgPSBpdGVtLmV4dGVudDtcbiAgfVxuICBpZiAod2ViTWFwLm9wZXJhdGlvbmFsTGF5ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCBmZWF0dXJlTGF5ZXIgPSBuZXcgRmVhdHVyZUxheWVyKHdlYk1hcC5vcGVyYXRpb25hbExheWVyc1swXS51cmwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgZmVhdHVyZUxheWVyLm9uKFwibG9hZFwiLCBhc3luYyAoZmVhdExheWVyKSA9PiB7XG4gICAgICAgIGlmIChmZWF0TGF5ZXIgPT09IG51bGwgfHwgZmVhdExheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWF0TGF5ZXIubGF5ZXIpIHtcbiAgICAgICAgICBmZWF0dXJlTGF5ZXIgPSBmZWF0TGF5ZXIubGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW50QXNMaXN0ID0gYXdhaXQgZ2V0RXh0ZW50V2l0aEZlYXR1cmVzKGZlYXR1cmVMYXllciwgZXh0ZW50KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB0aHVtYm5haWxVcmwgPSBhd2FpdCBidWlsZFRodW1ibmFpbFVSTEZyb21XZWJNYXAod2ViTWFwLCBleHRlbnRBc0xpc3QpO1xuICAgICAgICAgIHJlc29sdmUoeyByZXN1bHQ6IHRodW1ibmFpbFVybCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXNvbHZlKHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBlcnJvciB9IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBjaGVjayBpZiBhdCBsZWFzdCBvbmUgbGF5ZXIgaXMgaW4gc2NhbGVcbiAgICBjb25zdCBleHRlbnRBc0xpc3QgPSBpdGVtLmV4dGVudDtcbiAgICBjb25zdCBleHQgPSBuZXcgRXh0ZW50KGV4dGVudEFzTGlzdFswXVswXSwgZXh0ZW50QXNMaXN0WzBdWzFdLCBleHRlbnRBc0xpc3RbMV1bMF0sIGV4dGVudEFzTGlzdFsxXVsxXSk7XG4gICAgY29uc3QgdGh1bWJuYWlsU2NhbGUgPSBnZXRTY2FsZUZvckV4dGVudChleHQsIDIwMCk7XG4gICAgY29uc3Qgb3BMYXllcnMgPSBbXTtcbiAgICBjb25zdCBmZWF0dXJlTGF5ZXJzID0gW107XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICB3ZWJNYXAub3BlcmF0aW9uYWxMYXllcnMuZm9yRWFjaCgob3BMYXllcikgPT4ge1xuICAgICAgY29uc3QgZmVhdHVyZUxheWVyID0gbmV3IEZlYXR1cmVMYXllcihvcExheWVyLnVybCk7XG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgZmVhdHVyZUxheWVyLm9uKFwibG9hZFwiLCAobGF5ZXIpID0+IHtcbiAgICAgICAgICBvcExheWVycy5wdXNoKG9wTGF5ZXIpO1xuICAgICAgICAgIGZlYXR1cmVMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgaWYgKGxheWVyLm1pblNjYWxlIDw9IHRodW1ibmFpbFNjYWxlICYmIGxheWVyLm1heFNjYWxlID4gdGh1bWJuYWlsU2NhbGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZmVhdHVyZUxheWVyLm9uKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgLy8gY2xlYW4gb3V0IGxheWVycyB0aGF0IGRpZG4ndCBsb2FkIGZyb20gdGhlIHdlYm1hcFxuICAgIHdlYk1hcC5vcGVyYXRpb25hbExheWVycyA9IG9wTGF5ZXJzO1xuICAgIGNvbnN0IGZvdW5kID0gcmVzcG9uc2VzLmZpbHRlcigocmVzKSA9PiByZXMpLmxlbmd0aCA+IDA7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghZm91bmQgJiYgZmVhdHVyZUxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHNhdmluZyB0aHVtYm5haWwgd2l0aCBpdGVtIGV4dGVudCB3aWxsIGJlIGJsYW5rXG4gICAgICAgIC8vIHpvb20gdG8gZmVhdHVyZXMgaW5zdGVhZDsgdXNlIGZpcnN0IHdvcmtpbmcgbGF5ZXJcbiAgICAgICAgY29uc3QgZXh0ZW50V2l0aEZlYXR1cmVzID0gYXdhaXQgZ2V0RXh0ZW50V2l0aEZlYXR1cmVzKGZlYXR1cmVMYXllcnNbMF0sIGV4dGVudEFzTGlzdCk7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgYnVpbGRUaHVtYm5haWxVUkxGcm9tV2ViTWFwKHdlYk1hcCwgZXh0ZW50V2l0aEZlYXR1cmVzKSB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgYnVpbGRUaHVtYm5haWxVUkxGcm9tV2ViTWFwKHdlYk1hcCwgZXh0ZW50QXNMaXN0KSB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiwgbWVzc2FnZTogZXJyb3IgfSB9O1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyQXV0aChpdGVtSW5mbywgY2hlY2tVcmxSZXNwb25zZSwgY2hlY2tBdXRoKSB7XG4gIHZhciBfYSwgX2I7XG4gIC8vSWYgYSBzZXJ2aWNlIGlzIGZlZGVyYXRlZCB3aXRoIGFub3RoZXIgcG9ydGFsLCBhbmQgaXMgc2VjdXJlZCB3aXRoIHdlYiB0aWVyIGF1dGhlbnRpY2F0aW9uXG4gIC8vaXQgd2lsbCBzdGlsbCByZXBvcnQgYmFjayB0aGF0IGl0cyBzZWN1cmVkIHdpdGggdG9rZW4gc2VjdXJpdHkgKFwiNDk5XCIpLCBldmVuIHRob3VnaCBpdCB1c2VzIHdlYiB0aWVyIGF1dGhlbnRpY2F0aW9uIChcIjQwMVwiKVxuICAvL2l0IGRvZXMgdGhpcyBiZWNhdXNlIGl0cyBmZWRlcmF0ZWQgd2l0aCBhbm90aGVyIHBvcnRhbCwgdW5mb3J0dW5hdGVseS4gIElmIHNlY3VyZWQgd2l0aCB3ZWIgdGllciwgdGhlcmVcbiAgLy9pc24ndCBhIHJlYXNvbiB0byBzdG9yZSB0aGUgY3JlZGVudGlhbHMgc28gbGV0cyBoaWRlIHRoYXQgYm94LCBidXQgdGhlIG9ubHkgd2F5IHRvIGNoZWNrIHRoYXQgaXMgdG8gY2FsbFxuICAvL2NoZWNrVXJsIHdpdGggdGhlIGdlbmVyYXRlVG9rZW4gZW5kcG9pbnQsIGFuZCBzZWUgaWYgdGhhdCByZXR1cm5zIDQwMVxuICAvL2h0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8zNzkxXG4gIGlmICgoY2hlY2tVcmxSZXNwb25zZSA9PT0gbnVsbCB8fCBjaGVja1VybFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGVja1VybFJlc3BvbnNlLmh0dHBTdGF0dXNDb2RlKSA9PT0gNDk5KSB7XG4gICAgY29uc3QgW2VzcmlJZF0gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICBjb25maWdTdGF0ZS5hcGkgPT09IDMgPyBcImVzcmkvSWRlbnRpdHlNYW5hZ2VyXCIgOiBcImVzcmkvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyXCJcbiAgICBdKTtcbiAgICBjb25zdCB7IHVybCwgcGFzc3dvcmQsIHVzZXJuYW1lIH0gPSBpdGVtSW5mbztcbiAgICBjb25zdCB0b2tlblNlcnZpY2VVcmwgPSBhd2FpdCBlc3JpSWQuX2dldFRva2VuU3ZjVXJsKHVybCk7XG4gICAgbGV0IGdlbmVyYXRlVG9rZW5VcmwgPSAoX2EgPSB0b2tlblNlcnZpY2VVcmwuYXV0aEluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2tlblNlcnZpY2VzVXJsO1xuICAgIGlmIChnZW5lcmF0ZVRva2VuVXJsKSB7XG4gICAgICAvLyBBZGQgYSB0cmFpbGluZyBzbGFzaCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoZ2VuZXJhdGVUb2tlblVybFtnZW5lcmF0ZVRva2VuVXJsLmxlbmd0aCAtIDFdICE9PSBcIi9cIikge1xuICAgICAgICBnZW5lcmF0ZVRva2VuVXJsICs9IFwiL1wiO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0SXNTZWN1cmVkKHsgcGFzc3dvcmQsIHVzZXJuYW1lIH0sIGdlbmVyYXRlVG9rZW5VcmwgIT09IG51bGwgJiYgZ2VuZXJhdGVUb2tlblVybCAhPT0gdm9pZCAwID8gZ2VuZXJhdGVUb2tlblVybCA6IFwiXCIsIGdldFJlc3RCYXNlVXJsKCksIGNoZWNrQXV0aCk7XG4gICAgICAgIHJldHVybiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LnNlY3VyZWQpICYmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuaHR0cFN0YXR1c0NvZGUpID09PSA0MDE7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICgoX2IgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluZGV4T2YoXCJIdHRwIFN0YXR1c0NvZGU6IC0xXCIpKSA+IC0xID8gLTEgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VBR1NUaXRsZSh1cmwpIHtcbiAgcmV0dXJuIHBhcnNlQUdTU2VydmVySW5mbyhmb3JtYXRHSVNVcmwodXJsKSkuc2VydmVyTmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQUdTVHlwZSh1cmwpIHtcbiAgY29uc3QgZm9ybWF0dGVkVXJsID0gZm9ybWF0R0lTVXJsKHVybCk7XG4gIGNvbnN0IHNlcnZlclR5cGVBbmRMYXllckluZGV4ID0gcGFyc2VBR1NTZXJ2ZXJJbmZvKHVybCk7XG4gIGNvbnN0IGNvbnRhaW5zQUdTID0gZm9ybWF0dGVkVXJsLnJlcGxhY2UodmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGgsIFwiXCIpLm1hdGNoKGFnc1JlZ0V4cCk7XG4gIGxldCBhZ3NUeXBlID0gc2VydmVyVHlwZUFuZExheWVySW5kZXggPT09IG51bGwgfHwgc2VydmVyVHlwZUFuZExheWVySW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZlclR5cGVBbmRMYXllckluZGV4LnNlcnZlclR5cGU7XG4gIGxldCBzb2VUeXBlID0gc2VydmVyVHlwZUFuZExheWVySW5kZXggPT09IG51bGwgfHwgc2VydmVyVHlwZUFuZExheWVySW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZlclR5cGVBbmRMYXllckluZGV4LmluZGV4O1xuICBjb25zdCBjYXNlQ29ycmVjdGVkID0ge1xuICAgIG1hcHNlcnZlcjogXCJNYXBTZXJ2ZXJcIixcbiAgICBnZW9jb2Rlc2VydmVyOiBcIkdlb2NvZGVTZXJ2ZXJcIixcbiAgICBncHNlcnZlcjogXCJHUFNlcnZlclwiLFxuICAgIGdlb21ldHJ5c2VydmVyOiBcIkdlb21ldHJ5U2VydmVyXCIsXG4gICAgZ2VvZW5yaWNobWVudHNlcnZlcjogXCJHZW9lbnJpY2htZW50U2VydmVyXCIsXG4gICAgaW1hZ2VzZXJ2ZXI6IFwiSW1hZ2VTZXJ2ZXJcIixcbiAgICBuYXNlcnZlcjogXCJOQVNlcnZlclwiLFxuICAgIGZlYXR1cmVzZXJ2ZXI6IFwiRmVhdHVyZVNlcnZlclwiLFxuICAgIGdlb2RhdGFzZXJ2ZXI6IFwiR2VvRGF0YVNlcnZlclwiLFxuICAgIGdsb2Jlc2VydmVyOiBcIkdsb2JlU2VydmVyXCIsXG4gICAgd21zZXJ2ZXI6IFwiV01TZXJ2ZXJcIixcbiAgICBzY2VuZXNlcnZlcjogXCJTY2VuZVNlcnZlclwiLFxuICAgIHZlY3RvcnRpbGVzZXJ2ZXI6IFwiVmVjdG9yVGlsZVNlcnZlclwiLFxuICAgIHN0cmVhbXNlcnZlcjogXCJTdHJlYW1TZXJ2ZXJcIixcbiAgICB2aWRlb3NlcnZlcjogXCJWaWRlb1NlcnZlclwiXG4gIH07XG4gIGlmIChhZ3NUeXBlICYmIGNhc2VDb3JyZWN0ZWRbYWdzVHlwZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIGFnc1R5cGUgPSBjYXNlQ29ycmVjdGVkW2Fnc1R5cGUudG9Mb3dlckNhc2UoKV07XG4gIH1cbiAgLy8gVE9ETzogRml4IHRoaXMgbWFwcGluZyBlYXJsaWVyLCBtYXliZSByZW1vdmUgdGhpcyB3aG9sZSBmdW5jdGlvbj8gVGhlIG9yaWdpbmFsIHVybCBwYXJzZXIgbWlnaHQgbWF5IGJlIGFibGUgdG8gaGFuZGxlIHRoaXMgdXAgZnJvbnRcbiAgaWYgKGFnc1R5cGUgPT09IFwiYWdzXCIgfHwgKCFhZ3NUeXBlICYmIGNvbnRhaW5zQUdTKSkge1xuICAgIGFnc1R5cGUgPSBcIk1hcFNlcnZlclwiO1xuICB9XG4gIGlmIChhZ3NUeXBlID09PSBcIk1hcFNlcnZlclwiICYmIHNvZVR5cGUgIT09IG51bGwpIHtcbiAgICAvLyBMYXllciB3aXRoaW4gYSBtYXBzZXJ2ZXIgLSBDUjI2MDg0NVxuICAgIHJldHVybiBcIkZlYXR1cmVTZXJ2ZXJcIjtcbiAgfVxuICByZXR1cm4gYWdzVHlwZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFNlY3VyZWRBR1NTZXJ2aWNlSW5mbyhpdGVtKSB7XG4gIHZhciBfYTtcbiAgLy8gVE9ETzogUGFzcyBpbiB3aGF0IHdlIG5lZWQgZnJvbSBjb25maWdTdGF0ZSBhcyBhcmdzXG4gIGNvbnN0IHsgY29uZmlnIH0gPSBjb25maWdTdGF0ZTtcbiAgY29uc3QgeyBjaGVja0F1dGgsIHN0b3JlQXV0aCwgdXNlcm5hbWUsIHBhc3N3b3JkIH0gPSBpdGVtO1xuICBpdGVtLnRpdGxlID0gcGFyc2VBR1NUaXRsZShpdGVtLnVybCk7XG4gIGNvbnN0IGFnc1R5cGUgPSBwYXJzZUFHU1R5cGUoaXRlbS51cmwpO1xuICBpZiAoIWFnc1R5cGUgfHwgKGFnc1R5cGUgPT09IFwiU2NlbmVTZXJ2ZXJcIiAmJiAhY29uZmlnLnNjZW5lVmlld2VyRW5hYmxlZCkpIHtcbiAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVua25vd25BR1NUeXBlXCIgfSB9O1xuICB9XG4gIGxldCBpdGVtVHlwZSA9IChfYSA9IGFkZENyZWF0ZUl0ZW1UeXBlc1thZ3NUeXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGU7XG4gIGlmICghaXRlbVR5cGUpIHtcbiAgICBjb25zb2xlLndhcm4oYFVua25vd24gQUdTIFR5cGUgJHthZ3NUeXBlfWApO1xuICAgIC8vIFRPRE86IENhbiB3ZSByZWFjaCB0aGlzIHBvaW50PyBBbmQgaWYgc28gd2lsbCBhbiBpdGVtIGJlIGNyZWF0ZWQ/XG4gIH1cbiAgaXRlbS50eXBlID0gaXRlbVR5cGU7XG4gIGl0ZW0uYWdzVHlwZSA9IGFnc1R5cGU7XG4gIHRyeSB7XG4gICAgaWYgKCFjb25maWdTdGF0ZS51c2VyKSB7XG4gICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKGl0ZW0pIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldElzU2VjdXJlZCh7IHVzZXJuYW1lLCBwYXNzd29yZCB9LCBpdGVtLnVybCwgZ2V0UmVzdEJhc2VVcmwoY29uZmlnU3RhdGUucG9ydGFsKSwgY2hlY2tBdXRoKTtcbiAgICBjb25zdCBjaGVja1VybEFsbG93U3RvcmVkQXV0aCA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5hbGxvd1N0b3JlZEF1dGg7XG4gICAgaWYgKGNoZWNrVXJsQWxsb3dTdG9yZWRBdXRoID09PSBmYWxzZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyAvY2hlY2tVcmwgZmFpbHMgZm9yIHNvbWUgcmVhc29uXG4gICAgICBpdGVtLmFsbG93U3RvcmVkQXV0aCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnNlY3VyZWQpIHtcbiAgICAgIGl0ZW0uaXNTZWN1cmVkID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KTtcbiAgICAgIGl0ZW0uYWxsb3dTdG9yZWRBdXRoID0gZmFsc2U7XG4gICAgICAvL2h0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8zNzkxXG4gICAgICBjb25zdCBpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyID0gYXdhaXQgaXNGZWRlcmF0ZWRXaXRoV2ViVGllckF1dGgoeyB1c2VybmFtZTogaXRlbS51c2VybmFtZSwgcGFzc3dvcmQ6IGl0ZW0ucGFzc3dvcmQsIHVybDogaXRlbS51cmwgfSwgcmVzdWx0LCBjaGVja0F1dGgpO1xuICAgICAgaWYgKCFpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyICYmIHJlc3VsdC5odHRwU3RhdHVzQ29kZSAhPT0gNDAxKSB7XG4gICAgICAgIGl0ZW0uaXNTZWN1cmVkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB7IGlzRmVkZXJhdGVkV2l0aFdlYlRpZXJBdXRoOiBpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyIH0pO1xuICAgICAgICAvLyBPbmx5IGFsbG93IHRvIHRvZ2dsZSBhdXRoIGlmIGAvY2hlY2tVcmxgIGRldGVybWluZSB0aGUgVVJMIGNhbiBiZSByZWFjaGVkXG4gICAgICAgIGlmIChjaGVja1VybEFsbG93U3RvcmVkQXV0aCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpdGVtLmFsbG93U3RvcmVkQXV0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5pc092ZXJyaWRlKSB7XG4gICAgICAgICAgLy8gIzI5OTE2LCBhcmNnaXMtcG9ydGFsLXNlcnZpY2VzLWRlc2lnbiAjMTUzIC0gR2VvZW5yaWNobWVudCBzZXJ2ZXJzIGFyZSBhYmxlIHRvIGhhdmUgYSBwcm94eSBjcmVhdGVkIHdpdGhvdXRcbiAgICAgICAgICAvLyBwcm9tcHRpbmcgZm9yIGNyZWRlbnRpYWxzLiBJbiB0aGlzIGNhc2UgZG9uJ3QgZGlzYWxsb3cgdGhlIHN0b3JlQXV0aCBvcHRpb24gYW5kIHBhc3MgY3JlYXRlQXNTZXJ2aWNlUHJveHlcbiAgICAgICAgICAvLyB0aHJvdWdoIHRvIHRoZSAvYWRkSXRlbSByZXF1ZXN0XG4gICAgICAgICAgaWYgKGFnc1R5cGUgPT09IFwiR2VvZW5yaWNobWVudFNlcnZlclwiICYmICFpdGVtLnN0b3JlQXV0aCkge1xuICAgICAgICAgICAgaXRlbS5jcmVhdGVBc1NlcnZpY2VQcm94eSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5zdG9yZUF1dGggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tBdXRoICYmICFzdG9yZUF1dGgpIHtcbiAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKGl0ZW0pIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBpdGVtIH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0ZlZGVyYXRlZFdpdGhXZWJUaWVyID09PSAtMSkge1xuICAgICAgICAvL2h0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8xOTAwXG4gICAgICAgIC8vaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvaXNzdWVzLzQ3NjVcbiAgICAgICAgLy8gLTEgbWVhbnMgdGhlIHByb3h5IGRvZXMgbm90IHRydXN0IHRoZSBzc2wgY2VydCBmb3IgdGhlIGlzRmVkZXJhdGVkV2l0aFdlYlRpZXJBdXRoIHJlcXVlc3QgZnJvbSBhYm92ZVxuICAgICAgICBjb25zdCB1cGRhdGVkSXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgaXNTZWN1cmVkOiBudWxsLCBjaGVja1VybEVycm9yOiB0cnVlLCBzdG9yZUF1dGg6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKHVwZGF0ZWRJdGVtKSB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyBpc1NlY3VyZWQ6IHsgaHR0cFN0YXR1c0NvZGU6IDQwMSwgaXNGZWRlcmF0ZWRXaXRoV2ViVGllckF1dGg6IGlzRmVkZXJhdGVkV2l0aFdlYlRpZXIgfSB9KTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBhd2FpdCBnZXRBR1NTZXJ2aWNlSW5mbyh1cGRhdGVkSXRlbSkgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKGl0ZW0pIH07XG4gICAgfVxuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIC8vIElmIHRoZSB1c2VyIGFib3J0ZWQgdGhlIGZsb3csIGRvbid0IHRyeSB0byBmZXRjaCBhZ2FpblxuICAgIC8vIEFsc28gcHJldmVudCByZS1yZXF1ZXN0IGlmIGl0J3Mga25vd24gdGhhdCBhbiBhcGkga2V5IGlzIG1pc3NpbmcgKGNvZGUgXCJ1bmF1dGhvcml6ZWRcIilcbiAgICBpZiAoaXNBcHBDb21wb25lbnRFcnJvcihlcnJvcikpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBlcnJvci5jb2RlO1xuICAgICAgaWYgKGNvZGUgPT09IFwiZmxvd0Fib3J0ZWRcIiB8fCBjb2RlID09PSBcInVuYXV0aG9yaXplZFwiIHx8IGNvZGUgPT09IFwiaW52YWxpZFNwYXRpYWxSZWZcIikge1xuICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy9odHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvMTkwMFxuICAgICAgY29uc3QgdXBkYXRlZEl0ZW0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IGlzU2VjdXJlZDogaXRlbS5pc1NlY3VyZWQgfHwgbnVsbCwgY2hlY2tVcmxFcnJvcjogZXJyb3IsIHN0b3JlQXV0aDogZmFsc2UgfSk7XG4gICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKHVwZGF0ZWRJdGVtKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0FwcENvbXBvbmVudEVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IE1BWF9SRVRSWSA9IDM7IC8vIFRPRE86IERldGVybWluZSBhIGJldHRlciBudW1iZXJcbmFzeW5jIGZ1bmN0aW9uIGdldEFHU1NlcnZpY2VJbmZvKGl0ZW0sIHVybCA9IGl0ZW0udXJsLCByZXRyeSA9IDApIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3Q7XG4gIGNvbnN0IFtlc3JpSWRdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgIGNvbmZpZ1N0YXRlLmFwaSA9PT0gMyA/IFwiZXNyaS9JZGVudGl0eU1hbmFnZXJcIiA6IFwiZXNyaS9pZGVudGl0eS9JZGVudGl0eU1hbmFnZXJcIlxuICBdKTtcbiAgY29uc3QgeyB1c2VybmFtZSwgcGFzc3dvcmQsIGNoZWNrQXV0aCwgYWdzVHlwZSB9ID0gaXRlbTtcbiAgY29uc3QgeyB0YWdzOiBpdGVtVGFncyA9IFtdIH0gPSBpdGVtUHJvcGVydGllc1N0YXRlIHx8IHt9O1xuICBjb25zdCBzZWN1cmVTZXJ2aWNlID0gWzQ5OSwgNDk4XTtcbiAgY29uc3Qgc2VydmljZVVybCA9IGZvcm1hdEdJU1VybCh1cmwpO1xuICBpZiAoIWl0ZW0uaXNTZWN1cmVkIHx8XG4gICAgKCgoX2EgPSBpdGVtLmlzU2VjdXJlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBTdGF0dXNDb2RlKSAhPT0gNDAxICYmIGNoZWNrQXV0aCkgfHxcbiAgICAoKChfYiA9IGl0ZW0uY2hlY2tVcmxFcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1lc3NhZ2UpICYmICEhaXRlbS5pc1NlY3VyZWQgJiYgISFpc0FHUyhpdGVtLnR5cGUpKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXJ2aWNlSW5mbyA9IGF3YWl0IGdldFNlcnZpY2VJbmZvKHsgdXNlcm5hbWUsIHBhc3N3b3JkIH0sIHNlcnZpY2VVcmwsIHtcbiAgICAgICAgaXNTZWN1cmU6IGl0ZW0uaXNTZWN1cmVkLFxuICAgICAgICBpc1ZpZGVvU2VydmljZTogaXRlbS50eXBlID09PSBcIlZpZGVvIFNlcnZpY2VcIixcbiAgICAgICAgY2hlY2tBdXRoXG4gICAgICB9KTtcbiAgICAgIC8vIEltYWdlIHNlcnZpY2Ugd2l0aCBMRVJDIGZvcm1hdCB0aWxlcywgY3JlYXRlIG5ldyBlbGV2YXRpb24gc2VydmljZVxuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJJbWFnZSBTZXJ2aWNlXCIgJiYgc2VydmljZUluZm8udGlsZUluZm8pIHtcbiAgICAgICAgaWYgKHNlcnZpY2VJbmZvLnRpbGVJbmZvLmZvcm1hdCA9PT0gXCJMRVJDXCIgfHwgKChfYyA9IHNlcnZpY2VJbmZvLmNhY2hlVHlwZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvTG93ZXJDYXNlKCkpID09PSBcImVsZXZhdGlvblwiKSB7XG4gICAgICAgICAgaXRlbS5hZ3NUeXBlID0gXCJFbGV2YXRpb25TZXJ2ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9kID0gc2VydmljZUluZm8uY2FjaGVUeXBlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9Mb3dlckNhc2UoKSkgPT09IFwicmFzdGVyXCIpIHtcbiAgICAgICAgICBpdGVtLmFnc1R5cGUgPSBcIlRpbGVkSW1hZ2VTZXJ2ZXJcIjtcbiAgICAgICAgICBpZiAoaXNIeWJyaWRJbWFnZVNlcnZpY2UodXJsLCBzZXJ2aWNlSW5mbykgJiYgYWRkSXRlbVN0YXRlLmh5YnJpZEltYWdlU2VydmljZVNldHRpbmcgIT09IFwiVGlsZWRJbWFnZVNlcnZlclwiKSB7XG4gICAgICAgICAgICBpdGVtLmFnc1R5cGUgPSBcIkltYWdlU2VydmVyXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjcmVkZW50aWFsID0gc2VydmljZUluZm8uY3JlZGVudGlhbCB8fCBlc3JpSWQuZmluZENyZWRlbnRpYWwodXJsKTtcbiAgICAgIGNvbnN0IGRvY3VtZW50SW5mbyA9IHNlcnZpY2VJbmZvLmRvY3VtZW50SW5mbztcbiAgICAgIGNvbnN0IGtleXdvcmRzID0gKChkb2N1bWVudEluZm8gPT09IG51bGwgfHwgZG9jdW1lbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudEluZm8uS2V5d29yZHMpIHx8IFwiXCIpLnNwbGl0KFwiLFwiKTtcbiAgICAgIGNvbnN0IHNlcnZpY2VUaXRsZSA9IChfZSA9IGRvY3VtZW50SW5mbyA9PT0gbnVsbCB8fCBkb2N1bWVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50SW5mby5UaXRsZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogc2VydmljZUluZm8ubmFtZTtcbiAgICAgIGl0ZW0udGFncyA9IHVuaXF1ZShbLi4ua2V5d29yZHMsIC4uLml0ZW1UYWdzXSkuZmlsdGVyKCh0YWcpID0+IHRhZyk7XG4gICAgICAvLyBLZWVwIHBhcnNlZCB0aXRsZSBpZiBzZXJ2aWNlIGlzIG51bGxpc2ggb3IgYW4gZW1wdHkgc3RyaW5nXG4gICAgICBpZiAoKHNlcnZpY2VUaXRsZSA9PT0gbnVsbCB8fCBzZXJ2aWNlVGl0bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VUaXRsZS5sZW5ndGgpID4gMCkge1xuICAgICAgICBpdGVtLnRpdGxlID0gc2VydmljZVRpdGxlO1xuICAgICAgfVxuICAgICAgaXRlbS5kZXNjcmlwdGlvbiA9IChfZyA9IChfZiA9IGRvY3VtZW50SW5mbyA9PT0gbnVsbCB8fCBkb2N1bWVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50SW5mby5Db21tZW50cykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogc2VydmljZUluZm8uZGVzY3JpcHRpb24pICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFwiXCI7XG4gICAgICBpdGVtLnNuaXBwZXQgPSAoX2ogPSAoX2ggPSBkb2N1bWVudEluZm8gPT09IG51bGwgfHwgZG9jdW1lbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudEluZm8uU3ViamVjdCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogc2VydmljZUluZm8uc2VydmljZURlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBcIlwiO1xuICAgICAgaXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbSksIHsgdGh1bWJuYWlsVG9rZW46IChjcmVkZW50aWFsID09PSBudWxsIHx8IGNyZWRlbnRpYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWwudG9rZW4pIHx8IG51bGwsIGV4dGVudDogaXRlbS5leHRlbnQgfHwgc2VydmljZUluZm8uZnVsbEV4dGVudCB8fCBzZXJ2aWNlSW5mby5leHRlbnQsIHNlcnZpY2VJbmZvOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcnZpY2VJbmZvKSwgeyBpc1NlY3VyZTogY2hlY2tBdXRoID8gdHJ1ZSA6IGZhbHNlLCB1c2VySW5mbzogeyB1c2VybmFtZSwgcGFzc3dvcmQgfSB9KSB9KTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoKChfayA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2sudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImFib3J0ZWRcIikpIHx8IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgPT09IFwiRXJyb3I6IGpzb25cIikge1xuICAgICAgICAvLyB1c2VyIGNhbmNlbGxlZCB3aGVuIHByb21wdGVkIGZvciBsb2dpblxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgY29kZTogXCJmbG93QWJvcnRlZFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLm1lc3NhZ2UubWVzc2FnZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIFVuZm9ydHVuYXRlbHkgdGhlIGlkTWFuYWdlciB0aHJvd3MgYW4gZXJyb3IgQU5EIGNhbGxzIGJhY2sgb24gdGhlIHNldFByb3RvY29sRXJyb3JIYW5kbGVyIHdoZW5cbiAgICAgIC8vIGFuIGFnbyBzZXJ2aWNlIG5lZWRzIHRvIGJlIGFjY2Vzc2VkIG92ZXIgc3NsLCAgc28gc2V0IHRoaXMgZmxhZyB0byBkaXN0dW5ndWlzaCBhIHR5cGljYWwgZXJyb3JcbiAgICAgIC8vIHZzIHRoZSBzZXRQcm90b2NvbEVycm9yXG4gICAgICBpZiAoc2VjdXJlU2VydmljZS5pbmNsdWRlcygoX2wgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogKF9tID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5odHRwU3RhdHVzKSkge1xuICAgICAgICBpZiAoaXRlbS5hbGxvd1N0b3JlZEF1dGggIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXRlbS5hbGxvd1N0b3JlZEF1dGggPSAhaXRlbS5jaGVja1VybEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IGlzU2VjdXJlZDogeyBzZWN1cmVkOiB0cnVlIH0sIHNlcnZpY2VJbmZvOiB7IGlzU2VjdXJlOiB0cnVlIH0sIFxuICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgZGV0ZXJtaW5lIHRoYXQgd2UgY2FuJ3Qgc3RvcmUgYXV0aCB2aWEgYGNoZWNrVXJsYCwganVzdCBzZXQgaXQgdG8gZmFsc2VcbiAgICAgICAgICBhbGxvd1N0b3JlZEF1dGg6IGl0ZW0uYWxsb3dTdG9yZWRBdXRoID09PSBmYWxzZSA/IGZhbHNlIDogYWRkSXRlbVN0YXRlLmFsbG93U3RvcmVkQXV0aCB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgPT09IDQwMykge1xuICAgICAgICBpdGVtLnNlcnZpY2VJbmZvID0geyBpc1NlY3VyZTogdHJ1ZSB9O1xuICAgICAgICBpdGVtLmlzU2VjdXJlZCA9IHsgc2VjdXJlZDogdHJ1ZSB9O1xuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgY29kZTogXCJmb3JiaWRkZW5DcmVkZW50aWFsXCIsXG4gICAgICAgICAgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlcnJvciAmJiAoKF9vID0gaXRlbS5jaGVja1VybEVycm9yKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28ubWVzc2FnZSkpIHtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGVycm9yIGhlcmUgdXNpbmcgb3VyIHN0YW5kYXJkIGZvcm1cbiAgICAgICAgaWYgKChfciA9IChfcSA9IChfcCA9IGl0ZW0uY2hlY2tVcmxFcnJvcikgPT09IG51bGwgfHwgX3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wLm1lc3NhZ2UpID09PSBudWxsIHx8IF9xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcS5pbmNsdWRlcykgPT09IG51bGwgfHwgX3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yLmNhbGwoX3EsIFwid2FzIG5vdCBmb3VuZFwiKSkge1xuICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIGNvZGU6IFwic2VydmljZU5vdEV4aXN0XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShpdGVtLmNoZWNrVXJsRXJyb3IubWVzc2FnZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoaXRlbS5jaGVja1VybEVycm9yLm1lc3NhZ2UpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgoISFhZ3NUeXBlICYmIGFnc1R5cGUgIT09IFwiRmVhdHVyZVNlcnZlclwiKSB8fFxuICAgICAgICAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiICYmIGVycm9yLmluY2x1ZGVzKFwibm90IGZvdW5kXCIpKSkge1xuICAgICAgICB0aHJvdyB7IGNvZGU6IFwic2VydmljZU5vdEV4aXN0XCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCYWNrZW5kRXJyb3IoZXJyb3IpICYmXG4gICAgICAgIGVycm9yLmRldGFpbHNbMF0gPT09IFwiVGhlIGlucHV0IHNwYXRpYWwgcmVmZXJlbmNlIG11c3QgYmUgZWl0aGVyIGEgZ2VvZ3JhcGhpYyBvciBwcm9qZWN0ZWQgY29vcmRpbmF0ZSBzeXN0ZW1cIikge1xuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgY29kZTogXCJpbnZhbGlkU3BhdGlhbFJlZlwiLFxuICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmV0cnkgPCBNQVhfUkVUUlkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFHU1NlcnZpY2VJbmZvKGl0ZW0sIHVybCwgcmV0cnkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoKChfcyA9IGl0ZW0uaXNTZWN1cmVkKSA9PT0gbnVsbCB8fCBfcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3MuaXNGZWRlcmF0ZWRXaXRoV2ViVGllckF1dGgpIHx8ICgoX3QgPSBpdGVtLmlzU2VjdXJlZCkgPT09IG51bGwgfHwgX3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90Lmh0dHBTdGF0dXNDb2RlKSA9PT0gNDAxKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdGl0bGUgfSA9IGl0ZW07XG4gICAgICBjb25zdCBzZXJ2aWNlSW5mbyA9IGF3YWl0IHJlcXVlc3QoaXRlbS51cmwsIHt9LCB7IGFkZFRva2VuTWFudWFsbHk6IGZhbHNlIH0pO1xuICAgICAgY29uc3QgZG9jdW1lbnRJbmZvID0gc2VydmljZUluZm8uZG9jdW1lbnRJbmZvO1xuICAgICAgY29uc3Qga2V5d29yZHMgPSAoZG9jdW1lbnRJbmZvLktleXdvcmRzIHx8IFwiXCIpLnNwbGl0KFwiLFwiKTtcbiAgICAgIGNvbnN0IHRhZ3MgPSBbLi4udW5pcXVlKFsuLi5rZXl3b3JkcywgLi4uaXRlbVRhZ3NdKV07XG4gICAgICBpdGVtID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyBleHRlbnQ6IHNlcnZpY2VJbmZvLmZ1bGxFeHRlbnQgfHwgc2VydmljZUluZm8uZXh0ZW50LCBzZXJ2aWNlSW5mbyB9KTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IHRpdGxlLCB0YWdzIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICB0aHJvdyB7IGNvZGU6IFwidW5hdXRob3JpemVkXCIgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IHsgY29kZTogXCJzZXJ2aWNlTm90RXhpc3RcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH07XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBhZGRTZWN1cmVBR1NVcmwoaXRlbVByb3BlcnRpZXMpIHtcbiAgY29uc3QgeyBzZXJ2aWNlSW5mbywgdXNlcm5hbWUsIHBhc3N3b3JkLCBpc1NlY3VyZWQsIHN0b3JlQXV0aCwgdHlwZSB9ID0gaXRlbVByb3BlcnRpZXM7XG4gIGNvbnN0IHsgdXNlciwgcG9ydGFsLCBjb25maWcgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCBpdGVtVHlwZSA9IHR5cGU7XG4gIGNvbnN0IHVzZXJJbmZvID0geyB1c2VybmFtZSwgcGFzc3dvcmQgfTtcbiAgY29uc3QgeyB0aHVtYm5haWxVUkwgfSA9IGdldEl0ZW1JbmZvQnlUeXBlKGl0ZW1UeXBlKTtcbiAgY29uc3QgaXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbVByb3BlcnRpZXMpLCB7IHRodW1ibmFpbFVSTDogdGh1bWJuYWlsVVJMIHx8IGl0ZW1Qcm9wZXJ0aWVzLnRodW1ibmFpbFVSTCB9KTtcbiAgaWYgKCgoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmlzU2VjdXJlKSAmJiAhc2VydmljZUluZm8udXNlckluZm8pIHx8XG4gICAgKChpc1NlY3VyZWQgPT09IG51bGwgfHwgaXNTZWN1cmVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc1NlY3VyZWQuaXNPdmVycmlkZSkgJiYgIXVzZXJJbmZvKSB8fFxuICAgICgoaXNTZWN1cmVkID09PSBudWxsIHx8IGlzU2VjdXJlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNTZWN1cmVkLmh0dHBTdGF0dXNDb2RlKSAhPT0gNDAxICYmICF1c2VySW5mbykgfHxcbiAgICAoc3RvcmVBdXRoICYmICF1c2VySW5mbykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkQ3JlZGVudGlhbHNcIik7XG4gIH1cbiAgaWYgKGlzU2VjdXJlZCkge1xuICAgIGlmIChzdG9yZUF1dGgpIHtcbiAgICAgIGlmICghcG9ydGFsLmlzUG9ydGFsIHx8IChwb3J0YWwuaXNQb3J0YWwgJiYgY2hlY2tQcm90b2NvbCgpKSkge1xuICAgICAgICBpdGVtLnNlcnZpY2VVc2VybmFtZSA9IHVzZXJuYW1lO1xuICAgICAgICBpdGVtLnNlcnZpY2VQYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2VjdXJlZC5odHRwU3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFkZEl0ZW0oaXRlbSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnJlc3RCYXNlVXJsKS50aGVuKCh7IGlkIH0pID0+IHJlcXVlc3QoYCR7dXNlci51c2VyQ29udGVudFVybH0vaXRlbXMvJHtpZH1gLCB7fSwge30sIFwicG9zdFwiKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgeyBpZDogcmVzdWx0Lml0ZW0uaWQsIHVybDogcmVzdWx0Lml0ZW0udXJsLCBzb3VyY2VVcmw6IHJlc3VsdC5pdGVtLnNvdXJjZVVybCB9KTtcbiAgICAgICAgcmV0dXJuIGFkZEFHU1NlcnZpY2UodXBkYXRlZEl0ZW0sIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5pc1NlY3VyZSkgJiYgIShzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8udXNlckluZm8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWRDcmVkZW50aWFsc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZEFHU1NlcnZpY2UoaXRlbSk7XG59XG5hc3luYyBmdW5jdGlvbiBhZGRBR1NTZXJ2aWNlKGl0ZW1Qcm9wZXJ0aWVzLCB1cGRhdGUgPSBmYWxzZSkge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IHsgdXJsLCBzZXJ2aWNlSW5mbywgdHlwZSwgc3RvcmVBdXRoLCBoeWJyaWRJbWFnZVNlcnZpY2VTZXR0aW5nIH0gPSBpdGVtUHJvcGVydGllcztcbiAgbGV0IHNpbmdsZWxheWVyID0geyBTdHJlYW1TZXJ2ZXI6IDEsIEltYWdlU2VydmVyOiAxLCBXb3Jrc3BhY2VTZXJ2ZXI6IDEgfSwgc2VydmljZUxheWVycztcbiAgaWYgKCFzZXJ2aWNlSW5mbyAmJiAhc3RvcmVBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2VydmljZU5vdEV4aXN0XCIpO1xuICB9XG4gIGlmIChzdG9yZUF1dGggJiYgIXNlcnZpY2VJbmZvKSB7XG4gICAgLy8gRm9yIHByb3hpZWQgc2VjdXJlIEFHUyBzZXJ2aWNlcywgd2UnbGwgbmVlZCB0byBkZWxldGUgdGhlIGl0ZW0gYWZ0ZXIgY3JlYXRpbmcgaXQgdG86XG4gICAgLy8gMS4gcmVtb3ZlIHRoZSBpdGVtIHRvIG5vdCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyB3aXRoIHRpdGxlc1xuICAgIC8vIDIuIHdlIHdpbGwgbmVlZCB0byBnZXQgc2VydmljZSBpbmZvIGFnYWluIHRvIGdldCB0aGUgY29ycmVjdCB0aHVtYm5haWwgLyBzZXJ2aWNlIGluZm9cbiAgICAvLyAzLiBXZSBjcmVhdGUgdGhlIGl0ZW0gaGVyZSBzbyB3ZSBjYW4gZ2V0IGluaXRpYWwgc2VydmljZUluZm8gc28gdGhhdCB3ZSBjYW4gYXBwZW5kIHRoZSBjb3JyZWN0IGl0ZW1LZXl3b3Jkc1xuICAgIGNvbnN0IHsgcmVzcG9uc2UsIHVwZGF0ZWRQcm9wZXJ0aWVzIH0gPSBhd2FpdCByZXRyaWV2ZVByb3h5U2VydmljZUluZm8oaXRlbVByb3BlcnRpZXMpO1xuICAgIGF3YWl0IGRlbGV0ZUl0ZW0ocmVzcG9uc2UuaWQsIHsgcGVybWFuZW50RGVsZXRlOiB0cnVlIH0pO1xuICAgIC8vIFdlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcCMzNTYxNSAtIHdhaXQgZm9yIHRoZSBkZWxldGVkIGl0ZW0gdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBzZWFyY2ggaW5kZXhcbiAgICBhd2FpdCB0aW1lb3V0KDMwMDApO1xuICAgIHJldHVybiB1cGRhdGVkUHJvcGVydGllcztcbiAgfVxuICBjb25zdCB1cGRhdGVkSXRlbSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbVByb3BlcnRpZXMpLCB7IGRlc2NyaXB0aW9uOiAoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmRlc2NyaXB0aW9uKSB8fCAoKF9hID0gc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmRvY3VtZW50SW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLkNvbW1lbnRzKSB8fCBcIlwiLCBhY2Nlc3NJbmZvcm1hdGlvbjogKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5jb3B5cmlnaHRUZXh0KSB8fCAoKF9iID0gc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmRvY3VtZW50SW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLkNyZWRpdHMpIHx8IFwiXCIsIHNwYXRpYWxSZWZlcmVuY2U6IGdldFNwYXRpYWxSZWZlcmVuY2UoaXRlbVByb3BlcnRpZXMuc2VydmljZUluZm8sIGl0ZW1Qcm9wZXJ0aWVzLmFnc1R5cGUpIH0pO1xuICAvL0ZvciBpY29uIHB1cnBvc2VzIHdlIGNhbiB1cGRhdGUgdGhlXG4gIC8vdHlwZUtleXdvcmRzIHRvIHNob3cgZGlmZmVyZW50IGljb25zXG4gIGlmICgodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlLnRvTG93ZXJDYXNlKCkpID09PSBcIm1hcCBzZXJ2aWNlXCIpIHtcbiAgICB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMucHVzaCgoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLnNpbmdsZUZ1c2VkTWFwQ2FjaGUpID8gXCJUaWxlZFwiIDogXCJEeW5hbWljXCIpO1xuICB9XG4gIGlmICgodHlwZSA9PT0gXCJJbWFnZSBTZXJ2aWNlXCIgJiYgaHlicmlkSW1hZ2VTZXJ2aWNlU2V0dGluZyA9PT0gXCJUaWxlZEltYWdlU2VydmVyXCIpIHx8XG4gICAgaXNUaWxlc09ubHlJbWFnZVNlcnZpY2UodXJsLCBzZXJ2aWNlSW5mbykpIHtcbiAgICB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMgPSBhZGRDcmVhdGVJdGVtVHlwZXMuVGlsZWRJbWFnZVNlcnZlci50eXBlS2V5d29yZHM7XG4gIH1cbiAgaWYgKChzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8udHlwZSkgPT09IFwiVGFibGVcIikge1xuICAgIHVwZGF0ZWRJdGVtLnR5cGVLZXl3b3JkcyA9IFsuLi51cGRhdGVkSXRlbS50eXBlS2V5d29yZHMsIFwiVGFibGVcIiwgXCJTaW5nbGVsYXllclwiXTtcbiAgfVxuICBpZiAodHlwZSBpbiBzaW5nbGVsYXllcikge1xuICAgIHVwZGF0ZWRJdGVtLnR5cGVLZXl3b3Jkcy5wdXNoKFwiU2luZ2xlbGF5ZXJcIik7XG4gIH1cbiAgZWxzZSBpZiAoKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5sYXllcnMpIHx8IChzZXJ2aWNlSW5mbyA9PT0gbnVsbCB8fCBzZXJ2aWNlSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmljZUluZm8udGFibGVzKSkge1xuICAgIGlmICgoIXNlcnZpY2VJbmZvLmxheWVycyB8fCAhKChfYyA9IHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5sYXllcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpKSAmJiAoc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLnRhYmxlcy5sZW5ndGgpKSB7XG4gICAgICAvL0NoZWNrIGlmIFwiVGFibGVcIiB3YXMgYWRkZWQgYWJvdmUsIGRvbnQgd2FudCB0byBhZGQgaXQgdHdpY2VcbiAgICAgIGlmICh1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMuZmluZEluZGV4KCh0eXBlKSA9PiB0eXBlID09PSBcIlRhYmxlXCIpID09PSAtMSkge1xuICAgICAgICB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMucHVzaChcIlRhYmxlXCIpO1xuICAgICAgfVxuICAgICAgdXBkYXRlZEl0ZW0udHlwZUtleXdvcmRzLnB1c2goc2VydmljZUluZm8udGFibGVzLmxlbmd0aCA+IDEgPyBcIk11bHRpbGF5ZXJcIiA6IFwiU2luZ2xlbGF5ZXJcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2VydmljZUxheWVycyA9IFsuLi4oc2VydmljZUluZm8ubGF5ZXJzIHx8IFtdKSwgLi4uKHNlcnZpY2VJbmZvLnRhYmxlcyB8fCBbXSldO1xuICAgICAgdXBkYXRlZEl0ZW0udHlwZUtleXdvcmRzLnB1c2goc2VydmljZUxheWVycy5sZW5ndGggPiAxID8gXCJNdWx0aWxheWVyXCIgOiBcIlNpbmdsZWxheWVyXCIpO1xuICAgIH1cbiAgfVxuICAvL0ZvciBpY29uIHB1cnBvc2VzIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSB0eXBlS2V5d29yZHMgZm9yIGEgU2NlbmVTZXJ2ZXIgYWRkZWQgYnkgcmVmZXJlbmNlXG4gIGlmICgodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlLnRvTG93ZXJDYXNlKCkpID09PSBcInNjZW5lc2VydmVyXCIpIHtcbiAgICBjb25zdCB7IGxheWVycyB9ID0gc2VydmljZUluZm87XG4gICAgY29uc3QgbGF5ZXJUeXBlID0gKChfZCA9IGxheWVycyA9PT0gbnVsbCB8fCBsYXllcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyc1swXSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxheWVyVHlwZSkgfHwgKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5sYXllclR5cGUpO1xuICAgIGxheWVyVHlwZSAmJiB1cGRhdGVkSXRlbS50eXBlS2V5d29yZHMucHVzaChsYXllclR5cGUpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgeyBleHRlbnQ6IHdnc0V4dGVudCB9ID0gYXdhaXQgcHJvamVjdEV4dGVudFRvV0dTODRGcm9tSXRlbShPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkSXRlbSkpO1xuICAgIGNvbnN0IGl0ZW0gPSB1cGRhdGVkSXRlbTtcbiAgICBjb25zdCBpdGVtSW5mbyA9IGdldEl0ZW1JbmZvQnlUeXBlKGl0ZW0udHlwZSk7XG4gICAgaXRlbS50eXBlID0gaXRlbUluZm8udHlwZTtcbiAgICBpdGVtLnR5cGVLZXl3b3JkcyA9IFsuLi4oaXRlbS50eXBlS2V5d29yZHMgfHwgW10pLCAuLi4oaXRlbUluZm8udHlwZUtleXdvcmRzIHx8IFtdKV07XG4gICAgaWYgKCFzdG9yZUF1dGgpIHtcbiAgICAgIC8vIFRPRE86IHVuaWZ5IGV4dGVudCBmb3JtYXR0aW5nLCB0aHVtYm5haWwgZ2VuZXJhdGlvbiBiZXR3ZWVuIGhlcmUgYW5kIHVwZGF0ZVByb3h5U2VydmljZVxuICAgICAgY29uc3QgZXh0ZW50QXNTdHJpbmcgPSBleHRlbnRUb1N0cmluZyhpdGVtLmV4dGVudCk7XG4gICAgICBjb25zdCBlID0gZXh0ZW50QXNTdHJpbmcuc3BsaXQoXCIsXCIpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkRXh0ZW50ID0gW1xuICAgICAgICBbcGFyc2VGbG9hdChlWzBdKSwgcGFyc2VGbG9hdChlWzFdKV0sXG4gICAgICAgIFtwYXJzZUZsb2F0KGVbMl0pLCBwYXJzZUZsb2F0KGVbM10pXVxuICAgICAgXTtcbiAgICAgIGl0ZW0uZXh0ZW50ID0gZm9ybWF0dGVkRXh0ZW50O1xuICAgICAgY29uc3QgdGh1bWJuYWlsVVJMID0gYXdhaXQgZ2V0QUdTVGh1bWJuYWlsKGl0ZW0pO1xuICAgICAgaXRlbS50aHVtYm5haWxVUkwgPSB0aHVtYm5haWxVUkw7XG4gICAgICBpZiAoaXRlbS50aHVtYm5haWxVUkwgJiYgaXRlbS50aHVtYm5haWxUb2tlbikge1xuICAgICAgICBpdGVtLnRodW1ibmFpbFVSTCArPSBgJHtpdGVtLnRodW1ibmFpbFVSTC5pbmRleE9mKFwiP1wiKSA+IC0xID8gXCImXCIgOiBcIj9cIn0ke2l0ZW0udGh1bWJuYWlsVG9rZW59YDtcbiAgICAgIH1cbiAgICAgIGl0ZW0uZXh0ZW50ID0gZXh0ZW50VG9TdHJpbmcoaXRlbS50eXBlID09PSBcIkZlYXR1cmUgU2VydmljZVwiID8gd2dzRXh0ZW50IDogaXRlbS5leHRlbnQpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVBdXRoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlUHJveHlTZXJ2aWNlKGl0ZW0pO1xuICAgIH1cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlSXRlbShpdGVtLmlkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pLCB7IHVybDogaXRlbS5zb3VyY2VVcmwgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRVcmwoaXRlbSk7XG4gICAgfVxuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGlmIChzdG9yZUF1dGgpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gYWRkVXJsKGl0ZW1Qcm9wZXJ0aWVzKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJveHlTZXJ2aWNlKGl0ZW1Qcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHsgdXNlciB9ID0gY29uZmlnU3RhdGU7XG4gIGNvbnN0IHsgZXhwb3J0VGlsZXNBbGxvd2VkIH0gPSBhZGRJdGVtU3RhdGU7XG4gIGNvbnN0IGNyZWF0ZWRJdGVtID0gYXdhaXQgYWRkVXJsKGl0ZW1Qcm9wZXJ0aWVzKTtcbiAgY29uc3QgcmVxdWVzdFVybCA9IGAke3VzZXIudXNlckNvbnRlbnRVcmx9L2l0ZW1zLyR7Y3JlYXRlZEl0ZW0uaWR9YDtcbiAgY29uc3QgeyBpdGVtIH0gPSBhd2FpdCByZXF1ZXN0KHJlcXVlc3RVcmwsIHt9LCB7fSwgXCJwb3N0XCIpO1xuICBjb25zdCBzZXJ2aWNlSW5mb1VybCA9IGV4cG9ydFRpbGVzQWxsb3dlZCA/IGl0ZW1Qcm9wZXJ0aWVzLnVybCA6IGl0ZW0udXJsO1xuICBjb25zdCB1cGRhdGVkSXRlbSA9IGF3YWl0IGdldEFHU1NlcnZpY2VJbmZvKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaXRlbVByb3BlcnRpZXMpLCB7IHR5cGU6IGFkZEl0ZW1TdGF0ZS50eXBlIH0pLCBzZXJ2aWNlSW5mb1VybCk7XG4gIGNvbnN0IHsgdHlwZUtleXdvcmRzLCB0aHVtYm5haWxUb2tlbiwgc3BhdGlhbFJlZmVyZW5jZSwgZXh0ZW50LCBkZXNjcmlwdGlvbiB9ID0gdXBkYXRlZEl0ZW07XG4gIGl0ZW1Qcm9wZXJ0aWVzLmlkID0gY3JlYXRlZEl0ZW0uaWQ7XG4gIGl0ZW1Qcm9wZXJ0aWVzLnByb3h5VXJsID0gaXRlbS51cmw7XG4gIGl0ZW1Qcm9wZXJ0aWVzLnR5cGVLZXl3b3JkcyA9IHR5cGVLZXl3b3JkcztcbiAgaXRlbVByb3BlcnRpZXMudGh1bWJuYWlsVG9rZW4gPSB0aHVtYm5haWxUb2tlbjtcbiAgaXRlbVByb3BlcnRpZXMuc3BhdGlhbFJlZmVyZW5jZSA9IHNwYXRpYWxSZWZlcmVuY2U7XG4gIGl0ZW1Qcm9wZXJ0aWVzLmV4dGVudCA9IGV4dGVudDtcbiAgaXRlbVByb3BlcnRpZXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgLy8gSU5DMTA1NTM5NyAtIE9uIGl0cyBvd24sIGEgZmFpbGVkIHRodW1ibmFpbCBzaG91bGRuJ3QgZGVyYWlsIHRoZSB3aG9sZSB1cGxvYWQgcHJvY2VzcyAoPylcbiAgLy8gVE9ETzogSWYgbmVlZGVkLCB0aHJvdyBhIG1vcmUgc3BlY2lmaWMgZXJyb3IgaW4gdGhlIGNhdGNoIGJsb2NrXG4gIHRyeSB7XG4gICAgY29uc3QgZXh0ZW50QXNTdHJpbmcgPSBleHRlbnRUb1N0cmluZyh1cGRhdGVkSXRlbS5leHRlbnQpO1xuICAgIGNvbnN0IGUgPSBleHRlbnRBc1N0cmluZy5zcGxpdChcIixcIik7XG4gICAgY29uc3QgZm9ybWF0dGVkRXh0ZW50ID0gW1xuICAgICAgW3BhcnNlRmxvYXQoZVswXSksIHBhcnNlRmxvYXQoZVsxXSldLFxuICAgICAgW3BhcnNlRmxvYXQoZVsyXSksIHBhcnNlRmxvYXQoZVszXSldXG4gICAgXTtcbiAgICBpdGVtUHJvcGVydGllcy5leHRlbnQgPSBmb3JtYXR0ZWRFeHRlbnQ7XG4gICAgY29uc3QgdGh1bWJuYWlsVVJMID0gYXdhaXQgZ2V0QUdTVGh1bWJuYWlsKGl0ZW1Qcm9wZXJ0aWVzKTtcbiAgICBpdGVtLnRodW1ibmFpbFVSTCA9IHRodW1ibmFpbFVSTDtcbiAgICBpZiAoaXRlbS50aHVtYm5haWxVUkwgJiYgaXRlbS50aHVtYm5haWxUb2tlbikge1xuICAgICAgaXRlbS50aHVtYm5haWxVUkwgKz0gYCR7aXRlbS50aHVtYm5haWxVUkwuaW5kZXhPZihcIj9cIikgPiAtMSA/IFwiJlwiIDogXCI/XCJ9JHtpdGVtLnRodW1ibmFpbFRva2VufWA7XG4gICAgfVxuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG4gIGF3YWl0IHVwZGF0ZUl0ZW0oY3JlYXRlZEl0ZW0uaWQsIHsgdGh1bWJuYWlsVVJMOiBpdGVtLnRodW1ibmFpbFVSTCB9KTtcbiAgcmV0dXJuIGNyZWF0ZWRJdGVtO1xufVxuYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVQcm94eVNlcnZpY2VJbmZvKGl0ZW1Qcm9wZXJ0aWVzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICBjb25zdCB7IHVzZXIgfSA9IGNvbmZpZ1N0YXRlO1xuICBjb25zdCB7IHR5cGUsIGV4cG9ydFRpbGVzQWxsb3dlZCB9ID0gaXRlbVByb3BlcnRpZXM7XG4gIGNvbnN0IGFkZGVkSXRlbSA9IGF3YWl0IGFkZFVybChpdGVtUHJvcGVydGllcyk7XG4gIGNvbnN0IHsgaWQgfSA9IGFkZGVkSXRlbTtcbiAgY29uc3QgdXJsID0gYCR7dXNlci51c2VyQ29udGVudFVybH0vaXRlbXMvJHtpZH1gO1xuICBjb25zdCB7IGl0ZW0gfSA9IGF3YWl0IHJlcXVlc3QodXJsLCB7fSwge30sIFwicG9zdFwiKTtcbiAgLy8gRm9yIHZlY3RvclRpbGUgc2VydmljZXMgd2hlcmUgdGhlIHJvb3QgdXJsIGlzIG5vdCBzZWN1cmVkLCBidXQgZXhwb3J0VGlsZXNBbGxvd2VkID0gdHJ1ZSwgbWF5IGhhdmUgdGhlIFwiZXhwb3JUaWxlc1wiIGVuZHBvaW50IHNlY3VyZWQuIFNvIHdoZW4gcmVxdWVzdGluZyBzZXJ2aWNlIGluZm8gd2Ugc2hvdWxkIHVzZSB0aGUgZW50ZXJlZCB1cmwsIG5vdCB0aGUgdXJsIGdlbmVyYXRlZCBmcm9tIHRoZSBwcm94aWVkIGl0ZW0gZ2VuZXJhdGlvblxuICBjb25zdCBzZXJ2aWNlSW5mb1VybCA9IGV4cG9ydFRpbGVzQWxsb3dlZCA/IGl0ZW1Qcm9wZXJ0aWVzLnVybCA6IGl0ZW0udXJsO1xuICBjb25zdCB1cGRhdGVkSXRlbSA9IChhd2FpdCBnZXRBR1NTZXJ2aWNlSW5mbyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGl0ZW1Qcm9wZXJ0aWVzKSwgeyB0eXBlIH0pLCBzZXJ2aWNlSW5mb1VybCkpIHx8IHt9O1xuICBjb25zdCBkb2N1bWVudEluZm8gPSAoX2IgPSAoX2EgPSB1cGRhdGVkSXRlbS5zZXJ2aWNlSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvY3VtZW50SW5mbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gIGNvbnN0IHsgdGFncywgc2VydmljZVVzZXJuYW1lLCBzZXJ2aWNlUGFzc3dvcmQsIHNlcnZpY2VJbmZvLCBzcGF0aWFsUmVmZXJlbmNlLCBleHRlbnQsIHRodW1ibmFpbFRva2VuIH0gPSB1cGRhdGVkSXRlbTtcbiAgbGV0IHN0b3JlVXBkYXRlcyA9IHt9O1xuICBzdG9yZVVwZGF0ZXMudGl0bGUgPSAoX2MgPSBkb2N1bWVudEluZm8gPT09IG51bGwgfHwgZG9jdW1lbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudEluZm8uVGl0bGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gIHN0b3JlVXBkYXRlcy5kZXNjcmlwdGlvbiA9IChfZCA9IGRvY3VtZW50SW5mbyA9PT0gbnVsbCB8fCBkb2N1bWVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50SW5mby5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogXCJcIjtcbiAgc3RvcmVVcGRhdGVzLnNuaXBwZXQgPSAoX2YgPSAoX2UgPSBkb2N1bWVudEluZm8gPT09IG51bGwgfHwgZG9jdW1lbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudEluZm8uU3ViamVjdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZG9jdW1lbnRJbmZvID09PSBudWxsIHx8IGRvY3VtZW50SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnRJbmZvLnNlcnZpY2VEZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogXCJcIjtcbiAgc3RvcmVVcGRhdGVzLnRhZ3MgPSB0YWdzO1xuICBzdG9yZVVwZGF0ZXMucHJveHlVcmwgPSBpdGVtLnVybDtcbiAgc3RvcmVVcGRhdGVzLnNlcnZpY2VVc2VybmFtZSA9IHNlcnZpY2VVc2VybmFtZTtcbiAgc3RvcmVVcGRhdGVzLnNlcnZpY2VQYXNzd29yZCA9IHNlcnZpY2VQYXNzd29yZDtcbiAgc3RvcmVVcGRhdGVzLnNlcnZpY2VJbmZvID0gc2VydmljZUluZm87XG4gIHN0b3JlVXBkYXRlcy5zcGF0aWFsUmVmZXJlbmNlID0gc3BhdGlhbFJlZmVyZW5jZTtcbiAgc3RvcmVVcGRhdGVzLmV4dGVudCA9IGV4dGVudDtcbiAgc3RvcmVVcGRhdGVzLnRodW1ibmFpbFRva2VuID0gdGh1bWJuYWlsVG9rZW47XG4gIHJldHVybiB7IHJlc3BvbnNlOiBhZGRlZEl0ZW0sIHVwZGF0ZWRQcm9wZXJ0aWVzOiBzdG9yZVVwZGF0ZXMgfTtcbn1cblxuY29uc3Qgb3ZlcnJpZGVVcmxzID0gW1xuICBcImdlb2NvZGUuYXJjZ2lzLmNvbVwiLFxuICBcImdlb2NvZGVkZXYuYXJjZ2lzLmNvbVwiLFxuICBcImdlb2NvZGVxYS5hcmNnaXMuY29tXCIsXG4gIFwicm91dGUuYXJjZ2lzLmNvbVwiLFxuICBcInJvdXRlZGV2LmFyY2dpcy5jb21cIixcbiAgXCJyb3V0ZXFhLmFyY2dpcy5jb21cIixcbiAgXCJnZW9lbnJpY2guYXJjZ2lzLmNvbVwiLFxuICBcImdlb2VucmljaHFhLmFyY2dpcy5jb21cIixcbiAgXCJnZW9lbnJpY2hkZGV2LmFyY2dpcy5jb21cIlxuXTtcbmFzeW5jIGZ1bmN0aW9uIGdldElzU2VjdXJlZCh1c2VySW5mbywgc2VydmljZVVybCwgcmVzdEJhc2VVcmwsIGNoZWNrQXV0aCkge1xuICAvLyB0aGUgL2NoZWNrVVJMIGNhbGwgd2lsbCByZXNwb25kIHdoZXRoZXIgYSBzZXJ2aWNlIG5lZWRzIGF1dGhlbnRpY2F0aW9uIG9yIG5vdC5cbiAgY29uc3QgdXJsID0gc2VydmljZVVybC5zcGxpdChcIj9cIilbMF07XG4gIGNvbnN0IHNlY3VyZWRVUkwgPSBgJHtyZXN0QmFzZVVybH1wb3J0YWxzL2NoZWNrdXJsYDtcbiAgY29uc3QgaXNPdmVycmlkZVVybCA9IG92ZXJyaWRlVXJscy5zb21lKCh1cmwpID0+IHNlcnZpY2VVcmwuaW5kZXhPZih1cmwpICE9PSAtMSk7XG4gIGlmIChpc092ZXJyaWRlVXJsKSB7XG4gICAgcmV0dXJuIHsgc2VjdXJlZDogdHJ1ZSwgaXNPdmVycmlkZTogdHJ1ZSB9O1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IGlzVmVjdG9yVGlsZVNlcnZpY2UgPSAhaXNPdmVycmlkZVVybCAmJiBzZXJ2aWNlVXJsLmluZGV4T2YoXCIvVmVjdG9yVGlsZVNlcnZlclwiKSA+IC0xO1xuICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBgJHtzZWN1cmVkVVJMfT91cmw9JHtlbmNvZGVVUklDb21wb25lbnQoYCR7YWRkUGFyYW1ldGVycyhgJHt1cmx9P2Y9anNvbmApfWApfWA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QocmVxdWVzdFVybCwge30sIHsgYWRkVG9rZW5NYW51YWxseTogZmFsc2UgfSk7XG4gICAgICBjb25zdCB7IGh0dHBTdGF0dXNDb2RlIH0gPSByZXN1bHQ7XG4gICAgICBpZiAocmVzdWx0LnNlY3VyZWQpIHtcbiAgICAgICAgaWYgKGh0dHBTdGF0dXNDb2RlID09PSA0MDMpIHtcbiAgICAgICAgICAvL1NlZSBodHRwczovL2RldnRvcGlhL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvNTEgNDAzIGNvbnNpZGVyZWQgbm90LXNlY3VyZVxuICAgICAgICAgIHJlc3VsdC5zZWN1cmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHR0cFN0YXR1c0NvZGUgPT09IDQwMSkge1xuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8zNTk4MSB3ZWIgdGllciBhdXRoIGRvZXNuJ3QgYWxsb3cgc3RvcmluZyBjcmVkZW50aWFsc1xuICAgICAgICAgIHJlc3VsdC5hbGxvd1N0b3JlZEF1dGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNWZWN0b3JUaWxlU2VydmljZSkge1xuICAgICAgICAvLyBGb3IgdmVjdG9yVGlsZSBzZXJ2aWNlcyB3aGVyZSB0aGUgcm9vdCB1cmwgaXMgbm90IHNlY3VyZWQsIGJ1dCBleHBvcnRUaWxlc0FsbG93ZWQgPSB0cnVlLCBtYXkgaGF2ZSB0aGUgXCJleHBvclRpbGVzXCIgZW5kcG9pbnQgc2VjdXJlZCxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayB0aGF0IGhlcmUsIGlmIGl0IGlzIHNlY3VyZWQgdGhlbiB3ZSBuZWVkIHRvIHByb21wdCBmb3IgY3JlZGVudGlhbHMgaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvaXNzdWVzLzE5NTEwXG4gICAgICAgIGNvbnN0IHNlcnZpY2VJbmZvID0gYXdhaXQgZ2V0U2VydmljZUluZm8oeyB1c2VybmFtZTogdXNlckluZm8udXNlcm5hbWUsIHBhc3N3b3JkOiB1c2VySW5mby5wYXNzd29yZCB9LCBzZXJ2aWNlVXJsLCB7IGlzVmlkZW9TZXJ2aWNlOiBmYWxzZSwgY2hlY2tBdXRoIH0pO1xuICAgICAgICBhZGRJdGVtU3RhdGUuZXhwb3J0VGlsZXNBbGxvd2VkID0gc2VydmljZUluZm8gPT09IG51bGwgfHwgc2VydmljZUluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VJbmZvLmV4cG9ydFRpbGVzQWxsb3dlZDtcbiAgICAgICAgaWYgKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5leHBvcnRUaWxlc0FsbG93ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0SXNTZWN1cmVkKHVzZXJJbmZvLCBgJHtzZXJ2aWNlVXJsfS9leHBvcnRUaWxlc2AsIHJlc3RCYXNlVXJsLCBjaGVja0F1dGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB7IGlzT3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgbWVzc2FnZSwgY29kZSB9ID0gZXJyb3I7XG4gICAgICBpZiAobWVzc2FnZSA9PT0gXCJFcnJvciBjaGVja2luZyByZXNvdXJjZVwiKSB7XG4gICAgICAgIC8vIEludGVybmFsIHNlcnZpY2UgVVJMIGRldGVjdGVkXG4gICAgICAgIC8vIGNoZWNrVXJsIHNob3VsZG4ndCBiZSBoYW5kbGluZyB0aGlzIC0tLSBDaGVjayB3aXRoIENocmlzIFdoaXRtb3JlIGZvciBkZXRhaWxcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZWN1cmVkOiBmYWxzZSxcbiAgICAgICAgICB1cmw6IHNlcnZpY2VVcmwsXG4gICAgICAgICAgaHR0cFJlc3BvbnNlOiBcIlwiLFxuICAgICAgICAgIGh0dHBTdGF0dXNDb2RlOiBjb2RlLFxuICAgICAgICAgIGh0dHBTdGF0dXNNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIGlzT3ZlcnJpZGU6IGZhbHNlLFxuICAgICAgICAgIGFsbG93U3RvcmVkQXV0aDogZmFsc2UgLy8gVGhpcyBpcyB0aGUga2V5IHBvaW50LCB3ZSBqdXN0IHdhbnQgdG8gaGlkZSB0aGUgdG9nZ2xlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd1N0b3JlZEF1dGg6IGZhbHNlLFxuICAgICAgICB1cmw6IHNlcnZpY2VVcmwsXG4gICAgICAgIGh0dHBSZXNwb25zZTogXCJcIixcbiAgICAgICAgaHR0cFN0YXR1c0NvZGU6IGNvZGUsXG4gICAgICAgIGh0dHBTdGF0dXNNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBpc092ZXJyaWRlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRXNyaUhvc3RlZFNlcnZpY2UodXJsKSB7XG4gIC8vIGVzcmkgaG9zdGVkIHNlcnZpY2U6IGh0dHBzOi8vZGV2MDAxMTIxMS5lc3JpLmNvbS9zZXJ2ZXIvcmVzdC9zZXJ2aWNlcy9Ib3N0ZWQvQ2FsaWZvcm5pYS9GZWF0dXJlU2VydmVyXG4gIHJldHVybiB1cmwuaW5kZXhPZihcIi5lc3JpLmNvbS9zZXJ2ZXIvcmVzdC9zZXJ2aWNlc1wiKSA+IC0xID8gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNIeWJyaWRJbWFnZVNlcnZpY2UodXJsLCBzZXJ2aWNlSW5mbykge1xuICB2YXIgX2E7XG4gIHJldHVybiAodXJsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIi9pbWFnZXNlcnZlclwiKSA+IC0xICYmXG4gICAgKHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5jYWNoZVR5cGUpID09PSBcIlJhc3RlclwiICYmXG4gICAgKChfYSA9IHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ0aWxlc29ubHlcIikpID09PSAtMSk7XG59XG5mdW5jdGlvbiBpc1RpbGVzT25seUltYWdlU2VydmljZSh1cmwsIHNlcnZpY2VJbmZvKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiAoKF9hID0gdXJsLnRvTG93ZXJDYXNlKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcIi9pbWFnZXNlcnZlclwiKSkgJiYgKChfYiA9IHNlcnZpY2VJbmZvID09PSBudWxsIHx8IHNlcnZpY2VJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidGlsZXNvbmx5XCIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFNlcnZpY2VJbmZvKHVzZXJJbmZvLCBzdmNVcmwsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29uZmlnID0gY29uZmlnU3RhdGUuY29uZmlnO1xuICBjb25zdCBbZXNyaUlkXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICBjb25maWdTdGF0ZS5hcGkgPT09IDMgPyBcImVzcmkvSWRlbnRpdHlNYW5hZ2VyXCIgOiBcImVzcmkvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyXCJcbiAgXSk7XG4gIGNvbnN0IHsgZm9yY2VBZGRUb2tlbiwgaXNTZWN1cmUsIGNoZWNrQXV0aCB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyB1c2VybmFtZSwgcGFzc3dvcmQgfSA9IHVzZXJJbmZvO1xuICBjb25zdCBtZXRob2QgPSBcImF1dG9cIjtcbiAgY29uc3QgaXNIb3N0ZWQgPSBpc0hvc3RlZFNlcnZpY2Uoc3ZjVXJsKTtcbiAgY29uc3QgaXNFU1JJID0gaXNFc3JpSG9zdGVkU2VydmljZShzdmNVcmwpO1xuICBjb25zdCBob3N0ZWRTZXJ2aWNlID0gaXNIb3N0ZWQgfHwgaXNFU1JJO1xuICBjb25zdCBpc092ZXJyaWRlVXJsID0gb3ZlcnJpZGVVcmxzLnNvbWUoKHVybCkgPT4gc3ZjVXJsLmluZGV4T2YodXJsKSAhPT0gLTEpO1xuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICB1c2VQcm94eTogZmFsc2UsXG4gICAgdGltZW91dDogY29uZmlnLmlzTXVsdGlUZW5hbnQgPT09IGZhbHNlID8gNjAwMDAgOiA1MDAwLFxuICAgIGFkZFNTTDogaG9zdGVkU2VydmljZSxcbiAgICBhZGRUb2tlbk1hbnVhbGx5OiAoaXNTZWN1cmUgJiYgaG9zdGVkU2VydmljZSAmJiAhIWNvbmZpZy5pc011bHRpVGVuYW50KSB8fCBmb3JjZUFkZFRva2VuIHx8IGZhbHNlLFxuICAgIGRpc2FibGVJZGVudGl0eUxvb2t1cDogbnVsbFxuICB9O1xuICBpZiAoY2hlY2tBdXRoKSB7XG4gICAgc3ZjVXJsID0gc3ZjVXJsLnNwbGl0KFwiP1wiKVswXTtcbiAgICBpZiAoaXNPdmVycmlkZVVybCkge1xuICAgICAgYXdhaXQgc2lnbkluKHN2Y1VybCwgeyB1c2VybmFtZSwgcGFzc3dvcmQgfSk7XG4gICAgICByZXR1cm4gc2VydmljZUluZm9SZXF1ZXN0KHN2Y1VybCwgcmVxdWVzdE9wdGlvbnMsIG1ldGhvZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gVmlkZW8gU2VydmljZSBVUkwgZG9lc24ndCBhY2NlcHQgUE9TVCBtZXRob2RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2VJbmZvUmVxdWVzdChzdmNVcmwsIHJlcXVlc3RPcHRpb25zLCBtZXRob2QpO1xuICAgICAgcmVzdWx0LmNyZWRlbnRpYWwgPSBlc3JpSWQuZmluZENyZWRlbnRpYWwoc3ZjVXJsKTtcbiAgICAgIGlmIChyZXN1bHQuY3JlZGVudGlhbCkge1xuICAgICAgICBlc3JpSWQucmVnaXN0ZXJUb2tlbih7XG4gICAgICAgICAgc2VydmVyOiBzdmNVcmwsXG4gICAgICAgICAgdG9rZW46IHJlc3VsdC5jcmVkZW50aWFsLnRva2VuLFxuICAgICAgICAgIHVzZXJJZDogcmVzdWx0LmNyZWRlbnRpYWwudXNlcklkLFxuICAgICAgICAgIGV4cGlyZXM6IHJlc3VsdC5jcmVkZW50aWFsLmV4cGlyZXMsXG4gICAgICAgICAgc3NsOiByZXN1bHQuY3JlZGVudGlhbC5zc2xcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBgZGlzYWJsZUlkZW50aXR5TG9va3VwYCB3aWxsIG92ZXJyaWRlIHRoZSBJZCBtYW5hZ2VyIGluIEVTUklSZXF1ZXN0IHNvIHRoYXQgaXQgZG9lc250IHJlbmRlciB0aGUgYXV0aCB3aW5kb3cgLSB3aGljaCBoYXMgYmVlbiBhIHBhaW4gcG9pbnQgZm9yIGNlcnRhaW4gdXJscyAtIGlmIHlvdSBoYXZlIGFuIGlzc3VlIHdpdGggYXV0aGVudGljYXRpb24gYW5kIHRoZSBJRCBtYW5hZ2VyIGNoZWNrIGhlcmUgZmlyc3QuXG4gICAgcmVxdWVzdE9wdGlvbnMuZGlzYWJsZUlkZW50aXR5TG9va3VwID0gdHJ1ZTtcbiAgICByZXR1cm4gYXdhaXQgc2VydmljZUluZm9SZXF1ZXN0KHN2Y1VybCwgcmVxdWVzdE9wdGlvbnMsIG1ldGhvZCk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbihzdmNVcmwsIHVzZXJJbmZvKSB7XG4gIGNvbnN0IFtlc3JpSWQsIENyZWRlbnRpYWxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1xuICAgIGNvbmZpZ1N0YXRlLmFwaSA9PT0gMyA/IFwiZXNyaS9JZGVudGl0eU1hbmFnZXJcIiA6IFwiZXNyaS9pZGVudGl0eS9JZGVudGl0eU1hbmFnZXJcIixcbiAgICBcImVzcmkvQ3JlZGVudGlhbFwiXG4gIF0pO1xuICBpZiAodXNlckluZm8udXNlcm5hbWUgJiYgdXNlckluZm8ucGFzc3dvcmQpIHtcbiAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgZmluZFNlcnZlckluZm8oc3ZjVXJsKTtcbiAgICBpZiAoZXNyaUlkLl9jaGVja1Byb3RvY29sKHN2Y1VybCwgc2VydmVySW5mbywgKGVycm9yKSA9PiBjb25zb2xlLmVycm9yKGVycm9yKSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZXNyaUlkLmdlbmVyYXRlVG9rZW4oc2VydmVySW5mbywgdXNlckluZm8pO1xuICAgICAgICBjb25zdCBleHBpcmVzID0gcmVzcG9uc2UuZXhwaXJlcyA/IE51bWJlcihyZXNwb25zZS5leHBpcmVzKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHNzbCA9ICEhcmVzcG9uc2Uuc3NsO1xuICAgICAgICBjb25zdCBjcmVkID0gbmV3IENyZWRlbnRpYWwoe1xuICAgICAgICAgIHVzZXJJZDogdXNlckluZm8udXNlcm5hbWUsXG4gICAgICAgICAgc2VydmVyOiBzZXJ2ZXJJbmZvLnNlcnZlcixcbiAgICAgICAgICB0b2tlbjogcmVzcG9uc2UudG9rZW4sXG4gICAgICAgICAgZXhwaXJlcyxcbiAgICAgICAgICBzc2wsXG4gICAgICAgICAgdmFsaWRpdHk6IHNlcnZlckluZm8uc2hvcnRMaXZlZFRva2VuVmFsaWRpdHksXG4gICAgICAgICAgcmVzb3VyY2VzOiBbc3ZjVXJsXSxcbiAgICAgICAgICBzY29wZTogXCJzZXJ2ZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVzcmlJZC5jcmVkZW50aWFscy5pbmRleE9mKGNyZWQpID09PSAtMSkge1xuICAgICAgICAgIGVzcmlJZC5jcmVkZW50aWFscy5wdXNoKGNyZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VySW5mbztcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvci5jb2RlID0gNDAzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmRTZXJ2ZXJJbmZvKHNlcnZpY2VVcmwpIHtcbiAgY29uc3QgW2VzcmlJZCwgU2VydmVySW5mb10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgY29uZmlnU3RhdGUuYXBpID09PSAzID8gXCJlc3JpL0lkZW50aXR5TWFuYWdlclwiIDogXCJlc3JpL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlclwiLFxuICAgIFwiZXNyaS9TZXJ2ZXJJbmZvXCJcbiAgXSk7XG4gIGxldCBzZXJ2ZXJJbmZvID0gYXdhaXQgZXNyaUlkLmZpbmRTZXJ2ZXJJbmZvKHNlcnZpY2VVcmwpO1xuICBpZiAoIXNlcnZlckluZm8pIHtcbiAgICBzZXJ2ZXJJbmZvID0gbmV3IFNlcnZlckluZm8oKTtcbiAgICBzZXJ2ZXJJbmZvLnNlcnZlciA9IGF3YWl0IGVzcmlJZC5fZ2V0T3JpZ2luKHNlcnZpY2VVcmwpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZXNyaUlkLl9nZXRUb2tlblN2Y1VybChzZXJ2aWNlVXJsKTtcbiAgICBjb25zdCB7IGF1dGhJbmZvLCB0b2tlblNlcnZpY2VVcmwsIGN1cnJlbnRWZXJzaW9uIH0gPSByZXNwb25zZTtcbiAgICBzZXJ2ZXJJbmZvLnRva2VuU2VydmljZVVybCA9IChhdXRoSW5mbyA9PT0gbnVsbCB8fCBhdXRoSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aEluZm8udG9rZW5TZXJ2aWNlc1VybCkgfHwgKGF1dGhJbmZvID09PSBudWxsIHx8IGF1dGhJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoSW5mby50b2tlblNlcnZpY2VVcmwpIHx8IHRva2VuU2VydmljZVVybDtcbiAgICBzZXJ2ZXJJbmZvLmN1cnJlbnRWZXJzaW9uID0gY3VycmVudFZlcnNpb247XG4gICAgc2VydmVySW5mby5oYXNTZXJ2ZXIgPSB0cnVlO1xuICAgIGVzcmlJZC5yZWdpc3RlclNlcnZlcnMoW3NlcnZlckluZm9dKTtcbiAgICByZXR1cm4gc2VydmVySW5mbztcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gc2VydmVySW5mbztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2VydmljZUluZm9SZXF1ZXN0KHNlcnZpY2VVcmwsIG9wdGlvbnMsIG1ldGhvZCA9IFwicG9zdFwiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QoYWRkUGFyYW1ldGVycyhzZXJ2aWNlVXJsKSwge30sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCBtZXRob2QpO1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRVcmxTZXJ2aWNlSW5mbyhpdGVtKSB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCB1cmxTZXJ2aWNlSW5mbyA9IHt9O1xuICBpZiAoaXNBR1MoaXRlbS50eXBlKSkge1xuICAgIHVybFNlcnZpY2VJbmZvID0gYXdhaXQgZ2V0U2VjdXJlZEFHU1NlcnZpY2VJbmZvKGl0ZW0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICBjYXNlIFwiT0dDRmVhdHVyZVNlcnZlclwiOlxuICAgICAgICB1cmxTZXJ2aWNlSW5mbyA9IGF3YWl0IGdldE9HQ0ZlYXR1cmVMYXllclNlcnZpY2VJbmZvKGl0ZW0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJXTVNcIjpcbiAgICAgICAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBnZXRXTVNTZXJ2aWNlSW5mbyhpdGVtKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgdXJsU2VydmljZUluZm8uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCB3bXNMYXllcnMgPSBhd2FpdCBsb2FkV01TTGF5ZXJzKHJlc3VsdC5zZXJ2aWNlSW5mbyk7XG4gICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB3bXNMYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIldGU1wiOlxuICAgICAgICB1cmxTZXJ2aWNlSW5mbyA9IGF3YWl0IGdldFdGU1NlcnZpY2VJbmZvKGl0ZW0pO1xuICAgICAgICBpZiAodXJsU2VydmljZUluZm8ucmVzdWx0KSB7XG4gICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0LmxheWVycyA9IHVybFNlcnZpY2VJbmZvLnJlc3VsdC5zZXJ2aWNlSW5mby5sYXllcnM7XG4gICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0LnRpdGxlID0gKF9hID0gdXJsU2VydmljZUluZm8ucmVzdWx0LnNlcnZpY2VJbmZvLnRpdGxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICAgIHVybFNlcnZpY2VJbmZvLnJlc3VsdC5pc0NvbXBsZXggPSB1cmxTZXJ2aWNlSW5mby5yZXN1bHQuc2VydmljZUluZm8uaXNDb21wbGV4ID09PSBcImVzcmlHZW9tZXRyeUNvbXBsZXhcIjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJXTVRTXCI6XG4gICAgICAgIHVybFNlcnZpY2VJbmZvID0gYXdhaXQgZ2V0V01UU1NlcnZpY2VJbmZvKGl0ZW0pO1xuICAgICAgICBpZiAodXJsU2VydmljZUluZm8ucmVzdWx0KSB7XG4gICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0LmxheWVycyA9IHVybFNlcnZpY2VJbmZvLnJlc3VsdC5zZXJ2aWNlSW5mby5sYXllcnM7XG4gICAgICAgICAgdXJsU2VydmljZUluZm8ucmVzdWx0LnRpdGxlID0gKF9iID0gdXJsU2VydmljZUluZm8ucmVzdWx0LnNlcnZpY2VJbmZvLnRpdGxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdXJsU2VydmljZUluZm8gPSB7IHJlc3VsdDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSkgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmxTZXJ2aWNlSW5mbztcbn1cbi8vIFdlIG5lZWQgdG8gc2VuZCBsYXllcidzIHJlbGF0aW9uc2hpcCBpbiBhIHNlcGFyYXRlIC9hZGRUb0RlZmluaXRpb24gY2FsbFxuLy8gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvaXNzdWVzLzQzMTlcbi8vIFNvIHRoaXMgZnVuY3Rpb24gc2hvdWxkIE5PVCBhY2NlcHQgbGF5ZXJzL3RhYmxlcyB3aXRoIHJlbGF0aW9uc2hpcHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2Uoc2VydmljZSwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICAvLyBTcHJlYWQgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBvcmlnaW5hbCBjb250ZW50XG4gIGNvbnN0IGNvcGllZFNlcnZpY2UgPSBPYmplY3QuYXNzaWduKHt9LCBzZXJ2aWNlKTtcbiAgY29uc3QgeyBjb25maWcsIHVzZXIsIGFzeW5jQWRkVG9EZWZpbml0aW9uID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgYWRkVG9EZWZpbml0aW9uQ29udGVudCA9IHtcbiAgICBsYXllcnM6IChfYSA9IGNvcGllZFNlcnZpY2UubGF5ZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICB0YWJsZXM6IChfYiA9IGNvcGllZFNlcnZpY2UudGFibGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXVxuICB9O1xuICBjb25zdCBhZGRUb0RlZmluaXRpb25SZXF1ZXN0Q29udGVudCA9IEpTT04uc3RyaW5naWZ5KGFkZFRvRGVmaW5pdGlvbkNvbnRlbnQpO1xuICAvLyBDcmVhdGUgc2VydmljZSBmYWlscyBpZiBwYXNzaW5nIGxheWVycywgdGFibGVzXG4gIGRlbGV0ZSBjb3BpZWRTZXJ2aWNlLmxheWVycztcbiAgZGVsZXRlIGNvcGllZFNlcnZpY2UudGFibGVzO1xuICBkZWxldGUgY29waWVkU2VydmljZS5pbml0aWFsRXh0ZW50O1xuICBkZWxldGUgY29waWVkU2VydmljZS5mdWxsRXh0ZW50O1xuICBkZWxldGUgY29waWVkU2VydmljZS5fc3NsO1xuICBjb25zdCBjcmVhdGVTZXJ2aWNlQ29udGVudCA9IHsgY3JlYXRlUGFyYW1ldGVyczogSlNPTi5zdHJpbmdpZnkoY29waWVkU2VydmljZSksIHRhcmdldFR5cGU6IFwiZmVhdHVyZVNlcnZpY2VcIiB9O1xuICBjb25zdCB1cmwgPSBgJHtjb25maWcucmVzdEJhc2VVcmx9Y29udGVudC91c2Vycy8ke3VzZXIudXNlcm5hbWV9L2NyZWF0ZVNlcnZpY2VgO1xuICBjb25zdCBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHVybCwgY3JlYXRlU2VydmljZUNvbnRlbnQsIHt9LCBcInBvc3RcIik7XG4gIHRyeSB7XG4gICAgYXdhaXQgYWRkVG9EZWZpbml0aW9uKGFkZFRvRGVmaW5pdGlvblJlcXVlc3RDb250ZW50LCBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UuZW5jb2RlZFNlcnZpY2VVUkwsIGFzeW5jQWRkVG9EZWZpbml0aW9uKTtcbiAgICByZXR1cm4geyBjcmVhdGVTZXJ2aWNlUmVzcG9uc2UsIGFkZFRvRGVmaW5pdGlvblJlc3BvbnNlOiBhZGRUb0RlZmluaXRpb25Db250ZW50IH07XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIC8vIGlmIHRoZXJlIHdlcmUgZXJyb3JzIGFkZGluZyB0byB0aGUgZGVmaW5pdGlvbiwgY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzIGFuZCBkZWxldGUgdGhlIHNlcnZpY2VcbiAgICBjb25zdCBkZWxldGVVcmwgPSBgJHt1c2VyLnVzZXJDb250ZW50VXJsfS9pdGVtcy8ke2NyZWF0ZVNlcnZpY2VSZXNwb25zZS5pdGVtSWR9L2RlbGV0ZWA7XG4gICAgYXdhaXQgcmVxdWVzdChkZWxldGVVcmwsIHt9LCB7fSwgXCJwb3N0XCIpO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZFRvRGVmaW5pdGlvbihwYXJhbXMsIGVuY29kZWRTZXJ2aWNlVVJMLCBhc3luYyA9IHRydWUpIHtcbiAgaWYgKHBhcmFtcykge1xuICAgIGNvbnN0IGFkbWluVXJsID0gZW5jb2RlZFNlcnZpY2VVUkwucmVwbGFjZShcInJlc3Qvc2VydmljZXNcIiwgXCJyZXN0L2FkbWluL3NlcnZpY2VzXCIpO1xuICAgIGNvbnN0IHVybCA9IGAke2FkbWluVXJsfS9hZGRUb0RlZmluaXRpb25gO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0KHVybCwgeyBhZGRUb0RlZmluaXRpb246IHBhcmFtcywgYXN5bmMgfSwge30sIFwicG9zdFwiKTtcbiAgICAgIHJldHVybiBhc3luYyA/IGF3YWl0IHBvbGxGb3JTdGF0dXMocmVzdWx0LnN0YXR1c1VSTCkgOiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBlcnJvciBncmFjZWZ1bGx5XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgdGhlIGJhY2tlbmQgc2hvd3MgbWVhbmluZ2Z1bCBlcnJvcnMgb24gYGFzeW5jOiB0cnVlYFxuICAgICAgICAvLyBgYXN5bmM6IHRydWVgIGRvZXNuJ3Qgc2hvdyBhIG1lYW5pbmdmdWwgZXJyb3IuXG4gICAgICAgIC8vICAgIHNvIHdlIGRvIHRoaXMgdG8gZ2V0IHRoZSBhY3R1YWwgZXJyb3IgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICBhd2FpdCBhZGRUb0RlZmluaXRpb24ocGFyYW1zLCBlbmNvZGVkU2VydmljZVVSTCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TGF5ZXJJdGVtRGF0YShpdGVtLCBwb3J0YWwpIHtcbiAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyB0byB1c2UgZ2V0SXRlbURhdGEgZnJvbSBzZXJ2ZXItaXRlbS50c1xuICBjb25zdCB1cmwgPSBgJHtnZXRSZXN0QmFzZVVybChwb3J0YWwpfWNvbnRlbnQvaXRlbXMvJHtpdGVtLmlkfS9kYXRhYDtcbiAgcmV0dXJuIHJlcXVlc3QodXJsKTtcbn1cbi8qKlxuICogRmV0Y2ggYW4gaXRlbSBvZiB0eXBlIFwiTGF5ZXIgVGVtcGxhdGVcIiB1c2VkIGJ5IHRoZSBvcmcgdG8gY3JlYXRlIG5ldyBhdHRhY2htZW50IGxheWVyc1xuICovXG5hc3luYyBmdW5jdGlvbiBmaW5kVGVtcGxhdGVTZXJ2aWNlSW5mbyhwb3J0YWwpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZ3JvdXBSZXNwb25zZSA9IGF3YWl0IHF1ZXJ5R3JvdXBzKHsgcTogJ3RpdGxlOiBcIkVzcmkgTGF5ZXIgVGVtcGxhdGVzXCIgQU5EIG93bmVyOiBcImVzcmlfZW5cIicsIG51bTogMSB9KTtcbiAgY29uc3QgZ3JvdXAgPSAoX2EgPSBncm91cFJlc3BvbnNlLnJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRlbXBsYXRlUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KGAke2dldFJlc3RCYXNlVXJsKHBvcnRhbCl9L3NlYXJjaGAsIHtcbiAgICBxOiBgdGl0bGU6XCJQb2ludHNcIiBncm91cDpcIiR7Z3JvdXAuaWR9XCIgQU5EIHR5cGU6XCJMYXllciBUZW1wbGF0ZVwiIC10eXBlOlwiQXR0YWNobWVudFwiYCxcbiAgICBudW06IDFcbiAgfSk7XG4gIGNvbnN0IHRlbXBsYXRlID0gKF9iID0gdGVtcGxhdGVSZXNwb25zZS5yZXN1bHRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF07XG4gIHJldHVybiB0ZW1wbGF0ZSA/IGdldExheWVySXRlbURhdGEodGVtcGxhdGUsIHBvcnRhbCkgOiBudWxsO1xufVxuXG52YXIgX19yZXN0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgfVxuICByZXR1cm4gdDtcbn07XG5jb25zdCBkZWZhdWx0VGVtcGxhdGVTZXJ2aWNlSW5mbyA9IHtcbiAgY3VycmVudFZlcnNpb246IDEwLjUxLFxuICBoYXNWZXJzaW9uZWREYXRhOiBmYWxzZSxcbiAgc3VwcG9ydHNEaXNjb25uZWN0ZWRFZGl0aW5nOiBmYWxzZSxcbiAgaGFzU3RhdGljRGF0YTogZmFsc2UsXG4gIG1heFJlY29yZENvdW50OiAyMDAwLFxuICBzdXBwb3J0ZWRRdWVyeUZvcm1hdHM6IFwiSlNPTlwiLFxuICBzdXBwb3J0c1ZDU1Byb2plY3Rpb246IGZhbHNlLFxuICBjYXBhYmlsaXRpZXM6IFwiUXVlcnksRWRpdGluZyxDcmVhdGUsVXBkYXRlLERlbGV0ZSxTeW5jXCIsXG4gIGRlc2NyaXB0aW9uOiBcIlwiLFxuICBjb3B5cmlnaHRUZXh0OiBcIlwiLFxuICBhbGxvd0dlb21ldHJ5VXBkYXRlczogdHJ1ZSxcbiAgdW5pdHM6IFwiZXNyaU1ldGVyc1wiLFxuICBzdXBwb3J0c0FwcGVuZDogdHJ1ZSxcbiAgc3luY0VuYWJsZWQ6IGZhbHNlLFxuICBzdXBwb3J0c0FwcGx5RWRpdHNXaXRoR2xvYmFsSWRzOiBmYWxzZSxcbiAgZWRpdG9yVHJhY2tpbmdJbmZvOiB7XG4gICAgYWxsb3dBbm9ueW1vdXNUb0RlbGV0ZTogdHJ1ZSxcbiAgICBhbGxvd0Fub255bW91c1RvUXVlcnk6IHRydWUsXG4gICAgYWxsb3dBbm9ueW1vdXNUb1VwZGF0ZTogdHJ1ZSxcbiAgICBhbGxvd090aGVyc1RvRGVsZXRlOiBmYWxzZSxcbiAgICBhbGxvd090aGVyc1RvUXVlcnk6IHRydWUsXG4gICAgYWxsb3dPdGhlcnNUb1VwZGF0ZTogdHJ1ZSxcbiAgICBlbmFibGVFZGl0b3JUcmFja2luZzogZmFsc2UsXG4gICAgZW5hYmxlT3duZXJzaGlwQWNjZXNzQ29udHJvbDogZmFsc2VcbiAgfSxcbiAgeHNzUHJldmVudGlvbkluZm86IHsgeHNzUHJldmVudGlvbkVuYWJsZWQ6IHRydWUsIHhzc1ByZXZlbnRpb25SdWxlOiBcIklucHV0T25seVwiLCB4c3NJbnB1dFJ1bGU6IFwicmVqZWN0SW52YWxpZFwiIH0sXG4gIF9zc2w6IHRydWVcbn07XG5jb25zdCBhZGRGZWF0dXJlTGF5ZXIgPSBhc3luYyAocmVxdWVzdFBhcmFtcykgPT4ge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgY29uc3QgeyB0YWdzLCBzZXJ2aWNlSW5mbywgdHlwZUtleXdvcmRzOiBzdG9yZVR5cGVLZXl3b3JkcywgZXh0ZW50OiBzdG9yZUV4dGVudCwgc2VsZWN0ZWRTZXJ2aWNlSW5mb0xheWVyc05hbWVzLCBhZGRGZWF0dXJlTGF5ZXJUeXBlIH0gPSByZXF1ZXN0UGFyYW1zO1xuICBjb25zdCB7IHBvcnRhbCB9ID0gY29uZmlnU3RhdGU7XG4gIGNvbnN0IGlzRW50ZXJwcmlzZSA9IHBvcnRhbC5pc1BvcnRhbDtcbiAgaWYgKCFzZXJ2aWNlSW5mbykge1xuICAgIC8vIFRPRE86IGhhdmUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSBoZXJlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2VydmljZSBpbmZvIGZvdW5kLlwiKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8zNzI1NSNpc3N1ZWNvbW1lbnQtMzE4NjU2NFxuICAgIGxldCBwcmVzZXRTZXJ2aWNlSW5mbyA9IGRlZmF1bHRUZW1wbGF0ZVNlcnZpY2VJbmZvO1xuICAgIHRyeSB7XG4gICAgICBwcmVzZXRTZXJ2aWNlSW5mbyA9IChfYSA9IChhd2FpdCBmaW5kVGVtcGxhdGVTZXJ2aWNlSW5mbyhwb3J0YWwpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFRlbXBsYXRlU2VydmljZUluZm87XG4gICAgICBwcmVzZXRTZXJ2aWNlSW5mby5jYXBhYmlsaXRpZXMgPSBcIlF1ZXJ5LEVkaXRpbmcsQ3JlYXRlLFVwZGF0ZSxEZWxldGVcIjtcbiAgICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy8zODk2NlxuICAgICAgcHJlc2V0U2VydmljZUluZm8uaGFzU3RhdGljRGF0YSA9IGZhbHNlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZldGNoIHRlbXBsYXRlICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IpfWApO1xuICAgIH1cbiAgICBjb25zdCBmZWF0dXJlTGF5ZXJTZXJ2aWNlSW5mbyA9IHNlcnZpY2VJbmZvO1xuICAgIGxldCBiYXNlTGF5ZXIgPSAoX2IgPSBmZWF0dXJlTGF5ZXJTZXJ2aWNlSW5mby5sYXllcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgIGxldCBiYXNlVGFibGVzID0gKF9jID0gZmVhdHVyZUxheWVyU2VydmljZUluZm8udGFibGVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAvLyAqIEZpbHRlciBzZWxlY3RlZCBsYXllcnNcbiAgICAvLyAhIE1ha2Ugc3VyZSB0aGlzIGlzIGRvbmUgYmVmb3JlIGV4dHJhY3RBbmRDbGVhblJlbGF0aW9uc2hpcFBhcmFtIGJlY2F1c2UgdGhlIGByZWxhdGlvbnNoaXBgXG4gICAgLy8gISAgIGRlcGVuZHMgb24gaXQhXG4gICAgLy8gQnVpbGQgZnJvbSBzY3JhdGNoIGZsb3cgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGZpbHRlciBhdCB0aGUgZW5kIG9mIGl0cyBwYWdlXG4gICAgaWYgKGFkZEZlYXR1cmVMYXllclR5cGUgIT09IFwiYnVpbGRcIiAmJiBzZWxlY3RlZFNlcnZpY2VJbmZvTGF5ZXJzTmFtZXMpIHtcbiAgICAgIGNvbnN0IGNoZWNrU2VsZWN0ZWQgPSAobGF5ZXIpID0+IHNlbGVjdGVkU2VydmljZUluZm9MYXllcnNOYW1lc1tsYXllci5uYW1lXTtcbiAgICAgIGJhc2VMYXllciA9IGJhc2VMYXllci5maWx0ZXIoY2hlY2tTZWxlY3RlZCk7XG4gICAgICBiYXNlVGFibGVzID0gYmFzZVRhYmxlcy5maWx0ZXIoY2hlY2tTZWxlY3RlZCk7XG4gICAgfVxuICAgIC8vICogRmlsdGVyIHVuaXF1ZSBpbmRleFxuICAgIC8vICEgU29tZXRpbWVzIHRoZSBiYWNrZW5kIHJldHVybnMgdGVtcGxhdGUgbGF5ZXJzIHdpdGggZHVwbGljYXRlIGluZGV4ZXMsXG4gICAgLy8gISAgd2UgbmVlZCB0byBtYWtlIGl0IHVuaXF1ZSB1bnRpbCB0aGUgcHJvYmxlbSBnb3QgZml4ZWRcbiAgICAvLyA/IE5vdGUgdGhhdCB0aGlzIG1pZ2h0IGJlIGEgYnVnIGluIHRoZSAvYWRkVG9EZWZpbml0aW9uIGJhY2tlbmQgYmVjYXVzZVxuICAgIC8vID8gIGh0dHBzOi8vZGV2ZWxvcGVycy5hcmNnaXMuY29tL3Jlc3Qvc2VydmljZXMtcmVmZXJlbmNlL29ubGluZS9hZGQtdG8tZGVmaW5pdGlvbi1mZWF0dXJlLXNlcnZpY2UtLmh0bVxuICAgIC8vID8gIGV4YW1wbGUgc2VlbXMgdG8gYWxsb3cgZHVwbGljYXRlIGZpZWxkc1xuICAgIGNvbnN0IHsgbGF5ZXJzOiB1bmlxdWVJbmRleExheWVycywgdGFibGVzOiB1bmlxdWVJbmRleFRhYmxlcyB9ID0gZXh0cmFjdFVuaXF1ZUluZGV4KGJhc2VMYXllciwgYmFzZVRhYmxlcyk7XG4gICAgLy8gKiBGaXggaWRzXG4gICAgLy8gIFNvbWUgdGVtcGxhdGUgcmV0dXJucyBub25jb250aW51b3VzIGlkLCB3aGljaCBpcyBiYWRcbiAgICAvLyAgPT4gd2UgYWxzbyBuZWVkIHRvIGZpeCBpZHMgdGhhdCBjYXNlXG4gICAgY29uc3QgeyBsYXllcnMsIHRhYmxlcyB9ID0gZml4SWRzKHVuaXF1ZUluZGV4TGF5ZXJzLCB1bmlxdWVJbmRleFRhYmxlcyk7XG4gICAgLy8gKiBGb3JtIHBhcmFtZXRlcnNcbiAgICBjb25zdCBjcmVhdGVQYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXNldFNlcnZpY2VJbmZvKSwgc2VydmljZUluZm8pLCB7IG5hbWU6IGZlYXR1cmVMYXllclNlcnZpY2VJbmZvLm5hbWUgfHwgaXRlbVByb3BlcnRpZXNTdGF0ZS50aXRsZSwgbGF5ZXJzLFxuICAgICAgdGFibGVzIH0pO1xuICAgIC8vICogQ2xlYW4gcGFyYW1ldGVyc1xuICAgIC8vIFdlIG5lZWQgdG8gc2VuZCBsYXllcidzIHJlbGF0aW9uc2hpcCBpbiBhIHNlcGFyYXRlIC9hZGRUb0RlZmluaXRpb24gY2FsbFxuICAgIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2lzc3Vlcy80MzE5XG4gICAgLy8gVGhlcmUgYXJlIGFsc28gc29tZSBjYXNlIHdoZXJlIGxheWVycyBkZXBlbmQgb24gZWFjaCBvdGhlciAoaGVuY2UgdGhlIGByZWxhdGlvbnNoaXBgKVxuICAgIC8vICBidXQgc29tZSBvZiB0aGUgbGF5ZXJzIGFyZSBkZXNlbGVjdGVkIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBiYWQgcmVsYXRpb25zaGlwIGRvZXNuJ3QgZ28gdGhlIGJhY2tlbmRcbiAgICAvLyA9PiBleHRyYWN0IGFuZCBjbGVhblxuICAgIGNvbnN0IHsgY2xlYW5lZENyZWF0ZVBhcmFtZXRlcnMsIHJlbGF0aW9uc2hpcFBhcmFtZXRlcnMgfSA9IGV4dHJhY3RBbmRDbGVhblJlbGF0aW9uc2hpcFBhcmFtKGNyZWF0ZVBhcmFtZXRlcnMpO1xuICAgIC8vICog8J+NkiDim48gdGhlIHJlc3Qgb2YgdGhlIHByb3BlcnRpZXNcbiAgICBjb25zdCBjaGVycnlQaWNrUHJvcHMgPSBbXG4gICAgICBcInNlcnZpY2VEZXNjcmlwdGlvblwiLFxuICAgICAgXCJoYXNTdGF0aWNEYXRhXCIsXG4gICAgICBcIm1heFJlY29yZENvdW50XCIsXG4gICAgICBcInN1cHBvcnRlZFF1ZXJ5Rm9ybWF0c1wiLFxuICAgICAgXCJjYXBhYmlsaXRpZXNcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICAgIFwiY29weXJpZ2h0VGV4dFwiLFxuICAgICAgXCJzcGF0aWFsUmVmZXJlbmNlXCIsXG4gICAgICBcImluaXRpYWxFeHRlbnRcIixcbiAgICAgIFwiZnVsbEV4dGVudFwiLFxuICAgICAgXCJfc3NsXCIsXG4gICAgICBcImFsbG93R2VvbWV0cnlVcGRhdGVzXCIsXG4gICAgICBcInVuaXRzXCIsXG4gICAgICBcInhzc1ByZXZlbnRpb25JbmZvXCJcbiAgICBdO1xuICAgIGNoZXJyeVBpY2tQcm9wcy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmVhdHVyZUxheWVyU2VydmljZUluZm9ba2V5XTtcbiAgICAgIHZhbHVlICE9IG51bGwgJiYgKGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzW2tleV0gPSB2YWx1ZSk7XG4gICAgfSk7XG4gICAgY2xlYW5lZENyZWF0ZVBhcmFtZXRlcnMubmFtZSA9IGZvcm1hdEZpbGVOYW1lKGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzLm5hbWUpO1xuICAgIGlmIChhZGRGZWF0dXJlTGF5ZXJUeXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICAgIGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzLnN5bmNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzLmNhcGFiaWxpdGllcyA9IFwiUXVlcnksRWRpdGluZyxDcmVhdGUsVXBkYXRlLERlbGV0ZSxTeW5jXCI7XG4gICAgfVxuICAgIC8vICogU2VuZCByZXF1ZXN0c1xuICAgIGNvbnN0IHsgY3JlYXRlU2VydmljZVJlc3BvbnNlIH0gPSBhd2FpdCBjcmVhdGVTZXJ2aWNlKGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzLCB7XG4gICAgICBhc3luY0FkZFRvRGVmaW5pdGlvbjogIWlzRW50ZXJwcmlzZSxcbiAgICAgIGNvbmZpZzogY29uZmlnU3RhdGUuY29uZmlnLFxuICAgICAgdXNlcjogY29uZmlnU3RhdGUudXNlclxuICAgIH0pO1xuICAgIGNvbnN0IHsgaXRlbUlkLCBzdWNjZXNzIH0gPSBjcmVhdGVTZXJ2aWNlUmVzcG9uc2U7XG4gICAgY29uc3QgeyB0eXBlS2V5d29yZHM6IGl0ZW1UeXBlS2V5d29yZHMgfSA9IChhd2FpdCBnZXRJdGVtKGl0ZW1JZCkpLnJlc3VsdDtcbiAgICBjb25zdCB0eXBlS2V5d29yZHMgPSBbLi4uc3RvcmVUeXBlS2V5d29yZHMsIC4uLml0ZW1UeXBlS2V5d29yZHNdO1xuICAgIGlmIChzZXJ2aWNlSW5mby5jYXB0dXJlR1BTKSB7XG4gICAgICB0eXBlS2V5d29yZHMucHVzaChcImdwc01ldGFkYXRhRW5hYmxlZFwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIG51bWJlciB0YWtlbiBmcm9tIHRoZSBvbGQgVUkncyBcIi91cGRhdGVcIiBlbmRwb2ludFxuICAgICAgY29uc3QgZXh0ZW50ID0gcG9ydGFsLmRlZmF1bHRFeHRlbnQgfHwgc2VydmljZUluZm8uZnVsbEV4dGVudCB8fCBzZXJ2aWNlSW5mby5leHRlbnQgfHwgc3RvcmVFeHRlbnQ7XG4gICAgICBjb25zdCBzcGF0aWFsUmVmZXJlbmNlID0gZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2Uud2tpZCB8fCBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZS53a3QgfHwgXCI0MzI2XCI7XG4gICAgICBjb25zdCBleHRlbnRTdHJpbmcgPSBleHRlbnRUb1N0cmluZyhpc1ZhbGlkV0dTODRFeHRlbnQoZXh0ZW50KSB8fCBzcGF0aWFsUmVmZXJlbmNlICE9PSBcIjQzMjZcIiA/IGV4dGVudCA6IGF3YWl0IHByb2plY3RFeHRlbnRUb1dHUzg0KGV4dGVudCkpO1xuICAgICAgY29uc3QgdGh1bWJuYWlsVVJMID0gYGh0dHBzOi8vc2VydmljZXMuYXJjZ2lzb25saW5lLmNvbS9BcmNHSVMvcmVzdC9zZXJ2aWNlcy9Xb3JsZF9Ub3BvX01hcC9NYXBTZXJ2ZXIvZXhwb3J0P3NpemU9ODAwLDUzMiZmb3JtYXQ9cG5nMjQmYmJveFNSPSR7c3BhdGlhbFJlZmVyZW5jZX0mYmJveD0ke2V4dGVudFN0cmluZ30mZj1pbWFnZWA7XG4gICAgICBjb25zdCBpc0luUm9vdCA9IGlzRm9sZGVyUm9vdChpdGVtUHJvcGVydGllc1N0YXRlLmZvbGRlcik7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHVwZGF0ZUl0ZW0oaXRlbUlkLCB7XG4gICAgICAgICAgdGl0bGU6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGl0bGUsXG4gICAgICAgICAgdHlwZUtleXdvcmRzOiB0eXBlS2V5d29yZHMuam9pbihcIixcIiksXG4gICAgICAgICAgdGFnczogKHRhZ3MgIT09IG51bGwgJiYgdGFncyAhPT0gdm9pZCAwID8gdGFncyA6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUudGFncykuam9pbihcIixcIiksXG4gICAgICAgICAgZXh0ZW50OiBleHRlbnRTdHJpbmcsXG4gICAgICAgICAgc25pcHBldDogaXRlbVByb3BlcnRpZXNTdGF0ZS5zbmlwcGV0LFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBhZGRJdGVtU3RhdGUuZGVzY3JpcHRpb25cbiAgICAgICAgfSksXG4gICAgICAgIHJlbGF0aW9uc2hpcFBhcmFtZXRlcnMubGF5ZXJzIHx8IHJlbGF0aW9uc2hpcFBhcmFtZXRlcnMudGFibGVzXG4gICAgICAgICAgPyBhZGRUb0RlZmluaXRpb24oSlNPTi5zdHJpbmdpZnkocmVsYXRpb25zaGlwUGFyYW1ldGVycyksIGNyZWF0ZVNlcnZpY2VSZXNwb25zZS5lbmNvZGVkU2VydmljZVVSTCwgIWlzRW50ZXJwcmlzZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgIWlzSW5Sb290ICYmIG1vdmVJdGVtKGl0ZW1JZCwgaXRlbVByb3BlcnRpZXNTdGF0ZS5mb2xkZXIuaWQpXG4gICAgICBdKTtcbiAgICAgIC8vIE5vIGF3YWl0LCBqdXN0IGxlYXZlIGl0IGJlXG4gICAgICB1cGRhdGVJdGVtKGl0ZW1JZCwgeyB0aHVtYm5haWxVUkwgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzLCBpZDogaXRlbUlkLCBmb2xkZXI6IGl0ZW1Qcm9wZXJ0aWVzU3RhdGUuZm9sZGVyLmlkIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgZGVsZXRlSXRlbShpdGVtSWQpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5jb25zdCBnZXRTZXJ2aWNlQW5kTGF5ZXJJbmZvID0gYXN5bmMgKHNlcnZpY2VVcmwsIHJlc3RCYXNlVXJsLCBmb3JjZUFkZFRva2VuLCBpc1NlY3VyZVxuLy8gVE9ETzogcmVmYWN0b3IgdGhpcyB0byBuZXcgZXJyb3Igc3lzdGVtXG4pID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IHVzZXJuYW1lLCBwYXNzd29yZCwgY2hlY2tBdXRoIH0gPSBhZGRJdGVtU3RhdGU7XG4gIHRyeSB7XG4gICAgY29uc3QgZ2V0U2VydmljZUluZm9XcmFwcGVyID0gKHVybCkgPT4gZ2V0U2VydmljZUluZm8oeyB1c2VybmFtZSwgcGFzc3dvcmQgfSwgdXJsLCB7XG4gICAgICBmb3JjZUFkZFRva2VuLFxuICAgICAgaXNTZWN1cmUsXG4gICAgICAvLyBBZGQgdGhlIHRpbWUgb2Ygd3JpdGluZywgb25seSBmZWF0dXJlIGxheWVyIGFuZCB0aWxlIGxheWVyIHVzZSB0aGlzIG1ldGhvZCwgc28gdGhleSdyZSBub3QgYSB2aWRlbyBzZXJ2aWNlXG4gICAgICBpc1ZpZGVvU2VydmljZTogZmFsc2UsXG4gICAgICBjaGVja0F1dGhcbiAgICB9KTtcbiAgICBjb25zdCBleHRyYWN0ZWRTZXJ2aWNlSW5mbyA9IHBhcnNlQUdTU2VydmVySW5mbyhzZXJ2aWNlVXJsKTtcbiAgICBpZiAoIWV4dHJhY3RlZFNlcnZpY2VJbmZvKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIHNlcnZpY2UgaW5mb1wiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IGJhc2VTZXJ2ZXJVcmwsIGluZGV4IH0gPSBleHRyYWN0ZWRTZXJ2aWNlSW5mbztcbiAgICBjb25zdCBzZXJ2aWNlSW5mbyA9IChhd2FpdCBnZXRTZXJ2aWNlSW5mb1dyYXBwZXIoYmFzZVNlcnZlclVybCkpO1xuICAgIGNvbnN0IGxheWVycyA9IChhd2FpdCBQcm9taXNlLmFsbCgoc2VydmljZUluZm8ubGF5ZXJzIHx8IFtdKVxuICAgICAgLmZpbHRlcigobGF5ZXIpID0+IGluZGV4ID09PSBudWxsIHx8IGxheWVyLmlkID09PSBpbmRleClcbiAgICAgIC5tYXAoKGxheWVyKSA9PiBnZXRTZXJ2aWNlSW5mb1dyYXBwZXIoYCR7YmFzZVNlcnZlclVybH0vJHtsYXllci5pZH1gKSkpKTtcbiAgICBjb25zdCB0YWJsZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoKHNlcnZpY2VJbmZvLnRhYmxlcyB8fCBbXSlcbiAgICAgIC5maWx0ZXIoKHRhYmxlKSA9PiBpbmRleCA9PT0gbnVsbCB8fCB0YWJsZS5pZCA9PT0gaW5kZXgpXG4gICAgICAubWFwKCh0YWJsZSkgPT4gZ2V0U2VydmljZUluZm9XcmFwcGVyKGAke2Jhc2VTZXJ2ZXJVcmx9LyR7dGFibGUuaWR9YCkpKSk7XG4gICAgcmV0dXJuIHsgc2VydmljZUluZm8sIGxheWVycywgdGFibGVzIH07XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgaWYgKCgoX2EgPSBlcnJvci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IFwidG9rZW4gcmVxdWlyZWRcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBzZWN1cmVkIH0gPSBhd2FpdCBnZXRJc1NlY3VyZWQoeyB1c2VybmFtZSwgcGFzc3dvcmQgfSwgc2VydmljZVVybCwgcmVzdEJhc2VVcmwsIGNoZWNrQXV0aCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXRTZXJ2aWNlQW5kTGF5ZXJJbmZvKHNlcnZpY2VVcmwsIHJlc3RCYXNlVXJsLCBzZWN1cmVkKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5jb25zdCBleHRyYWN0QW5kQ2xlYW5SZWxhdGlvbnNoaXBQYXJhbSA9IChjcmVhdGVQYXJhbWV0ZXJzKSA9PiB7XG4gIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICBjb25zdCBzZXR1cExvb2t1cE1hcCA9IChyZWxhdGlvbnNoaXApID0+IChsb29rdXBNYXBbcmVsYXRpb25zaGlwLmlkXSA9IHRydWUpO1xuICBjcmVhdGVQYXJhbWV0ZXJzLmxheWVycy5mb3JFYWNoKHNldHVwTG9va3VwTWFwKTtcbiAgY3JlYXRlUGFyYW1ldGVycy50YWJsZXMuZm9yRWFjaChzZXR1cExvb2t1cE1hcCk7XG4gIC8vICogRXh0cmFjdCByZWxhdGlvbnNoaXBcbiAgLy8gISBEbyBub3QgZGVsZXRlIGxheWVyLnJlbGF0aW9uc2hpcHMgaGVyZSBvciBpdCB3aWxsIGJyZWFrIHdoZW5cbiAgLy8gISAgdGhlIHVzZXIgZ28gQmFjayB0aGVuIE5leHQgaW4gdGhlIGNhc2UgaXRlbSBjcmVhdGlvbiBmYWlsZWRcbiAgY29uc3QgZmlsdGVyTWlzc2luZ1JlbGF0aW9uc2hpcCA9IChyZWxhdGlvbnNoaXApID0+IGxvb2t1cE1hcFtyZWxhdGlvbnNoaXAucmVsYXRlZFRhYmxlSWRdO1xuICBjb25zdCBleHRyYWN0UmVsYXRpb25zaGlwID0gKGxheWVyKSA9PiAoe1xuICAgIHJlbGF0aW9uc2hpcHM6IGxheWVyLnJlbGF0aW9uc2hpcHMuZmlsdGVyKGZpbHRlck1pc3NpbmdSZWxhdGlvbnNoaXApLFxuICAgIGlkOiBsYXllci5pZFxuICB9KTtcbiAgY29uc3QgZmlsdGVyRW1wdHlSZWxhdGlvbnNoaXAgPSAobGF5ZXIpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGxheWVyLnJlbGF0aW9uc2hpcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMDsgfTtcbiAgY29uc3QgbGF5ZXJSZWxhdGlvbnNoaXBzID0gY3JlYXRlUGFyYW1ldGVycy5sYXllcnMubWFwKGV4dHJhY3RSZWxhdGlvbnNoaXApLmZpbHRlcihmaWx0ZXJFbXB0eVJlbGF0aW9uc2hpcCk7XG4gIGNvbnN0IHRhYmxlUmVsYXRpb25zaGlwcyA9IGNyZWF0ZVBhcmFtZXRlcnMudGFibGVzLm1hcChleHRyYWN0UmVsYXRpb25zaGlwKS5maWx0ZXIoZmlsdGVyRW1wdHlSZWxhdGlvbnNoaXApO1xuICBjb25zdCByZWxhdGlvbnNoaXBQYXJhbWV0ZXJzID0geyBsYXllcnM6IGxheWVyUmVsYXRpb25zaGlwcywgdGFibGVzOiB0YWJsZVJlbGF0aW9uc2hpcHMgfTtcbiAgaWYgKHJlbGF0aW9uc2hpcFBhcmFtZXRlcnMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSByZWxhdGlvbnNoaXBQYXJhbWV0ZXJzLmxheWVycztcbiAgfVxuICBpZiAocmVsYXRpb25zaGlwUGFyYW1ldGVycy50YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHJlbGF0aW9uc2hpcFBhcmFtZXRlcnMudGFibGVzO1xuICB9XG4gIC8vICogQ3JlYXRlIG5ldyBjcmVhdGVQYXJhbWV0ZXJzIHdpdGhvdXQgcmVsYXRpb25zaGlwXG4gIGNvbnN0IGxheWVycyA9IGNyZWF0ZVBhcmFtZXRlcnMubGF5ZXJzLm1hcCgoX2EpID0+IHtcbiAgICB2YXIgbGF5ZXJzID0gX19yZXN0KF9hLCBbXCJyZWxhdGlvbnNoaXBzXCJdKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9KTtcbiAgY29uc3QgdGFibGVzID0gY3JlYXRlUGFyYW1ldGVycy50YWJsZXMubWFwKChfYSkgPT4ge1xuICAgIHZhciB0YWJsZXMgPSBfX3Jlc3QoX2EsIFtcInJlbGF0aW9uc2hpcHNcIl0pO1xuICAgIHJldHVybiB0YWJsZXM7XG4gIH0pO1xuICBjb25zdCBjbGVhbmVkQ3JlYXRlUGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3JlYXRlUGFyYW1ldGVycyksIHsgbGF5ZXJzLCB0YWJsZXMgfSk7XG4gIHJldHVybiB7IHJlbGF0aW9uc2hpcFBhcmFtZXRlcnMsIGNsZWFuZWRDcmVhdGVQYXJhbWV0ZXJzIH07XG59O1xuY29uc3QgZXh0cmFjdFVuaXF1ZUluZGV4ID0gKGxheWVycywgdGFibGVzKSA9PiB7XG4gIGNvbnN0IGdldFVuaXF1ZUluZGV4TGF5ZXIgPSAobGF5ZXIpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxheWVyKSwgeyBpbmRleGVzOiB1bmlxdWVCeShsYXllci5pbmRleGVzLCAoaXRlbSkgPT4gaXRlbS5uYW1lKSB9KSk7XG4gIHJldHVybiB7XG4gICAgbGF5ZXJzOiBsYXllcnMubWFwKGdldFVuaXF1ZUluZGV4TGF5ZXIpLFxuICAgIHRhYmxlczogdGFibGVzLm1hcChnZXRVbmlxdWVJbmRleExheWVyKVxuICB9O1xufTtcbi8qKiBGaXggaWRzIGZvciBib3RoIGxheWVycyBhbmQgcmVsYXRpb25zaGlwcyAqL1xuY29uc3QgZml4SWRzID0gKGxheWVycywgdGFibGVzKSA9PiB7XG4gIC8vIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwL2Jsb2IvbWFzdGVyL3NyYy9qcy9hcmNnaXNvbmxpbmUvc2hhcmluZy9kaWppdC9kaWFsb2cvUHVibGlzaFdpemFyZC5qcyNMMTQ1MC1MMTQ4M1xuICBsZXQgbGF5ZXJJbmZvcyA9IGNvbWJpbmVGZWF0dXJlTGF5ZXJJbmZvcyhsYXllcnMsIHRhYmxlcyk7XG4gIC8vICogRml4IGxheWVycyBpZHNcbiAgLyoqIFJlY29yZDxvbGQgaWQsIG5ldyBpZD4gKi9cbiAgY29uc3Qgb2xkTGF5ZXJJZHMgPSB7fTtcbiAgbGF5ZXJJbmZvcyA9IGxheWVySW5mb3MubWFwKChsYXllckluZm8sIGluZGV4KSA9PiB7XG4gICAgb2xkTGF5ZXJJZHNbbGF5ZXJJbmZvLmlkXSA9IGluZGV4O1xuICAgIGNvbnN0IG5ld0xheWVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsYXllckluZm8pLCB7IGlkOiBpbmRleCB9KTtcbiAgICByZXR1cm4gbmV3TGF5ZXI7XG4gIH0pO1xuICAvLyAqIEZpeCByZWxhdGlvbnNoaXBJZHNcbiAgbGF5ZXJJbmZvcy5mb3JFYWNoKChsYXllckluZm8pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGF5ZXJJbmZvLnJlbGF0aW9uc2hpcHMgPSAoKF9hID0gbGF5ZXJJbmZvLnJlbGF0aW9uc2hpcHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5tYXAoKHJlbGF0aW9uc2hpcCkgPT4ge1xuICAgICAgY29uc3Qgb2xkUmVsYXRlZElkID0gcmVsYXRpb25zaGlwLnJlbGF0ZWRUYWJsZUlkO1xuICAgICAgY29uc3QgbmV3UmVsYXRlZElkID0gb2xkTGF5ZXJJZHNbb2xkUmVsYXRlZElkXTtcbiAgICAgIGNvbnN0IG5ld1JlbGF0aW9uc2hpcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVsYXRpb25zaGlwKSwgeyByZWxhdGVkVGFibGVJZDogbmV3UmVsYXRlZElkIH0pO1xuICAgICAgcmV0dXJuIG5ld1JlbGF0aW9uc2hpcDtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBsYXllckluZm9zLnJlZHVjZSgocmVzdWx0LCBjdXJJbmZvKSA9PiB7XG4gICAgY3VySW5mby50eXBlID09PSBcIlRhYmxlXCIgPyByZXN1bHQudGFibGVzLnB1c2goY3VySW5mbykgOiByZXN1bHQubGF5ZXJzLnB1c2goY3VySW5mbyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgeyBsYXllcnM6IFtdLCB0YWJsZXM6IFtdIH0pO1xufTtcblxuZXhwb3J0IHsgZ2V0U2VjdXJlZEFHU1NlcnZpY2VJbmZvIGFzIEEsIE1VTFRJX1BBUlRfVVBMT0FEX01JTklNVU1fU0laRSBhcyBNLCBhZGRTZWN1cmVBR1NVcmwgYXMgYSwgYWRkQXBwbGljYXRpb24gYXMgYiwgYWRkRmVhdHVyZUxheWVyIGFzIGMsIGFkZENsb3VkUHJvdmlkZXJSZXNvdXJjZSBhcyBkLCBhZGRGaWxlIGFzIGUsIGZldGNoQXBwbGljYXRpb25NYW5pZmVzdCBhcyBmLCBnZXRTZXJ2aWNlQW5kTGF5ZXJJbmZvIGFzIGcsIGhhbmRsZUFkZFVybCBhcyBoLCBpc0h5YnJpZEltYWdlU2VydmljZSBhcyBpLCBpc0FwcENvbXBvbmVudEVycm9yIGFzIGosIGlzQmFja2VuZEVycm9yIGFzIGssIGFkZEZpbGVGcm9tRGF0YVVybCBhcyBsLCBzZWxlY3RPR0NGZWF0dXJlTGF5ZXIgYXMgbSwgZm9ybWF0Q3VzdG9tUGFyYW1ldGVycyBhcyBuLCBnZXRVcmxTZXJ2aWNlSW5mbyBhcyBvLCBwcm9jZXNzUG9zdEFkZEtNTCBhcyBwLCBpc0ZvbGRlclJvb3QgYXMgcSwgcmVtb3ZlUGFyYW1ldGVyIGFzIHIsIHN1YnNjcmlwdGlvblN0YXRlIGFzIHMsIGFkZEl0ZW0gYXMgdCwgZmluZFRlbXBsYXRlU2VydmljZUluZm8gYXMgdSwgY3JlYXRlU2VydmljZSBhcyB2LCBnZXRJdGVtU3RhdHVzIGFzIHcsIHVwbG9hZEZpbGUgYXMgeCwgcmVnaXN0ZXJBcHBsaWNhdGlvbiBhcyB5LCBnZXRMYXllckl0ZW1EYXRhIGFzIHogfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgYSBhcyBhZGRDcmVhdGVJdGVtVHlwZXMgfSBmcm9tICcuL2l0ZW0tdHlwZXMtYjRmZTg2YWQuanMnO1xuaW1wb3J0IHsgZyBhcyBndWlkIH0gZnJvbSAnLi9ndWlkLTRmNDE3NmJhLmpzJztcblxuZnVuY3Rpb24gc2FuaXRpemVGaWxlTmFtZShuYW1lLCBhZGRHVUlEKSB7XG4gIC8vVE9ETzogYWRkIG5ldyBwYXJhbSB0byBzcGVjIGZpbGUuXG4gIGNvbnN0IGV4cHJlc3Npb24gPSAvKD86XFwuKFteLl0rKSk/JC87XG4gIGNvbnN0IGludmFsaWRUaXRsZUNoYXJhY3RlcnMgPSAvXFwufC0vZztcbiAgbGV0IGZpbGVOYW1lID0gbmFtZS5yZXBsYWNlKC9eLiooXFxcXHxcXC98OikvLCBcIlwiKTtcbiAgbGV0IGV4dGVuc2lvbiA9IChmaWxlTmFtZSAmJiBleHByZXNzaW9uLmV4ZWMoZmlsZU5hbWUpWzFdID8gZXhwcmVzc2lvbi5leGVjKGZpbGVOYW1lKVsxXS50b0xvd2VyQ2FzZSgpIDogXCJcIik7XG4gIGxldCB0aXRsZSA9IFwiXCI7XG4gIGlmIChmaWxlTmFtZS5pbmRleE9mKFwiLnJmdC5cIikgPiAtMSkge1xuICAgIGNvbnN0IFtuYW1lLCBzdWZmaXhdID0gZmlsZU5hbWUuc3BsaXQoXCIucmZ0LlwiKTtcbiAgICBleHRlbnNpb24gPSBgcmZ0LiR7c3VmZml4fWA7XG4gICAgdGl0bGUgPSBuYW1lO1xuICB9XG4gIGlmIChmaWxlTmFtZSAmJiAhdGl0bGUpIHtcbiAgICB0aXRsZSA9IGZpbGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKSA9PT0gLTEgPyBmaWxlTmFtZSA6IGZpbGVOYW1lLnN1YnN0cmluZygwLCBmaWxlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikpO1xuICB9XG4gIC8vIFJlcGxhY2UgYW55IGludmFsaWQgY2hhcmFjdGVycyB3aXRoIGFuIHVuZGVyc2NvcmVcbiAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKGludmFsaWRUaXRsZUNoYXJhY3RlcnMsIFwiX1wiKTtcbiAgLy8gQWxsb3cgZmlsZSB1cGxvYWQgb2YgZXhpc3RpbmcgaXRlbSdzIGZpbGUgbmFtZSAvLyBjdXJyZW50bHkgdXNlZCBpbiBhcHBlbmRcbiAgaWYgKGFkZEdVSUQpIHtcbiAgICB0aXRsZSA9IG1ha2VVbmlxdWVGaWxlTmFtZSh0aXRsZSk7XG4gICAgZmlsZU5hbWUgPSBgJHt0aXRsZX0uJHtleHRlbnNpb259YDtcbiAgfVxuICByZXR1cm4geyB0aXRsZSwgZmlsZU5hbWUsIGV4dGVuc2lvbiB9O1xufVxuLy8gSGVscGVyIG1ldGhvZCB0aGF0IHRha2VzIGluIGEgZmlsZSAmIHJldHVybnMgdGhlIGNsZWFuZWQgdXAgZmlsZSBuYW1lIGFzIGlzIGFuZCBpbiB0aXRsZSBmb3JtLCBhbmQgdGhlIGRldGVjdGVkIGZpbGUgZXh0ZW5zaW9uXG5mdW5jdGlvbiBzYW5pdGl6ZUZpbGVJbnB1dChmaWxlLCBhZGRHVUlEKSB7XG4gIHJldHVybiBzYW5pdGl6ZUZpbGVOYW1lKGZpbGUubmFtZSwgISFhZGRHVUlEKTtcbn1cbmZ1bmN0aW9uIG1ha2VVbmlxdWVGaWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBgJHtuYW1lfV8ke2d1aWQoKX1gO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPdmVyd3JpdGVGaWxlTmFtZSh1cGxvYWRlZEZpbGVOYW1lLCBzb3VyY2VGaWxlTmFtZSkge1xuICBsZXQgZmlsZU5hbWUgPSB1cGxvYWRlZEZpbGVOYW1lO1xuICBjb25zdCBwb3NpdGlvbiA9IHVwbG9hZGVkRmlsZU5hbWUubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xuICBpZiAocG9zaXRpb24gPiAtMSkge1xuICAgIGZpbGVOYW1lID0gZmlsZU5hbWUuc3Vic3RyaW5nKHBvc2l0aW9uICsgMSwgZmlsZU5hbWUubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZmlsZU5hbWUucmVwbGFjZSgvXFwgL2csIFwiX1wiKSA9PT0gc291cmNlRmlsZU5hbWUucmVwbGFjZSgvXFwgL2csIFwiX1wiKTtcbn1cbmZ1bmN0aW9uIGdldEl0ZW1JbmZvQnlUeXBlKHR5cGUpIHtcbiAgaWYgKGFkZENyZWF0ZUl0ZW1UeXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBhZGRDcmVhdGVJdGVtVHlwZXNbdHlwZV07XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGFkZENyZWF0ZUl0ZW1UeXBlc1tPYmplY3Qua2V5cyhhZGRDcmVhdGVJdGVtVHlwZXMpLmZpbmQoKGZpbGVUeXBlKSA9PiBhZGRDcmVhdGVJdGVtVHlwZXNbZmlsZVR5cGVdLnR5cGUgPT09IHR5cGUpXTtcbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0RmlsZVNpemUoc2l6ZSkge1xuICBpZiAoIXNpemUpIHtcbiAgICByZXR1cm4gXCIwIEJcIjtcbiAgfVxuICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzaXplKSAvIE1hdGgubG9nKDEwMjQpKTtcbiAgY29uc3QgYWRqdXN0ZWRTaXplID0gTWF0aC5yb3VuZChzaXplIC8gTWF0aC5wb3coMTAyNCwgaSkpO1xuICBjb25zdCB1bml0ID0gW1wiQlwiLCBcIktCXCIsIFwiTUJcIiwgXCJHQlwiLCBcIlRCXCJdW2ldO1xuICByZXR1cm4gYCR7YWRqdXN0ZWRTaXplfSAke3VuaXR9YDtcbn1cblxuZXhwb3J0IHsgc2FuaXRpemVGaWxlTmFtZSBhcyBhLCBmb3JtYXRGaWxlU2l6ZSBhcyBmLCBnZXRJdGVtSW5mb0J5VHlwZSBhcyBnLCBzYW5pdGl6ZUZpbGVJbnB1dCBhcyBzLCB2YWxpZGF0ZU92ZXJ3cml0ZUZpbGVOYW1lIGFzIHYgfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVTdG9yZSB9IGZyb20gJy4vaW5kZXgtODFkNTQ4YjcuanMnO1xuXG5jb25zdCB3b3JrZmxvd1N0b3JlID0gY3JlYXRlU3RvcmUoe1xuICBwb3J0YWw6IG51bGwsXG4gIHVzZXI6IG51bGwsXG4gIGkxOG46IG51bGwsXG4gIHNjYWxlOiBcIm1cIixcbiAgYXBpOiA0LFxuICBuZXh0VGV4dDogbnVsbCxcbiAgdXBsb2FkUHJvZ3Jlc3M6IDBcbn0pO1xuY29uc3Qgd29ya2Zsb3dTdGF0ZSA9IHdvcmtmbG93U3RvcmUuc3RhdGU7XG5cbmV4cG9ydCB7IHdvcmtmbG93U3RhdGUgYXMgdyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9