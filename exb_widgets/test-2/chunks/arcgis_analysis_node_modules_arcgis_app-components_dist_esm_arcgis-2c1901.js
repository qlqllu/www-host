"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-2c1901"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-effects_2.entry.js":
/*!*******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-effects_2.entry.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_effects: () => (/* binding */ ArcgisEffects),
/* harmony export */   arcgis_effects_popovers: () => (/* binding */ ArcgisEffectsPopovers)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonFunctions-5262b094.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-5262b094.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./localStorage-f63100ef.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-f63100ef.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _commonEnums_f98a323c_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./commonEnums-f98a323c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-f98a323c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */









const CSS$1 = {
  flow: "flow",
  panel: "panel",
  notice: "notice",
  hint: "hint",
  basemapType: "basemap-type",
  radioButtons: "radio-buttons",
  switch: "switch",
  list: "list",
  effectThumb: "effect-thumb",
  effectThumbImg: "effect-thumb-img",
  effectCount: "effect-count"
};

/**
 * Returns true if the value is defined
 * @param value - value to check
 */
function isDefined(value) {
  return value !== undefined && value !== null;
}

let allLayerEffectTypes = [
  "bloom",
  "dropShadow",
  "blur",
  "brightnessContrast",
  "grayscale",
  "hueRotate",
  "saturate",
  "invert",
  "sepia"
];
let allLightFeatureEffectTypes = [
  "dropShadow_gray",
  "strongDropShadow",
  "dropShadow_transparency",
  "dropShadow_blur",
  "mutedBlur",
  "mutedGray"
];
let allDarkFeatureEffectTypes = ["bloom_gray", "bloom_blur", "bloom_transparency", "mutedBlur", "mutedGray"];
/* Neutral values :
bloom - (0,0,0)
blur - 0
brightness - 100%
contrast - 100%
dropshadow - 0,0,0,black
grayscale - 0%
hue-rotate - 0
invert - 0%
opacity - 100%
saturate - 100%
sepia - 0%
*/
// all applicable values stored as pt (not px)
const layerEffectDefaults = {
  bloom: { strength: 2, radius: 0.75, threshold: 0.1 },
  dropShadow: {
    line: { color: [0, 0, 0, 255], xoffset: 0.75, yoffset: 0.75, blurRadius: 1.125 },
    point: { color: [0, 0, 0, 255], xoffset: 1.125, yoffset: 1.125, blurRadius: 1.875 },
    polygon: { color: [0, 0, 0, 255], xoffset: 1.125, yoffset: 1.125, blurRadius: 2.25 }
  },
  blur: { radius: 1.5 },
  brightness: { amount: 1.5 },
  contrast: { amount: 2 },
  grayscale: { amount: 1 },
  hueRotate: { angle: 100 },
  saturate: { amount: 1 },
  invert: { amount: 1 },
  sepia: { amount: 0.7 }
};
const lastLayerEffectValues = JSON.parse(JSON.stringify(layerEffectDefaults));
// all applicable values stored as pt (not px)
// Drop Shadow + Gray: dropshadow (2/2/3px RGB 50,50,50) for active, 100% greyscale + 50% transparency for mute
// Strong Drop Shadow: dropshadow (4/4/4px, Hex#000000) for active, nothing on mute
// Drop Shadow + Transparency: dropshadow (2/2/6px, RGB 50,50,50) for active, 65% transparency for mute
// Drop Shadow + Blur: dropshadow (2/2/3px RGB 50,50,50) for active, 3px blur + 50% transparency for mute
// Bloom + Gray: Bloom (1.3/0.75/0) for active, Greyscale 100% + 50% opacity for mute
// Bloom + Blur:: Bloom (1.3/0.75/0) for active, 3px blur + 50% transparency for mute
// Bloom + Transparency: Bloom (1.3/0.75/0) for active, 65% opacity for mute
// Muted Blur: nothing for active, 3px blur + 50% transparency for mute
// Muted Grayscale: nothing for active, 100% greyscale + 50% transparency for mute-
const featureEffectDefaults = {
  dropShadow_gray: {
    included: [{ type: "drop-shadow", color: [50, 50, 50, 255], xoffset: 1.5, yoffset: 1.5, blurRadius: 2.25 }],
    excluded: [
      { type: "grayscale", amount: 1 },
      { type: "opacity", amount: 0.5 }
    ]
  },
  strongDropShadow: {
    included: [{ type: "drop-shadow", color: [0, 0, 0, 255], xoffset: 3, yoffset: 3, blurRadius: 3 }],
    excluded: []
  },
  dropShadow_transparency: {
    included: [{ type: "drop-shadow", color: [50, 50, 50, 255], xoffset: 1.5, yoffset: 1.5, blurRadius: 4.5 }],
    excluded: [{ type: "opacity", amount: 0.35 }]
  },
  dropShadow_blur: {
    included: [{ type: "drop-shadow", color: [50, 50, 50, 255], xoffset: 1.5, yoffset: 1.5, blurRadius: 2.25 }],
    excluded: [
      { type: "blur", radius: 2.25 },
      { type: "opacity", amount: 0.5 }
    ]
  },
  bloom_gray: {
    included: [{ type: "bloom", strength: 1.3, radius: 0.6, threshold: 0 }],
    excluded: [
      { type: "grayscale", amount: 1 },
      { type: "opacity", amount: 0.5 }
    ]
  },
  bloom_blur: {
    included: [{ type: "bloom", strength: 1.3, radius: 0.6, threshold: 0 }],
    excluded: [
      { type: "blur", radius: 2.25 },
      { type: "opacity", amount: 0.5 }
    ]
  },
  bloom_transparency: {
    included: [{ type: "bloom", strength: 1.3, radius: 0.6, threshold: 0 }],
    excluded: [{ type: "opacity", amount: 0.35 }]
  },
  mutedBlur: {
    included: [],
    excluded: [
      { type: "blur", radius: 2.25 },
      { type: "opacity", amount: 0.5 }
    ]
  },
  mutedGray: {
    included: [],
    excluded: [
      { type: "grayscale", amount: 1 },
      { type: "opacity", amount: 0.5 }
    ]
  }
};
function buildEffectsInfo(node, popovers /* HTMLArcgisEffectsPopoversElement[] */, props) {
  const parts = Array.from(node.children)
    .filter((child) => {
    if (child.tagName.toLowerCase() === "calcite-value-list-item") {
      const itemNode = child;
      const switchNode = itemNode.querySelector("calcite-switch");
      return switchNode.checked;
    }
    return false;
  })
    .map((child) => buildEffectInfo(child, popovers, props));
  let effectsString = "";
  let effects;
  let connector = "";
  parts.forEach((part) => {
    if (part && typeof part === "string") {
      if (!effects) {
        effectsString += connector + part;
      }
      else {
        effects.forEach((item) => {
          item.value += connector + part;
        });
      }
    }
    else if (part && typeof part === "object") {
      if (!effects) {
        effects = part;
        effects.forEach((item) => {
          item.value = effectsString + connector + item.value;
        });
      }
      else {
        effects.forEach((item) => {
          Array.from(part)
            .filter((newItem) => item.scale === newItem.scale)
            .forEach((newItem) => (item.value += connector + newItem.value));
        });
      }
    }
    connector = " ";
  });
  if (effects) {
    return effects;
  }
  return effectsString;
}
function parseEffects(props) {
  const { layer, modules, supportsFeatureEffects } = props;
  const anyLayer = layer;
  if (anyLayer.effect && anyLayer.featureEffect) {
    throw new Error("unsupported effect");
  }
  else if (anyLayer.featureEffect && !supportsFeatureEffects) {
    throw new Error("unsupported effect");
  }
  else if (anyLayer.effect) {
    // layer effect
    const effect = anyLayer.effect;
    if (typeof effect === "string") {
      //console.log("EffectJSON", modules.effectsUtils.toJSON(effect));
      return modules.effectsUtils.toJSON(effect);
    }
    else if (effect.length === 3) {
      if (minimalAutoCheckOK(effect)) {
        //console.log("EffectJSON", modules.effectsUtils.toJSON(effect[1].value));
        //console.log("EffectPropertyAPI", modules.effectsUtils.fromJSON(modules.effectsUtils.toJSON(effect[1].value)));
        return modules.effectsUtils.toJSON(effect[1].value);
      }
      else {
        throw new Error("unsupported effect");
      }
    }
    else {
      throw new Error("unsupported effect");
    }
  }
  else if (anyLayer.featureEffect) {
    // feature effect
    const effect = anyLayer.featureEffect;
    if (effect.excludedLabelsVisible &&
      (!effect.includedEffect || typeof effect.includedEffect === "string") &&
      (!effect.excludedEffect || typeof effect.excludedEffect === "string") &&
      (!effect.filter || !effect.filter.geometry)) {
      const included = effect.includedEffect ? modules.effectsUtils.toJSON(effect.includedEffect) : [];
      const excluded = effect.excludedEffect ? modules.effectsUtils.toJSON(effect.excludedEffect) : [];
      //console.log("parsed feature effect - included:", included, "excluded:", excluded, "where:", effect.filter.where);
      let key;
      let effectType;
      for (key in featureEffectDefaults) {
        const defaultJSON = featureEffectDefaults[key];
        if (isSameEffect(defaultJSON.included, included) && isSameEffect(defaultJSON.excluded, excluded)) {
          effectType = key;
          break;
        }
      }
      return effectType;
    }
    else {
      throw new Error("unsupported effect");
    }
  }
  return null;
}
function sortEffects(props) {
  const { effectsJSON } = props;
  if (!effectsJSON) {
    return;
  }
  const usedEffectTypes = effectsJSON.map((effect) => effect.type);
  allLayerEffectTypes.sort((typeA, typeB) => {
    const indexA = usedEffectTypes.indexOf(convertToAPIType(typeA));
    const indexB = usedEffectTypes.indexOf(convertToAPIType(typeB));
    const value = indexA > -1 && indexB > -1 && indexA < indexB
      ? -1
      : indexA > -1 && indexB > -1 && indexA > indexB
        ? 1
        : indexA > -1
          ? -1
          : indexB > -1
            ? 1
            : 0;
    return value;
  });
}
function getEffectProps(type, props) {
  var _a, _b;
  const { effectsJSON } = props;
  const layerEffect = effectsJSON && ((_b = (_a = Array.from(effectsJSON)) === null || _a === void 0 ? void 0 : _a.filter((effect) => effect.type === convertToAPIType(type))) === null || _b === void 0 ? void 0 : _b[0]);
  if (!layerEffect) {
    if (type === "dropShadow") {
      let geometryType = getSimpleGeometryType(props);
      return lastLayerEffectValues[type][geometryType];
    }
    else {
      return lastLayerEffectValues[type];
    }
  }
  return layerEffect;
}
function getSimpleGeometryType(props) {
  const { layer } = props;
  let simpleType = "point";
  const anyLayer = layer;
  if (layer.type === "csv") {
    simpleType = "point";
  }
  else if (anyLayer.geometryType) {
    simpleType =
      anyLayer.geometryType === "polyline"
        ? "line"
        : ["point", "multipoint"].includes(anyLayer.geometryType)
          ? "point"
          : "polygon";
  }
  return simpleType;
}
function convertToAPIType(type) {
  switch (type) {
    case "dropShadow":
      return "drop-shadow";
    case "hueRotate":
      return "hue-rotate";
    case "brightnessContrast":
      return "brightness";
    default:
      return type;
  }
}
function buildFeatureEffect(effectType, where, props) {
  const { modules } = props;
  const { FeatureEffect } = modules;
  const json = featureEffectDefaults[effectType];
  const featureEffect = new FeatureEffect({
    filter: {
      where
    },
    includedEffect: modules.effectsUtils.fromJSON(json.included),
    excludedEffect: modules.effectsUtils.fromJSON(json.excluded),
    excludedLabelsVisible: true
  });
  //console.log("buildFeatureEffect", effectType, featureEffect, json);
  return featureEffect;
}
function minimalAutoCheckOK(effect) {
  // make sure each effect type is mentioned in all 3 or none of the strings
  const strings = [effect[0].value, effect[1].value, effect[2].value];
  return !allLayerEffectTypes.some((type) => {
    if (type === "brightnessContrast") {
      const apiType1 = "brightness";
      const apiType2 = "contrast";
      if (strings[0].indexOf(apiType1) > -1 && strings[0].indexOf(apiType2) > -1) {
        return (strings[1].indexOf(apiType1) === -1 ||
          strings[2].indexOf(apiType1) === -1 ||
          strings[1].indexOf(apiType2) === -1 ||
          strings[2].indexOf(apiType2) === -1);
      }
      else if (strings[0].indexOf(apiType1) === -1 && strings[0].indexOf(apiType2) === -1) {
        return (strings[1].indexOf(apiType1) > -1 ||
          strings[2].indexOf(apiType1) > -1 ||
          strings[1].indexOf(apiType2) > -1 ||
          strings[2].indexOf(apiType2) > -1);
      }
      else {
        return true;
      }
    }
    else {
      const apiType = convertToAPIType(type);
      if (strings[0].indexOf(apiType) > -1) {
        return strings[1].indexOf(apiType) === -1 || strings[2].indexOf(apiType) === -1;
      }
      else {
        return strings[1].indexOf(apiType) > -1 || strings[2].indexOf(apiType) > -1;
      }
    }
  });
}
function isSameEffect(effectA_ /* __esri.EffectJSON[] */, effectB_ /* __esri.EffectJSON[] */) {
  // different order is OK
  // make copies so ordering won't affect the original
  const effectA = JSON.parse(JSON.stringify(effectA_));
  const effectB = JSON.parse(JSON.stringify(effectB_));
  // check length
  if (effectA.length !== effectB.length) {
    return false;
  }
  // sort by type name
  effectA.sort((a, b) => a.type.localeCompare(b.type));
  effectB.sort((a, b) => a.type.localeCompare(b.type));
  // loop through array
  let same = true;
  for (let i = 0; i < effectA.length; i++) {
    const a = effectA[i];
    const b = effectB[i];
    // same number of props?
    if (Object.keys(a).length !== Object.keys(b).length) {
      same = false;
      break;
    }
    // look at each prop
    for (let key in a) {
      if (typeof a[key] === "string" && typeof b[key] === "string" && a[key] === b[key]) {
        continue;
      }
      else if (typeof a[key] === "number" && typeof b[key] === "number" && a[key] === b[key]) {
        continue;
      }
      else if (a[key].length &&
        a[key].length === b[key].length &&
        a[key].every((val, idx) => val === b[key][idx])) {
        continue;
      }
      else {
        same = false;
        break;
      }
    }
    if (!same) {
      break;
    }
  }
  return same;
}
function buildEffectInfo(node, popovers /* HTMLArcgisEffectsPopoversElement[] */, props) {
  const type = node.value;
  switch (type) {
    case "bloom":
      return buildEffectInfoBloom(popovers[type], props);
    case "dropShadow":
      return buildEffectInfoDropShadow(popovers[type], props);
    case "blur":
      return buildEffectInfoBlur(popovers[type], props);
    case "brightnessContrast":
      return buildEffectInfoBrightnessContrast(popovers[type]);
    case "grayscale":
      return buildEffectInfoGrayscale(popovers[type]);
    case "hueRotate":
      return buildEffectInfoHueRotate(popovers[type]);
    case "saturate":
      return buildEffectInfoSaturate(popovers[type]);
    case "invert":
      return buildEffectInfoInvert(popovers[type]);
    case "sepia":
      return buildEffectInfoSepia(popovers[type]);
  }
}
function buildEffectInfoBloom(node /* HTMLArcgisEffectsPopoversElement */, props) {
  // strength, radius, threshold
  // bloom(200%, 1px, 0.2)";
  // bloom(2, 1px, 20%)";
  // bloom(2, 1px, 0.1)
  const numberNodes = node.querySelectorAll("calcite-input");
  let strength = getValue(numberNodes[0]);
  let radius = getValue(numberNodes[1]);
  let threshold = getValue(numberNodes[2]);
  if (!isDefined(strength) || !isDefined(radius) || !isDefined(threshold)) {
    return null;
  }
  strength = Math.round(strength * 10) / 10;
  radius = px2ptRoundTo3(Math.round(radius * 10) / 10, props);
  threshold = Math.round(threshold);
  threshold /= 100;
  lastLayerEffectValues.bloom = { strength, radius, threshold };
  const autoNode = node.querySelector(".auto");
  if (!autoNode.checked) {
    return `bloom(${strength}, ${radius}pt, ${threshold})`;
  }
  else {
    const { view } = props;
    const currentScale = view.scale;
    const factor = 2;
    const invFactor = 1 / factor;
    return [
      {
        // the original values have been doubled after two zoom level in
        scale: currentScale * 0.25,
        value: `bloom(${strength * factor}, ${radius * factor}pt, ${threshold})`
      },
      {
        scale: currentScale,
        value: `bloom(${strength}, ${radius}pt, ${threshold})`
      },
      {
        // the original values have been halved after two zooms level out
        scale: currentScale * 4,
        value: `bloom(${strength * invFactor}, ${radius * invFactor}pt, ${threshold})`
      }
    ];
  }
}
function buildEffectInfoDropShadow(node /* HTMLArcgisEffectsPopoversElement */, props) {
  // x offset, y offset, blur radius (=width) hsl(hue, saturation, lightness, alpha)
  // "drop-shadow(3px, 3px, 4px)"
  const color = node.querySelector("calcite-color-picker");
  const rgb = hexToRgb(color.value);
  const numberNodes = node.querySelectorAll("calcite-input");
  let blurRadius = getValue(numberNodes[0]);
  let xoffset = getValue(numberNodes[1]);
  let yoffset = getValue(numberNodes[2]);
  let opacity = getValue(numberNodes[3]);
  if (!isDefined(color.value) ||
    !isDefined(blurRadius) ||
    !isDefined(xoffset) ||
    !isDefined(yoffset) ||
    !isDefined(opacity)) {
    return null;
  }
  blurRadius = px2ptRoundTo3(Math.round(blurRadius), props);
  xoffset = px2ptRoundTo3(Math.round(xoffset), props);
  yoffset = px2ptRoundTo3(Math.round(yoffset), props);
  opacity = Math.round(opacity);
  opacity /= 100;
  lastLayerEffectValues.dropShadow[getSimpleGeometryType(props)] = {
    color: [rgb.r, rgb.g, rgb.b, opacity * 255],
    xoffset,
    yoffset,
    blurRadius
  };
  //const hsl = hexToHSL(color.value as any);
  //const colorStr = `hsla(${Math.round(hsl.h * 360)}, ${hsl.s * 100}%, ${hsl.l * 100}%, ${opacity})`;
  const colorStr = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
  const autoNode = node.querySelector(".auto");
  if (!autoNode.checked) {
    return `drop-shadow(${xoffset}pt ${yoffset}pt ${blurRadius}pt ${colorStr})`;
  }
  else {
    const { view } = props;
    const currentScale = view.scale;
    const factor = 2;
    const invFactor = 1 / factor;
    return [
      {
        // the original values have been doubled after two zoom level in
        scale: currentScale * 0.25,
        value: `drop-shadow(${xoffset * factor}pt ${yoffset * factor}pt ${blurRadius * factor}pt ${colorStr})`
      },
      {
        scale: currentScale,
        value: `drop-shadow(${xoffset}pt ${yoffset}pt ${blurRadius}pt ${colorStr})`
      },
      {
        // the original values have been halved after two zooms level out
        scale: currentScale * 4,
        value: `drop-shadow(${xoffset * invFactor}pt ${yoffset * invFactor}pt ${blurRadius * invFactor}pt ${colorStr})`
      }
    ];
  }
}
function buildEffectInfoBlur(node /* HTMLArcgisEffectsPopoversElement */, props) {
  // blur(10px)
  const numberNode = node.querySelector("calcite-input");
  let radius = getValue(numberNode);
  if (!isDefined(radius)) {
    return null;
  }
  radius = px2ptRoundTo3(Math.round(radius * 10) / 10, props);
  lastLayerEffectValues.blur = { radius };
  return `blur(${radius}pt)`;
}
function buildEffectInfoBrightnessContrast(node /* HTMLArcgisEffectsPopoversElement */) {
  // brightness(100%) contrast(100%)
  const numberNodes = node.querySelectorAll("calcite-input");
  let brightness = getValue(numberNodes[0]);
  let contrast = getValue(numberNodes[1]);
  if (!isDefined(brightness) || !isDefined(contrast)) {
    return null;
  }
  brightness = Math.round(brightness) / 100;
  contrast = Math.round(contrast) / 100;
  lastLayerEffectValues.brightness = { amount: brightness };
  lastLayerEffectValues.contrast = { amount: contrast };
  return `brightness(${brightness}) contrast(${contrast})`;
}
function buildEffectInfoGrayscale(node /* HTMLArcgisEffectsPopoversElement */) {
  // grayscale(25%)
  const numberNode = node.querySelector("calcite-input");
  let amount = getValue(numberNode);
  if (!isDefined(amount)) {
    return null;
  }
  amount = Math.round(amount) / 100;
  lastLayerEffectValues.grayscale = { amount };
  return `grayscale(${amount})`;
}
function buildEffectInfoHueRotate(node /* HTMLArcgisEffectsPopoversElement */) {
  // hue-rotate(270deg)
  const numberNode = node.querySelector("calcite-input");
  let angle = getValue(numberNode);
  if (!isDefined(angle)) {
    return null;
  }
  angle = Math.round(angle);
  lastLayerEffectValues.hueRotate = { angle };
  return `hue-rotate(${angle}deg)`;
}
function buildEffectInfoSaturate(node /* HTMLArcgisEffectsPopoversElement */) {
  // saturate(100%)
  const numberNode = node.querySelector("calcite-input");
  let amount = getValue(numberNode);
  if (!isDefined(amount)) {
    return null;
  }
  amount = Math.round(amount) / 100;
  lastLayerEffectValues.saturate = { amount };
  return `saturate(${amount})`;
}
function buildEffectInfoInvert(node /* HTMLArcgisEffectsPopoversElement */) {
  // invert(100%)
  const numberNode = node.querySelector("calcite-input");
  let amount = getValue(numberNode);
  if (!isDefined(amount)) {
    return null;
  }
  amount = Math.round(amount) / 100;
  lastLayerEffectValues.invert = { amount };
  return `invert(${amount})`;
}
function buildEffectInfoSepia(node /* HTMLArcgisEffectsPopoversElement */) {
  // sepia(50%)
  const numberNode = node.querySelector("calcite-input");
  let amount = getValue(numberNode);
  if (!isDefined(amount)) {
    return null;
  }
  amount = Math.round(amount) / 100;
  lastLayerEffectValues.sepia = { amount };
  return `sepia(${amount})`;
}
/* function hexToHSL(hex: string): any {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  let r = parseInt(result[1], 16);
  let g = parseInt(result[2], 16);
  let b = parseInt(result[3], 16);
  (r /= 255), (g /= 255), (b /= 255);
  const max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  let h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  const HSL = new Object();
  HSL["h"] = h;
  HSL["s"] = s;
  HSL["l"] = l;
  return HSL;
} */
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    }
    : null;
}
function getValue(node) {
  const value = Number(node.value);
  if (!isDefined(value)) {
    return null;
  }
  const clamped = Math.min(node.max, Math.max(node.min, value));
  // ensure value is within allowed range
  node.value = `${clamped}`;
  return clamped;
}
function px2ptRoundTo3(value, props) {
  const { modules } = props;
  const { screenUtils } = modules;
  return Math.round(screenUtils.px2pt(value) * 1000) / 1000;
}

function getDefaultField(props) {
  var _a, _b, _c, _d, _e;
  const { layer } = props;
  const { renderer } = layer;
  if (!renderer) {
    return null;
  }
  // not looking at Arcade expressions
  switch (renderer.type) {
    case "unique-value": {
      // types, predominance, relationship
      if (((_a = renderer.authoringInfo) === null || _a === void 0 ? void 0 : _a.type) === "predominance") {
        return renderer.uniqueValueInfos[0].value;
      }
      else if (((_b = renderer.authoringInfo) === null || _b === void 0 ? void 0 : _b.type) === "relationship") {
        return renderer.authoringInfo.field1.field;
      }
      else {
        return renderer.field;
      }
    }
    case "class-breaks": {
      // color, size
      if (renderer.visualVariables) {
        let fieldName = (_c = renderer.visualVariables.find((visVar) => visVar.type === "color")) === null || _c === void 0 ? void 0 : _c.field;
        if (fieldName) {
          return fieldName;
        }
        fieldName = (_d = renderer.visualVariables.find((visVar) => visVar.type === "size" && !visVar.target && visVar.valueExpression !== "$view.scale")) === null || _d === void 0 ? void 0 : _d.field;
        if (fieldName) {
          return fieldName;
        }
      }
      else {
        return renderer.field;
      }
      break;
    }
    case "dot-density":
      return (_e = renderer.attributes) === null || _e === void 0 ? void 0 : _e[0].field;
  }
  return null;
}

const arcgisEffectsCss = ":host{height:100%}.flow{height:100%}.panel{height:100%}.notice{margin:0.5rem}.radio-buttons{padding:0.5rem;background-color:white}.hint{padding:0.25rem 0.5rem;background-color:white}.basemap-type{padding:0.75rem 0.5rem 0.25rem 0.5rem}.switch{margin-right:0.75rem;margin-left:0;align-self:center}.list{flex-flow:column nowrap;margin:1px}.effect-thumb{display:flex;align-items:center;padding-left:0.5rem;cursor:pointer}.effect-thumb-img{margin-top:0.25rem;margin-bottom:0.25rem;height:48px;width:48px}.arcgis--rtl .switch{margin-left:0.75rem;margin-right:0}.arcgis--rtl .effect-thumb{padding-left:0;padding-right:0.5rem}";

const ArcgisEffects = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisEffectsClose = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsClose", 7);
    this.arcgisEffectsChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsChange", 7);
    this.arcgisEffectsApplyLayerEffect = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsApplyLayerEffect", 7);
    this.popovers = [];
    this.imagesPath = "../arcgis-app-assets/images/effects/test.jpg";
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    this.afterCreatePanel = (node) => {
      this.panelNode = node;
      const { props } = this;
      const { featureEffectType, supportsFeatureEffects } = props;
      // open all popovers so we have access to all current props
      // feature effects all share one popover
      const { popovers, panelNode } = this;
      if (popovers) {
        // remove them
        this.done();
      }
      // wait until panelNode has dimensions
      setTimeout(() => {
        let allTypes = supportsFeatureEffects
          ? allLayerEffectTypes.concat(["featureEffect"])
          : allLayerEffectTypes;
        allTypes.forEach((type) => {
          popovers[type] = document.createElement(`arcgis-effects-popovers`);
          popovers[type].props = props;
          popovers[type].type = type;
          popovers[type].referenceElement = panelNode;
          popovers[type].popovers = popovers;
          document.body.appendChild(popovers[type]);
        });
        if (featureEffectType) {
          // we're starting with a set feature effect
          const popover = popovers["featureEffect"];
          popover.open = true;
          popover.updateHeader(featureEffectType);
        }
      }, 1000);
    };
    this.onSwitchEffectType = (event) => {
      const { props, popovers } = this;
      const layer = props.layer;
      const node = event.target;
      // close all popovers
      let key;
      for (key in popovers) {
        popovers[key].open = false;
      }
      if (node.selectedItem.value === "layer") {
        this.lastFeatureEffect = layer.featureEffect || this.lastFeatureEffect;
        layer.featureEffect = null;
        layer.effect = this.lastLayerEffect;
        this.showFeatureEffects = false;
      }
      else {
        // "feature"
        this.lastLayerEffect = layer.effect;
        layer.effect = null;
        if (this.lastFeatureEffect) {
          layer.featureEffect = this.lastFeatureEffect;
          props.featureEffectType = parseEffects(props);
        }
        else {
          const { backgroundTheme } = props;
          this.selectFeatureEffectType(backgroundTheme === "light" ? allLightFeatureEffectTypes[0] : allDarkFeatureEffectTypes[0]);
        }
        this.showFeatureEffects = true;
        const popover = popovers["featureEffect"];
        popover.open = true;
        popover.updateHeader(props.featureEffectType);
      }
      this.reRender = !this.reRender;
    };
    this.onRemoveEffect = () => {
      const { props } = this;
      const { layer } = props;
      layer.effect = null;
      layer.featureEffect = null;
      this.isUnsupported = false;
    };
    this.onSwitchChange = (event) => {
      const { popovers } = this;
      const switchNode = event.target;
      const itemNode = (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_3__.q)(switchNode, "calcite-value-list-item");
      const type = itemNode.value;
      if (!switchNode.checked) {
        popovers[type].open = false;
        itemNode.selected = false;
      }
      this.arcgisEffectsApplyLayerEffect.emit({ type, keepSwitch: true });
    };
    this.onFeatureEffectEnabledSwitchChange = (event) => {
      const { popovers, props, lightListNode, darkListNode } = this;
      const layer = props.layer;
      const switchNode = event.target;
      if (!switchNode.checked) {
        popovers["featureEffect"].open = false;
        lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => (item.selected = false));
        darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => (item.selected = false));
        this.lastFeatureEffect = layer.featureEffect;
        layer.featureEffect = null;
        this.arcgisEffectsChange.emit();
      }
      else {
        if (this.lastFeatureEffect) {
          layer.featureEffect = this.lastFeatureEffect;
          props.featureEffectType = parseEffects(props);
        }
        else {
          const { backgroundTheme } = props;
          props.featureEffectType =
            backgroundTheme === "light"
              ? allLightFeatureEffectTypes[0]
              : allDarkFeatureEffectTypes[0];
        }
        lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
          if (item.value === props.featureEffectType) {
            item.selected = true;
          }
        });
        darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
          if (item.value === props.featureEffectType) {
            item.selected = true;
          }
        });
        this.selectFeatureEffectType(props.featureEffectType);
      }
    };
    this.openPopover = (event) => {
      const { popovers } = this;
      const target = event.target;
      const tagName = target.tagName.toLowerCase();
      let itemNode;
      if (tagName === "img") {
        itemNode = (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_3__.q)(target, "calcite-value-list-item");
      }
      else if (tagName === "calcite-switch") {
        if (target.checked) {
          itemNode = (0,_commonFunctions_5262b094_js__WEBPACK_IMPORTED_MODULE_3__.q)(target, "calcite-value-list-item");
        }
        else {
          return;
        }
      }
      else if (tagName === "calcite-value-list-item") {
        itemNode = target;
      }
      else {
        return;
      }
      itemNode.selected = true;
      const type = itemNode.value;
      const isFeatureEffectType = allLightFeatureEffectTypes.concat(allDarkFeatureEffectTypes).indexOf(type) > -1;
      if (isFeatureEffectType) {
        this.selectFeatureEffectType(type);
      }
      else {
        // layer effects
        const switchNode = itemNode.querySelector("calcite-switch");
        if (popovers[type].open) {
          // if already open then close popover and toggle off
          popovers[type].open = false;
          switchNode.checked = false;
          itemNode.selected = false;
          this.arcgisEffectsApplyLayerEffect.emit();
        }
        else {
          // switch effect on
          if (!switchNode.checked) {
            switchNode.checked = true;
            this.arcgisEffectsApplyLayerEffect.emit();
          }
          // close other popovers
          let key;
          for (key in popovers) {
            popovers[key].open = false;
          }
          popovers[type].open = true;
        }
      }
    };
    this.view = undefined;
    this.layer = undefined;
    this.hideLayerTitle = false;
    this.props = undefined;
    this.reRender = false;
    this.isUnsupported = false;
    this.showFeatureEffects = false;
  }
  arcgisEffectsApplyLayerEffectHandler(event) {
    var _a, _b;
    const { props, listNode } = this;
    const { layer } = props;
    const type = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.type;
    if (type && !((_b = event.detail) === null || _b === void 0 ? void 0 : _b.keepSwitch)) {
      // toggle effect on if it's not already
      const itemNode = Array.from(listNode.querySelectorAll("calcite-value-list-item")).filter((item) => item.value === type)[0];
      itemNode.querySelector("calcite-switch").checked = true;
    }
    const effects = buildEffectsInfo(this.listNode, this.popovers, props);
    layer.effect = effects;
    this.arcgisEffectsChange.emit();
    props.effectsJSON = parseEffects(props);
    // refresh to get the numbers
    //this.reRender = !this.reRender;
  }
  arcgisEffectsPopoverFilterChangeHandler(event) {
    const { props, hostElement } = this;
    const { layer } = props;
    const where = event.detail;
    const itemNode = Array.from(hostElement.shadowRoot.querySelectorAll("calcite-value-list-item")).find((node) => node.selected);
    const type = itemNode === null || itemNode === void 0 ? void 0 : itemNode.value;
    if (!type) {
      // we're too early, but need to apply the filter later once a type gets selected
      this.defaultWhere = where;
    }
    else {
      // a feature effect type is selected
      layer.featureEffect = buildFeatureEffect(type, where, props);
      this.arcgisEffectsChange.emit();
    }
  }
  arcgisEffectsPopoverCloseHandler() {
    const { listNode, lightListNode, darkListNode } = this;
    listNode === null || listNode === void 0 ? void 0 : listNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
      if (item.selected) {
        item.selected = false;
        item.setFocus();
      }
    });
    lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
      if (item.selected) {
        item.setFocus();
      }
    });
    darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
      if (item.selected) {
        item.setFocus();
      }
    });
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Set focus on component
   */
  async setFocus(focusId) {
    var _a, _b;
    if (!focusId || focusId === "dismiss-button") {
      (_a = this.panelNode) === null || _a === void 0 ? void 0 : _a.setFocus();
      return;
    }
    (_b = this.listNode) === null || _b === void 0 ? void 0 : _b.setFocus();
  }
  /**
   * Cleans up component, closes popovers
   */
  async done() {
    const { popovers } = this;
    // close  popovers
    let key;
    for (key in popovers) {
      popovers[key].open = false;
    }
    document.body
      .querySelectorAll("arcgis-effects-popovers")
      .forEach((node) => node.parentNode.removeChild(node));
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    const { view, layer } = this;
    const [strings, currentLanguage] = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement);
    this.strings = strings;
    const supportsFeatureEffects = !layer.featureReduction &&
      ["feature", "geojson", "ogc-feature", "wfs", "csv", "stream"].indexOf(layer.type) > -1;
    this.props = { view, layer, strings, supportsFeatureEffects };
    const { props } = this;
    props.locale = currentLanguage;
    const [FeatureEffect, effectsUtils, screenUtils, colorUtils] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_4__.l)([
      "esri/layers/support/FeatureEffect",
      "esri/layers/effects/jsonUtils",
      "esri/core/screenUtils",
      "esri/views/support/colorUtils"
    ]);
    props.modules = { FeatureEffect, effectsUtils, screenUtils };
    props.backgroundTheme = view && (await colorUtils.getBackgroundColorTheme(view));
    try {
      const anyLayer = layer;
      if (anyLayer.effect && anyLayer.featureEffect) {
        this.isUnsupported = true;
      }
      else if (anyLayer.effect) {
        props.effectsJSON = parseEffects(props);
        //console.log("layer.effect", (layer as any).effect, props.effectsJSON);
        sortEffects(props);
      }
      else if (anyLayer.featureEffect) {
        props.featureEffectType = parseEffects(props);
      }
    }
    catch (e) {
      this.isUnsupported = true;
    }
  }
  componentDidLoad() {
    requestAnimationFrame(() => this.setFocus());
  }
  disconnectedCallback() {
    this.done();
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    // filter (9.4) only for these layer types (not heatmap): __esri.FeatureLayer | __esri.CSVLayer | __esri.WFSLayer | __esri.StreamLayer
    const { isUnsupported } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-flow", { class: CSS$1.flow, dir: (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement), ref: (node) => (this.flowNode = node) }, isUnsupported ? this.renderUnsupported() : this.renderContent())));
  }
  renderUnsupported() {
    const { props, hideLayerTitle } = this;
    const { layer, strings } = props;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { heading: strings.general.effects, description: !hideLayerTitle ? layer.title : undefined, class: {
        [CSS$1.panel]: true,
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.C.rtl]: rtl
      }, closable: true, onCalcitePanelClose: () => {
        this.arcgisEffectsClose.emit();
      }, ref: (node) => (this.panelNode = node) }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tip", { heading: strings.error.title, closeDisabled: true }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, strings.error.text1), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, strings.error.text2)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-fab", { class: "autofocus", slot: "fab", appearance: "outline-fill", kind: "neutral", scale: "s", textEnabled: true, icon: null, label: strings.error.button, text: strings.error.button, onClick: this.onRemoveEffect })));
  }
  renderContent() {
    const { props, hideLayerTitle, showFeatureEffects } = this;
    const { layer, supportsFeatureEffects, strings } = props;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
    const hasFeatureEffect = supportsFeatureEffects && !!layer.featureEffect;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { heading: strings.general.effects, description: !hideLayerTitle ? layer.title : undefined, class: {
        [CSS$1.panel]: true,
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.C.rtl]: rtl
      }, closable: true, onCalcitePanelClose: () => {
        // close all popovers
        const { popovers } = this;
        let key;
        for (key in popovers) {
          popovers[key].open = false;
        }
        this.arcgisEffectsClose.emit();
      }, ref: this.afterCreatePanel }, this.renderTip(), supportsFeatureEffects ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.radioButtons }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control", { layout: "horizontal", appearance: "solid", scale: "s", width: "full", onCalciteSegmentedControlChange: this.onSwitchEffectType }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "layer", checked: !(hasFeatureEffect || showFeatureEffects) }, strings.general.wholeLayer), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-segmented-control-item", { value: "feature", checked: hasFeatureEffect || showFeatureEffects }, strings.general.featureSpecific)))) : null, hasFeatureEffect || showFeatureEffects
      ? this.renderFeatureEffectsContent()
      : this.renderLayerEffectsContent()));
  }
  renderTip() {
    const { props } = this;
    const { strings } = props;
    if ((0,_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_5__.g)(_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_5__.l.ARCGIS_COMPONENT_NOTIFICATIONS, _localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_5__.a.EFFECTS_TIP_DISMISSED)) {
      return null;
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.notice }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { scale: "s", width: "full", open: true, closable: true, onCalciteNoticeClose: () => {
        (0,_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_5__.s)(_localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_5__.l.ARCGIS_COMPONENT_NOTIFICATIONS, {
          key: _localStorage_f63100ef_js__WEBPACK_IMPORTED_MODULE_5__.a.EFFECTS_TIP_DISMISSED,
          value: "true"
        });
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, strings.general.notice))));
  }
  renderLayerEffectsContent() {
    const { strings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.hint }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.dragToReorder)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { class: CSS$1.list, dragEnabled: true, onCalciteListOrderChange: () => this.arcgisEffectsApplyLayerEffect.emit(), ref: (node) => (this.listNode = node) }, allLayerEffectTypes.map((type) => this.renderLayerEffectItem(type)))));
  }
  renderLayerEffectItem(type) {
    var _a;
    const { props } = this;
    const { effectsJSON, strings } = props;
    let effectPos = -1;
    effectsJSON &&
      ((_a = Array.from(effectsJSON)) === null || _a === void 0 ? void 0 : _a.forEach((effect, idx) => {
        if (effect.type === convertToAPIType(type)) {
          effectPos = idx + 1;
        }
      }));
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list-item", { label: strings.effectsTitle[type], description: strings.effectsSummary[type], value: type, onClick: this.openPopover, onKeyDown: (event) => {
        if (event.key === "Enter") {
          this.openPopover(event);
        }
        // space key is reserved for drag-n-drop
        if (event.key === " ") {
          const composedPath = event.composedPath();
          const firstElement = composedPath[0];
          if (firstElement.tagName !== "SPAN" || !firstElement.classList.contains("handle")) {
            this.openPopover(event);
          }
        }
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "actions-start", class: CSS$1.effectThumb }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { class: CSS$1.effectThumbImg,
      //class={`${CSS.effectThumbImg} ${effectPos > 0 ? `blur` : ``}`}
      src: (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/effect-thumbs/${type}.png`), alt: "" })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { scale: "s", checked: effectPos > 0, slot: "actions-end", class: CSS$1.switch, onCalciteSwitchChange: this.onSwitchChange })));
  }
  renderFeatureEffectsContent() {
    const { props, lastFeatureEffect, strings } = this;
    const { layer, backgroundTheme } = props;
    const isLightBackground = backgroundTheme === "light";
    const lightContent = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.basemapType }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.lightBasemaps)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { class: CSS$1.list, "data-value": "light", ref: (node) => (this.lightListNode = node) }, allLightFeatureEffectTypes.map((type) => this.renderFeatureEffectItem(type, "light")))));
    const darkContent = ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.basemapType }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.darkBasemaps)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list", { class: CSS$1.list, "data-value": "dark", ref: (node) => (this.darkListNode = node) }, allDarkFeatureEffectTypes.map((type) => this.renderFeatureEffectItem(type, "dark")))));
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$1.hint }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.general.emphasize), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", layout: "inline-space-between" }, strings.general.enabled, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { scale: "s", checked: !!(layer.featureEffect || lastFeatureEffect), onCalciteSwitchChange: this.onFeatureEffectEnabledSwitchChange, ref: (node) => (this.enabledSwitchNode = node) }))), isLightBackground ? lightContent : darkContent, isLightBackground ? darkContent : lightContent));
  }
  renderFeatureEffectItem(type, theme) {
    const { props } = this;
    const { featureEffectType, strings } = props;
    const inLight = allLightFeatureEffectTypes.find((feType) => type === feType);
    const inDark = allDarkFeatureEffectTypes.find((feType) => type === feType);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-value-list-item", { label: strings.featureEffectsTitle[type], description: strings.featureEffectsSummary[type], value: type, selected: featureEffectType === type, onClick: this.openPopover, onKeyDown: (event) => {
        if (event.key === "Enter") {
          this.openPopover(event);
        }
        // space key is reserved for drag-n-drop
        if (event.key === " ") {
          const composedPath = event.composedPath();
          const firstElement = composedPath[0];
          if (firstElement.tagName !== "SPAN" || !firstElement.classList.contains("handle")) {
            this.openPopover(event);
          }
        }
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "actions-start", class: CSS$1.effectThumb }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("img", { class: `${CSS$1.effectThumbImg} feature`, src: (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/effect-thumbs/${type}${inLight && inDark ? `_${theme}` : ``}.png`), alt: "" }))));
  }
  selectFeatureEffectType(type) {
    var _a, _b;
    const { popovers, props, lightListNode, darkListNode, defaultWhere, enabledSwitchNode } = this;
    const { layer } = props;
    props.featureEffectType = type;
    // unselect item from second list
    lightListNode === null || lightListNode === void 0 ? void 0 : lightListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
      if (item.selected && item.value !== type) {
        item.selected = false;
      }
    });
    darkListNode === null || darkListNode === void 0 ? void 0 : darkListNode.querySelectorAll("calcite-value-list-item").forEach((item) => {
      if (item.selected && item.value !== type) {
        item.selected = false;
      }
    });
    // feature effects
    layer.featureEffect = buildFeatureEffect(type, ((_b = (_a = layer.featureEffect) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.where) || defaultWhere, props);
    this.defaultWhere = undefined;
    this.arcgisEffectsChange.emit();
    const popover = popovers["featureEffect"];
    if (popover.open) {
      // if already open then just rename title
      popover.updateHeader(type);
    }
    else {
      // close other popovers
      let key;
      for (key in popovers) {
        popovers[key].open = false;
      }
      popover.open = true;
      popover.updateHeader(type);
    }
    if (enabledSwitchNode) {
      // after a list click
      enabledSwitchNode.checked = true;
    }
    else {
      // after a layer effect -> feature effect switch
      this.reRender = !this.reRender;
    }
  }
  static get assetsDirs() { return ["assets"]; }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisEffects.style = arcgisEffectsCss;

const CSS = {
  popover: "popover",
  panel: "panel",
  auto: "auto",
  content: "effects-content",
  bottomSpace: "bottom-space",
  bottomSpaceLittle: "bottom-space-little",
  switch: "switch",
  reset: "reset",
  subHeader: "sub-header"
};

const SelectCSS$1 = {
  base: "select-number",
  input: "select-number__input"
};
const stepperClickHandlerForProperFocus$1 = (event) => {
  // workaround for calcite-label wrapped SelectNumber focus bug
  event.stopPropagation();
};
const calciteLabelClickHandlerForProperFocus = (event) => {
  var _a, _b;
  // workaround for calcite-label wrapped SelectNumber focus bug
  (_b = (_a = event.target).setFocus) === null || _b === void 0 ? void 0 : _b.call(_a);
  event.preventDefault();
};
const SelectNumber = (props) => {
  const { disabled, min, max, step, value, units, classNames, label } = props;
  return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${SelectCSS$1.base} ${classNames}` },
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-slider", { disabled: disabled, min: min, max: max, value: value, step: step, snap: true, labelTicks: true, ticks: max - min, minLabel: label, onCalciteSliderInput: (event) => applyValueOnChange$1(event, props) }),
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { type: "number", onClick: stepperClickHandlerForProperFocus$1, disabled: disabled, min: min, max: max, value: `${value}`, scale: "s", step: step, suffixText: units, onCalciteInputInput: (event) => applyValueOnChange$1(event, props), class: SelectCSS$1.input, label: label })));
};
function applyValueOnChange$1(event, props) {
  const { locale } = props;
  const node = event.currentTarget;
  const sliderNode = node.parentElement.querySelector("calcite-slider");
  const inputNode = node.parentElement.querySelector("calcite-input");
  const value = Number(node.value);
  const clamped = Math.min(props.max, Math.max(props.min, value));
  if (clamped === sliderNode.value && `${clamped}` === inputNode.value) {
    // no changes
    return;
  }
  // ensure value we show is within allowed range
  sliderNode.value = clamped;
  inputNode.value = `${clamped}`;
  // TODO workaround for https://github.com/Esri/calcite-components/issues/3003
  const clampedString = clamped.toLocaleString(locale);
  inputNode
    .querySelectorAll("input")
    .forEach((input) => (input.value = clampedString));
  props.onValueChange(clamped, node);
}

const SelectCSS = {
  base: "select-xy",
  input: "select-xy__input"
};
const stepperClickHandlerForProperFocus = (event) => {
  // workaround for calcite-label wrapped SelectXy focus bug
  event.stopPropagation();
};
const SelectXy = (props) => {
  const { min, max, step, x, y, classNames, strings, locale } = props;
  let hostNode;
  return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `${SelectCSS.base} ${classNames}`, ref: (node) => (hostNode = node) },
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-xy-slider", { "data-value": "slider", minX: min, maxX: max, minY: min, maxY: max, x: x, y: y, step: step, snappable: true, onArcgisXYSliderInput: (event) => {
        const slider = event.currentTarget;
        const emittingActiveFlagAttribute = "data-active";
        // we ignore the first event since it's caused by the
        // value snapping to a step interval during initialization
        if (!slider.hasAttribute(emittingActiveFlagAttribute)) {
          slider.setAttribute(emittingActiveFlagAttribute, "");
          return;
        }
        applyValueOnChange(event, props, hostNode);
      } }),
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null,
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" },
        strings.effectsProps.xOffset,
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { "data-value": "x", type: "number", min: min, max: max, step: step, lang: locale, value: `${x}`, class: SelectCSS.input, scale: "s", onClick: stepperClickHandlerForProperFocus, onCalciteInputInput: (event) => applyValueOnChange(event, props, hostNode) })),
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" },
        strings.effectsProps.yOffset,
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { "data-value": "y", type: "number", min: min, max: max, step: step, lang: locale, value: `${y}`, class: SelectCSS.input, scale: "s", onClick: stepperClickHandlerForProperFocus, onCalciteInputInput: (event) => applyValueOnChange(event, props, hostNode) })))));
};
function applyValueOnChange(event, props, hostNode) {
  const { step, locale } = props;
  const node = event.currentTarget;
  const dataValue = node.getAttribute("data-value");
  const sliderNode = hostNode.querySelector("arcgis-xy-slider");
  const inputNodes = hostNode.querySelectorAll("calcite-input");
  const origValueX = Number(dataValue === "slider"
    ? node.x
    : dataValue === "x"
      ? node.value
      : inputNodes[0].value);
  const origValueY = Number(dataValue === "slider"
    ? node.y
    : dataValue === "y"
      ? node.value
      : inputNodes[1].value);
  // make sure we don't get more precision than step
  // slider returns values like 1.9000000000000001 (#2928)
  const decimalsCount = countDecimalDigits(step);
  const factor = Math.pow(10, decimalsCount);
  const x = Math.round(origValueX * factor) / factor;
  const y = Math.round(origValueY * factor) / factor;
  const xClamped = Math.min(props.max, Math.max(props.min, x));
  const yClamped = Math.min(props.max, Math.max(props.min, y));
  if (xClamped === sliderNode.x &&
    `${xClamped}` === inputNodes[0].value &&
    yClamped === sliderNode.y &&
    `${yClamped}` === inputNodes[1].value) {
    // no changes
    return;
  }
  // ensure value we show is within allowed range
  sliderNode.x = xClamped;
  sliderNode.y = yClamped;
  inputNodes[0].value = `${xClamped}`;
  inputNodes[1].value = `${yClamped}`;
  // TODO workaround for https://github.com/Esri/calcite-components/issues/3003
  const xClampedString = xClamped.toLocaleString(locale);
  const yClampedString = yClamped.toLocaleString(locale);
  inputNodes[0]
    .querySelectorAll("input")
    .forEach((input) => (input.value = xClampedString));
  inputNodes[1]
    .querySelectorAll("input")
    .forEach((input) => (input.value = yClampedString));
  props.onValueChange(xClamped, yClamped, node);
}
function countDecimalDigits(number) {
  if (number === null || number === undefined) {
    return 0;
  }
  const char_array = number.toString().split(""); // split every single char
  const not_decimal = char_array.lastIndexOf(".");
  return not_decimal < 0 ? 0 : char_array.length - not_decimal;
}

const arcgisEffectsPopoversCss = ".select-number.sc-arcgis-effects-popovers{display:flex;align-items:center;justify-content:space-between;position:relative}.select-number.sc-arcgis-effects-popovers calcite-slider.sc-arcgis-effects-popovers{width:58%;height:30px;margin:0 4px;overflow-wrap:normal;word-break:normal}.select-number__input.sc-arcgis-effects-popovers{width:35%;font-size:var(--arcgis-app-font-size-0);font-family:var(--arcgis-app-font-family)}.select-xy.sc-arcgis-effects-popovers{display:flex;align-items:center}.select-xy.sc-arcgis-effects-popovers arcgis-xy-slider.sc-arcgis-effects-popovers{width:120px;min-width:120px;margin:0 10px}.select-xy__input.sc-arcgis-effects-popovers{width:100%;font-size:var(--arcgis-app-font-size-0);font-family:var(--arcgis-app-font-family)}.popover.sc-arcgis-effects-popovers{z-index:99}.panel.sc-arcgis-effects-popovers{width:325px}.panel.filter.sc-arcgis-effects-popovers{min-height:500px;background-color:var(--calcite-ui-background)}.effects-content.sc-arcgis-effects-popovers{padding:1rem;background-color:white;max-height:80vh}.bottom-space.sc-arcgis-effects-popovers{margin-bottom:1.5rem}.bottom-space-little.sc-arcgis-effects-popovers{margin-bottom:0.5rem}.switch.sc-arcgis-effects-popovers{width:100%;display:flex;justify-content:space-between}.reset.sc-arcgis-effects-popovers{display:flex;align-items:center}.sub-header.sc-arcgis-effects-popovers{margin-left:0.75rem;margin-right:0}.arcgis--rtl.sc-arcgis-effects-popovers .sub-header.sc-arcgis-effects-popovers{margin-right:0.75rem;margin-left:0}";

const ArcgisEffectsPopovers = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisEffectsApplyLayerEffect = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsApplyLayerEffect", 7);
    this.arcgisEffectsPopoverFilterChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsPopoverFilterChange", 7);
    this.arcgisEffectsPopoverClose = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisEffectsPopoverClose", 7);
    //--------------------------------------------------------------------------
    //
    //  Private Properties
    //
    //--------------------------------------------------------------------------
    this.defaultExpression = false;
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    this.onOpen = () => {
      setTimeout(() => requestAnimationFrame(() => { var _a; return (_a = this.closeNode) === null || _a === void 0 ? void 0 : _a.setFocus(); }), 1);
    };
    this.onClose = () => {
      var _a;
      (_a = this.filterNode) === null || _a === void 0 ? void 0 : _a.closePopovers();
    };
    this.onPropChange = () => {
      const { type } = this;
      this.arcgisEffectsApplyLayerEffect.emit({ type });
    };
    this.onReset = () => {
      const { type, props, popoverNode } = this;
      const { modules } = props;
      const { screenUtils } = modules;
      const defaults = layerEffectDefaults[type];
      switch (type) {
        case "bloom": {
          const inputs = popoverNode.querySelectorAll("calcite-input");
          inputs[0].value = `${defaults.strength}`;
          inputs[1].value = `${screenUtils.pt2px(defaults.radius)}`;
          inputs[2].value = `${Math.round(defaults.threshold * 100)}`;
          const sliders = popoverNode.querySelectorAll("calcite-slider");
          sliders[0].value = defaults.strength;
          sliders[1].value = screenUtils.pt2px(defaults.radius);
          sliders[2].value = Math.round(defaults.threshold * 100);
          break;
        }
        case "dropShadow": {
          let geometryType = getSimpleGeometryType(props);
          const colorPicker = popoverNode.querySelector("calcite-color-picker");
          colorPicker.value = `${this.rgb2Hex(defaults[geometryType].color)}`;
          const inputs = popoverNode.querySelectorAll("calcite-input");
          inputs[0].value = `${Math.round(screenUtils.pt2px(defaults[geometryType].blurRadius))}`;
          inputs[1].value = `${Math.round(screenUtils.pt2px(defaults[geometryType].xoffset))}`;
          inputs[2].value = `${Math.round(screenUtils.pt2px(defaults[geometryType].yoffset))}`;
          inputs[3].value = `${(defaults[geometryType].color[3] / 255) * 100}`;
          const sliders = popoverNode.querySelectorAll("calcite-slider");
          sliders[0].value = Math.round(screenUtils.pt2px(defaults[geometryType].blurRadius));
          sliders[1].value = (defaults[geometryType].color[3] / 255) * 100;
          const xySliders = popoverNode.querySelectorAll("arcgis-xy-slider");
          xySliders[0].x = Math.round(screenUtils.pt2px(defaults[geometryType].xoffset));
          xySliders[0].y = Math.round(screenUtils.pt2px(defaults[geometryType].yoffset));
          break;
        }
        case "blur": {
          popoverNode.querySelector("calcite-input").value = `${screenUtils.pt2px(defaults.radius)}`;
          popoverNode.querySelector("calcite-slider").value = screenUtils.pt2px(defaults.radius);
          break;
        }
        case "brightnessContrast": {
          const defaultsBrightness = layerEffectDefaults["brightness"];
          const defaultsContrast = layerEffectDefaults["contrast"];
          const inputs = popoverNode.querySelectorAll("calcite-input");
          inputs[0].value = `${Math.round(defaultsBrightness.amount * 100)}`;
          inputs[1].value = `${Math.round(defaultsContrast.amount * 100)}`;
          const sliders = popoverNode.querySelectorAll("calcite-slider");
          sliders[0].value = Math.round(defaultsBrightness.amount * 100);
          sliders[1].value = Math.round(defaultsContrast.amount * 100);
          break;
        }
        case "grayscale": {
          popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
          popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
          break;
        }
        case "hueRotate": {
          popoverNode.querySelector("calcite-input").value = `${defaults.angle}`;
          popoverNode.querySelector("calcite-slider").value = defaults.angle;
          break;
        }
        case "saturate": {
          popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
          popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
          break;
        }
        case "invert": {
          popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
          popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
          break;
        }
        case "sepia": {
          popoverNode.querySelector("calcite-input").value = `${defaults.amount * 100}`;
          popoverNode.querySelector("calcite-slider").value = defaults.amount * 100;
          break;
        }
      }
      this.arcgisEffectsApplyLayerEffect.emit({ type });
    };
    this.props = undefined;
    this.type = undefined;
    this.open = false;
    this.referenceElement = undefined;
    this.popovers = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  public calls
  //
  //--------------------------------------------------------------------------
  async reposition() {
    var _a;
    (_a = this.popoverNode) === null || _a === void 0 ? void 0 : _a.reposition();
  }
  async updateHeader(type) {
    const { props, filterNode } = this;
    const { strings } = props;
    if (filterNode) {
      // close field-pick-list
      filterNode.closePopovers();
      filterNode.panelHeading = strings.featureEffectsTitle[type] || strings.effectsTitle[type];
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    const { props } = this;
    const { layer } = props;
    if (!layer.featureEffect) {
      // don't start with empty filter, if possible
      this.defaultExpression = true;
    }
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { props, referenceElement, type, open } = this;
    const { strings } = props;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
    const isLongPopover = ["featureEffect", "dropShadow"].indexOf(type) > -1;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "js-app-flyout" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-popover", { dir: (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement), pointerDisabled: true, label: strings.effectsTitle[type], offsetDistance: 10, offsetSkidding: isLongPopover ? 10 : 100, open: open, placement: "leading-start", triggerDisabled: true, class: {
        "arcgis-effects-popover": true,
        popover: true,
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.C.rtl]: rtl
      }, referenceElement: referenceElement, onCalcitePopoverOpen: this.onOpen, onCalcitePopoverClose: this.onClose, ref: (node) => {
        this.popoverNode = node;
        //", popovers[type], node);
        //popovers[type] = node;
      } }, type === "featureEffect"
      ? this.renderFeatureEffectProps()
      : this.renderLayerEffectProps())));
  }
  renderLayerEffectProps() {
    const { props, referenceElement, type } = this;
    const { strings } = props;
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement) === "rtl";
    const panelRect = referenceElement.getBoundingClientRect();
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { closable: false, heading: strings.effectsTitle[type], class: CSS.panel, style: {
        maxHeight: `${panelRect.height * 0.9}px`
      }, ref: (node) => (this.panelNode = node) }, [
      "bloom",
      "dropShadow",
      "blur",
      "brightnessContrast",
      "grayscale",
      "hueRotate",
      "saturate",
      "invert",
      "sepia"
    ].indexOf(type) > -1 ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.effectsProps.reset, scale: "s", slot: "header-actions-end", title: strings.effectsProps.reset, onClick: this.onReset }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { scale: "s", icon: rtl ? "redo" : "undo" }))) : null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { text: strings.general.close, icon: "x", slot: "header-actions-end", title: strings.general.close, ref: (node) => (this.closeNode = node), onClick: () => {
        this.arcgisEffectsPopoverClose.emit();
        this.open = false;
        this.popoverNode.open = false;
        this.panelNode.closed = false;
      } }), type === "bloom" ? this.renderBloom() : null, type === "dropShadow" ? this.renderDropShadow() : null, type === "blur" ? this.renderBlur() : null, type === "brightnessContrast" ? this.renderBrightnessContrast() : null, type === "grayscale" ? this.renderGrayscale() : null, type === "hueRotate" ? this.renderHueRotate() : null, type === "saturate" ? this.renderSaturate() : null, type === "invert" ? this.renderInvert() : null, type === "sepia" ? this.renderSepia() : null));
  }
  renderBloom() {
    // "Bloom": `bloom(2,1px,0.1)`,
    // Strength (0-5) - step 0.1
    // Radius (0-5) - step 0.1
    // Threshold (0-1) - step 0.1
    const { props, type } = this;
    const { layer, strings, locale, modules } = props;
    const { screenUtils } = modules;
    const anyLayer = layer;
    const effectProps = getEffectProps(type, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 5, step: 0.1, locale: locale, value: Math.round(effectProps.strength * 10) / 10, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.radius, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 5, step: 0.1, locale: locale, value: Math.round(screenUtils.pt2px(effectProps.radius) * 10) / 10, classNames: CSS.bottomSpace, label: strings.effectsProps.radius, onValueChange: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.threshold, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: Math.round(effectProps.threshold * 100), classNames: CSS.bottomSpace, label: strings.effectsProps.threshold, onValueChange: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline-space-between", scale: "s", class: CSS.switch }, strings.effectsProps.autoAdjust, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { checked: !!(!anyLayer.effect || typeof anyLayer.effect !== "string"), scale: "s", class: CSS.auto, onCalciteSwitchChange: this.onPropChange }))));
  }
  renderDropShadow() {
    // "Drop shadow": `drop-shadow(1px,1px,2px,#000000)`,
    // X offset (-20-20) - step 1
    // Y offset (-20-20) - step 1
    // Blur radius (0-20) - step 1
    const { props, type } = this;
    const { layer, strings, locale, modules } = props;
    const { screenUtils } = modules;
    const anyLayer = layer;
    const effectProps = getEffectProps(type, props);
    const hexValue = this.rgb2Hex(effectProps.color);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.effectsProps.color, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker", { scale: "m", value: hexValue, hideSaved: true, onCalciteColorPickerInput: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.effectsProps.width, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 20, step: 1, locale: locale, value: Math.round(screenUtils.pt2px(effectProps.blurRadius)), classNames: CSS.bottomSpace, label: strings.effectsProps.width, onValueChange: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s" }, strings.effectsProps.offset, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectXy, { min: -20, max: 20, step: 1, locale: locale, x: Math.round(screenUtils.pt2px(effectProps.xoffset)), y: Math.round(screenUtils.pt2px(effectProps.yoffset)), classNames: CSS.bottomSpaceLittle, strings: strings, onValueChange: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.opacity, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: (effectProps.color[3] / 255) * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.opacity, onValueChange: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline-space-between", scale: "s", class: CSS.switch }, strings.effectsProps.autoAdjust, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { checked: !!(!anyLayer.effect || typeof anyLayer.effect !== "string"), scale: "s", class: CSS.auto, onCalciteSwitchChange: this.onPropChange }))));
  }
  renderBlur() {
    // "Blur": `blur(2px)`,
    // Blur (0-30) - step 0.1
    const { props, type } = this;
    const { strings, locale, modules } = props;
    const { screenUtils } = modules;
    const effectProps = getEffectProps(type, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 30, step: 0.1, locale: locale, value: Math.round(screenUtils.pt2px(effectProps.radius) * 10) / 10, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange }))));
  }
  renderBrightnessContrast() {
    // brightness(100%) contrast(100%)
    // Brightness (0-300) - step 1 + Contrast (0-300) - step 1
    const { props } = this;
    const { strings, locale } = props;
    const effectPropsBrightness = getEffectProps("brightness", props);
    const effectPropsContrast = getEffectProps("contrast", props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.brightness, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 300, step: 1, locale: locale, value: Math.round(effectPropsBrightness.amount * 100), classNames: CSS.bottomSpace, label: strings.effectsProps.brightness, onValueChange: this.onPropChange })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.contrast, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 300, step: 1, locale: locale, value: Math.round(effectPropsContrast.amount * 100), classNames: CSS.bottomSpace, label: strings.effectsProps.contrast, onValueChange: this.onPropChange }))));
  }
  renderGrayscale() {
    // grayscale(25%)
    // Grayscale (0-100) - step 1
    const { props, type } = this;
    const { strings, locale } = props;
    const effectProps = getEffectProps(type, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange }))));
  }
  renderHueRotate() {
    // hue-rotate(270deg),
    // Hue rotate (0-360) - step 1
    const { props, type } = this;
    const { strings, locale } = props;
    const effectProps = getEffectProps(type, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.degrees, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 360, step: 1, locale: locale, value: effectProps.angle, classNames: CSS.bottomSpace, label: strings.effectsProps.degrees, onValueChange: this.onPropChange }))));
  }
  renderSaturate() {
    // saturate(100%)
    // Saturate (0-200) - step 1
    const { props, type } = this;
    const { strings, locale } = props;
    const effectProps = getEffectProps(type, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 200, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange }))));
  }
  renderInvert() {
    // invert(100%)
    // Invert (0-100) or (0-1) - step 1 or 0.01
    const { props, type } = this;
    const { strings, locale } = props;
    const effectProps = getEffectProps(type, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange }))));
  }
  renderSepia() {
    // sepia(50%)
    // Sepia (0-100) - step 1
    const { props, type } = this;
    const { strings, locale } = props;
    const effectProps = getEffectProps(type, props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS.content }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { scale: "s", onClick: calciteLabelClickHandlerForProperFocus }, strings.effectsProps.strength, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(SelectNumber, { min: 0, max: 100, step: 1, locale: locale, value: effectProps.amount * 100, classNames: CSS.bottomSpace, label: strings.effectsProps.strength, onValueChange: this.onPropChange }))));
  }
  renderFeatureEffectProps() {
    const { props, type, defaultExpression } = this;
    const { view, layer, strings } = props;
    const defaultField = getDefaultField(props);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-filter", { class: `${CSS.panel} filter`, view: view, layer: layer, hideLayerTitle: true, panelHeading: strings.featureEffectsTitle[type], tipHeading: strings.filter.tipHeading, tipMsg: strings.filter.tipMsg, invalidHeading: strings.filter.invalidHeading, invalidMsg: strings.filter.invalidMsg, mode: "effects", defaultFieldName: defaultField, defaultOperator: ">", defaultExpression: !!defaultField && defaultExpression, hideButtons: true, dismissible: true, panelMaxHeight: "80vh", onArcgisFilterDismissedChange: () => {
        this.arcgisEffectsPopoverClose.emit();
        this.popoverNode.open = false;
        this.open = false;
      }, onArcgisFilterWhereChange: ({ detail: where }) => {
        this.arcgisEffectsPopoverFilterChange.emit(where);
      }, ref: (node) => (this.filterNode = node) }));
  }
  rgb2Hex(color) {
    return ("#" +
      this.componentToHex(Math.max(0, Math.min(255, color[0]))) +
      this.componentToHex(Math.max(0, Math.min(255, color[1]))) +
      this.componentToHex(Math.max(0, Math.min(255, color[2]))));
  }
  componentToHex(c) {
    const hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisEffectsPopovers.style = arcgisEffectsPopoversCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-f63100ef.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-f63100ef.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arcgisComponentNotificationsKeys),
/* harmony export */   g: () => (/* binding */ getSingleObjectLocalStorage),
/* harmony export */   l: () => (/* binding */ localStorageKeys),
/* harmony export */   s: () => (/* binding */ setSingleObjectLocalStorage)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
var localStorageKeys;
(function (localStorageKeys) {
  localStorageKeys["ARCGIS_COMPONENT_NOTIFICATIONS"] = "arcgisComponent_notifications";
})(localStorageKeys || (localStorageKeys = {}));
var arcgisComponentNotificationsKeys;
(function (arcgisComponentNotificationsKeys) {
  arcgisComponentNotificationsKeys["FEATURE_REDUCTION_WARNING_DISMISSED"] = "arcgis_feature_reduction_warning_dismissed";
  arcgisComponentNotificationsKeys["POPUP_WARNING_DISMISSED"] = "arcgis_popup_warning_dismissed";
  arcgisComponentNotificationsKeys["INCOMPATIBLE_VECTOR_SYMBOLS_DISMISSED"] = "arcgis_symbol_styler_incompatible_vector_symbols_dismissed";
  arcgisComponentNotificationsKeys["EFFECTS_TIP_DISMISSED"] = "arcgis_effects_tip_dismissed";
  arcgisComponentNotificationsKeys["LAYER_VIEW_DEFINITION_DISMISSED"] = "arcgis_layer_view_definition_dismissed";
  arcgisComponentNotificationsKeys["LAYER_OVERRIDE_STATUS_TIP_DISMISSED"] = "arcgis_layer_override_status_tip_dismissed";
  arcgisComponentNotificationsKeys["LAYER_VIEW_JOIN_TIP_DISMISSED"] = "arcgis_layer_view_join_tip_dismissed";
  arcgisComponentNotificationsKeys["MULTIDIMENSIONAL_INFO_TIP_DISMISSED"] = "arcgis_multidimensional_info_tip_dismissed";
})(arcgisComponentNotificationsKeys || (arcgisComponentNotificationsKeys = {}));
const getLocalStorage = (localStorageKey) => {
  return localStorage.getItem(localStorageKey);
};
const setLocalStorage = (localStorageKey, value) => {
  localStorage.setItem(localStorageKey, value);
};
const getObjectLocalStorage = (localStorageKey) => {
  return JSON.parse(getLocalStorage(localStorageKey)) || {};
};
const setSingleObjectLocalStorage = (localStorageKey, keyValueObject) => {
  const setLocalStorageVal = getObjectLocalStorage(localStorageKey);
  setLocalStorageVal[keyValueObject.key] = keyValueObject.value;
  setLocalStorage(localStorageKey, JSON.stringify(setLocalStorageVal));
};
const getSingleObjectLocalStorage = (localStorageKey, objectKey) => {
  const getLocalStorageVal = getObjectLocalStorage(localStorageKey);
  if (getLocalStorageVal === null || getLocalStorageVal === void 0 ? void 0 : getLocalStorageVal.hasOwnProperty(objectKey)) {
    return getLocalStorageVal[objectKey];
  }
  else {
    return null;
  }
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
  var _a, _b, _c;
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    // "ru-RU" maps to "ru" use case
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
    }
    else {
      return "en";
    }
  }
}
function getComponentClosestLanguageIntl(element) {
  var _a, _b, _c;
  // it's OK if we don't have the 4 letter language file for it
  // 4 letter language code needed for formatting numbers
  const closestElement = (_a = (0,_dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
  // language set by the calling application or browser. defaults to english.
  const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
  if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
    return _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
  }
  else {
    if (_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
      // we support the 2 letter coded language
      // e.g. it-CH vs it
      return lang;
    }
    else {
      return "en";
    }
  }
}
function fetchLocaleStringsForComponent(componentName, locale) {
  return new Promise((resolve, reject) => {
    fetch((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
      if (result.ok)
        resolve(result.json());
      else
        reject();
    }, () => reject());
  });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
  const id = `${componentName}${locale}`;
  if (!stringCache[id]) {
    stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
  }
  return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
  const componentName = tagName || element.tagName.toLowerCase();
  const componentLanguage = getComponentClosestLanguage(element);
  const componentLanguageIntl = getComponentClosestLanguageIntl(element);
  let strings;
  try {
    strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
  }
  catch (e) {
    console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
    strings = await fetchLocaleStringsFromCache(componentName, "en");
  }
  return [strings, componentLanguage, componentLanguageIntl];
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTJjMTkwMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDZ0k7QUFDMUQ7QUFDWTtBQUNWO0FBQ1g7QUFDaUg7QUFDbko7QUFDUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkNBQTJDO0FBQ3REO0FBQ0EsWUFBWSx3RUFBd0U7QUFDcEYsYUFBYSwwRUFBMEU7QUFDdkYsZUFBZTtBQUNmLEdBQUc7QUFDSCxVQUFVLGFBQWE7QUFDdkIsZ0JBQWdCLGFBQWE7QUFDN0IsY0FBYyxXQUFXO0FBQ3pCLGVBQWUsV0FBVztBQUMxQixlQUFlLFlBQVk7QUFDM0IsY0FBYyxXQUFXO0FBQ3pCLFlBQVksV0FBVztBQUN2QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2RkFBNkY7QUFDOUc7QUFDQSxRQUFRLDhCQUE4QjtBQUN0QyxRQUFRO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsbUZBQW1GO0FBQ3BHO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDRGQUE0RjtBQUM3RyxpQkFBaUIsK0JBQStCO0FBQ2hELEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2RkFBNkY7QUFDOUc7QUFDQSxRQUFRLDRCQUE0QjtBQUNwQyxRQUFRO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIseURBQXlEO0FBQzFFO0FBQ0EsUUFBUSw4QkFBOEI7QUFDdEMsUUFBUTtBQUNSO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHlEQUF5RDtBQUMxRTtBQUNBLFFBQVEsNEJBQTRCO0FBQ3BDLFFBQVE7QUFDUjtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQix5REFBeUQ7QUFDMUUsaUJBQWlCLCtCQUErQjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEMsUUFBUTtBQUNSO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEJBQThCO0FBQ3RDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5Q0FBeUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxJQUFJLE9BQU8sTUFBTSxVQUFVO0FBQ3hEO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCLElBQUksZ0JBQWdCLE1BQU0sVUFBVTtBQUM5RSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixTQUFTLElBQUksT0FBTyxNQUFNLFVBQVU7QUFDNUQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUIsSUFBSSxtQkFBbUIsTUFBTSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0IsSUFBSSxZQUFZLEtBQUssWUFBWSxLQUFLLFFBQVE7QUFDbkcsMkJBQTJCLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLFFBQVE7QUFDakU7QUFDQTtBQUNBLDBCQUEwQixRQUFRLEtBQUssUUFBUSxLQUFLLFdBQVcsS0FBSyxTQUFTO0FBQzdFO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCLEtBQUssaUJBQWlCLEtBQUssb0JBQW9CLEtBQUssU0FBUztBQUM1RyxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhCQUE4QixRQUFRLEtBQUssUUFBUSxLQUFLLFdBQVcsS0FBSyxTQUFTO0FBQ2pGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CLEtBQUssb0JBQW9CLEtBQUssdUJBQXVCLEtBQUssU0FBUztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxxQ0FBcUM7QUFDckMsdUJBQXVCLFdBQVcsYUFBYSxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLDhCQUE4QixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSw4QkFBOEIsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQixVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFlBQVksTUFBTSxZQUFZLE9BQU8sWUFBWSxRQUFRLGNBQWMsZUFBZSxlQUFlLHVCQUF1QixNQUFNLHVCQUF1Qix1QkFBdUIsY0FBYyxzQ0FBc0MsUUFBUSxxQkFBcUIsY0FBYyxrQkFBa0IsTUFBTSx3QkFBd0IsV0FBVyxjQUFjLGFBQWEsbUJBQW1CLG9CQUFvQixlQUFlLGtCQUFrQixtQkFBbUIsc0JBQXNCLFlBQVksV0FBVyxxQkFBcUIsb0JBQW9CLGVBQWUsMkJBQTJCLGVBQWUscUJBQXFCOztBQUVwb0I7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCLDhCQUE4QixxREFBVztBQUN6QywrQkFBK0IscURBQVc7QUFDMUMseUNBQXlDLHFEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLDRDQUE0QztBQUMxRDtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSx1QkFBdUIsK0RBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQSxjQUFjLCtDQUErQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQiw2Q0FBNkMsc0RBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQSx5RUFBeUUsMkRBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxxREFBQyxDQUFDLGlEQUFJLElBQUksK0JBQStCLEVBQUUscURBQUMsbUJBQW1CLHdCQUF3Qiw0REFBYSwyREFBMkQ7QUFDM0s7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLFlBQVksaUJBQWlCO0FBQzdCLGdCQUFnQiw0REFBYTtBQUM3QixZQUFZLHFEQUFDLG9CQUFvQjtBQUNqQztBQUNBLFNBQVMsd0RBQVc7QUFDcEIsT0FBTztBQUNQO0FBQ0EsT0FBTywwQ0FBMEMsRUFBRSxxREFBQyxrQkFBa0IsbURBQW1ELEVBQUUscURBQUMsb0NBQW9DLHFEQUFDLHFDQUFxQyxxREFBQyxrQkFBa0IsZ05BQWdOO0FBQ3phO0FBQ0E7QUFDQSxZQUFZLDRDQUE0QztBQUN4RCxZQUFZLHlDQUF5QztBQUNyRCxnQkFBZ0IsNERBQWE7QUFDN0I7QUFDQSxZQUFZLHFEQUFDLG9CQUFvQjtBQUNqQztBQUNBLFNBQVMsd0RBQVc7QUFDcEIsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sOEJBQThCLDhDQUE4QyxxREFBQyxVQUFVLDJCQUEyQixFQUFFLHFEQUFDLGdDQUFnQyxnSUFBZ0ksRUFBRSxxREFBQyxxQ0FBcUMsb0VBQW9FLCtCQUErQixxREFBQyxxQ0FBcUMsbUVBQW1FO0FBQ2hoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEIsUUFBUSw0REFBMkIsQ0FBQyx3REFBZ0IsaUNBQWlDLHdEQUFnQztBQUNySDtBQUNBO0FBQ0EsWUFBWSxxREFBQyxVQUFVLHFCQUFxQixFQUFFLHFEQUFDLHFCQUFxQjtBQUNwRSxRQUFRLDREQUEyQixDQUFDLHdEQUFnQjtBQUNwRCxlQUFlLHdEQUFnQztBQUMvQztBQUNBLFNBQVM7QUFDVCxTQUFTLEVBQUUscURBQUMsVUFBVSxpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLHFEQUFDLGNBQWMscURBQUMsVUFBVSxtQkFBbUIsRUFBRSxxREFBQyxvQkFBb0IsWUFBWSxtQ0FBbUMscURBQUMseUJBQXlCLHdKQUF3SjtBQUNqVDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFlBQVkscURBQUMsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUUscURBQUMsVUFBVSxpREFBaUQsRUFBRSxxREFBQyxVQUFVO0FBQ3BGLGVBQWUsR0FBRyxvQkFBb0IsRUFBRSw0QkFBNEI7QUFDcEUsV0FBVyxxREFBWSwyQkFBMkIsS0FBSyxpQkFBaUIsSUFBSSxxREFBQyxxQkFBcUIsMEhBQTBIO0FBQzVOO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRCxZQUFZLHlCQUF5QjtBQUNyQztBQUNBLDBCQUEwQixxREFBQyxjQUFjLHFEQUFDLFVBQVUsMEJBQTBCLEVBQUUscURBQUMsb0JBQW9CLFlBQVksbUNBQW1DLHFEQUFDLHlCQUF5QixzRkFBc0Y7QUFDcFEseUJBQXlCLHFEQUFDLGNBQWMscURBQUMsVUFBVSwwQkFBMEIsRUFBRSxxREFBQyxvQkFBb0IsWUFBWSxrQ0FBa0MscURBQUMseUJBQXlCLG9GQUFvRjtBQUNoUSxZQUFZLHFEQUFDLGNBQWMscURBQUMsVUFBVSxtQkFBbUIsRUFBRSxxREFBQyxvQkFBb0IsWUFBWSw4QkFBOEIscURBQUMsb0JBQW9CLDRDQUE0QywyQkFBMkIscURBQUMscUJBQXFCLG1MQUFtTDtBQUMvWjtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQSxZQUFZLHFEQUFDLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFLHFEQUFDLFVBQVUsaURBQWlELEVBQUUscURBQUMsVUFBVSxVQUFVLHNCQUFzQixlQUFlLHFEQUFZLDJCQUEyQixLQUFLLEVBQUUsd0JBQXdCLE1BQU0sT0FBTyxpQkFBaUI7QUFDdk87QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRkFBZ0Y7QUFDNUYsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsc0JBQXNCLE9BQU8scURBQVU7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQTREO0FBQ3RFLFVBQVUscURBQUMsVUFBVSxVQUFVLGtCQUFrQixFQUFFLFdBQVcsR0FBRztBQUNqRSxJQUFJLHFEQUFDLHFCQUFxQix3TUFBd007QUFDbE8sSUFBSSxxREFBQyxvQkFBb0IsZ0hBQWdILE1BQU0sMEpBQTBKO0FBQ3pTO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFvRDtBQUM5RDtBQUNBLFVBQVUscURBQUMsVUFBVSxVQUFVLGdCQUFnQixFQUFFLFdBQVcscUNBQXFDO0FBQ2pHLElBQUkscURBQUMsdUJBQXVCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxJQUFJLHFEQUFDO0FBQ0wsTUFBTSxxREFBQyxvQkFBb0IsWUFBWTtBQUN2QztBQUNBLFFBQVEscURBQUMsb0JBQW9CLDJGQUEyRixFQUFFLCtKQUErSjtBQUN6UixNQUFNLHFEQUFDLG9CQUFvQixZQUFZO0FBQ3ZDO0FBQ0EsUUFBUSxxREFBQyxvQkFBb0IsMkZBQTJGLEVBQUUsK0pBQStKO0FBQ3pSO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sU0FBUztBQUNoQjtBQUNBLE9BQU8sU0FBUztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQywyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBOztBQUVBLDRFQUE0RSxhQUFhLG1CQUFtQiw4QkFBOEIsa0JBQWtCLG9GQUFvRixVQUFVLFlBQVksYUFBYSxxQkFBcUIsa0JBQWtCLGlEQUFpRCxVQUFVLHdDQUF3QywwQ0FBMEMsc0NBQXNDLGFBQWEsbUJBQW1CLGtGQUFrRixZQUFZLGdCQUFnQixjQUFjLDZDQUE2QyxXQUFXLHdDQUF3QywwQ0FBMEMsb0NBQW9DLFdBQVcsa0NBQWtDLFlBQVkseUNBQXlDLGlCQUFpQiw4Q0FBOEMsNENBQTRDLGFBQWEsdUJBQXVCLGdCQUFnQix5Q0FBeUMscUJBQXFCLGdEQUFnRCxxQkFBcUIsbUNBQW1DLFdBQVcsYUFBYSw4QkFBOEIsa0NBQWtDLGFBQWEsbUJBQW1CLHVDQUF1QyxvQkFBb0IsZUFBZSwrRUFBK0UscUJBQXFCLGNBQWM7O0FBRWxoRDtBQUNBO0FBQ0EsSUFBSSxxREFBZ0I7QUFDcEIseUNBQXlDLHFEQUFXO0FBQ3BELDRDQUE0QyxxREFBVztBQUN2RCxxQ0FBcUMscURBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVEsa0ZBQWtGO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekMsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQsK0JBQStCLG1DQUFtQztBQUNsRSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQSwrQkFBK0IsaUVBQWlFO0FBQ2hHLCtCQUErQiw4REFBOEQ7QUFDN0YsK0JBQStCLDhEQUE4RDtBQUM3RiwrQkFBK0IsOENBQThDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxtQ0FBbUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNENBQTRDO0FBQzNFLCtCQUErQiwwQ0FBMEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxlQUFlO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRCxZQUFZLFVBQVU7QUFDdEIsZ0JBQWdCLDREQUFhO0FBQzdCO0FBQ0EsWUFBWSxxREFBQyxDQUFDLGlEQUFJLElBQUksd0JBQXdCLEVBQUUscURBQUMsc0JBQXNCLEtBQUssNERBQWE7QUFDekY7QUFDQTtBQUNBLFNBQVMsd0RBQVc7QUFDcEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDLFlBQVksVUFBVTtBQUN0QixnQkFBZ0IsNERBQWE7QUFDN0I7QUFDQSxZQUFZLHFEQUFDLG9CQUFvQjtBQUNqQyxzQkFBc0IsdUJBQXVCO0FBQzdDLE9BQU8sMENBQTBDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxREFBQyxxQkFBcUIsb0lBQW9JLEVBQUUscURBQUMsbUJBQW1CLHlDQUF5QyxZQUFZLHFEQUFDLHFCQUFxQjtBQUN2UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxrQ0FBa0M7QUFDOUMsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQSxZQUFZLHFEQUFDLFVBQVUsb0JBQW9CLEVBQUUscURBQUMsb0JBQW9CLDZEQUE2RCxpQ0FBaUMscURBQUMsaUJBQWlCLG1NQUFtTSxJQUFJLHFEQUFDLG9CQUFvQiw2REFBNkQsK0JBQStCLHFEQUFDLGlCQUFpQixrTkFBa04sSUFBSSxxREFBQyxvQkFBb0IsNkRBQTZELGtDQUFrQyxxREFBQyxpQkFBaUIsaU1BQWlNLElBQUkscURBQUMsb0JBQW9CLCtEQUErRCxtQ0FBbUMscURBQUMscUJBQXFCLDZJQUE2STtBQUN2ekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFDLFVBQVUsb0JBQW9CLEVBQUUscURBQUMsb0JBQW9CLFlBQVksOEJBQThCLHFEQUFDLDJCQUEyQiw0RkFBNEYsSUFBSSxxREFBQyxvQkFBb0IsWUFBWSw4QkFBOEIscURBQUMsaUJBQWlCLDBNQUEwTSxJQUFJLHFEQUFDLG9CQUFvQixZQUFZLCtCQUErQixxREFBQyxhQUFhLGlQQUFpUCxJQUFJLHFEQUFDLG9CQUFvQiw2REFBNkQsZ0NBQWdDLHFEQUFDLGlCQUFpQiwwTEFBMEwsSUFBSSxxREFBQyxvQkFBb0IsK0RBQStELG1DQUFtQyxxREFBQyxxQkFBcUIsNklBQTZJO0FBQ3Q2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLDJCQUEyQjtBQUN2QyxZQUFZLGNBQWM7QUFDMUI7QUFDQSxZQUFZLHFEQUFDLFVBQVUsb0JBQW9CLEVBQUUscURBQUMsb0JBQW9CLDZEQUE2RCxpQ0FBaUMscURBQUMsaUJBQWlCLHFOQUFxTjtBQUN2WTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsWUFBWSxxREFBQyxVQUFVLG9CQUFvQixFQUFFLHFEQUFDLG9CQUFvQiw2REFBNkQsbUNBQW1DLHFEQUFDLGlCQUFpQix5TUFBeU0sSUFBSSxxREFBQyxvQkFBb0IsNkRBQTZELGlDQUFpQyxxREFBQyxpQkFBaUIscU1BQXFNO0FBQzNzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLFlBQVkscURBQUMsVUFBVSxvQkFBb0IsRUFBRSxxREFBQyxvQkFBb0IsNkRBQTZELGlDQUFpQyxxREFBQyxpQkFBaUIsaUxBQWlMO0FBQ25XO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsWUFBWSxxREFBQyxVQUFVLG9CQUFvQixFQUFFLHFEQUFDLG9CQUFvQiw2REFBNkQsZ0NBQWdDLHFEQUFDLGlCQUFpQix5S0FBeUs7QUFDMVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSxZQUFZLHFEQUFDLFVBQVUsb0JBQW9CLEVBQUUscURBQUMsb0JBQW9CLDZEQUE2RCxpQ0FBaUMscURBQUMsaUJBQWlCLGlMQUFpTDtBQUNuVztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLFlBQVkscURBQUMsVUFBVSxvQkFBb0IsRUFBRSxxREFBQyxvQkFBb0IsNkRBQTZELGlDQUFpQyxxREFBQyxpQkFBaUIsaUxBQWlMO0FBQ25XO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsWUFBWSxxREFBQyxVQUFVLG9CQUFvQixFQUFFLHFEQUFDLG9CQUFvQiw2REFBNkQsaUNBQWlDLHFEQUFDLGlCQUFpQixpTEFBaUw7QUFDblc7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0EsWUFBWSxxREFBQyxvQkFBb0IsVUFBVSxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0NBQWdDLGVBQWU7QUFDdEQ7QUFDQSxPQUFPLDJDQUEyQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8scURBQVU7QUFDdkM7QUFDQTs7QUFFNkY7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BuRDdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRFQUE0RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0STs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDMkU7QUFDYjtBQUNOOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbURBQWlDO0FBQ2hFO0FBQ0E7QUFDQSxNQUFNLHdEQUFXO0FBQ2pCLFdBQVcsd0RBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBVztBQUNuQixhQUFhLHdEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFpQztBQUNoRTtBQUNBO0FBQ0EsTUFBTSx3REFBVztBQUNqQixXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHdEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFZLDhCQUE4QixjQUFjLFFBQVEsT0FBTztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWMsRUFBRSxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlLEdBQUcsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUU0RSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1lZmZlY3RzXzIuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxTdG9yYWdlLWY2MzEwMGVmLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0xM2UwMGE3NS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBhIGFzIGdldEFzc2V0UGF0aCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgfSBmcm9tICcuL2xvY2FsZS0xM2UwMGE3NS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldEVsZW1lbnREaXIsIEMgYXMgQ1NTX1VUSUxJVFkgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyc7XG5pbXBvcnQgeyBxIGFzIHF1ZXJ5UGFyZW50RWxlbWVudCB9IGZyb20gJy4vY29tbW9uRnVuY3Rpb25zLTUyNjJiMDk0LmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlLCBzIGFzIHNldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSwgYSBhcyBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cywgbCBhcyBsb2NhbFN0b3JhZ2VLZXlzIH0gZnJvbSAnLi9sb2NhbFN0b3JhZ2UtZjYzMTAwZWYuanMnO1xuaW1wb3J0ICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZjk4YTMyM2MuanMnO1xuXG5jb25zdCBDU1MkMSA9IHtcbiAgZmxvdzogXCJmbG93XCIsXG4gIHBhbmVsOiBcInBhbmVsXCIsXG4gIG5vdGljZTogXCJub3RpY2VcIixcbiAgaGludDogXCJoaW50XCIsXG4gIGJhc2VtYXBUeXBlOiBcImJhc2VtYXAtdHlwZVwiLFxuICByYWRpb0J1dHRvbnM6IFwicmFkaW8tYnV0dG9uc1wiLFxuICBzd2l0Y2g6IFwic3dpdGNoXCIsXG4gIGxpc3Q6IFwibGlzdFwiLFxuICBlZmZlY3RUaHVtYjogXCJlZmZlY3QtdGh1bWJcIixcbiAgZWZmZWN0VGh1bWJJbWc6IFwiZWZmZWN0LXRodW1iLWltZ1wiLFxuICBlZmZlY3RDb3VudDogXCJlZmZlY3QtY291bnRcIlxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWRcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGNoZWNrXG4gKi9cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxubGV0IGFsbExheWVyRWZmZWN0VHlwZXMgPSBbXG4gIFwiYmxvb21cIixcbiAgXCJkcm9wU2hhZG93XCIsXG4gIFwiYmx1clwiLFxuICBcImJyaWdodG5lc3NDb250cmFzdFwiLFxuICBcImdyYXlzY2FsZVwiLFxuICBcImh1ZVJvdGF0ZVwiLFxuICBcInNhdHVyYXRlXCIsXG4gIFwiaW52ZXJ0XCIsXG4gIFwic2VwaWFcIlxuXTtcbmxldCBhbGxMaWdodEZlYXR1cmVFZmZlY3RUeXBlcyA9IFtcbiAgXCJkcm9wU2hhZG93X2dyYXlcIixcbiAgXCJzdHJvbmdEcm9wU2hhZG93XCIsXG4gIFwiZHJvcFNoYWRvd190cmFuc3BhcmVuY3lcIixcbiAgXCJkcm9wU2hhZG93X2JsdXJcIixcbiAgXCJtdXRlZEJsdXJcIixcbiAgXCJtdXRlZEdyYXlcIlxuXTtcbmxldCBhbGxEYXJrRmVhdHVyZUVmZmVjdFR5cGVzID0gW1wiYmxvb21fZ3JheVwiLCBcImJsb29tX2JsdXJcIiwgXCJibG9vbV90cmFuc3BhcmVuY3lcIiwgXCJtdXRlZEJsdXJcIiwgXCJtdXRlZEdyYXlcIl07XG4vKiBOZXV0cmFsIHZhbHVlcyA6XG5ibG9vbSAtICgwLDAsMClcbmJsdXIgLSAwXG5icmlnaHRuZXNzIC0gMTAwJVxuY29udHJhc3QgLSAxMDAlXG5kcm9wc2hhZG93IC0gMCwwLDAsYmxhY2tcbmdyYXlzY2FsZSAtIDAlXG5odWUtcm90YXRlIC0gMFxuaW52ZXJ0IC0gMCVcbm9wYWNpdHkgLSAxMDAlXG5zYXR1cmF0ZSAtIDEwMCVcbnNlcGlhIC0gMCVcbiovXG4vLyBhbGwgYXBwbGljYWJsZSB2YWx1ZXMgc3RvcmVkIGFzIHB0IChub3QgcHgpXG5jb25zdCBsYXllckVmZmVjdERlZmF1bHRzID0ge1xuICBibG9vbTogeyBzdHJlbmd0aDogMiwgcmFkaXVzOiAwLjc1LCB0aHJlc2hvbGQ6IDAuMSB9LFxuICBkcm9wU2hhZG93OiB7XG4gICAgbGluZTogeyBjb2xvcjogWzAsIDAsIDAsIDI1NV0sIHhvZmZzZXQ6IDAuNzUsIHlvZmZzZXQ6IDAuNzUsIGJsdXJSYWRpdXM6IDEuMTI1IH0sXG4gICAgcG9pbnQ6IHsgY29sb3I6IFswLCAwLCAwLCAyNTVdLCB4b2Zmc2V0OiAxLjEyNSwgeW9mZnNldDogMS4xMjUsIGJsdXJSYWRpdXM6IDEuODc1IH0sXG4gICAgcG9seWdvbjogeyBjb2xvcjogWzAsIDAsIDAsIDI1NV0sIHhvZmZzZXQ6IDEuMTI1LCB5b2Zmc2V0OiAxLjEyNSwgYmx1clJhZGl1czogMi4yNSB9XG4gIH0sXG4gIGJsdXI6IHsgcmFkaXVzOiAxLjUgfSxcbiAgYnJpZ2h0bmVzczogeyBhbW91bnQ6IDEuNSB9LFxuICBjb250cmFzdDogeyBhbW91bnQ6IDIgfSxcbiAgZ3JheXNjYWxlOiB7IGFtb3VudDogMSB9LFxuICBodWVSb3RhdGU6IHsgYW5nbGU6IDEwMCB9LFxuICBzYXR1cmF0ZTogeyBhbW91bnQ6IDEgfSxcbiAgaW52ZXJ0OiB7IGFtb3VudDogMSB9LFxuICBzZXBpYTogeyBhbW91bnQ6IDAuNyB9XG59O1xuY29uc3QgbGFzdExheWVyRWZmZWN0VmFsdWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsYXllckVmZmVjdERlZmF1bHRzKSk7XG4vLyBhbGwgYXBwbGljYWJsZSB2YWx1ZXMgc3RvcmVkIGFzIHB0IChub3QgcHgpXG4vLyBEcm9wIFNoYWRvdyArIEdyYXk6IGRyb3BzaGFkb3cgKDIvMi8zcHggUkdCIDUwLDUwLDUwKSBmb3IgYWN0aXZlLCAxMDAlIGdyZXlzY2FsZSArIDUwJSB0cmFuc3BhcmVuY3kgZm9yIG11dGVcbi8vIFN0cm9uZyBEcm9wIFNoYWRvdzogZHJvcHNoYWRvdyAoNC80LzRweCwgSGV4IzAwMDAwMCkgZm9yIGFjdGl2ZSwgbm90aGluZyBvbiBtdXRlXG4vLyBEcm9wIFNoYWRvdyArIFRyYW5zcGFyZW5jeTogZHJvcHNoYWRvdyAoMi8yLzZweCwgUkdCIDUwLDUwLDUwKSBmb3IgYWN0aXZlLCA2NSUgdHJhbnNwYXJlbmN5IGZvciBtdXRlXG4vLyBEcm9wIFNoYWRvdyArIEJsdXI6IGRyb3BzaGFkb3cgKDIvMi8zcHggUkdCIDUwLDUwLDUwKSBmb3IgYWN0aXZlLCAzcHggYmx1ciArIDUwJSB0cmFuc3BhcmVuY3kgZm9yIG11dGVcbi8vIEJsb29tICsgR3JheTogQmxvb20gKDEuMy8wLjc1LzApIGZvciBhY3RpdmUsIEdyZXlzY2FsZSAxMDAlICsgNTAlIG9wYWNpdHkgZm9yIG11dGVcbi8vIEJsb29tICsgQmx1cjo6IEJsb29tICgxLjMvMC43NS8wKSBmb3IgYWN0aXZlLCAzcHggYmx1ciArIDUwJSB0cmFuc3BhcmVuY3kgZm9yIG11dGVcbi8vIEJsb29tICsgVHJhbnNwYXJlbmN5OiBCbG9vbSAoMS4zLzAuNzUvMCkgZm9yIGFjdGl2ZSwgNjUlIG9wYWNpdHkgZm9yIG11dGVcbi8vIE11dGVkIEJsdXI6IG5vdGhpbmcgZm9yIGFjdGl2ZSwgM3B4IGJsdXIgKyA1MCUgdHJhbnNwYXJlbmN5IGZvciBtdXRlXG4vLyBNdXRlZCBHcmF5c2NhbGU6IG5vdGhpbmcgZm9yIGFjdGl2ZSwgMTAwJSBncmV5c2NhbGUgKyA1MCUgdHJhbnNwYXJlbmN5IGZvciBtdXRlLVxuY29uc3QgZmVhdHVyZUVmZmVjdERlZmF1bHRzID0ge1xuICBkcm9wU2hhZG93X2dyYXk6IHtcbiAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJkcm9wLXNoYWRvd1wiLCBjb2xvcjogWzUwLCA1MCwgNTAsIDI1NV0sIHhvZmZzZXQ6IDEuNSwgeW9mZnNldDogMS41LCBibHVyUmFkaXVzOiAyLjI1IH1dLFxuICAgIGV4Y2x1ZGVkOiBbXG4gICAgICB7IHR5cGU6IFwiZ3JheXNjYWxlXCIsIGFtb3VudDogMSB9LFxuICAgICAgeyB0eXBlOiBcIm9wYWNpdHlcIiwgYW1vdW50OiAwLjUgfVxuICAgIF1cbiAgfSxcbiAgc3Ryb25nRHJvcFNoYWRvdzoge1xuICAgIGluY2x1ZGVkOiBbeyB0eXBlOiBcImRyb3Atc2hhZG93XCIsIGNvbG9yOiBbMCwgMCwgMCwgMjU1XSwgeG9mZnNldDogMywgeW9mZnNldDogMywgYmx1clJhZGl1czogMyB9XSxcbiAgICBleGNsdWRlZDogW11cbiAgfSxcbiAgZHJvcFNoYWRvd190cmFuc3BhcmVuY3k6IHtcbiAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJkcm9wLXNoYWRvd1wiLCBjb2xvcjogWzUwLCA1MCwgNTAsIDI1NV0sIHhvZmZzZXQ6IDEuNSwgeW9mZnNldDogMS41LCBibHVyUmFkaXVzOiA0LjUgfV0sXG4gICAgZXhjbHVkZWQ6IFt7IHR5cGU6IFwib3BhY2l0eVwiLCBhbW91bnQ6IDAuMzUgfV1cbiAgfSxcbiAgZHJvcFNoYWRvd19ibHVyOiB7XG4gICAgaW5jbHVkZWQ6IFt7IHR5cGU6IFwiZHJvcC1zaGFkb3dcIiwgY29sb3I6IFs1MCwgNTAsIDUwLCAyNTVdLCB4b2Zmc2V0OiAxLjUsIHlvZmZzZXQ6IDEuNSwgYmx1clJhZGl1czogMi4yNSB9XSxcbiAgICBleGNsdWRlZDogW1xuICAgICAgeyB0eXBlOiBcImJsdXJcIiwgcmFkaXVzOiAyLjI1IH0sXG4gICAgICB7IHR5cGU6IFwib3BhY2l0eVwiLCBhbW91bnQ6IDAuNSB9XG4gICAgXVxuICB9LFxuICBibG9vbV9ncmF5OiB7XG4gICAgaW5jbHVkZWQ6IFt7IHR5cGU6IFwiYmxvb21cIiwgc3RyZW5ndGg6IDEuMywgcmFkaXVzOiAwLjYsIHRocmVzaG9sZDogMCB9XSxcbiAgICBleGNsdWRlZDogW1xuICAgICAgeyB0eXBlOiBcImdyYXlzY2FsZVwiLCBhbW91bnQ6IDEgfSxcbiAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICBdXG4gIH0sXG4gIGJsb29tX2JsdXI6IHtcbiAgICBpbmNsdWRlZDogW3sgdHlwZTogXCJibG9vbVwiLCBzdHJlbmd0aDogMS4zLCByYWRpdXM6IDAuNiwgdGhyZXNob2xkOiAwIH1dLFxuICAgIGV4Y2x1ZGVkOiBbXG4gICAgICB7IHR5cGU6IFwiYmx1clwiLCByYWRpdXM6IDIuMjUgfSxcbiAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICBdXG4gIH0sXG4gIGJsb29tX3RyYW5zcGFyZW5jeToge1xuICAgIGluY2x1ZGVkOiBbeyB0eXBlOiBcImJsb29tXCIsIHN0cmVuZ3RoOiAxLjMsIHJhZGl1czogMC42LCB0aHJlc2hvbGQ6IDAgfV0sXG4gICAgZXhjbHVkZWQ6IFt7IHR5cGU6IFwib3BhY2l0eVwiLCBhbW91bnQ6IDAuMzUgfV1cbiAgfSxcbiAgbXV0ZWRCbHVyOiB7XG4gICAgaW5jbHVkZWQ6IFtdLFxuICAgIGV4Y2x1ZGVkOiBbXG4gICAgICB7IHR5cGU6IFwiYmx1clwiLCByYWRpdXM6IDIuMjUgfSxcbiAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICBdXG4gIH0sXG4gIG11dGVkR3JheToge1xuICAgIGluY2x1ZGVkOiBbXSxcbiAgICBleGNsdWRlZDogW1xuICAgICAgeyB0eXBlOiBcImdyYXlzY2FsZVwiLCBhbW91bnQ6IDEgfSxcbiAgICAgIHsgdHlwZTogXCJvcGFjaXR5XCIsIGFtb3VudDogMC41IH1cbiAgICBdXG4gIH1cbn07XG5mdW5jdGlvbiBidWlsZEVmZmVjdHNJbmZvKG5vZGUsIHBvcG92ZXJzIC8qIEhUTUxBcmNnaXNFZmZlY3RzUG9wb3ZlcnNFbGVtZW50W10gKi8sIHByb3BzKSB7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKVxuICAgIC5maWx0ZXIoKGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKSB7XG4gICAgICBjb25zdCBpdGVtTm9kZSA9IGNoaWxkO1xuICAgICAgY29uc3Qgc3dpdGNoTm9kZSA9IGl0ZW1Ob2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLXN3aXRjaFwiKTtcbiAgICAgIHJldHVybiBzd2l0Y2hOb2RlLmNoZWNrZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSlcbiAgICAubWFwKChjaGlsZCkgPT4gYnVpbGRFZmZlY3RJbmZvKGNoaWxkLCBwb3BvdmVycywgcHJvcHMpKTtcbiAgbGV0IGVmZmVjdHNTdHJpbmcgPSBcIlwiO1xuICBsZXQgZWZmZWN0cztcbiAgbGV0IGNvbm5lY3RvciA9IFwiXCI7XG4gIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICBpZiAocGFydCAmJiB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgIGVmZmVjdHNTdHJpbmcgKz0gY29ubmVjdG9yICsgcGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlZmZlY3RzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLnZhbHVlICs9IGNvbm5lY3RvciArIHBhcnQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJ0ICYmIHR5cGVvZiBwYXJ0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoIWVmZmVjdHMpIHtcbiAgICAgICAgZWZmZWN0cyA9IHBhcnQ7XG4gICAgICAgIGVmZmVjdHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGl0ZW0udmFsdWUgPSBlZmZlY3RzU3RyaW5nICsgY29ubmVjdG9yICsgaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWZmZWN0cy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgQXJyYXkuZnJvbShwYXJ0KVxuICAgICAgICAgICAgLmZpbHRlcigobmV3SXRlbSkgPT4gaXRlbS5zY2FsZSA9PT0gbmV3SXRlbS5zY2FsZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChuZXdJdGVtKSA9PiAoaXRlbS52YWx1ZSArPSBjb25uZWN0b3IgKyBuZXdJdGVtLnZhbHVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0b3IgPSBcIiBcIjtcbiAgfSk7XG4gIGlmIChlZmZlY3RzKSB7XG4gICAgcmV0dXJuIGVmZmVjdHM7XG4gIH1cbiAgcmV0dXJuIGVmZmVjdHNTdHJpbmc7XG59XG5mdW5jdGlvbiBwYXJzZUVmZmVjdHMocHJvcHMpIHtcbiAgY29uc3QgeyBsYXllciwgbW9kdWxlcywgc3VwcG9ydHNGZWF0dXJlRWZmZWN0cyB9ID0gcHJvcHM7XG4gIGNvbnN0IGFueUxheWVyID0gbGF5ZXI7XG4gIGlmIChhbnlMYXllci5lZmZlY3QgJiYgYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGVmZmVjdFwiKTtcbiAgfVxuICBlbHNlIGlmIChhbnlMYXllci5mZWF0dXJlRWZmZWN0ICYmICFzdXBwb3J0c0ZlYXR1cmVFZmZlY3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgZWZmZWN0XCIpO1xuICB9XG4gIGVsc2UgaWYgKGFueUxheWVyLmVmZmVjdCkge1xuICAgIC8vIGxheWVyIGVmZmVjdFxuICAgIGNvbnN0IGVmZmVjdCA9IGFueUxheWVyLmVmZmVjdDtcbiAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIkVmZmVjdEpTT05cIiwgbW9kdWxlcy5lZmZlY3RzVXRpbHMudG9KU09OKGVmZmVjdCkpO1xuICAgICAgcmV0dXJuIG1vZHVsZXMuZWZmZWN0c1V0aWxzLnRvSlNPTihlZmZlY3QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlZmZlY3QubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAobWluaW1hbEF1dG9DaGVja09LKGVmZmVjdCkpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkVmZmVjdEpTT05cIiwgbW9kdWxlcy5lZmZlY3RzVXRpbHMudG9KU09OKGVmZmVjdFsxXS52YWx1ZSkpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiRWZmZWN0UHJvcGVydHlBUElcIiwgbW9kdWxlcy5lZmZlY3RzVXRpbHMuZnJvbUpTT04obW9kdWxlcy5lZmZlY3RzVXRpbHMudG9KU09OKGVmZmVjdFsxXS52YWx1ZSkpKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZXMuZWZmZWN0c1V0aWxzLnRvSlNPTihlZmZlY3RbMV0udmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGVmZmVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBlZmZlY3RcIik7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFueUxheWVyLmZlYXR1cmVFZmZlY3QpIHtcbiAgICAvLyBmZWF0dXJlIGVmZmVjdFxuICAgIGNvbnN0IGVmZmVjdCA9IGFueUxheWVyLmZlYXR1cmVFZmZlY3Q7XG4gICAgaWYgKGVmZmVjdC5leGNsdWRlZExhYmVsc1Zpc2libGUgJiZcbiAgICAgICghZWZmZWN0LmluY2x1ZGVkRWZmZWN0IHx8IHR5cGVvZiBlZmZlY3QuaW5jbHVkZWRFZmZlY3QgPT09IFwic3RyaW5nXCIpICYmXG4gICAgICAoIWVmZmVjdC5leGNsdWRlZEVmZmVjdCB8fCB0eXBlb2YgZWZmZWN0LmV4Y2x1ZGVkRWZmZWN0ID09PSBcInN0cmluZ1wiKSAmJlxuICAgICAgKCFlZmZlY3QuZmlsdGVyIHx8ICFlZmZlY3QuZmlsdGVyLmdlb21ldHJ5KSkge1xuICAgICAgY29uc3QgaW5jbHVkZWQgPSBlZmZlY3QuaW5jbHVkZWRFZmZlY3QgPyBtb2R1bGVzLmVmZmVjdHNVdGlscy50b0pTT04oZWZmZWN0LmluY2x1ZGVkRWZmZWN0KSA6IFtdO1xuICAgICAgY29uc3QgZXhjbHVkZWQgPSBlZmZlY3QuZXhjbHVkZWRFZmZlY3QgPyBtb2R1bGVzLmVmZmVjdHNVdGlscy50b0pTT04oZWZmZWN0LmV4Y2x1ZGVkRWZmZWN0KSA6IFtdO1xuICAgICAgLy9jb25zb2xlLmxvZyhcInBhcnNlZCBmZWF0dXJlIGVmZmVjdCAtIGluY2x1ZGVkOlwiLCBpbmNsdWRlZCwgXCJleGNsdWRlZDpcIiwgZXhjbHVkZWQsIFwid2hlcmU6XCIsIGVmZmVjdC5maWx0ZXIud2hlcmUpO1xuICAgICAgbGV0IGtleTtcbiAgICAgIGxldCBlZmZlY3RUeXBlO1xuICAgICAgZm9yIChrZXkgaW4gZmVhdHVyZUVmZmVjdERlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRKU09OID0gZmVhdHVyZUVmZmVjdERlZmF1bHRzW2tleV07XG4gICAgICAgIGlmIChpc1NhbWVFZmZlY3QoZGVmYXVsdEpTT04uaW5jbHVkZWQsIGluY2x1ZGVkKSAmJiBpc1NhbWVFZmZlY3QoZGVmYXVsdEpTT04uZXhjbHVkZWQsIGV4Y2x1ZGVkKSkge1xuICAgICAgICAgIGVmZmVjdFR5cGUgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlZmZlY3RUeXBlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGVmZmVjdFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzb3J0RWZmZWN0cyhwcm9wcykge1xuICBjb25zdCB7IGVmZmVjdHNKU09OIH0gPSBwcm9wcztcbiAgaWYgKCFlZmZlY3RzSlNPTikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1c2VkRWZmZWN0VHlwZXMgPSBlZmZlY3RzSlNPTi5tYXAoKGVmZmVjdCkgPT4gZWZmZWN0LnR5cGUpO1xuICBhbGxMYXllckVmZmVjdFR5cGVzLnNvcnQoKHR5cGVBLCB0eXBlQikgPT4ge1xuICAgIGNvbnN0IGluZGV4QSA9IHVzZWRFZmZlY3RUeXBlcy5pbmRleE9mKGNvbnZlcnRUb0FQSVR5cGUodHlwZUEpKTtcbiAgICBjb25zdCBpbmRleEIgPSB1c2VkRWZmZWN0VHlwZXMuaW5kZXhPZihjb252ZXJ0VG9BUElUeXBlKHR5cGVCKSk7XG4gICAgY29uc3QgdmFsdWUgPSBpbmRleEEgPiAtMSAmJiBpbmRleEIgPiAtMSAmJiBpbmRleEEgPCBpbmRleEJcbiAgICAgID8gLTFcbiAgICAgIDogaW5kZXhBID4gLTEgJiYgaW5kZXhCID4gLTEgJiYgaW5kZXhBID4gaW5kZXhCXG4gICAgICAgID8gMVxuICAgICAgICA6IGluZGV4QSA+IC0xXG4gICAgICAgICAgPyAtMVxuICAgICAgICAgIDogaW5kZXhCID4gLTFcbiAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgOiAwO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFZmZlY3RQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB7IGVmZmVjdHNKU09OIH0gPSBwcm9wcztcbiAgY29uc3QgbGF5ZXJFZmZlY3QgPSBlZmZlY3RzSlNPTiAmJiAoKF9iID0gKF9hID0gQXJyYXkuZnJvbShlZmZlY3RzSlNPTikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGVmZmVjdCkgPT4gZWZmZWN0LnR5cGUgPT09IGNvbnZlcnRUb0FQSVR5cGUodHlwZSkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pO1xuICBpZiAoIWxheWVyRWZmZWN0KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiZHJvcFNoYWRvd1wiKSB7XG4gICAgICBsZXQgZ2VvbWV0cnlUeXBlID0gZ2V0U2ltcGxlR2VvbWV0cnlUeXBlKHByb3BzKTtcbiAgICAgIHJldHVybiBsYXN0TGF5ZXJFZmZlY3RWYWx1ZXNbdHlwZV1bZ2VvbWV0cnlUeXBlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbGFzdExheWVyRWZmZWN0VmFsdWVzW3R5cGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGF5ZXJFZmZlY3Q7XG59XG5mdW5jdGlvbiBnZXRTaW1wbGVHZW9tZXRyeVR5cGUocHJvcHMpIHtcbiAgY29uc3QgeyBsYXllciB9ID0gcHJvcHM7XG4gIGxldCBzaW1wbGVUeXBlID0gXCJwb2ludFwiO1xuICBjb25zdCBhbnlMYXllciA9IGxheWVyO1xuICBpZiAobGF5ZXIudHlwZSA9PT0gXCJjc3ZcIikge1xuICAgIHNpbXBsZVR5cGUgPSBcInBvaW50XCI7XG4gIH1cbiAgZWxzZSBpZiAoYW55TGF5ZXIuZ2VvbWV0cnlUeXBlKSB7XG4gICAgc2ltcGxlVHlwZSA9XG4gICAgICBhbnlMYXllci5nZW9tZXRyeVR5cGUgPT09IFwicG9seWxpbmVcIlxuICAgICAgICA/IFwibGluZVwiXG4gICAgICAgIDogW1wicG9pbnRcIiwgXCJtdWx0aXBvaW50XCJdLmluY2x1ZGVzKGFueUxheWVyLmdlb21ldHJ5VHlwZSlcbiAgICAgICAgICA/IFwicG9pbnRcIlxuICAgICAgICAgIDogXCJwb2x5Z29uXCI7XG4gIH1cbiAgcmV0dXJuIHNpbXBsZVR5cGU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9BUElUeXBlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImRyb3BTaGFkb3dcIjpcbiAgICAgIHJldHVybiBcImRyb3Atc2hhZG93XCI7XG4gICAgY2FzZSBcImh1ZVJvdGF0ZVwiOlxuICAgICAgcmV0dXJuIFwiaHVlLXJvdGF0ZVwiO1xuICAgIGNhc2UgXCJicmlnaHRuZXNzQ29udHJhc3RcIjpcbiAgICAgIHJldHVybiBcImJyaWdodG5lc3NcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHR5cGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRmVhdHVyZUVmZmVjdChlZmZlY3RUeXBlLCB3aGVyZSwgcHJvcHMpIHtcbiAgY29uc3QgeyBtb2R1bGVzIH0gPSBwcm9wcztcbiAgY29uc3QgeyBGZWF0dXJlRWZmZWN0IH0gPSBtb2R1bGVzO1xuICBjb25zdCBqc29uID0gZmVhdHVyZUVmZmVjdERlZmF1bHRzW2VmZmVjdFR5cGVdO1xuICBjb25zdCBmZWF0dXJlRWZmZWN0ID0gbmV3IEZlYXR1cmVFZmZlY3Qoe1xuICAgIGZpbHRlcjoge1xuICAgICAgd2hlcmVcbiAgICB9LFxuICAgIGluY2x1ZGVkRWZmZWN0OiBtb2R1bGVzLmVmZmVjdHNVdGlscy5mcm9tSlNPTihqc29uLmluY2x1ZGVkKSxcbiAgICBleGNsdWRlZEVmZmVjdDogbW9kdWxlcy5lZmZlY3RzVXRpbHMuZnJvbUpTT04oanNvbi5leGNsdWRlZCksXG4gICAgZXhjbHVkZWRMYWJlbHNWaXNpYmxlOiB0cnVlXG4gIH0pO1xuICAvL2NvbnNvbGUubG9nKFwiYnVpbGRGZWF0dXJlRWZmZWN0XCIsIGVmZmVjdFR5cGUsIGZlYXR1cmVFZmZlY3QsIGpzb24pO1xuICByZXR1cm4gZmVhdHVyZUVmZmVjdDtcbn1cbmZ1bmN0aW9uIG1pbmltYWxBdXRvQ2hlY2tPSyhlZmZlY3QpIHtcbiAgLy8gbWFrZSBzdXJlIGVhY2ggZWZmZWN0IHR5cGUgaXMgbWVudGlvbmVkIGluIGFsbCAzIG9yIG5vbmUgb2YgdGhlIHN0cmluZ3NcbiAgY29uc3Qgc3RyaW5ncyA9IFtlZmZlY3RbMF0udmFsdWUsIGVmZmVjdFsxXS52YWx1ZSwgZWZmZWN0WzJdLnZhbHVlXTtcbiAgcmV0dXJuICFhbGxMYXllckVmZmVjdFR5cGVzLnNvbWUoKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSA9PT0gXCJicmlnaHRuZXNzQ29udHJhc3RcIikge1xuICAgICAgY29uc3QgYXBpVHlwZTEgPSBcImJyaWdodG5lc3NcIjtcbiAgICAgIGNvbnN0IGFwaVR5cGUyID0gXCJjb250cmFzdFwiO1xuICAgICAgaWYgKHN0cmluZ3NbMF0uaW5kZXhPZihhcGlUeXBlMSkgPiAtMSAmJiBzdHJpbmdzWzBdLmluZGV4T2YoYXBpVHlwZTIpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmdzWzFdLmluZGV4T2YoYXBpVHlwZTEpID09PSAtMSB8fFxuICAgICAgICAgIHN0cmluZ3NbMl0uaW5kZXhPZihhcGlUeXBlMSkgPT09IC0xIHx8XG4gICAgICAgICAgc3RyaW5nc1sxXS5pbmRleE9mKGFwaVR5cGUyKSA9PT0gLTEgfHxcbiAgICAgICAgICBzdHJpbmdzWzJdLmluZGV4T2YoYXBpVHlwZTIpID09PSAtMSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdHJpbmdzWzBdLmluZGV4T2YoYXBpVHlwZTEpID09PSAtMSAmJiBzdHJpbmdzWzBdLmluZGV4T2YoYXBpVHlwZTIpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gKHN0cmluZ3NbMV0uaW5kZXhPZihhcGlUeXBlMSkgPiAtMSB8fFxuICAgICAgICAgIHN0cmluZ3NbMl0uaW5kZXhPZihhcGlUeXBlMSkgPiAtMSB8fFxuICAgICAgICAgIHN0cmluZ3NbMV0uaW5kZXhPZihhcGlUeXBlMikgPiAtMSB8fFxuICAgICAgICAgIHN0cmluZ3NbMl0uaW5kZXhPZihhcGlUeXBlMikgPiAtMSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYXBpVHlwZSA9IGNvbnZlcnRUb0FQSVR5cGUodHlwZSk7XG4gICAgICBpZiAoc3RyaW5nc1swXS5pbmRleE9mKGFwaVR5cGUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ3NbMV0uaW5kZXhPZihhcGlUeXBlKSA9PT0gLTEgfHwgc3RyaW5nc1syXS5pbmRleE9mKGFwaVR5cGUpID09PSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5nc1sxXS5pbmRleE9mKGFwaVR5cGUpID4gLTEgfHwgc3RyaW5nc1syXS5pbmRleE9mKGFwaVR5cGUpID4gLTE7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzU2FtZUVmZmVjdChlZmZlY3RBXyAvKiBfX2VzcmkuRWZmZWN0SlNPTltdICovLCBlZmZlY3RCXyAvKiBfX2VzcmkuRWZmZWN0SlNPTltdICovKSB7XG4gIC8vIGRpZmZlcmVudCBvcmRlciBpcyBPS1xuICAvLyBtYWtlIGNvcGllcyBzbyBvcmRlcmluZyB3b24ndCBhZmZlY3QgdGhlIG9yaWdpbmFsXG4gIGNvbnN0IGVmZmVjdEEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVmZmVjdEFfKSk7XG4gIGNvbnN0IGVmZmVjdEIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVmZmVjdEJfKSk7XG4gIC8vIGNoZWNrIGxlbmd0aFxuICBpZiAoZWZmZWN0QS5sZW5ndGggIT09IGVmZmVjdEIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIHNvcnQgYnkgdHlwZSBuYW1lXG4gIGVmZmVjdEEuc29ydCgoYSwgYikgPT4gYS50eXBlLmxvY2FsZUNvbXBhcmUoYi50eXBlKSk7XG4gIGVmZmVjdEIuc29ydCgoYSwgYikgPT4gYS50eXBlLmxvY2FsZUNvbXBhcmUoYi50eXBlKSk7XG4gIC8vIGxvb3AgdGhyb3VnaCBhcnJheVxuICBsZXQgc2FtZSA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWZmZWN0QS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBlZmZlY3RBW2ldO1xuICAgIGNvbnN0IGIgPSBlZmZlY3RCW2ldO1xuICAgIC8vIHNhbWUgbnVtYmVyIG9mIHByb3BzP1xuICAgIGlmIChPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIGxvb2sgYXQgZWFjaCBwcm9wXG4gICAgZm9yIChsZXQga2V5IGluIGEpIHtcbiAgICAgIGlmICh0eXBlb2YgYVtrZXldID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBiW2tleV0gPT09IFwic3RyaW5nXCIgJiYgYVtrZXldID09PSBiW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgYVtrZXldID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiW2tleV0gPT09IFwibnVtYmVyXCIgJiYgYVtrZXldID09PSBiW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhW2tleV0ubGVuZ3RoICYmXG4gICAgICAgIGFba2V5XS5sZW5ndGggPT09IGJba2V5XS5sZW5ndGggJiZcbiAgICAgICAgYVtrZXldLmV2ZXJ5KCh2YWwsIGlkeCkgPT4gdmFsID09PSBiW2tleV1baWR4XSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2FtZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzYW1lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNhbWU7XG59XG5mdW5jdGlvbiBidWlsZEVmZmVjdEluZm8obm9kZSwgcG9wb3ZlcnMgLyogSFRNTEFyY2dpc0VmZmVjdHNQb3BvdmVyc0VsZW1lbnRbXSAqLywgcHJvcHMpIHtcbiAgY29uc3QgdHlwZSA9IG5vZGUudmFsdWU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJibG9vbVwiOlxuICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb0Jsb29tKHBvcG92ZXJzW3R5cGVdLCBwcm9wcyk7XG4gICAgY2FzZSBcImRyb3BTaGFkb3dcIjpcbiAgICAgIHJldHVybiBidWlsZEVmZmVjdEluZm9Ecm9wU2hhZG93KHBvcG92ZXJzW3R5cGVdLCBwcm9wcyk7XG4gICAgY2FzZSBcImJsdXJcIjpcbiAgICAgIHJldHVybiBidWlsZEVmZmVjdEluZm9CbHVyKHBvcG92ZXJzW3R5cGVdLCBwcm9wcyk7XG4gICAgY2FzZSBcImJyaWdodG5lc3NDb250cmFzdFwiOlxuICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb0JyaWdodG5lc3NDb250cmFzdChwb3BvdmVyc1t0eXBlXSk7XG4gICAgY2FzZSBcImdyYXlzY2FsZVwiOlxuICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb0dyYXlzY2FsZShwb3BvdmVyc1t0eXBlXSk7XG4gICAgY2FzZSBcImh1ZVJvdGF0ZVwiOlxuICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb0h1ZVJvdGF0ZShwb3BvdmVyc1t0eXBlXSk7XG4gICAgY2FzZSBcInNhdHVyYXRlXCI6XG4gICAgICByZXR1cm4gYnVpbGRFZmZlY3RJbmZvU2F0dXJhdGUocG9wb3ZlcnNbdHlwZV0pO1xuICAgIGNhc2UgXCJpbnZlcnRcIjpcbiAgICAgIHJldHVybiBidWlsZEVmZmVjdEluZm9JbnZlcnQocG9wb3ZlcnNbdHlwZV0pO1xuICAgIGNhc2UgXCJzZXBpYVwiOlxuICAgICAgcmV0dXJuIGJ1aWxkRWZmZWN0SW5mb1NlcGlhKHBvcG92ZXJzW3R5cGVdKTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvQmxvb20obm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLywgcHJvcHMpIHtcbiAgLy8gc3RyZW5ndGgsIHJhZGl1cywgdGhyZXNob2xkXG4gIC8vIGJsb29tKDIwMCUsIDFweCwgMC4yKVwiO1xuICAvLyBibG9vbSgyLCAxcHgsIDIwJSlcIjtcbiAgLy8gYmxvb20oMiwgMXB4LCAwLjEpXG4gIGNvbnN0IG51bWJlck5vZGVzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS1pbnB1dFwiKTtcbiAgbGV0IHN0cmVuZ3RoID0gZ2V0VmFsdWUobnVtYmVyTm9kZXNbMF0pO1xuICBsZXQgcmFkaXVzID0gZ2V0VmFsdWUobnVtYmVyTm9kZXNbMV0pO1xuICBsZXQgdGhyZXNob2xkID0gZ2V0VmFsdWUobnVtYmVyTm9kZXNbMl0pO1xuICBpZiAoIWlzRGVmaW5lZChzdHJlbmd0aCkgfHwgIWlzRGVmaW5lZChyYWRpdXMpIHx8ICFpc0RlZmluZWQodGhyZXNob2xkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0cmVuZ3RoID0gTWF0aC5yb3VuZChzdHJlbmd0aCAqIDEwKSAvIDEwO1xuICByYWRpdXMgPSBweDJwdFJvdW5kVG8zKE1hdGgucm91bmQocmFkaXVzICogMTApIC8gMTAsIHByb3BzKTtcbiAgdGhyZXNob2xkID0gTWF0aC5yb3VuZCh0aHJlc2hvbGQpO1xuICB0aHJlc2hvbGQgLz0gMTAwO1xuICBsYXN0TGF5ZXJFZmZlY3RWYWx1ZXMuYmxvb20gPSB7IHN0cmVuZ3RoLCByYWRpdXMsIHRocmVzaG9sZCB9O1xuICBjb25zdCBhdXRvTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcihcIi5hdXRvXCIpO1xuICBpZiAoIWF1dG9Ob2RlLmNoZWNrZWQpIHtcbiAgICByZXR1cm4gYGJsb29tKCR7c3RyZW5ndGh9LCAke3JhZGl1c31wdCwgJHt0aHJlc2hvbGR9KWA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgeyB2aWV3IH0gPSBwcm9wcztcbiAgICBjb25zdCBjdXJyZW50U2NhbGUgPSB2aWV3LnNjYWxlO1xuICAgIGNvbnN0IGZhY3RvciA9IDI7XG4gICAgY29uc3QgaW52RmFjdG9yID0gMSAvIGZhY3RvcjtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWVzIGhhdmUgYmVlbiBkb3VibGVkIGFmdGVyIHR3byB6b29tIGxldmVsIGluXG4gICAgICAgIHNjYWxlOiBjdXJyZW50U2NhbGUgKiAwLjI1LFxuICAgICAgICB2YWx1ZTogYGJsb29tKCR7c3RyZW5ndGggKiBmYWN0b3J9LCAke3JhZGl1cyAqIGZhY3Rvcn1wdCwgJHt0aHJlc2hvbGR9KWBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjYWxlOiBjdXJyZW50U2NhbGUsXG4gICAgICAgIHZhbHVlOiBgYmxvb20oJHtzdHJlbmd0aH0sICR7cmFkaXVzfXB0LCAke3RocmVzaG9sZH0pYFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlcyBoYXZlIGJlZW4gaGFsdmVkIGFmdGVyIHR3byB6b29tcyBsZXZlbCBvdXRcbiAgICAgICAgc2NhbGU6IGN1cnJlbnRTY2FsZSAqIDQsXG4gICAgICAgIHZhbHVlOiBgYmxvb20oJHtzdHJlbmd0aCAqIGludkZhY3Rvcn0sICR7cmFkaXVzICogaW52RmFjdG9yfXB0LCAke3RocmVzaG9sZH0pYFxuICAgICAgfVxuICAgIF07XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRWZmZWN0SW5mb0Ryb3BTaGFkb3cobm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLywgcHJvcHMpIHtcbiAgLy8geCBvZmZzZXQsIHkgb2Zmc2V0LCBibHVyIHJhZGl1cyAoPXdpZHRoKSBoc2woaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhKVxuICAvLyBcImRyb3Atc2hhZG93KDNweCwgM3B4LCA0cHgpXCJcbiAgY29uc3QgY29sb3IgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWNvbG9yLXBpY2tlclwiKTtcbiAgY29uc3QgcmdiID0gaGV4VG9SZ2IoY29sb3IudmFsdWUpO1xuICBjb25zdCBudW1iZXJOb2RlcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtaW5wdXRcIik7XG4gIGxldCBibHVyUmFkaXVzID0gZ2V0VmFsdWUobnVtYmVyTm9kZXNbMF0pO1xuICBsZXQgeG9mZnNldCA9IGdldFZhbHVlKG51bWJlck5vZGVzWzFdKTtcbiAgbGV0IHlvZmZzZXQgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1syXSk7XG4gIGxldCBvcGFjaXR5ID0gZ2V0VmFsdWUobnVtYmVyTm9kZXNbM10pO1xuICBpZiAoIWlzRGVmaW5lZChjb2xvci52YWx1ZSkgfHxcbiAgICAhaXNEZWZpbmVkKGJsdXJSYWRpdXMpIHx8XG4gICAgIWlzRGVmaW5lZCh4b2Zmc2V0KSB8fFxuICAgICFpc0RlZmluZWQoeW9mZnNldCkgfHxcbiAgICAhaXNEZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYmx1clJhZGl1cyA9IHB4MnB0Um91bmRUbzMoTWF0aC5yb3VuZChibHVyUmFkaXVzKSwgcHJvcHMpO1xuICB4b2Zmc2V0ID0gcHgycHRSb3VuZFRvMyhNYXRoLnJvdW5kKHhvZmZzZXQpLCBwcm9wcyk7XG4gIHlvZmZzZXQgPSBweDJwdFJvdW5kVG8zKE1hdGgucm91bmQoeW9mZnNldCksIHByb3BzKTtcbiAgb3BhY2l0eSA9IE1hdGgucm91bmQob3BhY2l0eSk7XG4gIG9wYWNpdHkgLz0gMTAwO1xuICBsYXN0TGF5ZXJFZmZlY3RWYWx1ZXMuZHJvcFNoYWRvd1tnZXRTaW1wbGVHZW9tZXRyeVR5cGUocHJvcHMpXSA9IHtcbiAgICBjb2xvcjogW3JnYi5yLCByZ2IuZywgcmdiLmIsIG9wYWNpdHkgKiAyNTVdLFxuICAgIHhvZmZzZXQsXG4gICAgeW9mZnNldCxcbiAgICBibHVyUmFkaXVzXG4gIH07XG4gIC8vY29uc3QgaHNsID0gaGV4VG9IU0woY29sb3IudmFsdWUgYXMgYW55KTtcbiAgLy9jb25zdCBjb2xvclN0ciA9IGBoc2xhKCR7TWF0aC5yb3VuZChoc2wuaCAqIDM2MCl9LCAke2hzbC5zICogMTAwfSUsICR7aHNsLmwgKiAxMDB9JSwgJHtvcGFjaXR5fSlgO1xuICBjb25zdCBjb2xvclN0ciA9IGByZ2JhKCR7cmdiLnJ9LCAke3JnYi5nfSwgJHtyZ2IuYn0sICR7b3BhY2l0eX0pYDtcbiAgY29uc3QgYXV0b05vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCIuYXV0b1wiKTtcbiAgaWYgKCFhdXRvTm9kZS5jaGVja2VkKSB7XG4gICAgcmV0dXJuIGBkcm9wLXNoYWRvdygke3hvZmZzZXR9cHQgJHt5b2Zmc2V0fXB0ICR7Ymx1clJhZGl1c31wdCAke2NvbG9yU3RyfSlgO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IHsgdmlldyB9ID0gcHJvcHM7XG4gICAgY29uc3QgY3VycmVudFNjYWxlID0gdmlldy5zY2FsZTtcbiAgICBjb25zdCBmYWN0b3IgPSAyO1xuICAgIGNvbnN0IGludkZhY3RvciA9IDEgLyBmYWN0b3I7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHZhbHVlcyBoYXZlIGJlZW4gZG91YmxlZCBhZnRlciB0d28gem9vbSBsZXZlbCBpblxuICAgICAgICBzY2FsZTogY3VycmVudFNjYWxlICogMC4yNSxcbiAgICAgICAgdmFsdWU6IGBkcm9wLXNoYWRvdygke3hvZmZzZXQgKiBmYWN0b3J9cHQgJHt5b2Zmc2V0ICogZmFjdG9yfXB0ICR7Ymx1clJhZGl1cyAqIGZhY3Rvcn1wdCAke2NvbG9yU3RyfSlgXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY2FsZTogY3VycmVudFNjYWxlLFxuICAgICAgICB2YWx1ZTogYGRyb3Atc2hhZG93KCR7eG9mZnNldH1wdCAke3lvZmZzZXR9cHQgJHtibHVyUmFkaXVzfXB0ICR7Y29sb3JTdHJ9KWBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCB2YWx1ZXMgaGF2ZSBiZWVuIGhhbHZlZCBhZnRlciB0d28gem9vbXMgbGV2ZWwgb3V0XG4gICAgICAgIHNjYWxlOiBjdXJyZW50U2NhbGUgKiA0LFxuICAgICAgICB2YWx1ZTogYGRyb3Atc2hhZG93KCR7eG9mZnNldCAqIGludkZhY3Rvcn1wdCAke3lvZmZzZXQgKiBpbnZGYWN0b3J9cHQgJHtibHVyUmFkaXVzICogaW52RmFjdG9yfXB0ICR7Y29sb3JTdHJ9KWBcbiAgICAgIH1cbiAgICBdO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZEVmZmVjdEluZm9CbHVyKG5vZGUgLyogSFRNTEFyY2dpc0VmZmVjdHNQb3BvdmVyc0VsZW1lbnQgKi8sIHByb3BzKSB7XG4gIC8vIGJsdXIoMTBweClcbiAgY29uc3QgbnVtYmVyTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIik7XG4gIGxldCByYWRpdXMgPSBnZXRWYWx1ZShudW1iZXJOb2RlKTtcbiAgaWYgKCFpc0RlZmluZWQocmFkaXVzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJhZGl1cyA9IHB4MnB0Um91bmRUbzMoTWF0aC5yb3VuZChyYWRpdXMgKiAxMCkgLyAxMCwgcHJvcHMpO1xuICBsYXN0TGF5ZXJFZmZlY3RWYWx1ZXMuYmx1ciA9IHsgcmFkaXVzIH07XG4gIHJldHVybiBgYmx1cigke3JhZGl1c31wdClgO1xufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvQnJpZ2h0bmVzc0NvbnRyYXN0KG5vZGUgLyogSFRNTEFyY2dpc0VmZmVjdHNQb3BvdmVyc0VsZW1lbnQgKi8pIHtcbiAgLy8gYnJpZ2h0bmVzcygxMDAlKSBjb250cmFzdCgxMDAlKVxuICBjb25zdCBudW1iZXJOb2RlcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtaW5wdXRcIik7XG4gIGxldCBicmlnaHRuZXNzID0gZ2V0VmFsdWUobnVtYmVyTm9kZXNbMF0pO1xuICBsZXQgY29udHJhc3QgPSBnZXRWYWx1ZShudW1iZXJOb2Rlc1sxXSk7XG4gIGlmICghaXNEZWZpbmVkKGJyaWdodG5lc3MpIHx8ICFpc0RlZmluZWQoY29udHJhc3QpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYnJpZ2h0bmVzcyA9IE1hdGgucm91bmQoYnJpZ2h0bmVzcykgLyAxMDA7XG4gIGNvbnRyYXN0ID0gTWF0aC5yb3VuZChjb250cmFzdCkgLyAxMDA7XG4gIGxhc3RMYXllckVmZmVjdFZhbHVlcy5icmlnaHRuZXNzID0geyBhbW91bnQ6IGJyaWdodG5lc3MgfTtcbiAgbGFzdExheWVyRWZmZWN0VmFsdWVzLmNvbnRyYXN0ID0geyBhbW91bnQ6IGNvbnRyYXN0IH07XG4gIHJldHVybiBgYnJpZ2h0bmVzcygke2JyaWdodG5lc3N9KSBjb250cmFzdCgke2NvbnRyYXN0fSlgO1xufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvR3JheXNjYWxlKG5vZGUgLyogSFRNTEFyY2dpc0VmZmVjdHNQb3BvdmVyc0VsZW1lbnQgKi8pIHtcbiAgLy8gZ3JheXNjYWxlKDI1JSlcbiAgY29uc3QgbnVtYmVyTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIik7XG4gIGxldCBhbW91bnQgPSBnZXRWYWx1ZShudW1iZXJOb2RlKTtcbiAgaWYgKCFpc0RlZmluZWQoYW1vdW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGFtb3VudCA9IE1hdGgucm91bmQoYW1vdW50KSAvIDEwMDtcbiAgbGFzdExheWVyRWZmZWN0VmFsdWVzLmdyYXlzY2FsZSA9IHsgYW1vdW50IH07XG4gIHJldHVybiBgZ3JheXNjYWxlKCR7YW1vdW50fSlgO1xufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvSHVlUm90YXRlKG5vZGUgLyogSFRNTEFyY2dpc0VmZmVjdHNQb3BvdmVyc0VsZW1lbnQgKi8pIHtcbiAgLy8gaHVlLXJvdGF0ZSgyNzBkZWcpXG4gIGNvbnN0IG51bWJlck5vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpO1xuICBsZXQgYW5nbGUgPSBnZXRWYWx1ZShudW1iZXJOb2RlKTtcbiAgaWYgKCFpc0RlZmluZWQoYW5nbGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlKTtcbiAgbGFzdExheWVyRWZmZWN0VmFsdWVzLmh1ZVJvdGF0ZSA9IHsgYW5nbGUgfTtcbiAgcmV0dXJuIGBodWUtcm90YXRlKCR7YW5nbGV9ZGVnKWA7XG59XG5mdW5jdGlvbiBidWlsZEVmZmVjdEluZm9TYXR1cmF0ZShub2RlIC8qIEhUTUxBcmNnaXNFZmZlY3RzUG9wb3ZlcnNFbGVtZW50ICovKSB7XG4gIC8vIHNhdHVyYXRlKDEwMCUpXG4gIGNvbnN0IG51bWJlck5vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpO1xuICBsZXQgYW1vdW50ID0gZ2V0VmFsdWUobnVtYmVyTm9kZSk7XG4gIGlmICghaXNEZWZpbmVkKGFtb3VudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhbW91bnQgPSBNYXRoLnJvdW5kKGFtb3VudCkgLyAxMDA7XG4gIGxhc3RMYXllckVmZmVjdFZhbHVlcy5zYXR1cmF0ZSA9IHsgYW1vdW50IH07XG4gIHJldHVybiBgc2F0dXJhdGUoJHthbW91bnR9KWA7XG59XG5mdW5jdGlvbiBidWlsZEVmZmVjdEluZm9JbnZlcnQobm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLykge1xuICAvLyBpbnZlcnQoMTAwJSlcbiAgY29uc3QgbnVtYmVyTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIik7XG4gIGxldCBhbW91bnQgPSBnZXRWYWx1ZShudW1iZXJOb2RlKTtcbiAgaWYgKCFpc0RlZmluZWQoYW1vdW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGFtb3VudCA9IE1hdGgucm91bmQoYW1vdW50KSAvIDEwMDtcbiAgbGFzdExheWVyRWZmZWN0VmFsdWVzLmludmVydCA9IHsgYW1vdW50IH07XG4gIHJldHVybiBgaW52ZXJ0KCR7YW1vdW50fSlgO1xufVxuZnVuY3Rpb24gYnVpbGRFZmZlY3RJbmZvU2VwaWEobm9kZSAvKiBIVE1MQXJjZ2lzRWZmZWN0c1BvcG92ZXJzRWxlbWVudCAqLykge1xuICAvLyBzZXBpYSg1MCUpXG4gIGNvbnN0IG51bWJlck5vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpO1xuICBsZXQgYW1vdW50ID0gZ2V0VmFsdWUobnVtYmVyTm9kZSk7XG4gIGlmICghaXNEZWZpbmVkKGFtb3VudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhbW91bnQgPSBNYXRoLnJvdW5kKGFtb3VudCkgLyAxMDA7XG4gIGxhc3RMYXllckVmZmVjdFZhbHVlcy5zZXBpYSA9IHsgYW1vdW50IH07XG4gIHJldHVybiBgc2VwaWEoJHthbW91bnR9KWA7XG59XG4vKiBmdW5jdGlvbiBoZXhUb0hTTChoZXg6IHN0cmluZyk6IGFueSB7XG4gIGNvbnN0IHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICBsZXQgciA9IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpO1xuICBsZXQgZyA9IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpO1xuICBsZXQgYiA9IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpO1xuICAociAvPSAyNTUpLCAoZyAvPSAyNTUpLCAoYiAvPSAyNTUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgbGV0IGgsXG4gICAgcyxcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAobWF4ID09IG1pbikge1xuICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGc6XG4gICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaCAvPSA2O1xuICB9XG4gIGNvbnN0IEhTTCA9IG5ldyBPYmplY3QoKTtcbiAgSFNMW1wiaFwiXSA9IGg7XG4gIEhTTFtcInNcIl0gPSBzO1xuICBIU0xbXCJsXCJdID0gbDtcbiAgcmV0dXJuIEhTTDtcbn0gKi9cbmZ1bmN0aW9uIGhleFRvUmdiKGhleCkge1xuICBjb25zdCByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgcmV0dXJuIHJlc3VsdFxuICAgID8ge1xuICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXG4gICAgfVxuICAgIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKG5vZGUpIHtcbiAgY29uc3QgdmFsdWUgPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1pbihub2RlLm1heCwgTWF0aC5tYXgobm9kZS5taW4sIHZhbHVlKSk7XG4gIC8vIGVuc3VyZSB2YWx1ZSBpcyB3aXRoaW4gYWxsb3dlZCByYW5nZVxuICBub2RlLnZhbHVlID0gYCR7Y2xhbXBlZH1gO1xuICByZXR1cm4gY2xhbXBlZDtcbn1cbmZ1bmN0aW9uIHB4MnB0Um91bmRUbzModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHsgbW9kdWxlcyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgc2NyZWVuVXRpbHMgfSA9IG1vZHVsZXM7XG4gIHJldHVybiBNYXRoLnJvdW5kKHNjcmVlblV0aWxzLnB4MnB0KHZhbHVlKSAqIDEwMDApIC8gMTAwMDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEZpZWxkKHByb3BzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICBjb25zdCB7IHJlbmRlcmVyIH0gPSBsYXllcjtcbiAgaWYgKCFyZW5kZXJlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIG5vdCBsb29raW5nIGF0IEFyY2FkZSBleHByZXNzaW9uc1xuICBzd2l0Y2ggKHJlbmRlcmVyLnR5cGUpIHtcbiAgICBjYXNlIFwidW5pcXVlLXZhbHVlXCI6IHtcbiAgICAgIC8vIHR5cGVzLCBwcmVkb21pbmFuY2UsIHJlbGF0aW9uc2hpcFxuICAgICAgaWYgKCgoX2EgPSByZW5kZXJlci5hdXRob3JpbmdJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwicHJlZG9taW5hbmNlXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3NbMF0udmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgoKF9iID0gcmVuZGVyZXIuYXV0aG9yaW5nSW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSBcInJlbGF0aW9uc2hpcFwiKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJlci5hdXRob3JpbmdJbmZvLmZpZWxkMS5maWVsZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIuZmllbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNhc2UgXCJjbGFzcy1icmVha3NcIjoge1xuICAgICAgLy8gY29sb3IsIHNpemVcbiAgICAgIGlmIChyZW5kZXJlci52aXN1YWxWYXJpYWJsZXMpIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IChfYyA9IHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcy5maW5kKCh2aXNWYXIpID0+IHZpc1Zhci50eXBlID09PSBcImNvbG9yXCIpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmllbGQ7XG4gICAgICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkTmFtZSA9IChfZCA9IHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcy5maW5kKCh2aXNWYXIpID0+IHZpc1Zhci50eXBlID09PSBcInNpemVcIiAmJiAhdmlzVmFyLnRhcmdldCAmJiB2aXNWYXIudmFsdWVFeHByZXNzaW9uICE9PSBcIiR2aWV3LnNjYWxlXCIpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZmllbGQ7XG4gICAgICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmZpZWxkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkb3QtZGVuc2l0eVwiOlxuICAgICAgcmV0dXJuIChfZSA9IHJlbmRlcmVyLmF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXS5maWVsZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgYXJjZ2lzRWZmZWN0c0NzcyA9IFwiOmhvc3R7aGVpZ2h0OjEwMCV9LmZsb3d7aGVpZ2h0OjEwMCV9LnBhbmVse2hlaWdodDoxMDAlfS5ub3RpY2V7bWFyZ2luOjAuNXJlbX0ucmFkaW8tYnV0dG9uc3twYWRkaW5nOjAuNXJlbTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlfS5oaW50e3BhZGRpbmc6MC4yNXJlbSAwLjVyZW07YmFja2dyb3VuZC1jb2xvcjp3aGl0ZX0uYmFzZW1hcC10eXBle3BhZGRpbmc6MC43NXJlbSAwLjVyZW0gMC4yNXJlbSAwLjVyZW19LnN3aXRjaHttYXJnaW4tcmlnaHQ6MC43NXJlbTttYXJnaW4tbGVmdDowO2FsaWduLXNlbGY6Y2VudGVyfS5saXN0e2ZsZXgtZmxvdzpjb2x1bW4gbm93cmFwO21hcmdpbjoxcHh9LmVmZmVjdC10aHVtYntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmctbGVmdDowLjVyZW07Y3Vyc29yOnBvaW50ZXJ9LmVmZmVjdC10aHVtYi1pbWd7bWFyZ2luLXRvcDowLjI1cmVtO21hcmdpbi1ib3R0b206MC4yNXJlbTtoZWlnaHQ6NDhweDt3aWR0aDo0OHB4fS5hcmNnaXMtLXJ0bCAuc3dpdGNoe21hcmdpbi1sZWZ0OjAuNzVyZW07bWFyZ2luLXJpZ2h0OjB9LmFyY2dpcy0tcnRsIC5lZmZlY3QtdGh1bWJ7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowLjVyZW19XCI7XG5cbmNvbnN0IEFyY2dpc0VmZmVjdHMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0Nsb3NlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNFZmZlY3RzQ2xvc2VcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNFZmZlY3RzQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNFZmZlY3RzQ2hhbmdlXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0FwcGx5TGF5ZXJFZmZlY3QgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0XCIsIDcpO1xuICAgIHRoaXMucG9wb3ZlcnMgPSBbXTtcbiAgICB0aGlzLmltYWdlc1BhdGggPSBcIi4uL2FyY2dpcy1hcHAtYXNzZXRzL2ltYWdlcy9lZmZlY3RzL3Rlc3QuanBnXCI7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5hZnRlckNyZWF0ZVBhbmVsID0gKG5vZGUpID0+IHtcbiAgICAgIHRoaXMucGFuZWxOb2RlID0gbm9kZTtcbiAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IGZlYXR1cmVFZmZlY3RUeXBlLCBzdXBwb3J0c0ZlYXR1cmVFZmZlY3RzIH0gPSBwcm9wcztcbiAgICAgIC8vIG9wZW4gYWxsIHBvcG92ZXJzIHNvIHdlIGhhdmUgYWNjZXNzIHRvIGFsbCBjdXJyZW50IHByb3BzXG4gICAgICAvLyBmZWF0dXJlIGVmZmVjdHMgYWxsIHNoYXJlIG9uZSBwb3BvdmVyXG4gICAgICBjb25zdCB7IHBvcG92ZXJzLCBwYW5lbE5vZGUgfSA9IHRoaXM7XG4gICAgICBpZiAocG9wb3ZlcnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZW1cbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICB9XG4gICAgICAvLyB3YWl0IHVudGlsIHBhbmVsTm9kZSBoYXMgZGltZW5zaW9uc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCBhbGxUeXBlcyA9IHN1cHBvcnRzRmVhdHVyZUVmZmVjdHNcbiAgICAgICAgICA/IGFsbExheWVyRWZmZWN0VHlwZXMuY29uY2F0KFtcImZlYXR1cmVFZmZlY3RcIl0pXG4gICAgICAgICAgOiBhbGxMYXllckVmZmVjdFR5cGVzO1xuICAgICAgICBhbGxUeXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgcG9wb3ZlcnNbdHlwZV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGBhcmNnaXMtZWZmZWN0cy1wb3BvdmVyc2ApO1xuICAgICAgICAgIHBvcG92ZXJzW3R5cGVdLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgcG9wb3ZlcnNbdHlwZV0udHlwZSA9IHR5cGU7XG4gICAgICAgICAgcG9wb3ZlcnNbdHlwZV0ucmVmZXJlbmNlRWxlbWVudCA9IHBhbmVsTm9kZTtcbiAgICAgICAgICBwb3BvdmVyc1t0eXBlXS5wb3BvdmVycyA9IHBvcG92ZXJzO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9wb3ZlcnNbdHlwZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZlYXR1cmVFZmZlY3RUeXBlKSB7XG4gICAgICAgICAgLy8gd2UncmUgc3RhcnRpbmcgd2l0aCBhIHNldCBmZWF0dXJlIGVmZmVjdFxuICAgICAgICAgIGNvbnN0IHBvcG92ZXIgPSBwb3BvdmVyc1tcImZlYXR1cmVFZmZlY3RcIl07XG4gICAgICAgICAgcG9wb3Zlci5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICBwb3BvdmVyLnVwZGF0ZUhlYWRlcihmZWF0dXJlRWZmZWN0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH07XG4gICAgdGhpcy5vblN3aXRjaEVmZmVjdFR5cGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHMsIHBvcG92ZXJzIH0gPSB0aGlzO1xuICAgICAgY29uc3QgbGF5ZXIgPSBwcm9wcy5sYXllcjtcbiAgICAgIGNvbnN0IG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAvLyBjbG9zZSBhbGwgcG9wb3ZlcnNcbiAgICAgIGxldCBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICBwb3BvdmVyc1trZXldLm9wZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnNlbGVjdGVkSXRlbS52YWx1ZSA9PT0gXCJsYXllclwiKSB7XG4gICAgICAgIHRoaXMubGFzdEZlYXR1cmVFZmZlY3QgPSBsYXllci5mZWF0dXJlRWZmZWN0IHx8IHRoaXMubGFzdEZlYXR1cmVFZmZlY3Q7XG4gICAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBudWxsO1xuICAgICAgICBsYXllci5lZmZlY3QgPSB0aGlzLmxhc3RMYXllckVmZmVjdDtcbiAgICAgICAgdGhpcy5zaG93RmVhdHVyZUVmZmVjdHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBcImZlYXR1cmVcIlxuICAgICAgICB0aGlzLmxhc3RMYXllckVmZmVjdCA9IGxheWVyLmVmZmVjdDtcbiAgICAgICAgbGF5ZXIuZWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubGFzdEZlYXR1cmVFZmZlY3QpIHtcbiAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gdGhpcy5sYXN0RmVhdHVyZUVmZmVjdDtcbiAgICAgICAgICBwcm9wcy5mZWF0dXJlRWZmZWN0VHlwZSA9IHBhcnNlRWZmZWN0cyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgeyBiYWNrZ3JvdW5kVGhlbWUgfSA9IHByb3BzO1xuICAgICAgICAgIHRoaXMuc2VsZWN0RmVhdHVyZUVmZmVjdFR5cGUoYmFja2dyb3VuZFRoZW1lID09PSBcImxpZ2h0XCIgPyBhbGxMaWdodEZlYXR1cmVFZmZlY3RUeXBlc1swXSA6IGFsbERhcmtGZWF0dXJlRWZmZWN0VHlwZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvd0ZlYXR1cmVFZmZlY3RzID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcG9wb3ZlciA9IHBvcG92ZXJzW1wiZmVhdHVyZUVmZmVjdFwiXTtcbiAgICAgICAgcG9wb3Zlci5vcGVuID0gdHJ1ZTtcbiAgICAgICAgcG9wb3Zlci51cGRhdGVIZWFkZXIocHJvcHMuZmVhdHVyZUVmZmVjdFR5cGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZVJlbmRlciA9ICF0aGlzLnJlUmVuZGVyO1xuICAgIH07XG4gICAgdGhpcy5vblJlbW92ZUVmZmVjdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IGxheWVyIH0gPSBwcm9wcztcbiAgICAgIGxheWVyLmVmZmVjdCA9IG51bGw7XG4gICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuaXNVbnN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5vblN3aXRjaENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBwb3BvdmVycyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHN3aXRjaE5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCBpdGVtTm9kZSA9IHF1ZXJ5UGFyZW50RWxlbWVudChzd2l0Y2hOb2RlLCBcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpO1xuICAgICAgY29uc3QgdHlwZSA9IGl0ZW1Ob2RlLnZhbHVlO1xuICAgICAgaWYgKCFzd2l0Y2hOb2RlLmNoZWNrZWQpIHtcbiAgICAgICAgcG9wb3ZlcnNbdHlwZV0ub3BlbiA9IGZhbHNlO1xuICAgICAgICBpdGVtTm9kZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzQXBwbHlMYXllckVmZmVjdC5lbWl0KHsgdHlwZSwga2VlcFN3aXRjaDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIHRoaXMub25GZWF0dXJlRWZmZWN0RW5hYmxlZFN3aXRjaENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3QgeyBwb3BvdmVycywgcHJvcHMsIGxpZ2h0TGlzdE5vZGUsIGRhcmtMaXN0Tm9kZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGxheWVyID0gcHJvcHMubGF5ZXI7XG4gICAgICBjb25zdCBzd2l0Y2hOb2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKCFzd2l0Y2hOb2RlLmNoZWNrZWQpIHtcbiAgICAgICAgcG9wb3ZlcnNbXCJmZWF0dXJlRWZmZWN0XCJdLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgbGlnaHRMaXN0Tm9kZSA9PT0gbnVsbCB8fCBsaWdodExpc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaWdodExpc3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKS5mb3JFYWNoKChpdGVtKSA9PiAoaXRlbS5zZWxlY3RlZCA9IGZhbHNlKSk7XG4gICAgICAgIGRhcmtMaXN0Tm9kZSA9PT0gbnVsbCB8fCBkYXJrTGlzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhcmtMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4gKGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZSkpO1xuICAgICAgICB0aGlzLmxhc3RGZWF0dXJlRWZmZWN0ID0gbGF5ZXIuZmVhdHVyZUVmZmVjdDtcbiAgICAgICAgbGF5ZXIuZmVhdHVyZUVmZmVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0NoYW5nZS5lbWl0KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEZlYXR1cmVFZmZlY3QpIHtcbiAgICAgICAgICBsYXllci5mZWF0dXJlRWZmZWN0ID0gdGhpcy5sYXN0RmVhdHVyZUVmZmVjdDtcbiAgICAgICAgICBwcm9wcy5mZWF0dXJlRWZmZWN0VHlwZSA9IHBhcnNlRWZmZWN0cyhwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgeyBiYWNrZ3JvdW5kVGhlbWUgfSA9IHByb3BzO1xuICAgICAgICAgIHByb3BzLmZlYXR1cmVFZmZlY3RUeXBlID1cbiAgICAgICAgICAgIGJhY2tncm91bmRUaGVtZSA9PT0gXCJsaWdodFwiXG4gICAgICAgICAgICAgID8gYWxsTGlnaHRGZWF0dXJlRWZmZWN0VHlwZXNbMF1cbiAgICAgICAgICAgICAgOiBhbGxEYXJrRmVhdHVyZUVmZmVjdFR5cGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGxpZ2h0TGlzdE5vZGUgPT09IG51bGwgfHwgbGlnaHRMaXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlnaHRMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09PSBwcm9wcy5mZWF0dXJlRWZmZWN0VHlwZSkge1xuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGFya0xpc3ROb2RlID09PSBudWxsIHx8IGRhcmtMaXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGFya0xpc3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IHByb3BzLmZlYXR1cmVFZmZlY3RUeXBlKSB7XG4gICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdEZlYXR1cmVFZmZlY3RUeXBlKHByb3BzLmZlYXR1cmVFZmZlY3RUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3BlblBvcG92ZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHsgcG9wb3ZlcnMgfSA9IHRoaXM7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCB0YWdOYW1lID0gdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGxldCBpdGVtTm9kZTtcbiAgICAgIGlmICh0YWdOYW1lID09PSBcImltZ1wiKSB7XG4gICAgICAgIGl0ZW1Ob2RlID0gcXVlcnlQYXJlbnRFbGVtZW50KHRhcmdldCwgXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRhZ05hbWUgPT09IFwiY2FsY2l0ZS1zd2l0Y2hcIikge1xuICAgICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICBpdGVtTm9kZSA9IHF1ZXJ5UGFyZW50RWxlbWVudCh0YXJnZXQsIFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0YWdOYW1lID09PSBcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpIHtcbiAgICAgICAgaXRlbU5vZGUgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaXRlbU5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgdHlwZSA9IGl0ZW1Ob2RlLnZhbHVlO1xuICAgICAgY29uc3QgaXNGZWF0dXJlRWZmZWN0VHlwZSA9IGFsbExpZ2h0RmVhdHVyZUVmZmVjdFR5cGVzLmNvbmNhdChhbGxEYXJrRmVhdHVyZUVmZmVjdFR5cGVzKS5pbmRleE9mKHR5cGUpID4gLTE7XG4gICAgICBpZiAoaXNGZWF0dXJlRWZmZWN0VHlwZSkge1xuICAgICAgICB0aGlzLnNlbGVjdEZlYXR1cmVFZmZlY3RUeXBlKHR5cGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGxheWVyIGVmZmVjdHNcbiAgICAgICAgY29uc3Qgc3dpdGNoTm9kZSA9IGl0ZW1Ob2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLXN3aXRjaFwiKTtcbiAgICAgICAgaWYgKHBvcG92ZXJzW3R5cGVdLm9wZW4pIHtcbiAgICAgICAgICAvLyBpZiBhbHJlYWR5IG9wZW4gdGhlbiBjbG9zZSBwb3BvdmVyIGFuZCB0b2dnbGUgb2ZmXG4gICAgICAgICAgcG9wb3ZlcnNbdHlwZV0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIHN3aXRjaE5vZGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIGl0ZW1Ob2RlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzQXBwbHlMYXllckVmZmVjdC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gc3dpdGNoIGVmZmVjdCBvblxuICAgICAgICAgIGlmICghc3dpdGNoTm9kZS5jaGVja2VkKSB7XG4gICAgICAgICAgICBzd2l0Y2hOb2RlLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzQXBwbHlMYXllckVmZmVjdC5lbWl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNsb3NlIG90aGVyIHBvcG92ZXJzXG4gICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICAgICAgcG9wb3ZlcnNba2V5XS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcG92ZXJzW3R5cGVdLm9wZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnZpZXcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYXllciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpZGVMYXllclRpdGxlID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlUmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5pc1Vuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5zaG93RmVhdHVyZUVmZmVjdHMgPSBmYWxzZTtcbiAgfVxuICBhcmNnaXNFZmZlY3RzQXBwbHlMYXllckVmZmVjdEhhbmRsZXIoZXZlbnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgcHJvcHMsIGxpc3ROb2RlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IHR5cGUgPSAoX2EgPSBldmVudC5kZXRhaWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlO1xuICAgIGlmICh0eXBlICYmICEoKF9iID0gZXZlbnQuZGV0YWlsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iua2VlcFN3aXRjaCkpIHtcbiAgICAgIC8vIHRvZ2dsZSBlZmZlY3Qgb24gaWYgaXQncyBub3QgYWxyZWFkeVxuICAgICAgY29uc3QgaXRlbU5vZGUgPSBBcnJheS5mcm9tKGxpc3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnZhbHVlID09PSB0eXBlKVswXTtcbiAgICAgIGl0ZW1Ob2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLXN3aXRjaFwiKS5jaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0cyA9IGJ1aWxkRWZmZWN0c0luZm8odGhpcy5saXN0Tm9kZSwgdGhpcy5wb3BvdmVycywgcHJvcHMpO1xuICAgIGxheWVyLmVmZmVjdCA9IGVmZmVjdHM7XG4gICAgdGhpcy5hcmNnaXNFZmZlY3RzQ2hhbmdlLmVtaXQoKTtcbiAgICBwcm9wcy5lZmZlY3RzSlNPTiA9IHBhcnNlRWZmZWN0cyhwcm9wcyk7XG4gICAgLy8gcmVmcmVzaCB0byBnZXQgdGhlIG51bWJlcnNcbiAgICAvL3RoaXMucmVSZW5kZXIgPSAhdGhpcy5yZVJlbmRlcjtcbiAgfVxuICBhcmNnaXNFZmZlY3RzUG9wb3ZlckZpbHRlckNoYW5nZUhhbmRsZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7IHByb3BzLCBob3N0RWxlbWVudCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyIH0gPSBwcm9wcztcbiAgICBjb25zdCB3aGVyZSA9IGV2ZW50LmRldGFpbDtcbiAgICBjb25zdCBpdGVtTm9kZSA9IEFycmF5LmZyb20oaG9zdEVsZW1lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikpLmZpbmQoKG5vZGUpID0+IG5vZGUuc2VsZWN0ZWQpO1xuICAgIGNvbnN0IHR5cGUgPSBpdGVtTm9kZSA9PT0gbnVsbCB8fCBpdGVtTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbU5vZGUudmFsdWU7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICAvLyB3ZSdyZSB0b28gZWFybHksIGJ1dCBuZWVkIHRvIGFwcGx5IHRoZSBmaWx0ZXIgbGF0ZXIgb25jZSBhIHR5cGUgZ2V0cyBzZWxlY3RlZFxuICAgICAgdGhpcy5kZWZhdWx0V2hlcmUgPSB3aGVyZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBhIGZlYXR1cmUgZWZmZWN0IHR5cGUgaXMgc2VsZWN0ZWRcbiAgICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBidWlsZEZlYXR1cmVFZmZlY3QodHlwZSwgd2hlcmUsIHByb3BzKTtcbiAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0NoYW5nZS5lbWl0KCk7XG4gICAgfVxuICB9XG4gIGFyY2dpc0VmZmVjdHNQb3BvdmVyQ2xvc2VIYW5kbGVyKCkge1xuICAgIGNvbnN0IHsgbGlzdE5vZGUsIGxpZ2h0TGlzdE5vZGUsIGRhcmtMaXN0Tm9kZSB9ID0gdGhpcztcbiAgICBsaXN0Tm9kZSA9PT0gbnVsbCB8fCBsaXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdE5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaXRlbS5zZXRGb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxpZ2h0TGlzdE5vZGUgPT09IG51bGwgfHwgbGlnaHRMaXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlnaHRMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgaXRlbS5zZXRGb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRhcmtMaXN0Tm9kZSA9PT0gbnVsbCB8fCBkYXJrTGlzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhcmtMaXN0Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgaXRlbS5zZXRGb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFB1YmxpYyBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIFNldCBmb2N1cyBvbiBjb21wb25lbnRcbiAgICovXG4gIGFzeW5jIHNldEZvY3VzKGZvY3VzSWQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghZm9jdXNJZCB8fCBmb2N1c0lkID09PSBcImRpc21pc3MtYnV0dG9uXCIpIHtcbiAgICAgIChfYSA9IHRoaXMucGFuZWxOb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKF9iID0gdGhpcy5saXN0Tm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldEZvY3VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFucyB1cCBjb21wb25lbnQsIGNsb3NlcyBwb3BvdmVyc1xuICAgKi9cbiAgYXN5bmMgZG9uZSgpIHtcbiAgICBjb25zdCB7IHBvcG92ZXJzIH0gPSB0aGlzO1xuICAgIC8vIGNsb3NlICBwb3BvdmVyc1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gcG9wb3ZlcnMpIHtcbiAgICAgIHBvcG92ZXJzW2tleV0ub3BlbiA9IGZhbHNlO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5XG4gICAgICAucXVlcnlTZWxlY3RvckFsbChcImFyY2dpcy1lZmZlY3RzLXBvcG92ZXJzXCIpXG4gICAgICAuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBMaWZlY3ljbGVcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICBjb25zdCB7IHZpZXcsIGxheWVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtzdHJpbmdzLCBjdXJyZW50TGFuZ3VhZ2VdID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIGNvbnN0IHN1cHBvcnRzRmVhdHVyZUVmZmVjdHMgPSAhbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbiAmJlxuICAgICAgW1wiZmVhdHVyZVwiLCBcImdlb2pzb25cIiwgXCJvZ2MtZmVhdHVyZVwiLCBcIndmc1wiLCBcImNzdlwiLCBcInN0cmVhbVwiXS5pbmRleE9mKGxheWVyLnR5cGUpID4gLTE7XG4gICAgdGhpcy5wcm9wcyA9IHsgdmlldywgbGF5ZXIsIHN0cmluZ3MsIHN1cHBvcnRzRmVhdHVyZUVmZmVjdHMgfTtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIHByb3BzLmxvY2FsZSA9IGN1cnJlbnRMYW5ndWFnZTtcbiAgICBjb25zdCBbRmVhdHVyZUVmZmVjdCwgZWZmZWN0c1V0aWxzLCBzY3JlZW5VdGlscywgY29sb3JVdGlsc10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICBcImVzcmkvbGF5ZXJzL3N1cHBvcnQvRmVhdHVyZUVmZmVjdFwiLFxuICAgICAgXCJlc3JpL2xheWVycy9lZmZlY3RzL2pzb25VdGlsc1wiLFxuICAgICAgXCJlc3JpL2NvcmUvc2NyZWVuVXRpbHNcIixcbiAgICAgIFwiZXNyaS92aWV3cy9zdXBwb3J0L2NvbG9yVXRpbHNcIlxuICAgIF0pO1xuICAgIHByb3BzLm1vZHVsZXMgPSB7IEZlYXR1cmVFZmZlY3QsIGVmZmVjdHNVdGlscywgc2NyZWVuVXRpbHMgfTtcbiAgICBwcm9wcy5iYWNrZ3JvdW5kVGhlbWUgPSB2aWV3ICYmIChhd2FpdCBjb2xvclV0aWxzLmdldEJhY2tncm91bmRDb2xvclRoZW1lKHZpZXcpKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYW55TGF5ZXIgPSBsYXllcjtcbiAgICAgIGlmIChhbnlMYXllci5lZmZlY3QgJiYgYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkge1xuICAgICAgICB0aGlzLmlzVW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYW55TGF5ZXIuZWZmZWN0KSB7XG4gICAgICAgIHByb3BzLmVmZmVjdHNKU09OID0gcGFyc2VFZmZlY3RzKHByb3BzKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImxheWVyLmVmZmVjdFwiLCAobGF5ZXIgYXMgYW55KS5lZmZlY3QsIHByb3BzLmVmZmVjdHNKU09OKTtcbiAgICAgICAgc29ydEVmZmVjdHMocHJvcHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYW55TGF5ZXIuZmVhdHVyZUVmZmVjdCkge1xuICAgICAgICBwcm9wcy5mZWF0dXJlRWZmZWN0VHlwZSA9IHBhcnNlRWZmZWN0cyhwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmlzVW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNldEZvY3VzKCkpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuZG9uZSgpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICAvLyBmaWx0ZXIgKDkuNCkgb25seSBmb3IgdGhlc2UgbGF5ZXIgdHlwZXMgKG5vdCBoZWF0bWFwKTogX19lc3JpLkZlYXR1cmVMYXllciB8IF9fZXNyaS5DU1ZMYXllciB8IF9fZXNyaS5XRlNMYXllciB8IF9fZXNyaS5TdHJlYW1MYXllclxuICAgIGNvbnN0IHsgaXNVbnN1cHBvcnRlZCB9ID0gdGhpcztcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogXCJjYWxjaXRlLW1hdGNoLWhlaWdodFwiIH0sIGgoXCJjYWxjaXRlLWZsb3dcIiwgeyBjbGFzczogQ1NTJDEuZmxvdywgZGlyOiBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpLCByZWY6IChub2RlKSA9PiAodGhpcy5mbG93Tm9kZSA9IG5vZGUpIH0sIGlzVW5zdXBwb3J0ZWQgPyB0aGlzLnJlbmRlclVuc3VwcG9ydGVkKCkgOiB0aGlzLnJlbmRlckNvbnRlbnQoKSkpKTtcbiAgfVxuICByZW5kZXJVbnN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCB7IHByb3BzLCBoaWRlTGF5ZXJUaXRsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgIHJldHVybiAoaChcImNhbGNpdGUtcGFuZWxcIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmdlbmVyYWwuZWZmZWN0cywgZGVzY3JpcHRpb246ICFoaWRlTGF5ZXJUaXRsZSA/IGxheWVyLnRpdGxlIDogdW5kZWZpbmVkLCBjbGFzczoge1xuICAgICAgICBbQ1NTJDEucGFuZWxdOiB0cnVlLFxuICAgICAgICBbQ1NTX1VUSUxJVFkucnRsXTogcnRsXG4gICAgICB9LCBjbG9zYWJsZTogdHJ1ZSwgb25DYWxjaXRlUGFuZWxDbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNDbG9zZS5lbWl0KCk7XG4gICAgICB9LCByZWY6IChub2RlKSA9PiAodGhpcy5wYW5lbE5vZGUgPSBub2RlKSB9LCBoKFwiY2FsY2l0ZS10aXBcIiwgeyBoZWFkaW5nOiBzdHJpbmdzLmVycm9yLnRpdGxlLCBjbG9zZURpc2FibGVkOiB0cnVlIH0sIGgoXCJkaXZcIiwgbnVsbCwgc3RyaW5ncy5lcnJvci50ZXh0MSksIGgoXCJkaXZcIiwgbnVsbCwgc3RyaW5ncy5lcnJvci50ZXh0MikpLCBoKFwiY2FsY2l0ZS1mYWJcIiwgeyBjbGFzczogXCJhdXRvZm9jdXNcIiwgc2xvdDogXCJmYWJcIiwgYXBwZWFyYW5jZTogXCJvdXRsaW5lLWZpbGxcIiwga2luZDogXCJuZXV0cmFsXCIsIHNjYWxlOiBcInNcIiwgdGV4dEVuYWJsZWQ6IHRydWUsIGljb246IG51bGwsIGxhYmVsOiBzdHJpbmdzLmVycm9yLmJ1dHRvbiwgdGV4dDogc3RyaW5ncy5lcnJvci5idXR0b24sIG9uQ2xpY2s6IHRoaXMub25SZW1vdmVFZmZlY3QgfSkpKTtcbiAgfVxuICByZW5kZXJDb250ZW50KCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIGhpZGVMYXllclRpdGxlLCBzaG93RmVhdHVyZUVmZmVjdHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXllciwgc3VwcG9ydHNGZWF0dXJlRWZmZWN0cywgc3RyaW5ncyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICBjb25zdCBoYXNGZWF0dXJlRWZmZWN0ID0gc3VwcG9ydHNGZWF0dXJlRWZmZWN0cyAmJiAhIWxheWVyLmZlYXR1cmVFZmZlY3Q7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1wYW5lbFwiLCB7IGhlYWRpbmc6IHN0cmluZ3MuZ2VuZXJhbC5lZmZlY3RzLCBkZXNjcmlwdGlvbjogIWhpZGVMYXllclRpdGxlID8gbGF5ZXIudGl0bGUgOiB1bmRlZmluZWQsIGNsYXNzOiB7XG4gICAgICAgIFtDU1MkMS5wYW5lbF06IHRydWUsXG4gICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgIH0sIGNsb3NhYmxlOiB0cnVlLCBvbkNhbGNpdGVQYW5lbENsb3NlOiAoKSA9PiB7XG4gICAgICAgIC8vIGNsb3NlIGFsbCBwb3BvdmVyc1xuICAgICAgICBjb25zdCB7IHBvcG92ZXJzIH0gPSB0aGlzO1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBwb3BvdmVycykge1xuICAgICAgICAgIHBvcG92ZXJzW2tleV0ub3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0Nsb3NlLmVtaXQoKTtcbiAgICAgIH0sIHJlZjogdGhpcy5hZnRlckNyZWF0ZVBhbmVsIH0sIHRoaXMucmVuZGVyVGlwKCksIHN1cHBvcnRzRmVhdHVyZUVmZmVjdHMgPyAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMS5yYWRpb0J1dHRvbnMgfSwgaChcImNhbGNpdGUtc2VnbWVudGVkLWNvbnRyb2xcIiwgeyBsYXlvdXQ6IFwiaG9yaXpvbnRhbFwiLCBhcHBlYXJhbmNlOiBcInNvbGlkXCIsIHNjYWxlOiBcInNcIiwgd2lkdGg6IFwiZnVsbFwiLCBvbkNhbGNpdGVTZWdtZW50ZWRDb250cm9sQ2hhbmdlOiB0aGlzLm9uU3dpdGNoRWZmZWN0VHlwZSB9LCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbC1pdGVtXCIsIHsgdmFsdWU6IFwibGF5ZXJcIiwgY2hlY2tlZDogIShoYXNGZWF0dXJlRWZmZWN0IHx8IHNob3dGZWF0dXJlRWZmZWN0cykgfSwgc3RyaW5ncy5nZW5lcmFsLndob2xlTGF5ZXIpLCBoKFwiY2FsY2l0ZS1zZWdtZW50ZWQtY29udHJvbC1pdGVtXCIsIHsgdmFsdWU6IFwiZmVhdHVyZVwiLCBjaGVja2VkOiBoYXNGZWF0dXJlRWZmZWN0IHx8IHNob3dGZWF0dXJlRWZmZWN0cyB9LCBzdHJpbmdzLmdlbmVyYWwuZmVhdHVyZVNwZWNpZmljKSkpKSA6IG51bGwsIGhhc0ZlYXR1cmVFZmZlY3QgfHwgc2hvd0ZlYXR1cmVFZmZlY3RzXG4gICAgICA/IHRoaXMucmVuZGVyRmVhdHVyZUVmZmVjdHNDb250ZW50KClcbiAgICAgIDogdGhpcy5yZW5kZXJMYXllckVmZmVjdHNDb250ZW50KCkpKTtcbiAgfVxuICByZW5kZXJUaXAoKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGlmIChnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5cy5BUkNHSVNfQ09NUE9ORU5UX05PVElGSUNBVElPTlMsIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLkVGRkVDVFNfVElQX0RJU01JU1NFRCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEubm90aWNlIH0sIGgoXCJjYWxjaXRlLW5vdGljZVwiLCB7IHNjYWxlOiBcInNcIiwgd2lkdGg6IFwiZnVsbFwiLCBvcGVuOiB0cnVlLCBjbG9zYWJsZTogdHJ1ZSwgb25DYWxjaXRlTm90aWNlQ2xvc2U6ICgpID0+IHtcbiAgICAgICAgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleXMuQVJDR0lTX0NPTVBPTkVOVF9OT1RJRklDQVRJT05TLCB7XG4gICAgICAgICAga2V5OiBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cy5FRkZFQ1RTX1RJUF9ESVNNSVNTRUQsXG4gICAgICAgICAgdmFsdWU6IFwidHJ1ZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSB9LCBoKFwiZGl2XCIsIHsgc2xvdDogXCJtZXNzYWdlXCIgfSwgc3RyaW5ncy5nZW5lcmFsLm5vdGljZSkpKSk7XG4gIH1cbiAgcmVuZGVyTGF5ZXJFZmZlY3RzQ29udGVudCgpIHtcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuaGludCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiB9LCBzdHJpbmdzLmdlbmVyYWwuZHJhZ1RvUmVvcmRlcikpLCBoKFwiY2FsY2l0ZS12YWx1ZS1saXN0XCIsIHsgY2xhc3M6IENTUyQxLmxpc3QsIGRyYWdFbmFibGVkOiB0cnVlLCBvbkNhbGNpdGVMaXN0T3JkZXJDaGFuZ2U6ICgpID0+IHRoaXMuYXJjZ2lzRWZmZWN0c0FwcGx5TGF5ZXJFZmZlY3QuZW1pdCgpLCByZWY6IChub2RlKSA9PiAodGhpcy5saXN0Tm9kZSA9IG5vZGUpIH0sIGFsbExheWVyRWZmZWN0VHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLnJlbmRlckxheWVyRWZmZWN0SXRlbSh0eXBlKSkpKSk7XG4gIH1cbiAgcmVuZGVyTGF5ZXJFZmZlY3RJdGVtKHR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGVmZmVjdHNKU09OLCBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBsZXQgZWZmZWN0UG9zID0gLTE7XG4gICAgZWZmZWN0c0pTT04gJiZcbiAgICAgICgoX2EgPSBBcnJheS5mcm9tKGVmZmVjdHNKU09OKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGVmZmVjdCwgaWR4KSA9PiB7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gY29udmVydFRvQVBJVHlwZSh0eXBlKSkge1xuICAgICAgICAgIGVmZmVjdFBvcyA9IGlkeCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiLCB7IGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNUaXRsZVt0eXBlXSwgZGVzY3JpcHRpb246IHN0cmluZ3MuZWZmZWN0c1N1bW1hcnlbdHlwZV0sIHZhbHVlOiB0eXBlLCBvbkNsaWNrOiB0aGlzLm9wZW5Qb3BvdmVyLCBvbktleURvd246IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGFjZSBrZXkgaXMgcmVzZXJ2ZWQgZm9yIGRyYWctbi1kcm9wXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiIFwiKSB7XG4gICAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50ID0gY29tcG9zZWRQYXRoWzBdO1xuICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnQudGFnTmFtZSAhPT0gXCJTUEFOXCIgfHwgIWZpcnN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJoYW5kbGVcIikpIHtcbiAgICAgICAgICAgIHRoaXMub3BlblBvcG92ZXIoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB9LCBoKFwiZGl2XCIsIHsgc2xvdDogXCJhY3Rpb25zLXN0YXJ0XCIsIGNsYXNzOiBDU1MkMS5lZmZlY3RUaHVtYiB9LCBoKFwiaW1nXCIsIHsgY2xhc3M6IENTUyQxLmVmZmVjdFRodW1iSW1nLFxuICAgICAgLy9jbGFzcz17YCR7Q1NTLmVmZmVjdFRodW1iSW1nfSAke2VmZmVjdFBvcyA+IDAgPyBgYmx1cmAgOiBgYH1gfVxuICAgICAgc3JjOiBnZXRBc3NldFBhdGgoYC4vYXNzZXRzL2VmZmVjdC10aHVtYnMvJHt0eXBlfS5wbmdgKSwgYWx0OiBcIlwiIH0pKSwgaChcImNhbGNpdGUtc3dpdGNoXCIsIHsgc2NhbGU6IFwic1wiLCBjaGVja2VkOiBlZmZlY3RQb3MgPiAwLCBzbG90OiBcImFjdGlvbnMtZW5kXCIsIGNsYXNzOiBDU1MkMS5zd2l0Y2gsIG9uQ2FsY2l0ZVN3aXRjaENoYW5nZTogdGhpcy5vblN3aXRjaENoYW5nZSB9KSkpO1xuICB9XG4gIHJlbmRlckZlYXR1cmVFZmZlY3RzQ29udGVudCgpIHtcbiAgICBjb25zdCB7IHByb3BzLCBsYXN0RmVhdHVyZUVmZmVjdCwgc3RyaW5ncyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyLCBiYWNrZ3JvdW5kVGhlbWUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzTGlnaHRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZFRoZW1lID09PSBcImxpZ2h0XCI7XG4gICAgY29uc3QgbGlnaHRDb250ZW50ID0gKGgoXCJkaXZcIiwgbnVsbCwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMS5iYXNlbWFwVHlwZSB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiB9LCBzdHJpbmdzLmdlbmVyYWwubGlnaHRCYXNlbWFwcykpLCBoKFwiY2FsY2l0ZS12YWx1ZS1saXN0XCIsIHsgY2xhc3M6IENTUyQxLmxpc3QsIFwiZGF0YS12YWx1ZVwiOiBcImxpZ2h0XCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLmxpZ2h0TGlzdE5vZGUgPSBub2RlKSB9LCBhbGxMaWdodEZlYXR1cmVFZmZlY3RUeXBlcy5tYXAoKHR5cGUpID0+IHRoaXMucmVuZGVyRmVhdHVyZUVmZmVjdEl0ZW0odHlwZSwgXCJsaWdodFwiKSkpKSk7XG4gICAgY29uc3QgZGFya0NvbnRlbnQgPSAoaChcImRpdlwiLCBudWxsLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUyQxLmJhc2VtYXBUeXBlIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiIH0sIHN0cmluZ3MuZ2VuZXJhbC5kYXJrQmFzZW1hcHMpKSwgaChcImNhbGNpdGUtdmFsdWUtbGlzdFwiLCB7IGNsYXNzOiBDU1MkMS5saXN0LCBcImRhdGEtdmFsdWVcIjogXCJkYXJrXCIsIHJlZjogKG5vZGUpID0+ICh0aGlzLmRhcmtMaXN0Tm9kZSA9IG5vZGUpIH0sIGFsbERhcmtGZWF0dXJlRWZmZWN0VHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLnJlbmRlckZlYXR1cmVFZmZlY3RJdGVtKHR5cGUsIFwiZGFya1wiKSkpKSk7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDEuaGludCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiB9LCBzdHJpbmdzLmdlbmVyYWwuZW1waGFzaXplKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIGxheW91dDogXCJpbmxpbmUtc3BhY2UtYmV0d2VlblwiIH0sIHN0cmluZ3MuZ2VuZXJhbC5lbmFibGVkLCBoKFwiY2FsY2l0ZS1zd2l0Y2hcIiwgeyBzY2FsZTogXCJzXCIsIGNoZWNrZWQ6ICEhKGxheWVyLmZlYXR1cmVFZmZlY3QgfHwgbGFzdEZlYXR1cmVFZmZlY3QpLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IHRoaXMub25GZWF0dXJlRWZmZWN0RW5hYmxlZFN3aXRjaENoYW5nZSwgcmVmOiAobm9kZSkgPT4gKHRoaXMuZW5hYmxlZFN3aXRjaE5vZGUgPSBub2RlKSB9KSkpLCBpc0xpZ2h0QmFja2dyb3VuZCA/IGxpZ2h0Q29udGVudCA6IGRhcmtDb250ZW50LCBpc0xpZ2h0QmFja2dyb3VuZCA/IGRhcmtDb250ZW50IDogbGlnaHRDb250ZW50KSk7XG4gIH1cbiAgcmVuZGVyRmVhdHVyZUVmZmVjdEl0ZW0odHlwZSwgdGhlbWUpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZmVhdHVyZUVmZmVjdFR5cGUsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGNvbnN0IGluTGlnaHQgPSBhbGxMaWdodEZlYXR1cmVFZmZlY3RUeXBlcy5maW5kKChmZVR5cGUpID0+IHR5cGUgPT09IGZlVHlwZSk7XG4gICAgY29uc3QgaW5EYXJrID0gYWxsRGFya0ZlYXR1cmVFZmZlY3RUeXBlcy5maW5kKChmZVR5cGUpID0+IHR5cGUgPT09IGZlVHlwZSk7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS12YWx1ZS1saXN0LWl0ZW1cIiwgeyBsYWJlbDogc3RyaW5ncy5mZWF0dXJlRWZmZWN0c1RpdGxlW3R5cGVdLCBkZXNjcmlwdGlvbjogc3RyaW5ncy5mZWF0dXJlRWZmZWN0c1N1bW1hcnlbdHlwZV0sIHZhbHVlOiB0eXBlLCBzZWxlY3RlZDogZmVhdHVyZUVmZmVjdFR5cGUgPT09IHR5cGUsIG9uQ2xpY2s6IHRoaXMub3BlblBvcG92ZXIsIG9uS2V5RG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIHRoaXMub3BlblBvcG92ZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwYWNlIGtleSBpcyByZXNlcnZlZCBmb3IgZHJhZy1uLWRyb3BcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBjb21wb3NlZFBhdGhbMF07XG4gICAgICAgICAgaWYgKGZpcnN0RWxlbWVudC50YWdOYW1lICE9PSBcIlNQQU5cIiB8fCAhZmlyc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImhhbmRsZVwiKSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuUG9wb3ZlcihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IH0sIGgoXCJkaXZcIiwgeyBzbG90OiBcImFjdGlvbnMtc3RhcnRcIiwgY2xhc3M6IENTUyQxLmVmZmVjdFRodW1iIH0sIGgoXCJpbWdcIiwgeyBjbGFzczogYCR7Q1NTJDEuZWZmZWN0VGh1bWJJbWd9IGZlYXR1cmVgLCBzcmM6IGdldEFzc2V0UGF0aChgLi9hc3NldHMvZWZmZWN0LXRodW1icy8ke3R5cGV9JHtpbkxpZ2h0ICYmIGluRGFyayA/IGBfJHt0aGVtZX1gIDogYGB9LnBuZ2ApLCBhbHQ6IFwiXCIgfSkpKSk7XG4gIH1cbiAgc2VsZWN0RmVhdHVyZUVmZmVjdFR5cGUodHlwZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBwb3BvdmVycywgcHJvcHMsIGxpZ2h0TGlzdE5vZGUsIGRhcmtMaXN0Tm9kZSwgZGVmYXVsdFdoZXJlLCBlbmFibGVkU3dpdGNoTm9kZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxheWVyIH0gPSBwcm9wcztcbiAgICBwcm9wcy5mZWF0dXJlRWZmZWN0VHlwZSA9IHR5cGU7XG4gICAgLy8gdW5zZWxlY3QgaXRlbSBmcm9tIHNlY29uZCBsaXN0XG4gICAgbGlnaHRMaXN0Tm9kZSA9PT0gbnVsbCB8fCBsaWdodExpc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaWdodExpc3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXZhbHVlLWxpc3QtaXRlbVwiKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS5zZWxlY3RlZCAmJiBpdGVtLnZhbHVlICE9PSB0eXBlKSB7XG4gICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkYXJrTGlzdE5vZGUgPT09IG51bGwgfHwgZGFya0xpc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXJrTGlzdE5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtdmFsdWUtbGlzdC1pdGVtXCIpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnNlbGVjdGVkICYmIGl0ZW0udmFsdWUgIT09IHR5cGUpIHtcbiAgICAgICAgaXRlbS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGZlYXR1cmUgZWZmZWN0c1xuICAgIGxheWVyLmZlYXR1cmVFZmZlY3QgPSBidWlsZEZlYXR1cmVFZmZlY3QodHlwZSwgKChfYiA9IChfYSA9IGxheWVyLmZlYXR1cmVFZmZlY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aGVyZSkgfHwgZGVmYXVsdFdoZXJlLCBwcm9wcyk7XG4gICAgdGhpcy5kZWZhdWx0V2hlcmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hcmNnaXNFZmZlY3RzQ2hhbmdlLmVtaXQoKTtcbiAgICBjb25zdCBwb3BvdmVyID0gcG9wb3ZlcnNbXCJmZWF0dXJlRWZmZWN0XCJdO1xuICAgIGlmIChwb3BvdmVyLm9wZW4pIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgb3BlbiB0aGVuIGp1c3QgcmVuYW1lIHRpdGxlXG4gICAgICBwb3BvdmVyLnVwZGF0ZUhlYWRlcih0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBjbG9zZSBvdGhlciBwb3BvdmVyc1xuICAgICAgbGV0IGtleTtcbiAgICAgIGZvciAoa2V5IGluIHBvcG92ZXJzKSB7XG4gICAgICAgIHBvcG92ZXJzW2tleV0ub3BlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcG9wb3Zlci5vcGVuID0gdHJ1ZTtcbiAgICAgIHBvcG92ZXIudXBkYXRlSGVhZGVyKHR5cGUpO1xuICAgIH1cbiAgICBpZiAoZW5hYmxlZFN3aXRjaE5vZGUpIHtcbiAgICAgIC8vIGFmdGVyIGEgbGlzdCBjbGlja1xuICAgICAgZW5hYmxlZFN3aXRjaE5vZGUuY2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYWZ0ZXIgYSBsYXllciBlZmZlY3QgLT4gZmVhdHVyZSBlZmZlY3Qgc3dpdGNoXG4gICAgICB0aGlzLnJlUmVuZGVyID0gIXRoaXMucmVSZW5kZXI7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcImFzc2V0c1wiXTsgfVxuICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzRWZmZWN0cy5zdHlsZSA9IGFyY2dpc0VmZmVjdHNDc3M7XG5cbmNvbnN0IENTUyA9IHtcbiAgcG9wb3ZlcjogXCJwb3BvdmVyXCIsXG4gIHBhbmVsOiBcInBhbmVsXCIsXG4gIGF1dG86IFwiYXV0b1wiLFxuICBjb250ZW50OiBcImVmZmVjdHMtY29udGVudFwiLFxuICBib3R0b21TcGFjZTogXCJib3R0b20tc3BhY2VcIixcbiAgYm90dG9tU3BhY2VMaXR0bGU6IFwiYm90dG9tLXNwYWNlLWxpdHRsZVwiLFxuICBzd2l0Y2g6IFwic3dpdGNoXCIsXG4gIHJlc2V0OiBcInJlc2V0XCIsXG4gIHN1YkhlYWRlcjogXCJzdWItaGVhZGVyXCJcbn07XG5cbmNvbnN0IFNlbGVjdENTUyQxID0ge1xuICBiYXNlOiBcInNlbGVjdC1udW1iZXJcIixcbiAgaW5wdXQ6IFwic2VsZWN0LW51bWJlcl9faW5wdXRcIlxufTtcbmNvbnN0IHN0ZXBwZXJDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyQxID0gKGV2ZW50KSA9PiB7XG4gIC8vIHdvcmthcm91bmQgZm9yIGNhbGNpdGUtbGFiZWwgd3JhcHBlZCBTZWxlY3ROdW1iZXIgZm9jdXMgYnVnXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcbmNvbnN0IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzID0gKGV2ZW50KSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIC8vIHdvcmthcm91bmQgZm9yIGNhbGNpdGUtbGFiZWwgd3JhcHBlZCBTZWxlY3ROdW1iZXIgZm9jdXMgYnVnXG4gIChfYiA9IChfYSA9IGV2ZW50LnRhcmdldCkuc2V0Rm9jdXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG5jb25zdCBTZWxlY3ROdW1iZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBkaXNhYmxlZCwgbWluLCBtYXgsIHN0ZXAsIHZhbHVlLCB1bml0cywgY2xhc3NOYW1lcywgbGFiZWwgfSA9IHByb3BzO1xuICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogYCR7U2VsZWN0Q1NTJDEuYmFzZX0gJHtjbGFzc05hbWVzfWAgfSxcbiAgICBoKFwiY2FsY2l0ZS1zbGlkZXJcIiwgeyBkaXNhYmxlZDogZGlzYWJsZWQsIG1pbjogbWluLCBtYXg6IG1heCwgdmFsdWU6IHZhbHVlLCBzdGVwOiBzdGVwLCBzbmFwOiB0cnVlLCBsYWJlbFRpY2tzOiB0cnVlLCB0aWNrczogbWF4IC0gbWluLCBtaW5MYWJlbDogbGFiZWwsIG9uQ2FsY2l0ZVNsaWRlcklucHV0OiAoZXZlbnQpID0+IGFwcGx5VmFsdWVPbkNoYW5nZSQxKGV2ZW50LCBwcm9wcykgfSksXG4gICAgaChcImNhbGNpdGUtaW5wdXRcIiwgeyB0eXBlOiBcIm51bWJlclwiLCBvbkNsaWNrOiBzdGVwcGVyQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMkMSwgZGlzYWJsZWQ6IGRpc2FibGVkLCBtaW46IG1pbiwgbWF4OiBtYXgsIHZhbHVlOiBgJHt2YWx1ZX1gLCBzY2FsZTogXCJzXCIsIHN0ZXA6IHN0ZXAsIHN1ZmZpeFRleHQ6IHVuaXRzLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZXZlbnQpID0+IGFwcGx5VmFsdWVPbkNoYW5nZSQxKGV2ZW50LCBwcm9wcyksIGNsYXNzOiBTZWxlY3RDU1MkMS5pbnB1dCwgbGFiZWw6IGxhYmVsIH0pKSk7XG59O1xuZnVuY3Rpb24gYXBwbHlWYWx1ZU9uQ2hhbmdlJDEoZXZlbnQsIHByb3BzKSB7XG4gIGNvbnN0IHsgbG9jYWxlIH0gPSBwcm9wcztcbiAgY29uc3Qgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IHNsaWRlck5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpO1xuICBjb25zdCBpbnB1dE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIik7XG4gIGNvbnN0IHZhbHVlID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICBjb25zdCBjbGFtcGVkID0gTWF0aC5taW4ocHJvcHMubWF4LCBNYXRoLm1heChwcm9wcy5taW4sIHZhbHVlKSk7XG4gIGlmIChjbGFtcGVkID09PSBzbGlkZXJOb2RlLnZhbHVlICYmIGAke2NsYW1wZWR9YCA9PT0gaW5wdXROb2RlLnZhbHVlKSB7XG4gICAgLy8gbm8gY2hhbmdlc1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlbnN1cmUgdmFsdWUgd2Ugc2hvdyBpcyB3aXRoaW4gYWxsb3dlZCByYW5nZVxuICBzbGlkZXJOb2RlLnZhbHVlID0gY2xhbXBlZDtcbiAgaW5wdXROb2RlLnZhbHVlID0gYCR7Y2xhbXBlZH1gO1xuICAvLyBUT0RPIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9pc3N1ZXMvMzAwM1xuICBjb25zdCBjbGFtcGVkU3RyaW5nID0gY2xhbXBlZC50b0xvY2FsZVN0cmluZyhsb2NhbGUpO1xuICBpbnB1dE5vZGVcbiAgICAucXVlcnlTZWxlY3RvckFsbChcImlucHV0XCIpXG4gICAgLmZvckVhY2goKGlucHV0KSA9PiAoaW5wdXQudmFsdWUgPSBjbGFtcGVkU3RyaW5nKSk7XG4gIHByb3BzLm9uVmFsdWVDaGFuZ2UoY2xhbXBlZCwgbm9kZSk7XG59XG5cbmNvbnN0IFNlbGVjdENTUyA9IHtcbiAgYmFzZTogXCJzZWxlY3QteHlcIixcbiAgaW5wdXQ6IFwic2VsZWN0LXh5X19pbnB1dFwiXG59O1xuY29uc3Qgc3RlcHBlckNsaWNrSGFuZGxlckZvclByb3BlckZvY3VzID0gKGV2ZW50KSA9PiB7XG4gIC8vIHdvcmthcm91bmQgZm9yIGNhbGNpdGUtbGFiZWwgd3JhcHBlZCBTZWxlY3RYeSBmb2N1cyBidWdcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuY29uc3QgU2VsZWN0WHkgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBtaW4sIG1heCwgc3RlcCwgeCwgeSwgY2xhc3NOYW1lcywgc3RyaW5ncywgbG9jYWxlIH0gPSBwcm9wcztcbiAgbGV0IGhvc3ROb2RlO1xuICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogYCR7U2VsZWN0Q1NTLmJhc2V9ICR7Y2xhc3NOYW1lc31gLCByZWY6IChub2RlKSA9PiAoaG9zdE5vZGUgPSBub2RlKSB9LFxuICAgIGgoXCJhcmNnaXMteHktc2xpZGVyXCIsIHsgXCJkYXRhLXZhbHVlXCI6IFwic2xpZGVyXCIsIG1pblg6IG1pbiwgbWF4WDogbWF4LCBtaW5ZOiBtaW4sIG1heFk6IG1heCwgeDogeCwgeTogeSwgc3RlcDogc3RlcCwgc25hcHBhYmxlOiB0cnVlLCBvbkFyY2dpc1hZU2xpZGVySW5wdXQ6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBzbGlkZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICBjb25zdCBlbWl0dGluZ0FjdGl2ZUZsYWdBdHRyaWJ1dGUgPSBcImRhdGEtYWN0aXZlXCI7XG4gICAgICAgIC8vIHdlIGlnbm9yZSB0aGUgZmlyc3QgZXZlbnQgc2luY2UgaXQncyBjYXVzZWQgYnkgdGhlXG4gICAgICAgIC8vIHZhbHVlIHNuYXBwaW5nIHRvIGEgc3RlcCBpbnRlcnZhbCBkdXJpbmcgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFzbGlkZXIuaGFzQXR0cmlidXRlKGVtaXR0aW5nQWN0aXZlRmxhZ0F0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBzbGlkZXIuc2V0QXR0cmlidXRlKGVtaXR0aW5nQWN0aXZlRmxhZ0F0dHJpYnV0ZSwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5VmFsdWVPbkNoYW5nZShldmVudCwgcHJvcHMsIGhvc3ROb2RlKTtcbiAgICAgIH0gfSksXG4gICAgaChcImRpdlwiLCBudWxsLFxuICAgICAgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSxcbiAgICAgICAgc3RyaW5ncy5lZmZlY3RzUHJvcHMueE9mZnNldCxcbiAgICAgICAgaChcImNhbGNpdGUtaW5wdXRcIiwgeyBcImRhdGEtdmFsdWVcIjogXCJ4XCIsIHR5cGU6IFwibnVtYmVyXCIsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCwgbGFuZzogbG9jYWxlLCB2YWx1ZTogYCR7eH1gLCBjbGFzczogU2VsZWN0Q1NTLmlucHV0LCBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IHN0ZXBwZXJDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cywgb25DYWxjaXRlSW5wdXRJbnB1dDogKGV2ZW50KSA9PiBhcHBseVZhbHVlT25DaGFuZ2UoZXZlbnQsIHByb3BzLCBob3N0Tm9kZSkgfSkpLFxuICAgICAgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSxcbiAgICAgICAgc3RyaW5ncy5lZmZlY3RzUHJvcHMueU9mZnNldCxcbiAgICAgICAgaChcImNhbGNpdGUtaW5wdXRcIiwgeyBcImRhdGEtdmFsdWVcIjogXCJ5XCIsIHR5cGU6IFwibnVtYmVyXCIsIG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCwgbGFuZzogbG9jYWxlLCB2YWx1ZTogYCR7eX1gLCBjbGFzczogU2VsZWN0Q1NTLmlucHV0LCBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IHN0ZXBwZXJDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cywgb25DYWxjaXRlSW5wdXRJbnB1dDogKGV2ZW50KSA9PiBhcHBseVZhbHVlT25DaGFuZ2UoZXZlbnQsIHByb3BzLCBob3N0Tm9kZSkgfSkpKSkpO1xufTtcbmZ1bmN0aW9uIGFwcGx5VmFsdWVPbkNoYW5nZShldmVudCwgcHJvcHMsIGhvc3ROb2RlKSB7XG4gIGNvbnN0IHsgc3RlcCwgbG9jYWxlIH0gPSBwcm9wcztcbiAgY29uc3Qgbm9kZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IGRhdGFWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKTtcbiAgY29uc3Qgc2xpZGVyTm9kZSA9IGhvc3ROb2RlLnF1ZXJ5U2VsZWN0b3IoXCJhcmNnaXMteHktc2xpZGVyXCIpO1xuICBjb25zdCBpbnB1dE5vZGVzID0gaG9zdE5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtaW5wdXRcIik7XG4gIGNvbnN0IG9yaWdWYWx1ZVggPSBOdW1iZXIoZGF0YVZhbHVlID09PSBcInNsaWRlclwiXG4gICAgPyBub2RlLnhcbiAgICA6IGRhdGFWYWx1ZSA9PT0gXCJ4XCJcbiAgICAgID8gbm9kZS52YWx1ZVxuICAgICAgOiBpbnB1dE5vZGVzWzBdLnZhbHVlKTtcbiAgY29uc3Qgb3JpZ1ZhbHVlWSA9IE51bWJlcihkYXRhVmFsdWUgPT09IFwic2xpZGVyXCJcbiAgICA/IG5vZGUueVxuICAgIDogZGF0YVZhbHVlID09PSBcInlcIlxuICAgICAgPyBub2RlLnZhbHVlXG4gICAgICA6IGlucHV0Tm9kZXNbMV0udmFsdWUpO1xuICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgZ2V0IG1vcmUgcHJlY2lzaW9uIHRoYW4gc3RlcFxuICAvLyBzbGlkZXIgcmV0dXJucyB2YWx1ZXMgbGlrZSAxLjkwMDAwMDAwMDAwMDAwMDEgKCMyOTI4KVxuICBjb25zdCBkZWNpbWFsc0NvdW50ID0gY291bnREZWNpbWFsRGlnaXRzKHN0ZXApO1xuICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHNDb3VudCk7XG4gIGNvbnN0IHggPSBNYXRoLnJvdW5kKG9yaWdWYWx1ZVggKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBjb25zdCB5ID0gTWF0aC5yb3VuZChvcmlnVmFsdWVZICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgY29uc3QgeENsYW1wZWQgPSBNYXRoLm1pbihwcm9wcy5tYXgsIE1hdGgubWF4KHByb3BzLm1pbiwgeCkpO1xuICBjb25zdCB5Q2xhbXBlZCA9IE1hdGgubWluKHByb3BzLm1heCwgTWF0aC5tYXgocHJvcHMubWluLCB5KSk7XG4gIGlmICh4Q2xhbXBlZCA9PT0gc2xpZGVyTm9kZS54ICYmXG4gICAgYCR7eENsYW1wZWR9YCA9PT0gaW5wdXROb2Rlc1swXS52YWx1ZSAmJlxuICAgIHlDbGFtcGVkID09PSBzbGlkZXJOb2RlLnkgJiZcbiAgICBgJHt5Q2xhbXBlZH1gID09PSBpbnB1dE5vZGVzWzFdLnZhbHVlKSB7XG4gICAgLy8gbm8gY2hhbmdlc1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlbnN1cmUgdmFsdWUgd2Ugc2hvdyBpcyB3aXRoaW4gYWxsb3dlZCByYW5nZVxuICBzbGlkZXJOb2RlLnggPSB4Q2xhbXBlZDtcbiAgc2xpZGVyTm9kZS55ID0geUNsYW1wZWQ7XG4gIGlucHV0Tm9kZXNbMF0udmFsdWUgPSBgJHt4Q2xhbXBlZH1gO1xuICBpbnB1dE5vZGVzWzFdLnZhbHVlID0gYCR7eUNsYW1wZWR9YDtcbiAgLy8gVE9ETyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvaXNzdWVzLzMwMDNcbiAgY29uc3QgeENsYW1wZWRTdHJpbmcgPSB4Q2xhbXBlZC50b0xvY2FsZVN0cmluZyhsb2NhbGUpO1xuICBjb25zdCB5Q2xhbXBlZFN0cmluZyA9IHlDbGFtcGVkLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG4gIGlucHV0Tm9kZXNbMF1cbiAgICAucXVlcnlTZWxlY3RvckFsbChcImlucHV0XCIpXG4gICAgLmZvckVhY2goKGlucHV0KSA9PiAoaW5wdXQudmFsdWUgPSB4Q2xhbXBlZFN0cmluZykpO1xuICBpbnB1dE5vZGVzWzFdXG4gICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKVxuICAgIC5mb3JFYWNoKChpbnB1dCkgPT4gKGlucHV0LnZhbHVlID0geUNsYW1wZWRTdHJpbmcpKTtcbiAgcHJvcHMub25WYWx1ZUNoYW5nZSh4Q2xhbXBlZCwgeUNsYW1wZWQsIG5vZGUpO1xufVxuZnVuY3Rpb24gY291bnREZWNpbWFsRGlnaXRzKG51bWJlcikge1xuICBpZiAobnVtYmVyID09PSBudWxsIHx8IG51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgY2hhcl9hcnJheSA9IG51bWJlci50b1N0cmluZygpLnNwbGl0KFwiXCIpOyAvLyBzcGxpdCBldmVyeSBzaW5nbGUgY2hhclxuICBjb25zdCBub3RfZGVjaW1hbCA9IGNoYXJfYXJyYXkubGFzdEluZGV4T2YoXCIuXCIpO1xuICByZXR1cm4gbm90X2RlY2ltYWwgPCAwID8gMCA6IGNoYXJfYXJyYXkubGVuZ3RoIC0gbm90X2RlY2ltYWw7XG59XG5cbmNvbnN0IGFyY2dpc0VmZmVjdHNQb3BvdmVyc0NzcyA9IFwiLnNlbGVjdC1udW1iZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjtwb3NpdGlvbjpyZWxhdGl2ZX0uc2VsZWN0LW51bWJlci5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVycyBjYWxjaXRlLXNsaWRlci5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVyc3t3aWR0aDo1OCU7aGVpZ2h0OjMwcHg7bWFyZ2luOjAgNHB4O292ZXJmbG93LXdyYXA6bm9ybWFsO3dvcmQtYnJlYWs6bm9ybWFsfS5zZWxlY3QtbnVtYmVyX19pbnB1dC5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVyc3t3aWR0aDozNSU7Zm9udC1zaXplOnZhcigtLWFyY2dpcy1hcHAtZm9udC1zaXplLTApO2ZvbnQtZmFtaWx5OnZhcigtLWFyY2dpcy1hcHAtZm9udC1mYW1pbHkpfS5zZWxlY3QteHkuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn0uc2VsZWN0LXh5LnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJzIGFyY2dpcy14eS1zbGlkZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7d2lkdGg6MTIwcHg7bWluLXdpZHRoOjEyMHB4O21hcmdpbjowIDEwcHh9LnNlbGVjdC14eV9faW5wdXQuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7d2lkdGg6MTAwJTtmb250LXNpemU6dmFyKC0tYXJjZ2lzLWFwcC1mb250LXNpemUtMCk7Zm9udC1mYW1pbHk6dmFyKC0tYXJjZ2lzLWFwcC1mb250LWZhbWlseSl9LnBvcG92ZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7ei1pbmRleDo5OX0ucGFuZWwuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7d2lkdGg6MzI1cHh9LnBhbmVsLmZpbHRlci5zYy1hcmNnaXMtZWZmZWN0cy1wb3BvdmVyc3ttaW4taGVpZ2h0OjUwMHB4O2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1iYWNrZ3JvdW5kKX0uZWZmZWN0cy1jb250ZW50LnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze3BhZGRpbmc6MXJlbTtiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO21heC1oZWlnaHQ6ODB2aH0uYm90dG9tLXNwYWNlLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze21hcmdpbi1ib3R0b206MS41cmVtfS5ib3R0b20tc3BhY2UtbGl0dGxlLnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze21hcmdpbi1ib3R0b206MC41cmVtfS5zd2l0Y2guc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LnJlc2V0LnNjLWFyY2dpcy1lZmZlY3RzLXBvcG92ZXJze2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LnN1Yi1oZWFkZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7bWFyZ2luLWxlZnQ6MC43NXJlbTttYXJnaW4tcmlnaHQ6MH0uYXJjZ2lzLS1ydGwuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnMgLnN1Yi1oZWFkZXIuc2MtYXJjZ2lzLWVmZmVjdHMtcG9wb3ZlcnN7bWFyZ2luLXJpZ2h0OjAuNzVyZW07bWFyZ2luLWxlZnQ6MH1cIjtcblxuY29uc3QgQXJjZ2lzRWZmZWN0c1BvcG92ZXJzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICB0aGlzLmFyY2dpc0VmZmVjdHNBcHBseUxheWVyRWZmZWN0ID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNFZmZlY3RzQXBwbHlMYXllckVmZmVjdFwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc0VmZmVjdHNQb3BvdmVyRmlsdGVyQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNFZmZlY3RzUG9wb3ZlckZpbHRlckNoYW5nZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc0VmZmVjdHNQb3BvdmVyQ2xvc2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc0VmZmVjdHNQb3BvdmVyQ2xvc2VcIiwgNyk7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgUHJvcGVydGllc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMuZGVmYXVsdEV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLm9uT3BlbiA9ICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5jbG9zZU5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KSwgMSk7XG4gICAgfTtcbiAgICB0aGlzLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLmZpbHRlck5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZVBvcG92ZXJzKCk7XG4gICAgfTtcbiAgICB0aGlzLm9uUHJvcENoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdHlwZSB9ID0gdGhpcztcbiAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0FwcGx5TGF5ZXJFZmZlY3QuZW1pdCh7IHR5cGUgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uUmVzZXQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwb3BvdmVyTm9kZSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gcHJvcHM7XG4gICAgICBjb25zdCB7IHNjcmVlblV0aWxzIH0gPSBtb2R1bGVzO1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBsYXllckVmZmVjdERlZmF1bHRzW3R5cGVdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9vbVwiOiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRzID0gcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtaW5wdXRcIik7XG4gICAgICAgICAgaW5wdXRzWzBdLnZhbHVlID0gYCR7ZGVmYXVsdHMuc3RyZW5ndGh9YDtcbiAgICAgICAgICBpbnB1dHNbMV0udmFsdWUgPSBgJHtzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0cy5yYWRpdXMpfWA7XG4gICAgICAgICAgaW5wdXRzWzJdLnZhbHVlID0gYCR7TWF0aC5yb3VuZChkZWZhdWx0cy50aHJlc2hvbGQgKiAxMDApfWA7XG4gICAgICAgICAgY29uc3Qgc2xpZGVycyA9IHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLXNsaWRlclwiKTtcbiAgICAgICAgICBzbGlkZXJzWzBdLnZhbHVlID0gZGVmYXVsdHMuc3RyZW5ndGg7XG4gICAgICAgICAgc2xpZGVyc1sxXS52YWx1ZSA9IHNjcmVlblV0aWxzLnB0MnB4KGRlZmF1bHRzLnJhZGl1cyk7XG4gICAgICAgICAgc2xpZGVyc1syXS52YWx1ZSA9IE1hdGgucm91bmQoZGVmYXVsdHMudGhyZXNob2xkICogMTAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZHJvcFNoYWRvd1wiOiB7XG4gICAgICAgICAgbGV0IGdlb21ldHJ5VHlwZSA9IGdldFNpbXBsZUdlb21ldHJ5VHlwZShwcm9wcyk7XG4gICAgICAgICAgY29uc3QgY29sb3JQaWNrZXIgPSBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1jb2xvci1waWNrZXJcIik7XG4gICAgICAgICAgY29sb3JQaWNrZXIudmFsdWUgPSBgJHt0aGlzLnJnYjJIZXgoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS5jb2xvcil9YDtcbiAgICAgICAgICBjb25zdCBpbnB1dHMgPSBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS1pbnB1dFwiKTtcbiAgICAgICAgICBpbnB1dHNbMF0udmFsdWUgPSBgJHtNYXRoLnJvdW5kKHNjcmVlblV0aWxzLnB0MnB4KGRlZmF1bHRzW2dlb21ldHJ5VHlwZV0uYmx1clJhZGl1cykpfWA7XG4gICAgICAgICAgaW5wdXRzWzFdLnZhbHVlID0gYCR7TWF0aC5yb3VuZChzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0c1tnZW9tZXRyeVR5cGVdLnhvZmZzZXQpKX1gO1xuICAgICAgICAgIGlucHV0c1syXS52YWx1ZSA9IGAke01hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS55b2Zmc2V0KSl9YDtcbiAgICAgICAgICBpbnB1dHNbM10udmFsdWUgPSBgJHsoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS5jb2xvclszXSAvIDI1NSkgKiAxMDB9YDtcbiAgICAgICAgICBjb25zdCBzbGlkZXJzID0gcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvckFsbChcImNhbGNpdGUtc2xpZGVyXCIpO1xuICAgICAgICAgIHNsaWRlcnNbMF0udmFsdWUgPSBNYXRoLnJvdW5kKHNjcmVlblV0aWxzLnB0MnB4KGRlZmF1bHRzW2dlb21ldHJ5VHlwZV0uYmx1clJhZGl1cykpO1xuICAgICAgICAgIHNsaWRlcnNbMV0udmFsdWUgPSAoZGVmYXVsdHNbZ2VvbWV0cnlUeXBlXS5jb2xvclszXSAvIDI1NSkgKiAxMDA7XG4gICAgICAgICAgY29uc3QgeHlTbGlkZXJzID0gcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvckFsbChcImFyY2dpcy14eS1zbGlkZXJcIik7XG4gICAgICAgICAgeHlTbGlkZXJzWzBdLnggPSBNYXRoLnJvdW5kKHNjcmVlblV0aWxzLnB0MnB4KGRlZmF1bHRzW2dlb21ldHJ5VHlwZV0ueG9mZnNldCkpO1xuICAgICAgICAgIHh5U2xpZGVyc1swXS55ID0gTWF0aC5yb3VuZChzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0c1tnZW9tZXRyeVR5cGVdLnlvZmZzZXQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmx1clwiOiB7XG4gICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIikudmFsdWUgPSBgJHtzY3JlZW5VdGlscy5wdDJweChkZWZhdWx0cy5yYWRpdXMpfWA7XG4gICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gc2NyZWVuVXRpbHMucHQycHgoZGVmYXVsdHMucmFkaXVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYnJpZ2h0bmVzc0NvbnRyYXN0XCI6IHtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0c0JyaWdodG5lc3MgPSBsYXllckVmZmVjdERlZmF1bHRzW1wiYnJpZ2h0bmVzc1wiXTtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0c0NvbnRyYXN0ID0gbGF5ZXJFZmZlY3REZWZhdWx0c1tcImNvbnRyYXN0XCJdO1xuICAgICAgICAgIGNvbnN0IGlucHV0cyA9IHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjYWxjaXRlLWlucHV0XCIpO1xuICAgICAgICAgIGlucHV0c1swXS52YWx1ZSA9IGAke01hdGgucm91bmQoZGVmYXVsdHNCcmlnaHRuZXNzLmFtb3VudCAqIDEwMCl9YDtcbiAgICAgICAgICBpbnB1dHNbMV0udmFsdWUgPSBgJHtNYXRoLnJvdW5kKGRlZmF1bHRzQ29udHJhc3QuYW1vdW50ICogMTAwKX1gO1xuICAgICAgICAgIGNvbnN0IHNsaWRlcnMgPSBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiY2FsY2l0ZS1zbGlkZXJcIik7XG4gICAgICAgICAgc2xpZGVyc1swXS52YWx1ZSA9IE1hdGgucm91bmQoZGVmYXVsdHNCcmlnaHRuZXNzLmFtb3VudCAqIDEwMCk7XG4gICAgICAgICAgc2xpZGVyc1sxXS52YWx1ZSA9IE1hdGgucm91bmQoZGVmYXVsdHNDb250cmFzdC5hbW91bnQgKiAxMDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJncmF5c2NhbGVcIjoge1xuICAgICAgICAgIHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpLnZhbHVlID0gYCR7ZGVmYXVsdHMuYW1vdW50ICogMTAwfWA7XG4gICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gZGVmYXVsdHMuYW1vdW50ICogMTAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJodWVSb3RhdGVcIjoge1xuICAgICAgICAgIHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpLnZhbHVlID0gYCR7ZGVmYXVsdHMuYW5nbGV9YDtcbiAgICAgICAgICBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1zbGlkZXJcIikudmFsdWUgPSBkZWZhdWx0cy5hbmdsZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic2F0dXJhdGVcIjoge1xuICAgICAgICAgIHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpLnZhbHVlID0gYCR7ZGVmYXVsdHMuYW1vdW50ICogMTAwfWA7XG4gICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gZGVmYXVsdHMuYW1vdW50ICogMTAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbnZlcnRcIjoge1xuICAgICAgICAgIHBvcG92ZXJOb2RlLnF1ZXJ5U2VsZWN0b3IoXCJjYWxjaXRlLWlucHV0XCIpLnZhbHVlID0gYCR7ZGVmYXVsdHMuYW1vdW50ICogMTAwfWA7XG4gICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtc2xpZGVyXCIpLnZhbHVlID0gZGVmYXVsdHMuYW1vdW50ICogMTAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzZXBpYVwiOiB7XG4gICAgICAgICAgcG9wb3Zlck5vZGUucXVlcnlTZWxlY3RvcihcImNhbGNpdGUtaW5wdXRcIikudmFsdWUgPSBgJHtkZWZhdWx0cy5hbW91bnQgKiAxMDB9YDtcbiAgICAgICAgICBwb3BvdmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwiY2FsY2l0ZS1zbGlkZXJcIikudmFsdWUgPSBkZWZhdWx0cy5hbW91bnQgKiAxMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYXJjZ2lzRWZmZWN0c0FwcGx5TGF5ZXJFZmZlY3QuZW1pdCh7IHR5cGUgfSk7XG4gICAgfTtcbiAgICB0aGlzLnByb3BzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudHlwZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgICB0aGlzLnJlZmVyZW5jZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3BvdmVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBwdWJsaWMgY2FsbHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyByZXBvc2l0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLnBvcG92ZXJOb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwb3NpdGlvbigpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUhlYWRlcih0eXBlKSB7XG4gICAgY29uc3QgeyBwcm9wcywgZmlsdGVyTm9kZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGlmIChmaWx0ZXJOb2RlKSB7XG4gICAgICAvLyBjbG9zZSBmaWVsZC1waWNrLWxpc3RcbiAgICAgIGZpbHRlck5vZGUuY2xvc2VQb3BvdmVycygpO1xuICAgICAgZmlsdGVyTm9kZS5wYW5lbEhlYWRpbmcgPSBzdHJpbmdzLmZlYXR1cmVFZmZlY3RzVGl0bGVbdHlwZV0gfHwgc3RyaW5ncy5lZmZlY3RzVGl0bGVbdHlwZV07XG4gICAgfVxuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsYXllciB9ID0gcHJvcHM7XG4gICAgaWYgKCFsYXllci5mZWF0dXJlRWZmZWN0KSB7XG4gICAgICAvLyBkb24ndCBzdGFydCB3aXRoIGVtcHR5IGZpbHRlciwgaWYgcG9zc2libGVcbiAgICAgIHRoaXMuZGVmYXVsdEV4cHJlc3Npb24gPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBwcm9wcywgcmVmZXJlbmNlRWxlbWVudCwgdHlwZSwgb3BlbiB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5ob3N0RWxlbWVudCkgPT09IFwicnRsXCI7XG4gICAgY29uc3QgaXNMb25nUG9wb3ZlciA9IFtcImZlYXR1cmVFZmZlY3RcIiwgXCJkcm9wU2hhZG93XCJdLmluZGV4T2YodHlwZSkgPiAtMTtcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogXCJqcy1hcHAtZmx5b3V0XCIgfSwgaChcImNhbGNpdGUtcG9wb3ZlclwiLCB7IGRpcjogZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSwgcG9pbnRlckRpc2FibGVkOiB0cnVlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzVGl0bGVbdHlwZV0sIG9mZnNldERpc3RhbmNlOiAxMCwgb2Zmc2V0U2tpZGRpbmc6IGlzTG9uZ1BvcG92ZXIgPyAxMCA6IDEwMCwgb3Blbjogb3BlbiwgcGxhY2VtZW50OiBcImxlYWRpbmctc3RhcnRcIiwgdHJpZ2dlckRpc2FibGVkOiB0cnVlLCBjbGFzczoge1xuICAgICAgICBcImFyY2dpcy1lZmZlY3RzLXBvcG92ZXJcIjogdHJ1ZSxcbiAgICAgICAgcG9wb3ZlcjogdHJ1ZSxcbiAgICAgICAgW0NTU19VVElMSVRZLnJ0bF06IHJ0bFxuICAgICAgfSwgcmVmZXJlbmNlRWxlbWVudDogcmVmZXJlbmNlRWxlbWVudCwgb25DYWxjaXRlUG9wb3Zlck9wZW46IHRoaXMub25PcGVuLCBvbkNhbGNpdGVQb3BvdmVyQ2xvc2U6IHRoaXMub25DbG9zZSwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICB0aGlzLnBvcG92ZXJOb2RlID0gbm9kZTtcbiAgICAgICAgLy9cIiwgcG9wb3ZlcnNbdHlwZV0sIG5vZGUpO1xuICAgICAgICAvL3BvcG92ZXJzW3R5cGVdID0gbm9kZTtcbiAgICAgIH0gfSwgdHlwZSA9PT0gXCJmZWF0dXJlRWZmZWN0XCJcbiAgICAgID8gdGhpcy5yZW5kZXJGZWF0dXJlRWZmZWN0UHJvcHMoKVxuICAgICAgOiB0aGlzLnJlbmRlckxheWVyRWZmZWN0UHJvcHMoKSkpKTtcbiAgfVxuICByZW5kZXJMYXllckVmZmVjdFByb3BzKCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIHJlZmVyZW5jZUVsZW1lbnQsIHR5cGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzIH0gPSBwcm9wcztcbiAgICBjb25zdCBydGwgPSBnZXRFbGVtZW50RGlyKHRoaXMuaG9zdEVsZW1lbnQpID09PSBcInJ0bFwiO1xuICAgIGNvbnN0IHBhbmVsUmVjdCA9IHJlZmVyZW5jZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1wYW5lbFwiLCB7IGNsb3NhYmxlOiBmYWxzZSwgaGVhZGluZzogc3RyaW5ncy5lZmZlY3RzVGl0bGVbdHlwZV0sIGNsYXNzOiBDU1MucGFuZWwsIHN0eWxlOiB7XG4gICAgICAgIG1heEhlaWdodDogYCR7cGFuZWxSZWN0LmhlaWdodCAqIDAuOX1weGBcbiAgICAgIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLnBhbmVsTm9kZSA9IG5vZGUpIH0sIFtcbiAgICAgIFwiYmxvb21cIixcbiAgICAgIFwiZHJvcFNoYWRvd1wiLFxuICAgICAgXCJibHVyXCIsXG4gICAgICBcImJyaWdodG5lc3NDb250cmFzdFwiLFxuICAgICAgXCJncmF5c2NhbGVcIixcbiAgICAgIFwiaHVlUm90YXRlXCIsXG4gICAgICBcInNhdHVyYXRlXCIsXG4gICAgICBcImludmVydFwiLFxuICAgICAgXCJzZXBpYVwiXG4gICAgXS5pbmRleE9mKHR5cGUpID4gLTEgPyAoaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5lZmZlY3RzUHJvcHMucmVzZXQsIHNjYWxlOiBcInNcIiwgc2xvdDogXCJoZWFkZXItYWN0aW9ucy1lbmRcIiwgdGl0bGU6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLnJlc2V0LCBvbkNsaWNrOiB0aGlzLm9uUmVzZXQgfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IHNjYWxlOiBcInNcIiwgaWNvbjogcnRsID8gXCJyZWRvXCIgOiBcInVuZG9cIiB9KSkpIDogbnVsbCwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5nZW5lcmFsLmNsb3NlLCBpY29uOiBcInhcIiwgc2xvdDogXCJoZWFkZXItYWN0aW9ucy1lbmRcIiwgdGl0bGU6IHN0cmluZ3MuZ2VuZXJhbC5jbG9zZSwgcmVmOiAobm9kZSkgPT4gKHRoaXMuY2xvc2VOb2RlID0gbm9kZSksIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzUG9wb3ZlckNsb3NlLmVtaXQoKTtcbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9wb3Zlck5vZGUub3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhbmVsTm9kZS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgIH0gfSksIHR5cGUgPT09IFwiYmxvb21cIiA/IHRoaXMucmVuZGVyQmxvb20oKSA6IG51bGwsIHR5cGUgPT09IFwiZHJvcFNoYWRvd1wiID8gdGhpcy5yZW5kZXJEcm9wU2hhZG93KCkgOiBudWxsLCB0eXBlID09PSBcImJsdXJcIiA/IHRoaXMucmVuZGVyQmx1cigpIDogbnVsbCwgdHlwZSA9PT0gXCJicmlnaHRuZXNzQ29udHJhc3RcIiA/IHRoaXMucmVuZGVyQnJpZ2h0bmVzc0NvbnRyYXN0KCkgOiBudWxsLCB0eXBlID09PSBcImdyYXlzY2FsZVwiID8gdGhpcy5yZW5kZXJHcmF5c2NhbGUoKSA6IG51bGwsIHR5cGUgPT09IFwiaHVlUm90YXRlXCIgPyB0aGlzLnJlbmRlckh1ZVJvdGF0ZSgpIDogbnVsbCwgdHlwZSA9PT0gXCJzYXR1cmF0ZVwiID8gdGhpcy5yZW5kZXJTYXR1cmF0ZSgpIDogbnVsbCwgdHlwZSA9PT0gXCJpbnZlcnRcIiA/IHRoaXMucmVuZGVySW52ZXJ0KCkgOiBudWxsLCB0eXBlID09PSBcInNlcGlhXCIgPyB0aGlzLnJlbmRlclNlcGlhKCkgOiBudWxsKSk7XG4gIH1cbiAgcmVuZGVyQmxvb20oKSB7XG4gICAgLy8gXCJCbG9vbVwiOiBgYmxvb20oMiwxcHgsMC4xKWAsXG4gICAgLy8gU3RyZW5ndGggKDAtNSkgLSBzdGVwIDAuMVxuICAgIC8vIFJhZGl1cyAoMC01KSAtIHN0ZXAgMC4xXG4gICAgLy8gVGhyZXNob2xkICgwLTEpIC0gc3RlcCAwLjFcbiAgICBjb25zdCB7IHByb3BzLCB0eXBlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5ZXIsIHN0cmluZ3MsIGxvY2FsZSwgbW9kdWxlcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBzY3JlZW5VdGlscyB9ID0gbW9kdWxlcztcbiAgICBjb25zdCBhbnlMYXllciA9IGxheWVyO1xuICAgIGNvbnN0IGVmZmVjdFByb3BzID0gZ2V0RWZmZWN0UHJvcHModHlwZSwgcHJvcHMpO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiA1LCBzdGVwOiAwLjEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogTWF0aC5yb3VuZChlZmZlY3RQcm9wcy5zdHJlbmd0aCAqIDEwKSAvIDEwLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMucmFkaXVzLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogNSwgc3RlcDogMC4xLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZWZmZWN0UHJvcHMucmFkaXVzKSAqIDEwKSAvIDEwLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5yYWRpdXMsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLnRocmVzaG9sZCwgaChTZWxlY3ROdW1iZXIsIHsgbWluOiAwLCBtYXg6IDEwMCwgc3RlcDogMSwgbG9jYWxlOiBsb2NhbGUsIHZhbHVlOiBNYXRoLnJvdW5kKGVmZmVjdFByb3BzLnRocmVzaG9sZCAqIDEwMCksIGNsYXNzTmFtZXM6IENTUy5ib3R0b21TcGFjZSwgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLnRocmVzaG9sZCwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGxheW91dDogXCJpbmxpbmUtc3BhY2UtYmV0d2VlblwiLCBzY2FsZTogXCJzXCIsIGNsYXNzOiBDU1Muc3dpdGNoIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLmF1dG9BZGp1c3QsIGgoXCJjYWxjaXRlLXN3aXRjaFwiLCB7IGNoZWNrZWQ6ICEhKCFhbnlMYXllci5lZmZlY3QgfHwgdHlwZW9mIGFueUxheWVyLmVmZmVjdCAhPT0gXCJzdHJpbmdcIiksIHNjYWxlOiBcInNcIiwgY2xhc3M6IENTUy5hdXRvLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSkpO1xuICB9XG4gIHJlbmRlckRyb3BTaGFkb3coKSB7XG4gICAgLy8gXCJEcm9wIHNoYWRvd1wiOiBgZHJvcC1zaGFkb3coMXB4LDFweCwycHgsIzAwMDAwMClgLFxuICAgIC8vIFggb2Zmc2V0ICgtMjAtMjApIC0gc3RlcCAxXG4gICAgLy8gWSBvZmZzZXQgKC0yMC0yMCkgLSBzdGVwIDFcbiAgICAvLyBCbHVyIHJhZGl1cyAoMC0yMCkgLSBzdGVwIDFcbiAgICBjb25zdCB7IHByb3BzLCB0eXBlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgbGF5ZXIsIHN0cmluZ3MsIGxvY2FsZSwgbW9kdWxlcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBzY3JlZW5VdGlscyB9ID0gbW9kdWxlcztcbiAgICBjb25zdCBhbnlMYXllciA9IGxheWVyO1xuICAgIGNvbnN0IGVmZmVjdFByb3BzID0gZ2V0RWZmZWN0UHJvcHModHlwZSwgcHJvcHMpO1xuICAgIGNvbnN0IGhleFZhbHVlID0gdGhpcy5yZ2IySGV4KGVmZmVjdFByb3BzLmNvbG9yKTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnQgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuY29sb3IsIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlclwiLCB7IHNjYWxlOiBcIm1cIiwgdmFsdWU6IGhleFZhbHVlLCBoaWRlU2F2ZWQ6IHRydWUsIG9uQ2FsY2l0ZUNvbG9yUGlja2VySW5wdXQ6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMud2lkdGgsIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAyMCwgc3RlcDogMSwgbG9jYWxlOiBsb2NhbGUsIHZhbHVlOiBNYXRoLnJvdW5kKHNjcmVlblV0aWxzLnB0MnB4KGVmZmVjdFByb3BzLmJsdXJSYWRpdXMpKSwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMud2lkdGgsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMub2Zmc2V0LCBoKFNlbGVjdFh5LCB7IG1pbjogLTIwLCBtYXg6IDIwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgeDogTWF0aC5yb3VuZChzY3JlZW5VdGlscy5wdDJweChlZmZlY3RQcm9wcy54b2Zmc2V0KSksIHk6IE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZWZmZWN0UHJvcHMueW9mZnNldCkpLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2VMaXR0bGUsIHN0cmluZ3M6IHN0cmluZ3MsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLm9wYWNpdHksIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAxMDAsIHN0ZXA6IDEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogKGVmZmVjdFByb3BzLmNvbG9yWzNdIC8gMjU1KSAqIDEwMCwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMub3BhY2l0eSwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpLCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IGxheW91dDogXCJpbmxpbmUtc3BhY2UtYmV0d2VlblwiLCBzY2FsZTogXCJzXCIsIGNsYXNzOiBDU1Muc3dpdGNoIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLmF1dG9BZGp1c3QsIGgoXCJjYWxjaXRlLXN3aXRjaFwiLCB7IGNoZWNrZWQ6ICEhKCFhbnlMYXllci5lZmZlY3QgfHwgdHlwZW9mIGFueUxheWVyLmVmZmVjdCAhPT0gXCJzdHJpbmdcIiksIHNjYWxlOiBcInNcIiwgY2xhc3M6IENTUy5hdXRvLCBvbkNhbGNpdGVTd2l0Y2hDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSkpO1xuICB9XG4gIHJlbmRlckJsdXIoKSB7XG4gICAgLy8gXCJCbHVyXCI6IGBibHVyKDJweClgLFxuICAgIC8vIEJsdXIgKDAtMzApIC0gc3RlcCAwLjFcbiAgICBjb25zdCB7IHByb3BzLCB0eXBlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RyaW5ncywgbG9jYWxlLCBtb2R1bGVzIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHNjcmVlblV0aWxzIH0gPSBtb2R1bGVzO1xuICAgIGNvbnN0IGVmZmVjdFByb3BzID0gZ2V0RWZmZWN0UHJvcHModHlwZSwgcHJvcHMpO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAzMCwgc3RlcDogMC4xLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IE1hdGgucm91bmQoc2NyZWVuVXRpbHMucHQycHgoZWZmZWN0UHJvcHMucmFkaXVzKSAqIDEwKSAvIDEwLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpKSk7XG4gIH1cbiAgcmVuZGVyQnJpZ2h0bmVzc0NvbnRyYXN0KCkge1xuICAgIC8vIGJyaWdodG5lc3MoMTAwJSkgY29udHJhc3QoMTAwJSlcbiAgICAvLyBCcmlnaHRuZXNzICgwLTMwMCkgLSBzdGVwIDEgKyBDb250cmFzdCAoMC0zMDApIC0gc3RlcCAxXG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MsIGxvY2FsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgZWZmZWN0UHJvcHNCcmlnaHRuZXNzID0gZ2V0RWZmZWN0UHJvcHMoXCJicmlnaHRuZXNzXCIsIHByb3BzKTtcbiAgICBjb25zdCBlZmZlY3RQcm9wc0NvbnRyYXN0ID0gZ2V0RWZmZWN0UHJvcHMoXCJjb250cmFzdFwiLCBwcm9wcyk7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyB9LCBzdHJpbmdzLmVmZmVjdHNQcm9wcy5icmlnaHRuZXNzLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMzAwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IE1hdGgucm91bmQoZWZmZWN0UHJvcHNCcmlnaHRuZXNzLmFtb3VudCAqIDEwMCksIGNsYXNzTmFtZXM6IENTUy5ib3R0b21TcGFjZSwgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLmJyaWdodG5lc3MsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLmNvbnRyYXN0LCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMzAwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IE1hdGgucm91bmQoZWZmZWN0UHJvcHNDb250cmFzdC5hbW91bnQgKiAxMDApLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5jb250cmFzdCwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpKSk7XG4gIH1cbiAgcmVuZGVyR3JheXNjYWxlKCkge1xuICAgIC8vIGdyYXlzY2FsZSgyNSUpXG4gICAgLy8gR3JheXNjYWxlICgwLTEwMCkgLSBzdGVwIDFcbiAgICBjb25zdCB7IHByb3BzLCB0eXBlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RyaW5ncywgbG9jYWxlIH0gPSBwcm9wcztcbiAgICBjb25zdCBlZmZlY3RQcm9wcyA9IGdldEVmZmVjdFByb3BzKHR5cGUsIHByb3BzKTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnQgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLnN0cmVuZ3RoLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMTAwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IGVmZmVjdFByb3BzLmFtb3VudCAqIDEwMCwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSkpO1xuICB9XG4gIHJlbmRlckh1ZVJvdGF0ZSgpIHtcbiAgICAvLyBodWUtcm90YXRlKDI3MGRlZyksXG4gICAgLy8gSHVlIHJvdGF0ZSAoMC0zNjApIC0gc3RlcCAxXG4gICAgY29uc3QgeyBwcm9wcywgdHlwZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MsIGxvY2FsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgZWZmZWN0UHJvcHMgPSBnZXRFZmZlY3RQcm9wcyh0eXBlLCBwcm9wcyk7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyB9LCBzdHJpbmdzLmVmZmVjdHNQcm9wcy5kZWdyZWVzLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMzYwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IGVmZmVjdFByb3BzLmFuZ2xlLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5kZWdyZWVzLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uUHJvcENoYW5nZSB9KSkpKTtcbiAgfVxuICByZW5kZXJTYXR1cmF0ZSgpIHtcbiAgICAvLyBzYXR1cmF0ZSgxMDAlKVxuICAgIC8vIFNhdHVyYXRlICgwLTIwMCkgLSBzdGVwIDFcbiAgICBjb25zdCB7IHByb3BzLCB0eXBlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RyaW5ncywgbG9jYWxlIH0gPSBwcm9wcztcbiAgICBjb25zdCBlZmZlY3RQcm9wcyA9IGdldEVmZmVjdFByb3BzKHR5cGUsIHByb3BzKTtcbiAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbnRlbnQgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgeyBzY2FsZTogXCJzXCIsIG9uQ2xpY2s6IGNhbGNpdGVMYWJlbENsaWNrSGFuZGxlckZvclByb3BlckZvY3VzIH0sIHN0cmluZ3MuZWZmZWN0c1Byb3BzLnN0cmVuZ3RoLCBoKFNlbGVjdE51bWJlciwgeyBtaW46IDAsIG1heDogMjAwLCBzdGVwOiAxLCBsb2NhbGU6IGxvY2FsZSwgdmFsdWU6IGVmZmVjdFByb3BzLmFtb3VudCAqIDEwMCwgY2xhc3NOYW1lczogQ1NTLmJvdHRvbVNwYWNlLCBsYWJlbDogc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIG9uVmFsdWVDaGFuZ2U6IHRoaXMub25Qcm9wQ2hhbmdlIH0pKSkpO1xuICB9XG4gIHJlbmRlckludmVydCgpIHtcbiAgICAvLyBpbnZlcnQoMTAwJSlcbiAgICAvLyBJbnZlcnQgKDAtMTAwKSBvciAoMC0xKSAtIHN0ZXAgMSBvciAwLjAxXG4gICAgY29uc3QgeyBwcm9wcywgdHlwZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHN0cmluZ3MsIGxvY2FsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgZWZmZWN0UHJvcHMgPSBnZXRFZmZlY3RQcm9wcyh0eXBlLCBwcm9wcyk7XG4gICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jb250ZW50IH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgc2NhbGU6IFwic1wiLCBvbkNsaWNrOiBjYWxjaXRlTGFiZWxDbGlja0hhbmRsZXJGb3JQcm9wZXJGb2N1cyB9LCBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCwgaChTZWxlY3ROdW1iZXIsIHsgbWluOiAwLCBtYXg6IDEwMCwgc3RlcDogMSwgbG9jYWxlOiBsb2NhbGUsIHZhbHVlOiBlZmZlY3RQcm9wcy5hbW91bnQgKiAxMDAsIGNsYXNzTmFtZXM6IENTUy5ib3R0b21TcGFjZSwgbGFiZWw6IHN0cmluZ3MuZWZmZWN0c1Byb3BzLnN0cmVuZ3RoLCBvblZhbHVlQ2hhbmdlOiB0aGlzLm9uUHJvcENoYW5nZSB9KSkpKTtcbiAgfVxuICByZW5kZXJTZXBpYSgpIHtcbiAgICAvLyBzZXBpYSg1MCUpXG4gICAgLy8gU2VwaWEgKDAtMTAwKSAtIHN0ZXAgMVxuICAgIGNvbnN0IHsgcHJvcHMsIHR5cGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdHJpbmdzLCBsb2NhbGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGVmZmVjdFByb3BzID0gZ2V0RWZmZWN0UHJvcHModHlwZSwgcHJvcHMpO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGVudCB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCB7IHNjYWxlOiBcInNcIiwgb25DbGljazogY2FsY2l0ZUxhYmVsQ2xpY2tIYW5kbGVyRm9yUHJvcGVyRm9jdXMgfSwgc3RyaW5ncy5lZmZlY3RzUHJvcHMuc3RyZW5ndGgsIGgoU2VsZWN0TnVtYmVyLCB7IG1pbjogMCwgbWF4OiAxMDAsIHN0ZXA6IDEsIGxvY2FsZTogbG9jYWxlLCB2YWx1ZTogZWZmZWN0UHJvcHMuYW1vdW50ICogMTAwLCBjbGFzc05hbWVzOiBDU1MuYm90dG9tU3BhY2UsIGxhYmVsOiBzdHJpbmdzLmVmZmVjdHNQcm9wcy5zdHJlbmd0aCwgb25WYWx1ZUNoYW5nZTogdGhpcy5vblByb3BDaGFuZ2UgfSkpKSk7XG4gIH1cbiAgcmVuZGVyRmVhdHVyZUVmZmVjdFByb3BzKCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIHR5cGUsIGRlZmF1bHRFeHByZXNzaW9uIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdmlldywgbGF5ZXIsIHN0cmluZ3MgfSA9IHByb3BzO1xuICAgIGNvbnN0IGRlZmF1bHRGaWVsZCA9IGdldERlZmF1bHRGaWVsZChwcm9wcyk7XG4gICAgcmV0dXJuIChoKFwiYXJjZ2lzLWZpbHRlclwiLCB7IGNsYXNzOiBgJHtDU1MucGFuZWx9IGZpbHRlcmAsIHZpZXc6IHZpZXcsIGxheWVyOiBsYXllciwgaGlkZUxheWVyVGl0bGU6IHRydWUsIHBhbmVsSGVhZGluZzogc3RyaW5ncy5mZWF0dXJlRWZmZWN0c1RpdGxlW3R5cGVdLCB0aXBIZWFkaW5nOiBzdHJpbmdzLmZpbHRlci50aXBIZWFkaW5nLCB0aXBNc2c6IHN0cmluZ3MuZmlsdGVyLnRpcE1zZywgaW52YWxpZEhlYWRpbmc6IHN0cmluZ3MuZmlsdGVyLmludmFsaWRIZWFkaW5nLCBpbnZhbGlkTXNnOiBzdHJpbmdzLmZpbHRlci5pbnZhbGlkTXNnLCBtb2RlOiBcImVmZmVjdHNcIiwgZGVmYXVsdEZpZWxkTmFtZTogZGVmYXVsdEZpZWxkLCBkZWZhdWx0T3BlcmF0b3I6IFwiPlwiLCBkZWZhdWx0RXhwcmVzc2lvbjogISFkZWZhdWx0RmllbGQgJiYgZGVmYXVsdEV4cHJlc3Npb24sIGhpZGVCdXR0b25zOiB0cnVlLCBkaXNtaXNzaWJsZTogdHJ1ZSwgcGFuZWxNYXhIZWlnaHQ6IFwiODB2aFwiLCBvbkFyY2dpc0ZpbHRlckRpc21pc3NlZENoYW5nZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmFyY2dpc0VmZmVjdHNQb3BvdmVyQ2xvc2UuZW1pdCgpO1xuICAgICAgICB0aGlzLnBvcG92ZXJOb2RlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICB9LCBvbkFyY2dpc0ZpbHRlcldoZXJlQ2hhbmdlOiAoeyBkZXRhaWw6IHdoZXJlIH0pID0+IHtcbiAgICAgICAgdGhpcy5hcmNnaXNFZmZlY3RzUG9wb3ZlckZpbHRlckNoYW5nZS5lbWl0KHdoZXJlKTtcbiAgICAgIH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLmZpbHRlck5vZGUgPSBub2RlKSB9KSk7XG4gIH1cbiAgcmdiMkhleChjb2xvcikge1xuICAgIHJldHVybiAoXCIjXCIgK1xuICAgICAgdGhpcy5jb21wb25lbnRUb0hleChNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIGNvbG9yWzBdKSkpICtcbiAgICAgIHRoaXMuY29tcG9uZW50VG9IZXgoTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBjb2xvclsxXSkpKSArXG4gICAgICB0aGlzLmNvbXBvbmVudFRvSGV4KE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgY29sb3JbMl0pKSkpO1xuICB9XG4gIGNvbXBvbmVudFRvSGV4KGMpIHtcbiAgICBjb25zdCBoZXggPSBjLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gXCIwXCIgKyBoZXggOiBoZXg7XG4gIH1cbiAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc0VmZmVjdHNQb3BvdmVycy5zdHlsZSA9IGFyY2dpc0VmZmVjdHNQb3BvdmVyc0NzcztcblxuZXhwb3J0IHsgQXJjZ2lzRWZmZWN0cyBhcyBhcmNnaXNfZWZmZWN0cywgQXJjZ2lzRWZmZWN0c1BvcG92ZXJzIGFzIGFyY2dpc19lZmZlY3RzX3BvcG92ZXJzIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbnZhciBsb2NhbFN0b3JhZ2VLZXlzO1xuKGZ1bmN0aW9uIChsb2NhbFN0b3JhZ2VLZXlzKSB7XG4gIGxvY2FsU3RvcmFnZUtleXNbXCJBUkNHSVNfQ09NUE9ORU5UX05PVElGSUNBVElPTlNcIl0gPSBcImFyY2dpc0NvbXBvbmVudF9ub3RpZmljYXRpb25zXCI7XG59KShsb2NhbFN0b3JhZ2VLZXlzIHx8IChsb2NhbFN0b3JhZ2VLZXlzID0ge30pKTtcbnZhciBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cztcbihmdW5jdGlvbiAoYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMpIHtcbiAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJGRUFUVVJFX1JFRFVDVElPTl9XQVJOSU5HX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2ZlYXR1cmVfcmVkdWN0aW9uX3dhcm5pbmdfZGlzbWlzc2VkXCI7XG4gIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiUE9QVVBfV0FSTklOR19ESVNNSVNTRURcIl0gPSBcImFyY2dpc19wb3B1cF93YXJuaW5nX2Rpc21pc3NlZFwiO1xuICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIklOQ09NUEFUSUJMRV9WRUNUT1JfU1lNQk9MU19ESVNNSVNTRURcIl0gPSBcImFyY2dpc19zeW1ib2xfc3R5bGVyX2luY29tcGF0aWJsZV92ZWN0b3Jfc3ltYm9sc19kaXNtaXNzZWRcIjtcbiAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJFRkZFQ1RTX1RJUF9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19lZmZlY3RzX3RpcF9kaXNtaXNzZWRcIjtcbiAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJMQVlFUl9WSUVXX0RFRklOSVRJT05fRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbGF5ZXJfdmlld19kZWZpbml0aW9uX2Rpc21pc3NlZFwiO1xuICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX09WRVJSSURFX1NUQVRVU19USVBfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbGF5ZXJfb3ZlcnJpZGVfc3RhdHVzX3RpcF9kaXNtaXNzZWRcIjtcbiAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJMQVlFUl9WSUVXX0pPSU5fVElQX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2xheWVyX3ZpZXdfam9pbl90aXBfZGlzbWlzc2VkXCI7XG4gIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiTVVMVElESU1FTlNJT05BTF9JTkZPX1RJUF9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19tdWx0aWRpbWVuc2lvbmFsX2luZm9fdGlwX2Rpc21pc3NlZFwiO1xufSkoYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMgfHwgKGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzID0ge30pKTtcbmNvbnN0IGdldExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXkpID0+IHtcbiAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU3RvcmFnZUtleSk7XG59O1xuY29uc3Qgc2V0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSwgdmFsdWUpID0+IHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxTdG9yYWdlS2V5LCB2YWx1ZSk7XG59O1xuY29uc3QgZ2V0T2JqZWN0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSkgPT4ge1xuICByZXR1cm4gSlNPTi5wYXJzZShnZXRMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KSkgfHwge307XG59O1xuY29uc3Qgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSwga2V5VmFsdWVPYmplY3QpID0+IHtcbiAgY29uc3Qgc2V0TG9jYWxTdG9yYWdlVmFsID0gZ2V0T2JqZWN0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSk7XG4gIHNldExvY2FsU3RvcmFnZVZhbFtrZXlWYWx1ZU9iamVjdC5rZXldID0ga2V5VmFsdWVPYmplY3QudmFsdWU7XG4gIHNldExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXksIEpTT04uc3RyaW5naWZ5KHNldExvY2FsU3RvcmFnZVZhbCkpO1xufTtcbmNvbnN0IGdldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXksIG9iamVjdEtleSkgPT4ge1xuICBjb25zdCBnZXRMb2NhbFN0b3JhZ2VWYWwgPSBnZXRPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KTtcbiAgaWYgKGdldExvY2FsU3RvcmFnZVZhbCA9PT0gbnVsbCB8fCBnZXRMb2NhbFN0b3JhZ2VWYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldExvY2FsU3RvcmFnZVZhbC5oYXNPd25Qcm9wZXJ0eShvYmplY3RLZXkpKSB7XG4gICAgcmV0dXJuIGdldExvY2FsU3RvcmFnZVZhbFtvYmplY3RLZXldO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5leHBvcnQgeyBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cyBhcyBhLCBnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgYXMgZywgbG9jYWxTdG9yYWdlS2V5cyBhcyBsLCBzZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgYXMgcyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTEzZjViMDBjLmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC0yMjI1OGM5MC5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gXCJlblwiO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgcmV0dXJuIGxhbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICB9XG4gIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICBsZXQgc3RyaW5ncztcbiAgdHJ5IHtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gIH1cbiAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9