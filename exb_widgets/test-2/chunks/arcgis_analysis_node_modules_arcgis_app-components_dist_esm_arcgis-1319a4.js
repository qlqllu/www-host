"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-1319a4"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-color-input_7.entry.js":
/*!***********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-color-input_7.entry.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_color_input: () => (/* binding */ ArcgisColorInput),
/* harmony export */   arcgis_popup_color_popover: () => (/* binding */ ArcgisPopupColorPopover),
/* harmony export */   arcgis_popup_styler_popover: () => (/* binding */ ArcgisPopupStylerPopover),
/* harmony export */   arcgis_symbol_picker_file_upload: () => (/* binding */ ArcgisSymbolStylerFileUpload),
/* harmony export */   arcgis_symbol_styler_color_ramp_input: () => (/* binding */ ArcgisSymbolStylerColorRampInput),
/* harmony export */   arcgis_symbol_styler_section: () => (/* binding */ ArcgisSymbolStylerSection),
/* harmony export */   arcgis_symbol_styler_symbol_preview: () => (/* binding */ ArcgisSymbolStylerSymbolPreview)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/* harmony import */ var _locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-13e00a75.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-13e00a75.js");
/* harmony import */ var _storage_d7f5822e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storage-d7f5822e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-d7f5822e.js");
/* harmony import */ var _languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languageUtil-22258c90.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-22258c90.js");
/* harmony import */ var _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popupStore-a5d93b58.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-a5d93b58.js");
/* harmony import */ var _loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loadModules-aaf30bd6.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-aaf30bd6.js");
/* harmony import */ var _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./colorRampUtils-7e6d2ad8.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorRampUtils-7e6d2ad8.js");
/* harmony import */ var _color_776689e9_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./color-776689e9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/color-776689e9.js");
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/* harmony import */ var _dom_13f5b00c_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-13f5b00c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-13f5b00c.js");
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */












const CSS$3 = {
  recent: "recent",
  preview: "preview",
  colorPickerContainer: "color-picker-container"
};
const defaultColor = "#d00b33";

const arcgisColorInputCss = ":host,arcgis-symbol-styler-inline-input{display:block}.color-picker-container{display:flex;flex-direction:column}.color-picker{--calcite-ui-border-1:transparent}[slot=preview] calcite-color-picker-swatch{width:100%;height:24px}.recent{align-items:center;border:1px solid #949494;display:flex;gap:8px;height:32px;padding:0px 6px;transition:outline-offset 100ms ease-in-out, outline-color 100ms ease-in-out}.recent:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:2px}.recent calcite-color-picker-swatch:not([active]){cursor:pointer}.recent calcite-color-picker-swatch:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:2px}.recent calcite-color-picker-swatch:focus[active]{border-radius:100%}.empty-swatch{cursor:default}calcite-tooltip:not([open]){visibility:hidden;pointer-events:none}";

const ArcgisColorInput = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisColorInputChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisColorInputChange", 7);
    this.arcgisInternalColorInputStoredColor = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisInternalColorInputStoredColor", 7);
    this.arcgisColorInputPopoverOpen = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisColorInputPopoverOpen", 7);
    this.arcgisColorInputPopoverClose = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisColorInputPopoverClose", 7);
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    this.focusHandler = (event) => {
      this.activeEl = event.target;
    };
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.onClose = (event) => {
      var _a;
      this.storeRecentColorToStorage((_a = this.colorPickerEl) === null || _a === void 0 ? void 0 : _a.value);
      event.stopPropagation();
      this.arcgisColorInputPopoverClose.emit();
    };
    this.handleSwatchClickOrKeyUp = (event) => {
      if ("key" in event && event.key !== "Enter" && event.key !== "Space") {
        return;
      }
      const swatch = event.currentTarget;
      const selected = swatch.color;
      this.updateColor(selected);
      setTimeout(() => this.recentColor1El.focus(), 200);
    };
    this.recentColorsKeyDownHandler = (event) => {
      if (this.recentColors.length === 1) {
        return;
      }
      const key = event.key;
      let activeRecentColorIndex;
      if (this.activeEl === this.recentColor1El) {
        activeRecentColorIndex = 1;
      }
      else if (this.activeEl === this.recentColor2El) {
        activeRecentColorIndex = 2;
      }
      else if (this.activeEl === this.recentColor3El) {
        activeRecentColorIndex = 3;
      }
      if (key === "ArrowLeft") {
        if (!activeRecentColorIndex || activeRecentColorIndex === 1) {
          this[`recentColor${this.recentColors.length}El`].focus();
        }
        else {
          this[`recentColor${activeRecentColorIndex - 1}El`].focus();
        }
      }
      if (key === "ArrowRight") {
        if (!activeRecentColorIndex || activeRecentColorIndex === this.recentColors.length) {
          this.recentColor1El.focus();
        }
        else {
          this[`recentColor${activeRecentColorIndex + 1}El`].focus();
        }
      }
    };
    this.setInlineInputRef = (el) => {
      this.inlineInputEl = el;
    };
    this.setColorPickerRef = (el) => {
      if (el) {
        this.colorPickerEl = el;
      }
      // we get a second call of this with el=null e.g. when toggling on background color in Map Viewer
    };
    this.setRecentColorRef1 = (el) => {
      if (el) {
        this.recentColor1El = el;
      }
    };
    this.setRecentColorRef2 = (el) => {
      if (el) {
        this.recentColor2El = el;
      }
    };
    this.setRecentColorRef3 = (el) => {
      if (el) {
        this.recentColor3El = el;
      }
    };
    this.onOpen = () => {
      var _a;
      (_a = this.colorPickerEl) === null || _a === void 0 ? void 0 : _a.setFocus();
      this.arcgisColorInputPopoverOpen.emit();
    };
    this.handleClear = () => {
      this.updateColor(null);
    };
    this.clearable = false;
    this.color = defaultColor;
    this.compact = false;
    this.disabled = false;
    this.placement = "auto";
    this.popoverProps = undefined;
    this.storageId = undefined;
    this.recentColors = [];
  }
  storedColorHandler(event) {
    if (!event.composedPath().includes(this.el)) {
      this.setRecentColorsFromStorage();
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  async setFocus() {
    var _a;
    await ((_a = this.inlineInputEl) === null || _a === void 0 ? void 0 : _a.setFocus());
  }
  async close() {
    await this.inlineInputEl.close();
  }
  updateColor(color, save = true) {
    if (color === this.color) {
      return;
    }
    this.color = color;
    this.arcgisColorInputChange.emit();
    if (save) {
      this.storeRecentColorToStorage(color);
    }
  }
  storeRecentColorToStorage(color) {
    if (!color) {
      return;
    }
    const recentColors = [color, ...this.recentColors.filter((recent) => recent !== color)].slice(0, 3);
    (0,_storage_d7f5822e_js__WEBPACK_IMPORTED_MODULE_2__.s)(this.storageId, recentColors, true);
    this.recentColors = recentColors;
    this.arcgisInternalColorInputStoredColor.emit();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    [this.strings] = await (0,_locale_13e00a75_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.el);
    this.setRecentColorsFromStorage();
  }
  setRecentColorsFromStorage() {
    const recentColors = (0,_storage_d7f5822e_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.storageId, true);
    if (recentColors) {
      this.recentColors = [...recentColors];
    }
  }
  disconnectedCallback() {
    this.removeTooltip();
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { compact, disabled, recentColors, strings } = this;
    const recents = [recentColors[0], recentColors[1]];
    const rtl = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.el) === "rtl";
    if (!compact) {
      recents.push(recentColors[2]);
    }
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-inline-input", { disabled: disabled, intlDone: strings.commitColor, heading: strings.selectColor, label: strings.selectColor, onArcgisSymbolStylerInlineInputClose: this.onClose, onArcgisSymbolStylerInlineInputOpen: this.onOpen, popoverProps: this.popoverProps, ref: this.setInlineInputRef }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$3.colorPickerContainer, slot: "content" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker", { allowEmpty: this.clearable, class: "color-picker", key: `color-picker${compact ? "--compact" : ""}`, onCalciteColorPickerInput: (event) => {
        this.updateColor(this.colorPickerEl.value, false);
        event.stopPropagation();
      }, ref: this.setColorPickerRef, scale: compact ? "s" : "m", storageId: this.storageId, value: this.color })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "preview" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker-swatch", { color: this.color, scale: "s" })), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { "aria-label": strings.recentColors, class: CSS$3.recent, onKeyDown: this.recentColorsKeyDownHandler, slot: "content-end", tabindex: -1 }, recents.map((recent, index) => {
      return recent ? ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker-swatch", { active: recent === this.color, color: recent, key: recent, onClick: this.handleSwatchClickOrKeyUp, onFocus: this.focusHandler, onKeyUp: this.handleSwatchClickOrKeyUp, ref: this[`setRecentColorRef${index + 1}`], role: "button", scale: "s", tabindex: 0 })) : (this.renderEmptySwatch(`empty-swatch-${index}`));
    })), this.clearable && [
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "content-end" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "circle-disallowed",
        //id="no-input-button"
        scale: "s", label: strings.clearColor, text: strings.clearColor, ref: (node) => (this.actionEl = node), onClick: this.handleClear, onMouseOver: () => this.addTooltip({
          referenceElement: this.actionEl,
          placement: rtl ? "right-start" : "left-start",
          innerHTML: strings.noColor
        }), onMouseOut: () => this.removeTooltip() }))
    ])));
  }
  renderEmptySwatch(key) {
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { class: "empty-swatch", viewBox: "0 0 20 20", xmlns: "http://www.w3.org/2000/svg", width: "20", key: key }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { width: "20", height: "20", fill: "#f8f8f8", stroke: "#000", "stroke-dasharray": "2" })));
  }
  addTooltip(props) {
    this.removeTooltip();
    this.tooltipEl = document.createElement("calcite-tooltip");
    this.tooltipEl.placement = props.placement || "auto";
    this.tooltipEl.referenceElement = props.referenceElement;
    this.tooltipEl.overlayPositioning = "fixed";
    this.tooltipEl.innerHTML = props.innerHTML;
    this.tooltipEl.open = true;
    // it won't show if just added to this.el
    this.el.parentElement.appendChild(this.tooltipEl);
  }
  removeTooltip() {
    var _a;
    if ((_a = this.tooltipEl) === null || _a === void 0 ? void 0 : _a.parentNode) {
      this.tooltipEl.parentNode.removeChild(this.tooltipEl);
      this.tooltipEl = undefined;
    }
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisColorInput.style = arcgisColorInputCss;

const ArcgisPopupColorPopover = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisPopupColorPopoverClose = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupColorPopoverClose", 7);
    this.arcgisPopupColorPopoverOpen = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupColorPopoverOpen", 7);
    this.arcgisPopupColorPopoverChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupColorPopoverChange", 7);
    this.closedWithEvent = false;
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.handlePanelDismissedChange = (event) => {
      const panel = event.currentTarget;
      if (panel.closed) {
        this.close();
        panel.closed = false;
      }
      event.stopPropagation();
    };
    this.handleDone = () => {
      this.close();
    };
    this.handlePopoverOpen = (event) => {
      this.arcgisPopupColorPopoverOpen.emit();
      event.stopPropagation();
    };
    this.handlePopoverClose = (event) => {
      this.arcgisPopupColorPopoverClose.emit();
      this.closedWithEvent = true;
      event.stopPropagation();
    };
    this.handlePopoverKeyUp = ({ key }) => {
      if (key === "Escape") {
        this.close();
      }
    };
    this.disabled = false;
    this.heading = undefined;
    this.intlDone = undefined;
    this.label = undefined;
    this.hexColor = undefined;
    this.popoverProps = undefined;
    this.open = false;
  }
  disabledChanged(value) {
    if (value && this.open) {
      this.close();
    }
  }
  onInlineInputOpen(event) {
    if (!this.open) {
      return;
    }
    if (!event.composedPath().includes(this.el)) {
      this.open = false;
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  async setFocus() {
    var _a;
    (_a = this.panelElement) === null || _a === void 0 ? void 0 : _a.setFocus();
  }
  async close() {
    this.open = false;
    this.arcgisPopupColorPopoverClose.emit();
    this.closedWithEvent = true;
  }
  async setOpen(open) {
    this.open = open;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle Methods
  //
  //--------------------------------------------------------------------------
  disconnectedCallback() {
    if (!this.closedWithEvent) {
      this.arcgisPopupColorPopoverClose.emit();
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { popoverProps } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "js-app-flyout" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-popover", { pointerDisabled: true, onKeyUp: this.handlePopoverKeyUp, label: this.label, offsetDistance: (popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.offsetDistance) || 0, offsetSkidding: (popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.offsetSkidding) || 0, flipDisabled: (popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.flipDisabled) || false, open: this.open, overlayPositioning: (popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.overlayPositioning) || "fixed", referenceElement: (popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.refElement) || this.previewContainerEl, onCalcitePopoverClose: this.handlePopoverClose, onCalcitePopoverOpen: this.handlePopoverOpen, placement: (popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.placement) || "bottom" // setting to bottom (vs auto) to workaround absolute placement issue
      ,
      triggerDisabled: true }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { closable: true, onCalcitePanelClose: this.handlePanelDismissedChange, heading: this.heading, style: (popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.maxHeight) && { maxHeight: popoverProps.maxHeight }, ref: (node) => (this.panelElement = node) }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-color-picker", { allowEmpty: false, onCalciteColorPickerInput: (event) => {
        const hexColor = event.target.value;
        this.arcgisPopupColorPopoverChange.emit(hexColor);
        event.stopPropagation();
      }, scale: "m", value: this.hexColor, storageId: "arcgis-symbol-styler-storage-colors" }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "solid", scale: "m", slot: "footer", width: "full", label: this.intlDone, onClick: this.handleDone }, this.intlDone)))));
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "disabled": ["disabledChanged"]
  }; }
};

const arcgisPopupStylerPopoverCss = ".styler-panel{width:328px;min-height:300px}.styler-div{width:100%}";

const ArcgisPopupStylerPopover = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisPopupStylerPopoverClose = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupStylerPopoverClose", 7);
    this.arcgisPopupStylerPopoverDisconnected = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisPopupStylerPopoverDisconnected", 7);
    // ====================================
    this.documentTabHandler = undefined;
    this.documentClickHandler = undefined;
    this.panelScrollHandler = undefined;
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    this.onOpen = () => {
      requestAnimationFrame(() => this.setFocus());
    };
    this.referenceElement = undefined;
    this.open = false;
  }
  //--------------------------------------------------------------------------
  //
  //  public calls
  //
  //--------------------------------------------------------------------------
  async reposition() {
    var _a;
    (_a = this.popoverNode) === null || _a === void 0 ? void 0 : _a.reposition();
  }
  async setFocus() {
    var _a;
    (_a = this.closeActionNode) === null || _a === void 0 ? void 0 : _a.setFocus();
  }
  async setOpen(open) {
    var _a;
    if (this.popoverNode) {
      this.popoverNode.open = open;
      if (open) {
        (_a = this.panelNode) === null || _a === void 0 ? void 0 : _a.setFocus();
        this.popoverNode.reposition();
      }
    }
  }
  async addStyler(stylerNode) {
    if (this.contentNode) {
      this.contentNode.appendChild(stylerNode);
    }
  }
  async getPopoverRefElement() {
    return this.closeActionNode;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  componentWillLoad() {
    this.strings = _popupStore_a5d93b58_js__WEBPACK_IMPORTED_MODULE_4__.p.strings;
  }
  componentDidLoad() {
    requestAnimationFrame(() => { var _a; return (_a = this.closeActionNode) === null || _a === void 0 ? void 0 : _a.setFocus(); });
  }
  disconnectedCallback() {
    // in case popover got removed by just removing node from DOM
    this.arcgisPopupStylerPopoverDisconnected.emit();
  }
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { referenceElement, open, strings } = this;
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "js-app-flyout" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-popover", { open: open, placement: "leading-start", offsetDistance: 0, offsetSkidding: 45, pointerDisabled: true, triggerDisabled: true, label: "", referenceElement: referenceElement, onCalcitePopoverOpen: this.onOpen, ref: (node) => (this.popoverNode = node) }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", {
      // need access to the close button dom to pass to symbol styler as reference element,
      // so can't use closable:true
      closable: false, heading: strings.chartStyle, class: "styler-panel", ref: (node) => (this.panelNode = node), onCalcitePanelClose: () => {
        this.arcgisPopupStylerPopoverClose.emit();
        // focus on info icon; wait so enter key doesn't re-open it
        setTimeout(() => referenceElement.parentElement.focus(), 300);
      }
    }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { id: "symbol-styler-dismiss-button", slot: "header-actions-end", scale: "s", icon: "x", text: strings.close, onClick: () => this.arcgisPopupStylerPopoverClose.emit(), ref: (node) => (this.closeActionNode = node) }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "styler-div", ref: (node) => (this.contentNode = node) })))));
  }
  get hostElement() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisPopupStylerPopover.style = arcgisPopupStylerPopoverCss;

const arcgisSymbolPickerFileUploadCss = ":host{display:inline-block;background-color:white;width:100%;padding:20px 5px 15px 5px;border-color:var(--calcite-ui-border-1);border-width:2px;border-style:dashed;box-sizing:border-box}.file-step{text-align:center}.file-step__upload-icon{margin-bottom:0.5rem;margin-top:0.25rem;color:var(--calcite-ui-text-3)}.file-step__upload-icon calcite-icon{width:4rem;height:4rem}.file-step__drag-text{font-size:0.9rem;margin-bottom:0.25rem}.file-step__browse-button{margin-top:1rem}.file-step__file-input{display:none}";

const ArcgisSymbolStylerFileUpload = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.arcgisSymbolPickerFileUploadChange = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolPickerFileUploadChange", 7);
    this.arcgisSymbolPickerFileUploadInvalidFile = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolPickerFileUploadInvalidFile", 7);
    this.arcgisSymbolPickerFileUploadError = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSymbolPickerFileUploadError", 7);
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.handleDragOver = (event) => {
      event.preventDefault();
    };
    this.handleDrop = (event) => {
      event.preventDefault();
      this.processFile(event.dataTransfer.files[0]);
    };
    this.handleFileInputChange = async (event) => {
      await this.processFile(event.target.files[0]);
    };
    this.portal = undefined;
    this.strings = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  // --------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "file-step", "aria-label": this.strings.fileUpload.dragDrop, onDragOver: this.handleDragOver, onDragEnter: this.handleDragOver, onDrop: this.handleDrop }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "file-step__drag-text", "aria-label": this.strings.fileUpload.dragDrop }, this.strings.fileUpload.dragDrop), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { class: "file-step__browse-button", appearance: "transparent", iconStart: "image", onClick: () => {
        this.fileInput.click();
      } }, this.strings.fileUpload.browse), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("input", { ref: (el) => {
        this.fileInput = el;
      }, onChange: this.handleFileInputChange, class: "file-step__file-input", type: "file", accept: ".jpg,.gif,.png,.svg,image/jpg,image/gif,image/png,image/svg+xml" }))));
  }
  async processFile(file) {
    const { portal } = this;
    if (!file) {
      return;
    }
    if (file) {
      if (!this.isValidFile(file)) {
        this.arcgisSymbolPickerFileUploadInvalidFile.emit();
        return;
      }
      if (this.isSVGFile(file)) {
        const [symbolService] = await (0,_loadModules_aaf30bd6_js__WEBPACK_IMPORTED_MODULE_5__.l)(["esri/rest/symbolService"]);
        const symbolServiceUrl = portal.helperServices.symbols.url;
        const reader = new FileReader();
        reader.onload = async (event) => {
          const params = { svgImage: event.target.result };
          symbolService.generateSymbol(symbolServiceUrl, params).then((result) => {
            this.arcgisSymbolPickerFileUploadChange.emit({
              cim: result.symbol,
              fileName: file.name || "",
              width: result.symbol.width,
              height: result.symbol.height
            });
          });
        };
        reader.readAsText(file);
      }
      else {
        const reader = new FileReader();
        reader.onload = async (event) => {
          var image = new Image();
          image.src = event.target.result;
          image.onload = () => {
            this.arcgisSymbolPickerFileUploadChange.emit({
              dataURL: event.target.result,
              fileName: file.name || "",
              width: image.width,
              height: image.height
            });
          };
          image.onerror = () => {
            this.arcgisSymbolPickerFileUploadError.emit();
          };
        };
        reader.readAsDataURL(file);
      }
    }
  }
  isValidFile(file) {
    return (file === null || file === void 0 ? void 0 : file.name) && /\.(gif|jpg|jpeg|png|svg)$/i.test(file.name);
  }
  isSVGFile(file) {
    return (file === null || file === void 0 ? void 0 : file.name) && /\.(svg)$/i.test(file.name);
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisSymbolStylerFileUpload.style = arcgisSymbolPickerFileUploadCss;

const CSS$2 = {
  recent: "recent",
  preview: "preview",
  colorPickerContainer: "color-picker-container"
};

let rampId = 0;
const CSS$1 = {
  colorRampItem: "color-ramp-item"
};
const ColorRampItem = ({ stops, style = "continuous", name, layout = "vertical", width = 20, height = 70 }) => {
  const id = `${rampId++}-color-ramp-gradient`;
  const gradientTransform = layout === "vertical" ? "rotate(90)" : "";
  return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { title: name, class: CSS$1.colorRampItem },
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { xmlns: "http://www.w3.org/2000/svg", height: height, width: width },
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("defs", null,
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("linearGradient", { id: id, gradientTransform: gradientTransform }, style === "continuous" ? getGradientStops(stops) : getSolidStops(stops))),
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { x: "0", y: "0", fill: `url('#${id}')`, width: "100%", height: "100%" }))));
};
function getGradientStops(stops) {
  const colorOffset = 1 / (stops.length - 1);
  return stops.slice().map(({ r, g, b }, index) => {
    const offset = index * colorOffset * 100;
    return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("stop", { "stop-color": `rgb(${r}, ${g}, ${b})`, offset: `${offset}%` });
  });
}
function getSolidStops(stops) {
  const colorOffset = 1 / stops.length;
  const colors = [];
  stops.slice().forEach(({ r, g, b }, index) => {
    const offset = index * colorOffset * 100;
    const nextOffset = (index + 1) * colorOffset * 100;
    colors.push((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("stop", { "stop-color": `rgb(${r}, ${g}, ${b})`, offset: `${offset}%` }), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("stop", { "stop-color": `rgb(${r}, ${g}, ${b})`, offset: `${nextOffset}%` }));
  });
  return colors;
}

const CSS = {
  colorRampItem: "color-ramp-item"
};
const RelationshipRampColorRampItem = ({ stops, name, opacity = null, size = 48 }) => {
  const { svgUtils } = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_7__.e;
  // rendering logic, types and utils are based on JS API ramp rendering from Legend
  // these will be refactored after some utils are made public: https://devtopia.esri.com/WebGIS/arcgis-js-api/pull/32811/
  const numClasses = Math.sqrt(stops.length);
  const colors = (0,_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__.E)(stops);
  const rotation = 0;
  const surfaceSize = Math.sqrt(Math.pow(size, 2) + Math.pow(size, 2)) + (0 ); // diagonal length + 5px padding for arrows
  let opacityStyle = null;
  if (opacity != null) {
    opacityStyle = { opacity: `${opacity}` };
  }
  const defs = [];
  const squares = [];
  const bboxes = [];
  const groupSize = size || 75;
  const cellSize = groupSize / numClasses;
  for (let i = 0; i < numClasses; i++) {
    const y = i * cellSize;
    for (let j = 0; j < numClasses; j++) {
      const x = j * cellSize;
      const fillAttrs = generateFillAttributes(colors[i][j]);
      const strokeAttrs = generateStrokeAttributes(null);
      const shape = {
        type: "rect",
        x,
        y,
        width: cellSize,
        height: cellSize
      };
      defs.push(renderDef(fillAttrs));
      squares.push(renderShape(shape, fillAttrs.fill, strokeAttrs, null));
      bboxes.push(svgUtils.getBoundingBox(shape));
    }
  }
  let svgStyle = null;
  const bbox = svgUtils.computeBBox(bboxes);
  const rectMatrix = svgUtils.getTransformMatrix(bbox, surfaceSize, surfaceSize, 0, false, rotation);
  return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { title: name, class: CSS.colorRampItem },
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { style: opacityStyle },
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("svg", { width: surfaceSize, height: surfaceSize, style: svgStyle, xmlns: "http://www.w3.org/2000/svg" },
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("defs", null, defs),
        (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("g", { transform: rectMatrix }, squares)))));
};
function renderDef(attrs) {
  const { pattern, linearGradient } = attrs;
  if (pattern) {
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("pattern", { id: pattern.id, patternUnits: "userSpaceOnUse", x: pattern.x, y: pattern.y, width: pattern.width, height: pattern.height },
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("image", { x: pattern.image.x, y: pattern.image.y, width: pattern.image.width, height: pattern.image.height, href: pattern.image.href })));
  }
  if (linearGradient) {
    const stops = linearGradient.stops.map((stop, index) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("stop", { key: `${index}-stop`, offset: stop.offset, "stop-color": stop.color })));
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("linearGradient", { id: linearGradient.id, gradientUnits: "userSpaceOnUse", x1: linearGradient.x1, y1: linearGradient.y1, x2: linearGradient.x2, y2: linearGradient.y2 }, stops));
  }
  return null;
}
function getSvgPathFromCommandObjects(commandObjects) {
  return commandObjects
    .map((commandObj) => `${commandObj.command} ${commandObj.values.join(" ")}`)
    .join(" ")
    .trim();
}
let patternCount = 0;
let linearGradientCount = 0;
function renderShape(shape, fill, stroke, textAttrs) {
  if (shape) {
    if (shape.type === "circle") {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("circle", { fill: fill, "fill-rule": "evenodd", stroke: stroke.color, "stroke-width": stroke.width, "stroke-linecap": stroke.cap, "stroke-linejoin": stroke.join, "stroke-dasharray": stroke.dashArray, "stroke-miterlimit": "4", cx: shape.cx, cy: shape.cy, r: shape.r }));
    }
    if (shape.type === "ellipse") {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("ellipse", { fill: fill, "fill-rule": "evenodd", stroke: stroke.color, "stroke-width": stroke.width, "stroke-linecap": stroke.cap, "stroke-linejoin": stroke.join, "stroke-dasharray": stroke.dashArray, "stroke-miterlimit": "4", cx: shape.cx, cy: shape.cy, rx: shape.rx, ry: shape.ry }));
    }
    if (shape.type === "rect") {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("rect", { fill: fill, "fill-rule": "evenodd", stroke: stroke.color, "stroke-width": stroke.width, "stroke-linecap": stroke.cap, "stroke-linejoin": stroke.join, "stroke-dasharray": stroke.dashArray, "stroke-miterlimit": "4", x: shape.x, y: shape.y, width: shape.width, height: shape.height }));
    }
    if (shape.type === "image") {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("image", { href: shape.src, x: shape.x, y: shape.y, width: shape.width, height: shape.height, preserveAspectRatio: "none" }));
    }
    if (shape.type === "path") {
      const path = typeof shape.path !== "string" ? getSvgPathFromCommandObjects(shape.path) : shape.path;
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("path", { fill: fill, "fill-rule": "evenodd", stroke: stroke.color, "stroke-width": stroke.width, "stroke-linecap": stroke.cap, "stroke-linejoin": stroke.join, "stroke-dasharray": stroke.dashArray, "stroke-miterlimit": "4", d: path }));
    }
    if (shape.type === "text") {
      return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("text", { fill: fill, "fill-rule": "evenodd", stroke: stroke.color, "stroke-width": stroke.width, "stroke-linecap": stroke.cap, "stroke-linejoin": stroke.join, "stroke-dasharray": stroke.dashArray, "stroke-miterlimit": "4", "text-anchor": textAttrs.align, "text-decoration": textAttrs.decoration, kerning: textAttrs.kerning, rotate: textAttrs.rotate, "text-rendering": "auto", "font-style": textAttrs.font.style, "font-variant": textAttrs.font.variant, "font-weight": textAttrs.font.weight, "font-size": textAttrs.font.size, "font-family": textAttrs.font.family, x: shape.x, y: shape.y }, shape.text));
    }
  }
  return null;
}
function generateFillAttributes(fill) {
  const attrs = {
    fill: "none",
    pattern: null,
    linearGradient: null
  };
  if (fill) {
    if ("type" in fill && fill.type === "pattern") {
      const id = `patternId-${++patternCount}`;
      attrs.fill = `url(#${id})`;
      attrs.pattern = {
        id,
        x: fill.x,
        y: fill.y,
        width: fill.width,
        height: fill.height,
        image: {
          x: 0,
          y: 0,
          width: fill.width,
          height: fill.height,
          href: fill.src
        }
      };
    }
    else if ("type" in fill && fill.type === "linear") {
      const id = `linearGradientId-${++linearGradientCount}`;
      attrs.fill = `url(#${id})`;
      attrs.linearGradient = {
        id,
        x1: fill.x1,
        y1: fill.y1,
        x2: fill.x2,
        y2: fill.y2,
        stops: fill.colors.map((stop) => ({
          offset: stop.offset,
          color: stop.color && (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_7__.d)(stop.color).toString()
        }))
      };
    }
    else if (fill) {
      const color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_7__.d)(fill);
      attrs.fill = color.toString();
    }
  }
  return attrs;
}
function generateStrokeAttributes(stroke) {
  const strokeAttrs = {
    color: "none",
    width: 1,
    cap: "butt",
    join: "4",
    dashArray: "none"
  };
  if (stroke) {
    if (stroke.width != null) {
      strokeAttrs.width = stroke.width;
    }
    if (stroke.cap) {
      strokeAttrs.cap = stroke.cap;
    }
    if (stroke.join) {
      strokeAttrs.join = stroke.join.toString();
    }
    if (stroke.color) {
      strokeAttrs.color = (0,_color_776689e9_js__WEBPACK_IMPORTED_MODULE_7__.d)(stroke.color).toString();
    }
    if (stroke.style) {
      let da = null;
      if (stroke.style in styleToDashArray) {
        da = styleToDashArray[stroke.style];
      }
      if (Array.isArray(da)) {
        da = da.slice(0);
        for (let i = 0; i < da.length; ++i) {
          da[i] *= stroke.width;
        }
        if (stroke.cap !== "butt") {
          for (let i = 0; i < da.length; i += 2) {
            da[i] -= stroke.width;
            if (da[i] < 1) {
              da[i] = 1;
            }
          }
          for (let i = 1; i < da.length; i += 2) {
            da[i] += stroke.width;
          }
        }
        da = da.join(",");
      }
      strokeAttrs.dashArray = da;
    }
  }
  return strokeAttrs;
}
const styleToDashArray = {
  solid: "none",
  shortdash: [4, 1],
  shortdot: [1, 1],
  shortdashdot: [4, 1, 1, 1],
  shortdashdotdot: [4, 1, 1, 1, 1, 1],
  dot: [1, 3],
  dash: [4, 3],
  longdash: [8, 3],
  dashdot: [4, 3, 1, 3],
  longdashdot: [8, 3, 1, 3],
  longdashdotdot: [8, 3, 1, 3, 1, 3]
};

const arcgisSymbolStylerColorRampInputCss = ".scroller{max-height:var(--scroller-max-height, 200px);overflow-y:auto;min-width:200px;overflow-x:hidden;display:flex;justify-content:center}.color-ramp-item{display:inline-flex;flex-grow:1}.color-ramp-item svg{display:flex}.color-picker-container{display:flex;flex-direction:column}.color-picker-container arcgis-item-palette .palette{gap:20px}calcite-color-picker-swatch{width:200px}.section{display:flex;flex-direction:column;padding:12px;background-color:var(--arcgis-app-background)}.color-ramp-selection{padding:4px 20px 4px 4px;border:1px solid lightgray;border-top:none}.arcgis--rtl .color-ramp-selection{padding:4px 4px 4px 20px;}.color-ramp-flipper calcite-icon{margin:0 0.5rem}[slot=preview] .color-ramp-item{height:24px}";

const ArcgisSymbolStylerColorRampInput = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.setInlineInputRef = (el) => {
      this.inlineInputEl = el;
    };
    this.disabled = false;
    this.options = undefined;
    this.placement = "auto";
    this.popoverProps = undefined;
    this.strings = undefined;
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  async setFocus() {
    var _a;
    await ((_a = this.inlineInputEl) === null || _a === void 0 ? void 0 : _a.setFocus());
  }
  async close() {
    var _a;
    await ((_a = this.inlineInputEl) === null || _a === void 0 ? void 0 : _a.close());
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { disabled, strings } = this;
    const dir = (0,_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.el);
    return ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-symbol-styler-inline-input", { disabled: disabled, intlDone: strings.done, heading: strings.ramp, label: this.options.heading, popoverProps: this.popoverProps, ref: this.setInlineInputRef, class: {
        [_languageUtil_22258c90_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: dir === "rtl"
      } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: CSS$2.colorPickerContainer, slot: "content" }, this.renderRampsContent(this.options)), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "preview" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(ColorRampItem, { stops: this.options.colorRampStops.slice().reverse(), style: this.options.style, layout: "horizontal", height: "100%", width: "100%" })))));
  }
  renderRampsContent({ activeCategory, colorRamps, isSelected, onCategoryChange, onFlip, onSelect, style }) {
    const { strings } = this;
    const { categories, ramps } = this.getCategoriesAndColorRampsBySelectedCategory(activeCategory, colorRamps);
    const is2D = style === "2d";
    const rampFlipIcon = is2D ? "rotate" : "arrow-up-down";
    const rampFlipLabel = is2D ? strings.rotateColors : strings.flipColors;
    const rampItemRenderer = is2D ? RelationshipRampColorRampItem : ColorRampItem;
    const rampsPerRow = is2D ? 3 : 6;
    return [
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "section" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.strings.category, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { width: "full", label: this.strings.category, onCalciteSelectChange: onCategoryChange }, categories.map((category) => ((0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { value: category, label: strings.categories[category], selected: category === activeCategory }))))), (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { class: _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__.C.colorRampFlipper, appearance: "transparent", onClick: (e) => {
          e.preventDefault();
          e.stopImmediatePropagation();
          onFlip();
        }, scale: "s", width: "full" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: rampFlipIcon, scale: "s", style: is2D ? { transform: "rotateY(180deg)" } : null }), rampFlipLabel)),
      (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: { [_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__.C.scroller]: true, [_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__.C.colorRampSelection]: true } }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-item-palette", { items: ramps, extraItemProps: { style }, ItemRenderer: rampItemRenderer, itemsPerRow: rampsPerRow, selected: isSelected, onArcgisItemSelect: onSelect }))
    ];
  }
  getCategoriesAndColorRampsBySelectedCategory(activeCategory, allRamps) {
    const activeTags = _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__.F[activeCategory];
    const activeRamps = allRamps.filter((colorRamp) => activeCategory === "all" || activeTags.some((tag) => colorRamp.tags.indexOf(tag) > -1));
    const usedTagsSet = new Set();
    allRamps.forEach((ramp) => ramp.tags.forEach((tag) => usedTagsSet.add(tag)));
    const categories = Object.keys(_colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__.F).filter((category) => category === "all" || _colorRampUtils_7e6d2ad8_js__WEBPACK_IMPORTED_MODULE_6__.F[category].some((tag) => usedTagsSet.has(tag)));
    return {
      categories,
      ramps: activeRamps
    };
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisSymbolStylerColorRampInput.style = arcgisSymbolStylerColorRampInputCss;

const arcgisSymbolStylerSectionCss = ":host{display:flex;flex-direction:column;background-color:var(--arcgis-app-background);padding:16px 12px}:host([disabled]){opacity:var(--arcgis-app-disabled-opacity);pointer-events:none}:host([embedded]){padding:0}";

const ArcgisSymbolStylerSection = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.disabled = false;
    this.embedded = false;
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    return (
    /* intentionally using attribute to avoid focusing container when !disabled */
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { tabindex: this.disabled ? -1 : "" }, (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null)));
  }
};
ArcgisSymbolStylerSection.style = arcgisSymbolStylerSectionCss;

const arcgisSymbolStylerSymbolPreviewCss = ":host{display:inline-block}:host(.dark){background-color:#f3f3f3}";

const ArcgisSymbolStylerSymbolPreview = class {
  constructor(hostRef) {
    (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    this.updatePreview = (0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_8__.d)(async () => {
      var _a;
      const { symbol } = this;
      if (!symbol) {
        return;
      }
      const options = Object.assign({}, this.options);
      // we drop size to prevent a known rendering issue â€“ https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/41790
      if (symbol.type === "cim" && symbol.data.symbol.type === "CIMPolygonSymbol") {
        delete options.size;
      }
      const printSymbol = symbol.clone();
      if (printSymbol.type === "picture-marker" && options.size && typeof options.size === "number") {
        // renderPreviewHTML doesn't work well with non-square PMS
        // change symbol to the size we need instead
        printSymbol.width = (printSymbol.width / printSymbol.height) * options.size;
        printSymbol.height = options.size;
      }
      const currentPreviewRender = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_7__.e.symbolUtils.renderPreviewHTML(printSymbol, options);
      this.lastPreviewRender = currentPreviewRender;
      const preview = await currentPreviewRender;
      const previewIsOutdated = this.lastPreviewRender !== currentPreviewRender;
      if (previewIsOutdated) {
        return;
      }
      (_a = this.lastPreview) === null || _a === void 0 ? void 0 : _a.remove();
      this.lastPreview = preview;
      this.el.shadowRoot.append(preview);
      this.backgroundTheme = _color_776689e9_js__WEBPACK_IMPORTED_MODULE_7__.e.previewSymbol2D.getContrastingBackgroundTheme(symbol, 245);
    }, 250);
    this.backgroundTheme = "light";
    this.contrast = false;
    this.options = undefined;
    this.symbol = undefined;
  }
  watchSymbolAndOptions() {
    this.updatePreview();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentDidLoad() {
    await this.updatePreview();
  }
  render() {
    return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: { dark: this.contrast && this.backgroundTheme === "dark" } });
  }
  get el() { return (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
  static get watchers() { return {
    "symbol": ["watchSymbolAndOptions"],
    "options": ["watchSymbolAndOptions"]
  }; }
};
ArcgisSymbolStylerSymbolPreview.style = arcgisSymbolStylerSymbolPreviewCss;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorRampUtils-7e6d2ad8.js":
/*!********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorRampUtils-7e6d2ad8.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ markerPlacementStepMin),
/* harmony export */   B: () => (/* binding */ markerPlacementRandomnessMax),
/* harmony export */   C: () => (/* binding */ CSS),
/* harmony export */   D: () => (/* binding */ markerPlacementRandomnessMin),
/* harmony export */   E: () => (/* binding */ expand2D),
/* harmony export */   F: () => (/* binding */ categoriesToTags),
/* harmony export */   a: () => (/* binding */ maxWidthInPx),
/* harmony export */   b: () => (/* binding */ supportedStyles),
/* harmony export */   c: () => (/* binding */ defaultVisibleColorSectionParts),
/* harmony export */   d: () => (/* binding */ defaultVisibleMarkerSectionParts),
/* harmony export */   e: () => (/* binding */ defaultVisibleColorRampSectionParts),
/* harmony export */   f: () => (/* binding */ flipColorRampStops),
/* harmony export */   g: () => (/* binding */ defaultVisibleExtraStrokeSectionParts),
/* harmony export */   h: () => (/* binding */ defaultVisibleStrokeSectionParts),
/* harmony export */   i: () => (/* binding */ maxDisplayedSymbolLayers),
/* harmony export */   j: () => (/* binding */ colorStorageId),
/* harmony export */   k: () => (/* binding */ opacityMax),
/* harmony export */   l: () => (/* binding */ rotationMax),
/* harmony export */   m: () => (/* binding */ minWidthInPx),
/* harmony export */   n: () => (/* binding */ sizeMin),
/* harmony export */   o: () => (/* binding */ opacityMin),
/* harmony export */   p: () => (/* binding */ pointPreviewOptions),
/* harmony export */   q: () => (/* binding */ sizeMax),
/* harmony export */   r: () => (/* binding */ rotationMin),
/* harmony export */   s: () => (/* binding */ supportedArrows),
/* harmony export */   t: () => (/* binding */ hatchFillOffsetMax),
/* harmony export */   u: () => (/* binding */ hatchFillOffsetMin),
/* harmony export */   v: () => (/* binding */ hatchFillSeparationMax),
/* harmony export */   w: () => (/* binding */ hatchFillSeparationMin),
/* harmony export */   x: () => (/* binding */ animationDurationMax),
/* harmony export */   y: () => (/* binding */ animationDurationMin),
/* harmony export */   z: () => (/* binding */ markerPlacementStepMax)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
const CSS = {
  customSymbolContent: "custom-symbol-content",
  autoAdjustLabel: "auto-adjust-label",
  styleDropdown: "style-dropdown",
  arrowDropdown: "arrow-dropdown",
  iconDropdown: "icon-dropdown",
  iconDropdownSelected: "icon-dropdown--selected",
  iconDropdownItemContent: "icon-dropdown-item-content",
  colorRampFlipper: "color-ramp-flipper",
  scroller: "scroller",
  colorRampSelection: "color-ramp-selection",
  sectionToggleDisabled: "section-toggle--disabled",
  autoAdjustCheckbox: "auto-adjust-checkbox",
  contentGroup: "content-group",
  colorLockedInfo: "color-locked-info",
  message: "message",
  // symbol button
  container: "container",
  label: "label",
  openIcon: "open-icon",
  symbol: "symbol",
  changeSymbolTrigger: "change-symbol-trigger"
};
const categoriesToTags = {
  all: ["*"],
  light: ["light"],
  dark: ["dark"],
  redsAndYellows: ["oranges", "reds", "yellows"],
  greens: ["greens"],
  blues: ["blues"],
  purplesAndPinks: ["purples", "pinks"],
  browns: ["browns"],
  grays: ["grays"],
  bright: ["bright"],
  subdued: ["subdued"],
  colorblindFriendly: ["colorblind-friendly"]
};
const supportedArrows = ["none", "begin", "end", "begin-end"];
const supportedStyles = [
  "solid",
  "dash",
  "dot",
  "dash-dot",
  "long-dash-dot-dot",
  "short-dash",
  "short-dot",
  "short-dash-dot",
  "short-dash-dot-dot",
  "long-dash",
  "long-dash-dot"
];
const defaultVisibleMarkerSectionParts = {
  size: true,
  preview: true,
  rotation: true
};
const defaultVisibleExtraStrokeSectionParts = {
  style: true,
  arrow: true,
  width: true,
  autoStrokeAdjust: false
};
const defaultVisibleColorSectionParts = {
  suggestedColors: true,
  customColor: true,
  transparency: true
};
const defaultVisibleColorRampSectionParts = {
  colorRamps: true,
  transparency: true
};
const defaultVisibleStrokeSectionParts = {
  extra: true
};
const colorStorageId = "arcgis-symbol-styler-storage-colors";
const pointPreviewOptions = {
  size: 24,
  maxSize: 24
};
const opacityMax = 100;
const opacityMin = 0;
const maxWidthInPx = 18;
const minWidthInPx = 0;
const rotationMax = 360;
const rotationMin = 0;
const sizeMax = 150;
const sizeMin = 1;
const markerPlacementStepMax = 200;
const markerPlacementStepMin = 0;
const markerPlacementRandomnessMax = 100;
const markerPlacementRandomnessMin = 0;
const maxDisplayedSymbolLayers = 10;
const hatchFillSeparationMax = 200;
const hatchFillSeparationMin = 0;
const hatchFillOffsetMax = 100;
const hatchFillOffsetMin = 0;
const animationDurationMax = 120;
const animationDurationMin = 0;

function flipColorRampStops(stops, is2d = false) {
  return is2d ? flipFlattened2DRamp(stops) : stops.slice().reverse();
}
function flipFlattened2DRamp(flat2dStops) {
  const numClasses = Math.sqrt(flat2dStops.length);
  const ramp2d = expand2D(flat2dStops);
  const oldRamp = ramp2d.reverse();
  const flippedRamp = [];
  // Flip 2D matrix of colors by 90 degrees in clockwise direction.
  for (let i = 0; i < numClasses; i++) {
    const newRow = [];
    oldRamp.forEach((oldRow) => newRow.push(oldRow[i]));
    flippedRamp.push(newRow);
  }
  return flatten2D(flippedRamp).reverse();
}
function expand2D(stops, focus) {
  let expandedArray = [];
  const numClasses = Math.sqrt(stops.length);
  // Focus decides whether we reverse the outer/inner arrays or not.
  const codes = (focus || "HH").split("");
  const startRowCode = codes[0];
  const startColCode = codes[1];
  const reverseEachRow = startColCode !== "H";
  for (let i = 0; i < numClasses; i++) {
    let row = [];
    for (let j = 0; j < numClasses; j++) {
      const index = i * numClasses + j;
      row.push(stops[index]);
    }
    if (reverseEachRow) {
      row.reverse();
    }
    expandedArray.push(row);
  }
  if (startRowCode === "L") {
    expandedArray.reverse();
  }
  return expandedArray;
}
function flatten2D(array2d, focus) {
  // Returns a flattened array from the given 2d array.
  // array2d is assumed to have the layout structure outlined at:
  // renderers/utils:getClassValuesForRelationship.
  // Order of elements in the output array is determined by "focus".
  // "focus" can be: HH, HL, LH or LL. Default is "HH".
  let flatArray = [];
  // clone to avoid modifying source data
  array2d = array2d.slice().map((colors) => colors.slice());
  // Focus decides whether we reverse the outer/inner arrays or not.
  const codes = (focus || "HH").split(""), startRowCode = codes[0], startColCode = codes[1];
  if (startRowCode === "L") {
    array2d.reverse();
  }
  const reverseEachRow = startColCode === "H";
  array2d.forEach((row) => {
    if (reverseEachRow) {
      row.slice().reverse();
    }
    flatArray = flatArray.concat(row);
  });
  return flatArray;
}




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-a5d93b58.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/popupStore-a5d93b58.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ clearPopupState),
/* harmony export */   p: () => (/* binding */ popupState)
/* harmony export */ });
/* harmony import */ var _index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-81d548b7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const popupStore = (0,_index_81d548b7_js__WEBPACK_IMPORTED_MODULE_0__.c)({
  layer: null,
  mapView: null,
  portal: null,
  config: null,
  strings: null,
  currentLanguage: null,
  currentLanguageIntl: null,
  serviceType: null,
  popupTemplate: null,
  layerHasAttachment: null,
  layerHasET: null,
  layerHasAttributes: null,
  layerHasCharts: null,
  layerHasImages: null,
  layerHasText: null,
  layerDisplayType: null,
  supportsArcade: null,
  layerHasRelatedRecords: false
});
// workaround for starting a panel with a clean state
function clearPopupState(popupState) {
  popupState.layer = null;
  popupState.mapView = null;
  popupState.portal = null;
  popupState.config = null;
  popupState.strings = null;
  popupState.currentLanguage = null;
  popupState.currentLanguageIntl = null;
  popupState.serviceType = null;
  popupState.popupTemplate = null;
  popupState.layerHasAttachment = null;
  popupState.layerHasET = null;
  popupState.layerHasAttributes = null;
  popupState.layerHasCharts = null;
  popupState.layerHasImages = null;
  popupState.layerHasText = null;
  popupState.layerDisplayType = null;
  popupState.supportsArcade = null;
  popupState.layerHasRelatedRecords = false;
}
const popupState = popupStore.state;




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-d7f5822e.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/storage-d7f5822e.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getCookie),
/* harmony export */   b: () => (/* binding */ setCookie),
/* harmony export */   c: () => (/* binding */ setSessionStorageItem),
/* harmony export */   d: () => (/* binding */ getSessionStorageItem),
/* harmony export */   g: () => (/* binding */ getLocalStorageItem),
/* harmony export */   s: () => (/* binding */ setLocalStorageItem)
/* harmony export */ });
/* harmony import */ var _functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional-c82f5ab9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


// import stringUtil from "./strings";
/**
 * Utility methods for dealing with storage of various forms (cookies, local storage, and session storage).
 */
function setCookie(name, cookie, properties, stringify) {
  writeCookie(name, stringify ? JSON.stringify(cookie) : cookie, properties);
}
function getCookie(name, parse) {
  const cookie = readCookie(name);
  return cookie && parse ? JSON.parse(cookie) : cookie;
}
function setLocalStorageItem(name, item, stringify) {
  window.localStorage.setItem(name, stringify ? JSON.stringify(item) : item);
}
function getLocalStorageItem(name, parse) {
  const item = window.localStorage.getItem(name);
  return item && parse ? JSON.parse(item) : item;
}
function setSessionStorageItem(name, item, stringify) {
  window.sessionStorage.setItem(name, stringify ? JSON.stringify(item) : item);
}
function getSessionStorageItem(name, parse) {
  const item = window.sessionStorage.getItem(name);
  return item && parse ? JSON.parse(item) : item;
}
function readCookie(name) {
  const cookie = document.cookie;
  const cookieNameRE = new RegExp(`(?:^|; )${(0,_functional_c82f5ab9_js__WEBPACK_IMPORTED_MODULE_0__.e)(name)}=([^;]*)`);
  const matchedCookies = cookie.match(cookieNameRE);
  return matchedCookies ? decodeURIComponent(matchedCookies[1]) : undefined;
}
function writeCookie(name, value, properties) {
  properties = properties || {};
  let expires = properties === null || properties === void 0 ? void 0 : properties.expires;
  if (typeof expires === "number") {
    const expirationDate = new Date();
    const daysFromTodayInMs = expires * 24 * 60 * 60 * 1000;
    expirationDate.setTime(Date.now() + daysFromTodayInMs);
    expires = properties.expires = expirationDate;
  }
  if (typeof expires !== "string" && (expires === null || expires === void 0 ? void 0 : expires.toUTCString)) {
    properties.expires = expires.toUTCString();
  }
  let cookie = `${name}=${encodeURIComponent(value)}`;
  let property;
  for (property in properties) {
    cookie += `; ${property}`;
    const propertyValue = properties[property];
    if (propertyValue !== true) {
      cookie += `=${propertyValue}`;
    }
  }
  document.cookie = cookie;
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTEzMTlhNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RztBQUN2QztBQUNxQjtBQUNUO0FBQ3ZCO0FBQ0U7QUFDbUM7QUFDNUI7QUFDWDtBQUM5QjtBQUNFOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFLGNBQWMsd0JBQXdCLGFBQWEsc0JBQXNCLGNBQWMsa0NBQWtDLDJDQUEyQyxXQUFXLFlBQVksUUFBUSxtQkFBbUIseUJBQXlCLGFBQWEsUUFBUSxZQUFZLGdCQUFnQiw2RUFBNkUsY0FBYywwQ0FBMEMsbUJBQW1CLGtEQUFrRCxlQUFlLDBDQUEwQywwQ0FBMEMsbUJBQW1CLGtEQUFrRCxtQkFBbUIsY0FBYyxlQUFlLDRCQUE0QixrQkFBa0Isb0JBQW9COztBQUV6MEI7QUFDQTtBQUNBLElBQUkscURBQWdCO0FBQ3BCLGtDQUFrQyxxREFBVztBQUM3QywrQ0FBK0MscURBQVc7QUFDMUQsdUNBQXVDLHFEQUFXO0FBQ2xELHdDQUF3QyxxREFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUJBQXlCO0FBQ3REO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pEakQ7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHLDBEQUFZLE9BQU8sS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxHQUFHLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsU0FBUztBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRXNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWNvbG9yLWlucHV0XzcuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vY29sb3JSYW1wVXRpbHMtN2U2ZDJhZDguanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaW5kZXgtODFkNTQ4YjcuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcG9wdXBTdG9yZS1hNWQ5M2I1OC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9zdG9yYWdlLWQ3ZjU4MjJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtOTJlYmIzOTYuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMTNlMDBhNzUuanMnO1xuaW1wb3J0IHsgcyBhcyBzZXRMb2NhbFN0b3JhZ2VJdGVtLCBnIGFzIGdldExvY2FsU3RvcmFnZUl0ZW0gfSBmcm9tICcuL3N0b3JhZ2UtZDdmNTgyMmUuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRFbGVtZW50RGlyLCBDIGFzIENTU19VVElMSVRZIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtMjIyNThjOTAuanMnO1xuaW1wb3J0IHsgcCBhcyBwb3B1cFN0YXRlIH0gZnJvbSAnLi9wb3B1cFN0b3JlLWE1ZDkzYjU4LmpzJztcbmltcG9ydCB7IGwgYXMgbG9hZE1vZHVsZXMgfSBmcm9tICcuL2xvYWRNb2R1bGVzLWFhZjMwYmQ2LmpzJztcbmltcG9ydCB7IEUgYXMgZXhwYW5kMkQsIEMgYXMgQ1NTJDQsIEYgYXMgY2F0ZWdvcmllc1RvVGFncyB9IGZyb20gJy4vY29sb3JSYW1wVXRpbHMtN2U2ZDJhZDguanMnO1xuaW1wb3J0IHsgZCBhcyBjcmVhdGUsIGUgYXMgZXNyaU1vZHVsZXMgfSBmcm9tICcuL2NvbG9yLTc3NjY4OWU5LmpzJztcbmltcG9ydCB7IGQgYXMgZGVib3VuY2UgfSBmcm9tICcuL2Z1bmN0aW9uYWwtYzgyZjVhYjkuanMnO1xuaW1wb3J0ICcuL2RvbS0xM2Y1YjAwYy5qcyc7XG5pbXBvcnQgJy4vaW5kZXgtODFkNTQ4YjcuanMnO1xuXG5jb25zdCBDU1MkMyA9IHtcbiAgcmVjZW50OiBcInJlY2VudFwiLFxuICBwcmV2aWV3OiBcInByZXZpZXdcIixcbiAgY29sb3JQaWNrZXJDb250YWluZXI6IFwiY29sb3ItcGlja2VyLWNvbnRhaW5lclwiXG59O1xuY29uc3QgZGVmYXVsdENvbG9yID0gXCIjZDAwYjMzXCI7XG5cbmNvbnN0IGFyY2dpc0NvbG9ySW5wdXRDc3MgPSBcIjpob3N0LGFyY2dpcy1zeW1ib2wtc3R5bGVyLWlubGluZS1pbnB1dHtkaXNwbGF5OmJsb2NrfS5jb2xvci1waWNrZXItY29udGFpbmVye2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmNvbG9yLXBpY2tlcnstLWNhbGNpdGUtdWktYm9yZGVyLTE6dHJhbnNwYXJlbnR9W3Nsb3Q9cHJldmlld10gY2FsY2l0ZS1jb2xvci1waWNrZXItc3dhdGNoe3dpZHRoOjEwMCU7aGVpZ2h0OjI0cHh9LnJlY2VudHthbGlnbi1pdGVtczpjZW50ZXI7Ym9yZGVyOjFweCBzb2xpZCAjOTQ5NDk0O2Rpc3BsYXk6ZmxleDtnYXA6OHB4O2hlaWdodDozMnB4O3BhZGRpbmc6MHB4IDZweDt0cmFuc2l0aW9uOm91dGxpbmUtb2Zmc2V0IDEwMG1zIGVhc2UtaW4tb3V0LCBvdXRsaW5lLWNvbG9yIDEwMG1zIGVhc2UtaW4tb3V0fS5yZWNlbnQ6Zm9jdXN7b3V0bGluZToycHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7b3V0bGluZS1vZmZzZXQ6MnB4fS5yZWNlbnQgY2FsY2l0ZS1jb2xvci1waWNrZXItc3dhdGNoOm5vdChbYWN0aXZlXSl7Y3Vyc29yOnBvaW50ZXJ9LnJlY2VudCBjYWxjaXRlLWNvbG9yLXBpY2tlci1zd2F0Y2g6Zm9jdXN7b3V0bGluZToycHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7b3V0bGluZS1vZmZzZXQ6MnB4fS5yZWNlbnQgY2FsY2l0ZS1jb2xvci1waWNrZXItc3dhdGNoOmZvY3VzW2FjdGl2ZV17Ym9yZGVyLXJhZGl1czoxMDAlfS5lbXB0eS1zd2F0Y2h7Y3Vyc29yOmRlZmF1bHR9Y2FsY2l0ZS10b29sdGlwOm5vdChbb3Blbl0pe3Zpc2liaWxpdHk6aGlkZGVuO3BvaW50ZXItZXZlbnRzOm5vbmV9XCI7XG5cbmNvbnN0IEFyY2dpc0NvbG9ySW5wdXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzQ29sb3JJbnB1dENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzQ29sb3JJbnB1dENoYW5nZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc0ludGVybmFsQ29sb3JJbnB1dFN0b3JlZENvbG9yID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNJbnRlcm5hbENvbG9ySW5wdXRTdG9yZWRDb2xvclwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc0NvbG9ySW5wdXRQb3BvdmVyT3BlbiA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzQ29sb3JJbnB1dFBvcG92ZXJPcGVuXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzQ29sb3JJbnB1dFBvcG92ZXJDbG9zZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzQ29sb3JJbnB1dFBvcG92ZXJDbG9zZVwiLCA3KTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgRXZlbnQgTGlzdGVuZXJzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5mb2N1c0hhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMuYWN0aXZlRWwgPSBldmVudC50YXJnZXQ7XG4gICAgfTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5vbkNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLnN0b3JlUmVjZW50Q29sb3JUb1N0b3JhZ2UoKF9hID0gdGhpcy5jb2xvclBpY2tlckVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmFyY2dpc0NvbG9ySW5wdXRQb3BvdmVyQ2xvc2UuZW1pdCgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTd2F0Y2hDbGlja09yS2V5VXAgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChcImtleVwiIGluIGV2ZW50ICYmIGV2ZW50LmtleSAhPT0gXCJFbnRlclwiICYmIGV2ZW50LmtleSAhPT0gXCJTcGFjZVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN3YXRjaCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBzZWxlY3RlZCA9IHN3YXRjaC5jb2xvcjtcbiAgICAgIHRoaXMudXBkYXRlQ29sb3Ioc2VsZWN0ZWQpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlY2VudENvbG9yMUVsLmZvY3VzKCksIDIwMCk7XG4gICAgfTtcbiAgICB0aGlzLnJlY2VudENvbG9yc0tleURvd25IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWNlbnRDb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleTtcbiAgICAgIGxldCBhY3RpdmVSZWNlbnRDb2xvckluZGV4O1xuICAgICAgaWYgKHRoaXMuYWN0aXZlRWwgPT09IHRoaXMucmVjZW50Q29sb3IxRWwpIHtcbiAgICAgICAgYWN0aXZlUmVjZW50Q29sb3JJbmRleCA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZUVsID09PSB0aGlzLnJlY2VudENvbG9yMkVsKSB7XG4gICAgICAgIGFjdGl2ZVJlY2VudENvbG9ySW5kZXggPSAyO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVFbCA9PT0gdGhpcy5yZWNlbnRDb2xvcjNFbCkge1xuICAgICAgICBhY3RpdmVSZWNlbnRDb2xvckluZGV4ID0gMztcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVSZWNlbnRDb2xvckluZGV4IHx8IGFjdGl2ZVJlY2VudENvbG9ySW5kZXggPT09IDEpIHtcbiAgICAgICAgICB0aGlzW2ByZWNlbnRDb2xvciR7dGhpcy5yZWNlbnRDb2xvcnMubGVuZ3RofUVsYF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzW2ByZWNlbnRDb2xvciR7YWN0aXZlUmVjZW50Q29sb3JJbmRleCAtIDF9RWxgXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcIkFycm93UmlnaHRcIikge1xuICAgICAgICBpZiAoIWFjdGl2ZVJlY2VudENvbG9ySW5kZXggfHwgYWN0aXZlUmVjZW50Q29sb3JJbmRleCA9PT0gdGhpcy5yZWNlbnRDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5yZWNlbnRDb2xvcjFFbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXNbYHJlY2VudENvbG9yJHthY3RpdmVSZWNlbnRDb2xvckluZGV4ICsgMX1FbGBdLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2V0SW5saW5lSW5wdXRSZWYgPSAoZWwpID0+IHtcbiAgICAgIHRoaXMuaW5saW5lSW5wdXRFbCA9IGVsO1xuICAgIH07XG4gICAgdGhpcy5zZXRDb2xvclBpY2tlclJlZiA9IChlbCkgPT4ge1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHRoaXMuY29sb3JQaWNrZXJFbCA9IGVsO1xuICAgICAgfVxuICAgICAgLy8gd2UgZ2V0IGEgc2Vjb25kIGNhbGwgb2YgdGhpcyB3aXRoIGVsPW51bGwgZS5nLiB3aGVuIHRvZ2dsaW5nIG9uIGJhY2tncm91bmQgY29sb3IgaW4gTWFwIFZpZXdlclxuICAgIH07XG4gICAgdGhpcy5zZXRSZWNlbnRDb2xvclJlZjEgPSAoZWwpID0+IHtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICB0aGlzLnJlY2VudENvbG9yMUVsID0gZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNldFJlY2VudENvbG9yUmVmMiA9IChlbCkgPT4ge1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHRoaXMucmVjZW50Q29sb3IyRWwgPSBlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2V0UmVjZW50Q29sb3JSZWYzID0gKGVsKSA9PiB7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdGhpcy5yZWNlbnRDb2xvcjNFbCA9IGVsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbk9wZW4gPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLmNvbG9yUGlja2VyRWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpO1xuICAgICAgdGhpcy5hcmNnaXNDb2xvcklucHV0UG9wb3Zlck9wZW4uZW1pdCgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDbGVhciA9ICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlQ29sb3IobnVsbCk7XG4gICAgfTtcbiAgICB0aGlzLmNsZWFyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgdGhpcy5jb21wYWN0ID0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJhdXRvXCI7XG4gICAgdGhpcy5wb3BvdmVyUHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9yYWdlSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZWNlbnRDb2xvcnMgPSBbXTtcbiAgfVxuICBzdG9yZWRDb2xvckhhbmRsZXIoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKHRoaXMuZWwpKSB7XG4gICAgICB0aGlzLnNldFJlY2VudENvbG9yc0Zyb21TdG9yYWdlKCk7XG4gICAgfVxuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFB1YmxpYyBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGF3YWl0ICgoX2EgPSB0aGlzLmlubGluZUlucHV0RWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpKTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBhd2FpdCB0aGlzLmlubGluZUlucHV0RWwuY2xvc2UoKTtcbiAgfVxuICB1cGRhdGVDb2xvcihjb2xvciwgc2F2ZSA9IHRydWUpIHtcbiAgICBpZiAoY29sb3IgPT09IHRoaXMuY29sb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuYXJjZ2lzQ29sb3JJbnB1dENoYW5nZS5lbWl0KCk7XG4gICAgaWYgKHNhdmUpIHtcbiAgICAgIHRoaXMuc3RvcmVSZWNlbnRDb2xvclRvU3RvcmFnZShjb2xvcik7XG4gICAgfVxuICB9XG4gIHN0b3JlUmVjZW50Q29sb3JUb1N0b3JhZ2UoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY2VudENvbG9ycyA9IFtjb2xvciwgLi4udGhpcy5yZWNlbnRDb2xvcnMuZmlsdGVyKChyZWNlbnQpID0+IHJlY2VudCAhPT0gY29sb3IpXS5zbGljZSgwLCAzKTtcbiAgICBzZXRMb2NhbFN0b3JhZ2VJdGVtKHRoaXMuc3RvcmFnZUlkLCByZWNlbnRDb2xvcnMsIHRydWUpO1xuICAgIHRoaXMucmVjZW50Q29sb3JzID0gcmVjZW50Q29sb3JzO1xuICAgIHRoaXMuYXJjZ2lzSW50ZXJuYWxDb2xvcklucHV0U3RvcmVkQ29sb3IuZW1pdCgpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgIFt0aGlzLnN0cmluZ3NdID0gYXdhaXQgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyh0aGlzLmVsKTtcbiAgICB0aGlzLnNldFJlY2VudENvbG9yc0Zyb21TdG9yYWdlKCk7XG4gIH1cbiAgc2V0UmVjZW50Q29sb3JzRnJvbVN0b3JhZ2UoKSB7XG4gICAgY29uc3QgcmVjZW50Q29sb3JzID0gZ2V0TG9jYWxTdG9yYWdlSXRlbSh0aGlzLnN0b3JhZ2VJZCwgdHJ1ZSk7XG4gICAgaWYgKHJlY2VudENvbG9ycykge1xuICAgICAgdGhpcy5yZWNlbnRDb2xvcnMgPSBbLi4ucmVjZW50Q29sb3JzXTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVUb29sdGlwKCk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUmVuZGVyIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb21wYWN0LCBkaXNhYmxlZCwgcmVjZW50Q29sb3JzLCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlY2VudHMgPSBbcmVjZW50Q29sb3JzWzBdLCByZWNlbnRDb2xvcnNbMV1dO1xuICAgIGNvbnN0IHJ0bCA9IGdldEVsZW1lbnREaXIodGhpcy5lbCkgPT09IFwicnRsXCI7XG4gICAgaWYgKCFjb21wYWN0KSB7XG4gICAgICByZWNlbnRzLnB1c2gocmVjZW50Q29sb3JzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1pbmxpbmUtaW5wdXRcIiwgeyBkaXNhYmxlZDogZGlzYWJsZWQsIGludGxEb25lOiBzdHJpbmdzLmNvbW1pdENvbG9yLCBoZWFkaW5nOiBzdHJpbmdzLnNlbGVjdENvbG9yLCBsYWJlbDogc3RyaW5ncy5zZWxlY3RDb2xvciwgb25BcmNnaXNTeW1ib2xTdHlsZXJJbmxpbmVJbnB1dENsb3NlOiB0aGlzLm9uQ2xvc2UsIG9uQXJjZ2lzU3ltYm9sU3R5bGVySW5saW5lSW5wdXRPcGVuOiB0aGlzLm9uT3BlbiwgcG9wb3ZlclByb3BzOiB0aGlzLnBvcG92ZXJQcm9wcywgcmVmOiB0aGlzLnNldElubGluZUlucHV0UmVmIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTJDMuY29sb3JQaWNrZXJDb250YWluZXIsIHNsb3Q6IFwiY29udGVudFwiIH0sIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlclwiLCB7IGFsbG93RW1wdHk6IHRoaXMuY2xlYXJhYmxlLCBjbGFzczogXCJjb2xvci1waWNrZXJcIiwga2V5OiBgY29sb3ItcGlja2VyJHtjb21wYWN0ID8gXCItLWNvbXBhY3RcIiA6IFwiXCJ9YCwgb25DYWxjaXRlQ29sb3JQaWNrZXJJbnB1dDogKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IodGhpcy5jb2xvclBpY2tlckVsLnZhbHVlLCBmYWxzZSk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSwgcmVmOiB0aGlzLnNldENvbG9yUGlja2VyUmVmLCBzY2FsZTogY29tcGFjdCA/IFwic1wiIDogXCJtXCIsIHN0b3JhZ2VJZDogdGhpcy5zdG9yYWdlSWQsIHZhbHVlOiB0aGlzLmNvbG9yIH0pKSwgaChcImRpdlwiLCB7IHNsb3Q6IFwicHJldmlld1wiIH0sIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlci1zd2F0Y2hcIiwgeyBjb2xvcjogdGhpcy5jb2xvciwgc2NhbGU6IFwic1wiIH0pKSwgaChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbFwiOiBzdHJpbmdzLnJlY2VudENvbG9ycywgY2xhc3M6IENTUyQzLnJlY2VudCwgb25LZXlEb3duOiB0aGlzLnJlY2VudENvbG9yc0tleURvd25IYW5kbGVyLCBzbG90OiBcImNvbnRlbnQtZW5kXCIsIHRhYmluZGV4OiAtMSB9LCByZWNlbnRzLm1hcCgocmVjZW50LCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHJlY2VudCA/IChoKFwiY2FsY2l0ZS1jb2xvci1waWNrZXItc3dhdGNoXCIsIHsgYWN0aXZlOiByZWNlbnQgPT09IHRoaXMuY29sb3IsIGNvbG9yOiByZWNlbnQsIGtleTogcmVjZW50LCBvbkNsaWNrOiB0aGlzLmhhbmRsZVN3YXRjaENsaWNrT3JLZXlVcCwgb25Gb2N1czogdGhpcy5mb2N1c0hhbmRsZXIsIG9uS2V5VXA6IHRoaXMuaGFuZGxlU3dhdGNoQ2xpY2tPcktleVVwLCByZWY6IHRoaXNbYHNldFJlY2VudENvbG9yUmVmJHtpbmRleCArIDF9YF0sIHJvbGU6IFwiYnV0dG9uXCIsIHNjYWxlOiBcInNcIiwgdGFiaW5kZXg6IDAgfSkpIDogKHRoaXMucmVuZGVyRW1wdHlTd2F0Y2goYGVtcHR5LXN3YXRjaC0ke2luZGV4fWApKTtcbiAgICB9KSksIHRoaXMuY2xlYXJhYmxlICYmIFtcbiAgICAgIGgoXCJkaXZcIiwgeyBzbG90OiBcImNvbnRlbnQtZW5kXCIgfSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgaWNvbjogXCJjaXJjbGUtZGlzYWxsb3dlZFwiLFxuICAgICAgICAvL2lkPVwibm8taW5wdXQtYnV0dG9uXCJcbiAgICAgICAgc2NhbGU6IFwic1wiLCBsYWJlbDogc3RyaW5ncy5jbGVhckNvbG9yLCB0ZXh0OiBzdHJpbmdzLmNsZWFyQ29sb3IsIHJlZjogKG5vZGUpID0+ICh0aGlzLmFjdGlvbkVsID0gbm9kZSksIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xlYXIsIG9uTW91c2VPdmVyOiAoKSA9PiB0aGlzLmFkZFRvb2x0aXAoe1xuICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuYWN0aW9uRWwsXG4gICAgICAgICAgcGxhY2VtZW50OiBydGwgPyBcInJpZ2h0LXN0YXJ0XCIgOiBcImxlZnQtc3RhcnRcIixcbiAgICAgICAgICBpbm5lckhUTUw6IHN0cmluZ3Mubm9Db2xvclxuICAgICAgICB9KSwgb25Nb3VzZU91dDogKCkgPT4gdGhpcy5yZW1vdmVUb29sdGlwKCkgfSkpXG4gICAgXSkpKTtcbiAgfVxuICByZW5kZXJFbXB0eVN3YXRjaChrZXkpIHtcbiAgICByZXR1cm4gKGgoXCJzdmdcIiwgeyBjbGFzczogXCJlbXB0eS1zd2F0Y2hcIiwgdmlld0JveDogXCIwIDAgMjAgMjBcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjBcIiwga2V5OiBrZXkgfSwgaChcInJlY3RcIiwgeyB3aWR0aDogXCIyMFwiLCBoZWlnaHQ6IFwiMjBcIiwgZmlsbDogXCIjZjhmOGY4XCIsIHN0cm9rZTogXCIjMDAwXCIsIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBcIjJcIiB9KSkpO1xuICB9XG4gIGFkZFRvb2x0aXAocHJvcHMpIHtcbiAgICB0aGlzLnJlbW92ZVRvb2x0aXAoKTtcbiAgICB0aGlzLnRvb2x0aXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYWxjaXRlLXRvb2x0aXBcIik7XG4gICAgdGhpcy50b29sdGlwRWwucGxhY2VtZW50ID0gcHJvcHMucGxhY2VtZW50IHx8IFwiYXV0b1wiO1xuICAgIHRoaXMudG9vbHRpcEVsLnJlZmVyZW5jZUVsZW1lbnQgPSBwcm9wcy5yZWZlcmVuY2VFbGVtZW50O1xuICAgIHRoaXMudG9vbHRpcEVsLm92ZXJsYXlQb3NpdGlvbmluZyA9IFwiZml4ZWRcIjtcbiAgICB0aGlzLnRvb2x0aXBFbC5pbm5lckhUTUwgPSBwcm9wcy5pbm5lckhUTUw7XG4gICAgdGhpcy50b29sdGlwRWwub3BlbiA9IHRydWU7XG4gICAgLy8gaXQgd29uJ3Qgc2hvdyBpZiBqdXN0IGFkZGVkIHRvIHRoaXMuZWxcbiAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50b29sdGlwRWwpO1xuICB9XG4gIHJlbW92ZVRvb2x0aXAoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoX2EgPSB0aGlzLnRvb2x0aXBFbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMudG9vbHRpcEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy50b29sdGlwRWwpO1xuICAgICAgdGhpcy50b29sdGlwRWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbn07XG5BcmNnaXNDb2xvcklucHV0LnN0eWxlID0gYXJjZ2lzQ29sb3JJbnB1dENzcztcblxuY29uc3QgQXJjZ2lzUG9wdXBDb2xvclBvcG92ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzUG9wdXBDb2xvclBvcG92ZXJDbG9zZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzUG9wdXBDb2xvclBvcG92ZXJDbG9zZVwiLCA3KTtcbiAgICB0aGlzLmFyY2dpc1BvcHVwQ29sb3JQb3BvdmVyT3BlbiA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzUG9wdXBDb2xvclBvcG92ZXJPcGVuXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzUG9wdXBDb2xvclBvcG92ZXJDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1BvcHVwQ29sb3JQb3BvdmVyQ2hhbmdlXCIsIDcpO1xuICAgIHRoaXMuY2xvc2VkV2l0aEV2ZW50ID0gZmFsc2U7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMuaGFuZGxlUGFuZWxEaXNtaXNzZWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhbmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIGlmIChwYW5lbC5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBwYW5lbC5jbG9zZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEb25lID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQb3BvdmVyT3BlbiA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yUG9wb3Zlck9wZW4uZW1pdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgdGhpcy5hcmNnaXNQb3B1cENvbG9yUG9wb3ZlckNsb3NlLmVtaXQoKTtcbiAgICAgIHRoaXMuY2xvc2VkV2l0aEV2ZW50ID0gdHJ1ZTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQb3BvdmVyS2V5VXAgPSAoeyBrZXkgfSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5oZWFkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW50bERvbmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhleENvbG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9wb3ZlclByb3BzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICB9XG4gIGRpc2FibGVkQ2hhbmdlZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0aGlzLm9wZW4pIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgb25JbmxpbmVJbnB1dE9wZW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKHRoaXMuZWwpKSB7XG4gICAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgUHVibGljIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBzZXRGb2N1cygpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5wYW5lbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuYXJjZ2lzUG9wdXBDb2xvclBvcG92ZXJDbG9zZS5lbWl0KCk7XG4gICAgdGhpcy5jbG9zZWRXaXRoRXZlbnQgPSB0cnVlO1xuICB9XG4gIGFzeW5jIHNldE9wZW4ob3Blbikge1xuICAgIHRoaXMub3BlbiA9IG9wZW47XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlIE1ldGhvZHNcbiAgLy9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkV2l0aEV2ZW50KSB7XG4gICAgICB0aGlzLmFyY2dpc1BvcHVwQ29sb3JQb3BvdmVyQ2xvc2UuZW1pdCgpO1xuICAgIH1cbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHBvcG92ZXJQcm9wcyB9ID0gdGhpcztcbiAgICByZXR1cm4gKGgoSG9zdCwgeyBjbGFzczogXCJqcy1hcHAtZmx5b3V0XCIgfSwgaChcImNhbGNpdGUtcG9wb3ZlclwiLCB7IHBvaW50ZXJEaXNhYmxlZDogdHJ1ZSwgb25LZXlVcDogdGhpcy5oYW5kbGVQb3BvdmVyS2V5VXAsIGxhYmVsOiB0aGlzLmxhYmVsLCBvZmZzZXREaXN0YW5jZTogKHBvcG92ZXJQcm9wcyA9PT0gbnVsbCB8fCBwb3BvdmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcG92ZXJQcm9wcy5vZmZzZXREaXN0YW5jZSkgfHwgMCwgb2Zmc2V0U2tpZGRpbmc6IChwb3BvdmVyUHJvcHMgPT09IG51bGwgfHwgcG9wb3ZlclByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3BvdmVyUHJvcHMub2Zmc2V0U2tpZGRpbmcpIHx8IDAsIGZsaXBEaXNhYmxlZDogKHBvcG92ZXJQcm9wcyA9PT0gbnVsbCB8fCBwb3BvdmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcG92ZXJQcm9wcy5mbGlwRGlzYWJsZWQpIHx8IGZhbHNlLCBvcGVuOiB0aGlzLm9wZW4sIG92ZXJsYXlQb3NpdGlvbmluZzogKHBvcG92ZXJQcm9wcyA9PT0gbnVsbCB8fCBwb3BvdmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcG92ZXJQcm9wcy5vdmVybGF5UG9zaXRpb25pbmcpIHx8IFwiZml4ZWRcIiwgcmVmZXJlbmNlRWxlbWVudDogKHBvcG92ZXJQcm9wcyA9PT0gbnVsbCB8fCBwb3BvdmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcG92ZXJQcm9wcy5yZWZFbGVtZW50KSB8fCB0aGlzLnByZXZpZXdDb250YWluZXJFbCwgb25DYWxjaXRlUG9wb3ZlckNsb3NlOiB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSwgb25DYWxjaXRlUG9wb3Zlck9wZW46IHRoaXMuaGFuZGxlUG9wb3Zlck9wZW4sIHBsYWNlbWVudDogKHBvcG92ZXJQcm9wcyA9PT0gbnVsbCB8fCBwb3BvdmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcG92ZXJQcm9wcy5wbGFjZW1lbnQpIHx8IFwiYm90dG9tXCIgLy8gc2V0dGluZyB0byBib3R0b20gKHZzIGF1dG8pIHRvIHdvcmthcm91bmQgYWJzb2x1dGUgcGxhY2VtZW50IGlzc3VlXG4gICAgICAsXG4gICAgICB0cmlnZ2VyRGlzYWJsZWQ6IHRydWUgfSwgaChcImNhbGNpdGUtcGFuZWxcIiwgeyBjbG9zYWJsZTogdHJ1ZSwgb25DYWxjaXRlUGFuZWxDbG9zZTogdGhpcy5oYW5kbGVQYW5lbERpc21pc3NlZENoYW5nZSwgaGVhZGluZzogdGhpcy5oZWFkaW5nLCBzdHlsZTogKHBvcG92ZXJQcm9wcyA9PT0gbnVsbCB8fCBwb3BvdmVyUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcG92ZXJQcm9wcy5tYXhIZWlnaHQpICYmIHsgbWF4SGVpZ2h0OiBwb3BvdmVyUHJvcHMubWF4SGVpZ2h0IH0sIHJlZjogKG5vZGUpID0+ICh0aGlzLnBhbmVsRWxlbWVudCA9IG5vZGUpIH0sIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlclwiLCB7IGFsbG93RW1wdHk6IGZhbHNlLCBvbkNhbGNpdGVDb2xvclBpY2tlcklucHV0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgaGV4Q29sb3IgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMuYXJjZ2lzUG9wdXBDb2xvclBvcG92ZXJDaGFuZ2UuZW1pdChoZXhDb2xvcik7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSwgc2NhbGU6IFwibVwiLCB2YWx1ZTogdGhpcy5oZXhDb2xvciwgc3RvcmFnZUlkOiBcImFyY2dpcy1zeW1ib2wtc3R5bGVyLXN0b3JhZ2UtY29sb3JzXCIgfSksIGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IGFwcGVhcmFuY2U6IFwic29saWRcIiwgc2NhbGU6IFwibVwiLCBzbG90OiBcImZvb3RlclwiLCB3aWR0aDogXCJmdWxsXCIsIGxhYmVsOiB0aGlzLmludGxEb25lLCBvbkNsaWNrOiB0aGlzLmhhbmRsZURvbmUgfSwgdGhpcy5pbnRsRG9uZSkpKSkpO1xuICB9XG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICBcImRpc2FibGVkXCI6IFtcImRpc2FibGVkQ2hhbmdlZFwiXVxuICB9OyB9XG59O1xuXG5jb25zdCBhcmNnaXNQb3B1cFN0eWxlclBvcG92ZXJDc3MgPSBcIi5zdHlsZXItcGFuZWx7d2lkdGg6MzI4cHg7bWluLWhlaWdodDozMDBweH0uc3R5bGVyLWRpdnt3aWR0aDoxMDAlfVwiO1xuXG5jb25zdCBBcmNnaXNQb3B1cFN0eWxlclBvcG92ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuYXJjZ2lzUG9wdXBTdHlsZXJQb3BvdmVyQ2xvc2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1BvcHVwU3R5bGVyUG9wb3ZlckNsb3NlXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzUG9wdXBTdHlsZXJQb3BvdmVyRGlzY29ubmVjdGVkID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNQb3B1cFN0eWxlclBvcG92ZXJEaXNjb25uZWN0ZWRcIiwgNyk7XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgdGhpcy5kb2N1bWVudFRhYkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kb2N1bWVudENsaWNrSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhbmVsU2Nyb2xsSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFByaXZhdGUgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLm9uT3BlbiA9ICgpID0+IHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnNldEZvY3VzKCkpO1xuICAgIH07XG4gICAgdGhpcy5yZWZlcmVuY2VFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIHB1YmxpYyBjYWxsc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIHJlcG9zaXRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMucG9wb3Zlck5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBvc2l0aW9uKCk7XG4gIH1cbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuY2xvc2VBY3Rpb25Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKTtcbiAgfVxuICBhc3luYyBzZXRPcGVuKG9wZW4pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMucG9wb3Zlck5vZGUpIHtcbiAgICAgIHRoaXMucG9wb3Zlck5vZGUub3BlbiA9IG9wZW47XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICAoX2EgPSB0aGlzLnBhbmVsTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEZvY3VzKCk7XG4gICAgICAgIHRoaXMucG9wb3Zlck5vZGUucmVwb3NpdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBhZGRTdHlsZXIoc3R5bGVyTm9kZSkge1xuICAgIGlmICh0aGlzLmNvbnRlbnROb2RlKSB7XG4gICAgICB0aGlzLmNvbnRlbnROb2RlLmFwcGVuZENoaWxkKHN0eWxlck5vZGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRQb3BvdmVyUmVmRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZUFjdGlvbk5vZGU7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgdGhpcy5zdHJpbmdzID0gcG9wdXBTdGF0ZS5zdHJpbmdzO1xuICB9XG4gIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5jbG9zZUFjdGlvbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRGb2N1cygpOyB9KTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAvLyBpbiBjYXNlIHBvcG92ZXIgZ290IHJlbW92ZWQgYnkganVzdCByZW1vdmluZyBub2RlIGZyb20gRE9NXG4gICAgdGhpcy5hcmNnaXNQb3B1cFN0eWxlclBvcG92ZXJEaXNjb25uZWN0ZWQuZW1pdCgpO1xuICB9XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHJlZmVyZW5jZUVsZW1lbnQsIG9wZW4sIHN0cmluZ3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwianMtYXBwLWZseW91dFwiIH0sIGgoXCJjYWxjaXRlLXBvcG92ZXJcIiwgeyBvcGVuOiBvcGVuLCBwbGFjZW1lbnQ6IFwibGVhZGluZy1zdGFydFwiLCBvZmZzZXREaXN0YW5jZTogMCwgb2Zmc2V0U2tpZGRpbmc6IDQ1LCBwb2ludGVyRGlzYWJsZWQ6IHRydWUsIHRyaWdnZXJEaXNhYmxlZDogdHJ1ZSwgbGFiZWw6IFwiXCIsIHJlZmVyZW5jZUVsZW1lbnQ6IHJlZmVyZW5jZUVsZW1lbnQsIG9uQ2FsY2l0ZVBvcG92ZXJPcGVuOiB0aGlzLm9uT3BlbiwgcmVmOiAobm9kZSkgPT4gKHRoaXMucG9wb3Zlck5vZGUgPSBub2RlKSB9LCBoKFwiY2FsY2l0ZS1wYW5lbFwiLCB7XG4gICAgICAvLyBuZWVkIGFjY2VzcyB0byB0aGUgY2xvc2UgYnV0dG9uIGRvbSB0byBwYXNzIHRvIHN5bWJvbCBzdHlsZXIgYXMgcmVmZXJlbmNlIGVsZW1lbnQsXG4gICAgICAvLyBzbyBjYW4ndCB1c2UgY2xvc2FibGU6dHJ1ZVxuICAgICAgY2xvc2FibGU6IGZhbHNlLCBoZWFkaW5nOiBzdHJpbmdzLmNoYXJ0U3R5bGUsIGNsYXNzOiBcInN0eWxlci1wYW5lbFwiLCByZWY6IChub2RlKSA9PiAodGhpcy5wYW5lbE5vZGUgPSBub2RlKSwgb25DYWxjaXRlUGFuZWxDbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLmFyY2dpc1BvcHVwU3R5bGVyUG9wb3ZlckNsb3NlLmVtaXQoKTtcbiAgICAgICAgLy8gZm9jdXMgb24gaW5mbyBpY29uOyB3YWl0IHNvIGVudGVyIGtleSBkb2Vzbid0IHJlLW9wZW4gaXRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWZlcmVuY2VFbGVtZW50LnBhcmVudEVsZW1lbnQuZm9jdXMoKSwgMzAwKTtcbiAgICAgIH1cbiAgICB9LCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBpZDogXCJzeW1ib2wtc3R5bGVyLWRpc21pc3MtYnV0dG9uXCIsIHNsb3Q6IFwiaGVhZGVyLWFjdGlvbnMtZW5kXCIsIHNjYWxlOiBcInNcIiwgaWNvbjogXCJ4XCIsIHRleHQ6IHN0cmluZ3MuY2xvc2UsIG9uQ2xpY2s6ICgpID0+IHRoaXMuYXJjZ2lzUG9wdXBTdHlsZXJQb3BvdmVyQ2xvc2UuZW1pdCgpLCByZWY6IChub2RlKSA9PiAodGhpcy5jbG9zZUFjdGlvbk5vZGUgPSBub2RlKSB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiBcInN0eWxlci1kaXZcIiwgcmVmOiAobm9kZSkgPT4gKHRoaXMuY29udGVudE5vZGUgPSBub2RlKSB9KSkpKSk7XG4gIH1cbiAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc1BvcHVwU3R5bGVyUG9wb3Zlci5zdHlsZSA9IGFyY2dpc1BvcHVwU3R5bGVyUG9wb3ZlckNzcztcblxuY29uc3QgYXJjZ2lzU3ltYm9sUGlja2VyRmlsZVVwbG9hZENzcyA9IFwiOmhvc3R7ZGlzcGxheTppbmxpbmUtYmxvY2s7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTt3aWR0aDoxMDAlO3BhZGRpbmc6MjBweCA1cHggMTVweCA1cHg7Ym9yZGVyLWNvbG9yOnZhcigtLWNhbGNpdGUtdWktYm9yZGVyLTEpO2JvcmRlci13aWR0aDoycHg7Ym9yZGVyLXN0eWxlOmRhc2hlZDtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmZpbGUtc3RlcHt0ZXh0LWFsaWduOmNlbnRlcn0uZmlsZS1zdGVwX191cGxvYWQtaWNvbnttYXJnaW4tYm90dG9tOjAuNXJlbTttYXJnaW4tdG9wOjAuMjVyZW07Y29sb3I6dmFyKC0tY2FsY2l0ZS11aS10ZXh0LTMpfS5maWxlLXN0ZXBfX3VwbG9hZC1pY29uIGNhbGNpdGUtaWNvbnt3aWR0aDo0cmVtO2hlaWdodDo0cmVtfS5maWxlLXN0ZXBfX2RyYWctdGV4dHtmb250LXNpemU6MC45cmVtO21hcmdpbi1ib3R0b206MC4yNXJlbX0uZmlsZS1zdGVwX19icm93c2UtYnV0dG9ue21hcmdpbi10b3A6MXJlbX0uZmlsZS1zdGVwX19maWxlLWlucHV0e2Rpc3BsYXk6bm9uZX1cIjtcblxuY29uc3QgQXJjZ2lzU3ltYm9sU3R5bGVyRmlsZVVwbG9hZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5hcmNnaXNTeW1ib2xQaWNrZXJGaWxlVXBsb2FkQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTeW1ib2xQaWNrZXJGaWxlVXBsb2FkQ2hhbmdlXCIsIDcpO1xuICAgIHRoaXMuYXJjZ2lzU3ltYm9sUGlja2VyRmlsZVVwbG9hZEludmFsaWRGaWxlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTeW1ib2xQaWNrZXJGaWxlVXBsb2FkSW52YWxpZEZpbGVcIiwgNyk7XG4gICAgdGhpcy5hcmNnaXNTeW1ib2xQaWNrZXJGaWxlVXBsb2FkRXJyb3IgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1N5bWJvbFBpY2tlckZpbGVVcGxvYWRFcnJvclwiLCA3KTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdGhpcy5oYW5kbGVEcmFnT3ZlciA9IChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRHJvcCA9IChldmVudCkgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMucHJvY2Vzc0ZpbGUoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzWzBdKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRmlsZUlucHV0Q2hhbmdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NGaWxlKGV2ZW50LnRhcmdldC5maWxlc1swXSk7XG4gICAgfTtcbiAgICB0aGlzLnBvcnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0cmluZ3MgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyAgTGlmZWN5Y2xlXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFJlbmRlciBNZXRob2RzXG4gIC8vXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBcImZpbGUtc3RlcFwiLCBcImFyaWEtbGFiZWxcIjogdGhpcy5zdHJpbmdzLmZpbGVVcGxvYWQuZHJhZ0Ryb3AsIG9uRHJhZ092ZXI6IHRoaXMuaGFuZGxlRHJhZ092ZXIsIG9uRHJhZ0VudGVyOiB0aGlzLmhhbmRsZURyYWdPdmVyLCBvbkRyb3A6IHRoaXMuaGFuZGxlRHJvcCB9LCBoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJmaWxlLXN0ZXBfX2RyYWctdGV4dFwiLCBcImFyaWEtbGFiZWxcIjogdGhpcy5zdHJpbmdzLmZpbGVVcGxvYWQuZHJhZ0Ryb3AgfSwgdGhpcy5zdHJpbmdzLmZpbGVVcGxvYWQuZHJhZ0Ryb3ApLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBjbGFzczogXCJmaWxlLXN0ZXBfX2Jyb3dzZS1idXR0b25cIiwgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCBpY29uU3RhcnQ6IFwiaW1hZ2VcIiwgb25DbGljazogKCkgPT4ge1xuICAgICAgICB0aGlzLmZpbGVJbnB1dC5jbGljaygpO1xuICAgICAgfSB9LCB0aGlzLnN0cmluZ3MuZmlsZVVwbG9hZC5icm93c2UpLCBoKFwiaW5wdXRcIiwgeyByZWY6IChlbCkgPT4ge1xuICAgICAgICB0aGlzLmZpbGVJbnB1dCA9IGVsO1xuICAgICAgfSwgb25DaGFuZ2U6IHRoaXMuaGFuZGxlRmlsZUlucHV0Q2hhbmdlLCBjbGFzczogXCJmaWxlLXN0ZXBfX2ZpbGUtaW5wdXRcIiwgdHlwZTogXCJmaWxlXCIsIGFjY2VwdDogXCIuanBnLC5naWYsLnBuZywuc3ZnLGltYWdlL2pwZyxpbWFnZS9naWYsaW1hZ2UvcG5nLGltYWdlL3N2Zyt4bWxcIiB9KSkpKTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRmlsZShmaWxlKSB7XG4gICAgY29uc3QgeyBwb3J0YWwgfSA9IHRoaXM7XG4gICAgaWYgKCFmaWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmaWxlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZEZpbGUoZmlsZSkpIHtcbiAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xQaWNrZXJGaWxlVXBsb2FkSW52YWxpZEZpbGUuZW1pdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1NWR0ZpbGUoZmlsZSkpIHtcbiAgICAgICAgY29uc3QgW3N5bWJvbFNlcnZpY2VdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9yZXN0L3N5bWJvbFNlcnZpY2VcIl0pO1xuICAgICAgICBjb25zdCBzeW1ib2xTZXJ2aWNlVXJsID0gcG9ydGFsLmhlbHBlclNlcnZpY2VzLnN5bWJvbHMudXJsO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0geyBzdmdJbWFnZTogZXZlbnQudGFyZ2V0LnJlc3VsdCB9O1xuICAgICAgICAgIHN5bWJvbFNlcnZpY2UuZ2VuZXJhdGVTeW1ib2woc3ltYm9sU2VydmljZVVybCwgcGFyYW1zKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sUGlja2VyRmlsZVVwbG9hZENoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgICAgY2ltOiByZXN1bHQuc3ltYm9sLFxuICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHdpZHRoOiByZXN1bHQuc3ltYm9sLndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3VsdC5zeW1ib2wuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgIGltYWdlLnNyYyA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNTeW1ib2xQaWNrZXJGaWxlVXBsb2FkQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgICBkYXRhVVJMOiBldmVudC50YXJnZXQucmVzdWx0LFxuICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lIHx8IFwiXCIsXG4gICAgICAgICAgICAgIHdpZHRoOiBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZS5oZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2Uub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU3ltYm9sUGlja2VyRmlsZVVwbG9hZEVycm9yLmVtaXQoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNWYWxpZEZpbGUoZmlsZSkge1xuICAgIHJldHVybiAoZmlsZSA9PT0gbnVsbCB8fCBmaWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlLm5hbWUpICYmIC9cXC4oZ2lmfGpwZ3xqcGVnfHBuZ3xzdmcpJC9pLnRlc3QoZmlsZS5uYW1lKTtcbiAgfVxuICBpc1NWR0ZpbGUoZmlsZSkge1xuICAgIHJldHVybiAoZmlsZSA9PT0gbnVsbCB8fCBmaWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlLm5hbWUpICYmIC9cXC4oc3ZnKSQvaS50ZXN0KGZpbGUubmFtZSk7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc1N5bWJvbFN0eWxlckZpbGVVcGxvYWQuc3R5bGUgPSBhcmNnaXNTeW1ib2xQaWNrZXJGaWxlVXBsb2FkQ3NzO1xuXG5jb25zdCBDU1MkMiA9IHtcbiAgcmVjZW50OiBcInJlY2VudFwiLFxuICBwcmV2aWV3OiBcInByZXZpZXdcIixcbiAgY29sb3JQaWNrZXJDb250YWluZXI6IFwiY29sb3ItcGlja2VyLWNvbnRhaW5lclwiXG59O1xuXG5sZXQgcmFtcElkID0gMDtcbmNvbnN0IENTUyQxID0ge1xuICBjb2xvclJhbXBJdGVtOiBcImNvbG9yLXJhbXAtaXRlbVwiXG59O1xuY29uc3QgQ29sb3JSYW1wSXRlbSA9ICh7IHN0b3BzLCBzdHlsZSA9IFwiY29udGludW91c1wiLCBuYW1lLCBsYXlvdXQgPSBcInZlcnRpY2FsXCIsIHdpZHRoID0gMjAsIGhlaWdodCA9IDcwIH0pID0+IHtcbiAgY29uc3QgaWQgPSBgJHtyYW1wSWQrK30tY29sb3ItcmFtcC1ncmFkaWVudGA7XG4gIGNvbnN0IGdyYWRpZW50VHJhbnNmb3JtID0gbGF5b3V0ID09PSBcInZlcnRpY2FsXCIgPyBcInJvdGF0ZSg5MClcIiA6IFwiXCI7XG4gIHJldHVybiAoaChcInNwYW5cIiwgeyB0aXRsZTogbmFtZSwgY2xhc3M6IENTUyQxLmNvbG9yUmFtcEl0ZW0gfSxcbiAgICBoKFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aCB9LFxuICAgICAgaChcImRlZnNcIiwgbnVsbCxcbiAgICAgICAgaChcImxpbmVhckdyYWRpZW50XCIsIHsgaWQ6IGlkLCBncmFkaWVudFRyYW5zZm9ybTogZ3JhZGllbnRUcmFuc2Zvcm0gfSwgc3R5bGUgPT09IFwiY29udGludW91c1wiID8gZ2V0R3JhZGllbnRTdG9wcyhzdG9wcykgOiBnZXRTb2xpZFN0b3BzKHN0b3BzKSkpLFxuICAgICAgaChcInJlY3RcIiwgeyB4OiBcIjBcIiwgeTogXCIwXCIsIGZpbGw6IGB1cmwoJyMke2lkfScpYCwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiIH0pKSkpO1xufTtcbmZ1bmN0aW9uIGdldEdyYWRpZW50U3RvcHMoc3RvcHMpIHtcbiAgY29uc3QgY29sb3JPZmZzZXQgPSAxIC8gKHN0b3BzLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gc3RvcHMuc2xpY2UoKS5tYXAoKHsgciwgZywgYiB9LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG9mZnNldCA9IGluZGV4ICogY29sb3JPZmZzZXQgKiAxMDA7XG4gICAgcmV0dXJuIGgoXCJzdG9wXCIsIHsgXCJzdG9wLWNvbG9yXCI6IGByZ2IoJHtyfSwgJHtnfSwgJHtifSlgLCBvZmZzZXQ6IGAke29mZnNldH0lYCB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTb2xpZFN0b3BzKHN0b3BzKSB7XG4gIGNvbnN0IGNvbG9yT2Zmc2V0ID0gMSAvIHN0b3BzLmxlbmd0aDtcbiAgY29uc3QgY29sb3JzID0gW107XG4gIHN0b3BzLnNsaWNlKCkuZm9yRWFjaCgoeyByLCBnLCBiIH0sIGluZGV4KSA9PiB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggKiBjb2xvck9mZnNldCAqIDEwMDtcbiAgICBjb25zdCBuZXh0T2Zmc2V0ID0gKGluZGV4ICsgMSkgKiBjb2xvck9mZnNldCAqIDEwMDtcbiAgICBjb2xvcnMucHVzaChoKFwic3RvcFwiLCB7IFwic3RvcC1jb2xvclwiOiBgcmdiKCR7cn0sICR7Z30sICR7Yn0pYCwgb2Zmc2V0OiBgJHtvZmZzZXR9JWAgfSksIGgoXCJzdG9wXCIsIHsgXCJzdG9wLWNvbG9yXCI6IGByZ2IoJHtyfSwgJHtnfSwgJHtifSlgLCBvZmZzZXQ6IGAke25leHRPZmZzZXR9JWAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIGNvbG9ycztcbn1cblxuY29uc3QgQ1NTID0ge1xuICBjb2xvclJhbXBJdGVtOiBcImNvbG9yLXJhbXAtaXRlbVwiXG59O1xuY29uc3QgUmVsYXRpb25zaGlwUmFtcENvbG9yUmFtcEl0ZW0gPSAoeyBzdG9wcywgbmFtZSwgb3BhY2l0eSA9IG51bGwsIHNpemUgPSA0OCB9KSA9PiB7XG4gIGNvbnN0IHsgc3ZnVXRpbHMgfSA9IGVzcmlNb2R1bGVzO1xuICAvLyByZW5kZXJpbmcgbG9naWMsIHR5cGVzIGFuZCB1dGlscyBhcmUgYmFzZWQgb24gSlMgQVBJIHJhbXAgcmVuZGVyaW5nIGZyb20gTGVnZW5kXG4gIC8vIHRoZXNlIHdpbGwgYmUgcmVmYWN0b3JlZCBhZnRlciBzb21lIHV0aWxzIGFyZSBtYWRlIHB1YmxpYzogaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWpzLWFwaS9wdWxsLzMyODExL1xuICBjb25zdCBudW1DbGFzc2VzID0gTWF0aC5zcXJ0KHN0b3BzLmxlbmd0aCk7XG4gIGNvbnN0IGNvbG9ycyA9IGV4cGFuZDJEKHN0b3BzKTtcbiAgY29uc3Qgcm90YXRpb24gPSAwO1xuICBjb25zdCBzdXJmYWNlU2l6ZSA9IE1hdGguc3FydChNYXRoLnBvdyhzaXplLCAyKSArIE1hdGgucG93KHNpemUsIDIpKSArICgwICk7IC8vIGRpYWdvbmFsIGxlbmd0aCArIDVweCBwYWRkaW5nIGZvciBhcnJvd3NcbiAgbGV0IG9wYWNpdHlTdHlsZSA9IG51bGw7XG4gIGlmIChvcGFjaXR5ICE9IG51bGwpIHtcbiAgICBvcGFjaXR5U3R5bGUgPSB7IG9wYWNpdHk6IGAke29wYWNpdHl9YCB9O1xuICB9XG4gIGNvbnN0IGRlZnMgPSBbXTtcbiAgY29uc3Qgc3F1YXJlcyA9IFtdO1xuICBjb25zdCBiYm94ZXMgPSBbXTtcbiAgY29uc3QgZ3JvdXBTaXplID0gc2l6ZSB8fCA3NTtcbiAgY29uc3QgY2VsbFNpemUgPSBncm91cFNpemUgLyBudW1DbGFzc2VzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsYXNzZXM7IGkrKykge1xuICAgIGNvbnN0IHkgPSBpICogY2VsbFNpemU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1DbGFzc2VzOyBqKyspIHtcbiAgICAgIGNvbnN0IHggPSBqICogY2VsbFNpemU7XG4gICAgICBjb25zdCBmaWxsQXR0cnMgPSBnZW5lcmF0ZUZpbGxBdHRyaWJ1dGVzKGNvbG9yc1tpXVtqXSk7XG4gICAgICBjb25zdCBzdHJva2VBdHRycyA9IGdlbmVyYXRlU3Ryb2tlQXR0cmlidXRlcyhudWxsKTtcbiAgICAgIGNvbnN0IHNoYXBlID0ge1xuICAgICAgICB0eXBlOiBcInJlY3RcIixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IGNlbGxTaXplLFxuICAgICAgICBoZWlnaHQ6IGNlbGxTaXplXG4gICAgICB9O1xuICAgICAgZGVmcy5wdXNoKHJlbmRlckRlZihmaWxsQXR0cnMpKTtcbiAgICAgIHNxdWFyZXMucHVzaChyZW5kZXJTaGFwZShzaGFwZSwgZmlsbEF0dHJzLmZpbGwsIHN0cm9rZUF0dHJzLCBudWxsKSk7XG4gICAgICBiYm94ZXMucHVzaChzdmdVdGlscy5nZXRCb3VuZGluZ0JveChzaGFwZSkpO1xuICAgIH1cbiAgfVxuICBsZXQgc3ZnU3R5bGUgPSBudWxsO1xuICBjb25zdCBiYm94ID0gc3ZnVXRpbHMuY29tcHV0ZUJCb3goYmJveGVzKTtcbiAgY29uc3QgcmVjdE1hdHJpeCA9IHN2Z1V0aWxzLmdldFRyYW5zZm9ybU1hdHJpeChiYm94LCBzdXJmYWNlU2l6ZSwgc3VyZmFjZVNpemUsIDAsIGZhbHNlLCByb3RhdGlvbik7XG4gIHJldHVybiAoaChcInNwYW5cIiwgeyB0aXRsZTogbmFtZSwgY2xhc3M6IENTUy5jb2xvclJhbXBJdGVtIH0sXG4gICAgaChcImRpdlwiLCB7IHN0eWxlOiBvcGFjaXR5U3R5bGUgfSxcbiAgICAgIGgoXCJzdmdcIiwgeyB3aWR0aDogc3VyZmFjZVNpemUsIGhlaWdodDogc3VyZmFjZVNpemUsIHN0eWxlOiBzdmdTdHlsZSwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICBoKFwiZGVmc1wiLCBudWxsLCBkZWZzKSxcbiAgICAgICAgaChcImdcIiwgeyB0cmFuc2Zvcm06IHJlY3RNYXRyaXggfSwgc3F1YXJlcykpKSkpO1xufTtcbmZ1bmN0aW9uIHJlbmRlckRlZihhdHRycykge1xuICBjb25zdCB7IHBhdHRlcm4sIGxpbmVhckdyYWRpZW50IH0gPSBhdHRycztcbiAgaWYgKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gKGgoXCJwYXR0ZXJuXCIsIHsgaWQ6IHBhdHRlcm4uaWQsIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLCB4OiBwYXR0ZXJuLngsIHk6IHBhdHRlcm4ueSwgd2lkdGg6IHBhdHRlcm4ud2lkdGgsIGhlaWdodDogcGF0dGVybi5oZWlnaHQgfSxcbiAgICAgIGgoXCJpbWFnZVwiLCB7IHg6IHBhdHRlcm4uaW1hZ2UueCwgeTogcGF0dGVybi5pbWFnZS55LCB3aWR0aDogcGF0dGVybi5pbWFnZS53aWR0aCwgaGVpZ2h0OiBwYXR0ZXJuLmltYWdlLmhlaWdodCwgaHJlZjogcGF0dGVybi5pbWFnZS5ocmVmIH0pKSk7XG4gIH1cbiAgaWYgKGxpbmVhckdyYWRpZW50KSB7XG4gICAgY29uc3Qgc3RvcHMgPSBsaW5lYXJHcmFkaWVudC5zdG9wcy5tYXAoKHN0b3AsIGluZGV4KSA9PiAoaChcInN0b3BcIiwgeyBrZXk6IGAke2luZGV4fS1zdG9wYCwgb2Zmc2V0OiBzdG9wLm9mZnNldCwgXCJzdG9wLWNvbG9yXCI6IHN0b3AuY29sb3IgfSkpKTtcbiAgICByZXR1cm4gKGgoXCJsaW5lYXJHcmFkaWVudFwiLCB7IGlkOiBsaW5lYXJHcmFkaWVudC5pZCwgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLCB4MTogbGluZWFyR3JhZGllbnQueDEsIHkxOiBsaW5lYXJHcmFkaWVudC55MSwgeDI6IGxpbmVhckdyYWRpZW50LngyLCB5MjogbGluZWFyR3JhZGllbnQueTIgfSwgc3RvcHMpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN2Z1BhdGhGcm9tQ29tbWFuZE9iamVjdHMoY29tbWFuZE9iamVjdHMpIHtcbiAgcmV0dXJuIGNvbW1hbmRPYmplY3RzXG4gICAgLm1hcCgoY29tbWFuZE9iaikgPT4gYCR7Y29tbWFuZE9iai5jb21tYW5kfSAke2NvbW1hbmRPYmoudmFsdWVzLmpvaW4oXCIgXCIpfWApXG4gICAgLmpvaW4oXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cbmxldCBwYXR0ZXJuQ291bnQgPSAwO1xubGV0IGxpbmVhckdyYWRpZW50Q291bnQgPSAwO1xuZnVuY3Rpb24gcmVuZGVyU2hhcGUoc2hhcGUsIGZpbGwsIHN0cm9rZSwgdGV4dEF0dHJzKSB7XG4gIGlmIChzaGFwZSkge1xuICAgIGlmIChzaGFwZS50eXBlID09PSBcImNpcmNsZVwiKSB7XG4gICAgICByZXR1cm4gKGgoXCJjaXJjbGVcIiwgeyBmaWxsOiBmaWxsLCBcImZpbGwtcnVsZVwiOiBcImV2ZW5vZGRcIiwgc3Ryb2tlOiBzdHJva2UuY29sb3IsIFwic3Ryb2tlLXdpZHRoXCI6IHN0cm9rZS53aWR0aCwgXCJzdHJva2UtbGluZWNhcFwiOiBzdHJva2UuY2FwLCBcInN0cm9rZS1saW5lam9pblwiOiBzdHJva2Uuam9pbiwgXCJzdHJva2UtZGFzaGFycmF5XCI6IHN0cm9rZS5kYXNoQXJyYXksIFwic3Ryb2tlLW1pdGVybGltaXRcIjogXCI0XCIsIGN4OiBzaGFwZS5jeCwgY3k6IHNoYXBlLmN5LCByOiBzaGFwZS5yIH0pKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlLnR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgICByZXR1cm4gKGgoXCJlbGxpcHNlXCIsIHsgZmlsbDogZmlsbCwgXCJmaWxsLXJ1bGVcIjogXCJldmVub2RkXCIsIHN0cm9rZTogc3Ryb2tlLmNvbG9yLCBcInN0cm9rZS13aWR0aFwiOiBzdHJva2Uud2lkdGgsIFwic3Ryb2tlLWxpbmVjYXBcIjogc3Ryb2tlLmNhcCwgXCJzdHJva2UtbGluZWpvaW5cIjogc3Ryb2tlLmpvaW4sIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBzdHJva2UuZGFzaEFycmF5LCBcInN0cm9rZS1taXRlcmxpbWl0XCI6IFwiNFwiLCBjeDogc2hhcGUuY3gsIGN5OiBzaGFwZS5jeSwgcng6IHNoYXBlLnJ4LCByeTogc2hhcGUucnkgfSkpO1xuICAgIH1cbiAgICBpZiAoc2hhcGUudHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICAgIHJldHVybiAoaChcInJlY3RcIiwgeyBmaWxsOiBmaWxsLCBcImZpbGwtcnVsZVwiOiBcImV2ZW5vZGRcIiwgc3Ryb2tlOiBzdHJva2UuY29sb3IsIFwic3Ryb2tlLXdpZHRoXCI6IHN0cm9rZS53aWR0aCwgXCJzdHJva2UtbGluZWNhcFwiOiBzdHJva2UuY2FwLCBcInN0cm9rZS1saW5lam9pblwiOiBzdHJva2Uuam9pbiwgXCJzdHJva2UtZGFzaGFycmF5XCI6IHN0cm9rZS5kYXNoQXJyYXksIFwic3Ryb2tlLW1pdGVybGltaXRcIjogXCI0XCIsIHg6IHNoYXBlLngsIHk6IHNoYXBlLnksIHdpZHRoOiBzaGFwZS53aWR0aCwgaGVpZ2h0OiBzaGFwZS5oZWlnaHQgfSkpO1xuICAgIH1cbiAgICBpZiAoc2hhcGUudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICByZXR1cm4gKGgoXCJpbWFnZVwiLCB7IGhyZWY6IHNoYXBlLnNyYywgeDogc2hhcGUueCwgeTogc2hhcGUueSwgd2lkdGg6IHNoYXBlLndpZHRoLCBoZWlnaHQ6IHNoYXBlLmhlaWdodCwgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCIgfSkpO1xuICAgIH1cbiAgICBpZiAoc2hhcGUudHlwZSA9PT0gXCJwYXRoXCIpIHtcbiAgICAgIGNvbnN0IHBhdGggPSB0eXBlb2Ygc2hhcGUucGF0aCAhPT0gXCJzdHJpbmdcIiA/IGdldFN2Z1BhdGhGcm9tQ29tbWFuZE9iamVjdHMoc2hhcGUucGF0aCkgOiBzaGFwZS5wYXRoO1xuICAgICAgcmV0dXJuIChoKFwicGF0aFwiLCB7IGZpbGw6IGZpbGwsIFwiZmlsbC1ydWxlXCI6IFwiZXZlbm9kZFwiLCBzdHJva2U6IHN0cm9rZS5jb2xvciwgXCJzdHJva2Utd2lkdGhcIjogc3Ryb2tlLndpZHRoLCBcInN0cm9rZS1saW5lY2FwXCI6IHN0cm9rZS5jYXAsIFwic3Ryb2tlLWxpbmVqb2luXCI6IHN0cm9rZS5qb2luLCBcInN0cm9rZS1kYXNoYXJyYXlcIjogc3Ryb2tlLmRhc2hBcnJheSwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiBcIjRcIiwgZDogcGF0aCB9KSk7XG4gICAgfVxuICAgIGlmIChzaGFwZS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgcmV0dXJuIChoKFwidGV4dFwiLCB7IGZpbGw6IGZpbGwsIFwiZmlsbC1ydWxlXCI6IFwiZXZlbm9kZFwiLCBzdHJva2U6IHN0cm9rZS5jb2xvciwgXCJzdHJva2Utd2lkdGhcIjogc3Ryb2tlLndpZHRoLCBcInN0cm9rZS1saW5lY2FwXCI6IHN0cm9rZS5jYXAsIFwic3Ryb2tlLWxpbmVqb2luXCI6IHN0cm9rZS5qb2luLCBcInN0cm9rZS1kYXNoYXJyYXlcIjogc3Ryb2tlLmRhc2hBcnJheSwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiBcIjRcIiwgXCJ0ZXh0LWFuY2hvclwiOiB0ZXh0QXR0cnMuYWxpZ24sIFwidGV4dC1kZWNvcmF0aW9uXCI6IHRleHRBdHRycy5kZWNvcmF0aW9uLCBrZXJuaW5nOiB0ZXh0QXR0cnMua2VybmluZywgcm90YXRlOiB0ZXh0QXR0cnMucm90YXRlLCBcInRleHQtcmVuZGVyaW5nXCI6IFwiYXV0b1wiLCBcImZvbnQtc3R5bGVcIjogdGV4dEF0dHJzLmZvbnQuc3R5bGUsIFwiZm9udC12YXJpYW50XCI6IHRleHRBdHRycy5mb250LnZhcmlhbnQsIFwiZm9udC13ZWlnaHRcIjogdGV4dEF0dHJzLmZvbnQud2VpZ2h0LCBcImZvbnQtc2l6ZVwiOiB0ZXh0QXR0cnMuZm9udC5zaXplLCBcImZvbnQtZmFtaWx5XCI6IHRleHRBdHRycy5mb250LmZhbWlseSwgeDogc2hhcGUueCwgeTogc2hhcGUueSB9LCBzaGFwZS50ZXh0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVGaWxsQXR0cmlidXRlcyhmaWxsKSB7XG4gIGNvbnN0IGF0dHJzID0ge1xuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHBhdHRlcm46IG51bGwsXG4gICAgbGluZWFyR3JhZGllbnQ6IG51bGxcbiAgfTtcbiAgaWYgKGZpbGwpIHtcbiAgICBpZiAoXCJ0eXBlXCIgaW4gZmlsbCAmJiBmaWxsLnR5cGUgPT09IFwicGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBpZCA9IGBwYXR0ZXJuSWQtJHsrK3BhdHRlcm5Db3VudH1gO1xuICAgICAgYXR0cnMuZmlsbCA9IGB1cmwoIyR7aWR9KWA7XG4gICAgICBhdHRycy5wYXR0ZXJuID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgeDogZmlsbC54LFxuICAgICAgICB5OiBmaWxsLnksXG4gICAgICAgIHdpZHRoOiBmaWxsLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGZpbGwuaGVpZ2h0LFxuICAgICAgICBpbWFnZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogZmlsbC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGZpbGwuaGVpZ2h0LFxuICAgICAgICAgIGhyZWY6IGZpbGwuc3JjXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKFwidHlwZVwiIGluIGZpbGwgJiYgZmlsbC50eXBlID09PSBcImxpbmVhclwiKSB7XG4gICAgICBjb25zdCBpZCA9IGBsaW5lYXJHcmFkaWVudElkLSR7KytsaW5lYXJHcmFkaWVudENvdW50fWA7XG4gICAgICBhdHRycy5maWxsID0gYHVybCgjJHtpZH0pYDtcbiAgICAgIGF0dHJzLmxpbmVhckdyYWRpZW50ID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgeDE6IGZpbGwueDEsXG4gICAgICAgIHkxOiBmaWxsLnkxLFxuICAgICAgICB4MjogZmlsbC54MixcbiAgICAgICAgeTI6IGZpbGwueTIsXG4gICAgICAgIHN0b3BzOiBmaWxsLmNvbG9ycy5tYXAoKHN0b3ApID0+ICh7XG4gICAgICAgICAgb2Zmc2V0OiBzdG9wLm9mZnNldCxcbiAgICAgICAgICBjb2xvcjogc3RvcC5jb2xvciAmJiBjcmVhdGUoc3RvcC5jb2xvcikudG9TdHJpbmcoKVxuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbGwpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gY3JlYXRlKGZpbGwpO1xuICAgICAgYXR0cnMuZmlsbCA9IGNvbG9yLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhdHRycztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU3Ryb2tlQXR0cmlidXRlcyhzdHJva2UpIHtcbiAgY29uc3Qgc3Ryb2tlQXR0cnMgPSB7XG4gICAgY29sb3I6IFwibm9uZVwiLFxuICAgIHdpZHRoOiAxLFxuICAgIGNhcDogXCJidXR0XCIsXG4gICAgam9pbjogXCI0XCIsXG4gICAgZGFzaEFycmF5OiBcIm5vbmVcIlxuICB9O1xuICBpZiAoc3Ryb2tlKSB7XG4gICAgaWYgKHN0cm9rZS53aWR0aCAhPSBudWxsKSB7XG4gICAgICBzdHJva2VBdHRycy53aWR0aCA9IHN0cm9rZS53aWR0aDtcbiAgICB9XG4gICAgaWYgKHN0cm9rZS5jYXApIHtcbiAgICAgIHN0cm9rZUF0dHJzLmNhcCA9IHN0cm9rZS5jYXA7XG4gICAgfVxuICAgIGlmIChzdHJva2Uuam9pbikge1xuICAgICAgc3Ryb2tlQXR0cnMuam9pbiA9IHN0cm9rZS5qb2luLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChzdHJva2UuY29sb3IpIHtcbiAgICAgIHN0cm9rZUF0dHJzLmNvbG9yID0gY3JlYXRlKHN0cm9rZS5jb2xvcikudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZS5zdHlsZSkge1xuICAgICAgbGV0IGRhID0gbnVsbDtcbiAgICAgIGlmIChzdHJva2Uuc3R5bGUgaW4gc3R5bGVUb0Rhc2hBcnJheSkge1xuICAgICAgICBkYSA9IHN0eWxlVG9EYXNoQXJyYXlbc3Ryb2tlLnN0eWxlXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhKSkge1xuICAgICAgICBkYSA9IGRhLnNsaWNlKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZGFbaV0gKj0gc3Ryb2tlLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJva2UuY2FwICE9PSBcImJ1dHRcIikge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGRhW2ldIC09IHN0cm9rZS53aWR0aDtcbiAgICAgICAgICAgIGlmIChkYVtpXSA8IDEpIHtcbiAgICAgICAgICAgICAgZGFbaV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBkYVtpXSArPSBzdHJva2Uud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhID0gZGEuam9pbihcIixcIik7XG4gICAgICB9XG4gICAgICBzdHJva2VBdHRycy5kYXNoQXJyYXkgPSBkYTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cm9rZUF0dHJzO1xufVxuY29uc3Qgc3R5bGVUb0Rhc2hBcnJheSA9IHtcbiAgc29saWQ6IFwibm9uZVwiLFxuICBzaG9ydGRhc2g6IFs0LCAxXSxcbiAgc2hvcnRkb3Q6IFsxLCAxXSxcbiAgc2hvcnRkYXNoZG90OiBbNCwgMSwgMSwgMV0sXG4gIHNob3J0ZGFzaGRvdGRvdDogWzQsIDEsIDEsIDEsIDEsIDFdLFxuICBkb3Q6IFsxLCAzXSxcbiAgZGFzaDogWzQsIDNdLFxuICBsb25nZGFzaDogWzgsIDNdLFxuICBkYXNoZG90OiBbNCwgMywgMSwgM10sXG4gIGxvbmdkYXNoZG90OiBbOCwgMywgMSwgM10sXG4gIGxvbmdkYXNoZG90ZG90OiBbOCwgMywgMSwgMywgMSwgM11cbn07XG5cbmNvbnN0IGFyY2dpc1N5bWJvbFN0eWxlckNvbG9yUmFtcElucHV0Q3NzID0gXCIuc2Nyb2xsZXJ7bWF4LWhlaWdodDp2YXIoLS1zY3JvbGxlci1tYXgtaGVpZ2h0LCAyMDBweCk7b3ZlcmZsb3cteTphdXRvO21pbi13aWR0aDoyMDBweDtvdmVyZmxvdy14OmhpZGRlbjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uY29sb3ItcmFtcC1pdGVte2Rpc3BsYXk6aW5saW5lLWZsZXg7ZmxleC1ncm93OjF9LmNvbG9yLXJhbXAtaXRlbSBzdmd7ZGlzcGxheTpmbGV4fS5jb2xvci1waWNrZXItY29udGFpbmVye2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmNvbG9yLXBpY2tlci1jb250YWluZXIgYXJjZ2lzLWl0ZW0tcGFsZXR0ZSAucGFsZXR0ZXtnYXA6MjBweH1jYWxjaXRlLWNvbG9yLXBpY2tlci1zd2F0Y2h7d2lkdGg6MjAwcHh9LnNlY3Rpb257ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtwYWRkaW5nOjEycHg7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hcmNnaXMtYXBwLWJhY2tncm91bmQpfS5jb2xvci1yYW1wLXNlbGVjdGlvbntwYWRkaW5nOjRweCAyMHB4IDRweCA0cHg7Ym9yZGVyOjFweCBzb2xpZCBsaWdodGdyYXk7Ym9yZGVyLXRvcDpub25lfS5hcmNnaXMtLXJ0bCAuY29sb3ItcmFtcC1zZWxlY3Rpb257cGFkZGluZzo0cHggNHB4IDRweCAyMHB4O30uY29sb3ItcmFtcC1mbGlwcGVyIGNhbGNpdGUtaWNvbnttYXJnaW46MCAwLjVyZW19W3Nsb3Q9cHJldmlld10gLmNvbG9yLXJhbXAtaXRlbXtoZWlnaHQ6MjRweH1cIjtcblxuY29uc3QgQXJjZ2lzU3ltYm9sU3R5bGVyQ29sb3JSYW1wSW5wdXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIHRoaXMuc2V0SW5saW5lSW5wdXRSZWYgPSAoZWwpID0+IHtcbiAgICAgIHRoaXMuaW5saW5lSW5wdXRFbCA9IGVsO1xuICAgIH07XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBsYWNlbWVudCA9IFwiYXV0b1wiO1xuICAgIHRoaXMucG9wb3ZlclByb3BzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RyaW5ncyA9IHVuZGVmaW5lZDtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBQdWJsaWMgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIHNldEZvY3VzKCkge1xuICAgIHZhciBfYTtcbiAgICBhd2FpdCAoKF9hID0gdGhpcy5pbmxpbmVJbnB1dEVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Rm9jdXMoKSk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGF3YWl0ICgoX2EgPSB0aGlzLmlubGluZUlucHV0RWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpKTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRpc2FibGVkLCBzdHJpbmdzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRpciA9IGdldEVsZW1lbnREaXIodGhpcy5lbCk7XG4gICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1pbmxpbmUtaW5wdXRcIiwgeyBkaXNhYmxlZDogZGlzYWJsZWQsIGludGxEb25lOiBzdHJpbmdzLmRvbmUsIGhlYWRpbmc6IHN0cmluZ3MucmFtcCwgbGFiZWw6IHRoaXMub3B0aW9ucy5oZWFkaW5nLCBwb3BvdmVyUHJvcHM6IHRoaXMucG9wb3ZlclByb3BzLCByZWY6IHRoaXMuc2V0SW5saW5lSW5wdXRSZWYsIGNsYXNzOiB7XG4gICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBkaXIgPT09IFwicnRsXCJcbiAgICAgIH0gfSwgaChcImRpdlwiLCB7IGNsYXNzOiBDU1MkMi5jb2xvclBpY2tlckNvbnRhaW5lciwgc2xvdDogXCJjb250ZW50XCIgfSwgdGhpcy5yZW5kZXJSYW1wc0NvbnRlbnQodGhpcy5vcHRpb25zKSksIGgoXCJkaXZcIiwgeyBzbG90OiBcInByZXZpZXdcIiB9LCBoKENvbG9yUmFtcEl0ZW0sIHsgc3RvcHM6IHRoaXMub3B0aW9ucy5jb2xvclJhbXBTdG9wcy5zbGljZSgpLnJldmVyc2UoKSwgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSwgbGF5b3V0OiBcImhvcml6b250YWxcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgd2lkdGg6IFwiMTAwJVwiIH0pKSkpKTtcbiAgfVxuICByZW5kZXJSYW1wc0NvbnRlbnQoeyBhY3RpdmVDYXRlZ29yeSwgY29sb3JSYW1wcywgaXNTZWxlY3RlZCwgb25DYXRlZ29yeUNoYW5nZSwgb25GbGlwLCBvblNlbGVjdCwgc3R5bGUgfSkge1xuICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGNhdGVnb3JpZXMsIHJhbXBzIH0gPSB0aGlzLmdldENhdGVnb3JpZXNBbmRDb2xvclJhbXBzQnlTZWxlY3RlZENhdGVnb3J5KGFjdGl2ZUNhdGVnb3J5LCBjb2xvclJhbXBzKTtcbiAgICBjb25zdCBpczJEID0gc3R5bGUgPT09IFwiMmRcIjtcbiAgICBjb25zdCByYW1wRmxpcEljb24gPSBpczJEID8gXCJyb3RhdGVcIiA6IFwiYXJyb3ctdXAtZG93blwiO1xuICAgIGNvbnN0IHJhbXBGbGlwTGFiZWwgPSBpczJEID8gc3RyaW5ncy5yb3RhdGVDb2xvcnMgOiBzdHJpbmdzLmZsaXBDb2xvcnM7XG4gICAgY29uc3QgcmFtcEl0ZW1SZW5kZXJlciA9IGlzMkQgPyBSZWxhdGlvbnNoaXBSYW1wQ29sb3JSYW1wSXRlbSA6IENvbG9yUmFtcEl0ZW07XG4gICAgY29uc3QgcmFtcHNQZXJSb3cgPSBpczJEID8gMyA6IDY7XG4gICAgcmV0dXJuIFtcbiAgICAgIGgoXCJkaXZcIiwgeyBjbGFzczogXCJzZWN0aW9uXCIgfSwgaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgdGhpcy5zdHJpbmdzLmNhdGVnb3J5LCBoKFwiY2FsY2l0ZS1zZWxlY3RcIiwgeyB3aWR0aDogXCJmdWxsXCIsIGxhYmVsOiB0aGlzLnN0cmluZ3MuY2F0ZWdvcnksIG9uQ2FsY2l0ZVNlbGVjdENoYW5nZTogb25DYXRlZ29yeUNoYW5nZSB9LCBjYXRlZ29yaWVzLm1hcCgoY2F0ZWdvcnkpID0+IChoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyB2YWx1ZTogY2F0ZWdvcnksIGxhYmVsOiBzdHJpbmdzLmNhdGVnb3JpZXNbY2F0ZWdvcnldLCBzZWxlY3RlZDogY2F0ZWdvcnkgPT09IGFjdGl2ZUNhdGVnb3J5IH0pKSkpKSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgY2xhc3M6IENTUyQ0LmNvbG9yUmFtcEZsaXBwZXIsIGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBvbkZsaXAoKTtcbiAgICAgICAgfSwgc2NhbGU6IFwic1wiLCB3aWR0aDogXCJmdWxsXCIgfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IGljb246IHJhbXBGbGlwSWNvbiwgc2NhbGU6IFwic1wiLCBzdHlsZTogaXMyRCA/IHsgdHJhbnNmb3JtOiBcInJvdGF0ZVkoMTgwZGVnKVwiIH0gOiBudWxsIH0pLCByYW1wRmxpcExhYmVsKSksXG4gICAgICBoKFwiZGl2XCIsIHsgY2xhc3M6IHsgW0NTUyQ0LnNjcm9sbGVyXTogdHJ1ZSwgW0NTUyQ0LmNvbG9yUmFtcFNlbGVjdGlvbl06IHRydWUgfSB9LCBoKFwiYXJjZ2lzLWl0ZW0tcGFsZXR0ZVwiLCB7IGl0ZW1zOiByYW1wcywgZXh0cmFJdGVtUHJvcHM6IHsgc3R5bGUgfSwgSXRlbVJlbmRlcmVyOiByYW1wSXRlbVJlbmRlcmVyLCBpdGVtc1BlclJvdzogcmFtcHNQZXJSb3csIHNlbGVjdGVkOiBpc1NlbGVjdGVkLCBvbkFyY2dpc0l0ZW1TZWxlY3Q6IG9uU2VsZWN0IH0pKVxuICAgIF07XG4gIH1cbiAgZ2V0Q2F0ZWdvcmllc0FuZENvbG9yUmFtcHNCeVNlbGVjdGVkQ2F0ZWdvcnkoYWN0aXZlQ2F0ZWdvcnksIGFsbFJhbXBzKSB7XG4gICAgY29uc3QgYWN0aXZlVGFncyA9IGNhdGVnb3JpZXNUb1RhZ3NbYWN0aXZlQ2F0ZWdvcnldO1xuICAgIGNvbnN0IGFjdGl2ZVJhbXBzID0gYWxsUmFtcHMuZmlsdGVyKChjb2xvclJhbXApID0+IGFjdGl2ZUNhdGVnb3J5ID09PSBcImFsbFwiIHx8IGFjdGl2ZVRhZ3Muc29tZSgodGFnKSA9PiBjb2xvclJhbXAudGFncy5pbmRleE9mKHRhZykgPiAtMSkpO1xuICAgIGNvbnN0IHVzZWRUYWdzU2V0ID0gbmV3IFNldCgpO1xuICAgIGFsbFJhbXBzLmZvckVhY2goKHJhbXApID0+IHJhbXAudGFncy5mb3JFYWNoKCh0YWcpID0+IHVzZWRUYWdzU2V0LmFkZCh0YWcpKSk7XG4gICAgY29uc3QgY2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKGNhdGVnb3JpZXNUb1RhZ3MpLmZpbHRlcigoY2F0ZWdvcnkpID0+IGNhdGVnb3J5ID09PSBcImFsbFwiIHx8IGNhdGVnb3JpZXNUb1RhZ3NbY2F0ZWdvcnldLnNvbWUoKHRhZykgPT4gdXNlZFRhZ3NTZXQuaGFzKHRhZykpKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2F0ZWdvcmllcyxcbiAgICAgIHJhbXBzOiBhY3RpdmVSYW1wc1xuICAgIH07XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc1N5bWJvbFN0eWxlckNvbG9yUmFtcElucHV0LnN0eWxlID0gYXJjZ2lzU3ltYm9sU3R5bGVyQ29sb3JSYW1wSW5wdXRDc3M7XG5cbmNvbnN0IGFyY2dpc1N5bWJvbFN0eWxlclNlY3Rpb25Dc3MgPSBcIjpob3N0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hcmNnaXMtYXBwLWJhY2tncm91bmQpO3BhZGRpbmc6MTZweCAxMnB4fTpob3N0KFtkaXNhYmxlZF0pe29wYWNpdHk6dmFyKC0tYXJjZ2lzLWFwcC1kaXNhYmxlZC1vcGFjaXR5KTtwb2ludGVyLWV2ZW50czpub25lfTpob3N0KFtlbWJlZGRlZF0pe3BhZGRpbmc6MH1cIjtcblxuY29uc3QgQXJjZ2lzU3ltYm9sU3R5bGVyU2VjdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1iZWRkZWQgPSBmYWxzZTtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgIC8qIGludGVudGlvbmFsbHkgdXNpbmcgYXR0cmlidXRlIHRvIGF2b2lkIGZvY3VzaW5nIGNvbnRhaW5lciB3aGVuICFkaXNhYmxlZCAqL1xuICAgIGgoSG9zdCwgeyB0YWJpbmRleDogdGhpcy5kaXNhYmxlZCA/IC0xIDogXCJcIiB9LCBoKFwic2xvdFwiLCBudWxsKSkpO1xuICB9XG59O1xuQXJjZ2lzU3ltYm9sU3R5bGVyU2VjdGlvbi5zdHlsZSA9IGFyY2dpc1N5bWJvbFN0eWxlclNlY3Rpb25Dc3M7XG5cbmNvbnN0IGFyY2dpc1N5bWJvbFN0eWxlclN5bWJvbFByZXZpZXdDc3MgPSBcIjpob3N0e2Rpc3BsYXk6aW5saW5lLWJsb2NrfTpob3N0KC5kYXJrKXtiYWNrZ3JvdW5kLWNvbG9yOiNmM2YzZjN9XCI7XG5cbmNvbnN0IEFyY2dpc1N5bWJvbFN0eWxlclN5bWJvbFByZXZpZXcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLnVwZGF0ZVByZXZpZXcgPSBkZWJvdW5jZShhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7IHN5bWJvbCB9ID0gdGhpcztcbiAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgLy8gd2UgZHJvcCBzaXplIHRvIHByZXZlbnQgYSBrbm93biByZW5kZXJpbmcgaXNzdWUg4oCTIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvaXNzdWVzLzQxNzkwXG4gICAgICBpZiAoc3ltYm9sLnR5cGUgPT09IFwiY2ltXCIgJiYgc3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNUG9seWdvblN5bWJvbFwiKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnNpemU7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmludFN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xuICAgICAgaWYgKHByaW50U3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiAmJiBvcHRpb25zLnNpemUgJiYgdHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvLyByZW5kZXJQcmV2aWV3SFRNTCBkb2Vzbid0IHdvcmsgd2VsbCB3aXRoIG5vbi1zcXVhcmUgUE1TXG4gICAgICAgIC8vIGNoYW5nZSBzeW1ib2wgdG8gdGhlIHNpemUgd2UgbmVlZCBpbnN0ZWFkXG4gICAgICAgIHByaW50U3ltYm9sLndpZHRoID0gKHByaW50U3ltYm9sLndpZHRoIC8gcHJpbnRTeW1ib2wuaGVpZ2h0KSAqIG9wdGlvbnMuc2l6ZTtcbiAgICAgICAgcHJpbnRTeW1ib2wuaGVpZ2h0ID0gb3B0aW9ucy5zaXplO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudFByZXZpZXdSZW5kZXIgPSBlc3JpTW9kdWxlcy5zeW1ib2xVdGlscy5yZW5kZXJQcmV2aWV3SFRNTChwcmludFN5bWJvbCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmxhc3RQcmV2aWV3UmVuZGVyID0gY3VycmVudFByZXZpZXdSZW5kZXI7XG4gICAgICBjb25zdCBwcmV2aWV3ID0gYXdhaXQgY3VycmVudFByZXZpZXdSZW5kZXI7XG4gICAgICBjb25zdCBwcmV2aWV3SXNPdXRkYXRlZCA9IHRoaXMubGFzdFByZXZpZXdSZW5kZXIgIT09IGN1cnJlbnRQcmV2aWV3UmVuZGVyO1xuICAgICAgaWYgKHByZXZpZXdJc091dGRhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChfYSA9IHRoaXMubGFzdFByZXZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgIHRoaXMubGFzdFByZXZpZXcgPSBwcmV2aWV3O1xuICAgICAgdGhpcy5lbC5zaGFkb3dSb290LmFwcGVuZChwcmV2aWV3KTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZFRoZW1lID0gZXNyaU1vZHVsZXMucHJldmlld1N5bWJvbDJELmdldENvbnRyYXN0aW5nQmFja2dyb3VuZFRoZW1lKHN5bWJvbCwgMjQ1KTtcbiAgICB9LCAyNTApO1xuICAgIHRoaXMuYmFja2dyb3VuZFRoZW1lID0gXCJsaWdodFwiO1xuICAgIHRoaXMuY29udHJhc3QgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zeW1ib2wgPSB1bmRlZmluZWQ7XG4gIH1cbiAgd2F0Y2hTeW1ib2xBbmRPcHRpb25zKCkge1xuICAgIHRoaXMudXBkYXRlUHJldmlldygpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGFzeW5jIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVQcmV2aWV3KCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBoKEhvc3QsIHsgY2xhc3M6IHsgZGFyazogdGhpcy5jb250cmFzdCAmJiB0aGlzLmJhY2tncm91bmRUaGVtZSA9PT0gXCJkYXJrXCIgfSB9KTtcbiAgfVxuICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgXCJzeW1ib2xcIjogW1wid2F0Y2hTeW1ib2xBbmRPcHRpb25zXCJdLFxuICAgIFwib3B0aW9uc1wiOiBbXCJ3YXRjaFN5bWJvbEFuZE9wdGlvbnNcIl1cbiAgfTsgfVxufTtcbkFyY2dpc1N5bWJvbFN0eWxlclN5bWJvbFByZXZpZXcuc3R5bGUgPSBhcmNnaXNTeW1ib2xTdHlsZXJTeW1ib2xQcmV2aWV3Q3NzO1xuXG5leHBvcnQgeyBBcmNnaXNDb2xvcklucHV0IGFzIGFyY2dpc19jb2xvcl9pbnB1dCwgQXJjZ2lzUG9wdXBDb2xvclBvcG92ZXIgYXMgYXJjZ2lzX3BvcHVwX2NvbG9yX3BvcG92ZXIsIEFyY2dpc1BvcHVwU3R5bGVyUG9wb3ZlciBhcyBhcmNnaXNfcG9wdXBfc3R5bGVyX3BvcG92ZXIsIEFyY2dpc1N5bWJvbFN0eWxlckZpbGVVcGxvYWQgYXMgYXJjZ2lzX3N5bWJvbF9waWNrZXJfZmlsZV91cGxvYWQsIEFyY2dpc1N5bWJvbFN0eWxlckNvbG9yUmFtcElucHV0IGFzIGFyY2dpc19zeW1ib2xfc3R5bGVyX2NvbG9yX3JhbXBfaW5wdXQsIEFyY2dpc1N5bWJvbFN0eWxlclNlY3Rpb24gYXMgYXJjZ2lzX3N5bWJvbF9zdHlsZXJfc2VjdGlvbiwgQXJjZ2lzU3ltYm9sU3R5bGVyU3ltYm9sUHJldmlldyBhcyBhcmNnaXNfc3ltYm9sX3N0eWxlcl9zeW1ib2xfcHJldmlldyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5jb25zdCBDU1MgPSB7XG4gIGN1c3RvbVN5bWJvbENvbnRlbnQ6IFwiY3VzdG9tLXN5bWJvbC1jb250ZW50XCIsXG4gIGF1dG9BZGp1c3RMYWJlbDogXCJhdXRvLWFkanVzdC1sYWJlbFwiLFxuICBzdHlsZURyb3Bkb3duOiBcInN0eWxlLWRyb3Bkb3duXCIsXG4gIGFycm93RHJvcGRvd246IFwiYXJyb3ctZHJvcGRvd25cIixcbiAgaWNvbkRyb3Bkb3duOiBcImljb24tZHJvcGRvd25cIixcbiAgaWNvbkRyb3Bkb3duU2VsZWN0ZWQ6IFwiaWNvbi1kcm9wZG93bi0tc2VsZWN0ZWRcIixcbiAgaWNvbkRyb3Bkb3duSXRlbUNvbnRlbnQ6IFwiaWNvbi1kcm9wZG93bi1pdGVtLWNvbnRlbnRcIixcbiAgY29sb3JSYW1wRmxpcHBlcjogXCJjb2xvci1yYW1wLWZsaXBwZXJcIixcbiAgc2Nyb2xsZXI6IFwic2Nyb2xsZXJcIixcbiAgY29sb3JSYW1wU2VsZWN0aW9uOiBcImNvbG9yLXJhbXAtc2VsZWN0aW9uXCIsXG4gIHNlY3Rpb25Ub2dnbGVEaXNhYmxlZDogXCJzZWN0aW9uLXRvZ2dsZS0tZGlzYWJsZWRcIixcbiAgYXV0b0FkanVzdENoZWNrYm94OiBcImF1dG8tYWRqdXN0LWNoZWNrYm94XCIsXG4gIGNvbnRlbnRHcm91cDogXCJjb250ZW50LWdyb3VwXCIsXG4gIGNvbG9yTG9ja2VkSW5mbzogXCJjb2xvci1sb2NrZWQtaW5mb1wiLFxuICBtZXNzYWdlOiBcIm1lc3NhZ2VcIixcbiAgLy8gc3ltYm9sIGJ1dHRvblxuICBjb250YWluZXI6IFwiY29udGFpbmVyXCIsXG4gIGxhYmVsOiBcImxhYmVsXCIsXG4gIG9wZW5JY29uOiBcIm9wZW4taWNvblwiLFxuICBzeW1ib2w6IFwic3ltYm9sXCIsXG4gIGNoYW5nZVN5bWJvbFRyaWdnZXI6IFwiY2hhbmdlLXN5bWJvbC10cmlnZ2VyXCJcbn07XG5jb25zdCBjYXRlZ29yaWVzVG9UYWdzID0ge1xuICBhbGw6IFtcIipcIl0sXG4gIGxpZ2h0OiBbXCJsaWdodFwiXSxcbiAgZGFyazogW1wiZGFya1wiXSxcbiAgcmVkc0FuZFllbGxvd3M6IFtcIm9yYW5nZXNcIiwgXCJyZWRzXCIsIFwieWVsbG93c1wiXSxcbiAgZ3JlZW5zOiBbXCJncmVlbnNcIl0sXG4gIGJsdWVzOiBbXCJibHVlc1wiXSxcbiAgcHVycGxlc0FuZFBpbmtzOiBbXCJwdXJwbGVzXCIsIFwicGlua3NcIl0sXG4gIGJyb3duczogW1wiYnJvd25zXCJdLFxuICBncmF5czogW1wiZ3JheXNcIl0sXG4gIGJyaWdodDogW1wiYnJpZ2h0XCJdLFxuICBzdWJkdWVkOiBbXCJzdWJkdWVkXCJdLFxuICBjb2xvcmJsaW5kRnJpZW5kbHk6IFtcImNvbG9yYmxpbmQtZnJpZW5kbHlcIl1cbn07XG5jb25zdCBzdXBwb3J0ZWRBcnJvd3MgPSBbXCJub25lXCIsIFwiYmVnaW5cIiwgXCJlbmRcIiwgXCJiZWdpbi1lbmRcIl07XG5jb25zdCBzdXBwb3J0ZWRTdHlsZXMgPSBbXG4gIFwic29saWRcIixcbiAgXCJkYXNoXCIsXG4gIFwiZG90XCIsXG4gIFwiZGFzaC1kb3RcIixcbiAgXCJsb25nLWRhc2gtZG90LWRvdFwiLFxuICBcInNob3J0LWRhc2hcIixcbiAgXCJzaG9ydC1kb3RcIixcbiAgXCJzaG9ydC1kYXNoLWRvdFwiLFxuICBcInNob3J0LWRhc2gtZG90LWRvdFwiLFxuICBcImxvbmctZGFzaFwiLFxuICBcImxvbmctZGFzaC1kb3RcIlxuXTtcbmNvbnN0IGRlZmF1bHRWaXNpYmxlTWFya2VyU2VjdGlvblBhcnRzID0ge1xuICBzaXplOiB0cnVlLFxuICBwcmV2aWV3OiB0cnVlLFxuICByb3RhdGlvbjogdHJ1ZVxufTtcbmNvbnN0IGRlZmF1bHRWaXNpYmxlRXh0cmFTdHJva2VTZWN0aW9uUGFydHMgPSB7XG4gIHN0eWxlOiB0cnVlLFxuICBhcnJvdzogdHJ1ZSxcbiAgd2lkdGg6IHRydWUsXG4gIGF1dG9TdHJva2VBZGp1c3Q6IGZhbHNlXG59O1xuY29uc3QgZGVmYXVsdFZpc2libGVDb2xvclNlY3Rpb25QYXJ0cyA9IHtcbiAgc3VnZ2VzdGVkQ29sb3JzOiB0cnVlLFxuICBjdXN0b21Db2xvcjogdHJ1ZSxcbiAgdHJhbnNwYXJlbmN5OiB0cnVlXG59O1xuY29uc3QgZGVmYXVsdFZpc2libGVDb2xvclJhbXBTZWN0aW9uUGFydHMgPSB7XG4gIGNvbG9yUmFtcHM6IHRydWUsXG4gIHRyYW5zcGFyZW5jeTogdHJ1ZVxufTtcbmNvbnN0IGRlZmF1bHRWaXNpYmxlU3Ryb2tlU2VjdGlvblBhcnRzID0ge1xuICBleHRyYTogdHJ1ZVxufTtcbmNvbnN0IGNvbG9yU3RvcmFnZUlkID0gXCJhcmNnaXMtc3ltYm9sLXN0eWxlci1zdG9yYWdlLWNvbG9yc1wiO1xuY29uc3QgcG9pbnRQcmV2aWV3T3B0aW9ucyA9IHtcbiAgc2l6ZTogMjQsXG4gIG1heFNpemU6IDI0XG59O1xuY29uc3Qgb3BhY2l0eU1heCA9IDEwMDtcbmNvbnN0IG9wYWNpdHlNaW4gPSAwO1xuY29uc3QgbWF4V2lkdGhJblB4ID0gMTg7XG5jb25zdCBtaW5XaWR0aEluUHggPSAwO1xuY29uc3Qgcm90YXRpb25NYXggPSAzNjA7XG5jb25zdCByb3RhdGlvbk1pbiA9IDA7XG5jb25zdCBzaXplTWF4ID0gMTUwO1xuY29uc3Qgc2l6ZU1pbiA9IDE7XG5jb25zdCBtYXJrZXJQbGFjZW1lbnRTdGVwTWF4ID0gMjAwO1xuY29uc3QgbWFya2VyUGxhY2VtZW50U3RlcE1pbiA9IDA7XG5jb25zdCBtYXJrZXJQbGFjZW1lbnRSYW5kb21uZXNzTWF4ID0gMTAwO1xuY29uc3QgbWFya2VyUGxhY2VtZW50UmFuZG9tbmVzc01pbiA9IDA7XG5jb25zdCBtYXhEaXNwbGF5ZWRTeW1ib2xMYXllcnMgPSAxMDtcbmNvbnN0IGhhdGNoRmlsbFNlcGFyYXRpb25NYXggPSAyMDA7XG5jb25zdCBoYXRjaEZpbGxTZXBhcmF0aW9uTWluID0gMDtcbmNvbnN0IGhhdGNoRmlsbE9mZnNldE1heCA9IDEwMDtcbmNvbnN0IGhhdGNoRmlsbE9mZnNldE1pbiA9IDA7XG5jb25zdCBhbmltYXRpb25EdXJhdGlvbk1heCA9IDEyMDtcbmNvbnN0IGFuaW1hdGlvbkR1cmF0aW9uTWluID0gMDtcblxuZnVuY3Rpb24gZmxpcENvbG9yUmFtcFN0b3BzKHN0b3BzLCBpczJkID0gZmFsc2UpIHtcbiAgcmV0dXJuIGlzMmQgPyBmbGlwRmxhdHRlbmVkMkRSYW1wKHN0b3BzKSA6IHN0b3BzLnNsaWNlKCkucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gZmxpcEZsYXR0ZW5lZDJEUmFtcChmbGF0MmRTdG9wcykge1xuICBjb25zdCBudW1DbGFzc2VzID0gTWF0aC5zcXJ0KGZsYXQyZFN0b3BzLmxlbmd0aCk7XG4gIGNvbnN0IHJhbXAyZCA9IGV4cGFuZDJEKGZsYXQyZFN0b3BzKTtcbiAgY29uc3Qgb2xkUmFtcCA9IHJhbXAyZC5yZXZlcnNlKCk7XG4gIGNvbnN0IGZsaXBwZWRSYW1wID0gW107XG4gIC8vIEZsaXAgMkQgbWF0cml4IG9mIGNvbG9ycyBieSA5MCBkZWdyZWVzIGluIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2xhc3NlczsgaSsrKSB7XG4gICAgY29uc3QgbmV3Um93ID0gW107XG4gICAgb2xkUmFtcC5mb3JFYWNoKChvbGRSb3cpID0+IG5ld1Jvdy5wdXNoKG9sZFJvd1tpXSkpO1xuICAgIGZsaXBwZWRSYW1wLnB1c2gobmV3Um93KTtcbiAgfVxuICByZXR1cm4gZmxhdHRlbjJEKGZsaXBwZWRSYW1wKS5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBleHBhbmQyRChzdG9wcywgZm9jdXMpIHtcbiAgbGV0IGV4cGFuZGVkQXJyYXkgPSBbXTtcbiAgY29uc3QgbnVtQ2xhc3NlcyA9IE1hdGguc3FydChzdG9wcy5sZW5ndGgpO1xuICAvLyBGb2N1cyBkZWNpZGVzIHdoZXRoZXIgd2UgcmV2ZXJzZSB0aGUgb3V0ZXIvaW5uZXIgYXJyYXlzIG9yIG5vdC5cbiAgY29uc3QgY29kZXMgPSAoZm9jdXMgfHwgXCJISFwiKS5zcGxpdChcIlwiKTtcbiAgY29uc3Qgc3RhcnRSb3dDb2RlID0gY29kZXNbMF07XG4gIGNvbnN0IHN0YXJ0Q29sQ29kZSA9IGNvZGVzWzFdO1xuICBjb25zdCByZXZlcnNlRWFjaFJvdyA9IHN0YXJ0Q29sQ29kZSAhPT0gXCJIXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2xhc3NlczsgaSsrKSB7XG4gICAgbGV0IHJvdyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQ2xhc3NlczsgaisrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiBudW1DbGFzc2VzICsgajtcbiAgICAgIHJvdy5wdXNoKHN0b3BzW2luZGV4XSk7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlRWFjaFJvdykge1xuICAgICAgcm93LnJldmVyc2UoKTtcbiAgICB9XG4gICAgZXhwYW5kZWRBcnJheS5wdXNoKHJvdyk7XG4gIH1cbiAgaWYgKHN0YXJ0Um93Q29kZSA9PT0gXCJMXCIpIHtcbiAgICBleHBhbmRlZEFycmF5LnJldmVyc2UoKTtcbiAgfVxuICByZXR1cm4gZXhwYW5kZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4yRChhcnJheTJkLCBmb2N1cykge1xuICAvLyBSZXR1cm5zIGEgZmxhdHRlbmVkIGFycmF5IGZyb20gdGhlIGdpdmVuIDJkIGFycmF5LlxuICAvLyBhcnJheTJkIGlzIGFzc3VtZWQgdG8gaGF2ZSB0aGUgbGF5b3V0IHN0cnVjdHVyZSBvdXRsaW5lZCBhdDpcbiAgLy8gcmVuZGVyZXJzL3V0aWxzOmdldENsYXNzVmFsdWVzRm9yUmVsYXRpb25zaGlwLlxuICAvLyBPcmRlciBvZiBlbGVtZW50cyBpbiB0aGUgb3V0cHV0IGFycmF5IGlzIGRldGVybWluZWQgYnkgXCJmb2N1c1wiLlxuICAvLyBcImZvY3VzXCIgY2FuIGJlOiBISCwgSEwsIExIIG9yIExMLiBEZWZhdWx0IGlzIFwiSEhcIi5cbiAgbGV0IGZsYXRBcnJheSA9IFtdO1xuICAvLyBjbG9uZSB0byBhdm9pZCBtb2RpZnlpbmcgc291cmNlIGRhdGFcbiAgYXJyYXkyZCA9IGFycmF5MmQuc2xpY2UoKS5tYXAoKGNvbG9ycykgPT4gY29sb3JzLnNsaWNlKCkpO1xuICAvLyBGb2N1cyBkZWNpZGVzIHdoZXRoZXIgd2UgcmV2ZXJzZSB0aGUgb3V0ZXIvaW5uZXIgYXJyYXlzIG9yIG5vdC5cbiAgY29uc3QgY29kZXMgPSAoZm9jdXMgfHwgXCJISFwiKS5zcGxpdChcIlwiKSwgc3RhcnRSb3dDb2RlID0gY29kZXNbMF0sIHN0YXJ0Q29sQ29kZSA9IGNvZGVzWzFdO1xuICBpZiAoc3RhcnRSb3dDb2RlID09PSBcIkxcIikge1xuICAgIGFycmF5MmQucmV2ZXJzZSgpO1xuICB9XG4gIGNvbnN0IHJldmVyc2VFYWNoUm93ID0gc3RhcnRDb2xDb2RlID09PSBcIkhcIjtcbiAgYXJyYXkyZC5mb3JFYWNoKChyb3cpID0+IHtcbiAgICBpZiAocmV2ZXJzZUVhY2hSb3cpIHtcbiAgICAgIHJvdy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZmxhdEFycmF5ID0gZmxhdEFycmF5LmNvbmNhdChyb3cpO1xuICB9KTtcbiAgcmV0dXJuIGZsYXRBcnJheTtcbn1cblxuZXhwb3J0IHsgbWFya2VyUGxhY2VtZW50U3RlcE1pbiBhcyBBLCBtYXJrZXJQbGFjZW1lbnRSYW5kb21uZXNzTWF4IGFzIEIsIENTUyBhcyBDLCBtYXJrZXJQbGFjZW1lbnRSYW5kb21uZXNzTWluIGFzIEQsIGV4cGFuZDJEIGFzIEUsIGNhdGVnb3JpZXNUb1RhZ3MgYXMgRiwgbWF4V2lkdGhJblB4IGFzIGEsIHN1cHBvcnRlZFN0eWxlcyBhcyBiLCBkZWZhdWx0VmlzaWJsZUNvbG9yU2VjdGlvblBhcnRzIGFzIGMsIGRlZmF1bHRWaXNpYmxlTWFya2VyU2VjdGlvblBhcnRzIGFzIGQsIGRlZmF1bHRWaXNpYmxlQ29sb3JSYW1wU2VjdGlvblBhcnRzIGFzIGUsIGZsaXBDb2xvclJhbXBTdG9wcyBhcyBmLCBkZWZhdWx0VmlzaWJsZUV4dHJhU3Ryb2tlU2VjdGlvblBhcnRzIGFzIGcsIGRlZmF1bHRWaXNpYmxlU3Ryb2tlU2VjdGlvblBhcnRzIGFzIGgsIG1heERpc3BsYXllZFN5bWJvbExheWVycyBhcyBpLCBjb2xvclN0b3JhZ2VJZCBhcyBqLCBvcGFjaXR5TWF4IGFzIGssIHJvdGF0aW9uTWF4IGFzIGwsIG1pbldpZHRoSW5QeCBhcyBtLCBzaXplTWluIGFzIG4sIG9wYWNpdHlNaW4gYXMgbywgcG9pbnRQcmV2aWV3T3B0aW9ucyBhcyBwLCBzaXplTWF4IGFzIHEsIHJvdGF0aW9uTWluIGFzIHIsIHN1cHBvcnRlZEFycm93cyBhcyBzLCBoYXRjaEZpbGxPZmZzZXRNYXggYXMgdCwgaGF0Y2hGaWxsT2Zmc2V0TWluIGFzIHUsIGhhdGNoRmlsbFNlcGFyYXRpb25NYXggYXMgdiwgaGF0Y2hGaWxsU2VwYXJhdGlvbk1pbiBhcyB3LCBhbmltYXRpb25EdXJhdGlvbk1heCBhcyB4LCBhbmltYXRpb25EdXJhdGlvbk1pbiBhcyB5LCBtYXJrZXJQbGFjZW1lbnRTdGVwTWF4IGFzIHogfTtcbiIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuaW1wb3J0IHsgZyBhcyBnZXRSZW5kZXJpbmdSZWYsIGYgYXMgZm9yY2VVcGRhdGUgfSBmcm9tICcuL2luZGV4LTkyZWJiMzk2LmpzJztcblxuY29uc3QgYXBwZW5kVG9NYXAgPSAobWFwLCBwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBpdGVtcyA9IG1hcC5nZXQocHJvcE5hbWUpO1xuICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgbWFwLnNldChwcm9wTmFtZSwgW3ZhbHVlXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpdGVtcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufTtcbmNvbnN0IGRlYm91bmNlID0gKGZuLCBtcykgPT4ge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dElkID0gMDtcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xuICAgICAgICB9LCBtcyk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb3NzaWJsZSBlbGVtZW50IGlzQ29ubmVjdGVkLlxuICogVGhlIHByb3BlcnR5IG1pZ2h0IG5vdCBiZSB0aGVyZSwgc28gd2UgY2hlY2sgZm9yIGl0LlxuICpcbiAqIFdlIHdhbnQgaXQgdG8gcmV0dXJuIHRydWUgaWYgaXNDb25uZWN0ZWQgaXMgbm90IGEgcHJvcGVydHksXG4gKiBvdGhlcndpc2Ugd2Ugd291bGQgcmVtb3ZlIHRoZXNlIGVsZW1lbnRzIGFuZCB3b3VsZCBub3QgdXBkYXRlLlxuICpcbiAqIEJldHRlciBsZWFrIGluIEVkZ2UgdGhhbiB0byBiZSB1c2VsZXNzLlxuICovXG5jb25zdCBpc0Nvbm5lY3RlZCA9IChtYXliZUVsZW1lbnQpID0+ICEoJ2lzQ29ubmVjdGVkJyBpbiBtYXliZUVsZW1lbnQpIHx8IG1heWJlRWxlbWVudC5pc0Nvbm5lY3RlZDtcbmNvbnN0IGNsZWFudXBFbGVtZW50cyA9IGRlYm91bmNlKChtYXApID0+IHtcbiAgICBmb3IgKGxldCBrZXkgb2YgbWFwLmtleXMoKSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgbWFwLmdldChrZXkpLmZpbHRlcihpc0Nvbm5lY3RlZCkpO1xuICAgIH1cbn0sIDIwMDApO1xuY29uc3Qgc3RlbmNpbFN1YnNjcmlwdGlvbiA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdldFJlbmRlcmluZ1JlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGluIGEgc3RlbmNpbCBwcm9qZWN0LCB3ZSBkbyBub3RoaW5nLlxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWFsbHkgZXhwb3J0ZWQgYnkgQHN0ZW5jaWwvY29yZS5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBlbG1zVG9VcGRhdGUgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcG9zZTogKCkgPT4gZWxtc1RvVXBkYXRlLmNsZWFyKCksXG4gICAgICAgIGdldDogKHByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbG0gPSBnZXRSZW5kZXJpbmdSZWYoKTtcbiAgICAgICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRUb01hcChlbG1zVG9VcGRhdGUsIHByb3BOYW1lLCBlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBlbG1zVG9VcGRhdGUuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGVsbXNUb1VwZGF0ZS5zZXQocHJvcE5hbWUsIGVsZW1lbnRzLmZpbHRlcihmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBlbG1zVG9VcGRhdGUuZm9yRWFjaCgoZWxtcykgPT4gZWxtcy5mb3JFYWNoKGZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICBjbGVhbnVwRWxlbWVudHMoZWxtc1RvVXBkYXRlKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgdW53cmFwID0gKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgPyB2YWwoKSA6IHZhbCk7XG5jb25zdCBjcmVhdGVPYnNlcnZhYmxlTWFwID0gKGRlZmF1bHRTdGF0ZSwgc2hvdWxkVXBkYXRlID0gKGEsIGIpID0+IGEgIT09IGIpID0+IHtcbiAgICBjb25zdCB1bndyYXBwZWRTdGF0ZSA9IHVud3JhcChkZWZhdWx0U3RhdGUpO1xuICAgIGxldCBzdGF0ZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHVud3JhcHBlZFN0YXRlICE9PSBudWxsICYmIHVud3JhcHBlZFN0YXRlICE9PSB2b2lkIDAgPyB1bndyYXBwZWRTdGF0ZSA6IHt9KSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICAgIGRpc3Bvc2U6IFtdLFxuICAgICAgICBnZXQ6IFtdLFxuICAgICAgICBzZXQ6IFtdLFxuICAgICAgICByZXNldDogW10sXG4gICAgfTtcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBXaGVuIHJlc2V0dGluZyB0aGUgc3RhdGUsIHRoZSBkZWZhdWx0IHN0YXRlIG1heSBiZSBhIGZ1bmN0aW9uIC0gdW53cmFwIGl0IHRvIGludm9rZSBpdC5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCB0aGUgc3RhdGUgd29uJ3QgYmUgcHJvcGVybHkgcmVzZXRcbiAgICAgICAgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcygoX2EgPSB1bndyYXAoZGVmYXVsdFN0YXRlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pKTtcbiAgICAgICAgaGFuZGxlcnMucmVzZXQuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgIH07XG4gICAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgICAgLy8gQ2FsbCBmaXJzdCBkaXNwb3NlIGFzIHJlc2V0dGluZyB0aGUgc3RhdGUgd291bGRcbiAgICAgICAgLy8gY2F1c2UgbGVzcyB1cGRhdGVzIDspXG4gICAgICAgIGhhbmRsZXJzLmRpc3Bvc2UuZm9yRWFjaCgoY2IpID0+IGNiKCkpO1xuICAgICAgICByZXNldCgpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0ID0gKHByb3BOYW1lKSA9PiB7XG4gICAgICAgIGhhbmRsZXJzLmdldC5mb3JFYWNoKChjYikgPT4gY2IocHJvcE5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlcy5nZXQocHJvcE5hbWUpO1xuICAgIH07XG4gICAgY29uc3Qgc2V0ID0gKHByb3BOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQocHJvcE5hbWUpO1xuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKHZhbHVlLCBvbGRWYWx1ZSwgcHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBzdGF0ZXMuc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBoYW5kbGVycy5zZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3RhdGUgPSAodHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHt9XG4gICAgICAgIDogbmV3IFByb3h5KHVud3JhcHBlZFN0YXRlLCB7XG4gICAgICAgICAgICBnZXQoXywgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvd25LZXlzKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZXMua2V5cygpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzKF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlcy5oYXMocHJvcE5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldChfLCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICBjb25zdCBvbiA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkoaGFuZGxlcnNbZXZlbnROYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3Qgb25DaGFuZ2UgPSAocHJvcE5hbWUsIGNiKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuU2V0ID0gb24oJ3NldCcsIChrZXksIG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIGNiKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gdW53cmFwIHRoZSBkZWZhdWx0U3RhdGUgYmVjYXVzZSBpdCBtaWdodCBiZSBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgbWlnaHQgbm90IGJlIHNlbmRpbmcgdGhlIHJpZ2h0IHJlc2V0IHZhbHVlLlxuICAgICAgICBjb25zdCB1blJlc2V0ID0gb24oJ3Jlc2V0JywgKCkgPT4gY2IodW53cmFwKGRlZmF1bHRTdGF0ZSlbcHJvcE5hbWVdKSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB1blNldCgpO1xuICAgICAgICAgICAgdW5SZXNldCgpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgdXNlID0gKC4uLnN1YnNjcmlwdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzID0gc3Vic2NyaXB0aW9ucy5yZWR1Y2UoKHVuc3Vicywgc3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdzZXQnLCBzdWJzY3JpcHRpb24uc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmdldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdnZXQnLCBzdWJzY3JpcHRpb24uZ2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnJlc2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ3Jlc2V0Jywgc3Vic2NyaXB0aW9uLnJlc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmRpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZGlzcG9zZScsIHN1YnNjcmlwdGlvbi5kaXNwb3NlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5zdWJzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB1bnN1YnMuZm9yRWFjaCgodW5zdWIpID0+IHVuc3ViKCkpO1xuICAgIH07XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc3RhdGVzLmdldChrZXkpO1xuICAgICAgICBoYW5kbGVycy5zZXQuZm9yRWFjaCgoY2IpID0+IGNiKGtleSwgb2xkVmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXQsXG4gICAgICAgIG9uLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgdXNlLFxuICAgICAgICBkaXNwb3NlLFxuICAgICAgICByZXNldCxcbiAgICAgICAgZm9yY2VVcGRhdGUsXG4gICAgfTtcbn07XG5jb25zdCByZW1vdmVGcm9tQXJyYXkgPSAoYXJyYXksIGl0ZW0pID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIGFycmF5Lmxlbmd0aC0tO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVN0b3JlID0gKGRlZmF1bHRTdGF0ZSwgc2hvdWxkVXBkYXRlKSA9PiB7XG4gICAgY29uc3QgbWFwID0gY3JlYXRlT2JzZXJ2YWJsZU1hcChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSk7XG4gICAgbWFwLnVzZShzdGVuY2lsU3Vic2NyaXB0aW9uKCkpO1xuICAgIHJldHVybiBtYXA7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSBhcyBjIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlU3RvcmUgfSBmcm9tICcuL2luZGV4LTgxZDU0OGI3LmpzJztcblxuY29uc3QgcG9wdXBTdG9yZSA9IGNyZWF0ZVN0b3JlKHtcbiAgbGF5ZXI6IG51bGwsXG4gIG1hcFZpZXc6IG51bGwsXG4gIHBvcnRhbDogbnVsbCxcbiAgY29uZmlnOiBudWxsLFxuICBzdHJpbmdzOiBudWxsLFxuICBjdXJyZW50TGFuZ3VhZ2U6IG51bGwsXG4gIGN1cnJlbnRMYW5ndWFnZUludGw6IG51bGwsXG4gIHNlcnZpY2VUeXBlOiBudWxsLFxuICBwb3B1cFRlbXBsYXRlOiBudWxsLFxuICBsYXllckhhc0F0dGFjaG1lbnQ6IG51bGwsXG4gIGxheWVySGFzRVQ6IG51bGwsXG4gIGxheWVySGFzQXR0cmlidXRlczogbnVsbCxcbiAgbGF5ZXJIYXNDaGFydHM6IG51bGwsXG4gIGxheWVySGFzSW1hZ2VzOiBudWxsLFxuICBsYXllckhhc1RleHQ6IG51bGwsXG4gIGxheWVyRGlzcGxheVR5cGU6IG51bGwsXG4gIHN1cHBvcnRzQXJjYWRlOiBudWxsLFxuICBsYXllckhhc1JlbGF0ZWRSZWNvcmRzOiBmYWxzZVxufSk7XG4vLyB3b3JrYXJvdW5kIGZvciBzdGFydGluZyBhIHBhbmVsIHdpdGggYSBjbGVhbiBzdGF0ZVxuZnVuY3Rpb24gY2xlYXJQb3B1cFN0YXRlKHBvcHVwU3RhdGUpIHtcbiAgcG9wdXBTdGF0ZS5sYXllciA9IG51bGw7XG4gIHBvcHVwU3RhdGUubWFwVmlldyA9IG51bGw7XG4gIHBvcHVwU3RhdGUucG9ydGFsID0gbnVsbDtcbiAgcG9wdXBTdGF0ZS5jb25maWcgPSBudWxsO1xuICBwb3B1cFN0YXRlLnN0cmluZ3MgPSBudWxsO1xuICBwb3B1cFN0YXRlLmN1cnJlbnRMYW5ndWFnZSA9IG51bGw7XG4gIHBvcHVwU3RhdGUuY3VycmVudExhbmd1YWdlSW50bCA9IG51bGw7XG4gIHBvcHVwU3RhdGUuc2VydmljZVR5cGUgPSBudWxsO1xuICBwb3B1cFN0YXRlLnBvcHVwVGVtcGxhdGUgPSBudWxsO1xuICBwb3B1cFN0YXRlLmxheWVySGFzQXR0YWNobWVudCA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJIYXNFVCA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJIYXNBdHRyaWJ1dGVzID0gbnVsbDtcbiAgcG9wdXBTdGF0ZS5sYXllckhhc0NoYXJ0cyA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJIYXNJbWFnZXMgPSBudWxsO1xuICBwb3B1cFN0YXRlLmxheWVySGFzVGV4dCA9IG51bGw7XG4gIHBvcHVwU3RhdGUubGF5ZXJEaXNwbGF5VHlwZSA9IG51bGw7XG4gIHBvcHVwU3RhdGUuc3VwcG9ydHNBcmNhZGUgPSBudWxsO1xuICBwb3B1cFN0YXRlLmxheWVySGFzUmVsYXRlZFJlY29yZHMgPSBmYWxzZTtcbn1cbmNvbnN0IHBvcHVwU3RhdGUgPSBwb3B1cFN0b3JlLnN0YXRlO1xuXG5leHBvcnQgeyBjbGVhclBvcHVwU3RhdGUgYXMgYywgcG9wdXBTdGF0ZSBhcyBwIH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGUgYXMgZXNjYXBlUmVnRXhwIH0gZnJvbSAnLi9mdW5jdGlvbmFsLWM4MmY1YWI5LmpzJztcblxuLy8gaW1wb3J0IHN0cmluZ1V0aWwgZnJvbSBcIi4vc3RyaW5nc1wiO1xuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZHMgZm9yIGRlYWxpbmcgd2l0aCBzdG9yYWdlIG9mIHZhcmlvdXMgZm9ybXMgKGNvb2tpZXMsIGxvY2FsIHN0b3JhZ2UsIGFuZCBzZXNzaW9uIHN0b3JhZ2UpLlxuICovXG5mdW5jdGlvbiBzZXRDb29raWUobmFtZSwgY29va2llLCBwcm9wZXJ0aWVzLCBzdHJpbmdpZnkpIHtcbiAgd3JpdGVDb29raWUobmFtZSwgc3RyaW5naWZ5ID8gSlNPTi5zdHJpbmdpZnkoY29va2llKSA6IGNvb2tpZSwgcHJvcGVydGllcyk7XG59XG5mdW5jdGlvbiBnZXRDb29raWUobmFtZSwgcGFyc2UpIHtcbiAgY29uc3QgY29va2llID0gcmVhZENvb2tpZShuYW1lKTtcbiAgcmV0dXJuIGNvb2tpZSAmJiBwYXJzZSA/IEpTT04ucGFyc2UoY29va2llKSA6IGNvb2tpZTtcbn1cbmZ1bmN0aW9uIHNldExvY2FsU3RvcmFnZUl0ZW0obmFtZSwgaXRlbSwgc3RyaW5naWZ5KSB7XG4gIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBzdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShpdGVtKSA6IGl0ZW0pO1xufVxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yYWdlSXRlbShuYW1lLCBwYXJzZSkge1xuICBjb25zdCBpdGVtID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpO1xuICByZXR1cm4gaXRlbSAmJiBwYXJzZSA/IEpTT04ucGFyc2UoaXRlbSkgOiBpdGVtO1xufVxuZnVuY3Rpb24gc2V0U2Vzc2lvblN0b3JhZ2VJdGVtKG5hbWUsIGl0ZW0sIHN0cmluZ2lmeSkge1xuICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBzdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShpdGVtKSA6IGl0ZW0pO1xufVxuZnVuY3Rpb24gZ2V0U2Vzc2lvblN0b3JhZ2VJdGVtKG5hbWUsIHBhcnNlKSB7XG4gIGNvbnN0IGl0ZW0gPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcbiAgcmV0dXJuIGl0ZW0gJiYgcGFyc2UgPyBKU09OLnBhcnNlKGl0ZW0pIDogaXRlbTtcbn1cbmZ1bmN0aW9uIHJlYWRDb29raWUobmFtZSkge1xuICBjb25zdCBjb29raWUgPSBkb2N1bWVudC5jb29raWU7XG4gIGNvbnN0IGNvb2tpZU5hbWVSRSA9IG5ldyBSZWdFeHAoYCg/Ol58OyApJHtlc2NhcGVSZWdFeHAobmFtZSl9PShbXjtdKilgKTtcbiAgY29uc3QgbWF0Y2hlZENvb2tpZXMgPSBjb29raWUubWF0Y2goY29va2llTmFtZVJFKTtcbiAgcmV0dXJuIG1hdGNoZWRDb29raWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoZWRDb29raWVzWzFdKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHdyaXRlQ29va2llKG5hbWUsIHZhbHVlLCBwcm9wZXJ0aWVzKSB7XG4gIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICBsZXQgZXhwaXJlcyA9IHByb3BlcnRpZXMgPT09IG51bGwgfHwgcHJvcGVydGllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcGVydGllcy5leHBpcmVzO1xuICBpZiAodHlwZW9mIGV4cGlyZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb25zdCBleHBpcmF0aW9uRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgZGF5c0Zyb21Ub2RheUluTXMgPSBleHBpcmVzICogMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICBleHBpcmF0aW9uRGF0ZS5zZXRUaW1lKERhdGUubm93KCkgKyBkYXlzRnJvbVRvZGF5SW5Ncyk7XG4gICAgZXhwaXJlcyA9IHByb3BlcnRpZXMuZXhwaXJlcyA9IGV4cGlyYXRpb25EYXRlO1xuICB9XG4gIGlmICh0eXBlb2YgZXhwaXJlcyAhPT0gXCJzdHJpbmdcIiAmJiAoZXhwaXJlcyA9PT0gbnVsbCB8fCBleHBpcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHBpcmVzLnRvVVRDU3RyaW5nKSkge1xuICAgIHByb3BlcnRpZXMuZXhwaXJlcyA9IGV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgfVxuICBsZXQgY29va2llID0gYCR7bmFtZX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG4gIGxldCBwcm9wZXJ0eTtcbiAgZm9yIChwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgY29va2llICs9IGA7ICR7cHJvcGVydHl9YDtcbiAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gcHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgaWYgKHByb3BlcnR5VmFsdWUgIT09IHRydWUpIHtcbiAgICAgIGNvb2tpZSArPSBgPSR7cHJvcGVydHlWYWx1ZX1gO1xuICAgIH1cbiAgfVxuICBkb2N1bWVudC5jb29raWUgPSBjb29raWU7XG59XG5cbmV4cG9ydCB7IGdldENvb2tpZSBhcyBhLCBzZXRDb29raWUgYXMgYiwgc2V0U2Vzc2lvblN0b3JhZ2VJdGVtIGFzIGMsIGdldFNlc3Npb25TdG9yYWdlSXRlbSBhcyBkLCBnZXRMb2NhbFN0b3JhZ2VJdGVtIGFzIGcsIHNldExvY2FsU3RvcmFnZUl0ZW0gYXMgcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9