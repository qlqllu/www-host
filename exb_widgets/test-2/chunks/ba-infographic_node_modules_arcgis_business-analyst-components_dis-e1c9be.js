"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-e1c9be"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/base-util-b7db69f0.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/base-util-b7db69f0.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ BaseUtil)
/* harmony export */ });
/* harmony import */ var _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ElementIds-a2c40592.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/ElementIds-a2c40592.js");


class ACLUtils {
  static announceVersion() {
    if (!ACLUtils.hasAnnounced) {
      ACLUtils.hasAnnounced = true;
      _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_0__.L.show('%gl', '> business-analyst-components - v' + ACLUtils.VERSION);
    }
  }
  // Utility functions
  static notDef(obj) {
    return typeof obj === 'undefined' || obj === null;
  }
  static isDef(obj) {
    return !ACLUtils.notDef(obj);
  }
  static hasText(str) {
    return (ACLUtils.isDef(str) &&
      typeof str === 'string' &&
      str.length > 0 &&
      str.trim().length > 0);
  }
  static getKeys(obj) {
    var k, keys = [];
    for (k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  }
  ;
  static isNumber(n) {
    return !isNaN(parseFloat(n)) && !isNaN(n - 0);
  }
  static _hasProperty(c, p) {
    return ACLUtils.hasText(c[p]);
  }
  // Returns an ID string containing the '#'
  static fixId(id) {
    if (!id || id.length <= 0) {
      return '';
    }
    return (id[0] === '#') ? id : '#' + id;
  }
  /** applyCss - applies css to elements in shadow dom of current component (context = this)
   *
   * NOTE: This function should be executed with 'call()' to pass the instance of the component
   *
   * @param css => array of css values [[prop,value]]
   * @param opt
   * {
   *  selector?:string,     //query selector for current shadow elements
   *  id?:string,           //query using element id in shadow dom
   *  subSelector?:string   //query selector for elements inside the shadow dom of the containing element (in a higher shadow)
   *  isClassname?:boolean  //flag indicating the css string is actually a class name
   *  }
   */
  // css => [[prop,value]]
  static applyCss(css, opt) {
    if (!css || !opt)
      return;
    const self = this;
    // if (opt.verbose)
    //   console.log("%c applyCss()...", ACLUtils.flagText, css, opt);
    function _doCss(obj) {
      if (obj && obj.style) {
        for (let m = 0; m < css.length; m++) {
          // if (opt.verbose)
          //   console.log("%c _doCss applying " + css[m][0], ACLUtils.flagText);
          if (obj.style)
            obj.style[css[m][0]] = css[m][1];
          else if (ACLUtils._verbose)
            console.log("%cWarn: missing style for ", ACLUtils.flagText, obj);
        }
      }
    }
    let arr = [];
    if (opt && opt.id) {
      let elem = ACLUtils.queryElementById.call(self, opt.id);
      if (elem) {
        arr.push(elem);
      }
    }
    else if (opt.selector) {
      let items = ACLUtils.queryElementAll.call(self, opt.selector);
      // if (opt.verbose)
      //   console.log("%c applyCss selector results=", ACLUtils.flagText, items);
      if (items && items.length > 0) {
        if (!opt.subSelector)
          arr.push(items);
        else {
          // if (opt.verbose)
          //   console.log("%c applyCss foreach item look for subselector", ACLUtils.flagText);
          items.forEach((i) => {
            let sub = ACLUtils.queryElementAll.call(self, opt.subSelector, i);
            arr.push(sub);
          });
        }
      }
    }
    if (opt.isClassname) {
      arr.forEach((a) => {
        let classname = css[0][0];
        if (!a.classList.contains(classname))
          a.classList.toggle(classname);
      });
    }
    else {
      // if (opt.verbose)
      //   console.log("%c applyCss doCss for array=", ACLUtils.flagText, arr);
      arr.forEach((a) => {
        if (NodeList.prototype.isPrototypeOf(a)) {
          for (let jj = 0; jj < a.length; jj++) {
            _doCss(a[jj]);
          }
        }
        else {
          _doCss(a);
        }
      });
    }
  }
  static getShadowRoot(context) {
    let root;
    if (context) {
      if (context.shadowRoot)
        root = context.shadowRoot;
      else if (context.el && context.el.shadowRoot)
        root = context.el.shadowRoot;
    }
    if (!root) {
      ACLUtils._rootCounter++;
    }
    return root;
  }
  /**
   * queryElement - this query searches the shadow dom of the component (if available) for
   * the first matching element (context = this)
   *
   * NOTE: These query functions should be executed with 'call()' to pass the instance of the component
   *
   *  - query:  standard CSS selector
   *  - elem: (optional) If not specified, the shadow dom used is this component's shadow dom.
   *                     If specified, we use the shadow dom of the element passed in
   */
  static queryElement(query, elem) {
    let self = this;
    let result, subRoot;
    if (!query || !ACLUtils.hasText(query)) {
      return result;
    }
    const root = ACLUtils.getShadowRoot(self);
    function _checkRoot() {
      let v;
      if (root)
        v = root.querySelector(query);
      if (!v)
        v = document.querySelector(query);
      return v;
    }
    if (elem) {
      subRoot = ACLUtils.getShadowRoot(elem);
      if (subRoot)
        result = subRoot.querySelector(query);
      if (!result)
        result = _checkRoot();
    }
    else {
      result = _checkRoot();
    }
    const r = result || undefined;
    // console.log("%cQueryElement final return=", (result) ? ACLUtils.greenText : ACLUtils.flagText, r);
    return r;
  }
  // query the shadow dom of the component for all matching elements (context = this)
  // use this doing a 'call' with the top element whose shadow dom will be searched
  // static queryElementAll(query: string, elem?: any): HTMLElement {
  //   // if (ACLUtils._verbose) console.log("%c queryElementAll("+query+','+elem+')', 'color:red');
  //   let self: any = this;
  //   let result: any, subRoot:any;
  //   const root:any = ACLUtils.getShadowRoot(self);
  //   // if (ACLUtils._verbose) console.log('%c queryElementAll self=', 'color:red', self);
  //   function _checkRoot() {
  //     let v;
  //     // if (ACLUtils._verbose) console.log('%c queryElementAll using shadow=', 'color:red', root);
  //     if (root) {
  //       v = root.querySelectorAll(query)
  //       // if (ACLUtils._verbose) console.log("%c queryElementAll -queried shadow for "+query, 'color:red', v);
  //     }
  //     if (!v)
  //       v = document.querySelectorAll(query);
  //     return v;
  //   }
  //   if (elem) {
  //     subRoot = ACLUtils.getShadowRoot(elem);
  //     if (subRoot)
  //       result = subRoot.querySelectorAll(query);
  //     if (!result)
  //       result = _checkRoot();
  //   }
  //   else {
  //     result = _checkRoot();
  //   }
  //   const r = result || undefined;
  //   // console.log("%cQueryElementAll final return=", (result) ? ACLUtils.greenText : ACLUtils.flagText, r);
  //   return r;
  // }
  static queryElementAll(query, elem) {
    let self = this;
    const allResults = [];
    function recursiveQueryShadow(root) {
      const results = root.querySelectorAll(query);
      results.forEach((result) => {
        allResults.push(result);
        const shadowRoot = ACLUtils.getShadowRoot(result);
        if (shadowRoot) {
          recursiveQueryShadow(shadowRoot);
        }
      });
    }
    if (elem) {
      const subRoot = ACLUtils.getShadowRoot(elem);
      if (subRoot) {
        recursiveQueryShadow(subRoot);
      }
      else {
        recursiveQueryShadow(elem);
      }
    }
    else {
      const primaryRoot = ACLUtils.getShadowRoot(self) || document;
      recursiveQueryShadow(primaryRoot);
    }
    return allResults;
  }
  // query the shadow dom of the component for the matching element (context = this)
  static queryElementById(id) {
    let result;
    if (!id || !ACLUtils.hasText(id)) {
      console.log('%c Error: queryElementById invoked with invalid id', 'color:red;font-size;8pt');
    }
    else {
      result = ACLUtils.queryElement.call(this, ACLUtils.fixId(id));
    }
    return result;
  }
  /*

* ACL Theme contains the following:
* {
* background: <main background color in the hex/alpha format #ffe0e0e0> default=#fff
* text: <main text color in the hex format #e0e0e0> default= #333
* darkBackground: <main background when in dark mode in hex format> default=#252526
* darkText: <main text color when in dark mode in hex> default=#C5C5C5
* headerBackground: <main header background color (if applies)> default= #2C78D4
* headerText: <main header text color (if applies)> default= #fff
* displayHeader: < visibility is true or false> default= true
* displayDarkMode: < dark mode is true or false> default= false
* }
*
* parseThemeString - expects a string representing the theme object. Parses the string and validates.
*
* return = Theme object
*/
  static parseThemeString(s) {
    if (this.hasText(s)) {
      return JSON.parse(s);
    }
    else {
      return {}; // no theme
    }
  }
  static parseBufferSizes(s) {
    if (typeof s == undefined) {
      return [1];
    }
    let result = [];
    try {
      if (this.hasText(s)) {
        let arr = s.split(',');
        for (let ii = 0; ii < arr.length; ii++) {
          if (ii >= 3)
            continue;
          let v = parseFloat(arr[ii]);
          result.push(v);
        }
      }
      else {
        return [1]; // default to 1 unit
      }
    }
    catch (ex) {
      console.log(ex);
      return [1]; // default to 1 unit
    }
    return result;
  }
}
ACLUtils.VERSION = '1.2.194';
ACLUtils.hasAnnounced = false;
ACLUtils._verbose = false;
ACLUtils._rootCounter = 0;
ACLUtils.noteStyle = 'background-color:#e1ebd4;color:#222;padding:3px;border-radius:2px;';
ACLUtils.errorStyle = 'background-color:red;color:white;padding:4px;border-radius:3px';
ACLUtils.grayStyle = 'background-color:#7890ad;color:#444;padding:3px;border-radius:2px;';
ACLUtils.flagStyle = 'background-color:yellow;color:#000;padding:5px;border-radius:2px;';
ACLUtils.blueStyle = 'background-color:blue;color:#eee;padding:1px 5px;border-radius:2px;';
ACLUtils.flagText = 'color:yellow;';
ACLUtils.blueText = 'color:#4d88ff;';
ACLUtils.greenText = 'color:#277711;';

var ThemeType;
(function (ThemeType) {
  ThemeType[ThemeType["light"] = 1] = "light";
  ThemeType[ThemeType["dark"] = 2] = "dark";
})(ThemeType || (ThemeType = {}));
// Since Stencil Components don't allow extending base classes, this
// class will stand-in as a way to provide common functionality across
// all components without duplicated code in each component.
//
class BaseUtil {
  // Provide stencil component instance as context
  constructor(name, context, callback) {
    this._dbg = false;
    // default colors
    this.defaultColors = {
      brand: '#007ac2',
      brandHover: '#00619b',
      brandPress: '#004874',
      background: '#f8f8f8',
      foreground: '#ffffff',
      text: '#151515',
      textInverse: '#ffffff',
      border: '#cacaca',
      scrollbar: '#232323',
      scrollbarBG: '#ffffff'
    };
    this._subComponents = {};
    this._context = context;
    if (callback) {
      this._updateCallback = callback;
    }
    if (!this._context.theme) {
      this._context.theme = ThemeType.light;
    }
    //this._color = { primary: "#fff", secondary: "#000", text: "blue", background: "transparent", foreground: "transparent" };
    this._theme = ThemeType.light;
    this.resetConfig();
    this.configInstanceId = BaseUtil.registerComponent(name, this);
    this.updateLocaleSettings();
  }
  static registerComponent(name, config) {
    const id = BaseUtil._getUniqueName(name);
    BaseUtil.ComponentRegistry[id] = config;
    return id;
  }
  static _getUniqueName(name) { return name + '-' + BaseUtil._componentIndex++; }
  //
  hasSubComponents() {
    const keys = Object.keys(this._subComponents);
    const v = (keys && keys.length > 0);
    return v;
  }
  addToParent(parentId) {
    if (parentId) {
      // Register myself with my parent config
      const parentCfg = BaseUtil.ComponentRegistry[parentId];
      if (parentCfg) {
        parentCfg.addSubComponent(this.configInstanceId);
      }
    }
  }
  addSubComponent(id) {
    this._subComponents[id] = true;
    //this.updateSubcomponentConfigs()
  }
  resetConfig() {
    const defaultConfig = {
      id: '',
      env: 'en-us',
      geoenrichmentUrl: null,
      username: null,
      token: null,
      langCode: 'en-us',
      theme: ThemeType.light
    };
    this.config = {
      id: '',
      env: 'en-us',
      geoenrichmentUrl: null,
      username: null,
      token: null,
      langCode: 'en-us',
      theme: ThemeType.light
    };
    this.updateConfig(defaultConfig, null);
  }
  /*
   * updateLocaleSettings
   *
   * use this to update any locale setting, or to revert to defaults
   *    obj = null or undefined: reset to defaults
   *    otherwise >> obj properties will overwrite exiting properties.  All other
   *    properties will remain as they were
   */
  updateLocaleSettings(obj) {
    if (!this._localeSettings || !obj) {
      // defaults
      this._localeSettings = {
        language: 'en-US',
        country: 'US',
        location: '-117.196,34.056',
        geocodeOutFields: 'Subregion,Region,PlaceName,Match_addr,Country,Addr_type,City,Place_addr,Phone,URL'
      };
    }
    else {
      const keys = ACLUtils.getKeys(obj);
      for (let ii = 0; ii < keys.length; ii++) {
        let k = keys[ii];
        if (ACLUtils.hasText(k)) {
          this._localeSettings[k] = obj[k];
        }
      }
    }
  }
  syncConfigFromProps() {
    // does nothing at this point
  }
  // Sets theme to dark or light
  //
  //    themeType = 1   standard calcite light theme (default)
  //              = 2   dark theme
  //
  setTheme(themeType = 1, updateComponentProp) {
    const self = this;
    const owner = self._context;
    // assign theme Prop to ThemeType
    let t = ThemeType.light;
    switch (themeType) {
      case (ThemeType.light):
      case ('light'):
      case ('1'):
      case (1): {
        t = ThemeType.light;
        break;
      }
      case (ThemeType.dark):
      case ('2'):
      case (2):
      case ('dark'): {
        t = ThemeType.dark;
        break;
      }
      default: t = ThemeType.light;
    }
    if (updateComponentProp) {
      // Update component theme Prop
      owner.theme = t;
    }
  }
  async updateSubcomponentConfigs() {
    if (this._dbg) {
      console.log('%c CONFIG updating subs', 'color:orange;font-size:11pt', this._subComponents);
    }
    if (this._subComponents) {
      const keys = Object.keys(this._subComponents);
      if (keys && keys.length > 0) {
        for (let ii = 0; ii < keys.length; ii++) {
          const subId = keys[ii];
          // look up config in global registry
          const config = BaseUtil.ComponentRegistry[subId];
          if (config) {
            config.updateConfig(this.config, null);
          }
        }
      }
    }
  }
  // base-util function to trigger component's registered callback (normally is onUpdateUI)
  onComponentHasRendered() {
    if (this._updateCallback && this._context?.el) {
      try {
        this._updateCallback.call(this._context);
      }
      catch (ex) {
        console.log('onComponentHasRendered error', ex);
      }
    }
  }
  // checks object for required colors, and sets defaults where needed
  _validateColors(existing, proposedColors) {
    // apply default to empty obj
    if (!existing) {
      existing = {};
    }
    const incoming = proposedColors || {};
    // Apply default colors
    const merged = Object.assign(this.defaultColors, existing, incoming);
    // Remode undefined properties
    const mKeys = ACLUtils.getKeys(merged);
    for (let ii = 0; ii < mKeys.length; ii++) {
      let k = mKeys[ii];
      if (!merged[k]) {
        delete merged[k];
      }
    }
    // update existing object
    return merged;
  }
  /* updateConfig
   *  Call this when the component config changes.  It will update essential Props,
   *  and return a list of property names that changed.  Changes overwrite properties, but
   *  leave other properties in the config as-is (unchanged)
   *
   * configs are passed in as objects (not strings)
   */
  updateConfig(newConfig, oldConfig) {
    if (this._dbg) {
      console.log('%c CONFIG update', 'color:yellow;font-size:11pt', this._context);
    }
    if (this._dbg) {
      console.log('%c CONFIG update running for ID=', 'color:yellow;font-size:11pt', this.configInstanceId);
    }
    const changedKeys = [];
    if (!newConfig || ACLUtils.getKeys(newConfig).length <= 0) {
      return changedKeys;
    }
    const self = this;
    const owner = self._context;
    try {
      // create a copy of the current config and return a list of what has changed
      // find the newConfig CHANGES
      const newKeys = ACLUtils.getKeys(newConfig);
      for (let ii = 0; ii < newKeys.length; ii++) {
        const key = newKeys[ii];
        try {
          if (newConfig.hasOwnProperty(key)) {
            if (!oldConfig && key != 'colors') {
              if (typeof newConfig[key] !== 'undefined') {
                changedKeys.push(key);
              }
            }
            else if (key == 'colors') {
              if (ACLUtils.getKeys(newConfig[key]).length > 0) {
                if (!oldConfig || !oldConfig.colors) {
                  changedKeys.push(key);
                }
                else {
                  // test individual properties belonging to colors
                  const colorKeys = ACLUtils.getKeys(newConfig.colors);
                  for (let kk = 0; kk < colorKeys.length; kk++) {
                    let colorKey = colorKeys[kk];
                    const colorName = colorKey;
                    if (newConfig.colors.hasOwnProperty(colorName)) {
                      if (newConfig.colors[colorName] != oldConfig.colors[colorName]) {
                        if (!changedKeys.includes(key)) {
                          changedKeys.push(key);
                        }
                      }
                    }
                  }
                }
              }
              else {
                if (!changedKeys.includes(key)) {
                  changedKeys.push(key);
                }
              }
            }
            else if (newConfig[key] != oldConfig[key]) {
              changedKeys.push(key);
            }
          }
        }
        catch (ex) {
          console.log('baseConfig error:', ex);
        }
      }
      if (this._dbg) {
        console.log('%c ...CONFIG changed=', 'color:yellow;font-size:11pt', changedKeys);
      }
      // COLORS
      //
      // Make sure colors exists
      if (!this.config.colors) {
        this.config.colors = {};
      }
      // apply incoming changes to our colors object
      if (changedKeys.includes('colors')) {
        this.config.colors = this._validateColors(this.config.colors, newConfig.colors);
      }
      //
      // THEME
      if (changedKeys.includes('theme')) {
        this.setTheme(newConfig.theme);
      }
      //
      // update base-util config object with changes (except for colors which is already done above)
      if (!this.config) {
        this.config = {};
      }
      for (let jj = 0; jj < changedKeys.length; jj++) {
        let k = changedKeys[jj];
        if (k != 'colors') {
          this.config[k] = newConfig[k];
        }
      }
      // sync owner component props @@ may trigger endless loop @@
      // AUTHENTICATION
      if (changedKeys.includes('username')) {
        owner.username = newConfig.username;
      }
      if (changedKeys.includes('token')) {
        owner.token = newConfig.token;
      }
      //
      // MISC
      if (changedKeys.includes('env')) {
        owner.env = newConfig.env;
      }
      if (changedKeys.includes('geoenrichmentUrl')) {
        owner.geoenrichmentUrl = newConfig.geoenrichmentUrl;
      }
      if (changedKeys.includes('langCode')) {
        owner.langCode = newConfig.langCode;
      }
      // Use passed in langCode if set
      if (changedKeys.includes('langCode')) {
        if (!owner._localeSettings) {
          owner._localeSettings = {};
        }
        owner._localeSettings.language = newConfig.langCode;
        owner.langCode = newConfig.langCode || 'en-us';
        _ElementIds_a2c40592_js__WEBPACK_IMPORTED_MODULE_0__.B._initialize(owner.langCode);
        owner.setLocaleStrings();
      }
      if (changedKeys.includes('sourceCountry')) {
        this.config.sourceCountry = owner.sourceCountry = newConfig.sourceCountry || 'US';
      }
      self.updateSubcomponentConfigs();
      if (newConfig._parentConfigId && changedKeys.includes('_parentConfigId')) {
        this.addToParent(newConfig._parentConfigId);
      }
      self.onComponentHasRendered();
    }
    catch (ex2) {
      console.log('updateConfig error', ex2);
    }
    return changedKeys;
  }
  getConfigString() {
    let obj = { ...this.config, _parentConfigId: this.configInstanceId };
    return JSON.stringify(obj);
  }
}
// index of all subcomponents related to any base-util instance
//   { <subcomponentId>: <config ref>, ... }
BaseUtil.ComponentRegistry = {};
BaseUtil._componentIndex = 1;



//# sourceMappingURL=base-util-b7db69f0.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLWUxYzliZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFeUI7O0FBRXpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9iYS1pbmZvZ3JhcGhpYy9ub2RlX21vZHVsZXMvQGFyY2dpcy9idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHMvZGlzdC9zdGVuY2lsLWNvbXBvbmVudHMvZGlzdC9lc20vYmFzZS11dGlsLWI3ZGI2OWYwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEwgYXMgTG9neiwgQiBhcyBCYVJlcG9ydHNMYW5ndWFnZSB9IGZyb20gJy4vRWxlbWVudElkcy1hMmM0MDU5Mi5qcyc7XG5cbmNsYXNzIEFDTFV0aWxzIHtcclxuICBzdGF0aWMgYW5ub3VuY2VWZXJzaW9uKCkge1xyXG4gICAgaWYgKCFBQ0xVdGlscy5oYXNBbm5vdW5jZWQpIHtcclxuICAgICAgQUNMVXRpbHMuaGFzQW5ub3VuY2VkID0gdHJ1ZTtcclxuICAgICAgTG9nei5zaG93KCclZ2wnLCAnPiBidXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHMgLSB2JyArIEFDTFV0aWxzLlZFUlNJT04pO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uc1xyXG4gIHN0YXRpYyBub3REZWYob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgfHwgb2JqID09PSBudWxsO1xyXG4gIH1cclxuICBzdGF0aWMgaXNEZWYob2JqKSB7XHJcbiAgICByZXR1cm4gIUFDTFV0aWxzLm5vdERlZihvYmopO1xyXG4gIH1cclxuICBzdGF0aWMgaGFzVGV4dChzdHIpIHtcclxuICAgIHJldHVybiAoQUNMVXRpbHMuaXNEZWYoc3RyKSAmJlxyXG4gICAgICB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICBzdHIubGVuZ3RoID4gMCAmJlxyXG4gICAgICBzdHIudHJpbSgpLmxlbmd0aCA+IDApO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0S2V5cyhvYmopIHtcclxuICAgIHZhciBrLCBrZXlzID0gW107XHJcbiAgICBmb3IgKGsgaW4gb2JqKSB7XHJcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcclxuICAgICAgICBrZXlzLnB1c2goayk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBrZXlzO1xyXG4gIH1cclxuICA7XHJcbiAgc3RhdGljIGlzTnVtYmVyKG4pIHtcclxuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgIWlzTmFOKG4gLSAwKTtcclxuICB9XHJcbiAgc3RhdGljIF9oYXNQcm9wZXJ0eShjLCBwKSB7XHJcbiAgICByZXR1cm4gQUNMVXRpbHMuaGFzVGV4dChjW3BdKTtcclxuICB9XHJcbiAgLy8gUmV0dXJucyBhbiBJRCBzdHJpbmcgY29udGFpbmluZyB0aGUgJyMnXHJcbiAgc3RhdGljIGZpeElkKGlkKSB7XHJcbiAgICBpZiAoIWlkIHx8IGlkLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiAoaWRbMF0gPT09ICcjJykgPyBpZCA6ICcjJyArIGlkO1xyXG4gIH1cclxuICAvKiogYXBwbHlDc3MgLSBhcHBsaWVzIGNzcyB0byBlbGVtZW50cyBpbiBzaGFkb3cgZG9tIG9mIGN1cnJlbnQgY29tcG9uZW50IChjb250ZXh0ID0gdGhpcylcclxuICAgKlxyXG4gICAqIE5PVEU6IFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGV4ZWN1dGVkIHdpdGggJ2NhbGwoKScgdG8gcGFzcyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNzcyA9PiBhcnJheSBvZiBjc3MgdmFsdWVzIFtbcHJvcCx2YWx1ZV1dXHJcbiAgICogQHBhcmFtIG9wdFxyXG4gICAqIHtcclxuICAgKiAgc2VsZWN0b3I/OnN0cmluZywgICAgIC8vcXVlcnkgc2VsZWN0b3IgZm9yIGN1cnJlbnQgc2hhZG93IGVsZW1lbnRzXHJcbiAgICogIGlkPzpzdHJpbmcsICAgICAgICAgICAvL3F1ZXJ5IHVzaW5nIGVsZW1lbnQgaWQgaW4gc2hhZG93IGRvbVxyXG4gICAqICBzdWJTZWxlY3Rvcj86c3RyaW5nICAgLy9xdWVyeSBzZWxlY3RvciBmb3IgZWxlbWVudHMgaW5zaWRlIHRoZSBzaGFkb3cgZG9tIG9mIHRoZSBjb250YWluaW5nIGVsZW1lbnQgKGluIGEgaGlnaGVyIHNoYWRvdylcclxuICAgKiAgaXNDbGFzc25hbWU/OmJvb2xlYW4gIC8vZmxhZyBpbmRpY2F0aW5nIHRoZSBjc3Mgc3RyaW5nIGlzIGFjdHVhbGx5IGEgY2xhc3MgbmFtZVxyXG4gICAqICB9XHJcbiAgICovXHJcbiAgLy8gY3NzID0+IFtbcHJvcCx2YWx1ZV1dXHJcbiAgc3RhdGljIGFwcGx5Q3NzKGNzcywgb3B0KSB7XHJcbiAgICBpZiAoIWNzcyB8fCAhb3B0KVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIC8vIGlmIChvcHQudmVyYm9zZSlcclxuICAgIC8vICAgY29uc29sZS5sb2coXCIlYyBhcHBseUNzcygpLi4uXCIsIEFDTFV0aWxzLmZsYWdUZXh0LCBjc3MsIG9wdCk7XHJcbiAgICBmdW5jdGlvbiBfZG9Dc3Mob2JqKSB7XHJcbiAgICAgIGlmIChvYmogJiYgb2JqLnN0eWxlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCBjc3MubGVuZ3RoOyBtKyspIHtcclxuICAgICAgICAgIC8vIGlmIChvcHQudmVyYm9zZSlcclxuICAgICAgICAgIC8vICAgY29uc29sZS5sb2coXCIlYyBfZG9Dc3MgYXBwbHlpbmcgXCIgKyBjc3NbbV1bMF0sIEFDTFV0aWxzLmZsYWdUZXh0KTtcclxuICAgICAgICAgIGlmIChvYmouc3R5bGUpXHJcbiAgICAgICAgICAgIG9iai5zdHlsZVtjc3NbbV1bMF1dID0gY3NzW21dWzFdO1xyXG4gICAgICAgICAgZWxzZSBpZiAoQUNMVXRpbHMuX3ZlcmJvc2UpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWNXYXJuOiBtaXNzaW5nIHN0eWxlIGZvciBcIiwgQUNMVXRpbHMuZmxhZ1RleHQsIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgYXJyID0gW107XHJcbiAgICBpZiAob3B0ICYmIG9wdC5pZCkge1xyXG4gICAgICBsZXQgZWxlbSA9IEFDTFV0aWxzLnF1ZXJ5RWxlbWVudEJ5SWQuY2FsbChzZWxmLCBvcHQuaWQpO1xyXG4gICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgIGFyci5wdXNoKGVsZW0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcHQuc2VsZWN0b3IpIHtcclxuICAgICAgbGV0IGl0ZW1zID0gQUNMVXRpbHMucXVlcnlFbGVtZW50QWxsLmNhbGwoc2VsZiwgb3B0LnNlbGVjdG9yKTtcclxuICAgICAgLy8gaWYgKG9wdC52ZXJib3NlKVxyXG4gICAgICAvLyAgIGNvbnNvbGUubG9nKFwiJWMgYXBwbHlDc3Mgc2VsZWN0b3IgcmVzdWx0cz1cIiwgQUNMVXRpbHMuZmxhZ1RleHQsIGl0ZW1zKTtcclxuICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpZiAoIW9wdC5zdWJTZWxlY3RvcilcclxuICAgICAgICAgIGFyci5wdXNoKGl0ZW1zKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vIGlmIChvcHQudmVyYm9zZSlcclxuICAgICAgICAgIC8vICAgY29uc29sZS5sb2coXCIlYyBhcHBseUNzcyBmb3JlYWNoIGl0ZW0gbG9vayBmb3Igc3Vic2VsZWN0b3JcIiwgQUNMVXRpbHMuZmxhZ1RleHQpO1xyXG4gICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3ViID0gQUNMVXRpbHMucXVlcnlFbGVtZW50QWxsLmNhbGwoc2VsZiwgb3B0LnN1YlNlbGVjdG9yLCBpKTtcclxuICAgICAgICAgICAgYXJyLnB1c2goc3ViKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdC5pc0NsYXNzbmFtZSkge1xyXG4gICAgICBhcnIuZm9yRWFjaCgoYSkgPT4ge1xyXG4gICAgICAgIGxldCBjbGFzc25hbWUgPSBjc3NbMF1bMF07XHJcbiAgICAgICAgaWYgKCFhLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc25hbWUpKVxyXG4gICAgICAgICAgYS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzbmFtZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIGlmIChvcHQudmVyYm9zZSlcclxuICAgICAgLy8gICBjb25zb2xlLmxvZyhcIiVjIGFwcGx5Q3NzIGRvQ3NzIGZvciBhcnJheT1cIiwgQUNMVXRpbHMuZmxhZ1RleHQsIGFycik7XHJcbiAgICAgIGFyci5mb3JFYWNoKChhKSA9PiB7XHJcbiAgICAgICAgaWYgKE5vZGVMaXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGEpKSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBqaiA9IDA7IGpqIDwgYS5sZW5ndGg7IGpqKyspIHtcclxuICAgICAgICAgICAgX2RvQ3NzKGFbampdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBfZG9Dc3MoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGljIGdldFNoYWRvd1Jvb3QoY29udGV4dCkge1xyXG4gICAgbGV0IHJvb3Q7XHJcbiAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICBpZiAoY29udGV4dC5zaGFkb3dSb290KVxyXG4gICAgICAgIHJvb3QgPSBjb250ZXh0LnNoYWRvd1Jvb3Q7XHJcbiAgICAgIGVsc2UgaWYgKGNvbnRleHQuZWwgJiYgY29udGV4dC5lbC5zaGFkb3dSb290KVxyXG4gICAgICAgIHJvb3QgPSBjb250ZXh0LmVsLnNoYWRvd1Jvb3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoIXJvb3QpIHtcclxuICAgICAgQUNMVXRpbHMuX3Jvb3RDb3VudGVyKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm9vdDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogcXVlcnlFbGVtZW50IC0gdGhpcyBxdWVyeSBzZWFyY2hlcyB0aGUgc2hhZG93IGRvbSBvZiB0aGUgY29tcG9uZW50IChpZiBhdmFpbGFibGUpIGZvclxyXG4gICAqIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IChjb250ZXh0ID0gdGhpcylcclxuICAgKlxyXG4gICAqIE5PVEU6IFRoZXNlIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgYmUgZXhlY3V0ZWQgd2l0aCAnY2FsbCgpJyB0byBwYXNzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50XHJcbiAgICpcclxuICAgKiAgLSBxdWVyeTogIHN0YW5kYXJkIENTUyBzZWxlY3RvclxyXG4gICAqICAtIGVsZW06IChvcHRpb25hbCkgSWYgbm90IHNwZWNpZmllZCwgdGhlIHNoYWRvdyBkb20gdXNlZCBpcyB0aGlzIGNvbXBvbmVudCdzIHNoYWRvdyBkb20uXHJcbiAgICogICAgICAgICAgICAgICAgICAgICBJZiBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgc2hhZG93IGRvbSBvZiB0aGUgZWxlbWVudCBwYXNzZWQgaW5cclxuICAgKi9cclxuICBzdGF0aWMgcXVlcnlFbGVtZW50KHF1ZXJ5LCBlbGVtKSB7XHJcbiAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICBsZXQgcmVzdWx0LCBzdWJSb290O1xyXG4gICAgaWYgKCFxdWVyeSB8fCAhQUNMVXRpbHMuaGFzVGV4dChxdWVyeSkpIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJvb3QgPSBBQ0xVdGlscy5nZXRTaGFkb3dSb290KHNlbGYpO1xyXG4gICAgZnVuY3Rpb24gX2NoZWNrUm9vdCgpIHtcclxuICAgICAgbGV0IHY7XHJcbiAgICAgIGlmIChyb290KVxyXG4gICAgICAgIHYgPSByb290LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xyXG4gICAgICBpZiAoIXYpXHJcbiAgICAgICAgdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xyXG4gICAgICByZXR1cm4gdjtcclxuICAgIH1cclxuICAgIGlmIChlbGVtKSB7XHJcbiAgICAgIHN1YlJvb3QgPSBBQ0xVdGlscy5nZXRTaGFkb3dSb290KGVsZW0pO1xyXG4gICAgICBpZiAoc3ViUm9vdClcclxuICAgICAgICByZXN1bHQgPSBzdWJSb290LnF1ZXJ5U2VsZWN0b3IocXVlcnkpO1xyXG4gICAgICBpZiAoIXJlc3VsdClcclxuICAgICAgICByZXN1bHQgPSBfY2hlY2tSb290KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmVzdWx0ID0gX2NoZWNrUm9vdCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgciA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIiVjUXVlcnlFbGVtZW50IGZpbmFsIHJldHVybj1cIiwgKHJlc3VsdCkgPyBBQ0xVdGlscy5ncmVlblRleHQgOiBBQ0xVdGlscy5mbGFnVGV4dCwgcik7XHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcbiAgLy8gcXVlcnkgdGhlIHNoYWRvdyBkb20gb2YgdGhlIGNvbXBvbmVudCBmb3IgYWxsIG1hdGNoaW5nIGVsZW1lbnRzIChjb250ZXh0ID0gdGhpcylcclxuICAvLyB1c2UgdGhpcyBkb2luZyBhICdjYWxsJyB3aXRoIHRoZSB0b3AgZWxlbWVudCB3aG9zZSBzaGFkb3cgZG9tIHdpbGwgYmUgc2VhcmNoZWRcclxuICAvLyBzdGF0aWMgcXVlcnlFbGVtZW50QWxsKHF1ZXJ5OiBzdHJpbmcsIGVsZW0/OiBhbnkpOiBIVE1MRWxlbWVudCB7XHJcbiAgLy8gICAvLyBpZiAoQUNMVXRpbHMuX3ZlcmJvc2UpIGNvbnNvbGUubG9nKFwiJWMgcXVlcnlFbGVtZW50QWxsKFwiK3F1ZXJ5KycsJytlbGVtKycpJywgJ2NvbG9yOnJlZCcpO1xyXG4gIC8vICAgbGV0IHNlbGY6IGFueSA9IHRoaXM7XHJcbiAgLy8gICBsZXQgcmVzdWx0OiBhbnksIHN1YlJvb3Q6YW55O1xyXG4gIC8vICAgY29uc3Qgcm9vdDphbnkgPSBBQ0xVdGlscy5nZXRTaGFkb3dSb290KHNlbGYpO1xyXG4gIC8vICAgLy8gaWYgKEFDTFV0aWxzLl92ZXJib3NlKSBjb25zb2xlLmxvZygnJWMgcXVlcnlFbGVtZW50QWxsIHNlbGY9JywgJ2NvbG9yOnJlZCcsIHNlbGYpO1xyXG4gIC8vICAgZnVuY3Rpb24gX2NoZWNrUm9vdCgpIHtcclxuICAvLyAgICAgbGV0IHY7XHJcbiAgLy8gICAgIC8vIGlmIChBQ0xVdGlscy5fdmVyYm9zZSkgY29uc29sZS5sb2coJyVjIHF1ZXJ5RWxlbWVudEFsbCB1c2luZyBzaGFkb3c9JywgJ2NvbG9yOnJlZCcsIHJvb3QpO1xyXG4gIC8vICAgICBpZiAocm9vdCkge1xyXG4gIC8vICAgICAgIHYgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpXHJcbiAgLy8gICAgICAgLy8gaWYgKEFDTFV0aWxzLl92ZXJib3NlKSBjb25zb2xlLmxvZyhcIiVjIHF1ZXJ5RWxlbWVudEFsbCAtcXVlcmllZCBzaGFkb3cgZm9yIFwiK3F1ZXJ5LCAnY29sb3I6cmVkJywgdik7XHJcbiAgLy8gICAgIH1cclxuICAvLyAgICAgaWYgKCF2KVxyXG4gIC8vICAgICAgIHYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcclxuICAvLyAgICAgcmV0dXJuIHY7XHJcbiAgLy8gICB9XHJcbiAgLy8gICBpZiAoZWxlbSkge1xyXG4gIC8vICAgICBzdWJSb290ID0gQUNMVXRpbHMuZ2V0U2hhZG93Um9vdChlbGVtKTtcclxuICAvLyAgICAgaWYgKHN1YlJvb3QpXHJcbiAgLy8gICAgICAgcmVzdWx0ID0gc3ViUm9vdC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcclxuICAvLyAgICAgaWYgKCFyZXN1bHQpXHJcbiAgLy8gICAgICAgcmVzdWx0ID0gX2NoZWNrUm9vdCgpO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgZWxzZSB7XHJcbiAgLy8gICAgIHJlc3VsdCA9IF9jaGVja1Jvb3QoKTtcclxuICAvLyAgIH1cclxuICAvLyAgIGNvbnN0IHIgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xyXG4gIC8vICAgLy8gY29uc29sZS5sb2coXCIlY1F1ZXJ5RWxlbWVudEFsbCBmaW5hbCByZXR1cm49XCIsIChyZXN1bHQpID8gQUNMVXRpbHMuZ3JlZW5UZXh0IDogQUNMVXRpbHMuZmxhZ1RleHQsIHIpO1xyXG4gIC8vICAgcmV0dXJuIHI7XHJcbiAgLy8gfVxyXG4gIHN0YXRpYyBxdWVyeUVsZW1lbnRBbGwocXVlcnksIGVsZW0pIHtcclxuICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IGFsbFJlc3VsdHMgPSBbXTtcclxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZVF1ZXJ5U2hhZG93KHJvb3QpIHtcclxuICAgICAgY29uc3QgcmVzdWx0cyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbChxdWVyeSk7XHJcbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XHJcbiAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IEFDTFV0aWxzLmdldFNoYWRvd1Jvb3QocmVzdWx0KTtcclxuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgcmVjdXJzaXZlUXVlcnlTaGFkb3coc2hhZG93Um9vdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChlbGVtKSB7XHJcbiAgICAgIGNvbnN0IHN1YlJvb3QgPSBBQ0xVdGlscy5nZXRTaGFkb3dSb290KGVsZW0pO1xyXG4gICAgICBpZiAoc3ViUm9vdCkge1xyXG4gICAgICAgIHJlY3Vyc2l2ZVF1ZXJ5U2hhZG93KHN1YlJvb3QpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJlY3Vyc2l2ZVF1ZXJ5U2hhZG93KGVsZW0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3QgcHJpbWFyeVJvb3QgPSBBQ0xVdGlscy5nZXRTaGFkb3dSb290KHNlbGYpIHx8IGRvY3VtZW50O1xyXG4gICAgICByZWN1cnNpdmVRdWVyeVNoYWRvdyhwcmltYXJ5Um9vdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWxsUmVzdWx0cztcclxuICB9XHJcbiAgLy8gcXVlcnkgdGhlIHNoYWRvdyBkb20gb2YgdGhlIGNvbXBvbmVudCBmb3IgdGhlIG1hdGNoaW5nIGVsZW1lbnQgKGNvbnRleHQgPSB0aGlzKVxyXG4gIHN0YXRpYyBxdWVyeUVsZW1lbnRCeUlkKGlkKSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgaWYgKCFpZCB8fCAhQUNMVXRpbHMuaGFzVGV4dChpZCkpIHtcclxuICAgICAgY29uc29sZS5sb2coJyVjIEVycm9yOiBxdWVyeUVsZW1lbnRCeUlkIGludm9rZWQgd2l0aCBpbnZhbGlkIGlkJywgJ2NvbG9yOnJlZDtmb250LXNpemU7OHB0Jyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmVzdWx0ID0gQUNMVXRpbHMucXVlcnlFbGVtZW50LmNhbGwodGhpcywgQUNMVXRpbHMuZml4SWQoaWQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIC8qXHJcblxyXG4qIEFDTCBUaGVtZSBjb250YWlucyB0aGUgZm9sbG93aW5nOlxyXG4qIHtcclxuKiBiYWNrZ3JvdW5kOiA8bWFpbiBiYWNrZ3JvdW5kIGNvbG9yIGluIHRoZSBoZXgvYWxwaGEgZm9ybWF0ICNmZmUwZTBlMD4gZGVmYXVsdD0jZmZmXHJcbiogdGV4dDogPG1haW4gdGV4dCBjb2xvciBpbiB0aGUgaGV4IGZvcm1hdCAjZTBlMGUwPiBkZWZhdWx0PSAjMzMzXHJcbiogZGFya0JhY2tncm91bmQ6IDxtYWluIGJhY2tncm91bmQgd2hlbiBpbiBkYXJrIG1vZGUgaW4gaGV4IGZvcm1hdD4gZGVmYXVsdD0jMjUyNTI2XHJcbiogZGFya1RleHQ6IDxtYWluIHRleHQgY29sb3Igd2hlbiBpbiBkYXJrIG1vZGUgaW4gaGV4PiBkZWZhdWx0PSNDNUM1QzVcclxuKiBoZWFkZXJCYWNrZ3JvdW5kOiA8bWFpbiBoZWFkZXIgYmFja2dyb3VuZCBjb2xvciAoaWYgYXBwbGllcyk+IGRlZmF1bHQ9ICMyQzc4RDRcclxuKiBoZWFkZXJUZXh0OiA8bWFpbiBoZWFkZXIgdGV4dCBjb2xvciAoaWYgYXBwbGllcyk+IGRlZmF1bHQ9ICNmZmZcclxuKiBkaXNwbGF5SGVhZGVyOiA8IHZpc2liaWxpdHkgaXMgdHJ1ZSBvciBmYWxzZT4gZGVmYXVsdD0gdHJ1ZVxyXG4qIGRpc3BsYXlEYXJrTW9kZTogPCBkYXJrIG1vZGUgaXMgdHJ1ZSBvciBmYWxzZT4gZGVmYXVsdD0gZmFsc2VcclxuKiB9XHJcbipcclxuKiBwYXJzZVRoZW1lU3RyaW5nIC0gZXhwZWN0cyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRoZW1lIG9iamVjdC4gUGFyc2VzIHRoZSBzdHJpbmcgYW5kIHZhbGlkYXRlcy5cclxuKlxyXG4qIHJldHVybiA9IFRoZW1lIG9iamVjdFxyXG4qL1xyXG4gIHN0YXRpYyBwYXJzZVRoZW1lU3RyaW5nKHMpIHtcclxuICAgIGlmICh0aGlzLmhhc1RleHQocykpIHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uocyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIHt9OyAvLyBubyB0aGVtZVxyXG4gICAgfVxyXG4gIH1cclxuICBzdGF0aWMgcGFyc2VCdWZmZXJTaXplcyhzKSB7XHJcbiAgICBpZiAodHlwZW9mIHMgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBbMV07XHJcbiAgICB9XHJcbiAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodGhpcy5oYXNUZXh0KHMpKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IHMuc3BsaXQoJywnKTtcclxuICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgYXJyLmxlbmd0aDsgaWkrKykge1xyXG4gICAgICAgICAgaWYgKGlpID49IDMpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgbGV0IHYgPSBwYXJzZUZsb2F0KGFycltpaV0pO1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2godik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbMV07IC8vIGRlZmF1bHQgdG8gMSB1bml0XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChleCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhleCk7XHJcbiAgICAgIHJldHVybiBbMV07IC8vIGRlZmF1bHQgdG8gMSB1bml0XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufVxyXG5BQ0xVdGlscy5WRVJTSU9OID0gJzEuMi4xOTQnO1xyXG5BQ0xVdGlscy5oYXNBbm5vdW5jZWQgPSBmYWxzZTtcclxuQUNMVXRpbHMuX3ZlcmJvc2UgPSBmYWxzZTtcclxuQUNMVXRpbHMuX3Jvb3RDb3VudGVyID0gMDtcclxuQUNMVXRpbHMubm90ZVN0eWxlID0gJ2JhY2tncm91bmQtY29sb3I6I2UxZWJkNDtjb2xvcjojMjIyO3BhZGRpbmc6M3B4O2JvcmRlci1yYWRpdXM6MnB4Oyc7XHJcbkFDTFV0aWxzLmVycm9yU3R5bGUgPSAnYmFja2dyb3VuZC1jb2xvcjpyZWQ7Y29sb3I6d2hpdGU7cGFkZGluZzo0cHg7Ym9yZGVyLXJhZGl1czozcHgnO1xyXG5BQ0xVdGlscy5ncmF5U3R5bGUgPSAnYmFja2dyb3VuZC1jb2xvcjojNzg5MGFkO2NvbG9yOiM0NDQ7cGFkZGluZzozcHg7Ym9yZGVyLXJhZGl1czoycHg7JztcclxuQUNMVXRpbHMuZmxhZ1N0eWxlID0gJ2JhY2tncm91bmQtY29sb3I6eWVsbG93O2NvbG9yOiMwMDA7cGFkZGluZzo1cHg7Ym9yZGVyLXJhZGl1czoycHg7JztcclxuQUNMVXRpbHMuYmx1ZVN0eWxlID0gJ2JhY2tncm91bmQtY29sb3I6Ymx1ZTtjb2xvcjojZWVlO3BhZGRpbmc6MXB4IDVweDtib3JkZXItcmFkaXVzOjJweDsnO1xyXG5BQ0xVdGlscy5mbGFnVGV4dCA9ICdjb2xvcjp5ZWxsb3c7JztcclxuQUNMVXRpbHMuYmx1ZVRleHQgPSAnY29sb3I6IzRkODhmZjsnO1xyXG5BQ0xVdGlscy5ncmVlblRleHQgPSAnY29sb3I6IzI3NzcxMTsnO1xuXG52YXIgVGhlbWVUeXBlO1xyXG4oZnVuY3Rpb24gKFRoZW1lVHlwZSkge1xyXG4gIFRoZW1lVHlwZVtUaGVtZVR5cGVbXCJsaWdodFwiXSA9IDFdID0gXCJsaWdodFwiO1xyXG4gIFRoZW1lVHlwZVtUaGVtZVR5cGVbXCJkYXJrXCJdID0gMl0gPSBcImRhcmtcIjtcclxufSkoVGhlbWVUeXBlIHx8IChUaGVtZVR5cGUgPSB7fSkpO1xyXG4vLyBTaW5jZSBTdGVuY2lsIENvbXBvbmVudHMgZG9uJ3QgYWxsb3cgZXh0ZW5kaW5nIGJhc2UgY2xhc3NlcywgdGhpc1xyXG4vLyBjbGFzcyB3aWxsIHN0YW5kLWluIGFzIGEgd2F5IHRvIHByb3ZpZGUgY29tbW9uIGZ1bmN0aW9uYWxpdHkgYWNyb3NzXHJcbi8vIGFsbCBjb21wb25lbnRzIHdpdGhvdXQgZHVwbGljYXRlZCBjb2RlIGluIGVhY2ggY29tcG9uZW50LlxyXG4vL1xyXG5jbGFzcyBCYXNlVXRpbCB7XHJcbiAgLy8gUHJvdmlkZSBzdGVuY2lsIGNvbXBvbmVudCBpbnN0YW5jZSBhcyBjb250ZXh0XHJcbiAgY29uc3RydWN0b3IobmFtZSwgY29udGV4dCwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX2RiZyA9IGZhbHNlO1xyXG4gICAgLy8gZGVmYXVsdCBjb2xvcnNcclxuICAgIHRoaXMuZGVmYXVsdENvbG9ycyA9IHtcclxuICAgICAgYnJhbmQ6ICcjMDA3YWMyJyxcclxuICAgICAgYnJhbmRIb3ZlcjogJyMwMDYxOWInLFxyXG4gICAgICBicmFuZFByZXNzOiAnIzAwNDg3NCcsXHJcbiAgICAgIGJhY2tncm91bmQ6ICcjZjhmOGY4JyxcclxuICAgICAgZm9yZWdyb3VuZDogJyNmZmZmZmYnLFxyXG4gICAgICB0ZXh0OiAnIzE1MTUxNScsXHJcbiAgICAgIHRleHRJbnZlcnNlOiAnI2ZmZmZmZicsXHJcbiAgICAgIGJvcmRlcjogJyNjYWNhY2EnLFxyXG4gICAgICBzY3JvbGxiYXI6ICcjMjMyMzIzJyxcclxuICAgICAgc2Nyb2xsYmFyQkc6ICcjZmZmZmZmJ1xyXG4gICAgfTtcclxuICAgIHRoaXMuX3N1YkNvbXBvbmVudHMgPSB7fTtcclxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuX2NvbnRleHQudGhlbWUpIHtcclxuICAgICAgdGhpcy5fY29udGV4dC50aGVtZSA9IFRoZW1lVHlwZS5saWdodDtcclxuICAgIH1cclxuICAgIC8vdGhpcy5fY29sb3IgPSB7IHByaW1hcnk6IFwiI2ZmZlwiLCBzZWNvbmRhcnk6IFwiIzAwMFwiLCB0ZXh0OiBcImJsdWVcIiwgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLCBmb3JlZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIgfTtcclxuICAgIHRoaXMuX3RoZW1lID0gVGhlbWVUeXBlLmxpZ2h0O1xyXG4gICAgdGhpcy5yZXNldENvbmZpZygpO1xyXG4gICAgdGhpcy5jb25maWdJbnN0YW5jZUlkID0gQmFzZVV0aWwucmVnaXN0ZXJDb21wb25lbnQobmFtZSwgdGhpcyk7XHJcbiAgICB0aGlzLnVwZGF0ZUxvY2FsZVNldHRpbmdzKCk7XHJcbiAgfVxyXG4gIHN0YXRpYyByZWdpc3RlckNvbXBvbmVudChuYW1lLCBjb25maWcpIHtcclxuICAgIGNvbnN0IGlkID0gQmFzZVV0aWwuX2dldFVuaXF1ZU5hbWUobmFtZSk7XHJcbiAgICBCYXNlVXRpbC5Db21wb25lbnRSZWdpc3RyeVtpZF0gPSBjb25maWc7XHJcbiAgICByZXR1cm4gaWQ7XHJcbiAgfVxyXG4gIHN0YXRpYyBfZ2V0VW5pcXVlTmFtZShuYW1lKSB7IHJldHVybiBuYW1lICsgJy0nICsgQmFzZVV0aWwuX2NvbXBvbmVudEluZGV4Kys7IH1cclxuICAvL1xyXG4gIGhhc1N1YkNvbXBvbmVudHMoKSB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fc3ViQ29tcG9uZW50cyk7XHJcbiAgICBjb25zdCB2ID0gKGtleXMgJiYga2V5cy5sZW5ndGggPiAwKTtcclxuICAgIHJldHVybiB2O1xyXG4gIH1cclxuICBhZGRUb1BhcmVudChwYXJlbnRJZCkge1xyXG4gICAgaWYgKHBhcmVudElkKSB7XHJcbiAgICAgIC8vIFJlZ2lzdGVyIG15c2VsZiB3aXRoIG15IHBhcmVudCBjb25maWdcclxuICAgICAgY29uc3QgcGFyZW50Q2ZnID0gQmFzZVV0aWwuQ29tcG9uZW50UmVnaXN0cnlbcGFyZW50SWRdO1xyXG4gICAgICBpZiAocGFyZW50Q2ZnKSB7XHJcbiAgICAgICAgcGFyZW50Q2ZnLmFkZFN1YkNvbXBvbmVudCh0aGlzLmNvbmZpZ0luc3RhbmNlSWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFkZFN1YkNvbXBvbmVudChpZCkge1xyXG4gICAgdGhpcy5fc3ViQ29tcG9uZW50c1tpZF0gPSB0cnVlO1xyXG4gICAgLy90aGlzLnVwZGF0ZVN1YmNvbXBvbmVudENvbmZpZ3MoKVxyXG4gIH1cclxuICByZXNldENvbmZpZygpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XHJcbiAgICAgIGlkOiAnJyxcclxuICAgICAgZW52OiAnZW4tdXMnLFxyXG4gICAgICBnZW9lbnJpY2htZW50VXJsOiBudWxsLFxyXG4gICAgICB1c2VybmFtZTogbnVsbCxcclxuICAgICAgdG9rZW46IG51bGwsXHJcbiAgICAgIGxhbmdDb2RlOiAnZW4tdXMnLFxyXG4gICAgICB0aGVtZTogVGhlbWVUeXBlLmxpZ2h0XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgIGlkOiAnJyxcclxuICAgICAgZW52OiAnZW4tdXMnLFxyXG4gICAgICBnZW9lbnJpY2htZW50VXJsOiBudWxsLFxyXG4gICAgICB1c2VybmFtZTogbnVsbCxcclxuICAgICAgdG9rZW46IG51bGwsXHJcbiAgICAgIGxhbmdDb2RlOiAnZW4tdXMnLFxyXG4gICAgICB0aGVtZTogVGhlbWVUeXBlLmxpZ2h0XHJcbiAgICB9O1xyXG4gICAgdGhpcy51cGRhdGVDb25maWcoZGVmYXVsdENvbmZpZywgbnVsbCk7XHJcbiAgfVxyXG4gIC8qXHJcbiAgICogdXBkYXRlTG9jYWxlU2V0dGluZ3NcclxuICAgKlxyXG4gICAqIHVzZSB0aGlzIHRvIHVwZGF0ZSBhbnkgbG9jYWxlIHNldHRpbmcsIG9yIHRvIHJldmVydCB0byBkZWZhdWx0c1xyXG4gICAqICAgIG9iaiA9IG51bGwgb3IgdW5kZWZpbmVkOiByZXNldCB0byBkZWZhdWx0c1xyXG4gICAqICAgIG90aGVyd2lzZSA+PiBvYmogcHJvcGVydGllcyB3aWxsIG92ZXJ3cml0ZSBleGl0aW5nIHByb3BlcnRpZXMuICBBbGwgb3RoZXJcclxuICAgKiAgICBwcm9wZXJ0aWVzIHdpbGwgcmVtYWluIGFzIHRoZXkgd2VyZVxyXG4gICAqL1xyXG4gIHVwZGF0ZUxvY2FsZVNldHRpbmdzKG9iaikge1xyXG4gICAgaWYgKCF0aGlzLl9sb2NhbGVTZXR0aW5ncyB8fCAhb2JqKSB7XHJcbiAgICAgIC8vIGRlZmF1bHRzXHJcbiAgICAgIHRoaXMuX2xvY2FsZVNldHRpbmdzID0ge1xyXG4gICAgICAgIGxhbmd1YWdlOiAnZW4tVVMnLFxyXG4gICAgICAgIGNvdW50cnk6ICdVUycsXHJcbiAgICAgICAgbG9jYXRpb246ICctMTE3LjE5NiwzNC4wNTYnLFxyXG4gICAgICAgIGdlb2NvZGVPdXRGaWVsZHM6ICdTdWJyZWdpb24sUmVnaW9uLFBsYWNlTmFtZSxNYXRjaF9hZGRyLENvdW50cnksQWRkcl90eXBlLENpdHksUGxhY2VfYWRkcixQaG9uZSxVUkwnXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3Qga2V5cyA9IEFDTFV0aWxzLmdldEtleXMob2JqKTtcclxuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGtleXMubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgbGV0IGsgPSBrZXlzW2lpXTtcclxuICAgICAgICBpZiAoQUNMVXRpbHMuaGFzVGV4dChrKSkge1xyXG4gICAgICAgICAgdGhpcy5fbG9jYWxlU2V0dGluZ3Nba10gPSBvYmpba107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN5bmNDb25maWdGcm9tUHJvcHMoKSB7XHJcbiAgICAvLyBkb2VzIG5vdGhpbmcgYXQgdGhpcyBwb2ludFxyXG4gIH1cclxuICAvLyBTZXRzIHRoZW1lIHRvIGRhcmsgb3IgbGlnaHRcclxuICAvL1xyXG4gIC8vICAgIHRoZW1lVHlwZSA9IDEgICBzdGFuZGFyZCBjYWxjaXRlIGxpZ2h0IHRoZW1lIChkZWZhdWx0KVxyXG4gIC8vICAgICAgICAgICAgICA9IDIgICBkYXJrIHRoZW1lXHJcbiAgLy9cclxuICBzZXRUaGVtZSh0aGVtZVR5cGUgPSAxLCB1cGRhdGVDb21wb25lbnRQcm9wKSB7XHJcbiAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgIGNvbnN0IG93bmVyID0gc2VsZi5fY29udGV4dDtcclxuICAgIC8vIGFzc2lnbiB0aGVtZSBQcm9wIHRvIFRoZW1lVHlwZVxyXG4gICAgbGV0IHQgPSBUaGVtZVR5cGUubGlnaHQ7XHJcbiAgICBzd2l0Y2ggKHRoZW1lVHlwZSkge1xyXG4gICAgICBjYXNlIChUaGVtZVR5cGUubGlnaHQpOlxyXG4gICAgICBjYXNlICgnbGlnaHQnKTpcclxuICAgICAgY2FzZSAoJzEnKTpcclxuICAgICAgY2FzZSAoMSk6IHtcclxuICAgICAgICB0ID0gVGhlbWVUeXBlLmxpZ2h0O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgKFRoZW1lVHlwZS5kYXJrKTpcclxuICAgICAgY2FzZSAoJzInKTpcclxuICAgICAgY2FzZSAoMik6XHJcbiAgICAgIGNhc2UgKCdkYXJrJyk6IHtcclxuICAgICAgICB0ID0gVGhlbWVUeXBlLmRhcms7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgZGVmYXVsdDogdCA9IFRoZW1lVHlwZS5saWdodDtcclxuICAgIH1cclxuICAgIGlmICh1cGRhdGVDb21wb25lbnRQcm9wKSB7XHJcbiAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnQgdGhlbWUgUHJvcFxyXG4gICAgICBvd25lci50aGVtZSA9IHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIHVwZGF0ZVN1YmNvbXBvbmVudENvbmZpZ3MoKSB7XHJcbiAgICBpZiAodGhpcy5fZGJnKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCclYyBDT05GSUcgdXBkYXRpbmcgc3VicycsICdjb2xvcjpvcmFuZ2U7Zm9udC1zaXplOjExcHQnLCB0aGlzLl9zdWJDb21wb25lbnRzKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9zdWJDb21wb25lbnRzKSB7XHJcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9zdWJDb21wb25lbnRzKTtcclxuICAgICAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGtleXMubGVuZ3RoOyBpaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBzdWJJZCA9IGtleXNbaWldO1xyXG4gICAgICAgICAgLy8gbG9vayB1cCBjb25maWcgaW4gZ2xvYmFsIHJlZ2lzdHJ5XHJcbiAgICAgICAgICBjb25zdCBjb25maWcgPSBCYXNlVXRpbC5Db21wb25lbnRSZWdpc3RyeVtzdWJJZF07XHJcbiAgICAgICAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy51cGRhdGVDb25maWcodGhpcy5jb25maWcsIG51bGwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyBiYXNlLXV0aWwgZnVuY3Rpb24gdG8gdHJpZ2dlciBjb21wb25lbnQncyByZWdpc3RlcmVkIGNhbGxiYWNrIChub3JtYWxseSBpcyBvblVwZGF0ZVVJKVxyXG4gIG9uQ29tcG9uZW50SGFzUmVuZGVyZWQoKSB7XHJcbiAgICBpZiAodGhpcy5fdXBkYXRlQ2FsbGJhY2sgJiYgdGhpcy5fY29udGV4dD8uZWwpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLl91cGRhdGVDYWxsYmFjay5jYWxsKHRoaXMuX2NvbnRleHQpO1xyXG4gICAgICB9XHJcbiAgICAgIGNhdGNoIChleCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdvbkNvbXBvbmVudEhhc1JlbmRlcmVkIGVycm9yJywgZXgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGNoZWNrcyBvYmplY3QgZm9yIHJlcXVpcmVkIGNvbG9ycywgYW5kIHNldHMgZGVmYXVsdHMgd2hlcmUgbmVlZGVkXHJcbiAgX3ZhbGlkYXRlQ29sb3JzKGV4aXN0aW5nLCBwcm9wb3NlZENvbG9ycykge1xyXG4gICAgLy8gYXBwbHkgZGVmYXVsdCB0byBlbXB0eSBvYmpcclxuICAgIGlmICghZXhpc3RpbmcpIHtcclxuICAgICAgZXhpc3RpbmcgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluY29taW5nID0gcHJvcG9zZWRDb2xvcnMgfHwge307XHJcbiAgICAvLyBBcHBseSBkZWZhdWx0IGNvbG9yc1xyXG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbih0aGlzLmRlZmF1bHRDb2xvcnMsIGV4aXN0aW5nLCBpbmNvbWluZyk7XHJcbiAgICAvLyBSZW1vZGUgdW5kZWZpbmVkIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IG1LZXlzID0gQUNMVXRpbHMuZ2V0S2V5cyhtZXJnZWQpO1xyXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IG1LZXlzLmxlbmd0aDsgaWkrKykge1xyXG4gICAgICBsZXQgayA9IG1LZXlzW2lpXTtcclxuICAgICAgaWYgKCFtZXJnZWRba10pIHtcclxuICAgICAgICBkZWxldGUgbWVyZ2VkW2tdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgb2JqZWN0XHJcbiAgICByZXR1cm4gbWVyZ2VkO1xyXG4gIH1cclxuICAvKiB1cGRhdGVDb25maWdcclxuICAgKiAgQ2FsbCB0aGlzIHdoZW4gdGhlIGNvbXBvbmVudCBjb25maWcgY2hhbmdlcy4gIEl0IHdpbGwgdXBkYXRlIGVzc2VudGlhbCBQcm9wcyxcclxuICAgKiAgYW5kIHJldHVybiBhIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCBjaGFuZ2VkLiAgQ2hhbmdlcyBvdmVyd3JpdGUgcHJvcGVydGllcywgYnV0XHJcbiAgICogIGxlYXZlIG90aGVyIHByb3BlcnRpZXMgaW4gdGhlIGNvbmZpZyBhcy1pcyAodW5jaGFuZ2VkKVxyXG4gICAqXHJcbiAgICogY29uZmlncyBhcmUgcGFzc2VkIGluIGFzIG9iamVjdHMgKG5vdCBzdHJpbmdzKVxyXG4gICAqL1xyXG4gIHVwZGF0ZUNvbmZpZyhuZXdDb25maWcsIG9sZENvbmZpZykge1xyXG4gICAgaWYgKHRoaXMuX2RiZykge1xyXG4gICAgICBjb25zb2xlLmxvZygnJWMgQ09ORklHIHVwZGF0ZScsICdjb2xvcjp5ZWxsb3c7Zm9udC1zaXplOjExcHQnLCB0aGlzLl9jb250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9kYmcpIHtcclxuICAgICAgY29uc29sZS5sb2coJyVjIENPTkZJRyB1cGRhdGUgcnVubmluZyBmb3IgSUQ9JywgJ2NvbG9yOnllbGxvdztmb250LXNpemU6MTFwdCcsIHRoaXMuY29uZmlnSW5zdGFuY2VJZCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGFuZ2VkS2V5cyA9IFtdO1xyXG4gICAgaWYgKCFuZXdDb25maWcgfHwgQUNMVXRpbHMuZ2V0S2V5cyhuZXdDb25maWcpLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgIHJldHVybiBjaGFuZ2VkS2V5cztcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgY29uc3Qgb3duZXIgPSBzZWxmLl9jb250ZXh0O1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gY3JlYXRlIGEgY29weSBvZiB0aGUgY3VycmVudCBjb25maWcgYW5kIHJldHVybiBhIGxpc3Qgb2Ygd2hhdCBoYXMgY2hhbmdlZFxyXG4gICAgICAvLyBmaW5kIHRoZSBuZXdDb25maWcgQ0hBTkdFU1xyXG4gICAgICBjb25zdCBuZXdLZXlzID0gQUNMVXRpbHMuZ2V0S2V5cyhuZXdDb25maWcpO1xyXG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbmV3S2V5cy5sZW5ndGg7IGlpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXdLZXlzW2lpXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKG5ld0NvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmICghb2xkQ29uZmlnICYmIGtleSAhPSAnY29sb3JzJykge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q29uZmlnW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PSAnY29sb3JzJykge1xyXG4gICAgICAgICAgICAgIGlmIChBQ0xVdGlscy5nZXRLZXlzKG5ld0NvbmZpZ1trZXldKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9sZENvbmZpZyB8fCAhb2xkQ29uZmlnLmNvbG9ycykge1xyXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VkS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgLy8gdGVzdCBpbmRpdmlkdWFsIHByb3BlcnRpZXMgYmVsb25naW5nIHRvIGNvbG9yc1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjb2xvcktleXMgPSBBQ0xVdGlscy5nZXRLZXlzKG5ld0NvbmZpZy5jb2xvcnMpO1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBrayA9IDA7IGtrIDwgY29sb3JLZXlzLmxlbmd0aDsga2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xvcktleSA9IGNvbG9yS2V5c1tra107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3JOYW1lID0gY29sb3JLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbmZpZy5jb2xvcnMuaGFzT3duUHJvcGVydHkoY29sb3JOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbmZpZy5jb2xvcnNbY29sb3JOYW1lXSAhPSBvbGRDb25maWcuY29sb3JzW2NvbG9yTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNoYW5nZWRLZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3Q29uZmlnW2tleV0gIT0gb2xkQ29uZmlnW2tleV0pIHtcclxuICAgICAgICAgICAgICBjaGFuZ2VkS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnYmFzZUNvbmZpZyBlcnJvcjonLCBleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9kYmcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnJWMgLi4uQ09ORklHIGNoYW5nZWQ9JywgJ2NvbG9yOnllbGxvdztmb250LXNpemU6MTFwdCcsIGNoYW5nZWRLZXlzKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBDT0xPUlNcclxuICAgICAgLy9cclxuICAgICAgLy8gTWFrZSBzdXJlIGNvbG9ycyBleGlzdHNcclxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5jb2xvcnMpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZy5jb2xvcnMgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhcHBseSBpbmNvbWluZyBjaGFuZ2VzIHRvIG91ciBjb2xvcnMgb2JqZWN0XHJcbiAgICAgIGlmIChjaGFuZ2VkS2V5cy5pbmNsdWRlcygnY29sb3JzJykpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZy5jb2xvcnMgPSB0aGlzLl92YWxpZGF0ZUNvbG9ycyh0aGlzLmNvbmZpZy5jb2xvcnMsIG5ld0NvbmZpZy5jb2xvcnMpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRIRU1FXHJcbiAgICAgIGlmIChjaGFuZ2VkS2V5cy5pbmNsdWRlcygndGhlbWUnKSkge1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWUobmV3Q29uZmlnLnRoZW1lKTtcclxuICAgICAgfVxyXG4gICAgICAvL1xyXG4gICAgICAvLyB1cGRhdGUgYmFzZS11dGlsIGNvbmZpZyBvYmplY3Qgd2l0aCBjaGFuZ2VzIChleGNlcHQgZm9yIGNvbG9ycyB3aGljaCBpcyBhbHJlYWR5IGRvbmUgYWJvdmUpXHJcbiAgICAgIGlmICghdGhpcy5jb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobGV0IGpqID0gMDsgamogPCBjaGFuZ2VkS2V5cy5sZW5ndGg7IGpqKyspIHtcclxuICAgICAgICBsZXQgayA9IGNoYW5nZWRLZXlzW2pqXTtcclxuICAgICAgICBpZiAoayAhPSAnY29sb3JzJykge1xyXG4gICAgICAgICAgdGhpcy5jb25maWdba10gPSBuZXdDb25maWdba107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIHN5bmMgb3duZXIgY29tcG9uZW50IHByb3BzIEBAIG1heSB0cmlnZ2VyIGVuZGxlc3MgbG9vcCBAQFxyXG4gICAgICAvLyBBVVRIRU5USUNBVElPTlxyXG4gICAgICBpZiAoY2hhbmdlZEtleXMuaW5jbHVkZXMoJ3VzZXJuYW1lJykpIHtcclxuICAgICAgICBvd25lci51c2VybmFtZSA9IG5ld0NvbmZpZy51c2VybmFtZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhbmdlZEtleXMuaW5jbHVkZXMoJ3Rva2VuJykpIHtcclxuICAgICAgICBvd25lci50b2tlbiA9IG5ld0NvbmZpZy50b2tlbjtcclxuICAgICAgfVxyXG4gICAgICAvL1xyXG4gICAgICAvLyBNSVNDXHJcbiAgICAgIGlmIChjaGFuZ2VkS2V5cy5pbmNsdWRlcygnZW52JykpIHtcclxuICAgICAgICBvd25lci5lbnYgPSBuZXdDb25maWcuZW52O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjaGFuZ2VkS2V5cy5pbmNsdWRlcygnZ2VvZW5yaWNobWVudFVybCcpKSB7XHJcbiAgICAgICAgb3duZXIuZ2VvZW5yaWNobWVudFVybCA9IG5ld0NvbmZpZy5nZW9lbnJpY2htZW50VXJsO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjaGFuZ2VkS2V5cy5pbmNsdWRlcygnbGFuZ0NvZGUnKSkge1xyXG4gICAgICAgIG93bmVyLmxhbmdDb2RlID0gbmV3Q29uZmlnLmxhbmdDb2RlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFVzZSBwYXNzZWQgaW4gbGFuZ0NvZGUgaWYgc2V0XHJcbiAgICAgIGlmIChjaGFuZ2VkS2V5cy5pbmNsdWRlcygnbGFuZ0NvZGUnKSkge1xyXG4gICAgICAgIGlmICghb3duZXIuX2xvY2FsZVNldHRpbmdzKSB7XHJcbiAgICAgICAgICBvd25lci5fbG9jYWxlU2V0dGluZ3MgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3duZXIuX2xvY2FsZVNldHRpbmdzLmxhbmd1YWdlID0gbmV3Q29uZmlnLmxhbmdDb2RlO1xyXG4gICAgICAgIG93bmVyLmxhbmdDb2RlID0gbmV3Q29uZmlnLmxhbmdDb2RlIHx8ICdlbi11cyc7XHJcbiAgICAgICAgQmFSZXBvcnRzTGFuZ3VhZ2UuX2luaXRpYWxpemUob3duZXIubGFuZ0NvZGUpO1xyXG4gICAgICAgIG93bmVyLnNldExvY2FsZVN0cmluZ3MoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhbmdlZEtleXMuaW5jbHVkZXMoJ3NvdXJjZUNvdW50cnknKSkge1xyXG4gICAgICAgIHRoaXMuY29uZmlnLnNvdXJjZUNvdW50cnkgPSBvd25lci5zb3VyY2VDb3VudHJ5ID0gbmV3Q29uZmlnLnNvdXJjZUNvdW50cnkgfHwgJ1VTJztcclxuICAgICAgfVxyXG4gICAgICBzZWxmLnVwZGF0ZVN1YmNvbXBvbmVudENvbmZpZ3MoKTtcclxuICAgICAgaWYgKG5ld0NvbmZpZy5fcGFyZW50Q29uZmlnSWQgJiYgY2hhbmdlZEtleXMuaW5jbHVkZXMoJ19wYXJlbnRDb25maWdJZCcpKSB7XHJcbiAgICAgICAgdGhpcy5hZGRUb1BhcmVudChuZXdDb25maWcuX3BhcmVudENvbmZpZ0lkKTtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLm9uQ29tcG9uZW50SGFzUmVuZGVyZWQoKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChleDIpIHtcclxuICAgICAgY29uc29sZS5sb2coJ3VwZGF0ZUNvbmZpZyBlcnJvcicsIGV4Mik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbmdlZEtleXM7XHJcbiAgfVxyXG4gIGdldENvbmZpZ1N0cmluZygpIHtcclxuICAgIGxldCBvYmogPSB7IC4uLnRoaXMuY29uZmlnLCBfcGFyZW50Q29uZmlnSWQ6IHRoaXMuY29uZmlnSW5zdGFuY2VJZCB9O1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgfVxyXG59XHJcbi8vIGluZGV4IG9mIGFsbCBzdWJjb21wb25lbnRzIHJlbGF0ZWQgdG8gYW55IGJhc2UtdXRpbCBpbnN0YW5jZVxyXG4vLyAgIHsgPHN1YmNvbXBvbmVudElkPjogPGNvbmZpZyByZWY+LCAuLi4gfVxyXG5CYXNlVXRpbC5Db21wb25lbnRSZWdpc3RyeSA9IHt9O1xyXG5CYXNlVXRpbC5fY29tcG9uZW50SW5kZXggPSAxO1xuXG5leHBvcnQgeyBCYXNlVXRpbCBhcyBCIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtdXRpbC1iN2RiNjlmMC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=