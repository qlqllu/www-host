"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-5fd423"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/calcite-color-picker.entry.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/calcite-color-picker.entry.js ***!
  \***********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calcite_color_picker: () => (/* binding */ ColorPicker)
/* harmony export */ });
/* harmony import */ var _index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index-4e647411.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-4e647411.js");
/* harmony import */ var _index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-56dd1c42.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-56dd1c42.js");
/* harmony import */ var _dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-f1ee4d04.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/dom-f1ee4d04.js");
/* harmony import */ var _utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils-a71d8ee9.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/utils-a71d8ee9.js");
/* harmony import */ var _interactive_29995522_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interactive-29995522.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/interactive-29995522.js");
/* harmony import */ var _key_b75491c4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./key-b75491c4.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/key-b75491c4.js");
/* harmony import */ var _loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./loadable-cc14d728.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/loadable-cc14d728.js");
/* harmony import */ var _locale_f7b2fbb0_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./locale-f7b2fbb0.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/locale-f7b2fbb0.js");
/* harmony import */ var _math_7efd987a_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math-7efd987a.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/math-7efd987a.js");
/* harmony import */ var _t9n_dc67ab96_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./t9n-dc67ab96.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/t9n-dc67ab96.js");
/* harmony import */ var _debounce_047e09f4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debounce-047e09f4.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/debounce-047e09f4.js");
















/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if ((0,_debounce_047e09f4_js__WEBPACK_IMPORTED_MODULE_0__.i)(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return (0,_debounce_047e09f4_js__WEBPACK_IMPORTED_MODULE_0__.d)(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const CSS = {
  container: "container",
  controlSection: "control-section",
  hexOptions: "color-hex-options",
  section: "section",
  header: "header",
  control: "control",
  splitSection: "section--split",
  colorModeContainer: "color-mode-container",
  colorMode: "color-mode",
  channels: "channels",
  channel: "channel",
  savedColors: "saved-colors",
  savedColorsSection: "saved-colors-section",
  saveColor: "save-color",
  deleteColor: "delete-color",
  savedColorsButtons: "saved-colors-buttons",
  headerHex: "header--hex",
  colorFieldAndSlider: "color-field-and-slider",
  colorFieldAndSliderInteractive: "color-field-and-slider--interactive",
  colorFieldAndSliderWrap: "color-field-and-slider-wrap",
  scope: "scope",
  hueScope: "scope--hue",
  colorFieldScope: "scope--color-field",
  savedColor: "saved-color"
};
const DEFAULT_COLOR = (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)("#007AC2");
const DEFAULT_STORAGE_KEY_PREFIX = "calcite-color-";
const RGB_LIMITS = {
  r: 255,
  g: 255,
  b: 255
};
const HSV_LIMITS = {
  h: 360,
  s: 100,
  v: 100
};
const DIMENSIONS = {
  s: {
    slider: {
      height: 10,
      width: 160
    },
    colorField: {
      height: 80,
      width: 160
    },
    thumb: {
      radius: 8
    }
  },
  m: {
    slider: {
      height: 14,
      width: 272
    },
    colorField: {
      height: 150,
      width: 272
    },
    thumb: {
      radius: 10
    }
  },
  l: {
    slider: {
      height: 16,
      width: 464
    },
    colorField: {
      height: 200,
      width: 464
    },
    thumb: {
      radius: 12
    }
  }
};

const colorPickerCss = "@keyframes in{0%{opacity:0}100%{opacity:1}}@keyframes in-down{0%{opacity:0;transform:translate3D(0, -5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-up{0%{opacity:0;transform:translate3D(0, 5px, 0)}100%{opacity:1;transform:translate3D(0, 0, 0)}}@keyframes in-scale{0%{opacity:0;transform:scale3D(0.95, 0.95, 1)}100%{opacity:1;transform:scale3D(1, 1, 1)}}:root{--calcite-animation-timing:calc(150ms * var(--calcite-internal-duration-factor));--calcite-internal-duration-factor:var(--calcite-duration-factor, 1);--calcite-internal-animation-timing-fast:calc(100ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-medium:calc(200ms * var(--calcite-internal-duration-factor));--calcite-internal-animation-timing-slow:calc(300ms * var(--calcite-internal-duration-factor))}.calcite-animate{opacity:0;animation-fill-mode:both;animation-duration:var(--calcite-animation-timing)}.calcite-animate__in{animation-name:in}.calcite-animate__in-down{animation-name:in-down}.calcite-animate__in-up{animation-name:in-up}.calcite-animate__in-scale{animation-name:in-scale}@media (prefers-reduced-motion: reduce){:root{--calcite-internal-duration-factor:0}}:root{--calcite-floating-ui-transition:var(--calcite-animation-timing);--calcite-floating-ui-z-index:600}:host([hidden]){display:none}:host([disabled]){pointer-events:none;cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-ui-opacity-disabled)}:host{display:inline-block;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}:host([scale=s]) .container{inline-size:160px}:host([scale=s]) .saved-colors{grid-template-columns:repeat(auto-fill, minmax(20px, 1fr))}:host([scale=s]) .channels{flex-direction:column}:host([scale=s]) .channel{inline-size:100%;margin-block-end:4px}:host([scale=s]) .channel:last-child{margin-block-end:0}:host([scale=m]) .container{inline-size:272px}:host([scale=l]) .header{padding-block-end:0px}:host([scale=l]){font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=l]) .container{inline-size:464px}:host([scale=l]) .color-field-and-slider{margin-block-end:-20px}:host([scale=l]) .section{padding-block:0 16px;padding-inline:16px}:host([scale=l]) .section:first-of-type{padding-block-start:16px}:host([scale=l]) .saved-colors{grid-template-columns:repeat(auto-fill, minmax(28px, 1fr));grid-gap:12px;padding-block-start:16px}:host([scale=l]) .control-section{flex-wrap:nowrap;align-items:baseline}:host([scale=l]) .control-section>:nth-child(2){margin-inline-start:12px}:host([scale=l]) .color-hex-options{display:flex;flex-shrink:1;flex-direction:column;justify-content:space-around;min-block-size:98px;inline-size:160px}:host([scale=l]) .color-mode-container{flex-shrink:3}.container{background-color:var(--calcite-ui-foreground-1);display:inline-block;border:1px solid var(--calcite-ui-border-1)}.color-field-and-slider-wrap{position:relative}.scope{pointer-events:none;position:absolute;font-size:var(--calcite-font-size--1);outline-color:transparent;outline-offset:14px}.scope:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:16px}.color-field-and-slider{margin-block-end:-16px;touch-action:none}.color-field-and-slider--interactive{cursor:pointer}.control-section{display:flex;flex-direction:row;flex-wrap:wrap}.section{padding-block:0 12px;padding-inline:12px}.section:first-of-type{padding-block-start:12px}.color-hex-options,.section--split{flex-grow:1}.header{display:flex;align-items:center;justify-content:space-between;padding-block-end:0.25rem;color:var(--calcite-ui-text-1)}.header--hex,.color-mode-container{padding-block-start:12px}.channels{display:flex;justify-content:space-between}.channel{inline-size:31%}.saved-colors{padding-block-start:12px;display:grid;grid-template-columns:repeat(auto-fill, minmax(24px, 1fr));grid-gap:8px;inline-size:100%}.saved-colors-buttons{display:flex}.saved-color{outline-offset:0;outline-color:transparent;cursor:pointer}.saved-color:focus{outline:2px solid var(--calcite-ui-brand);outline-offset:2px}.saved-color:hover{transition:outline-color var(--calcite-internal-animation-timing-fast) ease-in-out;outline:2px solid var(--calcite-ui-border-2);outline-offset:2px}";

const throttleFor60FpsInMs = 16;
const defaultValue = (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.n)(DEFAULT_COLOR.hex());
const defaultFormat = "auto";
const ColorPicker = class {
  constructor(hostRef) {
    (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.r)(this, hostRef);
    this.calciteColorPickerChange = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.c)(this, "calciteColorPickerChange", 6);
    this.calciteColorPickerInput = (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.c)(this, "calciteColorPickerInput", 6);
    this.colorFieldAndSliderHovered = false;
    this.hueThumbState = "idle";
    this.internalColorUpdateContext = null;
    this.mode = _utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.C.HEX;
    this.shiftKeyChannelAdjustment = 0;
    this.sliderThumbState = "idle";
    this.handleTabActivate = (event) => {
      this.channelMode = event.currentTarget.getAttribute("data-color-mode");
      this.updateChannelsFromColor(this.color);
    };
    this.handleColorFieldScopeKeyDown = (event) => {
      const { key } = event;
      const arrowKeyToXYOffset = {
        ArrowUp: { x: 0, y: -10 },
        ArrowRight: { x: 10, y: 0 },
        ArrowDown: { x: 0, y: 10 },
        ArrowLeft: { x: -10, y: 0 }
      };
      if (arrowKeyToXYOffset[key]) {
        event.preventDefault();
        this.scopeOrientation = key === "ArrowDown" || key === "ArrowUp" ? "vertical" : "horizontal";
        this.captureColorFieldColor(this.colorFieldScopeLeft + arrowKeyToXYOffset[key].x || 0, this.colorFieldScopeTop + arrowKeyToXYOffset[key].y || 0, false);
      }
    };
    this.handleHueScopeKeyDown = (event) => {
      const modifier = event.shiftKey ? 10 : 1;
      const { key } = event;
      const arrowKeyToXOffset = {
        ArrowUp: 1,
        ArrowRight: 1,
        ArrowDown: -1,
        ArrowLeft: -1
      };
      if (arrowKeyToXOffset[key]) {
        event.preventDefault();
        const delta = arrowKeyToXOffset[key] * modifier;
        const hue = this.baseColorFieldColor.hue();
        const color = this.baseColorFieldColor.hue(hue + delta);
        this.internalColorSet(color, false);
      }
    };
    this.handleHexInputChange = (event) => {
      event.stopPropagation();
      const { allowEmpty, color: color$1 } = this;
      const input = event.target;
      const hex = input.value;
      if (allowEmpty && !hex) {
        this.internalColorSet(null);
        return;
      }
      const normalizedHex = color$1 && (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.n)(color$1.hex());
      if (hex !== normalizedHex) {
        this.internalColorSet((0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(hex));
      }
    };
    this.handleSavedColorSelect = (event) => {
      const swatch = event.currentTarget;
      this.internalColorSet((0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(swatch.color));
    };
    this.handleChannelInput = (event) => {
      const input = event.currentTarget;
      const channelIndex = Number(input.getAttribute("data-channel-index"));
      const limit = this.channelMode === "rgb"
        ? RGB_LIMITS[Object.keys(RGB_LIMITS)[channelIndex]]
        : HSV_LIMITS[Object.keys(HSV_LIMITS)[channelIndex]];
      let inputValue;
      if (this.allowEmpty && !input.value) {
        inputValue = "";
      }
      else {
        const value = Number(input.value) + this.shiftKeyChannelAdjustment;
        const clamped = (0,_math_7efd987a_js__WEBPACK_IMPORTED_MODULE_4__.c)(value, 0, limit);
        inputValue = clamped.toString();
      }
      input.value = inputValue;
      // TODO: refactor calcite-input so we don't need to sync the internals
      // https://github.com/Esri/calcite-components/issues/6100
      input.internalSyncChildElValue();
    };
    this.handleChannelChange = (event) => {
      const input = event.currentTarget;
      const channelIndex = Number(input.getAttribute("data-channel-index"));
      const channels = [...this.channels];
      const shouldClearChannels = this.allowEmpty && !input.value;
      if (shouldClearChannels) {
        this.channels = [null, null, null];
        this.internalColorSet(null);
        return;
      }
      channels[channelIndex] = Number(input.value);
      this.updateColorFromChannels(channels);
    };
    this.handleSavedColorKeyDown = (event) => {
      if ((0,_key_b75491c4_js__WEBPACK_IMPORTED_MODULE_5__.i)(event.key)) {
        event.preventDefault();
        this.handleSavedColorSelect(event);
      }
    };
    this.handleColorFieldAndSliderPointerLeave = () => {
      this.colorFieldAndSliderInteractive = false;
      this.colorFieldAndSliderHovered = false;
      if (this.sliderThumbState !== "drag" && this.hueThumbState !== "drag") {
        this.hueThumbState = "idle";
        this.sliderThumbState = "idle";
        this.drawColorFieldAndSlider();
      }
    };
    this.handleColorFieldAndSliderPointerDown = (event) => {
      if (!(0,_dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_6__.i)(event)) {
        return;
      }
      const { offsetX, offsetY } = event;
      const region = this.getCanvasRegion(offsetY);
      if (region === "color-field") {
        this.hueThumbState = "drag";
        this.captureColorFieldColor(offsetX, offsetY);
        this.colorFieldScopeNode?.focus();
      }
      else if (region === "slider") {
        this.sliderThumbState = "drag";
        this.captureHueSliderColor(offsetX);
        this.hueScopeNode?.focus();
      }
      // prevent text selection outside of color field & slider area
      event.preventDefault();
      document.addEventListener("pointermove", this.globalPointerMoveHandler);
      document.addEventListener("pointerup", this.globalPointerUpHandler, { once: true });
      this.activeColorFieldAndSliderRect =
        this.fieldAndSliderRenderingContext.canvas.getBoundingClientRect();
    };
    this.globalPointerUpHandler = (event) => {
      if (!(0,_dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_6__.i)(event)) {
        return;
      }
      const previouslyDragging = this.sliderThumbState === "drag" || this.hueThumbState === "drag";
      this.hueThumbState = "idle";
      this.sliderThumbState = "idle";
      this.activeColorFieldAndSliderRect = null;
      this.drawColorFieldAndSlider();
      if (previouslyDragging) {
        this.calciteColorPickerChange.emit();
      }
    };
    this.globalPointerMoveHandler = (event) => {
      const { el, dimensions } = this;
      const sliderThumbDragging = this.sliderThumbState === "drag";
      const hueThumbDragging = this.hueThumbState === "drag";
      if (!el.isConnected || (!sliderThumbDragging && !hueThumbDragging)) {
        return;
      }
      let samplingX;
      let samplingY;
      const colorFieldAndSliderRect = this.activeColorFieldAndSliderRect;
      const { clientX, clientY } = event;
      if (this.colorFieldAndSliderHovered) {
        samplingX = clientX - colorFieldAndSliderRect.x;
        samplingY = clientY - colorFieldAndSliderRect.y;
      }
      else {
        const colorFieldWidth = dimensions.colorField.width;
        const colorFieldHeight = dimensions.colorField.height;
        const hueSliderHeight = dimensions.slider.height;
        if (clientX < colorFieldAndSliderRect.x + colorFieldWidth &&
          clientX > colorFieldAndSliderRect.x) {
          samplingX = clientX - colorFieldAndSliderRect.x;
        }
        else if (clientX < colorFieldAndSliderRect.x) {
          samplingX = 0;
        }
        else {
          samplingX = colorFieldWidth - 1;
        }
        if (clientY < colorFieldAndSliderRect.y + colorFieldHeight + hueSliderHeight &&
          clientY > colorFieldAndSliderRect.y) {
          samplingY = clientY - colorFieldAndSliderRect.y;
        }
        else if (clientY < colorFieldAndSliderRect.y) {
          samplingY = 0;
        }
        else {
          samplingY = colorFieldHeight + hueSliderHeight;
        }
      }
      if (hueThumbDragging) {
        this.captureColorFieldColor(samplingX, samplingY, false);
      }
      else {
        this.captureHueSliderColor(samplingX);
      }
    };
    this.handleColorFieldAndSliderPointerEnterOrMove = ({ offsetX, offsetY }) => {
      const { dimensions: { colorField, slider, thumb } } = this;
      this.colorFieldAndSliderInteractive = offsetY <= colorField.height + slider.height;
      this.colorFieldAndSliderHovered = true;
      const region = this.getCanvasRegion(offsetY);
      if (region === "color-field") {
        const prevHueThumbState = this.hueThumbState;
        const color = this.baseColorFieldColor.hsv();
        const centerX = Math.round(color.saturationv() / (HSV_LIMITS.s / colorField.width));
        const centerY = Math.round(colorField.height - color.value() / (HSV_LIMITS.v / colorField.height));
        const hoveringThumb = this.containsPoint(offsetX, offsetY, centerX, centerY, thumb.radius);
        let transitionedBetweenHoverAndIdle = false;
        if (prevHueThumbState === "idle" && hoveringThumb) {
          this.hueThumbState = "hover";
          transitionedBetweenHoverAndIdle = true;
        }
        else if (prevHueThumbState === "hover" && !hoveringThumb) {
          this.hueThumbState = "idle";
          transitionedBetweenHoverAndIdle = true;
        }
        if (this.hueThumbState !== "drag") {
          if (transitionedBetweenHoverAndIdle) {
            // refresh since we won't update color and thus no redraw
            this.drawColorFieldAndSlider();
          }
        }
      }
      else if (region === "slider") {
        const sliderThumbColor = this.baseColorFieldColor.hsv().saturationv(100).value(100);
        const prevSliderThumbState = this.sliderThumbState;
        const sliderThumbCenterX = Math.round(sliderThumbColor.hue() / (360 / slider.width));
        const sliderThumbCenterY = Math.round((slider.height + this.getSliderCapSpacing()) / 2) + colorField.height;
        const hoveringSliderThumb = this.containsPoint(offsetX, offsetY, sliderThumbCenterX, sliderThumbCenterY, thumb.radius);
        let sliderThumbTransitionedBetweenHoverAndIdle = false;
        if (prevSliderThumbState === "idle" && hoveringSliderThumb) {
          this.sliderThumbState = "hover";
          sliderThumbTransitionedBetweenHoverAndIdle = true;
        }
        else if (prevSliderThumbState === "hover" && !hoveringSliderThumb) {
          this.sliderThumbState = "idle";
          sliderThumbTransitionedBetweenHoverAndIdle = true;
        }
        if (this.sliderThumbState !== "drag") {
          if (sliderThumbTransitionedBetweenHoverAndIdle) {
            // refresh since we won't update color and thus no redraw
            this.drawColorFieldAndSlider();
          }
        }
      }
    };
    this.storeColorFieldScope = (node) => {
      this.colorFieldScopeNode = node;
    };
    this.storeHueScope = (node) => {
      this.hueScopeNode = node;
    };
    this.renderChannelsTabTitle = (channelMode) => {
      const { channelMode: activeChannelMode, messages } = this;
      const selected = channelMode === activeChannelMode;
      const label = channelMode === "rgb" ? messages.rgb : messages.hsv;
      return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tab-title", { class: CSS.colorMode, "data-color-mode": channelMode, key: channelMode, onCalciteTabsActivate: this.handleTabActivate, selected: selected }, label));
    };
    this.renderChannelsTab = (channelMode) => {
      const { channelMode: activeChannelMode, channels, messages } = this;
      const selected = channelMode === activeChannelMode;
      const isRgb = channelMode === "rgb";
      const channelLabels = isRgb
        ? [messages.r, messages.g, messages.b]
        : [messages.h, messages.s, messages.v];
      const channelAriaLabels = isRgb
        ? [messages.red, messages.green, messages.blue]
        : [messages.hue, messages.saturation, messages.value];
      const direction = (0,_dom_f1ee4d04_js__WEBPACK_IMPORTED_MODULE_6__.b)(this.el);
      return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tab", { class: CSS.control, key: channelMode, selected: selected }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.channels, dir: "ltr" }, channels.map((channel, index) => 
      /* the channel container is ltr, so we apply the host's direction */
      this.renderChannel(channel, index, channelLabels[index], channelAriaLabels[index], direction)))));
    };
    this.renderChannel = (value, index, label, ariaLabel, direction) => ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-input", { class: CSS.channel, "data-channel-index": index, dir: direction, label: ariaLabel, lang: this.effectiveLocale, numberButtonType: "none", numberingSystem: this.numberingSystem, onCalciteInputChange: this.handleChannelChange, onCalciteInputInput: this.handleChannelInput, onKeyDown: this.handleKeyDown, prefixText: label, scale: this.scale === "l" ? "m" : "s", type: "number", value: value?.toString() }));
    this.deleteColor = () => {
      const colorToDelete = this.color.hex();
      const inStorage = this.savedColors.indexOf(colorToDelete) > -1;
      if (!inStorage) {
        return;
      }
      const savedColors = this.savedColors.filter((color) => color !== colorToDelete);
      this.savedColors = savedColors;
      const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
      if (this.storageId) {
        localStorage.setItem(storageKey, JSON.stringify(savedColors));
      }
    };
    this.saveColor = () => {
      const colorToSave = this.color.hex();
      const alreadySaved = this.savedColors.indexOf(colorToSave) > -1;
      if (alreadySaved) {
        return;
      }
      const savedColors = [...this.savedColors, colorToSave];
      this.savedColors = savedColors;
      const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
      if (this.storageId) {
        localStorage.setItem(storageKey, JSON.stringify(savedColors));
      }
    };
    this.drawColorFieldAndSlider = throttle(() => {
      if (!this.fieldAndSliderRenderingContext) {
        return;
      }
      this.drawColorField();
      this.drawHueSlider();
    }, throttleFor60FpsInMs);
    this.captureColorFieldColor = (x, y, skipEqual = true) => {
      const { dimensions: { colorField: { height, width } } } = this;
      const saturation = Math.round((HSV_LIMITS.s / width) * x);
      const value = Math.round((HSV_LIMITS.v / height) * (height - y));
      this.internalColorSet(this.baseColorFieldColor.hsv().saturationv(saturation).value(value), skipEqual);
    };
    this.initColorFieldAndSlider = (canvas) => {
      this.fieldAndSliderRenderingContext = canvas.getContext("2d");
      this.updateCanvasSize(canvas);
    };
    this.allowEmpty = false;
    this.color = DEFAULT_COLOR;
    this.disabled = false;
    this.format = defaultFormat;
    this.hideHex = false;
    this.hideChannels = false;
    this.hideSaved = false;
    this.scale = "m";
    this.storageId = undefined;
    this.messageOverrides = undefined;
    this.numberingSystem = undefined;
    this.value = defaultValue;
    this.defaultMessages = undefined;
    this.colorFieldAndSliderInteractive = false;
    this.channelMode = "rgb";
    this.channels = this.toChannels(DEFAULT_COLOR);
    this.dimensions = DIMENSIONS.m;
    this.effectiveLocale = "";
    this.messages = undefined;
    this.savedColors = [];
    this.colorFieldScopeTop = undefined;
    this.colorFieldScopeLeft = undefined;
    this.scopeOrientation = undefined;
    this.hueScopeLeft = undefined;
    this.hueScopeTop = undefined;
  }
  handleColorChange(color, oldColor) {
    this.drawColorFieldAndSlider();
    this.updateChannelsFromColor(color);
    this.previousColor = oldColor;
  }
  handleFormatChange(format) {
    this.setMode(format);
    this.internalColorSet(this.color, false, "internal");
  }
  handleScaleChange(scale = "m") {
    this.updateDimensions(scale);
    this.updateCanvasSize(this.fieldAndSliderRenderingContext?.canvas);
  }
  onMessagesChange() {
    /* wired up by t9n util */
  }
  handleValueChange(value, oldValue) {
    const { allowEmpty, format } = this;
    const checkMode = !allowEmpty || value;
    let modeChanged = false;
    if (checkMode) {
      const nextMode = (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.p)(value);
      if (!nextMode || (format !== "auto" && nextMode !== format)) {
        this.showIncompatibleColorWarning(value, format);
        this.value = oldValue;
        return;
      }
      modeChanged = this.mode !== nextMode;
      this.setMode(nextMode);
    }
    const dragging = this.sliderThumbState === "drag" || this.hueThumbState === "drag";
    if (this.internalColorUpdateContext === "initial") {
      return;
    }
    if (this.internalColorUpdateContext === "user-interaction") {
      this.calciteColorPickerInput.emit();
      if (!dragging) {
        this.calciteColorPickerChange.emit();
      }
      return;
    }
    const color$1 = allowEmpty && !value ? null : (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(value);
    const colorChanged = !(0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.c)(color$1, this.color);
    if (modeChanged || colorChanged) {
      this.internalColorSet(color$1, true, "internal");
    }
  }
  //--------------------------------------------------------------------------
  //
  //  Internal State/Props
  //
  //--------------------------------------------------------------------------
  get baseColorFieldColor() {
    return this.color || this.previousColor || DEFAULT_COLOR;
  }
  effectiveLocaleChange() {
    (0,_t9n_dc67ab96_js__WEBPACK_IMPORTED_MODULE_7__.u)(this, this.effectiveLocale);
  }
  // using @Listen as a workaround for VDOM listener not firing
  handleChannelKeyUpOrDown(event) {
    this.shiftKeyChannelAdjustment = 0;
    const { key } = event;
    if ((key !== "ArrowUp" && key !== "ArrowDown") ||
      !event.composedPath().some((node) => node.classList?.contains(CSS.channel))) {
      return;
    }
    const { shiftKey } = event;
    event.preventDefault();
    if (!this.color) {
      this.internalColorSet(this.previousColor);
      event.stopPropagation();
      return;
    }
    // this gets applied to the input's up/down arrow increment/decrement
    const complementaryBump = 9;
    this.shiftKeyChannelAdjustment =
      key === "ArrowUp" && shiftKey
        ? complementaryBump
        : key === "ArrowDown" && shiftKey
          ? -complementaryBump
          : 0;
  }
  //--------------------------------------------------------------------------
  //
  //  Public Methods
  //
  //--------------------------------------------------------------------------
  /** Sets focus on the component's first focusable element. */
  async setFocus() {
    await (0,_loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__.c)(this);
    this.el.focus();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  async componentWillLoad() {
    (0,_loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__.a)(this);
    const { allowEmpty, color: color$1, format, value } = this;
    const willSetNoColor = allowEmpty && !value;
    const parsedMode = (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.p)(value);
    const valueIsCompatible = willSetNoColor || (format === "auto" && parsedMode) || format === parsedMode;
    const initialColor = willSetNoColor ? null : valueIsCompatible ? (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(value) : color$1;
    if (!valueIsCompatible) {
      this.showIncompatibleColorWarning(value, format);
    }
    this.setMode(format);
    this.internalColorSet(initialColor, false, "initial");
    this.updateDimensions(this.scale);
    const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;
    if (this.storageId && localStorage.getItem(storageKey)) {
      this.savedColors = JSON.parse(localStorage.getItem(storageKey));
    }
    await (0,_t9n_dc67ab96_js__WEBPACK_IMPORTED_MODULE_7__.s)(this);
  }
  connectedCallback() {
    (0,_locale_f7b2fbb0_js__WEBPACK_IMPORTED_MODULE_9__.c)(this);
    (0,_t9n_dc67ab96_js__WEBPACK_IMPORTED_MODULE_7__.c)(this);
  }
  componentDidLoad() {
    (0,_loadable_cc14d728_js__WEBPACK_IMPORTED_MODULE_8__.s)(this);
  }
  disconnectedCallback() {
    document.removeEventListener("pointermove", this.globalPointerMoveHandler);
    document.removeEventListener("pointerup", this.globalPointerUpHandler);
    (0,_locale_f7b2fbb0_js__WEBPACK_IMPORTED_MODULE_9__.d)(this);
    (0,_t9n_dc67ab96_js__WEBPACK_IMPORTED_MODULE_7__.d)(this);
  }
  componentDidRender() {
    (0,_interactive_29995522_js__WEBPACK_IMPORTED_MODULE_10__.u)(this);
  }
  //--------------------------------------------------------------------------
  //
  //  Render Methods
  //
  //--------------------------------------------------------------------------
  render() {
    const { allowEmpty, color, messages, hideHex, hideChannels, hideSaved, savedColors, scale } = this;
    const selectedColorInHex = color ? color.hex() : null;
    const hexInputScale = scale === "l" ? "m" : "s";
    const { colorFieldAndSliderInteractive, colorFieldScopeTop, colorFieldScopeLeft, hueScopeLeft, hueScopeTop, scopeOrientation, dimensions: { colorField: { height: colorFieldHeight, width: colorFieldWidth }, slider: { height: sliderHeight } } } = this;
    const hueTop = hueScopeTop ?? sliderHeight / 2 + colorFieldHeight;
    const hueLeft = hueScopeLeft ?? (colorFieldWidth * DEFAULT_COLOR.hue()) / HSV_LIMITS.h;
    const noColor = color === null;
    const vertical = scopeOrientation === "vertical";
    return ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.container }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.colorFieldAndSliderWrap }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("canvas", { class: {
        [CSS.colorFieldAndSlider]: true,
        [CSS.colorFieldAndSliderInteractive]: colorFieldAndSliderInteractive
      }, onPointerDown: this.handleColorFieldAndSliderPointerDown, onPointerEnter: this.handleColorFieldAndSliderPointerEnterOrMove, onPointerLeave: this.handleColorFieldAndSliderPointerLeave, onPointerMove: this.handleColorFieldAndSliderPointerEnterOrMove, ref: this.initColorFieldAndSlider }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { "aria-label": vertical ? messages.value : messages.saturation, "aria-valuemax": vertical ? HSV_LIMITS.v : HSV_LIMITS.s, "aria-valuemin": "0", "aria-valuenow": (vertical ? color?.saturationv() : color?.value()) || "0", class: { [CSS.scope]: true, [CSS.colorFieldScope]: true }, onKeyDown: this.handleColorFieldScopeKeyDown, ref: this.storeColorFieldScope, role: "slider", style: { top: `${colorFieldScopeTop || 0}px`, left: `${colorFieldScopeLeft || 0}px` }, tabindex: "0" }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { "aria-label": messages.hue, "aria-valuemax": HSV_LIMITS.h, "aria-valuemin": "0", "aria-valuenow": color?.round().hue() || DEFAULT_COLOR.round().hue(), class: { [CSS.scope]: true, [CSS.hueScope]: true }, onKeyDown: this.handleHueScopeKeyDown, ref: this.storeHueScope, role: "slider", style: { top: `${hueTop}px`, left: `${hueLeft}px` }, tabindex: "0" })), hideHex && hideChannels ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: {
        [CSS.controlSection]: true,
        [CSS.section]: true
      } }, hideHex ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.hexOptions }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("span", { class: {
        [CSS.header]: true,
        [CSS.headerHex]: true
      } }, messages.hex), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-color-picker-hex-input", { allowEmpty: allowEmpty, class: CSS.control, hexLabel: messages.hex, numberingSystem: this.numberingSystem, onCalciteColorPickerHexInputChange: this.handleHexInputChange, scale: hexInputScale, value: selectedColorInHex }))), hideChannels ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tabs", { class: {
        [CSS.colorModeContainer]: true,
        [CSS.splitSection]: true
      }, scale: hexInputScale }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-tab-nav", { slot: "title-group" }, this.renderChannelsTabTitle("rgb"), this.renderChannelsTabTitle("hsv")), this.renderChannelsTab("rgb"), this.renderChannelsTab("hsv"))))), hideSaved ? null : ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: { [CSS.savedColorsSection]: true, [CSS.section]: true } }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.header }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("label", null, messages.saved), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.savedColorsButtons }, (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-button", { appearance: "transparent", class: CSS.deleteColor, disabled: noColor, iconStart: "minus", kind: "neutral", label: messages.deleteColor, onClick: this.deleteColor, scale: hexInputScale, type: "button" }), (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-button", { appearance: "transparent", class: CSS.saveColor, disabled: noColor, iconStart: "plus", kind: "neutral", label: messages.saveColor, onClick: this.saveColor, scale: hexInputScale, type: "button" }))), savedColors.length > 0 ? ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("div", { class: CSS.savedColors }, [
      ...savedColors.map((color) => ((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.h)("calcite-color-picker-swatch", { active: selectedColorInHex === color, class: CSS.savedColor, color: color, key: color, onClick: this.handleSavedColorSelect, onKeyDown: this.handleSavedColorKeyDown, scale: scale, tabIndex: 0 })))
    ])) : null))));
  }
  // --------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  handleKeyDown(event) {
    if (event.key === "Enter") {
      event.preventDefault();
    }
  }
  showIncompatibleColorWarning(value, format) {
    console.warn(`ignoring color value (${value}) as it is not compatible with the current format (${format})`);
  }
  setMode(format) {
    this.mode = format === "auto" ? this.mode : format;
  }
  captureHueSliderColor(x) {
    const { dimensions: { slider: { width } } } = this;
    const hue = (360 / width) * x;
    this.internalColorSet(this.baseColorFieldColor.hue(hue), false);
  }
  getCanvasRegion(y) {
    const { dimensions: { colorField: { height: colorFieldHeight }, slider: { height: sliderHeight } } } = this;
    if (y <= colorFieldHeight) {
      return "color-field";
    }
    if (y <= colorFieldHeight + sliderHeight) {
      return "slider";
    }
    return "none";
  }
  internalColorSet(color, skipEqual = true, context = "user-interaction") {
    if (skipEqual && (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.c)(color, this.color)) {
      return;
    }
    this.internalColorUpdateContext = context;
    this.color = color;
    this.value = this.toValue(color);
    this.internalColorUpdateContext = null;
  }
  toValue(color, format = this.mode) {
    if (!color) {
      return null;
    }
    const hexMode = "hex";
    if (format.includes(hexMode)) {
      return (0,_utils_a71d8ee9_js__WEBPACK_IMPORTED_MODULE_2__.n)(color.round()[hexMode]());
    }
    if (format.includes("-css")) {
      return color[format.replace("-css", "").replace("a", "")]().round().string();
    }
    const colorObject = color[format]().round().object();
    if (format.endsWith("a")) {
      // normalize alpha prop
      colorObject.a = colorObject.alpha;
      delete colorObject.alpha;
    }
    return colorObject;
  }
  getSliderCapSpacing() {
    const { dimensions: { slider: { height }, thumb: { radius } } } = this;
    return radius * 2 - height;
  }
  updateDimensions(scale = "m") {
    this.dimensions = DIMENSIONS[scale];
  }
  drawColorField() {
    const context = this.fieldAndSliderRenderingContext;
    const { dimensions: { colorField: { height, width } } } = this;
    context.fillStyle = this.baseColorFieldColor.hsv().saturationv(100).value(100).string();
    context.fillRect(0, 0, width, height);
    const whiteGradient = context.createLinearGradient(0, 0, width, 0);
    whiteGradient.addColorStop(0, "rgba(255,255,255,1)");
    whiteGradient.addColorStop(1, "rgba(255,255,255,0)");
    context.fillStyle = whiteGradient;
    context.fillRect(0, 0, width, height);
    const blackGradient = context.createLinearGradient(0, 0, 0, height);
    blackGradient.addColorStop(0, "rgba(0,0,0,0)");
    blackGradient.addColorStop(1, "rgba(0,0,0,1)");
    context.fillStyle = blackGradient;
    context.fillRect(0, 0, width, height);
    this.drawActiveColorFieldColor();
  }
  setCanvasContextSize(canvas, { height, width }) {
    const devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    canvas.style.height = `${height}px`;
    canvas.style.width = `${width}px`;
    const context = canvas.getContext("2d");
    context.scale(devicePixelRatio, devicePixelRatio);
  }
  updateCanvasSize(canvas) {
    if (!canvas) {
      return;
    }
    this.setCanvasContextSize(canvas, {
      width: this.dimensions.colorField.width,
      height: this.dimensions.colorField.height +
        this.dimensions.slider.height +
        this.getSliderCapSpacing() * 2
    });
    this.drawColorFieldAndSlider();
  }
  containsPoint(testPointX, testPointY, boundsX, boundsY, boundsRadius) {
    return (Math.pow(testPointX - boundsX, 2) + Math.pow(testPointY - boundsY, 2) <=
      Math.pow(boundsRadius, 2));
  }
  drawActiveColorFieldColor() {
    const { color } = this;
    if (!color) {
      return;
    }
    const hsvColor = color.hsv();
    const { dimensions: { colorField: { height, width }, thumb: { radius } } } = this;
    const x = hsvColor.saturationv() / (HSV_LIMITS.s / width);
    const y = height - hsvColor.value() / (HSV_LIMITS.v / height);
    requestAnimationFrame(() => {
      this.colorFieldScopeLeft = x;
      this.colorFieldScopeTop = y;
    });
    this.drawThumb(this.fieldAndSliderRenderingContext, radius, x, y, hsvColor, this.hueThumbState);
  }
  drawThumb(context, radius, x, y, color, state) {
    const startAngle = 0;
    const endAngle = 2 * Math.PI;
    context.beginPath();
    context.arc(x, y, radius, startAngle, endAngle);
    context.shadowBlur = state === "hover" ? 32 : 16;
    context.shadowColor = `rgba(0, 0, 0, ${state === "drag" ? 0.32 : 0.16})`;
    context.fillStyle = "#fff";
    context.fill();
    context.beginPath();
    context.arc(x, y, radius - 3, startAngle, endAngle);
    context.shadowBlur = 0;
    context.shadowColor = "transparent";
    context.fillStyle = color.rgb().string();
    context.fill();
  }
  drawActiveHueSliderColor() {
    const { color } = this;
    if (!color) {
      return;
    }
    const hsvColor = color.hsv().saturationv(100).value(100);
    const { dimensions: { colorField: { height: colorFieldHeight }, slider: { height, width }, thumb: { radius } } } = this;
    const x = hsvColor.hue() / (360 / width);
    const y = height / 2 + colorFieldHeight;
    requestAnimationFrame(() => {
      this.hueScopeLeft = x;
      this.hueScopeTop = y;
    });
    this.drawThumb(this.fieldAndSliderRenderingContext, radius, x, y, hsvColor, this.sliderThumbState);
  }
  drawHueSlider() {
    const context = this.fieldAndSliderRenderingContext;
    const { dimensions: { colorField: { height: colorFieldHeight }, slider: { height, width } } } = this;
    const gradient = context.createLinearGradient(0, 0, width, 0);
    const hueSliderColorStopKeywords = ["red", "yellow", "lime", "cyan", "blue", "magenta", "red"];
    const offset = 1 / (hueSliderColorStopKeywords.length - 1);
    let currentOffset = 0;
    hueSliderColorStopKeywords.forEach((keyword) => {
      gradient.addColorStop(currentOffset, (0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(keyword).string());
      currentOffset += offset;
    });
    context.fillStyle = gradient;
    context.clearRect(0, colorFieldHeight, width, height + this.getSliderCapSpacing() * 2);
    context.fillRect(0, colorFieldHeight, width, height);
    this.drawActiveHueSliderColor();
  }
  updateColorFromChannels(channels) {
    this.internalColorSet((0,_index_56dd1c42_js__WEBPACK_IMPORTED_MODULE_1__.c)(channels, this.channelMode));
  }
  updateChannelsFromColor(color) {
    this.channels = color ? this.toChannels(color) : [null, null, null];
  }
  toChannels(color) {
    const { channelMode } = this;
    return color[channelMode]()
      .array()
      .map((value) => Math.floor(value));
  }
  static get delegatesFocus() { return true; }
  static get assetsDirs() { return ["assets"]; }
  get el() { return (0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_3__.g)(this); }
  static get watchers() { return {
    "color": ["handleColorChange"],
    "format": ["handleFormatChange"],
    "scale": ["handleScaleChange"],
    "messageOverrides": ["onMessagesChange"],
    "value": ["handleValueChange"],
    "effectiveLocale": ["effectiveLocaleChange"]
  }; }
};
ColorPicker.style = colorPickerCss;



//# sourceMappingURL=calcite-color-picker.entry.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/interactive-29995522.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/interactive-29995522.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ updateHostInteraction)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function noopClick() {
  /** noop */
}
/**
 * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.
 *
 * This should be used in the `componentDidRender` lifecycle hook.
 *
 * **Notes**
 *
 * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.
 * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error
 *
 * @param component
 * @param hostIsTabbable
 */
function updateHostInteraction(component, hostIsTabbable = false) {
  if (component.disabled) {
    component.el.setAttribute("tabindex", "-1");
    component.el.setAttribute("aria-disabled", "true");
    if (component.el.contains(document.activeElement)) {
      document.activeElement.blur();
    }
    component.el.click = noopClick;
    return;
  }
  component.el.click = HTMLElement.prototype.click;
  if (typeof hostIsTabbable === "function") {
    component.el.setAttribute("tabindex", hostIsTabbable.call(component) ? "0" : "-1");
  }
  else if (hostIsTabbable === true) {
    component.el.setAttribute("tabindex", "0");
  }
  else if (hostIsTabbable === false) {
    component.el.removeAttribute("tabindex");
  }
  else ;
  component.el.removeAttribute("aria-disabled");
}



//# sourceMappingURL=interactive-29995522.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/loadable-cc14d728.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/loadable-cc14d728.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ setUpLoadableComponent),
/* harmony export */   c: () => (/* binding */ componentLoaded),
/* harmony export */   s: () => (/* binding */ setComponentLoaded)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const resolveMap = new WeakMap();
const promiseMap = new WeakMap();
/**
 * This helper util sets up the component for the ability to know when the component has been loaded.
 *
 * This should be used in the `componentWillLoad` lifecycle hook.
 *
 * ```
 * componentWillLoad(): void {
 *   setUpLoadableComponent(this);
 * }
 * ```
 *
 * @param component
 */
function setUpLoadableComponent(component) {
  promiseMap.set(component, new Promise((resolve) => resolveMap.set(component, resolve)));
}
/**
 * This helper util lets the loadable component know that it is now loaded.
 *
 * This should be used in the `componentDidLoad` lifecycle hook.
 *
 * ```
 * componentDidLoad(): void {
 *   setComponentLoaded(this);
 * }
 * ```
 *
 * @param component
 */
function setComponentLoaded(component) {
  resolveMap.get(component)();
}
/**
 * This helper util can be used to ensure a component has been loaded (The "componentDidLoad" stencil lifecycle method has been called).
 *
 * Requires "setUpLoadableComponent" and "setComponentLoaded" to be called first.
 *
 * A component developer can await this method before proceeding with any logic that requires a component to be loaded first.
 *
 * ```
 * async setFocus(): Promise<void> {
 *   await componentLoaded(this);
 * }
 * ```
 *
 * @param component
 * @returns Promise<void>
 */
function componentLoaded(component) {
  return promiseMap.get(component);
}



//# sourceMappingURL=loadable-cc14d728.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/math-7efd987a.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/math-7efd987a.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ clamp),
/* harmony export */   d: () => (/* binding */ decimalPlaces)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const clamp = (value, min, max) => Math.max(min, Math.min(value, max));
const decimalPlaces = (value) => {
  const match = ("" + value).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  if (!match) {
    return 0;
  }
  return Math.max(0, 
  // Number of digits right of decimal point.
  (match[1] ? match[1].length : 0) -
    // Adjust for scientific notation.
    (match[2] ? +match[2] : 0));
};



//# sourceMappingURL=math-7efd987a.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/t9n-dc67ab96.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/t9n-dc67ab96.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ connectMessages),
/* harmony export */   d: () => (/* binding */ disconnectMessages),
/* harmony export */   s: () => (/* binding */ setUpMessages),
/* harmony export */   u: () => (/* binding */ updateMessages)
/* harmony export */ });
/* harmony import */ var _index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-4e647411.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index-4e647411.js");
/* harmony import */ var _locale_f7b2fbb0_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-f7b2fbb0.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/locale-f7b2fbb0.js");



/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const componentLangToMessageBundleCache = {};
async function getMessageBundle(lang, component) {
  const key = `${component}_${lang}`;
  if (componentLangToMessageBundleCache[key]) {
    return componentLangToMessageBundleCache[key];
  }
  componentLangToMessageBundleCache[key] = fetch((0,_index_4e647411_js__WEBPACK_IMPORTED_MODULE_0__.a)(`./assets/${component}/t9n/messages_${lang}.json`))
    .then((resp) => {
    if (!resp.ok) {
      throwMessageFetchError();
    }
    return resp.json();
  })
    .catch(() => throwMessageFetchError());
  return componentLangToMessageBundleCache[key];
}
function throwMessageFetchError() {
  throw new Error("could not fetch component message bundle");
}
function mergeMessages(component) {
  component.messages = {
    ...component.defaultMessages,
    ...component.messageOverrides
  };
}
/**
 * This utility sets up the messages used by the component. It should be awaited in the `componentWillLoad` lifecycle hook.
 *
 * @param component
 */
async function setUpMessages(component) {
  component.defaultMessages = await fetchMessages(component, component.effectiveLocale);
  mergeMessages(component);
}
async function fetchMessages(component, lang) {
  const { el } = component;
  const tag = el.tagName.toLowerCase();
  const componentName = tag.replace("calcite-", "");
  return getMessageBundle((0,_locale_f7b2fbb0_js__WEBPACK_IMPORTED_MODULE_1__.g)(lang, "t9n"), componentName);
}
/**
 * This utility must be set up for the component to update its default message bundle if the locale changes.
 *
 * It can be set up in **either** of the following ways:
 *
 * 1. called from `LocalizedComponent`'s `onLocaleChange` method or
 * 2. called from a watcher configured to watch `LocalizedComponent`'s `effectiveLocale` prop
 *
 * @param component
 * @param lang
 */
async function updateMessages(component, lang) {
  component.defaultMessages = await fetchMessages(component, lang);
  mergeMessages(component);
}
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback`
 *
 * **Note**: this must be called after `LocalizedComponent`'s `connectLocalized` method.
 *
 * @param component
 */
function connectMessages(component) {
  component.onMessagesChange = defaultOnMessagesChange;
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectMessages(component) {
  component.onMessagesChange = undefined;
}
function defaultOnMessagesChange() {
  mergeMessages(this);
}



//# sourceMappingURL=t9n-dc67ab96.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/utils-a71d8ee9.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/utils-a71d8ee9.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSSColorMode),
/* harmony export */   a: () => (/* binding */ isLonghandHex),
/* harmony export */   b: () => (/* binding */ hexChar),
/* harmony export */   c: () => (/* binding */ colorEqual),
/* harmony export */   h: () => (/* binding */ hexToRGB),
/* harmony export */   i: () => (/* binding */ isValidHex),
/* harmony export */   n: () => (/* binding */ normalizeHex),
/* harmony export */   p: () => (/* binding */ parseMode),
/* harmony export */   r: () => (/* binding */ rgbToHex)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function rgbToHex(color) {
  const { r, g, b } = color;
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b
    .toString(16)
    .padStart(2, "0")}`.toLowerCase();
}
const hexChar = /^[0-9A-F]$/i;
const shortHandHex = /^#[0-9A-F]{3}$/i;
const longhandHex = /^#[0-9A-F]{6}$/i;
function isValidHex(hex) {
  return isShorthandHex(hex) || isLonghandHex(hex);
}
function isShorthandHex(hex) {
  return hex && hex.length === 4 && shortHandHex.test(hex);
}
function isLonghandHex(hex) {
  return hex && hex.length === 7 && longhandHex.test(hex);
}
function normalizeHex(hex) {
  hex = hex.toLowerCase();
  if (!hex.startsWith("#")) {
    hex = `#${hex}`;
  }
  if (isShorthandHex(hex)) {
    return rgbToHex(hexToRGB(hex));
  }
  return hex;
}
function hexToRGB(hex) {
  if (!isValidHex(hex)) {
    return null;
  }
  hex = hex.replace("#", "");
  if (hex.length === 3) {
    const [first, second, third] = hex.split("");
    const r = parseInt(`${first}${first}`, 16);
    const g = parseInt(`${second}${second}`, 16);
    const b = parseInt(`${third}${third}`, 16);
    return { r, g, b };
  }
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  return { r, g, b };
}
// these utils allow users to pass enum values as strings without having to access the enum
// based on the approach suggested by https://github.com/microsoft/TypeScript/issues/17690#issuecomment-321365759,
const enumify = (x) => x;
const CSSColorMode = enumify({
  HEX: "hex",
  HEXA: "hexa",
  RGB_CSS: "rgb-css",
  RGBA_CSS: "rgba-css",
  HSL_CSS: "hsl-css",
  HSLA_CSS: "hsla-css"
});
const ObjectColorMode = enumify({
  RGB: "rgb",
  RGBA: "rgba",
  HSL: "hsl",
  HSLA: "hsla",
  HSV: "hsv",
  HSVA: "hsva"
});
function parseMode(colorValue) {
  if (typeof colorValue === "string") {
    if (colorValue.startsWith("#")) {
      const { length } = colorValue;
      if (length === 4 || length === 7) {
        return CSSColorMode.HEX;
      }
      if (length === 5 || length === 9) {
        return CSSColorMode.HEXA;
      }
    }
    if (colorValue.startsWith("rgba(")) {
      return CSSColorMode.RGBA_CSS;
    }
    if (colorValue.startsWith("rgb(")) {
      return CSSColorMode.RGB_CSS;
    }
    if (colorValue.startsWith("hsl(")) {
      return CSSColorMode.HSL_CSS;
    }
    if (colorValue.startsWith("hsla(")) {
      return CSSColorMode.HSLA_CSS;
    }
  }
  if (typeof colorValue === "object") {
    if (hasChannels(colorValue, "r", "g", "b")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.RGBA : ObjectColorMode.RGB;
    }
    if (hasChannels(colorValue, "h", "s", "l")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSLA : ObjectColorMode.HSL;
    }
    if (hasChannels(colorValue, "h", "s", "v")) {
      return hasChannels(colorValue, "a") ? ObjectColorMode.HSVA : ObjectColorMode.HSV;
    }
  }
  return null;
}
function hasChannels(colorObject, ...channels) {
  return channels.every((channel) => channel && colorObject && `${channel}` in colorObject);
}
function colorEqual(value1, value2) {
  return value1?.rgbNumber() === value2?.rgbNumber();
}



//# sourceMappingURL=utils-a71d8ee9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLTVmZDQyMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0c7QUFDakQ7QUFDbUM7QUFDd0I7QUFDckM7QUFDZDtBQUMyRDtBQUM3QjtBQUN2QztBQUMyRTtBQUNyRDtBQUNyQztBQUNMO0FBQ0s7QUFDQTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3REFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0RBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LEVBQUUsZ0NBQWdDLEVBQUU7QUFDakY7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlDQUFpQyxFQUFFO0FBQ25DLGdDQUFnQyxFQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLEVBQUUsTUFBTTtBQUN4QywwQkFBMEIsT0FBTyxFQUFFLE9BQU87QUFDMUMsMEJBQTBCLE1BQU0sRUFBRSxNQUFNO0FBQ3hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVrSzs7QUFFbEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9jYWxjaXRlLWNvbG9yLXBpY2tlci5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9pbnRlcmFjdGl2ZS0yOTk5NTUyMi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9sb2FkYWJsZS1jYzE0ZDcyOC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS9tYXRoLTdlZmQ5ODdhLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYmEtaW5mb2dyYXBoaWMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYnVzaW5lc3MtYW5hbHlzdC1jb21wb25lbnRzL2Rpc3Qvc3RlbmNpbC1jb21wb25lbnRzL2Rpc3QvZXNtL3Q5bi1kYzY3YWI5Ni5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2JhLWluZm9ncmFwaGljL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2J1c2luZXNzLWFuYWx5c3QtY29tcG9uZW50cy9kaXN0L3N0ZW5jaWwtY29tcG9uZW50cy9kaXN0L2VzbS91dGlscy1hNzFkOGVlOS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIGcgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtNGU2NDc0MTEuanMnO1xuaW1wb3J0IHsgYyBhcyBjb2xvciB9IGZyb20gJy4vaW5kZXgtNTZkZDFjNDIuanMnO1xuaW1wb3J0IHsgaSBhcyBpc1ByaW1hcnlQb2ludGVyQnV0dG9uLCBiIGFzIGdldEVsZW1lbnREaXIgfSBmcm9tICcuL2RvbS1mMWVlNGQwNC5qcyc7XG5pbXBvcnQgeyBuIGFzIG5vcm1hbGl6ZUhleCwgQyBhcyBDU1NDb2xvck1vZGUsIHAgYXMgcGFyc2VNb2RlLCBjIGFzIGNvbG9yRXF1YWwgfSBmcm9tICcuL3V0aWxzLWE3MWQ4ZWU5LmpzJztcbmltcG9ydCB7IHUgYXMgdXBkYXRlSG9zdEludGVyYWN0aW9uIH0gZnJvbSAnLi9pbnRlcmFjdGl2ZS0yOTk5NTUyMi5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzQWN0aXZhdGlvbktleSB9IGZyb20gJy4va2V5LWI3NTQ5MWM0LmpzJztcbmltcG9ydCB7IGMgYXMgY29tcG9uZW50TG9hZGVkLCBhIGFzIHNldFVwTG9hZGFibGVDb21wb25lbnQsIHMgYXMgc2V0Q29tcG9uZW50TG9hZGVkIH0gZnJvbSAnLi9sb2FkYWJsZS1jYzE0ZDcyOC5qcyc7XG5pbXBvcnQgeyBjIGFzIGNvbm5lY3RMb2NhbGl6ZWQsIGQgYXMgZGlzY29ubmVjdExvY2FsaXplZCB9IGZyb20gJy4vbG9jYWxlLWY3YjJmYmIwLmpzJztcbmltcG9ydCB7IGMgYXMgY2xhbXAgfSBmcm9tICcuL21hdGgtN2VmZDk4N2EuanMnO1xuaW1wb3J0IHsgdSBhcyB1cGRhdGVNZXNzYWdlcywgcyBhcyBzZXRVcE1lc3NhZ2VzLCBjIGFzIGNvbm5lY3RNZXNzYWdlcywgZCBhcyBkaXNjb25uZWN0TWVzc2FnZXMgfSBmcm9tICcuL3Q5bi1kYzY3YWI5Ni5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlYm91bmNlLCBpIGFzIGlzT2JqZWN0IH0gZnJvbSAnLi9kZWJvdW5jZS0wNDdlMDlmNC5qcyc7XG5pbXBvcnQgJy4vaW5kZXguZXNtLTFjNjVkOGM3LmpzJztcbmltcG9ydCAnLi9ndWlkLTg4YTM3MjlmLmpzJztcbmltcG9ydCAnLi9yZXNvdXJjZXMtNDg0MzZlZWEuanMnO1xuaW1wb3J0ICcuL29ic2VydmVycy01Njc0MGU5OS5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5jb25zdCBDU1MgPSB7XG4gIGNvbnRhaW5lcjogXCJjb250YWluZXJcIixcbiAgY29udHJvbFNlY3Rpb246IFwiY29udHJvbC1zZWN0aW9uXCIsXG4gIGhleE9wdGlvbnM6IFwiY29sb3ItaGV4LW9wdGlvbnNcIixcbiAgc2VjdGlvbjogXCJzZWN0aW9uXCIsXG4gIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgY29udHJvbDogXCJjb250cm9sXCIsXG4gIHNwbGl0U2VjdGlvbjogXCJzZWN0aW9uLS1zcGxpdFwiLFxuICBjb2xvck1vZGVDb250YWluZXI6IFwiY29sb3ItbW9kZS1jb250YWluZXJcIixcbiAgY29sb3JNb2RlOiBcImNvbG9yLW1vZGVcIixcbiAgY2hhbm5lbHM6IFwiY2hhbm5lbHNcIixcbiAgY2hhbm5lbDogXCJjaGFubmVsXCIsXG4gIHNhdmVkQ29sb3JzOiBcInNhdmVkLWNvbG9yc1wiLFxuICBzYXZlZENvbG9yc1NlY3Rpb246IFwic2F2ZWQtY29sb3JzLXNlY3Rpb25cIixcbiAgc2F2ZUNvbG9yOiBcInNhdmUtY29sb3JcIixcbiAgZGVsZXRlQ29sb3I6IFwiZGVsZXRlLWNvbG9yXCIsXG4gIHNhdmVkQ29sb3JzQnV0dG9uczogXCJzYXZlZC1jb2xvcnMtYnV0dG9uc1wiLFxuICBoZWFkZXJIZXg6IFwiaGVhZGVyLS1oZXhcIixcbiAgY29sb3JGaWVsZEFuZFNsaWRlcjogXCJjb2xvci1maWVsZC1hbmQtc2xpZGVyXCIsXG4gIGNvbG9yRmllbGRBbmRTbGlkZXJJbnRlcmFjdGl2ZTogXCJjb2xvci1maWVsZC1hbmQtc2xpZGVyLS1pbnRlcmFjdGl2ZVwiLFxuICBjb2xvckZpZWxkQW5kU2xpZGVyV3JhcDogXCJjb2xvci1maWVsZC1hbmQtc2xpZGVyLXdyYXBcIixcbiAgc2NvcGU6IFwic2NvcGVcIixcbiAgaHVlU2NvcGU6IFwic2NvcGUtLWh1ZVwiLFxuICBjb2xvckZpZWxkU2NvcGU6IFwic2NvcGUtLWNvbG9yLWZpZWxkXCIsXG4gIHNhdmVkQ29sb3I6IFwic2F2ZWQtY29sb3JcIlxufTtcbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBjb2xvcihcIiMwMDdBQzJcIik7XG5jb25zdCBERUZBVUxUX1NUT1JBR0VfS0VZX1BSRUZJWCA9IFwiY2FsY2l0ZS1jb2xvci1cIjtcbmNvbnN0IFJHQl9MSU1JVFMgPSB7XG4gIHI6IDI1NSxcbiAgZzogMjU1LFxuICBiOiAyNTVcbn07XG5jb25zdCBIU1ZfTElNSVRTID0ge1xuICBoOiAzNjAsXG4gIHM6IDEwMCxcbiAgdjogMTAwXG59O1xuY29uc3QgRElNRU5TSU9OUyA9IHtcbiAgczoge1xuICAgIHNsaWRlcjoge1xuICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgIHdpZHRoOiAxNjBcbiAgICB9LFxuICAgIGNvbG9yRmllbGQ6IHtcbiAgICAgIGhlaWdodDogODAsXG4gICAgICB3aWR0aDogMTYwXG4gICAgfSxcbiAgICB0aHVtYjoge1xuICAgICAgcmFkaXVzOiA4XG4gICAgfVxuICB9LFxuICBtOiB7XG4gICAgc2xpZGVyOiB7XG4gICAgICBoZWlnaHQ6IDE0LFxuICAgICAgd2lkdGg6IDI3MlxuICAgIH0sXG4gICAgY29sb3JGaWVsZDoge1xuICAgICAgaGVpZ2h0OiAxNTAsXG4gICAgICB3aWR0aDogMjcyXG4gICAgfSxcbiAgICB0aHVtYjoge1xuICAgICAgcmFkaXVzOiAxMFxuICAgIH1cbiAgfSxcbiAgbDoge1xuICAgIHNsaWRlcjoge1xuICAgICAgaGVpZ2h0OiAxNixcbiAgICAgIHdpZHRoOiA0NjRcbiAgICB9LFxuICAgIGNvbG9yRmllbGQ6IHtcbiAgICAgIGhlaWdodDogMjAwLFxuICAgICAgd2lkdGg6IDQ2NFxuICAgIH0sXG4gICAgdGh1bWI6IHtcbiAgICAgIHJhZGl1czogMTJcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNvbG9yUGlja2VyQ3NzID0gXCJAa2V5ZnJhbWVzIGluezAle29wYWNpdHk6MH0xMDAle29wYWNpdHk6MX19QGtleWZyYW1lcyBpbi1kb3duezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgLTVweCwgMCl9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZTNEKDAsIDAsIDApfX1Aa2V5ZnJhbWVzIGluLXVwezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgNXB4LCAwKX0xMDAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM0QoMCwgMCwgMCl9fUBrZXlmcmFtZXMgaW4tc2NhbGV7MCV7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNEKDAuOTUsIDAuOTUsIDEpfTEwMCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNEKDEsIDEsIDEpfX06cm9vdHstLWNhbGNpdGUtYW5pbWF0aW9uLXRpbWluZzpjYWxjKDE1MG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtZHVyYXRpb24tZmFjdG9yOnZhcigtLWNhbGNpdGUtZHVyYXRpb24tZmFjdG9yLCAxKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1mYXN0OmNhbGMoMTAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpOy0tY2FsY2l0ZS1pbnRlcm5hbC1hbmltYXRpb24tdGltaW5nLW1lZGl1bTpjYWxjKDIwMG1zICogdmFyKC0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3IpKTstLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1zbG93OmNhbGMoMzAwbXMgKiB2YXIoLS1jYWxjaXRlLWludGVybmFsLWR1cmF0aW9uLWZhY3RvcikpfS5jYWxjaXRlLWFuaW1hdGV7b3BhY2l0eTowO2FuaW1hdGlvbi1maWxsLW1vZGU6Ym90aDthbmltYXRpb24tZHVyYXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKX0uY2FsY2l0ZS1hbmltYXRlX19pbnthbmltYXRpb24tbmFtZTppbn0uY2FsY2l0ZS1hbmltYXRlX19pbi1kb3due2FuaW1hdGlvbi1uYW1lOmluLWRvd259LmNhbGNpdGUtYW5pbWF0ZV9faW4tdXB7YW5pbWF0aW9uLW5hbWU6aW4tdXB9LmNhbGNpdGUtYW5pbWF0ZV9faW4tc2NhbGV7YW5pbWF0aW9uLW5hbWU6aW4tc2NhbGV9QG1lZGlhIChwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2Upezpyb290ey0tY2FsY2l0ZS1pbnRlcm5hbC1kdXJhdGlvbi1mYWN0b3I6MH19OnJvb3R7LS1jYWxjaXRlLWZsb2F0aW5nLXVpLXRyYW5zaXRpb246dmFyKC0tY2FsY2l0ZS1hbmltYXRpb24tdGltaW5nKTstLWNhbGNpdGUtZmxvYXRpbmctdWktei1pbmRleDo2MDB9Omhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX06aG9zdChbZGlzYWJsZWRdKXtwb2ludGVyLWV2ZW50czpub25lO2N1cnNvcjpkZWZhdWx0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO29wYWNpdHk6dmFyKC0tY2FsY2l0ZS11aS1vcGFjaXR5LWRpc2FibGVkKX06aG9zdHtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTIpO2xpbmUtaGVpZ2h0OjFyZW07Zm9udC13ZWlnaHQ6dmFyKC0tY2FsY2l0ZS1mb250LXdlaWdodC1ub3JtYWwpfTpob3N0KFtkaXNhYmxlZF0pIDo6c2xvdHRlZChbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRdKSw6aG9zdChbZGlzYWJsZWRdKSBbY2FsY2l0ZS1oeWRyYXRlZF1bZGlzYWJsZWRde29wYWNpdHk6MX06aG9zdChbc2NhbGU9c10pIC5jb250YWluZXJ7aW5saW5lLXNpemU6MTYwcHh9Omhvc3QoW3NjYWxlPXNdKSAuc2F2ZWQtY29sb3Jze2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoYXV0by1maWxsLCBtaW5tYXgoMjBweCwgMWZyKSl9Omhvc3QoW3NjYWxlPXNdKSAuY2hhbm5lbHN7ZmxleC1kaXJlY3Rpb246Y29sdW1ufTpob3N0KFtzY2FsZT1zXSkgLmNoYW5uZWx7aW5saW5lLXNpemU6MTAwJTttYXJnaW4tYmxvY2stZW5kOjRweH06aG9zdChbc2NhbGU9c10pIC5jaGFubmVsOmxhc3QtY2hpbGR7bWFyZ2luLWJsb2NrLWVuZDowfTpob3N0KFtzY2FsZT1tXSkgLmNvbnRhaW5lcntpbmxpbmUtc2l6ZToyNzJweH06aG9zdChbc2NhbGU9bF0pIC5oZWFkZXJ7cGFkZGluZy1ibG9jay1lbmQ6MHB4fTpob3N0KFtzY2FsZT1sXSl7Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0xKTtsaW5lLWhlaWdodDoxcmVtfTpob3N0KFtzY2FsZT1sXSkgLmNvbnRhaW5lcntpbmxpbmUtc2l6ZTo0NjRweH06aG9zdChbc2NhbGU9bF0pIC5jb2xvci1maWVsZC1hbmQtc2xpZGVye21hcmdpbi1ibG9jay1lbmQ6LTIwcHh9Omhvc3QoW3NjYWxlPWxdKSAuc2VjdGlvbntwYWRkaW5nLWJsb2NrOjAgMTZweDtwYWRkaW5nLWlubGluZToxNnB4fTpob3N0KFtzY2FsZT1sXSkgLnNlY3Rpb246Zmlyc3Qtb2YtdHlwZXtwYWRkaW5nLWJsb2NrLXN0YXJ0OjE2cHh9Omhvc3QoW3NjYWxlPWxdKSAuc2F2ZWQtY29sb3Jze2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoYXV0by1maWxsLCBtaW5tYXgoMjhweCwgMWZyKSk7Z3JpZC1nYXA6MTJweDtwYWRkaW5nLWJsb2NrLXN0YXJ0OjE2cHh9Omhvc3QoW3NjYWxlPWxdKSAuY29udHJvbC1zZWN0aW9ue2ZsZXgtd3JhcDpub3dyYXA7YWxpZ24taXRlbXM6YmFzZWxpbmV9Omhvc3QoW3NjYWxlPWxdKSAuY29udHJvbC1zZWN0aW9uPjpudGgtY2hpbGQoMil7bWFyZ2luLWlubGluZS1zdGFydDoxMnB4fTpob3N0KFtzY2FsZT1sXSkgLmNvbG9yLWhleC1vcHRpb25ze2Rpc3BsYXk6ZmxleDtmbGV4LXNocmluazoxO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYXJvdW5kO21pbi1ibG9jay1zaXplOjk4cHg7aW5saW5lLXNpemU6MTYwcHh9Omhvc3QoW3NjYWxlPWxdKSAuY29sb3ItbW9kZS1jb250YWluZXJ7ZmxleC1zaHJpbms6M30uY29udGFpbmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tY2FsY2l0ZS11aS1mb3JlZ3JvdW5kLTEpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JvcmRlcjoxcHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1ib3JkZXItMSl9LmNvbG9yLWZpZWxkLWFuZC1zbGlkZXItd3JhcHtwb3NpdGlvbjpyZWxhdGl2ZX0uc2NvcGV7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTEpO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7b3V0bGluZS1vZmZzZXQ6MTRweH0uc2NvcGU6Zm9jdXN7b3V0bGluZToycHggc29saWQgdmFyKC0tY2FsY2l0ZS11aS1icmFuZCk7b3V0bGluZS1vZmZzZXQ6MTZweH0uY29sb3ItZmllbGQtYW5kLXNsaWRlcnttYXJnaW4tYmxvY2stZW5kOi0xNnB4O3RvdWNoLWFjdGlvbjpub25lfS5jb2xvci1maWVsZC1hbmQtc2xpZGVyLS1pbnRlcmFjdGl2ZXtjdXJzb3I6cG9pbnRlcn0uY29udHJvbC1zZWN0aW9ue2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC13cmFwOndyYXB9LnNlY3Rpb257cGFkZGluZy1ibG9jazowIDEycHg7cGFkZGluZy1pbmxpbmU6MTJweH0uc2VjdGlvbjpmaXJzdC1vZi10eXBle3BhZGRpbmctYmxvY2stc3RhcnQ6MTJweH0uY29sb3ItaGV4LW9wdGlvbnMsLnNlY3Rpb24tLXNwbGl0e2ZsZXgtZ3JvdzoxfS5oZWFkZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtwYWRkaW5nLWJsb2NrLWVuZDowLjI1cmVtO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0xKX0uaGVhZGVyLS1oZXgsLmNvbG9yLW1vZGUtY29udGFpbmVye3BhZGRpbmctYmxvY2stc3RhcnQ6MTJweH0uY2hhbm5lbHN7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5jaGFubmVse2lubGluZS1zaXplOjMxJX0uc2F2ZWQtY29sb3Jze3BhZGRpbmctYmxvY2stc3RhcnQ6MTJweDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOnJlcGVhdChhdXRvLWZpbGwsIG1pbm1heCgyNHB4LCAxZnIpKTtncmlkLWdhcDo4cHg7aW5saW5lLXNpemU6MTAwJX0uc2F2ZWQtY29sb3JzLWJ1dHRvbnN7ZGlzcGxheTpmbGV4fS5zYXZlZC1jb2xvcntvdXRsaW5lLW9mZnNldDowO291dGxpbmUtY29sb3I6dHJhbnNwYXJlbnQ7Y3Vyc29yOnBvaW50ZXJ9LnNhdmVkLWNvbG9yOmZvY3Vze291dGxpbmU6MnB4IHNvbGlkIHZhcigtLWNhbGNpdGUtdWktYnJhbmQpO291dGxpbmUtb2Zmc2V0OjJweH0uc2F2ZWQtY29sb3I6aG92ZXJ7dHJhbnNpdGlvbjpvdXRsaW5lLWNvbG9yIHZhcigtLWNhbGNpdGUtaW50ZXJuYWwtYW5pbWF0aW9uLXRpbWluZy1mYXN0KSBlYXNlLWluLW91dDtvdXRsaW5lOjJweCBzb2xpZCB2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0yKTtvdXRsaW5lLW9mZnNldDoycHh9XCI7XG5cbmNvbnN0IHRocm90dGxlRm9yNjBGcHNJbk1zID0gMTY7XHJcbmNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5vcm1hbGl6ZUhleChERUZBVUxUX0NPTE9SLmhleCgpKTtcclxuY29uc3QgZGVmYXVsdEZvcm1hdCA9IFwiYXV0b1wiO1xyXG5jb25zdCBDb2xvclBpY2tlciA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XHJcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xyXG4gICAgdGhpcy5jYWxjaXRlQ29sb3JQaWNrZXJDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVDb2xvclBpY2tlckNoYW5nZVwiLCA2KTtcclxuICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VySW5wdXQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVDb2xvclBpY2tlcklucHV0XCIsIDYpO1xyXG4gICAgdGhpcy5jb2xvckZpZWxkQW5kU2xpZGVySG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5odWVUaHVtYlN0YXRlID0gXCJpZGxlXCI7XHJcbiAgICB0aGlzLmludGVybmFsQ29sb3JVcGRhdGVDb250ZXh0ID0gbnVsbDtcclxuICAgIHRoaXMubW9kZSA9IENTU0NvbG9yTW9kZS5IRVg7XHJcbiAgICB0aGlzLnNoaWZ0S2V5Q2hhbm5lbEFkanVzdG1lbnQgPSAwO1xyXG4gICAgdGhpcy5zbGlkZXJUaHVtYlN0YXRlID0gXCJpZGxlXCI7XHJcbiAgICB0aGlzLmhhbmRsZVRhYkFjdGl2YXRlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIHRoaXMuY2hhbm5lbE1vZGUgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3ItbW9kZVwiKTtcclxuICAgICAgdGhpcy51cGRhdGVDaGFubmVsc0Zyb21Db2xvcih0aGlzLmNvbG9yKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZUNvbG9yRmllbGRTY29wZUtleURvd24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgeyBrZXkgfSA9IGV2ZW50O1xyXG4gICAgICBjb25zdCBhcnJvd0tleVRvWFlPZmZzZXQgPSB7XHJcbiAgICAgICAgQXJyb3dVcDogeyB4OiAwLCB5OiAtMTAgfSxcclxuICAgICAgICBBcnJvd1JpZ2h0OiB7IHg6IDEwLCB5OiAwIH0sXHJcbiAgICAgICAgQXJyb3dEb3duOiB7IHg6IDAsIHk6IDEwIH0sXHJcbiAgICAgICAgQXJyb3dMZWZ0OiB7IHg6IC0xMCwgeTogMCB9XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChhcnJvd0tleVRvWFlPZmZzZXRba2V5XSkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5zY29wZU9yaWVudGF0aW9uID0ga2V5ID09PSBcIkFycm93RG93blwiIHx8IGtleSA9PT0gXCJBcnJvd1VwXCIgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIjtcclxuICAgICAgICB0aGlzLmNhcHR1cmVDb2xvckZpZWxkQ29sb3IodGhpcy5jb2xvckZpZWxkU2NvcGVMZWZ0ICsgYXJyb3dLZXlUb1hZT2Zmc2V0W2tleV0ueCB8fCAwLCB0aGlzLmNvbG9yRmllbGRTY29wZVRvcCArIGFycm93S2V5VG9YWU9mZnNldFtrZXldLnkgfHwgMCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVIdWVTY29wZUtleURvd24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgbW9kaWZpZXIgPSBldmVudC5zaGlmdEtleSA/IDEwIDogMTtcclxuICAgICAgY29uc3QgeyBrZXkgfSA9IGV2ZW50O1xyXG4gICAgICBjb25zdCBhcnJvd0tleVRvWE9mZnNldCA9IHtcclxuICAgICAgICBBcnJvd1VwOiAxLFxyXG4gICAgICAgIEFycm93UmlnaHQ6IDEsXHJcbiAgICAgICAgQXJyb3dEb3duOiAtMSxcclxuICAgICAgICBBcnJvd0xlZnQ6IC0xXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChhcnJvd0tleVRvWE9mZnNldFtrZXldKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBjb25zdCBkZWx0YSA9IGFycm93S2V5VG9YT2Zmc2V0W2tleV0gKiBtb2RpZmllcjtcclxuICAgICAgICBjb25zdCBodWUgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHVlKCk7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHVlKGh1ZSArIGRlbHRhKTtcclxuICAgICAgICB0aGlzLmludGVybmFsQ29sb3JTZXQoY29sb3IsIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlSGV4SW5wdXRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIGNvbnN0IHsgYWxsb3dFbXB0eSwgY29sb3I6IGNvbG9yJDEgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IGlucHV0ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICBjb25zdCBoZXggPSBpbnB1dC52YWx1ZTtcclxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgIWhleCkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChudWxsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgbm9ybWFsaXplZEhleCA9IGNvbG9yJDEgJiYgbm9ybWFsaXplSGV4KGNvbG9yJDEuaGV4KCkpO1xyXG4gICAgICBpZiAoaGV4ICE9PSBub3JtYWxpemVkSGV4KSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGNvbG9yKGhleCkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVTYXZlZENvbG9yU2VsZWN0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHN3YXRjaCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvcihzd2F0Y2guY29sb3IpKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZUNoYW5uZWxJbnB1dCA9IChldmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBpbnB1dCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgIGNvbnN0IGNoYW5uZWxJbmRleCA9IE51bWJlcihpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNoYW5uZWwtaW5kZXhcIikpO1xyXG4gICAgICBjb25zdCBsaW1pdCA9IHRoaXMuY2hhbm5lbE1vZGUgPT09IFwicmdiXCJcclxuICAgICAgICA/IFJHQl9MSU1JVFNbT2JqZWN0LmtleXMoUkdCX0xJTUlUUylbY2hhbm5lbEluZGV4XV1cclxuICAgICAgICA6IEhTVl9MSU1JVFNbT2JqZWN0LmtleXMoSFNWX0xJTUlUUylbY2hhbm5lbEluZGV4XV07XHJcbiAgICAgIGxldCBpbnB1dFZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5hbGxvd0VtcHR5ICYmICFpbnB1dC52YWx1ZSkge1xyXG4gICAgICAgIGlucHV0VmFsdWUgPSBcIlwiO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKGlucHV0LnZhbHVlKSArIHRoaXMuc2hpZnRLZXlDaGFubmVsQWRqdXN0bWVudDtcclxuICAgICAgICBjb25zdCBjbGFtcGVkID0gY2xhbXAodmFsdWUsIDAsIGxpbWl0KTtcclxuICAgICAgICBpbnB1dFZhbHVlID0gY2xhbXBlZC50b1N0cmluZygpO1xyXG4gICAgICB9XHJcbiAgICAgIGlucHV0LnZhbHVlID0gaW5wdXRWYWx1ZTtcclxuICAgICAgLy8gVE9ETzogcmVmYWN0b3IgY2FsY2l0ZS1pbnB1dCBzbyB3ZSBkb24ndCBuZWVkIHRvIHN5bmMgdGhlIGludGVybmFsc1xyXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvaXNzdWVzLzYxMDBcclxuICAgICAgaW5wdXQuaW50ZXJuYWxTeW5jQ2hpbGRFbFZhbHVlKCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVDaGFubmVsQ2hhbmdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGlucHV0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgICAgY29uc3QgY2hhbm5lbEluZGV4ID0gTnVtYmVyKGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtY2hhbm5lbC1pbmRleFwiKSk7XHJcbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gWy4uLnRoaXMuY2hhbm5lbHNdO1xyXG4gICAgICBjb25zdCBzaG91bGRDbGVhckNoYW5uZWxzID0gdGhpcy5hbGxvd0VtcHR5ICYmICFpbnB1dC52YWx1ZTtcclxuICAgICAgaWYgKHNob3VsZENsZWFyQ2hhbm5lbHMpIHtcclxuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW251bGwsIG51bGwsIG51bGxdO1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChudWxsKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY2hhbm5lbHNbY2hhbm5lbEluZGV4XSA9IE51bWJlcihpbnB1dC52YWx1ZSk7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29sb3JGcm9tQ2hhbm5lbHMoY2hhbm5lbHMpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlU2F2ZWRDb2xvcktleURvd24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgaWYgKGlzQWN0aXZhdGlvbktleShldmVudC5rZXkpKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLmhhbmRsZVNhdmVkQ29sb3JTZWxlY3QoZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVDb2xvckZpZWxkQW5kU2xpZGVyUG9pbnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJJbnRlcmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJIb3ZlcmVkID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnNsaWRlclRodW1iU3RhdGUgIT09IFwiZHJhZ1wiICYmIHRoaXMuaHVlVGh1bWJTdGF0ZSAhPT0gXCJkcmFnXCIpIHtcclxuICAgICAgICB0aGlzLmh1ZVRodW1iU3RhdGUgPSBcImlkbGVcIjtcclxuICAgICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImlkbGVcIjtcclxuICAgICAgICB0aGlzLmRyYXdDb2xvckZpZWxkQW5kU2xpZGVyKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZUNvbG9yRmllbGRBbmRTbGlkZXJQb2ludGVyRG93biA9IChldmVudCkgPT4ge1xyXG4gICAgICBpZiAoIWlzUHJpbWFyeVBvaW50ZXJCdXR0b24oZXZlbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XHJcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0Q2FudmFzUmVnaW9uKG9mZnNldFkpO1xyXG4gICAgICBpZiAocmVnaW9uID09PSBcImNvbG9yLWZpZWxkXCIpIHtcclxuICAgICAgICB0aGlzLmh1ZVRodW1iU3RhdGUgPSBcImRyYWdcIjtcclxuICAgICAgICB0aGlzLmNhcHR1cmVDb2xvckZpZWxkQ29sb3Iob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgdGhpcy5jb2xvckZpZWxkU2NvcGVOb2RlPy5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHJlZ2lvbiA9PT0gXCJzbGlkZXJcIikge1xyXG4gICAgICAgIHRoaXMuc2xpZGVyVGh1bWJTdGF0ZSA9IFwiZHJhZ1wiO1xyXG4gICAgICAgIHRoaXMuY2FwdHVyZUh1ZVNsaWRlckNvbG9yKG9mZnNldFgpO1xyXG4gICAgICAgIHRoaXMuaHVlU2NvcGVOb2RlPy5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gb3V0c2lkZSBvZiBjb2xvciBmaWVsZCAmIHNsaWRlciBhcmVhXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLmdsb2JhbFBvaW50ZXJNb3ZlSGFuZGxlcik7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5nbG9iYWxQb2ludGVyVXBIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XHJcbiAgICAgIHRoaXMuYWN0aXZlQ29sb3JGaWVsZEFuZFNsaWRlclJlY3QgPVxyXG4gICAgICAgIHRoaXMuZmllbGRBbmRTbGlkZXJSZW5kZXJpbmdDb250ZXh0LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmdsb2JhbFBvaW50ZXJVcEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcclxuICAgICAgaWYgKCFpc1ByaW1hcnlQb2ludGVyQnV0dG9uKGV2ZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBwcmV2aW91c2x5RHJhZ2dpbmcgPSB0aGlzLnNsaWRlclRodW1iU3RhdGUgPT09IFwiZHJhZ1wiIHx8IHRoaXMuaHVlVGh1bWJTdGF0ZSA9PT0gXCJkcmFnXCI7XHJcbiAgICAgIHRoaXMuaHVlVGh1bWJTdGF0ZSA9IFwiaWRsZVwiO1xyXG4gICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImlkbGVcIjtcclxuICAgICAgdGhpcy5hY3RpdmVDb2xvckZpZWxkQW5kU2xpZGVyUmVjdCA9IG51bGw7XHJcbiAgICAgIHRoaXMuZHJhd0NvbG9yRmllbGRBbmRTbGlkZXIoKTtcclxuICAgICAgaWYgKHByZXZpb3VzbHlEcmFnZ2luZykge1xyXG4gICAgICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VyQ2hhbmdlLmVtaXQoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuZ2xvYmFsUG9pbnRlck1vdmVIYW5kbGVyID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgZWwsIGRpbWVuc2lvbnMgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IHNsaWRlclRodW1iRHJhZ2dpbmcgPSB0aGlzLnNsaWRlclRodW1iU3RhdGUgPT09IFwiZHJhZ1wiO1xyXG4gICAgICBjb25zdCBodWVUaHVtYkRyYWdnaW5nID0gdGhpcy5odWVUaHVtYlN0YXRlID09PSBcImRyYWdcIjtcclxuICAgICAgaWYgKCFlbC5pc0Nvbm5lY3RlZCB8fCAoIXNsaWRlclRodW1iRHJhZ2dpbmcgJiYgIWh1ZVRodW1iRHJhZ2dpbmcpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBzYW1wbGluZ1g7XHJcbiAgICAgIGxldCBzYW1wbGluZ1k7XHJcbiAgICAgIGNvbnN0IGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0ID0gdGhpcy5hY3RpdmVDb2xvckZpZWxkQW5kU2xpZGVyUmVjdDtcclxuICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBldmVudDtcclxuICAgICAgaWYgKHRoaXMuY29sb3JGaWVsZEFuZFNsaWRlckhvdmVyZWQpIHtcclxuICAgICAgICBzYW1wbGluZ1ggPSBjbGllbnRYIC0gY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueDtcclxuICAgICAgICBzYW1wbGluZ1kgPSBjbGllbnRZIC0gY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb2xvckZpZWxkV2lkdGggPSBkaW1lbnNpb25zLmNvbG9yRmllbGQud2lkdGg7XHJcbiAgICAgICAgY29uc3QgY29sb3JGaWVsZEhlaWdodCA9IGRpbWVuc2lvbnMuY29sb3JGaWVsZC5oZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgaHVlU2xpZGVySGVpZ2h0ID0gZGltZW5zaW9ucy5zbGlkZXIuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChjbGllbnRYIDwgY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueCArIGNvbG9yRmllbGRXaWR0aCAmJlxyXG4gICAgICAgICAgY2xpZW50WCA+IGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0LngpIHtcclxuICAgICAgICAgIHNhbXBsaW5nWCA9IGNsaWVudFggLSBjb2xvckZpZWxkQW5kU2xpZGVyUmVjdC54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbGllbnRYIDwgY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueCkge1xyXG4gICAgICAgICAgc2FtcGxpbmdYID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBzYW1wbGluZ1ggPSBjb2xvckZpZWxkV2lkdGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xpZW50WSA8IGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0LnkgKyBjb2xvckZpZWxkSGVpZ2h0ICsgaHVlU2xpZGVySGVpZ2h0ICYmXHJcbiAgICAgICAgICBjbGllbnRZID4gY29sb3JGaWVsZEFuZFNsaWRlclJlY3QueSkge1xyXG4gICAgICAgICAgc2FtcGxpbmdZID0gY2xpZW50WSAtIGNvbG9yRmllbGRBbmRTbGlkZXJSZWN0Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNsaWVudFkgPCBjb2xvckZpZWxkQW5kU2xpZGVyUmVjdC55KSB7XHJcbiAgICAgICAgICBzYW1wbGluZ1kgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHNhbXBsaW5nWSA9IGNvbG9yRmllbGRIZWlnaHQgKyBodWVTbGlkZXJIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChodWVUaHVtYkRyYWdnaW5nKSB7XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlQ29sb3JGaWVsZENvbG9yKHNhbXBsaW5nWCwgc2FtcGxpbmdZLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jYXB0dXJlSHVlU2xpZGVyQ29sb3Ioc2FtcGxpbmdYKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlQ29sb3JGaWVsZEFuZFNsaWRlclBvaW50ZXJFbnRlck9yTW92ZSA9ICh7IG9mZnNldFgsIG9mZnNldFkgfSkgPT4ge1xyXG4gICAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHsgY29sb3JGaWVsZCwgc2xpZGVyLCB0aHVtYiB9IH0gPSB0aGlzO1xyXG4gICAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJJbnRlcmFjdGl2ZSA9IG9mZnNldFkgPD0gY29sb3JGaWVsZC5oZWlnaHQgKyBzbGlkZXIuaGVpZ2h0O1xyXG4gICAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJIb3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRDYW52YXNSZWdpb24ob2Zmc2V0WSk7XHJcbiAgICAgIGlmIChyZWdpb24gPT09IFwiY29sb3ItZmllbGRcIikge1xyXG4gICAgICAgIGNvbnN0IHByZXZIdWVUaHVtYlN0YXRlID0gdGhpcy5odWVUaHVtYlN0YXRlO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5iYXNlQ29sb3JGaWVsZENvbG9yLmhzdigpO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBNYXRoLnJvdW5kKGNvbG9yLnNhdHVyYXRpb252KCkgLyAoSFNWX0xJTUlUUy5zIC8gY29sb3JGaWVsZC53aWR0aCkpO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBNYXRoLnJvdW5kKGNvbG9yRmllbGQuaGVpZ2h0IC0gY29sb3IudmFsdWUoKSAvIChIU1ZfTElNSVRTLnYgLyBjb2xvckZpZWxkLmhlaWdodCkpO1xyXG4gICAgICAgIGNvbnN0IGhvdmVyaW5nVGh1bWIgPSB0aGlzLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSwgY2VudGVyWCwgY2VudGVyWSwgdGh1bWIucmFkaXVzKTtcclxuICAgICAgICBsZXQgdHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChwcmV2SHVlVGh1bWJTdGF0ZSA9PT0gXCJpZGxlXCIgJiYgaG92ZXJpbmdUaHVtYikge1xyXG4gICAgICAgICAgdGhpcy5odWVUaHVtYlN0YXRlID0gXCJob3ZlclwiO1xyXG4gICAgICAgICAgdHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByZXZIdWVUaHVtYlN0YXRlID09PSBcImhvdmVyXCIgJiYgIWhvdmVyaW5nVGh1bWIpIHtcclxuICAgICAgICAgIHRoaXMuaHVlVGh1bWJTdGF0ZSA9IFwiaWRsZVwiO1xyXG4gICAgICAgICAgdHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmh1ZVRodW1iU3RhdGUgIT09IFwiZHJhZ1wiKSB7XHJcbiAgICAgICAgICBpZiAodHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSkge1xyXG4gICAgICAgICAgICAvLyByZWZyZXNoIHNpbmNlIHdlIHdvbid0IHVwZGF0ZSBjb2xvciBhbmQgdGh1cyBubyByZWRyYXdcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q29sb3JGaWVsZEFuZFNsaWRlcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChyZWdpb24gPT09IFwic2xpZGVyXCIpIHtcclxuICAgICAgICBjb25zdCBzbGlkZXJUaHVtYkNvbG9yID0gdGhpcy5iYXNlQ29sb3JGaWVsZENvbG9yLmhzdigpLnNhdHVyYXRpb252KDEwMCkudmFsdWUoMTAwKTtcclxuICAgICAgICBjb25zdCBwcmV2U2xpZGVyVGh1bWJTdGF0ZSA9IHRoaXMuc2xpZGVyVGh1bWJTdGF0ZTtcclxuICAgICAgICBjb25zdCBzbGlkZXJUaHVtYkNlbnRlclggPSBNYXRoLnJvdW5kKHNsaWRlclRodW1iQ29sb3IuaHVlKCkgLyAoMzYwIC8gc2xpZGVyLndpZHRoKSk7XHJcbiAgICAgICAgY29uc3Qgc2xpZGVyVGh1bWJDZW50ZXJZID0gTWF0aC5yb3VuZCgoc2xpZGVyLmhlaWdodCArIHRoaXMuZ2V0U2xpZGVyQ2FwU3BhY2luZygpKSAvIDIpICsgY29sb3JGaWVsZC5oZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgaG92ZXJpbmdTbGlkZXJUaHVtYiA9IHRoaXMuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZLCBzbGlkZXJUaHVtYkNlbnRlclgsIHNsaWRlclRodW1iQ2VudGVyWSwgdGh1bWIucmFkaXVzKTtcclxuICAgICAgICBsZXQgc2xpZGVyVGh1bWJUcmFuc2l0aW9uZWRCZXR3ZWVuSG92ZXJBbmRJZGxlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHByZXZTbGlkZXJUaHVtYlN0YXRlID09PSBcImlkbGVcIiAmJiBob3ZlcmluZ1NsaWRlclRodW1iKSB7XHJcbiAgICAgICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImhvdmVyXCI7XHJcbiAgICAgICAgICBzbGlkZXJUaHVtYlRyYW5zaXRpb25lZEJldHdlZW5Ib3ZlckFuZElkbGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcmV2U2xpZGVyVGh1bWJTdGF0ZSA9PT0gXCJob3ZlclwiICYmICFob3ZlcmluZ1NsaWRlclRodW1iKSB7XHJcbiAgICAgICAgICB0aGlzLnNsaWRlclRodW1iU3RhdGUgPSBcImlkbGVcIjtcclxuICAgICAgICAgIHNsaWRlclRodW1iVHJhbnNpdGlvbmVkQmV0d2VlbkhvdmVyQW5kSWRsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNsaWRlclRodW1iU3RhdGUgIT09IFwiZHJhZ1wiKSB7XHJcbiAgICAgICAgICBpZiAoc2xpZGVyVGh1bWJUcmFuc2l0aW9uZWRCZXR3ZWVuSG92ZXJBbmRJZGxlKSB7XHJcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggc2luY2Ugd2Ugd29uJ3QgdXBkYXRlIGNvbG9yIGFuZCB0aHVzIG5vIHJlZHJhd1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDb2xvckZpZWxkQW5kU2xpZGVyKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zdG9yZUNvbG9yRmllbGRTY29wZSA9IChub2RlKSA9PiB7XHJcbiAgICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlTm9kZSA9IG5vZGU7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zdG9yZUh1ZVNjb3BlID0gKG5vZGUpID0+IHtcclxuICAgICAgdGhpcy5odWVTY29wZU5vZGUgPSBub2RlO1xyXG4gICAgfTtcclxuICAgIHRoaXMucmVuZGVyQ2hhbm5lbHNUYWJUaXRsZSA9IChjaGFubmVsTW9kZSkgPT4ge1xyXG4gICAgICBjb25zdCB7IGNoYW5uZWxNb2RlOiBhY3RpdmVDaGFubmVsTW9kZSwgbWVzc2FnZXMgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gY2hhbm5lbE1vZGUgPT09IGFjdGl2ZUNoYW5uZWxNb2RlO1xyXG4gICAgICBjb25zdCBsYWJlbCA9IGNoYW5uZWxNb2RlID09PSBcInJnYlwiID8gbWVzc2FnZXMucmdiIDogbWVzc2FnZXMuaHN2O1xyXG4gICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLXRhYi10aXRsZVwiLCB7IGNsYXNzOiBDU1MuY29sb3JNb2RlLCBcImRhdGEtY29sb3ItbW9kZVwiOiBjaGFubmVsTW9kZSwga2V5OiBjaGFubmVsTW9kZSwgb25DYWxjaXRlVGFic0FjdGl2YXRlOiB0aGlzLmhhbmRsZVRhYkFjdGl2YXRlLCBzZWxlY3RlZDogc2VsZWN0ZWQgfSwgbGFiZWwpKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnJlbmRlckNoYW5uZWxzVGFiID0gKGNoYW5uZWxNb2RlKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgY2hhbm5lbE1vZGU6IGFjdGl2ZUNoYW5uZWxNb2RlLCBjaGFubmVscywgbWVzc2FnZXMgfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gY2hhbm5lbE1vZGUgPT09IGFjdGl2ZUNoYW5uZWxNb2RlO1xyXG4gICAgICBjb25zdCBpc1JnYiA9IGNoYW5uZWxNb2RlID09PSBcInJnYlwiO1xyXG4gICAgICBjb25zdCBjaGFubmVsTGFiZWxzID0gaXNSZ2JcclxuICAgICAgICA/IFttZXNzYWdlcy5yLCBtZXNzYWdlcy5nLCBtZXNzYWdlcy5iXVxyXG4gICAgICAgIDogW21lc3NhZ2VzLmgsIG1lc3NhZ2VzLnMsIG1lc3NhZ2VzLnZdO1xyXG4gICAgICBjb25zdCBjaGFubmVsQXJpYUxhYmVscyA9IGlzUmdiXHJcbiAgICAgICAgPyBbbWVzc2FnZXMucmVkLCBtZXNzYWdlcy5ncmVlbiwgbWVzc2FnZXMuYmx1ZV1cclxuICAgICAgICA6IFttZXNzYWdlcy5odWUsIG1lc3NhZ2VzLnNhdHVyYXRpb24sIG1lc3NhZ2VzLnZhbHVlXTtcclxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0RWxlbWVudERpcih0aGlzLmVsKTtcclxuICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS10YWJcIiwgeyBjbGFzczogQ1NTLmNvbnRyb2wsIGtleTogY2hhbm5lbE1vZGUsIHNlbGVjdGVkOiBzZWxlY3RlZCB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5jaGFubmVscywgZGlyOiBcImx0clwiIH0sIGNoYW5uZWxzLm1hcCgoY2hhbm5lbCwgaW5kZXgpID0+IFxyXG4gICAgICAvKiB0aGUgY2hhbm5lbCBjb250YWluZXIgaXMgbHRyLCBzbyB3ZSBhcHBseSB0aGUgaG9zdCdzIGRpcmVjdGlvbiAqL1xyXG4gICAgICB0aGlzLnJlbmRlckNoYW5uZWwoY2hhbm5lbCwgaW5kZXgsIGNoYW5uZWxMYWJlbHNbaW5kZXhdLCBjaGFubmVsQXJpYUxhYmVsc1tpbmRleF0sIGRpcmVjdGlvbikpKSkpO1xyXG4gICAgfTtcclxuICAgIHRoaXMucmVuZGVyQ2hhbm5lbCA9ICh2YWx1ZSwgaW5kZXgsIGxhYmVsLCBhcmlhTGFiZWwsIGRpcmVjdGlvbikgPT4gKGgoXCJjYWxjaXRlLWlucHV0XCIsIHsgY2xhc3M6IENTUy5jaGFubmVsLCBcImRhdGEtY2hhbm5lbC1pbmRleFwiOiBpbmRleCwgZGlyOiBkaXJlY3Rpb24sIGxhYmVsOiBhcmlhTGFiZWwsIGxhbmc6IHRoaXMuZWZmZWN0aXZlTG9jYWxlLCBudW1iZXJCdXR0b25UeXBlOiBcIm5vbmVcIiwgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLm51bWJlcmluZ1N5c3RlbSwgb25DYWxjaXRlSW5wdXRDaGFuZ2U6IHRoaXMuaGFuZGxlQ2hhbm5lbENoYW5nZSwgb25DYWxjaXRlSW5wdXRJbnB1dDogdGhpcy5oYW5kbGVDaGFubmVsSW5wdXQsIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLCBwcmVmaXhUZXh0OiBsYWJlbCwgc2NhbGU6IHRoaXMuc2NhbGUgPT09IFwibFwiID8gXCJtXCIgOiBcInNcIiwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IHZhbHVlPy50b1N0cmluZygpIH0pKTtcclxuICAgIHRoaXMuZGVsZXRlQ29sb3IgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbG9yVG9EZWxldGUgPSB0aGlzLmNvbG9yLmhleCgpO1xyXG4gICAgICBjb25zdCBpblN0b3JhZ2UgPSB0aGlzLnNhdmVkQ29sb3JzLmluZGV4T2YoY29sb3JUb0RlbGV0ZSkgPiAtMTtcclxuICAgICAgaWYgKCFpblN0b3JhZ2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2F2ZWRDb2xvcnMgPSB0aGlzLnNhdmVkQ29sb3JzLmZpbHRlcigoY29sb3IpID0+IGNvbG9yICE9PSBjb2xvclRvRGVsZXRlKTtcclxuICAgICAgdGhpcy5zYXZlZENvbG9ycyA9IHNhdmVkQ29sb3JzO1xyXG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gYCR7REVGQVVMVF9TVE9SQUdFX0tFWV9QUkVGSVh9JHt0aGlzLnN0b3JhZ2VJZH1gO1xyXG4gICAgICBpZiAodGhpcy5zdG9yYWdlSWQpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeShzYXZlZENvbG9ycykpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zYXZlQ29sb3IgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbG9yVG9TYXZlID0gdGhpcy5jb2xvci5oZXgoKTtcclxuICAgICAgY29uc3QgYWxyZWFkeVNhdmVkID0gdGhpcy5zYXZlZENvbG9ycy5pbmRleE9mKGNvbG9yVG9TYXZlKSA+IC0xO1xyXG4gICAgICBpZiAoYWxyZWFkeVNhdmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNhdmVkQ29sb3JzID0gWy4uLnRoaXMuc2F2ZWRDb2xvcnMsIGNvbG9yVG9TYXZlXTtcclxuICAgICAgdGhpcy5zYXZlZENvbG9ycyA9IHNhdmVkQ29sb3JzO1xyXG4gICAgICBjb25zdCBzdG9yYWdlS2V5ID0gYCR7REVGQVVMVF9TVE9SQUdFX0tFWV9QUkVGSVh9JHt0aGlzLnN0b3JhZ2VJZH1gO1xyXG4gICAgICBpZiAodGhpcy5zdG9yYWdlSWQpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeShzYXZlZENvbG9ycykpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5kcmF3Q29sb3JGaWVsZEFuZFNsaWRlciA9IHRocm90dGxlKCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmZpZWxkQW5kU2xpZGVyUmVuZGVyaW5nQ29udGV4dCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRyYXdDb2xvckZpZWxkKCk7XHJcbiAgICAgIHRoaXMuZHJhd0h1ZVNsaWRlcigpO1xyXG4gICAgfSwgdGhyb3R0bGVGb3I2MEZwc0luTXMpO1xyXG4gICAgdGhpcy5jYXB0dXJlQ29sb3JGaWVsZENvbG9yID0gKHgsIHksIHNraXBFcXVhbCA9IHRydWUpID0+IHtcclxuICAgICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IGNvbG9yRmllbGQ6IHsgaGVpZ2h0LCB3aWR0aCB9IH0gfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IHNhdHVyYXRpb24gPSBNYXRoLnJvdW5kKChIU1ZfTElNSVRTLnMgLyB3aWR0aCkgKiB4KTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLnJvdW5kKChIU1ZfTElNSVRTLnYgLyBoZWlnaHQpICogKGhlaWdodCAtIHkpKTtcclxuICAgICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KHRoaXMuYmFzZUNvbG9yRmllbGRDb2xvci5oc3YoKS5zYXR1cmF0aW9udihzYXR1cmF0aW9uKS52YWx1ZSh2YWx1ZSksIHNraXBFcXVhbCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5pbml0Q29sb3JGaWVsZEFuZFNsaWRlciA9IChjYW52YXMpID0+IHtcclxuICAgICAgdGhpcy5maWVsZEFuZFNsaWRlclJlbmRlcmluZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUoY2FudmFzKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmFsbG93RW1wdHkgPSBmYWxzZTtcclxuICAgIHRoaXMuY29sb3IgPSBERUZBVUxUX0NPTE9SO1xyXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5mb3JtYXQgPSBkZWZhdWx0Rm9ybWF0O1xyXG4gICAgdGhpcy5oaWRlSGV4ID0gZmFsc2U7XHJcbiAgICB0aGlzLmhpZGVDaGFubmVscyA9IGZhbHNlO1xyXG4gICAgdGhpcy5oaWRlU2F2ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuc2NhbGUgPSBcIm1cIjtcclxuICAgIHRoaXMuc3RvcmFnZUlkID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5tZXNzYWdlT3ZlcnJpZGVzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgdGhpcy5kZWZhdWx0TWVzc2FnZXMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmNvbG9yRmllbGRBbmRTbGlkZXJJbnRlcmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5jaGFubmVsTW9kZSA9IFwicmdiXCI7XHJcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy50b0NoYW5uZWxzKERFRkFVTFRfQ09MT1IpO1xyXG4gICAgdGhpcy5kaW1lbnNpb25zID0gRElNRU5TSU9OUy5tO1xyXG4gICAgdGhpcy5lZmZlY3RpdmVMb2NhbGUgPSBcIlwiO1xyXG4gICAgdGhpcy5tZXNzYWdlcyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuc2F2ZWRDb2xvcnMgPSBbXTtcclxuICAgIHRoaXMuY29sb3JGaWVsZFNjb3BlVG9wID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5jb2xvckZpZWxkU2NvcGVMZWZ0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5zY29wZU9yaWVudGF0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5odWVTY29wZUxlZnQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmh1ZVNjb3BlVG9wID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBoYW5kbGVDb2xvckNoYW5nZShjb2xvciwgb2xkQ29sb3IpIHtcclxuICAgIHRoaXMuZHJhd0NvbG9yRmllbGRBbmRTbGlkZXIoKTtcclxuICAgIHRoaXMudXBkYXRlQ2hhbm5lbHNGcm9tQ29sb3IoY29sb3IpO1xyXG4gICAgdGhpcy5wcmV2aW91c0NvbG9yID0gb2xkQ29sb3I7XHJcbiAgfVxyXG4gIGhhbmRsZUZvcm1hdENoYW5nZShmb3JtYXQpIHtcclxuICAgIHRoaXMuc2V0TW9kZShmb3JtYXQpO1xyXG4gICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KHRoaXMuY29sb3IsIGZhbHNlLCBcImludGVybmFsXCIpO1xyXG4gIH1cclxuICBoYW5kbGVTY2FsZUNoYW5nZShzY2FsZSA9IFwibVwiKSB7XHJcbiAgICB0aGlzLnVwZGF0ZURpbWVuc2lvbnMoc2NhbGUpO1xyXG4gICAgdGhpcy51cGRhdGVDYW52YXNTaXplKHRoaXMuZmllbGRBbmRTbGlkZXJSZW5kZXJpbmdDb250ZXh0Py5jYW52YXMpO1xyXG4gIH1cclxuICBvbk1lc3NhZ2VzQ2hhbmdlKCkge1xyXG4gICAgLyogd2lyZWQgdXAgYnkgdDluIHV0aWwgKi9cclxuICB9XHJcbiAgaGFuZGxlVmFsdWVDaGFuZ2UodmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICBjb25zdCB7IGFsbG93RW1wdHksIGZvcm1hdCB9ID0gdGhpcztcclxuICAgIGNvbnN0IGNoZWNrTW9kZSA9ICFhbGxvd0VtcHR5IHx8IHZhbHVlO1xyXG4gICAgbGV0IG1vZGVDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBpZiAoY2hlY2tNb2RlKSB7XHJcbiAgICAgIGNvbnN0IG5leHRNb2RlID0gcGFyc2VNb2RlKHZhbHVlKTtcclxuICAgICAgaWYgKCFuZXh0TW9kZSB8fCAoZm9ybWF0ICE9PSBcImF1dG9cIiAmJiBuZXh0TW9kZSAhPT0gZm9ybWF0KSkge1xyXG4gICAgICAgIHRoaXMuc2hvd0luY29tcGF0aWJsZUNvbG9yV2FybmluZyh2YWx1ZSwgZm9ybWF0KTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gb2xkVmFsdWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIG1vZGVDaGFuZ2VkID0gdGhpcy5tb2RlICE9PSBuZXh0TW9kZTtcclxuICAgICAgdGhpcy5zZXRNb2RlKG5leHRNb2RlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRyYWdnaW5nID0gdGhpcy5zbGlkZXJUaHVtYlN0YXRlID09PSBcImRyYWdcIiB8fCB0aGlzLmh1ZVRodW1iU3RhdGUgPT09IFwiZHJhZ1wiO1xyXG4gICAgaWYgKHRoaXMuaW50ZXJuYWxDb2xvclVwZGF0ZUNvbnRleHQgPT09IFwiaW5pdGlhbFwiKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmludGVybmFsQ29sb3JVcGRhdGVDb250ZXh0ID09PSBcInVzZXItaW50ZXJhY3Rpb25cIikge1xyXG4gICAgICB0aGlzLmNhbGNpdGVDb2xvclBpY2tlcklucHV0LmVtaXQoKTtcclxuICAgICAgaWYgKCFkcmFnZ2luZykge1xyXG4gICAgICAgIHRoaXMuY2FsY2l0ZUNvbG9yUGlja2VyQ2hhbmdlLmVtaXQoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb2xvciQxID0gYWxsb3dFbXB0eSAmJiAhdmFsdWUgPyBudWxsIDogY29sb3IodmFsdWUpO1xyXG4gICAgY29uc3QgY29sb3JDaGFuZ2VkID0gIWNvbG9yRXF1YWwoY29sb3IkMSwgdGhpcy5jb2xvcik7XHJcbiAgICBpZiAobW9kZUNoYW5nZWQgfHwgY29sb3JDaGFuZ2VkKSB7XHJcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvciQxLCB0cnVlLCBcImludGVybmFsXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy9cclxuICAvLyAgSW50ZXJuYWwgU3RhdGUvUHJvcHNcclxuICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBnZXQgYmFzZUNvbG9yRmllbGRDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbG9yIHx8IHRoaXMucHJldmlvdXNDb2xvciB8fCBERUZBVUxUX0NPTE9SO1xyXG4gIH1cclxuICBlZmZlY3RpdmVMb2NhbGVDaGFuZ2UoKSB7XHJcbiAgICB1cGRhdGVNZXNzYWdlcyh0aGlzLCB0aGlzLmVmZmVjdGl2ZUxvY2FsZSk7XHJcbiAgfVxyXG4gIC8vIHVzaW5nIEBMaXN0ZW4gYXMgYSB3b3JrYXJvdW5kIGZvciBWRE9NIGxpc3RlbmVyIG5vdCBmaXJpbmdcclxuICBoYW5kbGVDaGFubmVsS2V5VXBPckRvd24oZXZlbnQpIHtcclxuICAgIHRoaXMuc2hpZnRLZXlDaGFubmVsQWRqdXN0bWVudCA9IDA7XHJcbiAgICBjb25zdCB7IGtleSB9ID0gZXZlbnQ7XHJcbiAgICBpZiAoKGtleSAhPT0gXCJBcnJvd1VwXCIgJiYga2V5ICE9PSBcIkFycm93RG93blwiKSB8fFxyXG4gICAgICAhZXZlbnQuY29tcG9zZWRQYXRoKCkuc29tZSgobm9kZSkgPT4gbm9kZS5jbGFzc0xpc3Q/LmNvbnRhaW5zKENTUy5jaGFubmVsKSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBzaGlmdEtleSB9ID0gZXZlbnQ7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgaWYgKCF0aGlzLmNvbG9yKSB7XHJcbiAgICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldCh0aGlzLnByZXZpb3VzQ29sb3IpO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdGhpcyBnZXRzIGFwcGxpZWQgdG8gdGhlIGlucHV0J3MgdXAvZG93biBhcnJvdyBpbmNyZW1lbnQvZGVjcmVtZW50XHJcbiAgICBjb25zdCBjb21wbGVtZW50YXJ5QnVtcCA9IDk7XHJcbiAgICB0aGlzLnNoaWZ0S2V5Q2hhbm5lbEFkanVzdG1lbnQgPVxyXG4gICAgICBrZXkgPT09IFwiQXJyb3dVcFwiICYmIHNoaWZ0S2V5XHJcbiAgICAgICAgPyBjb21wbGVtZW50YXJ5QnVtcFxyXG4gICAgICAgIDoga2V5ID09PSBcIkFycm93RG93blwiICYmIHNoaWZ0S2V5XHJcbiAgICAgICAgICA/IC1jb21wbGVtZW50YXJ5QnVtcFxyXG4gICAgICAgICAgOiAwO1xyXG4gIH1cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy9cclxuICAvLyAgUHVibGljIE1ldGhvZHNcclxuICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvKiogU2V0cyBmb2N1cyBvbiB0aGUgY29tcG9uZW50J3MgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQuICovXHJcbiAgYXN5bmMgc2V0Rm9jdXMoKSB7XHJcbiAgICBhd2FpdCBjb21wb25lbnRMb2FkZWQodGhpcyk7XHJcbiAgICB0aGlzLmVsLmZvY3VzKCk7XHJcbiAgfVxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvL1xyXG4gIC8vICBMaWZlY3ljbGVcclxuICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcclxuICAgIHNldFVwTG9hZGFibGVDb21wb25lbnQodGhpcyk7XHJcbiAgICBjb25zdCB7IGFsbG93RW1wdHksIGNvbG9yOiBjb2xvciQxLCBmb3JtYXQsIHZhbHVlIH0gPSB0aGlzO1xyXG4gICAgY29uc3Qgd2lsbFNldE5vQ29sb3IgPSBhbGxvd0VtcHR5ICYmICF2YWx1ZTtcclxuICAgIGNvbnN0IHBhcnNlZE1vZGUgPSBwYXJzZU1vZGUodmFsdWUpO1xyXG4gICAgY29uc3QgdmFsdWVJc0NvbXBhdGlibGUgPSB3aWxsU2V0Tm9Db2xvciB8fCAoZm9ybWF0ID09PSBcImF1dG9cIiAmJiBwYXJzZWRNb2RlKSB8fCBmb3JtYXQgPT09IHBhcnNlZE1vZGU7XHJcbiAgICBjb25zdCBpbml0aWFsQ29sb3IgPSB3aWxsU2V0Tm9Db2xvciA/IG51bGwgOiB2YWx1ZUlzQ29tcGF0aWJsZSA/IGNvbG9yKHZhbHVlKSA6IGNvbG9yJDE7XHJcbiAgICBpZiAoIXZhbHVlSXNDb21wYXRpYmxlKSB7XHJcbiAgICAgIHRoaXMuc2hvd0luY29tcGF0aWJsZUNvbG9yV2FybmluZyh2YWx1ZSwgZm9ybWF0KTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0TW9kZShmb3JtYXQpO1xyXG4gICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KGluaXRpYWxDb2xvciwgZmFsc2UsIFwiaW5pdGlhbFwiKTtcclxuICAgIHRoaXMudXBkYXRlRGltZW5zaW9ucyh0aGlzLnNjYWxlKTtcclxuICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBgJHtERUZBVUxUX1NUT1JBR0VfS0VZX1BSRUZJWH0ke3RoaXMuc3RvcmFnZUlkfWA7XHJcbiAgICBpZiAodGhpcy5zdG9yYWdlSWQgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkpIHtcclxuICAgICAgdGhpcy5zYXZlZENvbG9ycyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSkpO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgc2V0VXBNZXNzYWdlcyh0aGlzKTtcclxuICB9XHJcbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgICBjb25uZWN0TG9jYWxpemVkKHRoaXMpO1xyXG4gICAgY29ubmVjdE1lc3NhZ2VzKHRoaXMpO1xyXG4gIH1cclxuICBjb21wb25lbnREaWRMb2FkKCkge1xyXG4gICAgc2V0Q29tcG9uZW50TG9hZGVkKHRoaXMpO1xyXG4gIH1cclxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLmdsb2JhbFBvaW50ZXJNb3ZlSGFuZGxlcik7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuZ2xvYmFsUG9pbnRlclVwSGFuZGxlcik7XHJcbiAgICBkaXNjb25uZWN0TG9jYWxpemVkKHRoaXMpO1xyXG4gICAgZGlzY29ubmVjdE1lc3NhZ2VzKHRoaXMpO1xyXG4gIH1cclxuICBjb21wb25lbnREaWRSZW5kZXIoKSB7XHJcbiAgICB1cGRhdGVIb3N0SW50ZXJhY3Rpb24odGhpcyk7XHJcbiAgfVxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvL1xyXG4gIC8vICBSZW5kZXIgTWV0aG9kc1xyXG4gIC8vXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIHJlbmRlcigpIHtcclxuICAgIGNvbnN0IHsgYWxsb3dFbXB0eSwgY29sb3IsIG1lc3NhZ2VzLCBoaWRlSGV4LCBoaWRlQ2hhbm5lbHMsIGhpZGVTYXZlZCwgc2F2ZWRDb2xvcnMsIHNjYWxlIH0gPSB0aGlzO1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRDb2xvckluSGV4ID0gY29sb3IgPyBjb2xvci5oZXgoKSA6IG51bGw7XHJcbiAgICBjb25zdCBoZXhJbnB1dFNjYWxlID0gc2NhbGUgPT09IFwibFwiID8gXCJtXCIgOiBcInNcIjtcclxuICAgIGNvbnN0IHsgY29sb3JGaWVsZEFuZFNsaWRlckludGVyYWN0aXZlLCBjb2xvckZpZWxkU2NvcGVUb3AsIGNvbG9yRmllbGRTY29wZUxlZnQsIGh1ZVNjb3BlTGVmdCwgaHVlU2NvcGVUb3AsIHNjb3BlT3JpZW50YXRpb24sIGRpbWVuc2lvbnM6IHsgY29sb3JGaWVsZDogeyBoZWlnaHQ6IGNvbG9yRmllbGRIZWlnaHQsIHdpZHRoOiBjb2xvckZpZWxkV2lkdGggfSwgc2xpZGVyOiB7IGhlaWdodDogc2xpZGVySGVpZ2h0IH0gfSB9ID0gdGhpcztcclxuICAgIGNvbnN0IGh1ZVRvcCA9IGh1ZVNjb3BlVG9wID8/IHNsaWRlckhlaWdodCAvIDIgKyBjb2xvckZpZWxkSGVpZ2h0O1xyXG4gICAgY29uc3QgaHVlTGVmdCA9IGh1ZVNjb3BlTGVmdCA/PyAoY29sb3JGaWVsZFdpZHRoICogREVGQVVMVF9DT0xPUi5odWUoKSkgLyBIU1ZfTElNSVRTLmg7XHJcbiAgICBjb25zdCBub0NvbG9yID0gY29sb3IgPT09IG51bGw7XHJcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IHNjb3BlT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIjtcclxuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuY29udGFpbmVyIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmNvbG9yRmllbGRBbmRTbGlkZXJXcmFwIH0sIGgoXCJjYW52YXNcIiwgeyBjbGFzczoge1xyXG4gICAgICAgIFtDU1MuY29sb3JGaWVsZEFuZFNsaWRlcl06IHRydWUsXHJcbiAgICAgICAgW0NTUy5jb2xvckZpZWxkQW5kU2xpZGVySW50ZXJhY3RpdmVdOiBjb2xvckZpZWxkQW5kU2xpZGVySW50ZXJhY3RpdmVcclxuICAgICAgfSwgb25Qb2ludGVyRG93bjogdGhpcy5oYW5kbGVDb2xvckZpZWxkQW5kU2xpZGVyUG9pbnRlckRvd24sIG9uUG9pbnRlckVudGVyOiB0aGlzLmhhbmRsZUNvbG9yRmllbGRBbmRTbGlkZXJQb2ludGVyRW50ZXJPck1vdmUsIG9uUG9pbnRlckxlYXZlOiB0aGlzLmhhbmRsZUNvbG9yRmllbGRBbmRTbGlkZXJQb2ludGVyTGVhdmUsIG9uUG9pbnRlck1vdmU6IHRoaXMuaGFuZGxlQ29sb3JGaWVsZEFuZFNsaWRlclBvaW50ZXJFbnRlck9yTW92ZSwgcmVmOiB0aGlzLmluaXRDb2xvckZpZWxkQW5kU2xpZGVyIH0pLCBoKFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsXCI6IHZlcnRpY2FsID8gbWVzc2FnZXMudmFsdWUgOiBtZXNzYWdlcy5zYXR1cmF0aW9uLCBcImFyaWEtdmFsdWVtYXhcIjogdmVydGljYWwgPyBIU1ZfTElNSVRTLnYgOiBIU1ZfTElNSVRTLnMsIFwiYXJpYS12YWx1ZW1pblwiOiBcIjBcIiwgXCJhcmlhLXZhbHVlbm93XCI6ICh2ZXJ0aWNhbCA/IGNvbG9yPy5zYXR1cmF0aW9udigpIDogY29sb3I/LnZhbHVlKCkpIHx8IFwiMFwiLCBjbGFzczogeyBbQ1NTLnNjb3BlXTogdHJ1ZSwgW0NTUy5jb2xvckZpZWxkU2NvcGVdOiB0cnVlIH0sIG9uS2V5RG93bjogdGhpcy5oYW5kbGVDb2xvckZpZWxkU2NvcGVLZXlEb3duLCByZWY6IHRoaXMuc3RvcmVDb2xvckZpZWxkU2NvcGUsIHJvbGU6IFwic2xpZGVyXCIsIHN0eWxlOiB7IHRvcDogYCR7Y29sb3JGaWVsZFNjb3BlVG9wIHx8IDB9cHhgLCBsZWZ0OiBgJHtjb2xvckZpZWxkU2NvcGVMZWZ0IHx8IDB9cHhgIH0sIHRhYmluZGV4OiBcIjBcIiB9KSwgaChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbFwiOiBtZXNzYWdlcy5odWUsIFwiYXJpYS12YWx1ZW1heFwiOiBIU1ZfTElNSVRTLmgsIFwiYXJpYS12YWx1ZW1pblwiOiBcIjBcIiwgXCJhcmlhLXZhbHVlbm93XCI6IGNvbG9yPy5yb3VuZCgpLmh1ZSgpIHx8IERFRkFVTFRfQ09MT1Iucm91bmQoKS5odWUoKSwgY2xhc3M6IHsgW0NTUy5zY29wZV06IHRydWUsIFtDU1MuaHVlU2NvcGVdOiB0cnVlIH0sIG9uS2V5RG93bjogdGhpcy5oYW5kbGVIdWVTY29wZUtleURvd24sIHJlZjogdGhpcy5zdG9yZUh1ZVNjb3BlLCByb2xlOiBcInNsaWRlclwiLCBzdHlsZTogeyB0b3A6IGAke2h1ZVRvcH1weGAsIGxlZnQ6IGAke2h1ZUxlZnR9cHhgIH0sIHRhYmluZGV4OiBcIjBcIiB9KSksIGhpZGVIZXggJiYgaGlkZUNoYW5uZWxzID8gbnVsbCA6IChoKFwiZGl2XCIsIHsgY2xhc3M6IHtcclxuICAgICAgICBbQ1NTLmNvbnRyb2xTZWN0aW9uXTogdHJ1ZSxcclxuICAgICAgICBbQ1NTLnNlY3Rpb25dOiB0cnVlXHJcbiAgICAgIH0gfSwgaGlkZUhleCA/IG51bGwgOiAoaChcImRpdlwiLCB7IGNsYXNzOiBDU1MuaGV4T3B0aW9ucyB9LCBoKFwic3BhblwiLCB7IGNsYXNzOiB7XHJcbiAgICAgICAgW0NTUy5oZWFkZXJdOiB0cnVlLFxyXG4gICAgICAgIFtDU1MuaGVhZGVySGV4XTogdHJ1ZVxyXG4gICAgICB9IH0sIG1lc3NhZ2VzLmhleCksIGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlci1oZXgtaW5wdXRcIiwgeyBhbGxvd0VtcHR5OiBhbGxvd0VtcHR5LCBjbGFzczogQ1NTLmNvbnRyb2wsIGhleExhYmVsOiBtZXNzYWdlcy5oZXgsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sIG9uQ2FsY2l0ZUNvbG9yUGlja2VySGV4SW5wdXRDaGFuZ2U6IHRoaXMuaGFuZGxlSGV4SW5wdXRDaGFuZ2UsIHNjYWxlOiBoZXhJbnB1dFNjYWxlLCB2YWx1ZTogc2VsZWN0ZWRDb2xvckluSGV4IH0pKSksIGhpZGVDaGFubmVscyA/IG51bGwgOiAoaChcImNhbGNpdGUtdGFic1wiLCB7IGNsYXNzOiB7XHJcbiAgICAgICAgW0NTUy5jb2xvck1vZGVDb250YWluZXJdOiB0cnVlLFxyXG4gICAgICAgIFtDU1Muc3BsaXRTZWN0aW9uXTogdHJ1ZVxyXG4gICAgICB9LCBzY2FsZTogaGV4SW5wdXRTY2FsZSB9LCBoKFwiY2FsY2l0ZS10YWItbmF2XCIsIHsgc2xvdDogXCJ0aXRsZS1ncm91cFwiIH0sIHRoaXMucmVuZGVyQ2hhbm5lbHNUYWJUaXRsZShcInJnYlwiKSwgdGhpcy5yZW5kZXJDaGFubmVsc1RhYlRpdGxlKFwiaHN2XCIpKSwgdGhpcy5yZW5kZXJDaGFubmVsc1RhYihcInJnYlwiKSwgdGhpcy5yZW5kZXJDaGFubmVsc1RhYihcImhzdlwiKSkpKSksIGhpZGVTYXZlZCA/IG51bGwgOiAoaChcImRpdlwiLCB7IGNsYXNzOiB7IFtDU1Muc2F2ZWRDb2xvcnNTZWN0aW9uXTogdHJ1ZSwgW0NTUy5zZWN0aW9uXTogdHJ1ZSB9IH0sIGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLmhlYWRlciB9LCBoKFwibGFiZWxcIiwgbnVsbCwgbWVzc2FnZXMuc2F2ZWQpLCBoKFwiZGl2XCIsIHsgY2xhc3M6IENTUy5zYXZlZENvbG9yc0J1dHRvbnMgfSwgaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCBjbGFzczogQ1NTLmRlbGV0ZUNvbG9yLCBkaXNhYmxlZDogbm9Db2xvciwgaWNvblN0YXJ0OiBcIm1pbnVzXCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBsYWJlbDogbWVzc2FnZXMuZGVsZXRlQ29sb3IsIG9uQ2xpY2s6IHRoaXMuZGVsZXRlQ29sb3IsIHNjYWxlOiBoZXhJbnB1dFNjYWxlLCB0eXBlOiBcImJ1dHRvblwiIH0pLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGNsYXNzOiBDU1Muc2F2ZUNvbG9yLCBkaXNhYmxlZDogbm9Db2xvciwgaWNvblN0YXJ0OiBcInBsdXNcIiwga2luZDogXCJuZXV0cmFsXCIsIGxhYmVsOiBtZXNzYWdlcy5zYXZlQ29sb3IsIG9uQ2xpY2s6IHRoaXMuc2F2ZUNvbG9yLCBzY2FsZTogaGV4SW5wdXRTY2FsZSwgdHlwZTogXCJidXR0b25cIiB9KSkpLCBzYXZlZENvbG9ycy5sZW5ndGggPiAwID8gKGgoXCJkaXZcIiwgeyBjbGFzczogQ1NTLnNhdmVkQ29sb3JzIH0sIFtcclxuICAgICAgLi4uc2F2ZWRDb2xvcnMubWFwKChjb2xvcikgPT4gKGgoXCJjYWxjaXRlLWNvbG9yLXBpY2tlci1zd2F0Y2hcIiwgeyBhY3RpdmU6IHNlbGVjdGVkQ29sb3JJbkhleCA9PT0gY29sb3IsIGNsYXNzOiBDU1Muc2F2ZWRDb2xvciwgY29sb3I6IGNvbG9yLCBrZXk6IGNvbG9yLCBvbkNsaWNrOiB0aGlzLmhhbmRsZVNhdmVkQ29sb3JTZWxlY3QsIG9uS2V5RG93bjogdGhpcy5oYW5kbGVTYXZlZENvbG9yS2V5RG93biwgc2NhbGU6IHNjYWxlLCB0YWJJbmRleDogMCB9KSkpXHJcbiAgICBdKSkgOiBudWxsKSkpKTtcclxuICB9XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvL1xyXG4gIC8vICBQcml2YXRlIE1ldGhvZHNcclxuICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2hvd0luY29tcGF0aWJsZUNvbG9yV2FybmluZyh2YWx1ZSwgZm9ybWF0KSB7XHJcbiAgICBjb25zb2xlLndhcm4oYGlnbm9yaW5nIGNvbG9yIHZhbHVlICgke3ZhbHVlfSkgYXMgaXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgY3VycmVudCBmb3JtYXQgKCR7Zm9ybWF0fSlgKTtcclxuICB9XHJcbiAgc2V0TW9kZShmb3JtYXQpIHtcclxuICAgIHRoaXMubW9kZSA9IGZvcm1hdCA9PT0gXCJhdXRvXCIgPyB0aGlzLm1vZGUgOiBmb3JtYXQ7XHJcbiAgfVxyXG4gIGNhcHR1cmVIdWVTbGlkZXJDb2xvcih4KSB7XHJcbiAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHsgc2xpZGVyOiB7IHdpZHRoIH0gfSB9ID0gdGhpcztcclxuICAgIGNvbnN0IGh1ZSA9ICgzNjAgLyB3aWR0aCkgKiB4O1xyXG4gICAgdGhpcy5pbnRlcm5hbENvbG9yU2V0KHRoaXMuYmFzZUNvbG9yRmllbGRDb2xvci5odWUoaHVlKSwgZmFsc2UpO1xyXG4gIH1cclxuICBnZXRDYW52YXNSZWdpb24oeSkge1xyXG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IGNvbG9yRmllbGQ6IHsgaGVpZ2h0OiBjb2xvckZpZWxkSGVpZ2h0IH0sIHNsaWRlcjogeyBoZWlnaHQ6IHNsaWRlckhlaWdodCB9IH0gfSA9IHRoaXM7XHJcbiAgICBpZiAoeSA8PSBjb2xvckZpZWxkSGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBcImNvbG9yLWZpZWxkXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoeSA8PSBjb2xvckZpZWxkSGVpZ2h0ICsgc2xpZGVySGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBcInNsaWRlclwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwibm9uZVwiO1xyXG4gIH1cclxuICBpbnRlcm5hbENvbG9yU2V0KGNvbG9yLCBza2lwRXF1YWwgPSB0cnVlLCBjb250ZXh0ID0gXCJ1c2VyLWludGVyYWN0aW9uXCIpIHtcclxuICAgIGlmIChza2lwRXF1YWwgJiYgY29sb3JFcXVhbChjb2xvciwgdGhpcy5jb2xvcikpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pbnRlcm5hbENvbG9yVXBkYXRlQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICB0aGlzLnZhbHVlID0gdGhpcy50b1ZhbHVlKGNvbG9yKTtcclxuICAgIHRoaXMuaW50ZXJuYWxDb2xvclVwZGF0ZUNvbnRleHQgPSBudWxsO1xyXG4gIH1cclxuICB0b1ZhbHVlKGNvbG9yLCBmb3JtYXQgPSB0aGlzLm1vZGUpIHtcclxuICAgIGlmICghY29sb3IpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoZXhNb2RlID0gXCJoZXhcIjtcclxuICAgIGlmIChmb3JtYXQuaW5jbHVkZXMoaGV4TW9kZSkpIHtcclxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUhleChjb2xvci5yb3VuZCgpW2hleE1vZGVdKCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZvcm1hdC5pbmNsdWRlcyhcIi1jc3NcIikpIHtcclxuICAgICAgcmV0dXJuIGNvbG9yW2Zvcm1hdC5yZXBsYWNlKFwiLWNzc1wiLCBcIlwiKS5yZXBsYWNlKFwiYVwiLCBcIlwiKV0oKS5yb3VuZCgpLnN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29sb3JPYmplY3QgPSBjb2xvcltmb3JtYXRdKCkucm91bmQoKS5vYmplY3QoKTtcclxuICAgIGlmIChmb3JtYXQuZW5kc1dpdGgoXCJhXCIpKSB7XHJcbiAgICAgIC8vIG5vcm1hbGl6ZSBhbHBoYSBwcm9wXHJcbiAgICAgIGNvbG9yT2JqZWN0LmEgPSBjb2xvck9iamVjdC5hbHBoYTtcclxuICAgICAgZGVsZXRlIGNvbG9yT2JqZWN0LmFscGhhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbG9yT2JqZWN0O1xyXG4gIH1cclxuICBnZXRTbGlkZXJDYXBTcGFjaW5nKCkge1xyXG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IHNsaWRlcjogeyBoZWlnaHQgfSwgdGh1bWI6IHsgcmFkaXVzIH0gfSB9ID0gdGhpcztcclxuICAgIHJldHVybiByYWRpdXMgKiAyIC0gaGVpZ2h0O1xyXG4gIH1cclxuICB1cGRhdGVEaW1lbnNpb25zKHNjYWxlID0gXCJtXCIpIHtcclxuICAgIHRoaXMuZGltZW5zaW9ucyA9IERJTUVOU0lPTlNbc2NhbGVdO1xyXG4gIH1cclxuICBkcmF3Q29sb3JGaWVsZCgpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmZpZWxkQW5kU2xpZGVyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBjb2xvckZpZWxkOiB7IGhlaWdodCwgd2lkdGggfSB9IH0gPSB0aGlzO1xyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmJhc2VDb2xvckZpZWxkQ29sb3IuaHN2KCkuc2F0dXJhdGlvbnYoMTAwKS52YWx1ZSgxMDApLnN0cmluZygpO1xyXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIGNvbnN0IHdoaXRlR3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcclxuICAgIHdoaXRlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIFwicmdiYSgyNTUsMjU1LDI1NSwxKVwiKTtcclxuICAgIHdoaXRlR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFwicmdiYSgyNTUsMjU1LDI1NSwwKVwiKTtcclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gd2hpdGVHcmFkaWVudDtcclxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICBjb25zdCBibGFja0dyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAwLCBoZWlnaHQpO1xyXG4gICAgYmxhY2tHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgXCJyZ2JhKDAsMCwwLDApXCIpO1xyXG4gICAgYmxhY2tHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgXCJyZ2JhKDAsMCwwLDEpXCIpO1xyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBibGFja0dyYWRpZW50O1xyXG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHRoaXMuZHJhd0FjdGl2ZUNvbG9yRmllbGRDb2xvcigpO1xyXG4gIH1cclxuICBzZXRDYW52YXNDb250ZXh0U2l6ZShjYW52YXMsIHsgaGVpZ2h0LCB3aWR0aCB9KSB7XHJcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XHJcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGNvbnRleHQuc2NhbGUoZGV2aWNlUGl4ZWxSYXRpbywgZGV2aWNlUGl4ZWxSYXRpbyk7XHJcbiAgfVxyXG4gIHVwZGF0ZUNhbnZhc1NpemUoY2FudmFzKSB7XHJcbiAgICBpZiAoIWNhbnZhcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldENhbnZhc0NvbnRleHRTaXplKGNhbnZhcywge1xyXG4gICAgICB3aWR0aDogdGhpcy5kaW1lbnNpb25zLmNvbG9yRmllbGQud2lkdGgsXHJcbiAgICAgIGhlaWdodDogdGhpcy5kaW1lbnNpb25zLmNvbG9yRmllbGQuaGVpZ2h0ICtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbnMuc2xpZGVyLmhlaWdodCArXHJcbiAgICAgICAgdGhpcy5nZXRTbGlkZXJDYXBTcGFjaW5nKCkgKiAyXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZHJhd0NvbG9yRmllbGRBbmRTbGlkZXIoKTtcclxuICB9XHJcbiAgY29udGFpbnNQb2ludCh0ZXN0UG9pbnRYLCB0ZXN0UG9pbnRZLCBib3VuZHNYLCBib3VuZHNZLCBib3VuZHNSYWRpdXMpIHtcclxuICAgIHJldHVybiAoTWF0aC5wb3codGVzdFBvaW50WCAtIGJvdW5kc1gsIDIpICsgTWF0aC5wb3codGVzdFBvaW50WSAtIGJvdW5kc1ksIDIpIDw9XHJcbiAgICAgIE1hdGgucG93KGJvdW5kc1JhZGl1cywgMikpO1xyXG4gIH1cclxuICBkcmF3QWN0aXZlQ29sb3JGaWVsZENvbG9yKCkge1xyXG4gICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcztcclxuICAgIGlmICghY29sb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaHN2Q29sb3IgPSBjb2xvci5oc3YoKTtcclxuICAgIGNvbnN0IHsgZGltZW5zaW9uczogeyBjb2xvckZpZWxkOiB7IGhlaWdodCwgd2lkdGggfSwgdGh1bWI6IHsgcmFkaXVzIH0gfSB9ID0gdGhpcztcclxuICAgIGNvbnN0IHggPSBoc3ZDb2xvci5zYXR1cmF0aW9udigpIC8gKEhTVl9MSU1JVFMucyAvIHdpZHRoKTtcclxuICAgIGNvbnN0IHkgPSBoZWlnaHQgLSBoc3ZDb2xvci52YWx1ZSgpIC8gKEhTVl9MSU1JVFMudiAvIGhlaWdodCk7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLmNvbG9yRmllbGRTY29wZUxlZnQgPSB4O1xyXG4gICAgICB0aGlzLmNvbG9yRmllbGRTY29wZVRvcCA9IHk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZHJhd1RodW1iKHRoaXMuZmllbGRBbmRTbGlkZXJSZW5kZXJpbmdDb250ZXh0LCByYWRpdXMsIHgsIHksIGhzdkNvbG9yLCB0aGlzLmh1ZVRodW1iU3RhdGUpO1xyXG4gIH1cclxuICBkcmF3VGh1bWIoY29udGV4dCwgcmFkaXVzLCB4LCB5LCBjb2xvciwgc3RhdGUpIHtcclxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSAwO1xyXG4gICAgY29uc3QgZW5kQW5nbGUgPSAyICogTWF0aC5QSTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcclxuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IHN0YXRlID09PSBcImhvdmVyXCIgPyAzMiA6IDE2O1xyXG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IGByZ2JhKDAsIDAsIDAsICR7c3RhdGUgPT09IFwiZHJhZ1wiID8gMC4zMiA6IDAuMTZ9KWA7XHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI2ZmZlwiO1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzIC0gMywgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xyXG4gICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcclxuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnJnYigpLnN0cmluZygpO1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgfVxyXG4gIGRyYXdBY3RpdmVIdWVTbGlkZXJDb2xvcigpIHtcclxuICAgIGNvbnN0IHsgY29sb3IgfSA9IHRoaXM7XHJcbiAgICBpZiAoIWNvbG9yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGhzdkNvbG9yID0gY29sb3IuaHN2KCkuc2F0dXJhdGlvbnYoMTAwKS52YWx1ZSgxMDApO1xyXG4gICAgY29uc3QgeyBkaW1lbnNpb25zOiB7IGNvbG9yRmllbGQ6IHsgaGVpZ2h0OiBjb2xvckZpZWxkSGVpZ2h0IH0sIHNsaWRlcjogeyBoZWlnaHQsIHdpZHRoIH0sIHRodW1iOiB7IHJhZGl1cyB9IH0gfSA9IHRoaXM7XHJcbiAgICBjb25zdCB4ID0gaHN2Q29sb3IuaHVlKCkgLyAoMzYwIC8gd2lkdGgpO1xyXG4gICAgY29uc3QgeSA9IGhlaWdodCAvIDIgKyBjb2xvckZpZWxkSGVpZ2h0O1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5odWVTY29wZUxlZnQgPSB4O1xyXG4gICAgICB0aGlzLmh1ZVNjb3BlVG9wID0geTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5kcmF3VGh1bWIodGhpcy5maWVsZEFuZFNsaWRlclJlbmRlcmluZ0NvbnRleHQsIHJhZGl1cywgeCwgeSwgaHN2Q29sb3IsIHRoaXMuc2xpZGVyVGh1bWJTdGF0ZSk7XHJcbiAgfVxyXG4gIGRyYXdIdWVTbGlkZXIoKSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5maWVsZEFuZFNsaWRlclJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBjb25zdCB7IGRpbWVuc2lvbnM6IHsgY29sb3JGaWVsZDogeyBoZWlnaHQ6IGNvbG9yRmllbGRIZWlnaHQgfSwgc2xpZGVyOiB7IGhlaWdodCwgd2lkdGggfSB9IH0gPSB0aGlzO1xyXG4gICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcclxuICAgIGNvbnN0IGh1ZVNsaWRlckNvbG9yU3RvcEtleXdvcmRzID0gW1wicmVkXCIsIFwieWVsbG93XCIsIFwibGltZVwiLCBcImN5YW5cIiwgXCJibHVlXCIsIFwibWFnZW50YVwiLCBcInJlZFwiXTtcclxuICAgIGNvbnN0IG9mZnNldCA9IDEgLyAoaHVlU2xpZGVyQ29sb3JTdG9wS2V5d29yZHMubGVuZ3RoIC0gMSk7XHJcbiAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICBodWVTbGlkZXJDb2xvclN0b3BLZXl3b3Jkcy5mb3JFYWNoKChrZXl3b3JkKSA9PiB7XHJcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChjdXJyZW50T2Zmc2V0LCBjb2xvcihrZXl3b3JkKS5zdHJpbmcoKSk7XHJcbiAgICAgIGN1cnJlbnRPZmZzZXQgKz0gb2Zmc2V0O1xyXG4gICAgfSk7XHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xyXG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgY29sb3JGaWVsZEhlaWdodCwgd2lkdGgsIGhlaWdodCArIHRoaXMuZ2V0U2xpZGVyQ2FwU3BhY2luZygpICogMik7XHJcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIGNvbG9yRmllbGRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgdGhpcy5kcmF3QWN0aXZlSHVlU2xpZGVyQ29sb3IoKTtcclxuICB9XHJcbiAgdXBkYXRlQ29sb3JGcm9tQ2hhbm5lbHMoY2hhbm5lbHMpIHtcclxuICAgIHRoaXMuaW50ZXJuYWxDb2xvclNldChjb2xvcihjaGFubmVscywgdGhpcy5jaGFubmVsTW9kZSkpO1xyXG4gIH1cclxuICB1cGRhdGVDaGFubmVsc0Zyb21Db2xvcihjb2xvcikge1xyXG4gICAgdGhpcy5jaGFubmVscyA9IGNvbG9yID8gdGhpcy50b0NoYW5uZWxzKGNvbG9yKSA6IFtudWxsLCBudWxsLCBudWxsXTtcclxuICB9XHJcbiAgdG9DaGFubmVscyhjb2xvcikge1xyXG4gICAgY29uc3QgeyBjaGFubmVsTW9kZSB9ID0gdGhpcztcclxuICAgIHJldHVybiBjb2xvcltjaGFubmVsTW9kZV0oKVxyXG4gICAgICAuYXJyYXkoKVxyXG4gICAgICAubWFwKCh2YWx1ZSkgPT4gTWF0aC5mbG9vcih2YWx1ZSkpO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IGRlbGVnYXRlc0ZvY3VzKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG4gIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcImFzc2V0c1wiXTsgfVxyXG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cclxuICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xyXG4gICAgXCJjb2xvclwiOiBbXCJoYW5kbGVDb2xvckNoYW5nZVwiXSxcclxuICAgIFwiZm9ybWF0XCI6IFtcImhhbmRsZUZvcm1hdENoYW5nZVwiXSxcclxuICAgIFwic2NhbGVcIjogW1wiaGFuZGxlU2NhbGVDaGFuZ2VcIl0sXHJcbiAgICBcIm1lc3NhZ2VPdmVycmlkZXNcIjogW1wib25NZXNzYWdlc0NoYW5nZVwiXSxcclxuICAgIFwidmFsdWVcIjogW1wiaGFuZGxlVmFsdWVDaGFuZ2VcIl0sXHJcbiAgICBcImVmZmVjdGl2ZUxvY2FsZVwiOiBbXCJlZmZlY3RpdmVMb2NhbGVDaGFuZ2VcIl1cclxuICB9OyB9XHJcbn07XHJcbkNvbG9yUGlja2VyLnN0eWxlID0gY29sb3JQaWNrZXJDc3M7XG5cbmV4cG9ydCB7IENvbG9yUGlja2VyIGFzIGNhbGNpdGVfY29sb3JfcGlja2VyIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGNpdGUtY29sb3ItcGlja2VyLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5mdW5jdGlvbiBub29wQ2xpY2soKSB7XG4gIC8qKiBub29wICovXG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHVwZGF0ZXMgdGhlIGhvc3QgZWxlbWVudCB0byBwcmV2ZW50IGtleWJvYXJkIGludGVyYWN0aW9uIG9uIGl0cyBzdWJ0cmVlIGFuZCBzZXRzIHRoZSBhcHByb3ByaWF0ZSBhcmlhIGF0dHJpYnV0ZSBmb3IgYWNjZXNzaWJpbGl0eS5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIHRoZSBgY29tcG9uZW50RGlkUmVuZGVyYCBsaWZlY3ljbGUgaG9vay5cbiAqXG4gKiAqKk5vdGVzKipcbiAqXG4gKiB0aGlzIHV0aWwgaXMgbm90IG5lZWRlZCBmb3Igc2ltcGxlIGNvbXBvbmVudHMgd2hvc2Ugcm9vdCBlbGVtZW50IG9yIGVsZW1lbnRzIGFyZSBhbiBpbnRlcmFjdGl2ZSBjb21wb25lbnQgKGN1c3RvbSBlbGVtZW50IG9yIG5hdGl2ZSBjb250cm9sKS4gRm9yIHRob3NlIGNhc2VzLCBzZXQgdGhlIGBkaXNhYmxlZGAgcHJvcHMgb24gdGhlIHJvb3QgY29tcG9uZW50cyBpbnN0ZWFkLlxuICogdGVjaG5pY2FsbHksIHVzZXJzIGNhbiBvdmVycmlkZSBgdGFiaW5kZXhgIGFuZCByZXN0b3JlIGtleWJvYXJkIG5hdmlnYXRpb24sIGJ1dCB0aGlzIHdpbGwgYmUgY29uc2lkZXJlZCB1c2VyIGVycm9yXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHBhcmFtIGhvc3RJc1RhYmJhYmxlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RJbnRlcmFjdGlvbihjb21wb25lbnQsIGhvc3RJc1RhYmJhYmxlID0gZmFsc2UpIHtcbiAgaWYgKGNvbXBvbmVudC5kaXNhYmxlZCkge1xuICAgIGNvbXBvbmVudC5lbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuICAgIGNvbXBvbmVudC5lbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiKTtcbiAgICBpZiAoY29tcG9uZW50LmVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgY29tcG9uZW50LmVsLmNsaWNrID0gbm9vcENsaWNrO1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wb25lbnQuZWwuY2xpY2sgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUuY2xpY2s7XG4gIGlmICh0eXBlb2YgaG9zdElzVGFiYmFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbXBvbmVudC5lbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBob3N0SXNUYWJiYWJsZS5jYWxsKGNvbXBvbmVudCkgPyBcIjBcIiA6IFwiLTFcIik7XG4gIH1cbiAgZWxzZSBpZiAoaG9zdElzVGFiYmFibGUgPT09IHRydWUpIHtcbiAgICBjb21wb25lbnQuZWwuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICB9XG4gIGVsc2UgaWYgKGhvc3RJc1RhYmJhYmxlID09PSBmYWxzZSkge1xuICAgIGNvbXBvbmVudC5lbC5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcbiAgfVxuICBlbHNlIDtcbiAgY29tcG9uZW50LmVsLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIik7XG59XG5cbmV4cG9ydCB7IHVwZGF0ZUhvc3RJbnRlcmFjdGlvbiBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyYWN0aXZlLTI5OTk1NTIyLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5jb25zdCByZXNvbHZlTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHByb21pc2VNYXAgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUaGlzIGhlbHBlciB1dGlsIHNldHMgdXAgdGhlIGNvbXBvbmVudCBmb3IgdGhlIGFiaWxpdHkgdG8ga25vdyB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbG9hZGVkLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIGBjb21wb25lbnRXaWxsTG9hZGAgbGlmZWN5Y2xlIGhvb2suXG4gKlxuICogYGBgXG4gKiBjb21wb25lbnRXaWxsTG9hZCgpOiB2b2lkIHtcbiAqICAgc2V0VXBMb2FkYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gc2V0VXBMb2FkYWJsZUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcHJvbWlzZU1hcC5zZXQoY29tcG9uZW50LCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZU1hcC5zZXQoY29tcG9uZW50LCByZXNvbHZlKSkpO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciB1dGlsIGxldHMgdGhlIGxvYWRhYmxlIGNvbXBvbmVudCBrbm93IHRoYXQgaXQgaXMgbm93IGxvYWRlZC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIHRoZSBgY29tcG9uZW50RGlkTG9hZGAgbGlmZWN5Y2xlIGhvb2suXG4gKlxuICogYGBgXG4gKiBjb21wb25lbnREaWRMb2FkKCk6IHZvaWQge1xuICogICBzZXRDb21wb25lbnRMb2FkZWQodGhpcyk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIHNldENvbXBvbmVudExvYWRlZChjb21wb25lbnQpIHtcbiAgcmVzb2x2ZU1hcC5nZXQoY29tcG9uZW50KSgpO1xufVxuLyoqXG4gKiBUaGlzIGhlbHBlciB1dGlsIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSBhIGNvbXBvbmVudCBoYXMgYmVlbiBsb2FkZWQgKFRoZSBcImNvbXBvbmVudERpZExvYWRcIiBzdGVuY2lsIGxpZmVjeWNsZSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkKS5cbiAqXG4gKiBSZXF1aXJlcyBcInNldFVwTG9hZGFibGVDb21wb25lbnRcIiBhbmQgXCJzZXRDb21wb25lbnRMb2FkZWRcIiB0byBiZSBjYWxsZWQgZmlyc3QuXG4gKlxuICogQSBjb21wb25lbnQgZGV2ZWxvcGVyIGNhbiBhd2FpdCB0aGlzIG1ldGhvZCBiZWZvcmUgcHJvY2VlZGluZyB3aXRoIGFueSBsb2dpYyB0aGF0IHJlcXVpcmVzIGEgY29tcG9uZW50IHRvIGJlIGxvYWRlZCBmaXJzdC5cbiAqXG4gKiBgYGBcbiAqIGFzeW5jIHNldEZvY3VzKCk6IFByb21pc2U8dm9pZD4ge1xuICogICBhd2FpdCBjb21wb25lbnRMb2FkZWQodGhpcyk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudExvYWRlZChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHByb21pc2VNYXAuZ2V0KGNvbXBvbmVudCk7XG59XG5cbmV4cG9ydCB7IHNldFVwTG9hZGFibGVDb21wb25lbnQgYXMgYSwgY29tcG9uZW50TG9hZGVkIGFzIGMsIHNldENvbXBvbmVudExvYWRlZCBhcyBzIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRhYmxlLWNjMTRkNzI4LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5jb25zdCBjbGFtcCA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuY29uc3QgZGVjaW1hbFBsYWNlcyA9ICh2YWx1ZSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IChcIlwiICsgdmFsdWUpLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KDAsIFxuICAvLyBOdW1iZXIgb2YgZGlnaXRzIHJpZ2h0IG9mIGRlY2ltYWwgcG9pbnQuXG4gIChtYXRjaFsxXSA/IG1hdGNoWzFdLmxlbmd0aCA6IDApIC1cbiAgICAvLyBBZGp1c3QgZm9yIHNjaWVudGlmaWMgbm90YXRpb24uXG4gICAgKG1hdGNoWzJdID8gK21hdGNoWzJdIDogMCkpO1xufTtcblxuZXhwb3J0IHsgY2xhbXAgYXMgYywgZGVjaW1hbFBsYWNlcyBhcyBkIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGgtN2VmZDk4N2EuanMubWFwIiwiaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LTRlNjQ3NDExLmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0U3VwcG9ydGVkTG9jYWxlIH0gZnJvbSAnLi9sb2NhbGUtZjdiMmZiYjAuanMnO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuY29uc3QgY29tcG9uZW50TGFuZ1RvTWVzc2FnZUJ1bmRsZUNhY2hlID0ge307XG5hc3luYyBmdW5jdGlvbiBnZXRNZXNzYWdlQnVuZGxlKGxhbmcsIGNvbXBvbmVudCkge1xuICBjb25zdCBrZXkgPSBgJHtjb21wb25lbnR9XyR7bGFuZ31gO1xuICBpZiAoY29tcG9uZW50TGFuZ1RvTWVzc2FnZUJ1bmRsZUNhY2hlW2tleV0pIHtcbiAgICByZXR1cm4gY29tcG9uZW50TGFuZ1RvTWVzc2FnZUJ1bmRsZUNhY2hlW2tleV07XG4gIH1cbiAgY29tcG9uZW50TGFuZ1RvTWVzc2FnZUJ1bmRsZUNhY2hlW2tleV0gPSBmZXRjaChnZXRBc3NldFBhdGgoYC4vYXNzZXRzLyR7Y29tcG9uZW50fS90OW4vbWVzc2FnZXNfJHtsYW5nfS5qc29uYCkpXG4gICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgIHRocm93TWVzc2FnZUZldGNoRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3AuanNvbigpO1xuICB9KVxuICAgIC5jYXRjaCgoKSA9PiB0aHJvd01lc3NhZ2VGZXRjaEVycm9yKCkpO1xuICByZXR1cm4gY29tcG9uZW50TGFuZ1RvTWVzc2FnZUJ1bmRsZUNhY2hlW2tleV07XG59XG5mdW5jdGlvbiB0aHJvd01lc3NhZ2VGZXRjaEVycm9yKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgZmV0Y2ggY29tcG9uZW50IG1lc3NhZ2UgYnVuZGxlXCIpO1xufVxuZnVuY3Rpb24gbWVyZ2VNZXNzYWdlcyhjb21wb25lbnQpIHtcbiAgY29tcG9uZW50Lm1lc3NhZ2VzID0ge1xuICAgIC4uLmNvbXBvbmVudC5kZWZhdWx0TWVzc2FnZXMsXG4gICAgLi4uY29tcG9uZW50Lm1lc3NhZ2VPdmVycmlkZXNcbiAgfTtcbn1cbi8qKlxuICogVGhpcyB1dGlsaXR5IHNldHMgdXAgdGhlIG1lc3NhZ2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gSXQgc2hvdWxkIGJlIGF3YWl0ZWQgaW4gdGhlIGBjb21wb25lbnRXaWxsTG9hZGAgbGlmZWN5Y2xlIGhvb2suXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRVcE1lc3NhZ2VzKGNvbXBvbmVudCkge1xuICBjb21wb25lbnQuZGVmYXVsdE1lc3NhZ2VzID0gYXdhaXQgZmV0Y2hNZXNzYWdlcyhjb21wb25lbnQsIGNvbXBvbmVudC5lZmZlY3RpdmVMb2NhbGUpO1xuICBtZXJnZU1lc3NhZ2VzKGNvbXBvbmVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaE1lc3NhZ2VzKGNvbXBvbmVudCwgbGFuZykge1xuICBjb25zdCB7IGVsIH0gPSBjb21wb25lbnQ7XG4gIGNvbnN0IHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZy5yZXBsYWNlKFwiY2FsY2l0ZS1cIiwgXCJcIik7XG4gIHJldHVybiBnZXRNZXNzYWdlQnVuZGxlKGdldFN1cHBvcnRlZExvY2FsZShsYW5nLCBcInQ5blwiKSwgY29tcG9uZW50TmFtZSk7XG59XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBtdXN0IGJlIHNldCB1cCBmb3IgdGhlIGNvbXBvbmVudCB0byB1cGRhdGUgaXRzIGRlZmF1bHQgbWVzc2FnZSBidW5kbGUgaWYgdGhlIGxvY2FsZSBjaGFuZ2VzLlxuICpcbiAqIEl0IGNhbiBiZSBzZXQgdXAgaW4gKiplaXRoZXIqKiBvZiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogMS4gY2FsbGVkIGZyb20gYExvY2FsaXplZENvbXBvbmVudGAncyBgb25Mb2NhbGVDaGFuZ2VgIG1ldGhvZCBvclxuICogMi4gY2FsbGVkIGZyb20gYSB3YXRjaGVyIGNvbmZpZ3VyZWQgdG8gd2F0Y2ggYExvY2FsaXplZENvbXBvbmVudGAncyBgZWZmZWN0aXZlTG9jYWxlYCBwcm9wXG4gKlxuICogQHBhcmFtIGNvbXBvbmVudFxuICogQHBhcmFtIGxhbmdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlTWVzc2FnZXMoY29tcG9uZW50LCBsYW5nKSB7XG4gIGNvbXBvbmVudC5kZWZhdWx0TWVzc2FnZXMgPSBhd2FpdCBmZXRjaE1lc3NhZ2VzKGNvbXBvbmVudCwgbGFuZyk7XG4gIG1lcmdlTWVzc2FnZXMoY29tcG9uZW50KTtcbn1cbi8qKlxuICogVGhpcyB1dGlsaXR5IHNldHMgdXAgaW50ZXJuYWxzIGZvciBtZXNzYWdlcyBzdXBwb3J0LlxuICpcbiAqIEl0IG5lZWRzIHRvIGJlIGNhbGxlZCBpbiBgY29ubmVjdGVkQ2FsbGJhY2tgXG4gKlxuICogKipOb3RlKio6IHRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYExvY2FsaXplZENvbXBvbmVudGAncyBgY29ubmVjdExvY2FsaXplZGAgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gY29ubmVjdE1lc3NhZ2VzKGNvbXBvbmVudCkge1xuICBjb21wb25lbnQub25NZXNzYWdlc0NoYW5nZSA9IGRlZmF1bHRPbk1lc3NhZ2VzQ2hhbmdlO1xufVxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgdGVhcnMgZG93biBpbnRlcm5hbHMgZm9yIG1lc3NhZ2VzIHN1cHBvcnQuXG4gKlxuICogSXQgbmVlZHMgdG8gYmUgY2FsbGVkIGluIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RNZXNzYWdlcyhjb21wb25lbnQpIHtcbiAgY29tcG9uZW50Lm9uTWVzc2FnZXNDaGFuZ2UgPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25NZXNzYWdlc0NoYW5nZSgpIHtcbiAgbWVyZ2VNZXNzYWdlcyh0aGlzKTtcbn1cblxuZXhwb3J0IHsgY29ubmVjdE1lc3NhZ2VzIGFzIGMsIGRpc2Nvbm5lY3RNZXNzYWdlcyBhcyBkLCBzZXRVcE1lc3NhZ2VzIGFzIHMsIHVwZGF0ZU1lc3NhZ2VzIGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dDluLWRjNjdhYjk2LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYxLjAuNVxuICovXG5mdW5jdGlvbiByZ2JUb0hleChjb2xvcikge1xuICBjb25zdCB7IHIsIGcsIGIgfSA9IGNvbG9yO1xuICByZXR1cm4gYCMke3IudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKX0ke2cudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKX0ke2JcbiAgICAudG9TdHJpbmcoMTYpXG4gICAgLnBhZFN0YXJ0KDIsIFwiMFwiKX1gLnRvTG93ZXJDYXNlKCk7XG59XG5jb25zdCBoZXhDaGFyID0gL15bMC05QS1GXSQvaTtcbmNvbnN0IHNob3J0SGFuZEhleCA9IC9eI1swLTlBLUZdezN9JC9pO1xuY29uc3QgbG9uZ2hhbmRIZXggPSAvXiNbMC05QS1GXXs2fSQvaTtcbmZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4KSB7XG4gIHJldHVybiBpc1Nob3J0aGFuZEhleChoZXgpIHx8IGlzTG9uZ2hhbmRIZXgoaGV4KTtcbn1cbmZ1bmN0aW9uIGlzU2hvcnRoYW5kSGV4KGhleCkge1xuICByZXR1cm4gaGV4ICYmIGhleC5sZW5ndGggPT09IDQgJiYgc2hvcnRIYW5kSGV4LnRlc3QoaGV4KTtcbn1cbmZ1bmN0aW9uIGlzTG9uZ2hhbmRIZXgoaGV4KSB7XG4gIHJldHVybiBoZXggJiYgaGV4Lmxlbmd0aCA9PT0gNyAmJiBsb25naGFuZEhleC50ZXN0KGhleCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVIZXgoaGV4KSB7XG4gIGhleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWhleC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgIGhleCA9IGAjJHtoZXh9YDtcbiAgfVxuICBpZiAoaXNTaG9ydGhhbmRIZXgoaGV4KSkge1xuICAgIHJldHVybiByZ2JUb0hleChoZXhUb1JHQihoZXgpKTtcbiAgfVxuICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9SR0IoaGV4KSB7XG4gIGlmICghaXNWYWxpZEhleChoZXgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGV4ID0gaGV4LnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgIGNvbnN0IFtmaXJzdCwgc2Vjb25kLCB0aGlyZF0gPSBoZXguc3BsaXQoXCJcIik7XG4gICAgY29uc3QgciA9IHBhcnNlSW50KGAke2ZpcnN0fSR7Zmlyc3R9YCwgMTYpO1xuICAgIGNvbnN0IGcgPSBwYXJzZUludChgJHtzZWNvbmR9JHtzZWNvbmR9YCwgMTYpO1xuICAgIGNvbnN0IGIgPSBwYXJzZUludChgJHt0aGlyZH0ke3RoaXJkfWAsIDE2KTtcbiAgICByZXR1cm4geyByLCBnLCBiIH07XG4gIH1cbiAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zbGljZSgwLCAyKSwgMTYpO1xuICBjb25zdCBnID0gcGFyc2VJbnQoaGV4LnNsaWNlKDIsIDQpLCAxNik7XG4gIGNvbnN0IGIgPSBwYXJzZUludChoZXguc2xpY2UoNCwgNiksIDE2KTtcbiAgcmV0dXJuIHsgciwgZywgYiB9O1xufVxuLy8gdGhlc2UgdXRpbHMgYWxsb3cgdXNlcnMgdG8gcGFzcyBlbnVtIHZhbHVlcyBhcyBzdHJpbmdzIHdpdGhvdXQgaGF2aW5nIHRvIGFjY2VzcyB0aGUgZW51bVxuLy8gYmFzZWQgb24gdGhlIGFwcHJvYWNoIHN1Z2dlc3RlZCBieSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3NjkwI2lzc3VlY29tbWVudC0zMjEzNjU3NTksXG5jb25zdCBlbnVtaWZ5ID0gKHgpID0+IHg7XG5jb25zdCBDU1NDb2xvck1vZGUgPSBlbnVtaWZ5KHtcbiAgSEVYOiBcImhleFwiLFxuICBIRVhBOiBcImhleGFcIixcbiAgUkdCX0NTUzogXCJyZ2ItY3NzXCIsXG4gIFJHQkFfQ1NTOiBcInJnYmEtY3NzXCIsXG4gIEhTTF9DU1M6IFwiaHNsLWNzc1wiLFxuICBIU0xBX0NTUzogXCJoc2xhLWNzc1wiXG59KTtcbmNvbnN0IE9iamVjdENvbG9yTW9kZSA9IGVudW1pZnkoe1xuICBSR0I6IFwicmdiXCIsXG4gIFJHQkE6IFwicmdiYVwiLFxuICBIU0w6IFwiaHNsXCIsXG4gIEhTTEE6IFwiaHNsYVwiLFxuICBIU1Y6IFwiaHN2XCIsXG4gIEhTVkE6IFwiaHN2YVwiXG59KTtcbmZ1bmN0aW9uIHBhcnNlTW9kZShjb2xvclZhbHVlKSB7XG4gIGlmICh0eXBlb2YgY29sb3JWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gY29sb3JWYWx1ZTtcbiAgICAgIGlmIChsZW5ndGggPT09IDQgfHwgbGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuSEVYO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA9PT0gNSB8fCBsZW5ndGggPT09IDkpIHtcbiAgICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5IRVhBO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sb3JWYWx1ZS5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICAgIHJldHVybiBDU1NDb2xvck1vZGUuUkdCQV9DU1M7XG4gICAgfVxuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLlJHQl9DU1M7XG4gICAgfVxuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCJoc2woXCIpKSB7XG4gICAgICByZXR1cm4gQ1NTQ29sb3JNb2RlLkhTTF9DU1M7XG4gICAgfVxuICAgIGlmIChjb2xvclZhbHVlLnN0YXJ0c1dpdGgoXCJoc2xhKFwiKSkge1xuICAgICAgcmV0dXJuIENTU0NvbG9yTW9kZS5IU0xBX0NTUztcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2xvclZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiclwiLCBcImdcIiwgXCJiXCIpKSB7XG4gICAgICByZXR1cm4gaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJhXCIpID8gT2JqZWN0Q29sb3JNb2RlLlJHQkEgOiBPYmplY3RDb2xvck1vZGUuUkdCO1xuICAgIH1cbiAgICBpZiAoaGFzQ2hhbm5lbHMoY29sb3JWYWx1ZSwgXCJoXCIsIFwic1wiLCBcImxcIikpIHtcbiAgICAgIHJldHVybiBoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcImFcIikgPyBPYmplY3RDb2xvck1vZGUuSFNMQSA6IE9iamVjdENvbG9yTW9kZS5IU0w7XG4gICAgfVxuICAgIGlmIChoYXNDaGFubmVscyhjb2xvclZhbHVlLCBcImhcIiwgXCJzXCIsIFwidlwiKSkge1xuICAgICAgcmV0dXJuIGhhc0NoYW5uZWxzKGNvbG9yVmFsdWUsIFwiYVwiKSA/IE9iamVjdENvbG9yTW9kZS5IU1ZBIDogT2JqZWN0Q29sb3JNb2RlLkhTVjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoYXNDaGFubmVscyhjb2xvck9iamVjdCwgLi4uY2hhbm5lbHMpIHtcbiAgcmV0dXJuIGNoYW5uZWxzLmV2ZXJ5KChjaGFubmVsKSA9PiBjaGFubmVsICYmIGNvbG9yT2JqZWN0ICYmIGAke2NoYW5uZWx9YCBpbiBjb2xvck9iamVjdCk7XG59XG5mdW5jdGlvbiBjb2xvckVxdWFsKHZhbHVlMSwgdmFsdWUyKSB7XG4gIHJldHVybiB2YWx1ZTE/LnJnYk51bWJlcigpID09PSB2YWx1ZTI/LnJnYk51bWJlcigpO1xufVxuXG5leHBvcnQgeyBDU1NDb2xvck1vZGUgYXMgQywgaXNMb25naGFuZEhleCBhcyBhLCBoZXhDaGFyIGFzIGIsIGNvbG9yRXF1YWwgYXMgYywgaGV4VG9SR0IgYXMgaCwgaXNWYWxpZEhleCBhcyBpLCBub3JtYWxpemVIZXggYXMgbiwgcGFyc2VNb2RlIGFzIHAsIHJnYlRvSGV4IGFzIHIgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMtYTcxZDhlZTkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9