"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_geoenrichment-components_dist_-868c9c"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/arcgis-geoenrichment-databrowser-6ca8ea14.js":
/*!************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/arcgis-geoenrichment-databrowser-6ca8ea14.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ArcGISGeoEnrichmentDataBrowser),
/* harmony export */   a: () => (/* binding */ getGEMessages),
/* harmony export */   b: () => (/* binding */ c),
/* harmony export */   c: () => (/* binding */ createDeferred),
/* harmony export */   d: () => (/* binding */ h),
/* harmony export */   e: () => (/* binding */ e$1),
/* harmony export */   f: () => (/* binding */ f),
/* harmony export */   g: () => (/* binding */ globalObject),
/* harmony export */   h: () => (/* binding */ has),
/* harmony export */   i: () => (/* binding */ isImmediateResult),
/* harmony export */   j: () => (/* binding */ infographicsConfig),
/* harmony export */   s: () => (/* binding */ substituteString),
/* harmony export */   t: () => (/* binding */ t),
/* harmony export */   w: () => (/* binding */ when)
/* harmony export */ });
/* harmony import */ var _index_4a62c63d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-4a62c63d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/index-4a62c63d.js");


/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
const e$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:void 0;

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
var o$1,l,e;let r$1,t$1;const u=null!=(o$1=null==(l=e$1.esriConfig)?void 0:l.locale)?o$1:null==(e=e$1.dojoConfig)?void 0:e.locale;function i$1(){var o,l;return null!=(o=null!=u?u:null==(l=e$1.navigator)?void 0:l.language)?o:"en"}function c(){return void 0===t$1&&(t$1=i$1()),t$1}const d$1=[];function f(n){return d$1.push(n),{remove(){d$1.splice(d$1.indexOf(n),1);}}}const g=[];function h(n){return g.push(n),{remove(){d$1.splice(g.indexOf(n),1);}}}function p(){var n;const o=null!=(n=r$1)?n:i$1();t$1!==o&&(t$1=o,[...g].forEach((n=>{n.call(null,o);})),[...d$1].forEach((n=>{n.call(null,o);})));}null==e$1.addEventListener||e$1.addEventListener("languagechange",p);

/**
 * Safe way to check for global object, which is:
 * - Window in the browser main thread.
 * - WorkerSelf in web workers.
 * - UnitTestsSelf in unit tests.
 */
const globalObject = (() => {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof __webpack_require__.g !== "undefined") {
    return __webpack_require__.g;
  }
})();

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
var d,a;let o;var r,i;null!=(d=e$1.dojoConfig)&&d.has||null!=(a=e$1.esriConfig)&&a.has?o={...null==(r=e$1.dojoConfig)?void 0:r.has,...null==(i=e$1.esriConfig)?void 0:i.has}:o={};function t(d){return "function"==typeof o[d]?o[d]=o[d](e$1):o[d]}t.add=(e,d,a,r)=>((r||void 0===o[e])&&(o[e]=d),a&&t(e)),t.cache=o,t.add("esri-deprecation-warnings",!0),(()=>{t.add("host-webworker",void 0!==e$1.WorkerGlobalScope&&self instanceof e$1.WorkerGlobalScope);const d="undefined"!=typeof window&&"undefined"!=typeof location&&"undefined"!=typeof document&&window.location===location&&window.document===document;if(t.add("host-browser",d),t.add("host-node","object"==typeof e$1.process&&e$1.process.versions&&e$1.process.versions.node&&e$1.process.versions.v8),t.add("dom",d),t("host-browser")){const e=navigator,d=e.userAgent,a=e.appVersion,o=parseFloat(a);if(t.add("wp",parseFloat(d.split("Windows Phone")[1])||void 0),t.add("msapp",parseFloat(d.split("MSAppHost/")[1])||void 0),t.add("khtml",a.indexOf("Konqueror")>=0?o:void 0),t.add("edge",parseFloat(d.split("Edge/")[1])||void 0),t.add("opr",parseFloat(d.split("OPR/")[1])||void 0),t.add("webkit",!t("wp")&&!t("edge")&&parseFloat(d.split("WebKit/")[1])||void 0),t.add("chrome",!t("edge")&&!t("opr")&&parseFloat(d.split("Chrome/")[1])||void 0),t.add("android",!t("wp")&&parseFloat(d.split("Android ")[1])||void 0),t.add("safari",!(a.indexOf("Safari")>=0)||t("wp")||t("chrome")||t("android")||t("edge")||t("opr")?void 0:parseFloat(a.split("Version/")[1])),t.add("mac",a.indexOf("Macintosh")>=0),t.add("quirks","BackCompat"===document.compatMode),!t("wp")&&d.match(/(iPhone|iPod|iPad)/)){const e=RegExp.$1.replace(/P/,"p"),a=d.match(/OS ([\d_]+)/)?RegExp.$1:"1",o=parseFloat(a.replace(/_/,".").replace(/_/g,""));t.add(e,o),t.add("ios",o);}t.add("trident",parseFloat(a.split("Trident/")[1])||void 0),t.add("svg","undefined"!=typeof SVGAngle),t("webkit")||(d.indexOf("Opera")>=0&&t.add("opera",o>=9.8&&parseFloat(d.split("Version/")[1])||o),!(d.indexOf("Gecko")>=0)||t("wp")||t("khtml")||t("trident")||t("edge")||t.add("mozilla",o),t("mozilla")&&t.add("ff",parseFloat(d.split("Firefox/")[1]||d.split("Minefield/")[1])||void 0));}})(),(()=>{if(e$1.navigator){const e=navigator.userAgent,d=e.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini|IEMobile/i),a=e.match(/iPhone/i);d&&t.add("esri-mobile",d),a&&t.add("esri-iPhone",a),t.add("esri-geolocation",!!navigator.geolocation);}t.add("esri-canvas-svg-support",!t("trident")),t.add("esri-wasm","WebAssembly"in e$1),t.add("esri-shared-array-buffer",(()=>{const d="SharedArrayBuffer"in e$1,a=!1===e$1.crossOriginIsolated;return d&&!a})),t.add("esri-atomics","Atomics"in e$1),t.add("esri-workers","Worker"in e$1),t.add("esri-text-decoder","TextDecoder"in e$1),t.add("esri-text-encoder","TextEncoder"in e$1),t.add("featurelayer-snapshot-enabled",!0),t.add("featurelayer-snapshot-point-min-threshold",8e4),t.add("featurelayer-snapshot-point-max-threshold",4e5),t.add("featurelayer-snapshot-point-coverage",.1),t.add("featurelayer-advanced-symbols",!1),t.add("featurelayer-pbf",!0),t.add("featurelayer-pbf-statistics",!1),t.add("feature-layers-workers",!0),t.add("mapview-transitions-duration",200),t.add("mapserver-pbf-enabled",!1),t("host-webworker")||t("host-browser")&&(t.add("csp-restrictions",(()=>{try{new Function;}catch{return !0}return !1})),t.add("esri-image-decode",(()=>{if("decode"in new Image){const e=new Image;return e.src='data:image/svg+xml;charset=UTF-8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg"></svg>',void e.decode().then((()=>{t.add("esri-image-decode",!0,!0,!0);})).catch((()=>{t.add("esri-image-decode",!1,!0,!0);}))}return !1})),t.add("esri-url-encodes-apostrophe",(()=>{const d=e$1.document.createElement("a");return d.href="?'",d.href.indexOf("?%27")>-1})),t.add("vectortilelayer-max-buffers",(()=>t("ff")?160:Number.POSITIVE_INFINITY)));})();

function getGePackage() {
  const require = window.require;
  const packages = require.rawConfig.packages;
  return packages.filter((p) => p.name === "geoenrichment")[0];
}

// esri4.core
//import { createRequire } from "module";
const HTTP_S_RE = /^(http:\/\/|https:\/\/)/i;
/**
 * Checks for esri has features and features that come from defaultConfig.hasCache in build profiles.
 * See build/* for more details.
 *
 * Values:
 * - mac - True for MacOS.
 * - dojo-built - True for any dojo build including report player own builds.
 * - report-player-dist-build - True for this specific build. See build/report-player-dist.profile.js for more details.
 * - report-player-app-build - True for this specific build. See build/report-player-app.profile.js for more details.
 * - report-player-cdn-build - True for this specific build. See build/report-player-cdn.profile.js for more details.
 */
function has(name) {
  if (name === "worker") {
    // put it here to avoid cyclic dependency with WorkerUtil.ts
    return globalObject.isWorker === true;
  }
  if (!!t(name)) {
    return true; // the value is found the esri/core/has
  }
  if (has("worker")) {
    return false; // can't use has check in the worker except for has("worker")
  }
  if (globalObject.require && globalObject.require) {
    const value = !!globalObject.require.has.cache[name];
    if (value) {
      return true; // the value is found in dojo has
    }
  }
  // special case: CDN build
  // check if the package URL is pointing to a remote source
  if (name === "report-player-cdn-build" && HTTP_S_RE.test(getGePackage().location)) {
    return true;
  }
  return false;
}

/**
 * Type guard: tests an object to have 'then' function.
 * @param obj Tested object.
 * @returns The true value if this is a promise-like object.
 */
function isPromiseLike(obj) {
  return obj && typeof obj.then === "function";
}
/**
 * Creates a deferred controller.
 * @returns A new controller.
 */
function createDeferred() {
  let dfd, fulfilled = false;
  const promise = new Promise((resolveCallback, rejectCallback) => {
    dfd = {
      promise: null,
      resolve: (value) => {
        fulfilled = true;
        resolveCallback(value);
      },
      reject: (reason) => {
        fulfilled = true;
        rejectCallback(reason);
      },
      isFulfilled: () => fulfilled
    };
  });
  dfd.promise = promise;
  return dfd;
}
/**
 * Decorates a value with a promise if necessary.
 * @param valueOrPromise A value or promise.
 * @returns An original promise or a new promise wrapping the value.
 */
function when(valueOrPromise) {
  return valueOrPromise instanceof Promise ? valueOrPromise : Promise.resolve(valueOrPromise);
}
/**
 * Tests a value to be an immediate result.
 * @param value A tested value.
 * @returns The true if this result can be got immediatelly.
 */
function isImmediateResult(value) {
  return !isPromiseLike(value) ||
    !!value._isImmediatePromise && isImmediateResult(value._immediateResult);
}
// POLYFILL (for JS API)
if (!Promise.allSettled) {
  Promise.allSettled = (promises) => {
    const mappedPromises = promises.map((p) => p
      .then((value) => ({
      status: "fulfilled",
      value
    }))
      .catch((reason) => ({
      status: "rejected",
      reason
    })));
    return Promise.all(mappedPromises);
  };
}

// geoenrichment.utils
/**
 * Loads a file by path, relative to the origin HTML.
 */
function loadLocalFile(path) {
  let dfd = createDeferred();
  let txtFile = new XMLHttpRequest();
  txtFile.onreadystatechange = () => {
    // don't check for status here, because status can be 0 if the file is loaded via the file system and not https
    if (txtFile.readyState === 4 /* && txtFile.status === 200 */) {
      dfd.resolve(txtFile.responseText);
      dfd = null;
      txtFile = null;
    }
    else if (txtFile.status === 404 /* not found */) {
      dfd.reject(new Error("File not found."));
    }
  };
  txtFile.onerror = (e) => {
    dfd.reject(e);
  };
  txtFile.open("GET", path, true);
  txtFile.send(null);
  return dfd.promise;
}

/**
 * Applies all properites from a source object to a target object. Traverses inner objects.
 * Undefined properties are not written from the source object.
 * Undefined properties in the target object are overwritten.
 *
 * @param targetObject                 Object. Target object (object to write to).
 * @param sourceObject                 Object. Source object (object to write from).
 * @param overwrite                    Boolean. If true, overrides existing non-object properties.
 *
 * @returns targetObject.
 */
function populateObject(targetObject, sourceObject, overwrite = false) {
  function _populateObject(source, target) {
    if (!source || !target) {
      return; // can't proceed
    }
    // check for arrays
    if ((Array.isArray(source) && !Array.isArray(target)) || (Array.isArray(target) && !Array.isArray(source))) {
      return; // can't proceed for objects of different types
    }
    function processSourceId(id) {
      const sourceValue = source[id];
      let targetValue = target[id];
      const isSourceObject = sourceValue && typeof sourceValue === "object";
      const isTargetObject = targetValue && typeof targetValue === "object";
      if (sourceValue === undefined) {
        return; // skip: don't write undefined values
      }
      if (targetValue === undefined) {
        // pass whatever the source value is (except undefined)
        target[id] = sourceValue;
      }
      else if (isTargetObject && isSourceObject) {
        // work with 2 objects
        _populateObject(sourceValue, targetValue);
      }
      else if (overwrite) {
        if (isSourceObject) {
          // we can create a new object in the target object instead of the current value
          targetValue = target[id] = {};
          _populateObject(sourceValue, targetValue);
        }
        // just overrite the existing value
        else {
          target[id] = source[id];
        }
      }
    }
    if (Array.isArray(source)) {
      source.forEach((_item, index) => {
        processSourceId(index);
      });
    }
    else {
      for (const id in source) {
        processSourceId(id);
      }
    }
  }
  _populateObject(sourceObject, targetObject);
  return targetObject;
}
//--------------------------------------------------------------------------
//
// String substitute (replacement for dojo/string.js)
//
//--------------------------------------------------------------------------
const SUBST_RE = /\$\{.+?\}/g;
const SUBST_CLEAN_UP_RE = /^\$\{|\}$/g;
/**
 * @param params.nested Whether to allow nested properties, such as "person.name".
 * @example
 *  substituteString("Name is ${name}", { name: "Tom" }); // => "Name is Tom"
 *  substituteString("Name is ${cat.name}", { cat: { name: "Tom" } }, null, { nested: true }); // => "Name is Tom"
 */
function substituteString(pattern, source, transform, params) {
  return pattern.replace(SUBST_RE, (match) => {
    let value;
    const propName = match.replace(SUBST_CLEAN_UP_RE, "");
    if (params && params.nested && propName.indexOf(".") !== -1) {
      value = source;
      propName.split(".").forEach((subProp) => {
        value = value[subProp];
      });
    }
    else {
      value = source[propName];
    }
    return transform ? transform(value + "") : value + "";
  });
}
// TESTS
//console.log("Current locale number: " + util.formatNumber(100000.123, { places: 3 }));

// esri4.intl
const loadedModules = {};
/**
 * Custom locale set by user to override the browser's current locale.
 */
let userLocale;
/**
 * Current locale of the last loaded messages.
 */
let currentLocale;
const loadedLocalePromises = {};
const SUPPORTED_LOCALES = ["en", "ar", "bg", "bs", "ca", "cs", "de", "el", "es", "et", "fi", "fr", "he", "hr", "hu", "id", "it", "ja", "ko", "lt", "lv", "nb", "nl", "pl", "pt-BR", "pt-PT", "ro", "ru", "sk", "sl", "sr", "sv", "th", "tr", "uk", "vi", "zh-CN", "zh-HK", "zh-TW"];
function getGEMessages(moduleName) {
  const localeData = loadedModules[currentLocale];
  const module = localeData && localeData[moduleName];
  if (!module) {
    throw new Error("Messages are not loaded.");
  }
  return module;
}
/**
 * Specify the locale to load message files for.
 */
function setGELocale(locale) {
  userLocale = locale;
}
function _getModulePaths() {
  if (has("report-player-dist-build")) {
    // this is configured in the grunt file for this particular build
    return {
      infographics: "t9n/infographics",
      ReportPlayer: "t9n/ReportPlayer",
      widgets: "t9n/widgets"
    };
  }
  return {
    DataBrowser: "t9n/DataBrowser",
    infographics: "t9n/infographics",
    ReportPlayer: "t9n/ReportPlayer",
    widgets: "t9n/widgets"
  };
}
/**
 * Loads all messages used in geoenrichment.
 */
function loadGEMessages(assetPath) {
  // Check for full locale match (e.g. pt-BR = pt-BR, if not check for 2 character match (pt = pt))
  const defaultLocale = SUPPORTED_LOCALES[0];
  let locale = (userLocale || c());
  if (SUPPORTED_LOCALES.indexOf(locale) === -1) {
    locale = (userLocale || c()).substr(0, 2);
    if (SUPPORTED_LOCALES.indexOf(locale) === -1) {
      locale = defaultLocale; // common
    }
  }
  currentLocale = locale;
  if (loadedLocalePromises[locale]) {
    return loadedLocalePromises[locale]; // already being loaded
  }
  const promises = [];
  if (!loadedModules[locale]) {
    const localeData = (loadedModules[locale] = {});
    const paths = _getModulePaths();
    for (const moduleName in paths) {
      promises.push(_loadJsonFile(assetPath + `${paths[moduleName]}/${moduleName}_${locale}.json`).then((moduleJson) => {
        localeData[moduleName] = moduleJson;
        // provide missing properties for non-default locale
        if (locale !== defaultLocale) {
          return when((loadedModules[defaultLocale] && loadedModules[defaultLocale][moduleName]) ||
            _loadJsonFile(assetPath + `${paths[moduleName]}/${moduleName}_${defaultLocale}.json`)).then((moduleJson) => {
            populateObject(localeData[moduleName], moduleJson);
          });
        }
        return null;
      }));
    }
  }
  return (loadedLocalePromises[locale] = Promise.all(promises).then(() => { }));
}
function _loadJsonFile(path) {
  if (!globalObject.XMLHttpRequest) {
    return Promise.resolve({}); // in unit tests
  }
  return loadLocalFile(path)
    .then((responseText) => JSON.parse(responseText))
    .catch(() => ({}));
}
//!has("worker") && loadGEMessages(); // kick off the load right away if not in the worker (there may be issues loading JSON files in workers, so we need to initialize this utility using the loadedModulesToJSON() => loadedModulesFromJSON() methods)

// esri4.core
const protocol = "https:"; // always HTTPS
const infographicsConfig = {
  token: "",
  portalUrl: protocol + "//arcgis.com",
  server: protocol + "//geoenrich.arcgis.com/arcgis/rest/services/World/GeoenrichmentServer",
  levels: ["Admin3", "Admin2"],
  highestLevel: "Admin1",
  locatorUrl: protocol + "//geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer",
  addressFormat: "${Address}, ${City}, ${Region} ${Postal}",
  prizm5: {
    /**
     * Trick: when using this panel with data coming from the geoenrichment server, attributes may be taken from metadata.xml
     * instead of the original feature attributes. In this case we can only guess by using a loose search.
     *
     * @example
     * Original field name is "PZMD70_HHD"
     * Field from metadata.xml may look like this "FIELD_PZMD70HHD"
     */
    allowLooseAttributesGuess: false
  }
};

/**
 * Locale list (in alphabetical order) adopted from [JSAPI](https://devtopia.esri.com/WebGIS/arcgis-js-api/tree/master/esri/nls)
 * Full forms adopted from [1](https://www.science.co.il/language/Locale-codes.php) and [2](https://saimana.com/list-of-country-locale-code/)
 */
const SupportedLocales = {
  Arabic: "ar",
  Bosnian: "bs",
  Bulgarian: "bg",
  Catalan: "ca",
  Czech: "cs",
  Danish: "da",
  German: "de",
  Greek: "el",
  English: "en",
  EnglishUSA: "en-US",
  Spanish: "es",
  Estonian: "et",
  Finnish: "fi",
  French: "fr",
  Hebrew: "he",
  Croatian: "hr",
  Hungarian: "hu",
  Indonesian: "id",
  Italian: "it",
  Japanese: "ja",
  Korean: "ko",
  Lithuanian: "lt",
  Latvian: "lv",
  NorwegianBokml: "nb",
  Dutch: "nl",
  Polish: "pl",
  PortugueseBrazil: "pt-BR",
  PortuguesePortugal: "pt-PT",
  Romanian: "ro",
  Russian: "ru",
  Serbian: "sr",
  Slovenian: "sl",
  Slovak: "sk",
  Swedish: "sv",
  Thai: "th",
  Turkish: "tr",
  Ukrainian: "uk",
  Vietnamese: "vi",
  ChineseChina: "zh-CN",
  ChineseHongKong: "zh-HK",
  ChineseTaiwan: "zh-TW"
};
/**
 * This is list of locales for supporting different number and date formats ,
 * for cases in UI we may need to use them
 */
const SupportedLocalesForFormats = [
  ...Object.values(SupportedLocales),
  "ar-u-nu-latn",
  "en-AU",
  "en-GB",
  "es-ES",
  "es-MX",
  "de-CH",
  "de-DE",
  "it-CH",
  "it-IT"
];
/**
 * List of supported locales that are RTL
 * Adopted from https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/4master/esri/intl/locale.ts
 */
const RTLLocales = [SupportedLocales.Arabic, SupportedLocales.Hebrew];

/*
https://medium.com/@Cookie_Cookson/hi-lisa-backer-d0ebcdc2ff3e
https://dockyard.com/blog/2019/04/16/lazy-loading-custom-assets-with-stenciljs-part-1
uses the loaded script tag of the component to get the resource url
example:
<script type="module" src="http://127.0.0.1:5500/packages/arcgis-charts-config-components/dist/arcgis-charts-config-components/arcgis-charts-config-components.esm.js"
data-stencil-namespace="arcgis-charts-config-components"></script>
*/
/* Not working
function getPublicPath(componentName: string): string {
  const script: HTMLScriptElement = document.querySelector(
    `script[data-stencil-namespace='${componentName}']`
  ) as HTMLScriptElement;
  return script?.getAttribute("data-resources-url") ?? "";
}
*/
/**
 * Extracts language portion of locale code
 * Reference: https://github.com/meikidd/locale-code/blob/master/src/index.js#L8
 * Examples:
 * - en-US => en
 * - zh-CN => zh
 * - zh-cn => zh
 * - en => en
 * @param locale
 */
function extractLanguageTag(locale) {
  const localeCodeRegex = /^([a-z]{2})-([A-Z]{2})$/;
  const match = locale === null || locale === void 0 ? void 0 : locale.match(localeCodeRegex);
  let output = SupportedLocales.English;
  if (match !== null && match !== undefined && (match === null || match === void 0 ? void 0 : match.length) > 1) {
    output = match[1];
  }
  else if ((locale === null || locale === void 0 ? void 0 : locale.length) === 2 && locale.toLowerCase() === locale) {
    output = locale;
  }
  return output;
}
/**
 * Converts a given locale into a supported locale.
 * In case of an unsupported locale, "en" is returned.
 * Examples:
 * - en-US => en-US
 * - zh-CN => zh-CN
 * - en => en
 * - es-AR => es
 * - en-UK => en
 * @param locale
 */
function convertToSupportedLocale(locale) {
  let output = SupportedLocales.English;
  if (locale !== undefined) {
    const supportedLocales = Object.values(SupportedLocales);
    const hyphenatedSupportedLocales = supportedLocales.filter((ele) => {
      return ele.indexOf("-") !== -1;
    });
    if (locale.indexOf("-") !== -1) {
      const [lang, region] = locale.split("-");
      // To make sure it is valid locale code of form `zh-CN`.
      // In ArcGIS Online user locale codes come with region in lower case `zh-cn`.
      // TODO Remove next Eslint ignore comment.
      locale = `${lang}-${region.toUpperCase()}`;
    }
    if (hyphenatedSupportedLocales.includes(locale) === true) {
      output = locale;
    }
    else {
      const languageTag = extractLanguageTag(locale);
      if (supportedLocales.includes(languageTag) === true) {
        output = languageTag;
      }
    }
  }
  return output;
}
/**
 * Converts a given locale into a supported format locale.
 * In case of an unsupported locale, "en" is returned.
 * Examples:
 * - en-AU => en-AU
 * - zh-CN => zh-CN
 * - en => en
 * - en-GB => en-GB
 * - it-CH => it-CH
 * - it-ch => it-CH
 * @param locale
 */
function convertToSupportedFormatLocale(locale) {
  let formatLocale = SupportedLocalesForFormats.find((item) => item === locale);
  if (formatLocale === undefined) {
    formatLocale = locale;
  }
  if (formatLocale !== undefined && formatLocale.indexOf("-") !== -1) {
    const [lang, region] = formatLocale.split("-");
    formatLocale = `${lang}-${region.toUpperCase()}`;
  }
  // Special handling to maintain latn numbering system for arabic locale
  // https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/4master/esri/intl/number.ts#L11
  if (formatLocale === "ar") {
    formatLocale = "ar-u-nu-latn";
  }
  return formatLocale;
}
/**
 * Helper function to find the closest element crossing multiple (parent) shadowDOM boundaries.
 * The implementation is based on [this](https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd) solution.
 * @param {string} selector
 * @param {Element} base
 */
function getClosestElement(selector, base) {
  function closestFrom(el) {
    let element;
    if (el === undefined || el === document || el === window)
      element = null;
    else {
      const found = el.closest(selector);
      element = found || closestFrom(el.getRootNode().host);
    }
    return element;
  }
  return closestFrom(base);
}
/**
 * Finds the locale of the closest element to the given element.
 * If no element given, and converts `window.navigator.language` into a supported locale.
 * @param element
 */
function getLocaleInfo(element = document.documentElement) {
  var _a;
  const closestElement = getClosestElement("[lang]", element);
  const locale = (_a = closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) !== null && _a !== void 0 ? _a : window.navigator.language;
  const convertedLocale = convertToSupportedLocale(locale);
  const formatLocale = convertToSupportedFormatLocale(locale);
  return { locale: convertedLocale, rtl: RTLLocales.includes(convertedLocale), formatLocale };
}

const ArcGISGeoEnrichmentDataBrowser = class {
  constructor(hostRef) {
    (0,_index_4a62c63d_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
    this.pageLoaded = (0,_index_4a62c63d_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "pageLoaded", 7);
    this.widget = undefined;
    this.allowHierarchies = undefined;
    this.hideApplyButton = false;
    this.applyButton = undefined;
    this.hideBackButton = false;
    this.backButton = undefined;
    this.hideCancelButton = false;
    this.cancelButton = undefined;
    this.hidePageBackButton = false;
    this.pageBackButton = undefined;
    this.countryId = undefined;
    this.geoenrichmentUrl = undefined;
    this.locale = undefined;
    this.displayAllGlobalVariables = false;
  }
  componentWillLoad() {
    // Set GeoenrichmentUrl if it's specified
    if (this.geoenrichmentUrl) {
      infographicsConfig.server = this.geoenrichmentUrl;
    }
    // Pull locale from lang attribute
    const locale = getLocaleInfo(this.el); // this.getComponentClosestLanguage(this.el);
    if (locale) {
      setGELocale(locale.locale);
    }
    loadGEMessages((0,_index_4a62c63d_js__WEBPACK_IMPORTED_MODULE_0__.g)(".")).then(() => {
      __webpack_require__.e(/*! import() */ "vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_geoenrichment-components_dist_-e5d173").then(__webpack_require__.bind(__webpack_require__, /*! ./DataBrowser-5ce2ade9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/DataBrowser-5ce2ade9.js")).then(function (n) { return n.dT; }).then(async (DataBrowser) => {
        const databrowserDiv = document.createElement("div");
        if (locale.rtl) {
          this.el.classList.add("esri4GEDataBrowser-rtl");
        }
        this.el.appendChild(databrowserDiv);
        this.widget = new DataBrowser.DataBrowser({
          countryID: this.countryId,
          allowHierarchies: this.allowHierarchies,
          displayAllGlobalVariables: this.displayAllGlobalVariables
        }, databrowserDiv);
        // Apply Button
        if (this.hideApplyButton) {
          this.widget.applyButton = null;
        }
        else if (this.applyButton) {
          this.widget.applyButton = this.applyButton;
        }
        // Back Button
        if (this.hideBackButton) {
          this.widget.backButton = null;
        }
        else if (this.backButton) {
          this.widget.backButton = this.backButton;
        }
        // Cancel Button
        if (this.hideCancelButton) {
          this.widget.cancelButton = null;
        }
        else if (this.cancelButton) {
          this.widget.cancelButton = this.cancelButton;
        }
        // Page Back Button
        if (this.hidePageBackButton) {
          this.widget.pageBackButton = null;
        }
        else if (this.pageBackButton) {
          this.widget.pageBackButton = this.pageBackButton;
        }
        this.widget.on("pageLoaded", (e) => {
          this.pageLoaded.emit(e.pageName);
        });
        this.widget.launch();
      });
    });
  }
  getComponentClosestLanguage(element) {
    let closestElement = element.closest('[lang]');
    return closestElement ? closestElement.lang : '';
  }
  async getSelectedVariables() {
    return this.widget.selection;
  }
  async back() {
    this.widget.back();
  }
  setCountry(countryID) {
    this.widget.countryID = this.countryId;
  }
  static get assetsDirs() { return ["t9n"]; }
  get el() { return (0,_index_4a62c63d_js__WEBPACK_IMPORTED_MODULE_0__.a)(this); }
};



//# sourceMappingURL=arcgis-geoenrichment-databrowser-6ca8ea14.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/arcgis-geoenrichment-databrowser.entry.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/arcgis-geoenrichment-databrowser.entry.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_geoenrichment_databrowser: () => (/* reexport safe */ _arcgis_geoenrichment_databrowser_6ca8ea14_js__WEBPACK_IMPORTED_MODULE_0__.A)
/* harmony export */ });
/* harmony import */ var _arcgis_geoenrichment_databrowser_6ca8ea14_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arcgis-geoenrichment-databrowser-6ca8ea14.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/arcgis-geoenrichment-databrowser-6ca8ea14.js");
/* harmony import */ var _index_4a62c63d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-4a62c63d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/geoenrichment-components/dist/esm/index-4a62c63d.js");



//# sourceMappingURL=arcgis-geoenrichment-databrowser.entry.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfZ2VvZW5yaWNobWVudC1jb21wb25lbnRzX2Rpc3RfLTg2OGM5Yy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0g7O0FBRWxIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0lBQXdJLHFCQUFNLENBQUMscUJBQU07O0FBRXJKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZLDBHQUEwRyxlQUFlLFFBQVEsNEVBQTRFLGFBQWEscUNBQXFDLGFBQWEsY0FBYyxvQkFBb0IsU0FBUyxnQ0FBZ0MsV0FBVyxjQUFjLGtCQUFrQixTQUFTLDhCQUE4QixhQUFhLE1BQU0sOEJBQThCLG9DQUFvQyxnQkFBZ0IseUJBQXlCLGdCQUFnQixLQUFLOztBQUVwbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFNO0FBQ25CLFdBQVcscUJBQU07QUFDakI7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNLFFBQVEsb0VBQW9FLGtGQUFrRixNQUFNLGNBQWMsbURBQW1ELDhHQUE4Ryw4RkFBOEYsdUpBQXVKLHVMQUF1TCwrREFBK0QsOHdCQUE4d0IsNEhBQTRILDJCQUEyQixxWUFBcVksVUFBVSxrQkFBa0IsNkhBQTZILHVHQUF1Ryw2SEFBNkgsaUVBQWlFLGFBQWEsMnBCQUEycEIsSUFBSSxjQUFjLE1BQU0sVUFBVSxVQUFVLG1DQUFtQyx5QkFBeUIsa0JBQWtCLGlDQUFpQyx1R0FBdUcscUNBQXFDLGVBQWUscUNBQXFDLEdBQUcsVUFBVSw2Q0FBNkMsd0NBQXdDLDZDQUE2QyxxRkFBcUY7O0FBRTN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLLEtBQUssYUFBYSxHQUFHO0FBQzFELGdDQUFnQyxTQUFTLEtBQUssT0FBTyxlQUFlLFVBQVUsY0FBYyxHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVzs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLE9BQU87QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLGNBQWM7QUFDMUY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxJQUFJLEtBQUssSUFBSSxRQUFRLEVBQUUsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUUsU0FBUyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssR0FBRyxxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLLEdBQUcscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHFEQUFnQjtBQUNwQixzQkFBc0IscURBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBWTtBQUMvQixNQUFNLHlWQUFtQyxxQkFBcUIsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGFBQWEsT0FBTyxxREFBVTtBQUM5Qjs7QUFFd087O0FBRXhPOzs7Ozs7Ozs7Ozs7Ozs7O0FDN3FCdUc7QUFDMUU7O0FBRTdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvZ2VvZW5yaWNobWVudC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1nZW9lbnJpY2htZW50LWRhdGFicm93c2VyLTZjYThlYTE0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2dlb2VucmljaG1lbnQtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtZ2VvZW5yaWNobWVudC1kYXRhYnJvd3Nlci5lbnRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGcgYXMgZ2V0QXNzZXRQYXRoLCBhIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LTRhNjJjNjNkLmpzJztcblxuLypcbkFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMTkvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxuKi9cbmNvbnN0IGUkMT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6dm9pZCAwO1xuXG4vKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4xOS9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xudmFyIG8kMSxsLGU7bGV0IHIkMSx0JDE7Y29uc3QgdT1udWxsIT0obyQxPW51bGw9PShsPWUkMS5lc3JpQ29uZmlnKT92b2lkIDA6bC5sb2NhbGUpP28kMTpudWxsPT0oZT1lJDEuZG9qb0NvbmZpZyk/dm9pZCAwOmUubG9jYWxlO2Z1bmN0aW9uIGkkMSgpe3ZhciBvLGw7cmV0dXJuIG51bGwhPShvPW51bGwhPXU/dTpudWxsPT0obD1lJDEubmF2aWdhdG9yKT92b2lkIDA6bC5sYW5ndWFnZSk/bzpcImVuXCJ9ZnVuY3Rpb24gYygpe3JldHVybiB2b2lkIDA9PT10JDEmJih0JDE9aSQxKCkpLHQkMX1jb25zdCBkJDE9W107ZnVuY3Rpb24gZihuKXtyZXR1cm4gZCQxLnB1c2gobikse3JlbW92ZSgpe2QkMS5zcGxpY2UoZCQxLmluZGV4T2YobiksMSk7fX19Y29uc3QgZz1bXTtmdW5jdGlvbiBoKG4pe3JldHVybiBnLnB1c2gobikse3JlbW92ZSgpe2QkMS5zcGxpY2UoZy5pbmRleE9mKG4pLDEpO319fWZ1bmN0aW9uIHAoKXt2YXIgbjtjb25zdCBvPW51bGwhPShuPXIkMSk/bjppJDEoKTt0JDEhPT1vJiYodCQxPW8sWy4uLmddLmZvckVhY2goKG49PntuLmNhbGwobnVsbCxvKTt9KSksWy4uLmQkMV0uZm9yRWFjaCgobj0+e24uY2FsbChudWxsLG8pO30pKSk7fW51bGw9PWUkMS5hZGRFdmVudExpc3RlbmVyfHxlJDEuYWRkRXZlbnRMaXN0ZW5lcihcImxhbmd1YWdlY2hhbmdlXCIscCk7XG5cbi8qKlxyXG4gKiBTYWZlIHdheSB0byBjaGVjayBmb3IgZ2xvYmFsIG9iamVjdCwgd2hpY2ggaXM6XHJcbiAqIC0gV2luZG93IGluIHRoZSBicm93c2VyIG1haW4gdGhyZWFkLlxyXG4gKiAtIFdvcmtlclNlbGYgaW4gd2ViIHdvcmtlcnMuXHJcbiAqIC0gVW5pdFRlc3RzU2VsZiBpbiB1bml0IHRlc3RzLlxyXG4gKi9cclxuY29uc3QgZ2xvYmFsT2JqZWN0ID0gKCgpID0+IHtcclxuICAvLyB0aGUgb25seSByZWxpYWJsZSBtZWFucyB0byBnZXQgdGhlIGdsb2JhbCBvYmplY3QgaXNcclxuICAvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcclxuICAvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cclxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJldHVybiBnbG9iYWxUaGlzO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJldHVybiBzZWxmO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgcmV0dXJuIHdpbmRvdztcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJldHVybiBnbG9iYWw7XHJcbiAgfVxyXG59KSgpO1xuXG4vKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4xOS9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xudmFyIGQsYTtsZXQgbzt2YXIgcixpO251bGwhPShkPWUkMS5kb2pvQ29uZmlnKSYmZC5oYXN8fG51bGwhPShhPWUkMS5lc3JpQ29uZmlnKSYmYS5oYXM/bz17Li4ubnVsbD09KHI9ZSQxLmRvam9Db25maWcpP3ZvaWQgMDpyLmhhcywuLi5udWxsPT0oaT1lJDEuZXNyaUNvbmZpZyk/dm9pZCAwOmkuaGFzfTpvPXt9O2Z1bmN0aW9uIHQoZCl7cmV0dXJuIFwiZnVuY3Rpb25cIj09dHlwZW9mIG9bZF0/b1tkXT1vW2RdKGUkMSk6b1tkXX10LmFkZD0oZSxkLGEscik9Pigocnx8dm9pZCAwPT09b1tlXSkmJihvW2VdPWQpLGEmJnQoZSkpLHQuY2FjaGU9byx0LmFkZChcImVzcmktZGVwcmVjYXRpb24td2FybmluZ3NcIiwhMCksKCgpPT57dC5hZGQoXCJob3N0LXdlYndvcmtlclwiLHZvaWQgMCE9PWUkMS5Xb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIGUkMS5Xb3JrZXJHbG9iYWxTY29wZSk7Y29uc3QgZD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbG9jYXRpb24mJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmd2luZG93LmxvY2F0aW9uPT09bG9jYXRpb24mJndpbmRvdy5kb2N1bWVudD09PWRvY3VtZW50O2lmKHQuYWRkKFwiaG9zdC1icm93c2VyXCIsZCksdC5hZGQoXCJob3N0LW5vZGVcIixcIm9iamVjdFwiPT10eXBlb2YgZSQxLnByb2Nlc3MmJmUkMS5wcm9jZXNzLnZlcnNpb25zJiZlJDEucHJvY2Vzcy52ZXJzaW9ucy5ub2RlJiZlJDEucHJvY2Vzcy52ZXJzaW9ucy52OCksdC5hZGQoXCJkb21cIixkKSx0KFwiaG9zdC1icm93c2VyXCIpKXtjb25zdCBlPW5hdmlnYXRvcixkPWUudXNlckFnZW50LGE9ZS5hcHBWZXJzaW9uLG89cGFyc2VGbG9hdChhKTtpZih0LmFkZChcIndwXCIscGFyc2VGbG9hdChkLnNwbGl0KFwiV2luZG93cyBQaG9uZVwiKVsxXSl8fHZvaWQgMCksdC5hZGQoXCJtc2FwcFwiLHBhcnNlRmxvYXQoZC5zcGxpdChcIk1TQXBwSG9zdC9cIilbMV0pfHx2b2lkIDApLHQuYWRkKFwia2h0bWxcIixhLmluZGV4T2YoXCJLb25xdWVyb3JcIik+PTA/bzp2b2lkIDApLHQuYWRkKFwiZWRnZVwiLHBhcnNlRmxvYXQoZC5zcGxpdChcIkVkZ2UvXCIpWzFdKXx8dm9pZCAwKSx0LmFkZChcIm9wclwiLHBhcnNlRmxvYXQoZC5zcGxpdChcIk9QUi9cIilbMV0pfHx2b2lkIDApLHQuYWRkKFwid2Via2l0XCIsIXQoXCJ3cFwiKSYmIXQoXCJlZGdlXCIpJiZwYXJzZUZsb2F0KGQuc3BsaXQoXCJXZWJLaXQvXCIpWzFdKXx8dm9pZCAwKSx0LmFkZChcImNocm9tZVwiLCF0KFwiZWRnZVwiKSYmIXQoXCJvcHJcIikmJnBhcnNlRmxvYXQoZC5zcGxpdChcIkNocm9tZS9cIilbMV0pfHx2b2lkIDApLHQuYWRkKFwiYW5kcm9pZFwiLCF0KFwid3BcIikmJnBhcnNlRmxvYXQoZC5zcGxpdChcIkFuZHJvaWQgXCIpWzFdKXx8dm9pZCAwKSx0LmFkZChcInNhZmFyaVwiLCEoYS5pbmRleE9mKFwiU2FmYXJpXCIpPj0wKXx8dChcIndwXCIpfHx0KFwiY2hyb21lXCIpfHx0KFwiYW5kcm9pZFwiKXx8dChcImVkZ2VcIil8fHQoXCJvcHJcIik/dm9pZCAwOnBhcnNlRmxvYXQoYS5zcGxpdChcIlZlcnNpb24vXCIpWzFdKSksdC5hZGQoXCJtYWNcIixhLmluZGV4T2YoXCJNYWNpbnRvc2hcIik+PTApLHQuYWRkKFwicXVpcmtzXCIsXCJCYWNrQ29tcGF0XCI9PT1kb2N1bWVudC5jb21wYXRNb2RlKSwhdChcIndwXCIpJiZkLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkvKSl7Y29uc3QgZT1SZWdFeHAuJDEucmVwbGFjZSgvUC8sXCJwXCIpLGE9ZC5tYXRjaCgvT1MgKFtcXGRfXSspLyk/UmVnRXhwLiQxOlwiMVwiLG89cGFyc2VGbG9hdChhLnJlcGxhY2UoL18vLFwiLlwiKS5yZXBsYWNlKC9fL2csXCJcIikpO3QuYWRkKGUsbyksdC5hZGQoXCJpb3NcIixvKTt9dC5hZGQoXCJ0cmlkZW50XCIscGFyc2VGbG9hdChhLnNwbGl0KFwiVHJpZGVudC9cIilbMV0pfHx2b2lkIDApLHQuYWRkKFwic3ZnXCIsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNWR0FuZ2xlKSx0KFwid2Via2l0XCIpfHwoZC5pbmRleE9mKFwiT3BlcmFcIik+PTAmJnQuYWRkKFwib3BlcmFcIixvPj05LjgmJnBhcnNlRmxvYXQoZC5zcGxpdChcIlZlcnNpb24vXCIpWzFdKXx8byksIShkLmluZGV4T2YoXCJHZWNrb1wiKT49MCl8fHQoXCJ3cFwiKXx8dChcImtodG1sXCIpfHx0KFwidHJpZGVudFwiKXx8dChcImVkZ2VcIil8fHQuYWRkKFwibW96aWxsYVwiLG8pLHQoXCJtb3ppbGxhXCIpJiZ0LmFkZChcImZmXCIscGFyc2VGbG9hdChkLnNwbGl0KFwiRmlyZWZveC9cIilbMV18fGQuc3BsaXQoXCJNaW5lZmllbGQvXCIpWzFdKXx8dm9pZCAwKSk7fX0pKCksKCgpPT57aWYoZSQxLm5hdmlnYXRvcil7Y29uc3QgZT1uYXZpZ2F0b3IudXNlckFnZW50LGQ9ZS5tYXRjaCgvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8T3BlcmEgTWluaXxJRU1vYmlsZS9pKSxhPWUubWF0Y2goL2lQaG9uZS9pKTtkJiZ0LmFkZChcImVzcmktbW9iaWxlXCIsZCksYSYmdC5hZGQoXCJlc3JpLWlQaG9uZVwiLGEpLHQuYWRkKFwiZXNyaS1nZW9sb2NhdGlvblwiLCEhbmF2aWdhdG9yLmdlb2xvY2F0aW9uKTt9dC5hZGQoXCJlc3JpLWNhbnZhcy1zdmctc3VwcG9ydFwiLCF0KFwidHJpZGVudFwiKSksdC5hZGQoXCJlc3JpLXdhc21cIixcIldlYkFzc2VtYmx5XCJpbiBlJDEpLHQuYWRkKFwiZXNyaS1zaGFyZWQtYXJyYXktYnVmZmVyXCIsKCgpPT57Y29uc3QgZD1cIlNoYXJlZEFycmF5QnVmZmVyXCJpbiBlJDEsYT0hMT09PWUkMS5jcm9zc09yaWdpbklzb2xhdGVkO3JldHVybiBkJiYhYX0pKSx0LmFkZChcImVzcmktYXRvbWljc1wiLFwiQXRvbWljc1wiaW4gZSQxKSx0LmFkZChcImVzcmktd29ya2Vyc1wiLFwiV29ya2VyXCJpbiBlJDEpLHQuYWRkKFwiZXNyaS10ZXh0LWRlY29kZXJcIixcIlRleHREZWNvZGVyXCJpbiBlJDEpLHQuYWRkKFwiZXNyaS10ZXh0LWVuY29kZXJcIixcIlRleHRFbmNvZGVyXCJpbiBlJDEpLHQuYWRkKFwiZmVhdHVyZWxheWVyLXNuYXBzaG90LWVuYWJsZWRcIiwhMCksdC5hZGQoXCJmZWF0dXJlbGF5ZXItc25hcHNob3QtcG9pbnQtbWluLXRocmVzaG9sZFwiLDhlNCksdC5hZGQoXCJmZWF0dXJlbGF5ZXItc25hcHNob3QtcG9pbnQtbWF4LXRocmVzaG9sZFwiLDRlNSksdC5hZGQoXCJmZWF0dXJlbGF5ZXItc25hcHNob3QtcG9pbnQtY292ZXJhZ2VcIiwuMSksdC5hZGQoXCJmZWF0dXJlbGF5ZXItYWR2YW5jZWQtc3ltYm9sc1wiLCExKSx0LmFkZChcImZlYXR1cmVsYXllci1wYmZcIiwhMCksdC5hZGQoXCJmZWF0dXJlbGF5ZXItcGJmLXN0YXRpc3RpY3NcIiwhMSksdC5hZGQoXCJmZWF0dXJlLWxheWVycy13b3JrZXJzXCIsITApLHQuYWRkKFwibWFwdmlldy10cmFuc2l0aW9ucy1kdXJhdGlvblwiLDIwMCksdC5hZGQoXCJtYXBzZXJ2ZXItcGJmLWVuYWJsZWRcIiwhMSksdChcImhvc3Qtd2Vid29ya2VyXCIpfHx0KFwiaG9zdC1icm93c2VyXCIpJiYodC5hZGQoXCJjc3AtcmVzdHJpY3Rpb25zXCIsKCgpPT57dHJ5e25ldyBGdW5jdGlvbjt9Y2F0Y2h7cmV0dXJuICEwfXJldHVybiAhMX0pKSx0LmFkZChcImVzcmktaW1hZ2UtZGVjb2RlXCIsKCgpPT57aWYoXCJkZWNvZGVcImluIG5ldyBJbWFnZSl7Y29uc3QgZT1uZXcgSW1hZ2U7cmV0dXJuIGUuc3JjPSdkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCw8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PC9zdmc+Jyx2b2lkIGUuZGVjb2RlKCkudGhlbigoKCk9Pnt0LmFkZChcImVzcmktaW1hZ2UtZGVjb2RlXCIsITAsITAsITApO30pKS5jYXRjaCgoKCk9Pnt0LmFkZChcImVzcmktaW1hZ2UtZGVjb2RlXCIsITEsITAsITApO30pKX1yZXR1cm4gITF9KSksdC5hZGQoXCJlc3JpLXVybC1lbmNvZGVzLWFwb3N0cm9waGVcIiwoKCk9Pntjb25zdCBkPWUkMS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtyZXR1cm4gZC5ocmVmPVwiPydcIixkLmhyZWYuaW5kZXhPZihcIj8lMjdcIik+LTF9KSksdC5hZGQoXCJ2ZWN0b3J0aWxlbGF5ZXItbWF4LWJ1ZmZlcnNcIiwoKCk9PnQoXCJmZlwiKT8xNjA6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSkpO30pKCk7XG5cbmZ1bmN0aW9uIGdldEdlUGFja2FnZSgpIHtcclxuICBjb25zdCByZXF1aXJlID0gd2luZG93LnJlcXVpcmU7XHJcbiAgY29uc3QgcGFja2FnZXMgPSByZXF1aXJlLnJhd0NvbmZpZy5wYWNrYWdlcztcclxuICByZXR1cm4gcGFja2FnZXMuZmlsdGVyKChwKSA9PiBwLm5hbWUgPT09IFwiZ2VvZW5yaWNobWVudFwiKVswXTtcclxufVxuXG4vLyBlc3JpNC5jb3JlXHJcbi8vaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gXCJtb2R1bGVcIjtcclxuY29uc3QgSFRUUF9TX1JFID0gL14oaHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvKS9pO1xyXG4vKipcclxuICogQ2hlY2tzIGZvciBlc3JpIGhhcyBmZWF0dXJlcyBhbmQgZmVhdHVyZXMgdGhhdCBjb21lIGZyb20gZGVmYXVsdENvbmZpZy5oYXNDYWNoZSBpbiBidWlsZCBwcm9maWxlcy5cclxuICogU2VlIGJ1aWxkLyogZm9yIG1vcmUgZGV0YWlscy5cclxuICpcclxuICogVmFsdWVzOlxyXG4gKiAtIG1hYyAtIFRydWUgZm9yIE1hY09TLlxyXG4gKiAtIGRvam8tYnVpbHQgLSBUcnVlIGZvciBhbnkgZG9qbyBidWlsZCBpbmNsdWRpbmcgcmVwb3J0IHBsYXllciBvd24gYnVpbGRzLlxyXG4gKiAtIHJlcG9ydC1wbGF5ZXItZGlzdC1idWlsZCAtIFRydWUgZm9yIHRoaXMgc3BlY2lmaWMgYnVpbGQuIFNlZSBidWlsZC9yZXBvcnQtcGxheWVyLWRpc3QucHJvZmlsZS5qcyBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gKiAtIHJlcG9ydC1wbGF5ZXItYXBwLWJ1aWxkIC0gVHJ1ZSBmb3IgdGhpcyBzcGVjaWZpYyBidWlsZC4gU2VlIGJ1aWxkL3JlcG9ydC1wbGF5ZXItYXBwLnByb2ZpbGUuanMgZm9yIG1vcmUgZGV0YWlscy5cclxuICogLSByZXBvcnQtcGxheWVyLWNkbi1idWlsZCAtIFRydWUgZm9yIHRoaXMgc3BlY2lmaWMgYnVpbGQuIFNlZSBidWlsZC9yZXBvcnQtcGxheWVyLWNkbi5wcm9maWxlLmpzIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXMobmFtZSkge1xyXG4gIGlmIChuYW1lID09PSBcIndvcmtlclwiKSB7XHJcbiAgICAvLyBwdXQgaXQgaGVyZSB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSB3aXRoIFdvcmtlclV0aWwudHNcclxuICAgIHJldHVybiBnbG9iYWxPYmplY3QuaXNXb3JrZXIgPT09IHRydWU7XHJcbiAgfVxyXG4gIGlmICghIXQobmFtZSkpIHtcclxuICAgIHJldHVybiB0cnVlOyAvLyB0aGUgdmFsdWUgaXMgZm91bmQgdGhlIGVzcmkvY29yZS9oYXNcclxuICB9XHJcbiAgaWYgKGhhcyhcIndvcmtlclwiKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4ndCB1c2UgaGFzIGNoZWNrIGluIHRoZSB3b3JrZXIgZXhjZXB0IGZvciBoYXMoXCJ3b3JrZXJcIilcclxuICB9XHJcbiAgaWYgKGdsb2JhbE9iamVjdC5yZXF1aXJlICYmIGdsb2JhbE9iamVjdC5yZXF1aXJlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9ICEhZ2xvYmFsT2JqZWN0LnJlcXVpcmUuaGFzLmNhY2hlW25hbWVdO1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB0cnVlOyAvLyB0aGUgdmFsdWUgaXMgZm91bmQgaW4gZG9qbyBoYXNcclxuICAgIH1cclxuICB9XHJcbiAgLy8gc3BlY2lhbCBjYXNlOiBDRE4gYnVpbGRcclxuICAvLyBjaGVjayBpZiB0aGUgcGFja2FnZSBVUkwgaXMgcG9pbnRpbmcgdG8gYSByZW1vdGUgc291cmNlXHJcbiAgaWYgKG5hbWUgPT09IFwicmVwb3J0LXBsYXllci1jZG4tYnVpbGRcIiAmJiBIVFRQX1NfUkUudGVzdChnZXRHZVBhY2thZ2UoKS5sb2NhdGlvbikpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQ6IHRlc3RzIGFuIG9iamVjdCB0byBoYXZlICd0aGVuJyBmdW5jdGlvbi5cclxuICogQHBhcmFtIG9iaiBUZXN0ZWQgb2JqZWN0LlxyXG4gKiBAcmV0dXJucyBUaGUgdHJ1ZSB2YWx1ZSBpZiB0aGlzIGlzIGEgcHJvbWlzZS1saWtlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2Uob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGRlZmVycmVkIGNvbnRyb2xsZXIuXHJcbiAqIEByZXR1cm5zIEEgbmV3IGNvbnRyb2xsZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZCgpIHtcclxuICBsZXQgZGZkLCBmdWxmaWxsZWQgPSBmYWxzZTtcclxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVDYWxsYmFjaywgcmVqZWN0Q2FsbGJhY2spID0+IHtcclxuICAgIGRmZCA9IHtcclxuICAgICAgcHJvbWlzZTogbnVsbCxcclxuICAgICAgcmVzb2x2ZTogKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgZnVsZmlsbGVkID0gdHJ1ZTtcclxuICAgICAgICByZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xyXG4gICAgICB9LFxyXG4gICAgICByZWplY3Q6IChyZWFzb24pID0+IHtcclxuICAgICAgICBmdWxmaWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIHJlamVjdENhbGxiYWNrKHJlYXNvbik7XHJcbiAgICAgIH0sXHJcbiAgICAgIGlzRnVsZmlsbGVkOiAoKSA9PiBmdWxmaWxsZWRcclxuICAgIH07XHJcbiAgfSk7XHJcbiAgZGZkLnByb21pc2UgPSBwcm9taXNlO1xyXG4gIHJldHVybiBkZmQ7XHJcbn1cclxuLyoqXHJcbiAqIERlY29yYXRlcyBhIHZhbHVlIHdpdGggYSBwcm9taXNlIGlmIG5lY2Vzc2FyeS5cclxuICogQHBhcmFtIHZhbHVlT3JQcm9taXNlIEEgdmFsdWUgb3IgcHJvbWlzZS5cclxuICogQHJldHVybnMgQW4gb3JpZ2luYWwgcHJvbWlzZSBvciBhIG5ldyBwcm9taXNlIHdyYXBwaW5nIHRoZSB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHdoZW4odmFsdWVPclByb21pc2UpIHtcclxuICByZXR1cm4gdmFsdWVPclByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlID8gdmFsdWVPclByb21pc2UgOiBQcm9taXNlLnJlc29sdmUodmFsdWVPclByb21pc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBUZXN0cyBhIHZhbHVlIHRvIGJlIGFuIGltbWVkaWF0ZSByZXN1bHQuXHJcbiAqIEBwYXJhbSB2YWx1ZSBBIHRlc3RlZCB2YWx1ZS5cclxuICogQHJldHVybnMgVGhlIHRydWUgaWYgdGhpcyByZXN1bHQgY2FuIGJlIGdvdCBpbW1lZGlhdGVsbHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0ltbWVkaWF0ZVJlc3VsdCh2YWx1ZSkge1xyXG4gIHJldHVybiAhaXNQcm9taXNlTGlrZSh2YWx1ZSkgfHxcclxuICAgICEhdmFsdWUuX2lzSW1tZWRpYXRlUHJvbWlzZSAmJiBpc0ltbWVkaWF0ZVJlc3VsdCh2YWx1ZS5faW1tZWRpYXRlUmVzdWx0KTtcclxufVxyXG4vLyBQT0xZRklMTCAoZm9yIEpTIEFQSSlcclxuaWYgKCFQcm9taXNlLmFsbFNldHRsZWQpIHtcclxuICBQcm9taXNlLmFsbFNldHRsZWQgPSAocHJvbWlzZXMpID0+IHtcclxuICAgIGNvbnN0IG1hcHBlZFByb21pc2VzID0gcHJvbWlzZXMubWFwKChwKSA9PiBwXHJcbiAgICAgIC50aGVuKCh2YWx1ZSkgPT4gKHtcclxuICAgICAgc3RhdHVzOiBcImZ1bGZpbGxlZFwiLFxyXG4gICAgICB2YWx1ZVxyXG4gICAgfSkpXHJcbiAgICAgIC5jYXRjaCgocmVhc29uKSA9PiAoe1xyXG4gICAgICBzdGF0dXM6IFwicmVqZWN0ZWRcIixcclxuICAgICAgcmVhc29uXHJcbiAgICB9KSkpO1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKG1hcHBlZFByb21pc2VzKTtcclxuICB9O1xyXG59XG5cbi8vIGdlb2VucmljaG1lbnQudXRpbHNcclxuLyoqXHJcbiAqIExvYWRzIGEgZmlsZSBieSBwYXRoLCByZWxhdGl2ZSB0byB0aGUgb3JpZ2luIEhUTUwuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkTG9jYWxGaWxlKHBhdGgpIHtcclxuICBsZXQgZGZkID0gY3JlYXRlRGVmZXJyZWQoKTtcclxuICBsZXQgdHh0RmlsZSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gIHR4dEZpbGUub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgLy8gZG9uJ3QgY2hlY2sgZm9yIHN0YXR1cyBoZXJlLCBiZWNhdXNlIHN0YXR1cyBjYW4gYmUgMCBpZiB0aGUgZmlsZSBpcyBsb2FkZWQgdmlhIHRoZSBmaWxlIHN5c3RlbSBhbmQgbm90IGh0dHBzXHJcbiAgICBpZiAodHh0RmlsZS5yZWFkeVN0YXRlID09PSA0IC8qICYmIHR4dEZpbGUuc3RhdHVzID09PSAyMDAgKi8pIHtcclxuICAgICAgZGZkLnJlc29sdmUodHh0RmlsZS5yZXNwb25zZVRleHQpO1xyXG4gICAgICBkZmQgPSBudWxsO1xyXG4gICAgICB0eHRGaWxlID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR4dEZpbGUuc3RhdHVzID09PSA0MDQgLyogbm90IGZvdW5kICovKSB7XHJcbiAgICAgIGRmZC5yZWplY3QobmV3IEVycm9yKFwiRmlsZSBub3QgZm91bmQuXCIpKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHR4dEZpbGUub25lcnJvciA9IChlKSA9PiB7XHJcbiAgICBkZmQucmVqZWN0KGUpO1xyXG4gIH07XHJcbiAgdHh0RmlsZS5vcGVuKFwiR0VUXCIsIHBhdGgsIHRydWUpO1xyXG4gIHR4dEZpbGUuc2VuZChudWxsKTtcclxuICByZXR1cm4gZGZkLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEFwcGxpZXMgYWxsIHByb3Blcml0ZXMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LiBUcmF2ZXJzZXMgaW5uZXIgb2JqZWN0cy5cclxuICogVW5kZWZpbmVkIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0dGVuIGZyb20gdGhlIHNvdXJjZSBvYmplY3QuXHJcbiAqIFVuZGVmaW5lZCBwcm9wZXJ0aWVzIGluIHRoZSB0YXJnZXQgb2JqZWN0IGFyZSBvdmVyd3JpdHRlbi5cclxuICpcclxuICogQHBhcmFtIHRhcmdldE9iamVjdCAgICAgICAgICAgICAgICAgT2JqZWN0LiBUYXJnZXQgb2JqZWN0IChvYmplY3QgdG8gd3JpdGUgdG8pLlxyXG4gKiBAcGFyYW0gc291cmNlT2JqZWN0ICAgICAgICAgICAgICAgICBPYmplY3QuIFNvdXJjZSBvYmplY3QgKG9iamVjdCB0byB3cml0ZSBmcm9tKS5cclxuICogQHBhcmFtIG92ZXJ3cml0ZSAgICAgICAgICAgICAgICAgICAgQm9vbGVhbi4gSWYgdHJ1ZSwgb3ZlcnJpZGVzIGV4aXN0aW5nIG5vbi1vYmplY3QgcHJvcGVydGllcy5cclxuICpcclxuICogQHJldHVybnMgdGFyZ2V0T2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcG9wdWxhdGVPYmplY3QodGFyZ2V0T2JqZWN0LCBzb3VyY2VPYmplY3QsIG92ZXJ3cml0ZSA9IGZhbHNlKSB7XHJcbiAgZnVuY3Rpb24gX3BvcHVsYXRlT2JqZWN0KHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICBpZiAoIXNvdXJjZSB8fCAhdGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybjsgLy8gY2FuJ3QgcHJvY2VlZFxyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgZm9yIGFycmF5c1xyXG4gICAgaWYgKChBcnJheS5pc0FycmF5KHNvdXJjZSkgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkgfHwgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSkge1xyXG4gICAgICByZXR1cm47IC8vIGNhbid0IHByb2NlZWQgZm9yIG9iamVjdHMgb2YgZGlmZmVyZW50IHR5cGVzXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzU291cmNlSWQoaWQpIHtcclxuICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBzb3VyY2VbaWRdO1xyXG4gICAgICBsZXQgdGFyZ2V0VmFsdWUgPSB0YXJnZXRbaWRdO1xyXG4gICAgICBjb25zdCBpc1NvdXJjZU9iamVjdCA9IHNvdXJjZVZhbHVlICYmIHR5cGVvZiBzb3VyY2VWYWx1ZSA9PT0gXCJvYmplY3RcIjtcclxuICAgICAgY29uc3QgaXNUYXJnZXRPYmplY3QgPSB0YXJnZXRWYWx1ZSAmJiB0eXBlb2YgdGFyZ2V0VmFsdWUgPT09IFwib2JqZWN0XCI7XHJcbiAgICAgIGlmIChzb3VyY2VWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBza2lwOiBkb24ndCB3cml0ZSB1bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRhcmdldFZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBwYXNzIHdoYXRldmVyIHRoZSBzb3VyY2UgdmFsdWUgaXMgKGV4Y2VwdCB1bmRlZmluZWQpXHJcbiAgICAgICAgdGFyZ2V0W2lkXSA9IHNvdXJjZVZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGlzVGFyZ2V0T2JqZWN0ICYmIGlzU291cmNlT2JqZWN0KSB7XHJcbiAgICAgICAgLy8gd29yayB3aXRoIDIgb2JqZWN0c1xyXG4gICAgICAgIF9wb3B1bGF0ZU9iamVjdChzb3VyY2VWYWx1ZSwgdGFyZ2V0VmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKG92ZXJ3cml0ZSkge1xyXG4gICAgICAgIGlmIChpc1NvdXJjZU9iamVjdCkge1xyXG4gICAgICAgICAgLy8gd2UgY2FuIGNyZWF0ZSBhIG5ldyBvYmplY3QgaW4gdGhlIHRhcmdldCBvYmplY3QgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2YWx1ZVxyXG4gICAgICAgICAgdGFyZ2V0VmFsdWUgPSB0YXJnZXRbaWRdID0ge307XHJcbiAgICAgICAgICBfcG9wdWxhdGVPYmplY3Qoc291cmNlVmFsdWUsIHRhcmdldFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8ganVzdCBvdmVycml0ZSB0aGUgZXhpc3RpbmcgdmFsdWVcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRhcmdldFtpZF0gPSBzb3VyY2VbaWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICBzb3VyY2UuZm9yRWFjaCgoX2l0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1NvdXJjZUlkKGluZGV4KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgZm9yIChjb25zdCBpZCBpbiBzb3VyY2UpIHtcclxuICAgICAgICBwcm9jZXNzU291cmNlSWQoaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9wb3B1bGF0ZU9iamVjdChzb3VyY2VPYmplY3QsIHRhcmdldE9iamVjdCk7XHJcbiAgcmV0dXJuIHRhcmdldE9iamVjdDtcclxufVxyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vXHJcbi8vIFN0cmluZyBzdWJzdGl0dXRlIChyZXBsYWNlbWVudCBmb3IgZG9qby9zdHJpbmcuanMpXHJcbi8vXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgU1VCU1RfUkUgPSAvXFwkXFx7Lis/XFx9L2c7XHJcbmNvbnN0IFNVQlNUX0NMRUFOX1VQX1JFID0gL15cXCRcXHt8XFx9JC9nO1xyXG4vKipcclxuICogQHBhcmFtIHBhcmFtcy5uZXN0ZWQgV2hldGhlciB0byBhbGxvdyBuZXN0ZWQgcHJvcGVydGllcywgc3VjaCBhcyBcInBlcnNvbi5uYW1lXCIuXHJcbiAqIEBleGFtcGxlXHJcbiAqICBzdWJzdGl0dXRlU3RyaW5nKFwiTmFtZSBpcyAke25hbWV9XCIsIHsgbmFtZTogXCJUb21cIiB9KTsgLy8gPT4gXCJOYW1lIGlzIFRvbVwiXHJcbiAqICBzdWJzdGl0dXRlU3RyaW5nKFwiTmFtZSBpcyAke2NhdC5uYW1lfVwiLCB7IGNhdDogeyBuYW1lOiBcIlRvbVwiIH0gfSwgbnVsbCwgeyBuZXN0ZWQ6IHRydWUgfSk7IC8vID0+IFwiTmFtZSBpcyBUb21cIlxyXG4gKi9cclxuZnVuY3Rpb24gc3Vic3RpdHV0ZVN0cmluZyhwYXR0ZXJuLCBzb3VyY2UsIHRyYW5zZm9ybSwgcGFyYW1zKSB7XHJcbiAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZShTVUJTVF9SRSwgKG1hdGNoKSA9PiB7XHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICBjb25zdCBwcm9wTmFtZSA9IG1hdGNoLnJlcGxhY2UoU1VCU1RfQ0xFQU5fVVBfUkUsIFwiXCIpO1xyXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMubmVzdGVkICYmIHByb3BOYW1lLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xyXG4gICAgICB2YWx1ZSA9IHNvdXJjZTtcclxuICAgICAgcHJvcE5hbWUuc3BsaXQoXCIuXCIpLmZvckVhY2goKHN1YlByb3ApID0+IHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlW3N1YlByb3BdO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB2YWx1ZSA9IHNvdXJjZVtwcm9wTmFtZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtID8gdHJhbnNmb3JtKHZhbHVlICsgXCJcIikgOiB2YWx1ZSArIFwiXCI7XHJcbiAgfSk7XHJcbn1cclxuLy8gVEVTVFNcclxuLy9jb25zb2xlLmxvZyhcIkN1cnJlbnQgbG9jYWxlIG51bWJlcjogXCIgKyB1dGlsLmZvcm1hdE51bWJlcigxMDAwMDAuMTIzLCB7IHBsYWNlczogMyB9KSk7XG5cbi8vIGVzcmk0LmludGxcclxuY29uc3QgbG9hZGVkTW9kdWxlcyA9IHt9O1xyXG4vKipcclxuICogQ3VzdG9tIGxvY2FsZSBzZXQgYnkgdXNlciB0byBvdmVycmlkZSB0aGUgYnJvd3NlcidzIGN1cnJlbnQgbG9jYWxlLlxyXG4gKi9cclxubGV0IHVzZXJMb2NhbGU7XHJcbi8qKlxyXG4gKiBDdXJyZW50IGxvY2FsZSBvZiB0aGUgbGFzdCBsb2FkZWQgbWVzc2FnZXMuXHJcbiAqL1xyXG5sZXQgY3VycmVudExvY2FsZTtcclxuY29uc3QgbG9hZGVkTG9jYWxlUHJvbWlzZXMgPSB7fTtcclxuY29uc3QgU1VQUE9SVEVEX0xPQ0FMRVMgPSBbXCJlblwiLCBcImFyXCIsIFwiYmdcIiwgXCJic1wiLCBcImNhXCIsIFwiY3NcIiwgXCJkZVwiLCBcImVsXCIsIFwiZXNcIiwgXCJldFwiLCBcImZpXCIsIFwiZnJcIiwgXCJoZVwiLCBcImhyXCIsIFwiaHVcIiwgXCJpZFwiLCBcIml0XCIsIFwiamFcIiwgXCJrb1wiLCBcImx0XCIsIFwibHZcIiwgXCJuYlwiLCBcIm5sXCIsIFwicGxcIiwgXCJwdC1CUlwiLCBcInB0LVBUXCIsIFwicm9cIiwgXCJydVwiLCBcInNrXCIsIFwic2xcIiwgXCJzclwiLCBcInN2XCIsIFwidGhcIiwgXCJ0clwiLCBcInVrXCIsIFwidmlcIiwgXCJ6aC1DTlwiLCBcInpoLUhLXCIsIFwiemgtVFdcIl07XHJcbmZ1bmN0aW9uIGdldEdFTWVzc2FnZXMobW9kdWxlTmFtZSkge1xyXG4gIGNvbnN0IGxvY2FsZURhdGEgPSBsb2FkZWRNb2R1bGVzW2N1cnJlbnRMb2NhbGVdO1xyXG4gIGNvbnN0IG1vZHVsZSA9IGxvY2FsZURhdGEgJiYgbG9jYWxlRGF0YVttb2R1bGVOYW1lXTtcclxuICBpZiAoIW1vZHVsZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZXMgYXJlIG5vdCBsb2FkZWQuXCIpO1xyXG4gIH1cclxuICByZXR1cm4gbW9kdWxlO1xyXG59XHJcbi8qKlxyXG4gKiBTcGVjaWZ5IHRoZSBsb2NhbGUgdG8gbG9hZCBtZXNzYWdlIGZpbGVzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHNldEdFTG9jYWxlKGxvY2FsZSkge1xyXG4gIHVzZXJMb2NhbGUgPSBsb2NhbGU7XHJcbn1cclxuZnVuY3Rpb24gX2dldE1vZHVsZVBhdGhzKCkge1xyXG4gIGlmIChoYXMoXCJyZXBvcnQtcGxheWVyLWRpc3QtYnVpbGRcIikpIHtcclxuICAgIC8vIHRoaXMgaXMgY29uZmlndXJlZCBpbiB0aGUgZ3J1bnQgZmlsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGJ1aWxkXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpbmZvZ3JhcGhpY3M6IFwidDluL2luZm9ncmFwaGljc1wiLFxyXG4gICAgICBSZXBvcnRQbGF5ZXI6IFwidDluL1JlcG9ydFBsYXllclwiLFxyXG4gICAgICB3aWRnZXRzOiBcInQ5bi93aWRnZXRzXCJcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBEYXRhQnJvd3NlcjogXCJ0OW4vRGF0YUJyb3dzZXJcIixcclxuICAgIGluZm9ncmFwaGljczogXCJ0OW4vaW5mb2dyYXBoaWNzXCIsXHJcbiAgICBSZXBvcnRQbGF5ZXI6IFwidDluL1JlcG9ydFBsYXllclwiLFxyXG4gICAgd2lkZ2V0czogXCJ0OW4vd2lkZ2V0c1wiXHJcbiAgfTtcclxufVxyXG4vKipcclxuICogTG9hZHMgYWxsIG1lc3NhZ2VzIHVzZWQgaW4gZ2VvZW5yaWNobWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRHRU1lc3NhZ2VzKGFzc2V0UGF0aCkge1xyXG4gIC8vIENoZWNrIGZvciBmdWxsIGxvY2FsZSBtYXRjaCAoZS5nLiBwdC1CUiA9IHB0LUJSLCBpZiBub3QgY2hlY2sgZm9yIDIgY2hhcmFjdGVyIG1hdGNoIChwdCA9IHB0KSlcclxuICBjb25zdCBkZWZhdWx0TG9jYWxlID0gU1VQUE9SVEVEX0xPQ0FMRVNbMF07XHJcbiAgbGV0IGxvY2FsZSA9ICh1c2VyTG9jYWxlIHx8IGMoKSk7XHJcbiAgaWYgKFNVUFBPUlRFRF9MT0NBTEVTLmluZGV4T2YobG9jYWxlKSA9PT0gLTEpIHtcclxuICAgIGxvY2FsZSA9ICh1c2VyTG9jYWxlIHx8IGMoKSkuc3Vic3RyKDAsIDIpO1xyXG4gICAgaWYgKFNVUFBPUlRFRF9MT0NBTEVTLmluZGV4T2YobG9jYWxlKSA9PT0gLTEpIHtcclxuICAgICAgbG9jYWxlID0gZGVmYXVsdExvY2FsZTsgLy8gY29tbW9uXHJcbiAgICB9XHJcbiAgfVxyXG4gIGN1cnJlbnRMb2NhbGUgPSBsb2NhbGU7XHJcbiAgaWYgKGxvYWRlZExvY2FsZVByb21pc2VzW2xvY2FsZV0pIHtcclxuICAgIHJldHVybiBsb2FkZWRMb2NhbGVQcm9taXNlc1tsb2NhbGVdOyAvLyBhbHJlYWR5IGJlaW5nIGxvYWRlZFxyXG4gIH1cclxuICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gIGlmICghbG9hZGVkTW9kdWxlc1tsb2NhbGVdKSB7XHJcbiAgICBjb25zdCBsb2NhbGVEYXRhID0gKGxvYWRlZE1vZHVsZXNbbG9jYWxlXSA9IHt9KTtcclxuICAgIGNvbnN0IHBhdGhzID0gX2dldE1vZHVsZVBhdGhzKCk7XHJcbiAgICBmb3IgKGNvbnN0IG1vZHVsZU5hbWUgaW4gcGF0aHMpIHtcclxuICAgICAgcHJvbWlzZXMucHVzaChfbG9hZEpzb25GaWxlKGFzc2V0UGF0aCArIGAke3BhdGhzW21vZHVsZU5hbWVdfS8ke21vZHVsZU5hbWV9XyR7bG9jYWxlfS5qc29uYCkudGhlbigobW9kdWxlSnNvbikgPT4ge1xyXG4gICAgICAgIGxvY2FsZURhdGFbbW9kdWxlTmFtZV0gPSBtb2R1bGVKc29uO1xyXG4gICAgICAgIC8vIHByb3ZpZGUgbWlzc2luZyBwcm9wZXJ0aWVzIGZvciBub24tZGVmYXVsdCBsb2NhbGVcclxuICAgICAgICBpZiAobG9jYWxlICE9PSBkZWZhdWx0TG9jYWxlKSB7XHJcbiAgICAgICAgICByZXR1cm4gd2hlbigobG9hZGVkTW9kdWxlc1tkZWZhdWx0TG9jYWxlXSAmJiBsb2FkZWRNb2R1bGVzW2RlZmF1bHRMb2NhbGVdW21vZHVsZU5hbWVdKSB8fFxyXG4gICAgICAgICAgICBfbG9hZEpzb25GaWxlKGFzc2V0UGF0aCArIGAke3BhdGhzW21vZHVsZU5hbWVdfS8ke21vZHVsZU5hbWV9XyR7ZGVmYXVsdExvY2FsZX0uanNvbmApKS50aGVuKChtb2R1bGVKc29uKSA9PiB7XHJcbiAgICAgICAgICAgIHBvcHVsYXRlT2JqZWN0KGxvY2FsZURhdGFbbW9kdWxlTmFtZV0sIG1vZHVsZUpzb24pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAobG9hZGVkTG9jYWxlUHJvbWlzZXNbbG9jYWxlXSA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHsgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIF9sb2FkSnNvbkZpbGUocGF0aCkge1xyXG4gIGlmICghZ2xvYmFsT2JqZWN0LlhNTEh0dHBSZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTsgLy8gaW4gdW5pdCB0ZXN0c1xyXG4gIH1cclxuICByZXR1cm4gbG9hZExvY2FsRmlsZShwYXRoKVxyXG4gICAgLnRoZW4oKHJlc3BvbnNlVGV4dCkgPT4gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpKVxyXG4gICAgLmNhdGNoKCgpID0+ICh7fSkpO1xyXG59XHJcbi8vIWhhcyhcIndvcmtlclwiKSAmJiBsb2FkR0VNZXNzYWdlcygpOyAvLyBraWNrIG9mZiB0aGUgbG9hZCByaWdodCBhd2F5IGlmIG5vdCBpbiB0aGUgd29ya2VyICh0aGVyZSBtYXkgYmUgaXNzdWVzIGxvYWRpbmcgSlNPTiBmaWxlcyBpbiB3b3JrZXJzLCBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUgdGhpcyB1dGlsaXR5IHVzaW5nIHRoZSBsb2FkZWRNb2R1bGVzVG9KU09OKCkgPT4gbG9hZGVkTW9kdWxlc0Zyb21KU09OKCkgbWV0aG9kcylcblxuLy8gZXNyaTQuY29yZVxyXG5jb25zdCBwcm90b2NvbCA9IFwiaHR0cHM6XCI7IC8vIGFsd2F5cyBIVFRQU1xyXG5jb25zdCBpbmZvZ3JhcGhpY3NDb25maWcgPSB7XHJcbiAgdG9rZW46IFwiXCIsXHJcbiAgcG9ydGFsVXJsOiBwcm90b2NvbCArIFwiLy9hcmNnaXMuY29tXCIsXHJcbiAgc2VydmVyOiBwcm90b2NvbCArIFwiLy9nZW9lbnJpY2guYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZC9HZW9lbnJpY2htZW50U2VydmVyXCIsXHJcbiAgbGV2ZWxzOiBbXCJBZG1pbjNcIiwgXCJBZG1pbjJcIl0sXHJcbiAgaGlnaGVzdExldmVsOiBcIkFkbWluMVwiLFxyXG4gIGxvY2F0b3JVcmw6IHByb3RvY29sICsgXCIvL2dlb2NvZGUuYXJjZ2lzLmNvbS9hcmNnaXMvcmVzdC9zZXJ2aWNlcy9Xb3JsZC9HZW9jb2RlU2VydmVyXCIsXHJcbiAgYWRkcmVzc0Zvcm1hdDogXCIke0FkZHJlc3N9LCAke0NpdHl9LCAke1JlZ2lvbn0gJHtQb3N0YWx9XCIsXHJcbiAgcHJpem01OiB7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWNrOiB3aGVuIHVzaW5nIHRoaXMgcGFuZWwgd2l0aCBkYXRhIGNvbWluZyBmcm9tIHRoZSBnZW9lbnJpY2htZW50IHNlcnZlciwgYXR0cmlidXRlcyBtYXkgYmUgdGFrZW4gZnJvbSBtZXRhZGF0YS54bWxcclxuICAgICAqIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGZlYXR1cmUgYXR0cmlidXRlcy4gSW4gdGhpcyBjYXNlIHdlIGNhbiBvbmx5IGd1ZXNzIGJ5IHVzaW5nIGEgbG9vc2Ugc2VhcmNoLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBPcmlnaW5hbCBmaWVsZCBuYW1lIGlzIFwiUFpNRDcwX0hIRFwiXHJcbiAgICAgKiBGaWVsZCBmcm9tIG1ldGFkYXRhLnhtbCBtYXkgbG9vayBsaWtlIHRoaXMgXCJGSUVMRF9QWk1ENzBISERcIlxyXG4gICAgICovXHJcbiAgICBhbGxvd0xvb3NlQXR0cmlidXRlc0d1ZXNzOiBmYWxzZVxyXG4gIH1cclxufTtcblxuLyoqXHJcbiAqIExvY2FsZSBsaXN0IChpbiBhbHBoYWJldGljYWwgb3JkZXIpIGFkb3B0ZWQgZnJvbSBbSlNBUEldKGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvdHJlZS9tYXN0ZXIvZXNyaS9ubHMpXHJcbiAqIEZ1bGwgZm9ybXMgYWRvcHRlZCBmcm9tIFsxXShodHRwczovL3d3dy5zY2llbmNlLmNvLmlsL2xhbmd1YWdlL0xvY2FsZS1jb2Rlcy5waHApIGFuZCBbMl0oaHR0cHM6Ly9zYWltYW5hLmNvbS9saXN0LW9mLWNvdW50cnktbG9jYWxlLWNvZGUvKVxyXG4gKi9cclxuY29uc3QgU3VwcG9ydGVkTG9jYWxlcyA9IHtcclxuICBBcmFiaWM6IFwiYXJcIixcclxuICBCb3NuaWFuOiBcImJzXCIsXHJcbiAgQnVsZ2FyaWFuOiBcImJnXCIsXHJcbiAgQ2F0YWxhbjogXCJjYVwiLFxyXG4gIEN6ZWNoOiBcImNzXCIsXHJcbiAgRGFuaXNoOiBcImRhXCIsXHJcbiAgR2VybWFuOiBcImRlXCIsXHJcbiAgR3JlZWs6IFwiZWxcIixcclxuICBFbmdsaXNoOiBcImVuXCIsXHJcbiAgRW5nbGlzaFVTQTogXCJlbi1VU1wiLFxyXG4gIFNwYW5pc2g6IFwiZXNcIixcclxuICBFc3RvbmlhbjogXCJldFwiLFxyXG4gIEZpbm5pc2g6IFwiZmlcIixcclxuICBGcmVuY2g6IFwiZnJcIixcclxuICBIZWJyZXc6IFwiaGVcIixcclxuICBDcm9hdGlhbjogXCJoclwiLFxyXG4gIEh1bmdhcmlhbjogXCJodVwiLFxyXG4gIEluZG9uZXNpYW46IFwiaWRcIixcclxuICBJdGFsaWFuOiBcIml0XCIsXHJcbiAgSmFwYW5lc2U6IFwiamFcIixcclxuICBLb3JlYW46IFwia29cIixcclxuICBMaXRodWFuaWFuOiBcImx0XCIsXHJcbiAgTGF0dmlhbjogXCJsdlwiLFxyXG4gIE5vcndlZ2lhbkJva21sOiBcIm5iXCIsXHJcbiAgRHV0Y2g6IFwibmxcIixcclxuICBQb2xpc2g6IFwicGxcIixcclxuICBQb3J0dWd1ZXNlQnJhemlsOiBcInB0LUJSXCIsXHJcbiAgUG9ydHVndWVzZVBvcnR1Z2FsOiBcInB0LVBUXCIsXHJcbiAgUm9tYW5pYW46IFwicm9cIixcclxuICBSdXNzaWFuOiBcInJ1XCIsXHJcbiAgU2VyYmlhbjogXCJzclwiLFxyXG4gIFNsb3ZlbmlhbjogXCJzbFwiLFxyXG4gIFNsb3ZhazogXCJza1wiLFxyXG4gIFN3ZWRpc2g6IFwic3ZcIixcclxuICBUaGFpOiBcInRoXCIsXHJcbiAgVHVya2lzaDogXCJ0clwiLFxyXG4gIFVrcmFpbmlhbjogXCJ1a1wiLFxyXG4gIFZpZXRuYW1lc2U6IFwidmlcIixcclxuICBDaGluZXNlQ2hpbmE6IFwiemgtQ05cIixcclxuICBDaGluZXNlSG9uZ0tvbmc6IFwiemgtSEtcIixcclxuICBDaGluZXNlVGFpd2FuOiBcInpoLVRXXCJcclxufTtcclxuLyoqXHJcbiAqIFRoaXMgaXMgbGlzdCBvZiBsb2NhbGVzIGZvciBzdXBwb3J0aW5nIGRpZmZlcmVudCBudW1iZXIgYW5kIGRhdGUgZm9ybWF0cyAsXHJcbiAqIGZvciBjYXNlcyBpbiBVSSB3ZSBtYXkgbmVlZCB0byB1c2UgdGhlbVxyXG4gKi9cclxuY29uc3QgU3VwcG9ydGVkTG9jYWxlc0ZvckZvcm1hdHMgPSBbXHJcbiAgLi4uT2JqZWN0LnZhbHVlcyhTdXBwb3J0ZWRMb2NhbGVzKSxcclxuICBcImFyLXUtbnUtbGF0blwiLFxyXG4gIFwiZW4tQVVcIixcclxuICBcImVuLUdCXCIsXHJcbiAgXCJlcy1FU1wiLFxyXG4gIFwiZXMtTVhcIixcclxuICBcImRlLUNIXCIsXHJcbiAgXCJkZS1ERVwiLFxyXG4gIFwiaXQtQ0hcIixcclxuICBcIml0LUlUXCJcclxuXTtcclxuLyoqXHJcbiAqIExpc3Qgb2Ygc3VwcG9ydGVkIGxvY2FsZXMgdGhhdCBhcmUgUlRMXHJcbiAqIEFkb3B0ZWQgZnJvbSBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtanMtYXBpL2Jsb2IvNG1hc3Rlci9lc3JpL2ludGwvbG9jYWxlLnRzXHJcbiAqL1xyXG5jb25zdCBSVExMb2NhbGVzID0gW1N1cHBvcnRlZExvY2FsZXMuQXJhYmljLCBTdXBwb3J0ZWRMb2NhbGVzLkhlYnJld107XG5cbi8qXHJcbmh0dHBzOi8vbWVkaXVtLmNvbS9AQ29va2llX0Nvb2tzb24vaGktbGlzYS1iYWNrZXItZDBlYmNkYzJmZjNlXHJcbmh0dHBzOi8vZG9ja3lhcmQuY29tL2Jsb2cvMjAxOS8wNC8xNi9sYXp5LWxvYWRpbmctY3VzdG9tLWFzc2V0cy13aXRoLXN0ZW5jaWxqcy1wYXJ0LTFcclxudXNlcyB0aGUgbG9hZGVkIHNjcmlwdCB0YWcgb2YgdGhlIGNvbXBvbmVudCB0byBnZXQgdGhlIHJlc291cmNlIHVybFxyXG5leGFtcGxlOlxyXG48c2NyaXB0IHR5cGU9XCJtb2R1bGVcIiBzcmM9XCJodHRwOi8vMTI3LjAuMC4xOjU1MDAvcGFja2FnZXMvYXJjZ2lzLWNoYXJ0cy1jb25maWctY29tcG9uZW50cy9kaXN0L2FyY2dpcy1jaGFydHMtY29uZmlnLWNvbXBvbmVudHMvYXJjZ2lzLWNoYXJ0cy1jb25maWctY29tcG9uZW50cy5lc20uanNcIlxyXG5kYXRhLXN0ZW5jaWwtbmFtZXNwYWNlPVwiYXJjZ2lzLWNoYXJ0cy1jb25maWctY29tcG9uZW50c1wiPjwvc2NyaXB0PlxyXG4qL1xyXG4vKiBOb3Qgd29ya2luZ1xyXG5mdW5jdGlvbiBnZXRQdWJsaWNQYXRoKGNvbXBvbmVudE5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3Qgc2NyaXB0OiBIVE1MU2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXHJcbiAgICBgc2NyaXB0W2RhdGEtc3RlbmNpbC1uYW1lc3BhY2U9JyR7Y29tcG9uZW50TmFtZX0nXWBcclxuICApIGFzIEhUTUxTY3JpcHRFbGVtZW50O1xyXG4gIHJldHVybiBzY3JpcHQ/LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzb3VyY2VzLXVybFwiKSA/PyBcIlwiO1xyXG59XHJcbiovXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBsYW5ndWFnZSBwb3J0aW9uIG9mIGxvY2FsZSBjb2RlXHJcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL21laWtpZGQvbG9jYWxlLWNvZGUvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LmpzI0w4XHJcbiAqIEV4YW1wbGVzOlxyXG4gKiAtIGVuLVVTID0+IGVuXHJcbiAqIC0gemgtQ04gPT4gemhcclxuICogLSB6aC1jbiA9PiB6aFxyXG4gKiAtIGVuID0+IGVuXHJcbiAqIEBwYXJhbSBsb2NhbGVcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RMYW5ndWFnZVRhZyhsb2NhbGUpIHtcclxuICBjb25zdCBsb2NhbGVDb2RlUmVnZXggPSAvXihbYS16XXsyfSktKFtBLVpdezJ9KSQvO1xyXG4gIGNvbnN0IG1hdGNoID0gbG9jYWxlID09PSBudWxsIHx8IGxvY2FsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYWxlLm1hdGNoKGxvY2FsZUNvZGVSZWdleCk7XHJcbiAgbGV0IG91dHB1dCA9IFN1cHBvcnRlZExvY2FsZXMuRW5nbGlzaDtcclxuICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2ggIT09IHVuZGVmaW5lZCAmJiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoLmxlbmd0aCkgPiAxKSB7XHJcbiAgICBvdXRwdXQgPSBtYXRjaFsxXTtcclxuICB9XHJcbiAgZWxzZSBpZiAoKGxvY2FsZSA9PT0gbnVsbCB8fCBsb2NhbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvY2FsZS5sZW5ndGgpID09PSAyICYmIGxvY2FsZS50b0xvd2VyQ2FzZSgpID09PSBsb2NhbGUpIHtcclxuICAgIG91dHB1dCA9IGxvY2FsZTtcclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dDtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYSBnaXZlbiBsb2NhbGUgaW50byBhIHN1cHBvcnRlZCBsb2NhbGUuXHJcbiAqIEluIGNhc2Ugb2YgYW4gdW5zdXBwb3J0ZWQgbG9jYWxlLCBcImVuXCIgaXMgcmV0dXJuZWQuXHJcbiAqIEV4YW1wbGVzOlxyXG4gKiAtIGVuLVVTID0+IGVuLVVTXHJcbiAqIC0gemgtQ04gPT4gemgtQ05cclxuICogLSBlbiA9PiBlblxyXG4gKiAtIGVzLUFSID0+IGVzXHJcbiAqIC0gZW4tVUsgPT4gZW5cclxuICogQHBhcmFtIGxvY2FsZVxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFRvU3VwcG9ydGVkTG9jYWxlKGxvY2FsZSkge1xyXG4gIGxldCBvdXRwdXQgPSBTdXBwb3J0ZWRMb2NhbGVzLkVuZ2xpc2g7XHJcbiAgaWYgKGxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zdCBzdXBwb3J0ZWRMb2NhbGVzID0gT2JqZWN0LnZhbHVlcyhTdXBwb3J0ZWRMb2NhbGVzKTtcclxuICAgIGNvbnN0IGh5cGhlbmF0ZWRTdXBwb3J0ZWRMb2NhbGVzID0gc3VwcG9ydGVkTG9jYWxlcy5maWx0ZXIoKGVsZSkgPT4ge1xyXG4gICAgICByZXR1cm4gZWxlLmluZGV4T2YoXCItXCIpICE9PSAtMTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGxvY2FsZS5pbmRleE9mKFwiLVwiKSAhPT0gLTEpIHtcclxuICAgICAgY29uc3QgW2xhbmcsIHJlZ2lvbl0gPSBsb2NhbGUuc3BsaXQoXCItXCIpO1xyXG4gICAgICAvLyBUbyBtYWtlIHN1cmUgaXQgaXMgdmFsaWQgbG9jYWxlIGNvZGUgb2YgZm9ybSBgemgtQ05gLlxyXG4gICAgICAvLyBJbiBBcmNHSVMgT25saW5lIHVzZXIgbG9jYWxlIGNvZGVzIGNvbWUgd2l0aCByZWdpb24gaW4gbG93ZXIgY2FzZSBgemgtY25gLlxyXG4gICAgICAvLyBUT0RPIFJlbW92ZSBuZXh0IEVzbGludCBpZ25vcmUgY29tbWVudC5cclxuICAgICAgbG9jYWxlID0gYCR7bGFuZ30tJHtyZWdpb24udG9VcHBlckNhc2UoKX1gO1xyXG4gICAgfVxyXG4gICAgaWYgKGh5cGhlbmF0ZWRTdXBwb3J0ZWRMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZSkgPT09IHRydWUpIHtcclxuICAgICAgb3V0cHV0ID0gbG9jYWxlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGNvbnN0IGxhbmd1YWdlVGFnID0gZXh0cmFjdExhbmd1YWdlVGFnKGxvY2FsZSk7XHJcbiAgICAgIGlmIChzdXBwb3J0ZWRMb2NhbGVzLmluY2x1ZGVzKGxhbmd1YWdlVGFnKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIG91dHB1dCA9IGxhbmd1YWdlVGFnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgZ2l2ZW4gbG9jYWxlIGludG8gYSBzdXBwb3J0ZWQgZm9ybWF0IGxvY2FsZS5cclxuICogSW4gY2FzZSBvZiBhbiB1bnN1cHBvcnRlZCBsb2NhbGUsIFwiZW5cIiBpcyByZXR1cm5lZC5cclxuICogRXhhbXBsZXM6XHJcbiAqIC0gZW4tQVUgPT4gZW4tQVVcclxuICogLSB6aC1DTiA9PiB6aC1DTlxyXG4gKiAtIGVuID0+IGVuXHJcbiAqIC0gZW4tR0IgPT4gZW4tR0JcclxuICogLSBpdC1DSCA9PiBpdC1DSFxyXG4gKiAtIGl0LWNoID0+IGl0LUNIXHJcbiAqIEBwYXJhbSBsb2NhbGVcclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRUb1N1cHBvcnRlZEZvcm1hdExvY2FsZShsb2NhbGUpIHtcclxuICBsZXQgZm9ybWF0TG9jYWxlID0gU3VwcG9ydGVkTG9jYWxlc0ZvckZvcm1hdHMuZmluZCgoaXRlbSkgPT4gaXRlbSA9PT0gbG9jYWxlKTtcclxuICBpZiAoZm9ybWF0TG9jYWxlID09PSB1bmRlZmluZWQpIHtcclxuICAgIGZvcm1hdExvY2FsZSA9IGxvY2FsZTtcclxuICB9XHJcbiAgaWYgKGZvcm1hdExvY2FsZSAhPT0gdW5kZWZpbmVkICYmIGZvcm1hdExvY2FsZS5pbmRleE9mKFwiLVwiKSAhPT0gLTEpIHtcclxuICAgIGNvbnN0IFtsYW5nLCByZWdpb25dID0gZm9ybWF0TG9jYWxlLnNwbGl0KFwiLVwiKTtcclxuICAgIGZvcm1hdExvY2FsZSA9IGAke2xhbmd9LSR7cmVnaW9uLnRvVXBwZXJDYXNlKCl9YDtcclxuICB9XHJcbiAgLy8gU3BlY2lhbCBoYW5kbGluZyB0byBtYWludGFpbiBsYXRuIG51bWJlcmluZyBzeXN0ZW0gZm9yIGFyYWJpYyBsb2NhbGVcclxuICAvLyBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtanMtYXBpL2Jsb2IvNG1hc3Rlci9lc3JpL2ludGwvbnVtYmVyLnRzI0wxMVxyXG4gIGlmIChmb3JtYXRMb2NhbGUgPT09IFwiYXJcIikge1xyXG4gICAgZm9ybWF0TG9jYWxlID0gXCJhci11LW51LWxhdG5cIjtcclxuICB9XHJcbiAgcmV0dXJuIGZvcm1hdExvY2FsZTtcclxufVxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNsb3Nlc3QgZWxlbWVudCBjcm9zc2luZyBtdWx0aXBsZSAocGFyZW50KSBzaGFkb3dET00gYm91bmRhcmllcy5cclxuICogVGhlIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIFt0aGlzXShodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDUyMDU1NC9jdXN0b20tZWxlbWVudC1nZXRyb290bm9kZS1jbG9zZXN0LWZ1bmN0aW9uLWNyb3NzaW5nLW11bHRpcGxlLXBhcmVudC1zaGFkb3dkKSBzb2x1dGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gYmFzZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEVsZW1lbnQoc2VsZWN0b3IsIGJhc2UpIHtcclxuICBmdW5jdGlvbiBjbG9zZXN0RnJvbShlbCkge1xyXG4gICAgbGV0IGVsZW1lbnQ7XHJcbiAgICBpZiAoZWwgPT09IHVuZGVmaW5lZCB8fCBlbCA9PT0gZG9jdW1lbnQgfHwgZWwgPT09IHdpbmRvdylcclxuICAgICAgZWxlbWVudCA9IG51bGw7XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3QgZm91bmQgPSBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcclxuICAgICAgZWxlbWVudCA9IGZvdW5kIHx8IGNsb3Nlc3RGcm9tKGVsLmdldFJvb3ROb2RlKCkuaG9zdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbiAgcmV0dXJuIGNsb3Nlc3RGcm9tKGJhc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgbG9jYWxlIG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqIElmIG5vIGVsZW1lbnQgZ2l2ZW4sIGFuZCBjb252ZXJ0cyBgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZWAgaW50byBhIHN1cHBvcnRlZCBsb2NhbGUuXHJcbiAqIEBwYXJhbSBlbGVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRMb2NhbGVJbmZvKGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICB2YXIgX2E7XHJcbiAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSBnZXRDbG9zZXN0RWxlbWVudChcIltsYW5nXVwiLCBlbGVtZW50KTtcclxuICBjb25zdCBsb2NhbGUgPSAoX2EgPSBjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZTtcclxuICBjb25zdCBjb252ZXJ0ZWRMb2NhbGUgPSBjb252ZXJ0VG9TdXBwb3J0ZWRMb2NhbGUobG9jYWxlKTtcclxuICBjb25zdCBmb3JtYXRMb2NhbGUgPSBjb252ZXJ0VG9TdXBwb3J0ZWRGb3JtYXRMb2NhbGUobG9jYWxlKTtcclxuICByZXR1cm4geyBsb2NhbGU6IGNvbnZlcnRlZExvY2FsZSwgcnRsOiBSVExMb2NhbGVzLmluY2x1ZGVzKGNvbnZlcnRlZExvY2FsZSksIGZvcm1hdExvY2FsZSB9O1xyXG59XG5cbmNvbnN0IEFyY0dJU0dlb0VucmljaG1lbnREYXRhQnJvd3NlciA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XHJcbiAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xyXG4gICAgdGhpcy5wYWdlTG9hZGVkID0gY3JlYXRlRXZlbnQodGhpcywgXCJwYWdlTG9hZGVkXCIsIDcpO1xyXG4gICAgdGhpcy53aWRnZXQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmFsbG93SGllcmFyY2hpZXMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhpZGVBcHBseUJ1dHRvbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5hcHBseUJ1dHRvbiA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGlkZUJhY2tCdXR0b24gPSBmYWxzZTtcclxuICAgIHRoaXMuYmFja0J1dHRvbiA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGlkZUNhbmNlbEJ1dHRvbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5jYW5jZWxCdXR0b24gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhpZGVQYWdlQmFja0J1dHRvbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5wYWdlQmFja0J1dHRvbiA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuY291bnRyeUlkID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5nZW9lbnJpY2htZW50VXJsID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5sb2NhbGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmRpc3BsYXlBbGxHbG9iYWxWYXJpYWJsZXMgPSBmYWxzZTtcclxuICB9XHJcbiAgY29tcG9uZW50V2lsbExvYWQoKSB7XHJcbiAgICAvLyBTZXQgR2VvZW5yaWNobWVudFVybCBpZiBpdCdzIHNwZWNpZmllZFxyXG4gICAgaWYgKHRoaXMuZ2VvZW5yaWNobWVudFVybCkge1xyXG4gICAgICBpbmZvZ3JhcGhpY3NDb25maWcuc2VydmVyID0gdGhpcy5nZW9lbnJpY2htZW50VXJsO1xyXG4gICAgfVxyXG4gICAgLy8gUHVsbCBsb2NhbGUgZnJvbSBsYW5nIGF0dHJpYnV0ZVxyXG4gICAgY29uc3QgbG9jYWxlID0gZ2V0TG9jYWxlSW5mbyh0aGlzLmVsKTsgLy8gdGhpcy5nZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UodGhpcy5lbCk7XHJcbiAgICBpZiAobG9jYWxlKSB7XHJcbiAgICAgIHNldEdFTG9jYWxlKGxvY2FsZS5sb2NhbGUpO1xyXG4gICAgfVxyXG4gICAgbG9hZEdFTWVzc2FnZXMoZ2V0QXNzZXRQYXRoKFwiLlwiKSkudGhlbigoKSA9PiB7XHJcbiAgICAgIGltcG9ydCgnLi9EYXRhQnJvd3Nlci01Y2UyYWRlOS5qcycpLnRoZW4oZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4uZFQ7IH0pLnRoZW4oYXN5bmMgKERhdGFCcm93c2VyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YWJyb3dzZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGlmIChsb2NhbGUucnRsKSB7XHJcbiAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoXCJlc3JpNEdFRGF0YUJyb3dzZXItcnRsXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGRhdGFicm93c2VyRGl2KTtcclxuICAgICAgICB0aGlzLndpZGdldCA9IG5ldyBEYXRhQnJvd3Nlci5EYXRhQnJvd3Nlcih7XHJcbiAgICAgICAgICBjb3VudHJ5SUQ6IHRoaXMuY291bnRyeUlkLFxyXG4gICAgICAgICAgYWxsb3dIaWVyYXJjaGllczogdGhpcy5hbGxvd0hpZXJhcmNoaWVzLFxyXG4gICAgICAgICAgZGlzcGxheUFsbEdsb2JhbFZhcmlhYmxlczogdGhpcy5kaXNwbGF5QWxsR2xvYmFsVmFyaWFibGVzXHJcbiAgICAgICAgfSwgZGF0YWJyb3dzZXJEaXYpO1xyXG4gICAgICAgIC8vIEFwcGx5IEJ1dHRvblxyXG4gICAgICAgIGlmICh0aGlzLmhpZGVBcHBseUJ1dHRvbikge1xyXG4gICAgICAgICAgdGhpcy53aWRnZXQuYXBwbHlCdXR0b24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwcGx5QnV0dG9uKSB7XHJcbiAgICAgICAgICB0aGlzLndpZGdldC5hcHBseUJ1dHRvbiA9IHRoaXMuYXBwbHlCdXR0b247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJhY2sgQnV0dG9uXHJcbiAgICAgICAgaWYgKHRoaXMuaGlkZUJhY2tCdXR0b24pIHtcclxuICAgICAgICAgIHRoaXMud2lkZ2V0LmJhY2tCdXR0b24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcclxuICAgICAgICAgIHRoaXMud2lkZ2V0LmJhY2tCdXR0b24gPSB0aGlzLmJhY2tCdXR0b247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbmNlbCBCdXR0b25cclxuICAgICAgICBpZiAodGhpcy5oaWRlQ2FuY2VsQnV0dG9uKSB7XHJcbiAgICAgICAgICB0aGlzLndpZGdldC5jYW5jZWxCdXR0b24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNhbmNlbEJ1dHRvbikge1xyXG4gICAgICAgICAgdGhpcy53aWRnZXQuY2FuY2VsQnV0dG9uID0gdGhpcy5jYW5jZWxCdXR0b247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhZ2UgQmFjayBCdXR0b25cclxuICAgICAgICBpZiAodGhpcy5oaWRlUGFnZUJhY2tCdXR0b24pIHtcclxuICAgICAgICAgIHRoaXMud2lkZ2V0LnBhZ2VCYWNrQnV0dG9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYWdlQmFja0J1dHRvbikge1xyXG4gICAgICAgICAgdGhpcy53aWRnZXQucGFnZUJhY2tCdXR0b24gPSB0aGlzLnBhZ2VCYWNrQnV0dG9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZGdldC5vbihcInBhZ2VMb2FkZWRcIiwgKGUpID0+IHtcclxuICAgICAgICAgIHRoaXMucGFnZUxvYWRlZC5lbWl0KGUucGFnZU5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMud2lkZ2V0LmxhdW5jaCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xyXG4gICAgbGV0IGNsb3Nlc3RFbGVtZW50ID0gZWxlbWVudC5jbG9zZXN0KCdbbGFuZ10nKTtcclxuICAgIHJldHVybiBjbG9zZXN0RWxlbWVudCA/IGNsb3Nlc3RFbGVtZW50LmxhbmcgOiAnJztcclxuICB9XHJcbiAgYXN5bmMgZ2V0U2VsZWN0ZWRWYXJpYWJsZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy53aWRnZXQuc2VsZWN0aW9uO1xyXG4gIH1cclxuICBhc3luYyBiYWNrKCkge1xyXG4gICAgdGhpcy53aWRnZXQuYmFjaygpO1xyXG4gIH1cclxuICBzZXRDb3VudHJ5KGNvdW50cnlJRCkge1xyXG4gICAgdGhpcy53aWRnZXQuY291bnRyeUlEID0gdGhpcy5jb3VudHJ5SWQ7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgYXNzZXRzRGlycygpIHsgcmV0dXJuIFtcInQ5blwiXTsgfVxyXG4gIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cclxufTtcblxuZXhwb3J0IHsgQXJjR0lTR2VvRW5yaWNobWVudERhdGFCcm93c2VyIGFzIEEsIGdldEdFTWVzc2FnZXMgYXMgYSwgYyBhcyBiLCBjcmVhdGVEZWZlcnJlZCBhcyBjLCBoIGFzIGQsIGUkMSBhcyBlLCBmLCBnbG9iYWxPYmplY3QgYXMgZywgaGFzIGFzIGgsIGlzSW1tZWRpYXRlUmVzdWx0IGFzIGksIGluZm9ncmFwaGljc0NvbmZpZyBhcyBqLCBzdWJzdGl0dXRlU3RyaW5nIGFzIHMsIHQsIHdoZW4gYXMgdyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtZ2VvZW5yaWNobWVudC1kYXRhYnJvd3Nlci02Y2E4ZWExNC5qcy5tYXAiLCJleHBvcnQgeyBBIGFzIGFyY2dpc19nZW9lbnJpY2htZW50X2RhdGFicm93c2VyIH0gZnJvbSAnLi9hcmNnaXMtZ2VvZW5yaWNobWVudC1kYXRhYnJvd3Nlci02Y2E4ZWExNC5qcyc7XG5pbXBvcnQgJy4vaW5kZXgtNGE2MmM2M2QuanMnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtZ2VvZW5yaWNobWVudC1kYXRhYnJvd3Nlci5lbnRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=