"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_ba-infographic_node_modules_arcgis_business-analyst-components_dis-1c26d4"],{

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/dom-f1ee4d04.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/dom-f1ee4d04.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ containsCrossShadowBoundary),
/* harmony export */   b: () => (/* binding */ getElementDir),
/* harmony export */   c: () => (/* binding */ closestElementCrossShadowBoundary),
/* harmony export */   d: () => (/* binding */ setRequestedIcon),
/* harmony export */   e: () => (/* binding */ getModeName),
/* harmony export */   f: () => (/* binding */ getElementProp),
/* harmony export */   g: () => (/* binding */ getSlotted),
/* harmony export */   h: () => (/* binding */ focusElement),
/* harmony export */   i: () => (/* binding */ isPrimaryPointerButton),
/* harmony export */   j: () => (/* binding */ focusFirstTabbable),
/* harmony export */   k: () => (/* binding */ ensureId),
/* harmony export */   l: () => (/* binding */ tabbableOptions),
/* harmony export */   m: () => (/* binding */ slotChangeGetAssignedElements),
/* harmony export */   n: () => (/* binding */ nodeListToArray),
/* harmony export */   o: () => (/* binding */ intersects),
/* harmony export */   p: () => (/* binding */ focusElementInGroup),
/* harmony export */   q: () => (/* binding */ queryElementRoots),
/* harmony export */   r: () => (/* binding */ filterDirectChildren),
/* harmony export */   s: () => (/* binding */ slotChangeHasAssignedElement),
/* harmony export */   t: () => (/* binding */ toAriaBoolean),
/* harmony export */   u: () => (/* binding */ getRootNode)
/* harmony export */ });
/* harmony import */ var _index_esm_1c65d8c7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.esm-1c65d8c7.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/index.esm-1c65d8c7.js");
/* harmony import */ var _guid_88a3729f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./guid-88a3729f.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/guid-88a3729f.js");
/* harmony import */ var _resources_48436eea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources-48436eea.js */ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/resources-48436eea.js");




/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
const tabbableOptions = {
  getShadowRoot: true
};
/**
 * This helper will guarantee an ID on the provided element.
 *
 * If it already has an ID, it will be preserved, otherwise a unique one will be generated and assigned.
 *
 * @param el
 * @returns {string} The element's ID.
 */
function ensureId(el) {
  if (!el) {
    return "";
  }
  return (el.id = el.id || `${el.tagName.toLowerCase()}-${(0,_guid_88a3729f_js__WEBPACK_IMPORTED_MODULE_0__.g)()}`);
}
function nodeListToArray(nodeList) {
  return Array.isArray(nodeList) ? nodeList : Array.from(nodeList);
}
function getModeName(el) {
  const closestElWithMode = closestElementCrossShadowBoundary(el, `.${_resources_48436eea_js__WEBPACK_IMPORTED_MODULE_1__.C.darkMode}, .${_resources_48436eea_js__WEBPACK_IMPORTED_MODULE_1__.C.lightMode}`);
  return closestElWithMode?.classList.contains("calcite-mode-dark") ? "dark" : "light";
}
function getElementDir(el) {
  const prop = "dir";
  const selector = `[${prop}]`;
  const closest = closestElementCrossShadowBoundary(el, selector);
  return closest ? closest.getAttribute(prop) : "ltr";
}
function getElementProp(el, prop, fallbackValue) {
  const selector = `[${prop}]`;
  const closest = el.closest(selector);
  return closest ? closest.getAttribute(prop) : fallbackValue;
}
function getRootNode(el) {
  return el.getRootNode();
}
function getHost(root) {
  return root.host || null;
}
/**
 * This helper queries an element's rootNode and any ancestor rootNodes.
 *
 * If both an 'id' and 'selector' are supplied, 'id' will take precedence over 'selector'.
 *
 * @param element
 * @param root0
 * @param root0.selector
 * @param root0.id
 * @returns {Element} The element.
 */
function queryElementRoots(element, { selector, id }) {
  // Gets the rootNode and any ancestor rootNodes (shadowRoot or document) of an element and queries them for a selector.
  // Based on: https://stackoverflow.com/q/54520554/194216
  function queryFrom(el) {
    if (!el) {
      return null;
    }
    if (el.assignedSlot) {
      el = el.assignedSlot;
    }
    const rootNode = getRootNode(el);
    const found = id
      ? "getElementById" in rootNode
        ? /*
          Check to make sure 'getElementById' exists in cases where element is no longer connected to the DOM and getRootNode() returns the element.
          https://github.com/Esri/calcite-components/pull/4280
           */
          rootNode.getElementById(id)
        : null
      : selector
        ? rootNode.querySelector(selector)
        : null;
    const host = getHost(rootNode);
    return found ? found : host ? queryFrom(host) : null;
  }
  return queryFrom(element);
}
function closestElementCrossShadowBoundary(element, selector) {
  // based on https://stackoverflow.com/q/54520554/194216
  function closestFrom(el) {
    return el ? el.closest(selector) || closestFrom(getHost(getRootNode(el))) : null;
  }
  return closestFrom(element);
}
/**
 * This utility helps invoke a callback as it traverses a node and its ancestors until reaching the root document.
 *
 * Returning early or undefined in `onVisit` will continue traversing up the DOM tree. Otherwise, traversal will halt with the returned value as the result of the function
 *
 * @param element
 * @param onVisit
 */
function walkUpAncestry(element, onVisit) {
  return visit(element, onVisit);
}
function visit(node, onVisit) {
  if (!node) {
    return;
  }
  const result = onVisit(node);
  if (result !== undefined) {
    return result;
  }
  const { parentNode } = node;
  return visit(parentNode instanceof ShadowRoot ? parentNode.host : parentNode, onVisit);
}
function containsCrossShadowBoundary(element, maybeDescendant) {
  return !!walkUpAncestry(maybeDescendant, (node) => (node === element ? true : undefined));
}
function isCalciteFocusable(el) {
  return typeof el?.setFocus === "function";
}
async function focusElement(el) {
  if (!el) {
    return;
  }
  return isCalciteFocusable(el) ? el.setFocus() : el.focus();
}
/**
 * Helper to focus the first tabbable element.
 *
 * @param {HTMLElement} element The html element containing tabbable elements.
 */
function focusFirstTabbable(element) {
  ((0,_index_esm_1c65d8c7_js__WEBPACK_IMPORTED_MODULE_2__.t)(element, tabbableOptions)[0] || element).focus();
}
const defaultSlotSelector = ":not([slot])";
function getSlotted(element, slotName, options) {
  if (slotName && !Array.isArray(slotName) && typeof slotName !== "string") {
    options = slotName;
    slotName = null;
  }
  const slotSelector = slotName
    ? Array.isArray(slotName)
      ? slotName.map((name) => `[slot="${name}"]`).join(",")
      : `[slot="${slotName}"]`
    : defaultSlotSelector;
  if (options?.all) {
    return queryMultiple(element, slotSelector, options);
  }
  return querySingle(element, slotSelector, options);
}
function getDirectChildren(el, selector) {
  return el ? Array.from(el.children || []).filter((child) => child?.matches(selector)) : [];
}
function queryMultiple(element, slotSelector, options) {
  let matches = slotSelector === defaultSlotSelector
    ? getDirectChildren(element, defaultSlotSelector)
    : Array.from(element.querySelectorAll(slotSelector));
  matches = options && options.direct === false ? matches : matches.filter((el) => el.parentElement === element);
  matches = options?.matches ? matches.filter((el) => el?.matches(options.matches)) : matches;
  const selector = options?.selector;
  return selector
    ? matches
      .map((item) => Array.from(item.querySelectorAll(selector)))
      .reduce((previousValue, currentValue) => [...previousValue, ...currentValue], [])
      .filter((match) => !!match)
    : matches;
}
function querySingle(element, slotSelector, options) {
  let match = slotSelector === defaultSlotSelector
    ? getDirectChildren(element, defaultSlotSelector)[0] || null
    : element.querySelector(slotSelector);
  match = options && options.direct === false ? match : match?.parentElement === element ? match : null;
  match = options?.matches ? (match?.matches(options.matches) ? match : null) : match;
  const selector = options?.selector;
  return selector ? match?.querySelector(selector) : match;
}
function filterDirectChildren(el, selector) {
  return Array.from(el.children).filter((child) => child.matches(selector));
}
// set a default icon from a defined set or allow an override with an icon name string
function setRequestedIcon(iconObject, iconValue, matchedValue) {
  if (typeof iconValue === "string" && iconValue !== "") {
    return iconValue;
  }
  else if (iconValue === "") {
    return iconObject[matchedValue];
  }
}
function intersects(rect1, rect2) {
  return !(rect2.left > rect1.right ||
    rect2.right < rect1.left ||
    rect2.top > rect1.bottom ||
    rect2.bottom < rect1.top);
}
/**
 * This helper makes sure that boolean aria attributes are properly converted to a string.
 *
 * It should only be used for aria attributes that require a string value of "true" or "false".
 *
 * @param value
 * @returns {string} The string conversion of a boolean value ("true" | "false").
 */
function toAriaBoolean(value) {
  return Boolean(value).toString();
}
/**
 * This helper returns `true` if the target `slot` element from the `onSlotchange` event has an assigned element.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}
 * ```
 *
 * @param event
 * @returns {boolean} Whether the slot has any assigned elements.
 */
function slotChangeHasAssignedElement(event) {
  return !!slotChangeGetAssignedElements(event).length;
}
/**
 * This helper returns the assigned elements on a `slot` element from the `onSlotchange` event.
 *
 * ```
 * <slot onSlotchange={(event) => this.mySlotElements = slotChangeGetAssignedElements(event)} />}
 * ```
 *
 * @param event
 * @returns {boolean} Whether the slot has any assigned elements.
 */
function slotChangeGetAssignedElements(event) {
  return event.target.assignedElements({
    flatten: true
  });
}
/**
 * This helper returns true if the pointer event fired from the primary button of the device.
 *
 * See https://www.w3.org/TR/pointerevents/#the-button-property.
 *
 * @param event
 * @returns {boolean}
 */
function isPrimaryPointerButton(event) {
  return !!(event.isPrimary && event.button === 0);
}
const focusElementInGroup = (elements, currentElement, destination) => {
  const currentIndex = elements.indexOf(currentElement);
  const isFirstItem = currentIndex === 0;
  const isLastItem = currentIndex === elements.length - 1;
  destination =
    destination === "previous" && isFirstItem ? "last" : destination === "next" && isLastItem ? "first" : destination;
  let focusTarget;
  switch (destination) {
    case "first":
      focusTarget = elements[0];
      break;
    case "last":
      focusTarget = elements[elements.length - 1];
      break;
    case "next":
      focusTarget = elements[currentIndex + 1] || elements[0];
      break;
    case "previous":
      focusTarget = elements[currentIndex - 1] || elements[elements.length - 1];
      break;
  }
  focusElement(focusTarget);
  return focusTarget;
};



//# sourceMappingURL=dom-f1ee4d04.js.map

/***/ }),

/***/ "./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/guid-88a3729f.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/ba-infographic/node_modules/@arcgis/business-analyst-components/dist/stencil-components/dist/esm/guid-88a3729f.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ guid)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.5
 */
function gen(counts) {
  return counts
    .map((count) => {
    let out = "";
    for (let i = 0; i < count; i++) {
      out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    }
    return out;
  })
    .join("-");
}
const guid = () => gen([2, 1, 1, 1, 3]);



//# sourceMappingURL=guid-88a3729f.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYmEtaW5mb2dyYXBoaWNfbm9kZV9tb2R1bGVzX2FyY2dpc19idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHNfZGlzLTFjMjZkNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDVDtBQUNZOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUJBQXlCLEdBQUcsb0RBQUksR0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHFEQUFXLFVBQVUsS0FBSyxxREFBVyxXQUFXO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHLHlEQUFRO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUMsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdFQUF3RTtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1RUFBdUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzZ0I7O0FBRXRnQjs7Ozs7Ozs7Ozs7Ozs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFcUI7O0FBRXJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9iYS1pbmZvZ3JhcGhpYy9ub2RlX21vZHVsZXMvQGFyY2dpcy9idXNpbmVzcy1hbmFseXN0LWNvbXBvbmVudHMvZGlzdC9zdGVuY2lsLWNvbXBvbmVudHMvZGlzdC9lc20vZG9tLWYxZWU0ZDA0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYmEtaW5mb2dyYXBoaWMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYnVzaW5lc3MtYW5hbHlzdC1jb21wb25lbnRzL2Rpc3Qvc3RlbmNpbC1jb21wb25lbnRzL2Rpc3QvZXNtL2d1aWQtODhhMzcyOWYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdCBhcyB0YWJiYWJsZSB9IGZyb20gJy4vaW5kZXguZXNtLTFjNjVkOGM3LmpzJztcbmltcG9ydCB7IGcgYXMgZ3VpZCB9IGZyb20gJy4vZ3VpZC04OGEzNzI5Zi5qcyc7XG5pbXBvcnQgeyBDIGFzIENTU19VVElMSVRZIH0gZnJvbSAnLi9yZXNvdXJjZXMtNDg0MzZlZWEuanMnO1xuXG4vKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4wLjVcbiAqL1xuY29uc3QgdGFiYmFibGVPcHRpb25zID0ge1xuICBnZXRTaGFkb3dSb290OiB0cnVlXG59O1xuLyoqXG4gKiBUaGlzIGhlbHBlciB3aWxsIGd1YXJhbnRlZSBhbiBJRCBvbiB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAqXG4gKiBJZiBpdCBhbHJlYWR5IGhhcyBhbiBJRCwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQsIG90aGVyd2lzZSBhIHVuaXF1ZSBvbmUgd2lsbCBiZSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkLlxuICpcbiAqIEBwYXJhbSBlbFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVsZW1lbnQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlSWQoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHJldHVybiAoZWwuaWQgPSBlbC5pZCB8fCBgJHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9LSR7Z3VpZCgpfWApO1xufVxuZnVuY3Rpb24gbm9kZUxpc3RUb0FycmF5KG5vZGVMaXN0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG5vZGVMaXN0KSA/IG5vZGVMaXN0IDogQXJyYXkuZnJvbShub2RlTGlzdCk7XG59XG5mdW5jdGlvbiBnZXRNb2RlTmFtZShlbCkge1xuICBjb25zdCBjbG9zZXN0RWxXaXRoTW9kZSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbCwgYC4ke0NTU19VVElMSVRZLmRhcmtNb2RlfSwgLiR7Q1NTX1VUSUxJVFkubGlnaHRNb2RlfWApO1xuICByZXR1cm4gY2xvc2VzdEVsV2l0aE1vZGU/LmNsYXNzTGlzdC5jb250YWlucyhcImNhbGNpdGUtbW9kZS1kYXJrXCIpID8gXCJkYXJrXCIgOiBcImxpZ2h0XCI7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50RGlyKGVsKSB7XG4gIGNvbnN0IHByb3AgPSBcImRpclwiO1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtwcm9wfV1gO1xuICBjb25zdCBjbG9zZXN0ID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBzZWxlY3Rvcik7XG4gIHJldHVybiBjbG9zZXN0ID8gY2xvc2VzdC5nZXRBdHRyaWJ1dGUocHJvcCkgOiBcImx0clwiO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFByb3AoZWwsIHByb3AsIGZhbGxiYWNrVmFsdWUpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBgWyR7cHJvcH1dYDtcbiAgY29uc3QgY2xvc2VzdCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICByZXR1cm4gY2xvc2VzdCA/IGNsb3Nlc3QuZ2V0QXR0cmlidXRlKHByb3ApIDogZmFsbGJhY2tWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3ROb2RlKGVsKSB7XG4gIHJldHVybiBlbC5nZXRSb290Tm9kZSgpO1xufVxuZnVuY3Rpb24gZ2V0SG9zdChyb290KSB7XG4gIHJldHVybiByb290Lmhvc3QgfHwgbnVsbDtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgcXVlcmllcyBhbiBlbGVtZW50J3Mgcm9vdE5vZGUgYW5kIGFueSBhbmNlc3RvciByb290Tm9kZXMuXG4gKlxuICogSWYgYm90aCBhbiAnaWQnIGFuZCAnc2VsZWN0b3InIGFyZSBzdXBwbGllZCwgJ2lkJyB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyICdzZWxlY3RvcicuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwYXJhbSByb290MFxuICogQHBhcmFtIHJvb3QwLnNlbGVjdG9yXG4gKiBAcGFyYW0gcm9vdDAuaWRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcXVlcnlFbGVtZW50Um9vdHMoZWxlbWVudCwgeyBzZWxlY3RvciwgaWQgfSkge1xuICAvLyBHZXRzIHRoZSByb290Tm9kZSBhbmQgYW55IGFuY2VzdG9yIHJvb3ROb2RlcyAoc2hhZG93Um9vdCBvciBkb2N1bWVudCkgb2YgYW4gZWxlbWVudCBhbmQgcXVlcmllcyB0aGVtIGZvciBhIHNlbGVjdG9yLlxuICAvLyBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzU0NTIwNTU0LzE5NDIxNlxuICBmdW5jdGlvbiBxdWVyeUZyb20oZWwpIHtcbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGVsLmFzc2lnbmVkU2xvdCkge1xuICAgICAgZWwgPSBlbC5hc3NpZ25lZFNsb3Q7XG4gICAgfVxuICAgIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUoZWwpO1xuICAgIGNvbnN0IGZvdW5kID0gaWRcbiAgICAgID8gXCJnZXRFbGVtZW50QnlJZFwiIGluIHJvb3ROb2RlXG4gICAgICAgID8gLypcbiAgICAgICAgICBDaGVjayB0byBtYWtlIHN1cmUgJ2dldEVsZW1lbnRCeUlkJyBleGlzdHMgaW4gY2FzZXMgd2hlcmUgZWxlbWVudCBpcyBubyBsb25nZXIgY29ubmVjdGVkIHRvIHRoZSBET00gYW5kIGdldFJvb3ROb2RlKCkgcmV0dXJucyB0aGUgZWxlbWVudC5cbiAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvcHVsbC80MjgwXG4gICAgICAgICAgICovXG4gICAgICAgICAgcm9vdE5vZGUuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gICAgICAgIDogbnVsbFxuICAgICAgOiBzZWxlY3RvclxuICAgICAgICA/IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBob3N0ID0gZ2V0SG9zdChyb290Tm9kZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gZm91bmQgOiBob3N0ID8gcXVlcnlGcm9tKGhvc3QpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcXVlcnlGcm9tKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIC8vIGJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81NDUyMDU1NC8xOTQyMTZcbiAgZnVuY3Rpb24gY2xvc2VzdEZyb20oZWwpIHtcbiAgICByZXR1cm4gZWwgPyBlbC5jbG9zZXN0KHNlbGVjdG9yKSB8fCBjbG9zZXN0RnJvbShnZXRIb3N0KGdldFJvb3ROb2RlKGVsKSkpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gY2xvc2VzdEZyb20oZWxlbWVudCk7XG59XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBoZWxwcyBpbnZva2UgYSBjYWxsYmFjayBhcyBpdCB0cmF2ZXJzZXMgYSBub2RlIGFuZCBpdHMgYW5jZXN0b3JzIHVudGlsIHJlYWNoaW5nIHRoZSByb290IGRvY3VtZW50LlxuICpcbiAqIFJldHVybmluZyBlYXJseSBvciB1bmRlZmluZWQgaW4gYG9uVmlzaXRgIHdpbGwgY29udGludWUgdHJhdmVyc2luZyB1cCB0aGUgRE9NIHRyZWUuIE90aGVyd2lzZSwgdHJhdmVyc2FsIHdpbGwgaGFsdCB3aXRoIHRoZSByZXR1cm5lZCB2YWx1ZSBhcyB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcGFyYW0gb25WaXNpdFxuICovXG5mdW5jdGlvbiB3YWxrVXBBbmNlc3RyeShlbGVtZW50LCBvblZpc2l0KSB7XG4gIHJldHVybiB2aXNpdChlbGVtZW50LCBvblZpc2l0KTtcbn1cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIG9uVmlzaXQpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG9uVmlzaXQobm9kZSk7XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgeyBwYXJlbnROb2RlIH0gPSBub2RlO1xuICByZXR1cm4gdmlzaXQocGFyZW50Tm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBwYXJlbnROb2RlLmhvc3QgOiBwYXJlbnROb2RlLCBvblZpc2l0KTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zQ3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBtYXliZURlc2NlbmRhbnQpIHtcbiAgcmV0dXJuICEhd2Fsa1VwQW5jZXN0cnkobWF5YmVEZXNjZW5kYW50LCAobm9kZSkgPT4gKG5vZGUgPT09IGVsZW1lbnQgPyB0cnVlIDogdW5kZWZpbmVkKSk7XG59XG5mdW5jdGlvbiBpc0NhbGNpdGVGb2N1c2FibGUoZWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBlbD8uc2V0Rm9jdXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZvY3VzRWxlbWVudChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBpc0NhbGNpdGVGb2N1c2FibGUoZWwpID8gZWwuc2V0Rm9jdXMoKSA6IGVsLmZvY3VzKCk7XG59XG4vKipcbiAqIEhlbHBlciB0byBmb2N1cyB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBodG1sIGVsZW1lbnQgY29udGFpbmluZyB0YWJiYWJsZSBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gZm9jdXNGaXJzdFRhYmJhYmxlKGVsZW1lbnQpIHtcbiAgKHRhYmJhYmxlKGVsZW1lbnQsIHRhYmJhYmxlT3B0aW9ucylbMF0gfHwgZWxlbWVudCkuZm9jdXMoKTtcbn1cbmNvbnN0IGRlZmF1bHRTbG90U2VsZWN0b3IgPSBcIjpub3QoW3Nsb3RdKVwiO1xuZnVuY3Rpb24gZ2V0U2xvdHRlZChlbGVtZW50LCBzbG90TmFtZSwgb3B0aW9ucykge1xuICBpZiAoc2xvdE5hbWUgJiYgIUFycmF5LmlzQXJyYXkoc2xvdE5hbWUpICYmIHR5cGVvZiBzbG90TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIG9wdGlvbnMgPSBzbG90TmFtZTtcbiAgICBzbG90TmFtZSA9IG51bGw7XG4gIH1cbiAgY29uc3Qgc2xvdFNlbGVjdG9yID0gc2xvdE5hbWVcbiAgICA/IEFycmF5LmlzQXJyYXkoc2xvdE5hbWUpXG4gICAgICA/IHNsb3ROYW1lLm1hcCgobmFtZSkgPT4gYFtzbG90PVwiJHtuYW1lfVwiXWApLmpvaW4oXCIsXCIpXG4gICAgICA6IGBbc2xvdD1cIiR7c2xvdE5hbWV9XCJdYFxuICAgIDogZGVmYXVsdFNsb3RTZWxlY3RvcjtcbiAgaWYgKG9wdGlvbnM/LmFsbCkge1xuICAgIHJldHVybiBxdWVyeU11bHRpcGxlKGVsZW1lbnQsIHNsb3RTZWxlY3Rvciwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5U2luZ2xlKGVsZW1lbnQsIHNsb3RTZWxlY3Rvciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXREaXJlY3RDaGlsZHJlbihlbCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGVsID8gQXJyYXkuZnJvbShlbC5jaGlsZHJlbiB8fCBbXSkuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQ/Lm1hdGNoZXMoc2VsZWN0b3IpKSA6IFtdO1xufVxuZnVuY3Rpb24gcXVlcnlNdWx0aXBsZShlbGVtZW50LCBzbG90U2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgbGV0IG1hdGNoZXMgPSBzbG90U2VsZWN0b3IgPT09IGRlZmF1bHRTbG90U2VsZWN0b3JcbiAgICA/IGdldERpcmVjdENoaWxkcmVuKGVsZW1lbnQsIGRlZmF1bHRTbG90U2VsZWN0b3IpXG4gICAgOiBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzbG90U2VsZWN0b3IpKTtcbiAgbWF0Y2hlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXJlY3QgPT09IGZhbHNlID8gbWF0Y2hlcyA6IG1hdGNoZXMuZmlsdGVyKChlbCkgPT4gZWwucGFyZW50RWxlbWVudCA9PT0gZWxlbWVudCk7XG4gIG1hdGNoZXMgPSBvcHRpb25zPy5tYXRjaGVzID8gbWF0Y2hlcy5maWx0ZXIoKGVsKSA9PiBlbD8ubWF0Y2hlcyhvcHRpb25zLm1hdGNoZXMpKSA6IG1hdGNoZXM7XG4gIGNvbnN0IHNlbGVjdG9yID0gb3B0aW9ucz8uc2VsZWN0b3I7XG4gIHJldHVybiBzZWxlY3RvclxuICAgID8gbWF0Y2hlc1xuICAgICAgLm1hcCgoaXRlbSkgPT4gQXJyYXkuZnJvbShpdGVtLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSlcbiAgICAgIC5yZWR1Y2UoKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkgPT4gWy4uLnByZXZpb3VzVmFsdWUsIC4uLmN1cnJlbnRWYWx1ZV0sIFtdKVxuICAgICAgLmZpbHRlcigobWF0Y2gpID0+ICEhbWF0Y2gpXG4gICAgOiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gcXVlcnlTaW5nbGUoZWxlbWVudCwgc2xvdFNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIGxldCBtYXRjaCA9IHNsb3RTZWxlY3RvciA9PT0gZGVmYXVsdFNsb3RTZWxlY3RvclxuICAgID8gZ2V0RGlyZWN0Q2hpbGRyZW4oZWxlbWVudCwgZGVmYXVsdFNsb3RTZWxlY3RvcilbMF0gfHwgbnVsbFxuICAgIDogZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNsb3RTZWxlY3Rvcik7XG4gIG1hdGNoID0gb3B0aW9ucyAmJiBvcHRpb25zLmRpcmVjdCA9PT0gZmFsc2UgPyBtYXRjaCA6IG1hdGNoPy5wYXJlbnRFbGVtZW50ID09PSBlbGVtZW50ID8gbWF0Y2ggOiBudWxsO1xuICBtYXRjaCA9IG9wdGlvbnM/Lm1hdGNoZXMgPyAobWF0Y2g/Lm1hdGNoZXMob3B0aW9ucy5tYXRjaGVzKSA/IG1hdGNoIDogbnVsbCkgOiBtYXRjaDtcbiAgY29uc3Qgc2VsZWN0b3IgPSBvcHRpb25zPy5zZWxlY3RvcjtcbiAgcmV0dXJuIHNlbGVjdG9yID8gbWF0Y2g/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogbWF0Y2g7XG59XG5mdW5jdGlvbiBmaWx0ZXJEaXJlY3RDaGlsZHJlbihlbCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWwuY2hpbGRyZW4pLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcbn1cbi8vIHNldCBhIGRlZmF1bHQgaWNvbiBmcm9tIGEgZGVmaW5lZCBzZXQgb3IgYWxsb3cgYW4gb3ZlcnJpZGUgd2l0aCBhbiBpY29uIG5hbWUgc3RyaW5nXG5mdW5jdGlvbiBzZXRSZXF1ZXN0ZWRJY29uKGljb25PYmplY3QsIGljb25WYWx1ZSwgbWF0Y2hlZFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaWNvblZhbHVlID09PSBcInN0cmluZ1wiICYmIGljb25WYWx1ZSAhPT0gXCJcIikge1xuICAgIHJldHVybiBpY29uVmFsdWU7XG4gIH1cbiAgZWxzZSBpZiAoaWNvblZhbHVlID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGljb25PYmplY3RbbWF0Y2hlZFZhbHVlXTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJzZWN0cyhyZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuICEocmVjdDIubGVmdCA+IHJlY3QxLnJpZ2h0IHx8XG4gICAgcmVjdDIucmlnaHQgPCByZWN0MS5sZWZ0IHx8XG4gICAgcmVjdDIudG9wID4gcmVjdDEuYm90dG9tIHx8XG4gICAgcmVjdDIuYm90dG9tIDwgcmVjdDEudG9wKTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgbWFrZXMgc3VyZSB0aGF0IGJvb2xlYW4gYXJpYSBhdHRyaWJ1dGVzIGFyZSBwcm9wZXJseSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcuXG4gKlxuICogSXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgYXJpYSBhdHRyaWJ1dGVzIHRoYXQgcmVxdWlyZSBhIHN0cmluZyB2YWx1ZSBvZiBcInRydWVcIiBvciBcImZhbHNlXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIGNvbnZlcnNpb24gb2YgYSBib29sZWFuIHZhbHVlIChcInRydWVcIiB8IFwiZmFsc2VcIikuXG4gKi9cbmZ1bmN0aW9uIHRvQXJpYUJvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpLnRvU3RyaW5nKCk7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgYHRydWVgIGlmIHRoZSB0YXJnZXQgYHNsb3RgIGVsZW1lbnQgZnJvbSB0aGUgYG9uU2xvdGNoYW5nZWAgZXZlbnQgaGFzIGFuIGFzc2lnbmVkIGVsZW1lbnQuXG4gKlxuICogYGBgXG4gKiA8c2xvdCBvblNsb3RjaGFuZ2U9eyhldmVudCkgPT4gdGhpcy5teVNsb3RIYXNFbGVtZW50ID0gc2xvdENoYW5nZUhhc0Fzc2lnbmVkRWxlbWVudChldmVudCl9IC8+fVxuICogYGBgXG4gKlxuICogQHBhcmFtIGV2ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc2xvdCBoYXMgYW55IGFzc2lnbmVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBzbG90Q2hhbmdlSGFzQXNzaWduZWRFbGVtZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIXNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzKGV2ZW50KS5sZW5ndGg7XG59XG4vKipcbiAqIFRoaXMgaGVscGVyIHJldHVybnMgdGhlIGFzc2lnbmVkIGVsZW1lbnRzIG9uIGEgYHNsb3RgIGVsZW1lbnQgZnJvbSB0aGUgYG9uU2xvdGNoYW5nZWAgZXZlbnQuXG4gKlxuICogYGBgXG4gKiA8c2xvdCBvblNsb3RjaGFuZ2U9eyhldmVudCkgPT4gdGhpcy5teVNsb3RFbGVtZW50cyA9IHNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzKGV2ZW50KX0gLz59XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBzbG90IGhhcyBhbnkgYXNzaWduZWQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNsb3RDaGFuZ2VHZXRBc3NpZ25lZEVsZW1lbnRzKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50YXJnZXQuYXNzaWduZWRFbGVtZW50cyh7XG4gICAgZmxhdHRlbjogdHJ1ZVxuICB9KTtcbn1cbi8qKlxuICogVGhpcyBoZWxwZXIgcmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludGVyIGV2ZW50IGZpcmVkIGZyb20gdGhlIHByaW1hcnkgYnV0dG9uIG9mIHRoZSBkZXZpY2UuXG4gKlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN0aGUtYnV0dG9uLXByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBldmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWFyeVBvaW50ZXJCdXR0b24oZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50LmlzUHJpbWFyeSAmJiBldmVudC5idXR0b24gPT09IDApO1xufVxuY29uc3QgZm9jdXNFbGVtZW50SW5Hcm91cCA9IChlbGVtZW50cywgY3VycmVudEVsZW1lbnQsIGRlc3RpbmF0aW9uKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRJbmRleCA9IGVsZW1lbnRzLmluZGV4T2YoY3VycmVudEVsZW1lbnQpO1xuICBjb25zdCBpc0ZpcnN0SXRlbSA9IGN1cnJlbnRJbmRleCA9PT0gMDtcbiAgY29uc3QgaXNMYXN0SXRlbSA9IGN1cnJlbnRJbmRleCA9PT0gZWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgZGVzdGluYXRpb24gPVxuICAgIGRlc3RpbmF0aW9uID09PSBcInByZXZpb3VzXCIgJiYgaXNGaXJzdEl0ZW0gPyBcImxhc3RcIiA6IGRlc3RpbmF0aW9uID09PSBcIm5leHRcIiAmJiBpc0xhc3RJdGVtID8gXCJmaXJzdFwiIDogZGVzdGluYXRpb247XG4gIGxldCBmb2N1c1RhcmdldDtcbiAgc3dpdGNoIChkZXN0aW5hdGlvbikge1xuICAgIGNhc2UgXCJmaXJzdFwiOlxuICAgICAgZm9jdXNUYXJnZXQgPSBlbGVtZW50c1swXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsYXN0XCI6XG4gICAgICBmb2N1c1RhcmdldCA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5leHRcIjpcbiAgICAgIGZvY3VzVGFyZ2V0ID0gZWxlbWVudHNbY3VycmVudEluZGV4ICsgMV0gfHwgZWxlbWVudHNbMF07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicHJldmlvdXNcIjpcbiAgICAgIGZvY3VzVGFyZ2V0ID0gZWxlbWVudHNbY3VycmVudEluZGV4IC0gMV0gfHwgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICBicmVhaztcbiAgfVxuICBmb2N1c0VsZW1lbnQoZm9jdXNUYXJnZXQpO1xuICByZXR1cm4gZm9jdXNUYXJnZXQ7XG59O1xuXG5leHBvcnQgeyBjb250YWluc0Nyb3NzU2hhZG93Qm91bmRhcnkgYXMgYSwgZ2V0RWxlbWVudERpciBhcyBiLCBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgYXMgYywgc2V0UmVxdWVzdGVkSWNvbiBhcyBkLCBnZXRNb2RlTmFtZSBhcyBlLCBnZXRFbGVtZW50UHJvcCBhcyBmLCBnZXRTbG90dGVkIGFzIGcsIGZvY3VzRWxlbWVudCBhcyBoLCBpc1ByaW1hcnlQb2ludGVyQnV0dG9uIGFzIGksIGZvY3VzRmlyc3RUYWJiYWJsZSBhcyBqLCBlbnN1cmVJZCBhcyBrLCB0YWJiYWJsZU9wdGlvbnMgYXMgbCwgc2xvdENoYW5nZUdldEFzc2lnbmVkRWxlbWVudHMgYXMgbSwgbm9kZUxpc3RUb0FycmF5IGFzIG4sIGludGVyc2VjdHMgYXMgbywgZm9jdXNFbGVtZW50SW5Hcm91cCBhcyBwLCBxdWVyeUVsZW1lbnRSb290cyBhcyBxLCBmaWx0ZXJEaXJlY3RDaGlsZHJlbiBhcyByLCBzbG90Q2hhbmdlSGFzQXNzaWduZWRFbGVtZW50IGFzIHMsIHRvQXJpYUJvb2xlYW4gYXMgdCwgZ2V0Um9vdE5vZGUgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb20tZjFlZTRkMDQuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtY29tcG9uZW50cy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kIGZvciBkZXRhaWxzLlxuICogdjEuMC41XG4gKi9cbmZ1bmN0aW9uIGdlbihjb3VudHMpIHtcbiAgcmV0dXJuIGNvdW50c1xuICAgIC5tYXAoKGNvdW50KSA9PiB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBvdXQgKz0gKCgoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9KVxuICAgIC5qb2luKFwiLVwiKTtcbn1cbmNvbnN0IGd1aWQgPSAoKSA9PiBnZW4oWzIsIDEsIDEsIDEsIDNdKTtcblxuZXhwb3J0IHsgZ3VpZCBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWd1aWQtODhhMzcyOWYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9