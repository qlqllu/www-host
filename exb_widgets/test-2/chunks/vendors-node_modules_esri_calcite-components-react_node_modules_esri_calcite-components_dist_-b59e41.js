"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_esri_calcite-components-react_node_modules_esri_calcite-components_dist_-b59e41"],{

/***/ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/date-picker-month.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/date-picker-month.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DatePickerMonth),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client/index.js */ "./node_modules/@esri/calcite-components-react/node_modules/@stencil/core/internal/client/index.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./date.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/date.js");
/* harmony import */ var _date_picker_day_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./date-picker-day.js */ "./node_modules/@esri/calcite-components-react/node_modules/@esri/calcite-components/dist/components/date-picker-day.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v1.11.0
 */




const datePickerMonthCss = ":host([hidden]){display:none}[hidden]{display:none}.calendar{margin-block-end:0.25rem}.week-headers{display:flex;border-width:0px;border-block-start-width:1px;border-style:solid;border-color:var(--calcite-ui-border-3);padding-block:0px;padding-inline:0.25rem}.week-header{text-align:center;font-weight:var(--calcite-font-weight-bold);color:var(--calcite-ui-text-3);inline-size:14.2857142857%}.day{display:flex;min-inline-size:0px;justify-content:center;inline-size:14.2857142857%}.day calcite-date-picker-day{inline-size:100%}:host([scale=s]) .week-header{padding-inline:0px;padding-block:0.5rem 0.75rem;font-size:var(--calcite-font-size--2);line-height:1rem}:host([scale=m]) .week-header{padding-inline:0px;padding-block:0.75rem 1rem;font-size:var(--calcite-font-size--2);line-height:1rem}:host([scale=l]) .week-header{padding-inline:0px;padding-block:1rem 1.25rem;font-size:var(--calcite-font-size--1);line-height:1rem}.week-days{display:flex;flex-direction:row;padding-block:0px;padding-inline:6px}.week-days:focus{outline:2px solid transparent;outline-offset:2px}";

const DAYS_PER_WEEK = 7;
const DAYS_MAXIMUM_INDEX = 6;
const DatePickerMonth = /*@__PURE__*/ (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class extends _stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.calciteInternalDatePickerSelect = (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.createEvent)(this, "calciteInternalDatePickerSelect", 6);
    this.calciteInternalDatePickerHover = (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.createEvent)(this, "calciteInternalDatePickerHover", 6);
    this.calciteInternalDatePickerActiveDateChange = (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.createEvent)(this, "calciteInternalDatePickerActiveDateChange", 6);
    this.calciteInternalDatePickerMouseOut = (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.createEvent)(this, "calciteInternalDatePickerMouseOut", 6);
    //--------------------------------------------------------------------------
    //
    //  Event Listeners
    //
    //--------------------------------------------------------------------------
    this.keyDownHandler = (event) => {
      if (event.defaultPrevented) {
        return;
      }
      const isRTL = this.el.dir === "rtl";
      switch (event.key) {
        case "ArrowUp":
          event.preventDefault();
          this.addDays(-7);
          break;
        case "ArrowRight":
          event.preventDefault();
          this.addDays(isRTL ? -1 : 1);
          break;
        case "ArrowDown":
          event.preventDefault();
          this.addDays(7);
          break;
        case "ArrowLeft":
          event.preventDefault();
          this.addDays(isRTL ? 1 : -1);
          break;
        case "PageUp":
          event.preventDefault();
          this.addMonths(-1);
          break;
        case "PageDown":
          event.preventDefault();
          this.addMonths(1);
          break;
        case "Home":
          event.preventDefault();
          this.activeDate.setDate(1);
          this.addDays();
          break;
        case "End":
          event.preventDefault();
          this.activeDate.setDate(new Date(this.activeDate.getFullYear(), this.activeDate.getMonth() + 1, 0).getDate());
          this.addDays();
          break;
        case "Enter":
        case " ":
          event.preventDefault();
          break;
        case "Tab":
          this.activeFocus = false;
      }
    };
    /**
     * Once user is not interacting via keyboard,
     * disable auto focusing of active date
     */
    this.disableActiveFocus = () => {
      this.activeFocus = false;
    };
    this.dayHover = (event) => {
      const target = event.target;
      if (target.disabled) {
        this.calciteInternalDatePickerMouseOut.emit();
      }
      else {
        this.calciteInternalDatePickerHover.emit(target.value);
      }
      event.stopPropagation();
    };
    this.daySelect = (event) => {
      const target = event.target;
      this.calciteInternalDatePickerSelect.emit(target.value);
    };
    this.dateTimeFormat = undefined;
    this.selectedDate = undefined;
    this.activeDate = new Date();
    this.startDate = undefined;
    this.endDate = undefined;
    this.min = undefined;
    this.max = undefined;
    this.scale = undefined;
    this.localeData = undefined;
    this.hoverRange = undefined;
  }
  pointerOutHandler() {
    this.calciteInternalDatePickerMouseOut.emit();
  }
  //--------------------------------------------------------------------------
  //
  //  Lifecycle
  //
  //--------------------------------------------------------------------------
  render() {
    const month = this.activeDate.getMonth();
    const year = this.activeDate.getFullYear();
    const startOfWeek = this.localeData.weekStart % 7;
    const { abbreviated, short, narrow } = this.localeData.days;
    const weekDays = this.scale === "s" ? narrow || short || abbreviated : short || abbreviated || narrow;
    const adjustedWeekDays = [...weekDays.slice(startOfWeek, 7), ...weekDays.slice(0, startOfWeek)];
    const curMonDays = this.getCurrentMonthDays(month, year);
    const prevMonDays = this.getPreviousMonthDays(month, year, startOfWeek);
    const nextMonDays = this.getNextMonthDays(month, year, startOfWeek);
    let dayInWeek = 0;
    const getDayInWeek = () => dayInWeek++ % 7;
    const days = [
      ...prevMonDays.map((day) => {
        return {
          active: false,
          day,
          dayInWeek: getDayInWeek(),
          date: new Date(year, month - 1, day),
        };
      }),
      ...curMonDays.map((day) => {
        const date = new Date(year, month, day);
        const active = (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, this.activeDate);
        return {
          active,
          currentMonth: true,
          day,
          dayInWeek: getDayInWeek(),
          date,
          ref: true,
        };
      }),
      ...nextMonDays.map((day) => {
        return {
          active: false,
          day,
          dayInWeek: getDayInWeek(),
          date: new Date(year, month + 1, day),
        };
      }),
    ];
    const weeks = [];
    for (let i = 0; i < days.length; i += 7) {
      weeks.push(days.slice(i, i + 7));
    }
    return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.Host, { onFocusOut: this.disableActiveFocus, onKeyDown: this.keyDownHandler }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("div", { class: "calendar", role: "grid" }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("div", { class: "week-headers", role: "row" }, adjustedWeekDays.map((weekday) => ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("span", { class: "week-header", role: "columnheader" }, weekday)))), weeks.map((days) => ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("div", { class: "week-days", role: "row" }, days.map((day) => this.renderDateDay(day))))))));
  }
  //--------------------------------------------------------------------------
  //
  //  Private Methods
  //
  //--------------------------------------------------------------------------
  /**
   * Add n months to the current month
   *
   * @param step
   */
  addMonths(step) {
    const nextDate = new Date(this.activeDate);
    nextDate.setMonth(this.activeDate.getMonth() + step);
    this.calciteInternalDatePickerActiveDateChange.emit((0,_date_js__WEBPACK_IMPORTED_MODULE_0__.f)(nextDate, this.min, this.max));
    this.activeFocus = true;
  }
  /**
   * Add n days to the current date
   *
   * @param step
   */
  addDays(step = 0) {
    const nextDate = new Date(this.activeDate);
    nextDate.setDate(this.activeDate.getDate() + step);
    this.calciteInternalDatePickerActiveDateChange.emit((0,_date_js__WEBPACK_IMPORTED_MODULE_0__.f)(nextDate, this.min, this.max));
    this.activeFocus = true;
  }
  /**
   * Get dates for last days of the previous month
   *
   * @param month
   * @param year
   * @param startOfWeek
   */
  getPreviousMonthDays(month, year, startOfWeek) {
    const lastDate = new Date(year, month, 0);
    const date = lastDate.getDate();
    const startDay = lastDate.getDay();
    const days = [];
    if (startDay === (startOfWeek + DAYS_MAXIMUM_INDEX) % DAYS_PER_WEEK) {
      return days;
    }
    if (startDay === startOfWeek) {
      return [date];
    }
    for (let i = (DAYS_PER_WEEK + startDay - startOfWeek) % DAYS_PER_WEEK; i >= 0; i--) {
      days.push(date - i);
    }
    return days;
  }
  /**
   * Get dates for the current month
   *
   * @param month
   * @param year
   */
  getCurrentMonthDays(month, year) {
    const num = new Date(year, month + 1, 0).getDate();
    const days = [];
    for (let i = 0; i < num; i++) {
      days.push(i + 1);
    }
    return days;
  }
  /**
   * Get dates for first days of the next month
   *
   * @param month
   * @param year
   * @param startOfWeek
   */
  getNextMonthDays(month, year, startOfWeek) {
    const endDay = new Date(year, month + 1, 0).getDay();
    const days = [];
    if (endDay === (startOfWeek + DAYS_MAXIMUM_INDEX) % DAYS_PER_WEEK) {
      return days;
    }
    for (let i = 0; i < (DAYS_MAXIMUM_INDEX - (endDay - startOfWeek)) % DAYS_PER_WEEK; i++) {
      days.push(i + 1);
    }
    return days;
  }
  /**
   * Determine if the date is in between the start and end dates
   *
   * @param date
   */
  betweenSelectedRange(date) {
    return !!(this.startDate &&
      this.endDate &&
      date > this.startDate &&
      date < this.endDate &&
      !this.isRangeHover(date));
  }
  /**
   * Determine if the date should be in selected state
   *
   * @param date
   */
  isSelected(date) {
    return !!((0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, this.selectedDate) ||
      (this.startDate && (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, this.startDate)) ||
      (this.endDate && (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, this.endDate)));
  }
  /**
   * Determine if the date is the start of the date range
   *
   * @param date
   */
  isStartOfRange(date) {
    return !!(this.startDate &&
      !(0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.startDate, this.endDate) &&
      (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.startDate, date) &&
      !this.isEndOfRange(date));
  }
  isEndOfRange(date) {
    return !!((this.endDate && !(0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.startDate, this.endDate) && (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.endDate, date)) ||
      (!this.endDate &&
        this.hoverRange &&
        (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.startDate, this.hoverRange.end) &&
        (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, this.hoverRange.end)));
  }
  /**
   * Render calcite-date-picker-day
   *
   * @param active.active
   * @param active
   * @param day
   * @param dayInWeek
   * @param date
   * @param currentMonth
   * @param ref
   * @param active.currentMonth
   * @param active.date
   * @param active.day
   * @param active.dayInWeek
   * @param active.ref
   */
  renderDateDay({ active, currentMonth, date, day, dayInWeek, ref }) {
    const isFocusedOnStart = this.isFocusedOnStart();
    const isHoverInRange = this.isHoverInRange() ||
      (!this.endDate && this.hoverRange && (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.hoverRange?.end, this.startDate));
    return ((0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("div", { class: "day", key: date.toDateString(), role: "gridcell" }, (0,_stencil_core_internal_client_index_js__WEBPACK_IMPORTED_MODULE_2__.h)("calcite-date-picker-day", { active: active, class: {
        "hover--inside-range": this.startDate && isHoverInRange,
        "hover--outside-range": this.startDate && !isHoverInRange,
        "focused--start": isFocusedOnStart,
        "focused--end": !isFocusedOnStart,
      }, currentMonth: currentMonth, dateTimeFormat: this.dateTimeFormat, day: day, disabled: !(0,_date_js__WEBPACK_IMPORTED_MODULE_0__.i)(date, this.min, this.max), endOfRange: this.isEndOfRange(date), highlighted: this.betweenSelectedRange(date), onCalciteDaySelect: this.daySelect, onCalciteInternalDayHover: this.dayHover, range: !!this.startDate && !!this.endDate && !(0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(this.startDate, this.endDate), rangeEdge: dayInWeek === 0 ? "start" : dayInWeek === 6 ? "end" : undefined, rangeHover: this.isRangeHover(date), scale: this.scale, selected: this.isSelected(date), startOfRange: this.isStartOfRange(date), value: date,
      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)
      ref: (el) => {
        // when moving via keyboard, focus must be updated on active date
        if (ref && active && this.activeFocus) {
          el?.focus();
        }
      } })));
  }
  isFocusedOnStart() {
    return this.hoverRange?.focused === "start";
  }
  isHoverInRange() {
    if (!this.hoverRange) {
      return false;
    }
    const { start, end } = this.hoverRange;
    return !!((!this.isFocusedOnStart() && this.startDate && (!this.endDate || end < this.endDate)) ||
      (this.isFocusedOnStart() && this.startDate && start > this.startDate));
  }
  isRangeHover(date) {
    if (!this.hoverRange) {
      return false;
    }
    const { start, end } = this.hoverRange;
    const isStart = this.isFocusedOnStart();
    const insideRange = this.isHoverInRange();
    const cond1 = insideRange &&
      ((!isStart && date > this.startDate && (date < end || (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, end))) ||
        (isStart && date < this.endDate && (date > start || (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, start))));
    const cond2 = !insideRange &&
      ((!isStart && date >= this.endDate && (date < end || (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, end))) ||
        (isStart &&
          ((this.startDate && date < this.startDate) ||
            (this.endDate && (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, this.startDate))) &&
          ((start && date > start) || (0,_date_js__WEBPACK_IMPORTED_MODULE_0__.h)(date, start))));
    return cond1 || cond2;
  }
  get el() { return this; }
  static get style() { return datePickerMonthCss; }
}, [1, "calcite-date-picker-month", {
    "dateTimeFormat": [16],
    "selectedDate": [16],
    "activeDate": [16],
    "startDate": [16],
    "endDate": [16],
    "min": [16],
    "max": [16],
    "scale": [513],
    "localeData": [16],
    "hoverRange": [16]
  }, [[1, "pointerout", "pointerOutHandler"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["calcite-date-picker-month", "calcite-date-picker-day"];
  components.forEach(tagName => { switch (tagName) {
    case "calcite-date-picker-month":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, DatePickerMonth);
      }
      break;
    case "calcite-date-picker-day":
      if (!customElements.get(tagName)) {
        (0,_date_picker_day_js__WEBPACK_IMPORTED_MODULE_1__.d)();
      }
      break;
  } });
}
defineCustomElement();




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHMtcmVhY3Rfbm9kZV9tb2R1bGVzX2VzcmlfY2FsY2l0ZS1jb21wb25lbnRzX2Rpc3RfLWI1OWU0MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0c7QUFDbkM7QUFDVjs7QUFFbEUsNENBQTRDLGFBQWEsU0FBUyxhQUFhLFVBQVUseUJBQXlCLGNBQWMsYUFBYSxpQkFBaUIsNkJBQTZCLG1CQUFtQix3Q0FBd0Msa0JBQWtCLHVCQUF1QixhQUFhLGtCQUFrQiw0Q0FBNEMsK0JBQStCLDJCQUEyQixLQUFLLGFBQWEsb0JBQW9CLHVCQUF1QiwyQkFBMkIsNkJBQTZCLGlCQUFpQiw4QkFBOEIsbUJBQW1CLDZCQUE2QixzQ0FBc0MsaUJBQWlCLDhCQUE4QixtQkFBbUIsMkJBQTJCLHNDQUFzQyxpQkFBaUIsOEJBQThCLG1CQUFtQiwyQkFBMkIsc0NBQXNDLGlCQUFpQixXQUFXLGFBQWEsbUJBQW1CLGtCQUFrQixtQkFBbUIsaUJBQWlCLDhCQUE4QixtQkFBbUI7O0FBRXZrQztBQUNBO0FBQ0Esc0NBQXNDLDBGQUFrQixlQUFlLCtFQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1GQUFXO0FBQ3RELDBDQUEwQyxtRkFBVztBQUNyRCxxREFBcUQsbUZBQVc7QUFDaEUsNkNBQTZDLG1GQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkNBQVE7QUFDcEUsNERBQTRELDJDQUFRO0FBQ3BFO0FBQ0EsMkRBQTJELDJDQUFRO0FBQ25FO0FBQ0E7QUFDQSw2QkFBNkIsMkNBQVE7QUFDckMsc0NBQXNDLDJDQUFRO0FBQzlDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBcUI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUUwRCIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzLXJlYWN0L25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9jb21wb25lbnRzL2RhdGUtcGlja2VyLW1vbnRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9tYWluL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2MS4xMS4wXG4gKi9cbmltcG9ydCB7IHByb3h5Q3VzdG9tRWxlbWVudCwgSFRNTEVsZW1lbnQsIGNyZWF0ZUV2ZW50LCBoLCBIb3N0IH0gZnJvbSAnQHN0ZW5jaWwvY29yZS9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMnO1xuaW1wb3J0IHsgaCBhcyBzYW1lRGF0ZSwgZiBhcyBkYXRlRnJvbVJhbmdlLCBpIGFzIGluUmFuZ2UgfSBmcm9tICcuL2RhdGUuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWZpbmVDdXN0b21FbGVtZW50JDEgfSBmcm9tICcuL2RhdGUtcGlja2VyLWRheS5qcyc7XG5cbmNvbnN0IGRhdGVQaWNrZXJNb250aENzcyA9IFwiOmhvc3QoW2hpZGRlbl0pe2Rpc3BsYXk6bm9uZX1baGlkZGVuXXtkaXNwbGF5Om5vbmV9LmNhbGVuZGFye21hcmdpbi1ibG9jay1lbmQ6MC4yNXJlbX0ud2Vlay1oZWFkZXJze2Rpc3BsYXk6ZmxleDtib3JkZXItd2lkdGg6MHB4O2JvcmRlci1ibG9jay1zdGFydC13aWR0aDoxcHg7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1jb2xvcjp2YXIoLS1jYWxjaXRlLXVpLWJvcmRlci0zKTtwYWRkaW5nLWJsb2NrOjBweDtwYWRkaW5nLWlubGluZTowLjI1cmVtfS53ZWVrLWhlYWRlcnt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXdlaWdodDp2YXIoLS1jYWxjaXRlLWZvbnQtd2VpZ2h0LWJvbGQpO2NvbG9yOnZhcigtLWNhbGNpdGUtdWktdGV4dC0zKTtpbmxpbmUtc2l6ZToxNC4yODU3MTQyODU3JX0uZGF5e2Rpc3BsYXk6ZmxleDttaW4taW5saW5lLXNpemU6MHB4O2p1c3RpZnktY29udGVudDpjZW50ZXI7aW5saW5lLXNpemU6MTQuMjg1NzE0Mjg1NyV9LmRheSBjYWxjaXRlLWRhdGUtcGlja2VyLWRheXtpbmxpbmUtc2l6ZToxMDAlfTpob3N0KFtzY2FsZT1zXSkgLndlZWstaGVhZGVye3BhZGRpbmctaW5saW5lOjBweDtwYWRkaW5nLWJsb2NrOjAuNXJlbSAwLjc1cmVtO2ZvbnQtc2l6ZTp2YXIoLS1jYWxjaXRlLWZvbnQtc2l6ZS0tMik7bGluZS1oZWlnaHQ6MXJlbX06aG9zdChbc2NhbGU9bV0pIC53ZWVrLWhlYWRlcntwYWRkaW5nLWlubGluZTowcHg7cGFkZGluZy1ibG9jazowLjc1cmVtIDFyZW07Zm9udC1zaXplOnZhcigtLWNhbGNpdGUtZm9udC1zaXplLS0yKTtsaW5lLWhlaWdodDoxcmVtfTpob3N0KFtzY2FsZT1sXSkgLndlZWstaGVhZGVye3BhZGRpbmctaW5saW5lOjBweDtwYWRkaW5nLWJsb2NrOjFyZW0gMS4yNXJlbTtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTEpO2xpbmUtaGVpZ2h0OjFyZW19LndlZWstZGF5c3tkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O3BhZGRpbmctYmxvY2s6MHB4O3BhZGRpbmctaW5saW5lOjZweH0ud2Vlay1kYXlzOmZvY3Vze291dGxpbmU6MnB4IHNvbGlkIHRyYW5zcGFyZW50O291dGxpbmUtb2Zmc2V0OjJweH1cIjtcblxuY29uc3QgREFZU19QRVJfV0VFSyA9IDc7XG5jb25zdCBEQVlTX01BWElNVU1fSU5ERVggPSA2O1xuY29uc3QgRGF0ZVBpY2tlck1vbnRoID0gLypAX19QVVJFX18qLyBwcm94eUN1c3RvbUVsZW1lbnQoY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlZ2lzdGVySG9zdCgpO1xuICAgIHRoaXMuX19hdHRhY2hTaGFkb3coKTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbERhdGVQaWNrZXJTZWxlY3QgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVJbnRlcm5hbERhdGVQaWNrZXJTZWxlY3RcIiwgNik7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxEYXRlUGlja2VySG92ZXIgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNhbGNpdGVJbnRlcm5hbERhdGVQaWNrZXJIb3ZlclwiLCA2KTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbERhdGVQaWNrZXJBY3RpdmVEYXRlQ2hhbmdlID0gY3JlYXRlRXZlbnQodGhpcywgXCJjYWxjaXRlSW50ZXJuYWxEYXRlUGlja2VyQWN0aXZlRGF0ZUNoYW5nZVwiLCA2KTtcbiAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbERhdGVQaWNrZXJNb3VzZU91dCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2FsY2l0ZUludGVybmFsRGF0ZVBpY2tlck1vdXNlT3V0XCIsIDYpO1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBFdmVudCBMaXN0ZW5lcnNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLmtleURvd25IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc1JUTCA9IHRoaXMuZWwuZGlyID09PSBcInJ0bFwiO1xuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuYWRkRGF5cygtNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFkZERheXMoaXNSVEwgPyAtMSA6IDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFkZERheXMoNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuYWRkRGF5cyhpc1JUTCA/IDEgOiAtMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQYWdlVXBcIjpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuYWRkTW9udGhzKC0xKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBhZ2VEb3duXCI6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFkZE1vbnRocygxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXREYXRlKDEpO1xuICAgICAgICAgIHRoaXMuYWRkRGF5cygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmFjdGl2ZURhdGUuc2V0RGF0ZShuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSwgdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkgKyAxLCAwKS5nZXREYXRlKCkpO1xuICAgICAgICAgIHRoaXMuYWRkRGF5cygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVGFiXCI6XG4gICAgICAgICAgdGhpcy5hY3RpdmVGb2N1cyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogT25jZSB1c2VyIGlzIG5vdCBpbnRlcmFjdGluZyB2aWEga2V5Ym9hcmQsXG4gICAgICogZGlzYWJsZSBhdXRvIGZvY3VzaW5nIG9mIGFjdGl2ZSBkYXRlXG4gICAgICovXG4gICAgdGhpcy5kaXNhYmxlQWN0aXZlRm9jdXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZUZvY3VzID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLmRheUhvdmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY2FsY2l0ZUludGVybmFsRGF0ZVBpY2tlck1vdXNlT3V0LmVtaXQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbERhdGVQaWNrZXJIb3Zlci5lbWl0KHRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIHRoaXMuZGF5U2VsZWN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICB0aGlzLmNhbGNpdGVJbnRlcm5hbERhdGVQaWNrZXJTZWxlY3QuZW1pdCh0YXJnZXQudmFsdWUpO1xuICAgIH07XG4gICAgdGhpcy5kYXRlVGltZUZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuc3RhcnREYXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kRGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubG9jYWxlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvdmVyUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcG9pbnRlck91dEhhbmRsZXIoKSB7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxEYXRlUGlja2VyTW91c2VPdXQuZW1pdCgpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIExpZmVjeWNsZVxuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBtb250aCA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpO1xuICAgIGNvbnN0IHllYXIgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBzdGFydE9mV2VlayA9IHRoaXMubG9jYWxlRGF0YS53ZWVrU3RhcnQgJSA3O1xuICAgIGNvbnN0IHsgYWJicmV2aWF0ZWQsIHNob3J0LCBuYXJyb3cgfSA9IHRoaXMubG9jYWxlRGF0YS5kYXlzO1xuICAgIGNvbnN0IHdlZWtEYXlzID0gdGhpcy5zY2FsZSA9PT0gXCJzXCIgPyBuYXJyb3cgfHwgc2hvcnQgfHwgYWJicmV2aWF0ZWQgOiBzaG9ydCB8fCBhYmJyZXZpYXRlZCB8fCBuYXJyb3c7XG4gICAgY29uc3QgYWRqdXN0ZWRXZWVrRGF5cyA9IFsuLi53ZWVrRGF5cy5zbGljZShzdGFydE9mV2VlaywgNyksIC4uLndlZWtEYXlzLnNsaWNlKDAsIHN0YXJ0T2ZXZWVrKV07XG4gICAgY29uc3QgY3VyTW9uRGF5cyA9IHRoaXMuZ2V0Q3VycmVudE1vbnRoRGF5cyhtb250aCwgeWVhcik7XG4gICAgY29uc3QgcHJldk1vbkRheXMgPSB0aGlzLmdldFByZXZpb3VzTW9udGhEYXlzKG1vbnRoLCB5ZWFyLCBzdGFydE9mV2Vlayk7XG4gICAgY29uc3QgbmV4dE1vbkRheXMgPSB0aGlzLmdldE5leHRNb250aERheXMobW9udGgsIHllYXIsIHN0YXJ0T2ZXZWVrKTtcbiAgICBsZXQgZGF5SW5XZWVrID0gMDtcbiAgICBjb25zdCBnZXREYXlJbldlZWsgPSAoKSA9PiBkYXlJbldlZWsrKyAlIDc7XG4gICAgY29uc3QgZGF5cyA9IFtcbiAgICAgIC4uLnByZXZNb25EYXlzLm1hcCgoZGF5KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBkYXksXG4gICAgICAgICAgZGF5SW5XZWVrOiBnZXREYXlJbldlZWsoKSxcbiAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSksXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIC4uLmN1ck1vbkRheXMubWFwKChkYXkpID0+IHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSBzYW1lRGF0ZShkYXRlLCB0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICBjdXJyZW50TW9udGg6IHRydWUsXG4gICAgICAgICAgZGF5LFxuICAgICAgICAgIGRheUluV2VlazogZ2V0RGF5SW5XZWVrKCksXG4gICAgICAgICAgZGF0ZSxcbiAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIC4uLm5leHRNb25EYXlzLm1hcCgoZGF5KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBkYXksXG4gICAgICAgICAgZGF5SW5XZWVrOiBnZXREYXlJbldlZWsoKSxcbiAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIGRheSksXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICBdO1xuICAgIGNvbnN0IHdlZWtzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXlzLmxlbmd0aDsgaSArPSA3KSB7XG4gICAgICB3ZWVrcy5wdXNoKGRheXMuc2xpY2UoaSwgaSArIDcpKTtcbiAgICB9XG4gICAgcmV0dXJuIChoKEhvc3QsIHsgb25Gb2N1c091dDogdGhpcy5kaXNhYmxlQWN0aXZlRm9jdXMsIG9uS2V5RG93bjogdGhpcy5rZXlEb3duSGFuZGxlciB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiY2FsZW5kYXJcIiwgcm9sZTogXCJncmlkXCIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcIndlZWstaGVhZGVyc1wiLCByb2xlOiBcInJvd1wiIH0sIGFkanVzdGVkV2Vla0RheXMubWFwKCh3ZWVrZGF5KSA9PiAoaChcInNwYW5cIiwgeyBjbGFzczogXCJ3ZWVrLWhlYWRlclwiLCByb2xlOiBcImNvbHVtbmhlYWRlclwiIH0sIHdlZWtkYXkpKSkpLCB3ZWVrcy5tYXAoKGRheXMpID0+IChoKFwiZGl2XCIsIHsgY2xhc3M6IFwid2Vlay1kYXlzXCIsIHJvbGU6IFwicm93XCIgfSwgZGF5cy5tYXAoKGRheSkgPT4gdGhpcy5yZW5kZXJEYXRlRGF5KGRheSkpKSkpKSkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gIFByaXZhdGUgTWV0aG9kc1xuICAvL1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBBZGQgbiBtb250aHMgdG8gdGhlIGN1cnJlbnQgbW9udGhcbiAgICpcbiAgICogQHBhcmFtIHN0ZXBcbiAgICovXG4gIGFkZE1vbnRocyhzdGVwKSB7XG4gICAgY29uc3QgbmV4dERhdGUgPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpO1xuICAgIG5leHREYXRlLnNldE1vbnRoKHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxEYXRlUGlja2VyQWN0aXZlRGF0ZUNoYW5nZS5lbWl0KGRhdGVGcm9tUmFuZ2UobmV4dERhdGUsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuYWN0aXZlRm9jdXMgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgbiBkYXlzIHRvIHRoZSBjdXJyZW50IGRhdGVcbiAgICpcbiAgICogQHBhcmFtIHN0ZXBcbiAgICovXG4gIGFkZERheXMoc3RlcCA9IDApIHtcbiAgICBjb25zdCBuZXh0RGF0ZSA9IG5ldyBEYXRlKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgbmV4dERhdGUuc2V0RGF0ZSh0aGlzLmFjdGl2ZURhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG4gICAgdGhpcy5jYWxjaXRlSW50ZXJuYWxEYXRlUGlja2VyQWN0aXZlRGF0ZUNoYW5nZS5lbWl0KGRhdGVGcm9tUmFuZ2UobmV4dERhdGUsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuYWN0aXZlRm9jdXMgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZGF0ZXMgZm9yIGxhc3QgZGF5cyBvZiB0aGUgcHJldmlvdXMgbW9udGhcbiAgICpcbiAgICogQHBhcmFtIG1vbnRoXG4gICAqIEBwYXJhbSB5ZWFyXG4gICAqIEBwYXJhbSBzdGFydE9mV2Vla1xuICAgKi9cbiAgZ2V0UHJldmlvdXNNb250aERheXMobW9udGgsIHllYXIsIHN0YXJ0T2ZXZWVrKSB7XG4gICAgY29uc3QgbGFzdERhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMCk7XG4gICAgY29uc3QgZGF0ZSA9IGxhc3REYXRlLmdldERhdGUoKTtcbiAgICBjb25zdCBzdGFydERheSA9IGxhc3REYXRlLmdldERheSgpO1xuICAgIGNvbnN0IGRheXMgPSBbXTtcbiAgICBpZiAoc3RhcnREYXkgPT09IChzdGFydE9mV2VlayArIERBWVNfTUFYSU1VTV9JTkRFWCkgJSBEQVlTX1BFUl9XRUVLKSB7XG4gICAgICByZXR1cm4gZGF5cztcbiAgICB9XG4gICAgaWYgKHN0YXJ0RGF5ID09PSBzdGFydE9mV2Vlaykge1xuICAgICAgcmV0dXJuIFtkYXRlXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IChEQVlTX1BFUl9XRUVLICsgc3RhcnREYXkgLSBzdGFydE9mV2VlaykgJSBEQVlTX1BFUl9XRUVLOyBpID49IDA7IGktLSkge1xuICAgICAgZGF5cy5wdXNoKGRhdGUgLSBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRheXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBkYXRlcyBmb3IgdGhlIGN1cnJlbnQgbW9udGhcbiAgICpcbiAgICogQHBhcmFtIG1vbnRoXG4gICAqIEBwYXJhbSB5ZWFyXG4gICAqL1xuICBnZXRDdXJyZW50TW9udGhEYXlzKG1vbnRoLCB5ZWFyKSB7XG4gICAgY29uc3QgbnVtID0gbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAwKS5nZXREYXRlKCk7XG4gICAgY29uc3QgZGF5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgIGRheXMucHVzaChpICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXlzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZGF0ZXMgZm9yIGZpcnN0IGRheXMgb2YgdGhlIG5leHQgbW9udGhcbiAgICpcbiAgICogQHBhcmFtIG1vbnRoXG4gICAqIEBwYXJhbSB5ZWFyXG4gICAqIEBwYXJhbSBzdGFydE9mV2Vla1xuICAgKi9cbiAgZ2V0TmV4dE1vbnRoRGF5cyhtb250aCwgeWVhciwgc3RhcnRPZldlZWspIHtcbiAgICBjb25zdCBlbmREYXkgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIDApLmdldERheSgpO1xuICAgIGNvbnN0IGRheXMgPSBbXTtcbiAgICBpZiAoZW5kRGF5ID09PSAoc3RhcnRPZldlZWsgKyBEQVlTX01BWElNVU1fSU5ERVgpICUgREFZU19QRVJfV0VFSykge1xuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKERBWVNfTUFYSU1VTV9JTkRFWCAtIChlbmREYXkgLSBzdGFydE9mV2VlaykpICUgREFZU19QRVJfV0VFSzsgaSsrKSB7XG4gICAgICBkYXlzLnB1c2goaSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF5cztcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBkYXRlIGlzIGluIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGJldHdlZW5TZWxlY3RlZFJhbmdlKGRhdGUpIHtcbiAgICByZXR1cm4gISEodGhpcy5zdGFydERhdGUgJiZcbiAgICAgIHRoaXMuZW5kRGF0ZSAmJlxuICAgICAgZGF0ZSA+IHRoaXMuc3RhcnREYXRlICYmXG4gICAgICBkYXRlIDwgdGhpcy5lbmREYXRlICYmXG4gICAgICAhdGhpcy5pc1JhbmdlSG92ZXIoZGF0ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIGRhdGUgc2hvdWxkIGJlIGluIHNlbGVjdGVkIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqL1xuICBpc1NlbGVjdGVkKGRhdGUpIHtcbiAgICByZXR1cm4gISEoc2FtZURhdGUoZGF0ZSwgdGhpcy5zZWxlY3RlZERhdGUpIHx8XG4gICAgICAodGhpcy5zdGFydERhdGUgJiYgc2FtZURhdGUoZGF0ZSwgdGhpcy5zdGFydERhdGUpKSB8fFxuICAgICAgKHRoaXMuZW5kRGF0ZSAmJiBzYW1lRGF0ZShkYXRlLCB0aGlzLmVuZERhdGUpKSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgZGF0ZSBpcyB0aGUgc3RhcnQgb2YgdGhlIGRhdGUgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGlzU3RhcnRPZlJhbmdlKGRhdGUpIHtcbiAgICByZXR1cm4gISEodGhpcy5zdGFydERhdGUgJiZcbiAgICAgICFzYW1lRGF0ZSh0aGlzLnN0YXJ0RGF0ZSwgdGhpcy5lbmREYXRlKSAmJlxuICAgICAgc2FtZURhdGUodGhpcy5zdGFydERhdGUsIGRhdGUpICYmXG4gICAgICAhdGhpcy5pc0VuZE9mUmFuZ2UoZGF0ZSkpO1xuICB9XG4gIGlzRW5kT2ZSYW5nZShkYXRlKSB7XG4gICAgcmV0dXJuICEhKCh0aGlzLmVuZERhdGUgJiYgIXNhbWVEYXRlKHRoaXMuc3RhcnREYXRlLCB0aGlzLmVuZERhdGUpICYmIHNhbWVEYXRlKHRoaXMuZW5kRGF0ZSwgZGF0ZSkpIHx8XG4gICAgICAoIXRoaXMuZW5kRGF0ZSAmJlxuICAgICAgICB0aGlzLmhvdmVyUmFuZ2UgJiZcbiAgICAgICAgc2FtZURhdGUodGhpcy5zdGFydERhdGUsIHRoaXMuaG92ZXJSYW5nZS5lbmQpICYmXG4gICAgICAgIHNhbWVEYXRlKGRhdGUsIHRoaXMuaG92ZXJSYW5nZS5lbmQpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBjYWxjaXRlLWRhdGUtcGlja2VyLWRheVxuICAgKlxuICAgKiBAcGFyYW0gYWN0aXZlLmFjdGl2ZVxuICAgKiBAcGFyYW0gYWN0aXZlXG4gICAqIEBwYXJhbSBkYXlcbiAgICogQHBhcmFtIGRheUluV2Vla1xuICAgKiBAcGFyYW0gZGF0ZVxuICAgKiBAcGFyYW0gY3VycmVudE1vbnRoXG4gICAqIEBwYXJhbSByZWZcbiAgICogQHBhcmFtIGFjdGl2ZS5jdXJyZW50TW9udGhcbiAgICogQHBhcmFtIGFjdGl2ZS5kYXRlXG4gICAqIEBwYXJhbSBhY3RpdmUuZGF5XG4gICAqIEBwYXJhbSBhY3RpdmUuZGF5SW5XZWVrXG4gICAqIEBwYXJhbSBhY3RpdmUucmVmXG4gICAqL1xuICByZW5kZXJEYXRlRGF5KHsgYWN0aXZlLCBjdXJyZW50TW9udGgsIGRhdGUsIGRheSwgZGF5SW5XZWVrLCByZWYgfSkge1xuICAgIGNvbnN0IGlzRm9jdXNlZE9uU3RhcnQgPSB0aGlzLmlzRm9jdXNlZE9uU3RhcnQoKTtcbiAgICBjb25zdCBpc0hvdmVySW5SYW5nZSA9IHRoaXMuaXNIb3ZlckluUmFuZ2UoKSB8fFxuICAgICAgKCF0aGlzLmVuZERhdGUgJiYgdGhpcy5ob3ZlclJhbmdlICYmIHNhbWVEYXRlKHRoaXMuaG92ZXJSYW5nZT8uZW5kLCB0aGlzLnN0YXJ0RGF0ZSkpO1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBcImRheVwiLCBrZXk6IGRhdGUudG9EYXRlU3RyaW5nKCksIHJvbGU6IFwiZ3JpZGNlbGxcIiB9LCBoKFwiY2FsY2l0ZS1kYXRlLXBpY2tlci1kYXlcIiwgeyBhY3RpdmU6IGFjdGl2ZSwgY2xhc3M6IHtcbiAgICAgICAgXCJob3Zlci0taW5zaWRlLXJhbmdlXCI6IHRoaXMuc3RhcnREYXRlICYmIGlzSG92ZXJJblJhbmdlLFxuICAgICAgICBcImhvdmVyLS1vdXRzaWRlLXJhbmdlXCI6IHRoaXMuc3RhcnREYXRlICYmICFpc0hvdmVySW5SYW5nZSxcbiAgICAgICAgXCJmb2N1c2VkLS1zdGFydFwiOiBpc0ZvY3VzZWRPblN0YXJ0LFxuICAgICAgICBcImZvY3VzZWQtLWVuZFwiOiAhaXNGb2N1c2VkT25TdGFydCxcbiAgICAgIH0sIGN1cnJlbnRNb250aDogY3VycmVudE1vbnRoLCBkYXRlVGltZUZvcm1hdDogdGhpcy5kYXRlVGltZUZvcm1hdCwgZGF5OiBkYXksIGRpc2FibGVkOiAhaW5SYW5nZShkYXRlLCB0aGlzLm1pbiwgdGhpcy5tYXgpLCBlbmRPZlJhbmdlOiB0aGlzLmlzRW5kT2ZSYW5nZShkYXRlKSwgaGlnaGxpZ2h0ZWQ6IHRoaXMuYmV0d2VlblNlbGVjdGVkUmFuZ2UoZGF0ZSksIG9uQ2FsY2l0ZURheVNlbGVjdDogdGhpcy5kYXlTZWxlY3QsIG9uQ2FsY2l0ZUludGVybmFsRGF5SG92ZXI6IHRoaXMuZGF5SG92ZXIsIHJhbmdlOiAhIXRoaXMuc3RhcnREYXRlICYmICEhdGhpcy5lbmREYXRlICYmICFzYW1lRGF0ZSh0aGlzLnN0YXJ0RGF0ZSwgdGhpcy5lbmREYXRlKSwgcmFuZ2VFZGdlOiBkYXlJbldlZWsgPT09IDAgPyBcInN0YXJ0XCIgOiBkYXlJbldlZWsgPT09IDYgPyBcImVuZFwiIDogdW5kZWZpbmVkLCByYW5nZUhvdmVyOiB0aGlzLmlzUmFuZ2VIb3ZlcihkYXRlKSwgc2NhbGU6IHRoaXMuc2NhbGUsIHNlbGVjdGVkOiB0aGlzLmlzU2VsZWN0ZWQoZGF0ZSksIHN0YXJ0T2ZSYW5nZTogdGhpcy5pc1N0YXJ0T2ZSYW5nZShkYXRlKSwgdmFsdWU6IGRhdGUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LXNvcnQtcHJvcHMgLS0gcmVmIHNob3VsZCBiZSBsYXN0IHNvIG5vZGUgYXR0cnMvcHJvcHMgYXJlIGluIHN5bmMgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vcHVsbC82NTMwKVxuICAgICAgcmVmOiAoZWwpID0+IHtcbiAgICAgICAgLy8gd2hlbiBtb3ZpbmcgdmlhIGtleWJvYXJkLCBmb2N1cyBtdXN0IGJlIHVwZGF0ZWQgb24gYWN0aXZlIGRhdGVcbiAgICAgICAgaWYgKHJlZiAmJiBhY3RpdmUgJiYgdGhpcy5hY3RpdmVGb2N1cykge1xuICAgICAgICAgIGVsPy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IH0pKSk7XG4gIH1cbiAgaXNGb2N1c2VkT25TdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3ZlclJhbmdlPy5mb2N1c2VkID09PSBcInN0YXJ0XCI7XG4gIH1cbiAgaXNIb3ZlckluUmFuZ2UoKSB7XG4gICAgaWYgKCF0aGlzLmhvdmVyUmFuZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSB0aGlzLmhvdmVyUmFuZ2U7XG4gICAgcmV0dXJuICEhKCghdGhpcy5pc0ZvY3VzZWRPblN0YXJ0KCkgJiYgdGhpcy5zdGFydERhdGUgJiYgKCF0aGlzLmVuZERhdGUgfHwgZW5kIDwgdGhpcy5lbmREYXRlKSkgfHxcbiAgICAgICh0aGlzLmlzRm9jdXNlZE9uU3RhcnQoKSAmJiB0aGlzLnN0YXJ0RGF0ZSAmJiBzdGFydCA+IHRoaXMuc3RhcnREYXRlKSk7XG4gIH1cbiAgaXNSYW5nZUhvdmVyKGRhdGUpIHtcbiAgICBpZiAoIXRoaXMuaG92ZXJSYW5nZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuaG92ZXJSYW5nZTtcbiAgICBjb25zdCBpc1N0YXJ0ID0gdGhpcy5pc0ZvY3VzZWRPblN0YXJ0KCk7XG4gICAgY29uc3QgaW5zaWRlUmFuZ2UgPSB0aGlzLmlzSG92ZXJJblJhbmdlKCk7XG4gICAgY29uc3QgY29uZDEgPSBpbnNpZGVSYW5nZSAmJlxuICAgICAgKCghaXNTdGFydCAmJiBkYXRlID4gdGhpcy5zdGFydERhdGUgJiYgKGRhdGUgPCBlbmQgfHwgc2FtZURhdGUoZGF0ZSwgZW5kKSkpIHx8XG4gICAgICAgIChpc1N0YXJ0ICYmIGRhdGUgPCB0aGlzLmVuZERhdGUgJiYgKGRhdGUgPiBzdGFydCB8fCBzYW1lRGF0ZShkYXRlLCBzdGFydCkpKSk7XG4gICAgY29uc3QgY29uZDIgPSAhaW5zaWRlUmFuZ2UgJiZcbiAgICAgICgoIWlzU3RhcnQgJiYgZGF0ZSA+PSB0aGlzLmVuZERhdGUgJiYgKGRhdGUgPCBlbmQgfHwgc2FtZURhdGUoZGF0ZSwgZW5kKSkpIHx8XG4gICAgICAgIChpc1N0YXJ0ICYmXG4gICAgICAgICAgKCh0aGlzLnN0YXJ0RGF0ZSAmJiBkYXRlIDwgdGhpcy5zdGFydERhdGUpIHx8XG4gICAgICAgICAgICAodGhpcy5lbmREYXRlICYmIHNhbWVEYXRlKGRhdGUsIHRoaXMuc3RhcnREYXRlKSkpICYmXG4gICAgICAgICAgKChzdGFydCAmJiBkYXRlID4gc3RhcnQpIHx8IHNhbWVEYXRlKGRhdGUsIHN0YXJ0KSkpKTtcbiAgICByZXR1cm4gY29uZDEgfHwgY29uZDI7XG4gIH1cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpczsgfVxuICBzdGF0aWMgZ2V0IHN0eWxlKCkgeyByZXR1cm4gZGF0ZVBpY2tlck1vbnRoQ3NzOyB9XG59LCBbMSwgXCJjYWxjaXRlLWRhdGUtcGlja2VyLW1vbnRoXCIsIHtcbiAgICBcImRhdGVUaW1lRm9ybWF0XCI6IFsxNl0sXG4gICAgXCJzZWxlY3RlZERhdGVcIjogWzE2XSxcbiAgICBcImFjdGl2ZURhdGVcIjogWzE2XSxcbiAgICBcInN0YXJ0RGF0ZVwiOiBbMTZdLFxuICAgIFwiZW5kRGF0ZVwiOiBbMTZdLFxuICAgIFwibWluXCI6IFsxNl0sXG4gICAgXCJtYXhcIjogWzE2XSxcbiAgICBcInNjYWxlXCI6IFs1MTNdLFxuICAgIFwibG9jYWxlRGF0YVwiOiBbMTZdLFxuICAgIFwiaG92ZXJSYW5nZVwiOiBbMTZdXG4gIH0sIFtbMSwgXCJwb2ludGVyb3V0XCIsIFwicG9pbnRlck91dEhhbmRsZXJcIl1dXSk7XG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KCkge1xuICBpZiAodHlwZW9mIGN1c3RvbUVsZW1lbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBbXCJjYWxjaXRlLWRhdGUtcGlja2VyLW1vbnRoXCIsIFwiY2FsY2l0ZS1kYXRlLXBpY2tlci1kYXlcIl07XG4gIGNvbXBvbmVudHMuZm9yRWFjaCh0YWdOYW1lID0+IHsgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgY2FzZSBcImNhbGNpdGUtZGF0ZS1waWNrZXItbW9udGhcIjpcbiAgICAgIGlmICghY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBEYXRlUGlja2VyTW9udGgpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNhbGNpdGUtZGF0ZS1waWNrZXItZGF5XCI6XG4gICAgICBpZiAoIWN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSkge1xuICAgICAgICBkZWZpbmVDdXN0b21FbGVtZW50JDEoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9IH0pO1xufVxuZGVmaW5lQ3VzdG9tRWxlbWVudCgpO1xuXG5leHBvcnQgeyBEYXRlUGlja2VyTW9udGggYXMgRCwgZGVmaW5lQ3VzdG9tRWxlbWVudCBhcyBkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=