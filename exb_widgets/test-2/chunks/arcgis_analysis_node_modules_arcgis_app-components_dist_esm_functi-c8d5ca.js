"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_functi-c8d5ca"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-c82f5ab9.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
  let timeout;
  let status = "idle";
  function flush(...args) {
    status = "flushed";
    return debounced(...args);
  }
  function invoke(...args) {
    status = "invoked";
    return debounced(...args);
  }
  function cancel(...args) {
    status = "cancelled";
    return debounced(...args);
  }
  function getStatus() {
    return status;
  }
  const debounced = (...args) => new Promise((resolve) => {
    switch (status) {
      case "flushed":
        status = "idle";
        if (timeout) {
          clearTimeout(timeout);
          resolve(fn(...args));
        }
        else {
          resolve(null);
        }
        break;
      case "invoked":
        clearTimeout(timeout);
        status = "idle";
        resolve(fn(...args));
        break;
      case "cancelled":
        clearTimeout(timeout);
        status = "idle";
        resolve(null);
        break;
      default:
        if (timeout) {
          clearTimeout(timeout);
        }
        status = "pending";
        timeout = setTimeout(() => {
          status = "idle";
          return resolve(fn(...args));
        }, delay);
        break;
    }
  });
  debounced.flush = flush;
  debounced.invoke = invoke;
  debounced.cancel = cancel;
  debounced.getStatus = getStatus;
  return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
  let timeout;
  return (...args) => new Promise((resolve) => {
    if (timeout) {
      return;
    }
    timeout = setTimeout(() => {
      clearTimeout(timeout);
      timeout = undefined;
      resolve(fn(...args));
    }, delay);
  });
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
  await Promise.all([promise, timeout(minDelay)]);
  return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
  const { key, data } = getKeyAndItem(item);
  return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
  const resultArr = [];
  const lookupMap = {};
  myArr.forEach((item) => {
    const id = getItemId(item);
    if (lookupMap[id] == null) {
      lookupMap[id] = item;
      resultArr.push(item);
    }
  });
  return resultArr;
}
function unique(myArr) {
  const primitives = { boolean: {}, number: {}, string: {} };
  const objs = [];
  return myArr.filter((item) => {
    let type = typeof item;
    if (type in primitives) {
      return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
    }
    else {
      return objs.indexOf(item) >= 0 ? false : objs.push(item);
    }
  });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-81d548b7.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-92ebb396.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-92ebb396.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_92ebb396_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};




/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-ccd5f37d.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ adminCanShareOthersItemToGroup),
/* harmony export */   B: () => (/* binding */ canShareOthersItemsToOrg),
/* harmony export */   C: () => (/* binding */ canShareItemToPublic),
/* harmony export */   D: () => (/* binding */ canShareOthersItemsToPublic),
/* harmony export */   E: () => (/* binding */ hasAdminSharePrivilege),
/* harmony export */   F: () => (/* binding */ itemsBelongToUserOrg),
/* harmony export */   G: () => (/* binding */ canViewOthersOrgItems),
/* harmony export */   a: () => (/* binding */ isSubscriber),
/* harmony export */   b: () => (/* binding */ isPremium),
/* harmony export */   c: () => (/* binding */ isDeveloper),
/* harmony export */   d: () => (/* binding */ addTrailingSlashIfMissing),
/* harmony export */   e: () => (/* binding */ isOrgAdmin),
/* harmony export */   f: () => (/* binding */ canManageSecurity),
/* harmony export */   g: () => (/* binding */ canManageServers),
/* harmony export */   h: () => (/* binding */ canUpdateOrgItems),
/* harmony export */   i: () => (/* binding */ isOwner),
/* harmony export */   j: () => (/* binding */ canDeleteOrgItems),
/* harmony export */   k: () => (/* binding */ isOrgPublisher),
/* harmony export */   l: () => (/* binding */ getRestUrlFromUrl),
/* harmony export */   m: () => (/* binding */ getItemHomeAppUrl),
/* harmony export */   n: () => (/* binding */ isPublicUser),
/* harmony export */   o: () => (/* binding */ isHostedPortal),
/* harmony export */   p: () => (/* binding */ parseAGSServerInfo),
/* harmony export */   q: () => (/* binding */ geoJsonRegExp),
/* harmony export */   r: () => (/* binding */ agsRegExp),
/* harmony export */   s: () => (/* binding */ specialCharactersRegExp),
/* harmony export */   t: () => (/* binding */ isCustomRole),
/* harmony export */   u: () => (/* binding */ regexServerType),
/* harmony export */   v: () => (/* binding */ validArcgisRestServicePath),
/* harmony export */   w: () => (/* binding */ canManageCollaborations),
/* harmony export */   x: () => (/* binding */ isOrgUser),
/* harmony export */   y: () => (/* binding */ canShareItemToGroup),
/* harmony export */   z: () => (/* binding */ canShareItemToOrg)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v3.0.99
 */
const specialCharactersRegExp = /\+|\?|\/|\(|\)|\\|\!|\#|\"|\||\*|\:|<|>|\%|\$|\@|\'|\^|\[|\]|\,|\=|\;/gi;
const geoJsonRegExp = /(\.|outputFormat=)json|geojson$/i;
const agsRegExp = /\/ags\//gi;

const serverTypes = "MapServer|GeocodeServer|GPServer|GeometryServer|ImageServer|NAServer|FeatureServer|GeoDataServer|GlobeServer|MobileServer|WMServer|SceneServer|VectorTileServer|StreamServer|WorkspaceServer|GeoenrichmentServer|VideoServer";
const regexServerType = new RegExp(`http.+\/(${serverTypes})`);
const validArcgisRestServicePath = `\/arcgis\/rest\/services|\/rest\/services|\/arcgis\/services|\/arcgis\/rest`;
const serverInfoExp = `(?<server>http.+(?:${validArcgisRestServicePath})(?:\/?.*\/(?<name>.*)\/(?<type>${serverTypes})))(?!.*\/${serverTypes})\/?(?<soe>\\d+)?.*`;
/** Returns an array containing the input url, base server url, server name, server type, and layer index (if entered).
 * Example: [
 * "https://sampleserver6.arcgisonline.com/arcgis/rest/services/FeatureServer/500",
 * "https://sampleserver6.arcgisonline.com/arcgis/rest/services/TestService/FeatureServer",
 * "TestService",
 * "FeatureServer",
 * "500"
 * ]  */
const regexServerInfo = new RegExp(serverInfoExp, "i");

const parseAGSServerInfo = (url) => {
  const extractedInfo = url.match(regexServerInfo);
  if (!extractedInfo) {
    const containsAGS = url.match(agsRegExp);
    // Type is always MapServer for /ags/ services
    return containsAGS ? { baseServerUrl: url, serverName: null, serverType: "MapServer", index: null } : null;
  }
  const [, baseServerUrl, serverName, serverType, indexStr] = extractedInfo;
  const index = parseInt(indexStr);
  return { baseServerUrl, serverName, serverType, index: isNaN(index) ? null : index };
};
const getRestUrlFromUrl = (url) => {
  if (!url) {
    return null;
  }
  const extractedInfo = url.match(validArcgisRestServicePath);
  if (!extractedInfo) {
    return null;
  }
  const urlParts = url.split("/rest");
  return urlParts.length < 2 ? null : `${urlParts[0]}/rest/`;
};
const addTrailingSlashIfMissing = (url) => url && url.charAt(url.length - 1) !== "/" ? `${url}/` : url;

function isEsri(item) {
  var _a;
  return !!((_a = item.owner) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes("esri"));
}
function isPremium(item) {
  var _a;
  return isEsri(item) && !!((_a = item.typeKeywords) === null || _a === void 0 ? void 0 : _a.includes("Requires Credits"));
}
function isSubscriber(item) {
  var _a;
  return isEsri(item) && !!((_a = item.typeKeywords) === null || _a === void 0 ? void 0 : _a.includes("Requires Subscription"));
}
function isOwner(item, user) {
  return item.owner === user.username;
}
/**
 * Can the user update the item
 */
function canUpdateItem(item, user) {
  return userIsItemAdmin(item, user) || item.itemControl === "update";
}
/**
 * Is the user either an owner or admin of the item
 */
function userIsItemAdmin(item, user) {
  return isOwner(item, user) || isItemAdmin(item, user);
}
/**
 * Does the user have admin capabilities on this item
 */
function isItemAdmin(item, user) {
  var _a;
  // if this flag is already set (probably home app), use it
  if (item.isAdmin != null) {
    return !!item.isAdmin;
  }
  const itemOwner = item.owner;
  const itemControlAdmin = item.itemControl === "admin";
  const esriUsers = ["esri_livingatlas", "esri_demographics", "esri_boundaries"];
  if (((_a = item.portal) === null || _a === void 0 ? void 0 : _a.isPortal) &&
    !isOwner(item, user) &&
    itemControlAdmin &&
    itemOwner.includes("esri_") &&
    // portal incorrectly returns "itemControl="admin" for esri owned items
    !esriUsers.includes(itemOwner)) {
    return false;
  }
  return itemControlAdmin;
}
const itemsBelongToUserOrg = (items, user) => {
  return !!user.orgId && items.every((item) => item.isOrgItem);
};
const getItemHomeAppUrl = (itemId, baseUrl) => `${addTrailingSlashIfMissing(baseUrl)}item.html?id=${itemId}`;

const getUserRole = (user) => { var _a; return typeof (user === null || user === void 0 ? void 0 : user.role) === "string" && !!(user === null || user === void 0 ? void 0 : user.role) ? user === null || user === void 0 ? void 0 : user.role : (_a = user === null || user === void 0 ? void 0 : user.roleId) !== null && _a !== void 0 ? _a : user === null || user === void 0 ? void 0 : user.id; };
function isPublicUser(user) {
  return user && !user.orgId;
}
function isHostedPortal(portal) {
  return !portal.isPortal || !!portal.isBackedBySDS;
}
const canManageSecurity = (user) => { var _a; return (_a = user.privileges) === null || _a === void 0 ? void 0 : _a.includes("portal:admin:manageSecurity"); };
const canManageServers = (user) => { var _a; return (_a = user.privileges) === null || _a === void 0 ? void 0 : _a.includes("portal:admin:manageServers"); };
function isDeveloper(subscriptionInfo) {
  const devSubscriptionTypes = ["Trial Developer", "Developer", "Developer Subscription"];
  return devSubscriptionTypes.includes(subscriptionInfo === null || subscriptionInfo === void 0 ? void 0 : subscriptionInfo.type);
}
function isOrgAdmin(user) {
  return getUserRole(user) === "org_admin" || getUserRole(user) === "account_admin";
}
function isOrgUser(user) {
  return getUserRole(user) === "org_user" || getUserRole(user) === "account_user";
}
function isOrgPublisher(user) {
  return getUserRole(user) === "org_publisher" || getUserRole(user) === "account_publisher";
}
function isCustomRole(user) {
  // The Home App collapse the `roleId` and `role` into a single `id` property, that's why
  //  https://devtopia.esri.com/WebGIS/arcgis-portal-app/blob/master/src/js/arcgisonline/sharing/dijit/Role.ts#L469 works
  // In practice, we only need to check if `roleId` exist
  //  https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/44682#issuecomment-4146866
  return !!user.roleId && user.roleId.length > 0;
}
/**
 * Checks whether the user is allowed to update other user's items in their organization.
 */
function canUpdateOrgItems(user) {
  return (user.privileges || []).includes("portal:admin:updateItems");
}
const canDeleteOrgItems = (user) => { var _a; return (_a = user.privileges) === null || _a === void 0 ? void 0 : _a.includes("portal:admin:deleteItems"); };
/**
 * Checks to ensure the portal is an organization portal
 */
function isOrgPortal(portal) {
  return !!(portal.urlKey && portal.customBaseUrl) || !!portal.isPortal;
}
/**
 * Checks whether the user is allowed to share their item to groups
 */
function canShareItemToGroup(user) {
  return (user.privileges || []).includes("portal:user:shareToGroup");
}
/**
 * Checks whether the user can share an item on a given portal
 */
function canShare(user, portal) {
  return (!isOrgPortal(portal) ||
    canShareItemToGroup(user) ||
    canShareItemToOrg(user) ||
    (!!portal.canSharePublic && canShareItemToPublic(user)));
}
/**
 * Checks whether the user is allowed to share their item ot the organization.
 */
function canShareItemToOrg(user) {
  return (user.privileges || []).includes("portal:user:shareToOrg");
}
/**
 * Checks whether the user is allowed to share their item to public
 */
function canShareItemToPublic(user) {
  return (user.privileges || []).includes("portal:user:shareToPublic");
}
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItemsToOrg(user) {
  return (user.privileges || []).includes("portal:admin:shareToOrg");
}
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItemsToPublic(user) {
  return (user.privileges || []).includes("portal:admin:shareToPublic");
}
/**
 * Checks whether the user can share other user's items
 */
function adminCanShareOthersItemToGroup(user) {
  return (user.privileges || []).includes("portal:admin:shareToGroup");
}
/**
 * Checks whether the user is in an allowed organization and has the power to manage collaborations
 */
function canManageCollaborations(config, user, portal, subscriptionInfo) {
  const excludedOrgTypes = ["Trial", "Trial Press", "Trial Developer", "Developer Subscription", "Evaluation"];
  const isValidOrgType = subscriptionInfo && !excludedOrgTypes.includes(subscriptionInfo.type);
  const hasPrivilege = ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:manageCollaborations");
  return !!((config === null || config === void 0 ? void 0 : config.collaborationsEnabled) &&
    user &&
    (isOrgAdmin(user) || hasPrivilege) &&
    ((portal === null || portal === void 0 ? void 0 : portal.isPortal) || isValidOrgType));
}
/**
 * Checks whether the user can view other organization users' items
 */
function canViewOrgItems(user) {
  return (user.privileges || []).includes("portal:admin:viewItems");
}
/**
 * Checks whether the user can view other organization users' items
 */
function canViewOthersOrgItems(user) {
  return !isCustomRole(user) || (isCustomRole(user) && canViewOrgItems(user));
}
// TODO: add unit tests
const hasAdminSharePrivilege = ({ items, user, portal }) => {
  const item = items[0];
  // enterprise incorrectly returns items owned by "esri_" as item control admin (WebGIS/arcgis-portal-app#38695)
  const owner = item.owner;
  const whitelistOwner = ["esri_livingatlas"];
  if (portal.isPortal && owner !== user.username && owner.includes("esri_") && !whitelistOwner.includes(owner)) {
    return false;
  }
  const isOwnerOrAdmin = userIsItemAdmin(item, user);
  const isCustom = isCustomRole(user);
  const canShareOrgItems = canShareOthersItems(user);
  const canUpdateAndShare = canUpdateItem(item, user) &&
    canUpdateOrgItems(user) &&
    !isCustom &&
    (canShare(user, portal) || canShareOthersItems(user));
  // if it's the item owner or admin, or custom admin who can share
  return isOwnerOrAdmin || canUpdateAndShare || (itemsBelongToUserOrg(items, user) && canShareOrgItems);
};
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItems(user) {
  return adminCanShareOthersItemToGroup(user) || canShareOthersItemsToOrg(user) || canShareOthersItemsToPublic(user);
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZnVuY3RpLWM4ZDVjYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVpTTs7Ozs7Ozs7Ozs7Ozs7OztBQzdJak07QUFDQTtBQUNBO0FBQ0E7QUFDNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlLGlEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpREFBVztBQUN0RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0RBQXdELGlEQUFXO0FBQ25FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JNNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0EsNENBQTRDLDJCQUEyQixrQ0FBa0MsWUFBWSxZQUFZLFlBQVk7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkVBQTZFO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0EsMEZBQTBGLElBQUk7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1DQUFtQyxlQUFlLE9BQU87O0FBRTNHLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb3lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC1jODJmNWFiOS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9pbmRleC04MWQ1NDhiNy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9wcml2aWxlZ2VzLWNjZDVmMzdkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHYzLjAuOTlcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgIHJldHVybiBzdGF0dXM7XG4gIH1cbiAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgIH0sIGRlbGF5KTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICBjb25zdCBvYmpzID0gW107XG4gIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG4iLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2My4wLjk5XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVuZGVyaW5nUmVmLCBmIGFzIGZvcmNlVXBkYXRlIH0gZnJvbSAnLi9pbmRleC05MmViYjM5Ni5qcyc7XG5cbmNvbnN0IGFwcGVuZFRvTWFwID0gKG1hcCwgcHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSBtYXAuZ2V0KHByb3BOYW1lKTtcbiAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgIG1hcC5zZXQocHJvcE5hbWUsIFt2YWx1ZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXRlbXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBkZWJvdW5jZSA9IChmbiwgbXMpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcG9zc2libGUgZWxlbWVudCBpc0Nvbm5lY3RlZC5cbiAqIFRoZSBwcm9wZXJ0eSBtaWdodCBub3QgYmUgdGhlcmUsIHNvIHdlIGNoZWNrIGZvciBpdC5cbiAqXG4gKiBXZSB3YW50IGl0IHRvIHJldHVybiB0cnVlIGlmIGlzQ29ubmVjdGVkIGlzIG5vdCBhIHByb3BlcnR5LFxuICogb3RoZXJ3aXNlIHdlIHdvdWxkIHJlbW92ZSB0aGVzZSBlbGVtZW50cyBhbmQgd291bGQgbm90IHVwZGF0ZS5cbiAqXG4gKiBCZXR0ZXIgbGVhayBpbiBFZGdlIHRoYW4gdG8gYmUgdXNlbGVzcy5cbiAqL1xuY29uc3QgaXNDb25uZWN0ZWQgPSAobWF5YmVFbGVtZW50KSA9PiAhKCdpc0Nvbm5lY3RlZCcgaW4gbWF5YmVFbGVtZW50KSB8fCBtYXliZUVsZW1lbnQuaXNDb25uZWN0ZWQ7XG5jb25zdCBjbGVhbnVwRWxlbWVudHMgPSBkZWJvdW5jZSgobWFwKSA9PiB7XG4gICAgZm9yIChsZXQga2V5IG9mIG1hcC5rZXlzKCkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5nZXQoa2V5KS5maWx0ZXIoaXNDb25uZWN0ZWQpKTtcbiAgICB9XG59LCAyMDAwKTtcbmNvbnN0IHN0ZW5jaWxTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnZXRSZW5kZXJpbmdSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhIHN0ZW5jaWwgcHJvamVjdCwgd2UgZG8gbm90aGluZy5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IGV4cG9ydGVkIGJ5IEBzdGVuY2lsL2NvcmUuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxtc1RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3Bvc2U6ICgpID0+IGVsbXNUb1VwZGF0ZS5jbGVhcigpLFxuICAgICAgICBnZXQ6IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gZ2V0UmVuZGVyaW5nUmVmKCk7XG4gICAgICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kVG9NYXAoZWxtc1RvVXBkYXRlLCBwcm9wTmFtZSwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxtc1RvVXBkYXRlLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbG1zVG9VcGRhdGUuc2V0KHByb3BOYW1lLCBlbGVtZW50cy5maWx0ZXIoZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgZWxtc1RvVXBkYXRlLmZvckVhY2goKGVsbXMpID0+IGVsbXMuZm9yRWFjaChmb3JjZVVwZGF0ZSkpO1xuICAgICAgICAgICAgY2xlYW51cEVsZW1lbnRzKGVsbXNUb1VwZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IHVud3JhcCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID8gdmFsKCkgOiB2YWwpO1xuY29uc3QgY3JlYXRlT2JzZXJ2YWJsZU1hcCA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSA9IChhLCBiKSA9PiBhICE9PSBiKSA9PiB7XG4gICAgY29uc3QgdW53cmFwcGVkU3RhdGUgPSB1bndyYXAoZGVmYXVsdFN0YXRlKTtcbiAgICBsZXQgc3RhdGVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh1bndyYXBwZWRTdGF0ZSAhPT0gbnVsbCAmJiB1bndyYXBwZWRTdGF0ZSAhPT0gdm9pZCAwID8gdW53cmFwcGVkU3RhdGUgOiB7fSkpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgICBkaXNwb3NlOiBbXSxcbiAgICAgICAgZ2V0OiBbXSxcbiAgICAgICAgc2V0OiBbXSxcbiAgICAgICAgcmVzZXQ6IFtdLFxuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gV2hlbiByZXNldHRpbmcgdGhlIHN0YXRlLCB0aGUgZGVmYXVsdCBzdGF0ZSBtYXkgYmUgYSBmdW5jdGlvbiAtIHVud3JhcCBpdCB0byBpbnZva2UgaXQuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHN0YXRlIHdvbid0IGJlIHByb3Blcmx5IHJlc2V0XG4gICAgICAgIHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoKF9hID0gdW53cmFwKGRlZmF1bHRTdGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSk7XG4gICAgICAgIGhhbmRsZXJzLnJlc2V0LmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZmlyc3QgZGlzcG9zZSBhcyByZXNldHRpbmcgdGhlIHN0YXRlIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIGxlc3MgdXBkYXRlcyA7KVxuICAgICAgICBoYW5kbGVycy5kaXNwb3NlLmZvckVhY2goKGNiKSA9PiBjYigpKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGdldCA9IChwcm9wTmFtZSkgPT4ge1xuICAgICAgICBoYW5kbGVycy5nZXQuZm9yRWFjaCgoY2IpID0+IGNiKHByb3BOYW1lKSk7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldCA9IChwcm9wTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSh2YWx1ZSwgb2xkVmFsdWUsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgc3RhdGVzLnNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSwgdmFsdWUsIG9sZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0gKHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7fVxuICAgICAgICA6IG5ldyBQcm94eSh1bndyYXBwZWRTdGF0ZSwge1xuICAgICAgICAgICAgZ2V0KF8sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGVzLmtleXMoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhcyhfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXMuaGFzKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoXywgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgY29uc3Qgb24gPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBoYW5kbGVyc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGhhbmRsZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKHByb3BOYW1lLCBjYikgPT4ge1xuICAgICAgICBjb25zdCB1blNldCA9IG9uKCdzZXQnLCAoa2V5LCBuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVud3JhcCB0aGUgZGVmYXVsdFN0YXRlIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG1pZ2h0IG5vdCBiZSBzZW5kaW5nIHRoZSByaWdodCByZXNldCB2YWx1ZS5cbiAgICAgICAgY29uc3QgdW5SZXNldCA9IG9uKCdyZXNldCcsICgpID0+IGNiKHVud3JhcChkZWZhdWx0U3RhdGUpW3Byb3BOYW1lXSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5TZXQoKTtcbiAgICAgICAgICAgIHVuUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZSA9ICguLi5zdWJzY3JpcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3VicyA9IHN1YnNjcmlwdGlvbnMucmVkdWNlKCh1bnN1YnMsIHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignc2V0Jywgc3Vic2NyaXB0aW9uLnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5nZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbignZ2V0Jywgc3Vic2NyaXB0aW9uLmdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5yZXNldCkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdyZXNldCcsIHN1YnNjcmlwdGlvbi5yZXNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5kaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2Rpc3Bvc2UnLCBzdWJzY3JpcHRpb24uZGlzcG9zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuc3VicztcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5zdWJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaGFuZGxlcnMuc2V0LmZvckVhY2goKGNiKSA9PiBjYihrZXksIG9sZFZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBvbixcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHVzZSxcbiAgICAgICAgZGlzcG9zZSxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIGZvcmNlVXBkYXRlLFxuICAgIH07XG59O1xuY29uc3QgcmVtb3ZlRnJvbUFycmF5ID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBhcnJheS5sZW5ndGgtLTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChkZWZhdWx0U3RhdGUsIHNob3VsZFVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IGNyZWF0ZU9ic2VydmFibGVNYXAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpO1xuICAgIG1hcC51c2Uoc3RlbmNpbFN1YnNjcmlwdGlvbigpKTtcbiAgICByZXR1cm4gbWFwO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUgYXMgYyB9O1xuIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjMuMC45OVxuICovXG5jb25zdCBzcGVjaWFsQ2hhcmFjdGVyc1JlZ0V4cCA9IC9cXCt8XFw/fFxcL3xcXCh8XFwpfFxcXFx8XFwhfFxcI3xcXFwifFxcfHxcXCp8XFw6fDx8PnxcXCV8XFwkfFxcQHxcXCd8XFxefFxcW3xcXF18XFwsfFxcPXxcXDsvZ2k7XG5jb25zdCBnZW9Kc29uUmVnRXhwID0gLyhcXC58b3V0cHV0Rm9ybWF0PSlqc29ufGdlb2pzb24kL2k7XG5jb25zdCBhZ3NSZWdFeHAgPSAvXFwvYWdzXFwvL2dpO1xuXG5jb25zdCBzZXJ2ZXJUeXBlcyA9IFwiTWFwU2VydmVyfEdlb2NvZGVTZXJ2ZXJ8R1BTZXJ2ZXJ8R2VvbWV0cnlTZXJ2ZXJ8SW1hZ2VTZXJ2ZXJ8TkFTZXJ2ZXJ8RmVhdHVyZVNlcnZlcnxHZW9EYXRhU2VydmVyfEdsb2JlU2VydmVyfE1vYmlsZVNlcnZlcnxXTVNlcnZlcnxTY2VuZVNlcnZlcnxWZWN0b3JUaWxlU2VydmVyfFN0cmVhbVNlcnZlcnxXb3Jrc3BhY2VTZXJ2ZXJ8R2VvZW5yaWNobWVudFNlcnZlcnxWaWRlb1NlcnZlclwiO1xuY29uc3QgcmVnZXhTZXJ2ZXJUeXBlID0gbmV3IFJlZ0V4cChgaHR0cC4rXFwvKCR7c2VydmVyVHlwZXN9KWApO1xuY29uc3QgdmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGggPSBgXFwvYXJjZ2lzXFwvcmVzdFxcL3NlcnZpY2VzfFxcL3Jlc3RcXC9zZXJ2aWNlc3xcXC9hcmNnaXNcXC9zZXJ2aWNlc3xcXC9hcmNnaXNcXC9yZXN0YDtcbmNvbnN0IHNlcnZlckluZm9FeHAgPSBgKD88c2VydmVyPmh0dHAuKyg/OiR7dmFsaWRBcmNnaXNSZXN0U2VydmljZVBhdGh9KSg/OlxcLz8uKlxcLyg/PG5hbWU+LiopXFwvKD88dHlwZT4ke3NlcnZlclR5cGVzfSkpKSg/IS4qXFwvJHtzZXJ2ZXJUeXBlc30pXFwvPyg/PHNvZT5cXFxcZCspPy4qYDtcbi8qKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGlucHV0IHVybCwgYmFzZSBzZXJ2ZXIgdXJsLCBzZXJ2ZXIgbmFtZSwgc2VydmVyIHR5cGUsIGFuZCBsYXllciBpbmRleCAoaWYgZW50ZXJlZCkuXG4gKiBFeGFtcGxlOiBbXG4gKiBcImh0dHBzOi8vc2FtcGxlc2VydmVyNi5hcmNnaXNvbmxpbmUuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL0ZlYXR1cmVTZXJ2ZXIvNTAwXCIsXG4gKiBcImh0dHBzOi8vc2FtcGxlc2VydmVyNi5hcmNnaXNvbmxpbmUuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1Rlc3RTZXJ2aWNlL0ZlYXR1cmVTZXJ2ZXJcIixcbiAqIFwiVGVzdFNlcnZpY2VcIixcbiAqIFwiRmVhdHVyZVNlcnZlclwiLFxuICogXCI1MDBcIlxuICogXSAgKi9cbmNvbnN0IHJlZ2V4U2VydmVySW5mbyA9IG5ldyBSZWdFeHAoc2VydmVySW5mb0V4cCwgXCJpXCIpO1xuXG5jb25zdCBwYXJzZUFHU1NlcnZlckluZm8gPSAodXJsKSA9PiB7XG4gIGNvbnN0IGV4dHJhY3RlZEluZm8gPSB1cmwubWF0Y2gocmVnZXhTZXJ2ZXJJbmZvKTtcbiAgaWYgKCFleHRyYWN0ZWRJbmZvKSB7XG4gICAgY29uc3QgY29udGFpbnNBR1MgPSB1cmwubWF0Y2goYWdzUmVnRXhwKTtcbiAgICAvLyBUeXBlIGlzIGFsd2F5cyBNYXBTZXJ2ZXIgZm9yIC9hZ3MvIHNlcnZpY2VzXG4gICAgcmV0dXJuIGNvbnRhaW5zQUdTID8geyBiYXNlU2VydmVyVXJsOiB1cmwsIHNlcnZlck5hbWU6IG51bGwsIHNlcnZlclR5cGU6IFwiTWFwU2VydmVyXCIsIGluZGV4OiBudWxsIH0gOiBudWxsO1xuICB9XG4gIGNvbnN0IFssIGJhc2VTZXJ2ZXJVcmwsIHNlcnZlck5hbWUsIHNlcnZlclR5cGUsIGluZGV4U3RyXSA9IGV4dHJhY3RlZEluZm87XG4gIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoaW5kZXhTdHIpO1xuICByZXR1cm4geyBiYXNlU2VydmVyVXJsLCBzZXJ2ZXJOYW1lLCBzZXJ2ZXJUeXBlLCBpbmRleDogaXNOYU4oaW5kZXgpID8gbnVsbCA6IGluZGV4IH07XG59O1xuY29uc3QgZ2V0UmVzdFVybEZyb21VcmwgPSAodXJsKSA9PiB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZXh0cmFjdGVkSW5mbyA9IHVybC5tYXRjaCh2YWxpZEFyY2dpc1Jlc3RTZXJ2aWNlUGF0aCk7XG4gIGlmICghZXh0cmFjdGVkSW5mbykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiL3Jlc3RcIik7XG4gIHJldHVybiB1cmxQYXJ0cy5sZW5ndGggPCAyID8gbnVsbCA6IGAke3VybFBhcnRzWzBdfS9yZXN0L2A7XG59O1xuY29uc3QgYWRkVHJhaWxpbmdTbGFzaElmTWlzc2luZyA9ICh1cmwpID0+IHVybCAmJiB1cmwuY2hhckF0KHVybC5sZW5ndGggLSAxKSAhPT0gXCIvXCIgPyBgJHt1cmx9L2AgOiB1cmw7XG5cbmZ1bmN0aW9uIGlzRXNyaShpdGVtKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICEhKChfYSA9IGl0ZW0ub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiZXNyaVwiKSk7XG59XG5mdW5jdGlvbiBpc1ByZW1pdW0oaXRlbSkge1xuICB2YXIgX2E7XG4gIHJldHVybiBpc0VzcmkoaXRlbSkgJiYgISEoKF9hID0gaXRlbS50eXBlS2V5d29yZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhcIlJlcXVpcmVzIENyZWRpdHNcIikpO1xufVxuZnVuY3Rpb24gaXNTdWJzY3JpYmVyKGl0ZW0pIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gaXNFc3JpKGl0ZW0pICYmICEhKChfYSA9IGl0ZW0udHlwZUtleXdvcmRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJSZXF1aXJlcyBTdWJzY3JpcHRpb25cIikpO1xufVxuZnVuY3Rpb24gaXNPd25lcihpdGVtLCB1c2VyKSB7XG4gIHJldHVybiBpdGVtLm93bmVyID09PSB1c2VyLnVzZXJuYW1lO1xufVxuLyoqXG4gKiBDYW4gdGhlIHVzZXIgdXBkYXRlIHRoZSBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNhblVwZGF0ZUl0ZW0oaXRlbSwgdXNlcikge1xuICByZXR1cm4gdXNlcklzSXRlbUFkbWluKGl0ZW0sIHVzZXIpIHx8IGl0ZW0uaXRlbUNvbnRyb2wgPT09IFwidXBkYXRlXCI7XG59XG4vKipcbiAqIElzIHRoZSB1c2VyIGVpdGhlciBhbiBvd25lciBvciBhZG1pbiBvZiB0aGUgaXRlbVxuICovXG5mdW5jdGlvbiB1c2VySXNJdGVtQWRtaW4oaXRlbSwgdXNlcikge1xuICByZXR1cm4gaXNPd25lcihpdGVtLCB1c2VyKSB8fCBpc0l0ZW1BZG1pbihpdGVtLCB1c2VyKTtcbn1cbi8qKlxuICogRG9lcyB0aGUgdXNlciBoYXZlIGFkbWluIGNhcGFiaWxpdGllcyBvbiB0aGlzIGl0ZW1cbiAqL1xuZnVuY3Rpb24gaXNJdGVtQWRtaW4oaXRlbSwgdXNlcikge1xuICB2YXIgX2E7XG4gIC8vIGlmIHRoaXMgZmxhZyBpcyBhbHJlYWR5IHNldCAocHJvYmFibHkgaG9tZSBhcHApLCB1c2UgaXRcbiAgaWYgKGl0ZW0uaXNBZG1pbiAhPSBudWxsKSB7XG4gICAgcmV0dXJuICEhaXRlbS5pc0FkbWluO1xuICB9XG4gIGNvbnN0IGl0ZW1Pd25lciA9IGl0ZW0ub3duZXI7XG4gIGNvbnN0IGl0ZW1Db250cm9sQWRtaW4gPSBpdGVtLml0ZW1Db250cm9sID09PSBcImFkbWluXCI7XG4gIGNvbnN0IGVzcmlVc2VycyA9IFtcImVzcmlfbGl2aW5nYXRsYXNcIiwgXCJlc3JpX2RlbW9ncmFwaGljc1wiLCBcImVzcmlfYm91bmRhcmllc1wiXTtcbiAgaWYgKCgoX2EgPSBpdGVtLnBvcnRhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUG9ydGFsKSAmJlxuICAgICFpc093bmVyKGl0ZW0sIHVzZXIpICYmXG4gICAgaXRlbUNvbnRyb2xBZG1pbiAmJlxuICAgIGl0ZW1Pd25lci5pbmNsdWRlcyhcImVzcmlfXCIpICYmXG4gICAgLy8gcG9ydGFsIGluY29ycmVjdGx5IHJldHVybnMgXCJpdGVtQ29udHJvbD1cImFkbWluXCIgZm9yIGVzcmkgb3duZWQgaXRlbXNcbiAgICAhZXNyaVVzZXJzLmluY2x1ZGVzKGl0ZW1Pd25lcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGl0ZW1Db250cm9sQWRtaW47XG59XG5jb25zdCBpdGVtc0JlbG9uZ1RvVXNlck9yZyA9IChpdGVtcywgdXNlcikgPT4ge1xuICByZXR1cm4gISF1c2VyLm9yZ0lkICYmIGl0ZW1zLmV2ZXJ5KChpdGVtKSA9PiBpdGVtLmlzT3JnSXRlbSk7XG59O1xuY29uc3QgZ2V0SXRlbUhvbWVBcHBVcmwgPSAoaXRlbUlkLCBiYXNlVXJsKSA9PiBgJHthZGRUcmFpbGluZ1NsYXNoSWZNaXNzaW5nKGJhc2VVcmwpfWl0ZW0uaHRtbD9pZD0ke2l0ZW1JZH1gO1xuXG5jb25zdCBnZXRVc2VyUm9sZSA9ICh1c2VyKSA9PiB7IHZhciBfYTsgcmV0dXJuIHR5cGVvZiAodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGUpID09PSBcInN0cmluZ1wiICYmICEhKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5yb2xlKSA/IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5yb2xlIDogKF9hID0gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGVJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLmlkOyB9O1xuZnVuY3Rpb24gaXNQdWJsaWNVc2VyKHVzZXIpIHtcbiAgcmV0dXJuIHVzZXIgJiYgIXVzZXIub3JnSWQ7XG59XG5mdW5jdGlvbiBpc0hvc3RlZFBvcnRhbChwb3J0YWwpIHtcbiAgcmV0dXJuICFwb3J0YWwuaXNQb3J0YWwgfHwgISFwb3J0YWwuaXNCYWNrZWRCeVNEUztcbn1cbmNvbnN0IGNhbk1hbmFnZVNlY3VyaXR5ID0gKHVzZXIpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdXNlci5wcml2aWxlZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46bWFuYWdlU2VjdXJpdHlcIik7IH07XG5jb25zdCBjYW5NYW5hZ2VTZXJ2ZXJzID0gKHVzZXIpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdXNlci5wcml2aWxlZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46bWFuYWdlU2VydmVyc1wiKTsgfTtcbmZ1bmN0aW9uIGlzRGV2ZWxvcGVyKHN1YnNjcmlwdGlvbkluZm8pIHtcbiAgY29uc3QgZGV2U3Vic2NyaXB0aW9uVHlwZXMgPSBbXCJUcmlhbCBEZXZlbG9wZXJcIiwgXCJEZXZlbG9wZXJcIiwgXCJEZXZlbG9wZXIgU3Vic2NyaXB0aW9uXCJdO1xuICByZXR1cm4gZGV2U3Vic2NyaXB0aW9uVHlwZXMuaW5jbHVkZXMoc3Vic2NyaXB0aW9uSW5mbyA9PT0gbnVsbCB8fCBzdWJzY3JpcHRpb25JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJzY3JpcHRpb25JbmZvLnR5cGUpO1xufVxuZnVuY3Rpb24gaXNPcmdBZG1pbih1c2VyKSB7XG4gIHJldHVybiBnZXRVc2VyUm9sZSh1c2VyKSA9PT0gXCJvcmdfYWRtaW5cIiB8fCBnZXRVc2VyUm9sZSh1c2VyKSA9PT0gXCJhY2NvdW50X2FkbWluXCI7XG59XG5mdW5jdGlvbiBpc09yZ1VzZXIodXNlcikge1xuICByZXR1cm4gZ2V0VXNlclJvbGUodXNlcikgPT09IFwib3JnX3VzZXJcIiB8fCBnZXRVc2VyUm9sZSh1c2VyKSA9PT0gXCJhY2NvdW50X3VzZXJcIjtcbn1cbmZ1bmN0aW9uIGlzT3JnUHVibGlzaGVyKHVzZXIpIHtcbiAgcmV0dXJuIGdldFVzZXJSb2xlKHVzZXIpID09PSBcIm9yZ19wdWJsaXNoZXJcIiB8fCBnZXRVc2VyUm9sZSh1c2VyKSA9PT0gXCJhY2NvdW50X3B1Ymxpc2hlclwiO1xufVxuZnVuY3Rpb24gaXNDdXN0b21Sb2xlKHVzZXIpIHtcbiAgLy8gVGhlIEhvbWUgQXBwIGNvbGxhcHNlIHRoZSBgcm9sZUlkYCBhbmQgYHJvbGVgIGludG8gYSBzaW5nbGUgYGlkYCBwcm9wZXJ0eSwgdGhhdCdzIHdoeVxuICAvLyAgaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAvYmxvYi9tYXN0ZXIvc3JjL2pzL2FyY2dpc29ubGluZS9zaGFyaW5nL2Rpaml0L1JvbGUudHMjTDQ2OSB3b3Jrc1xuICAvLyBJbiBwcmFjdGljZSwgd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGByb2xlSWRgIGV4aXN0XG4gIC8vICBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvNDQ2ODIjaXNzdWVjb21tZW50LTQxNDY4NjZcbiAgcmV0dXJuICEhdXNlci5yb2xlSWQgJiYgdXNlci5yb2xlSWQubGVuZ3RoID4gMDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byB1cGRhdGUgb3RoZXIgdXNlcidzIGl0ZW1zIGluIHRoZWlyIG9yZ2FuaXphdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FuVXBkYXRlT3JnSXRlbXModXNlcikge1xuICByZXR1cm4gKHVzZXIucHJpdmlsZWdlcyB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46dXBkYXRlSXRlbXNcIik7XG59XG5jb25zdCBjYW5EZWxldGVPcmdJdGVtcyA9ICh1c2VyKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVzZXIucHJpdmlsZWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwicG9ydGFsOmFkbWluOmRlbGV0ZUl0ZW1zXCIpOyB9O1xuLyoqXG4gKiBDaGVja3MgdG8gZW5zdXJlIHRoZSBwb3J0YWwgaXMgYW4gb3JnYW5pemF0aW9uIHBvcnRhbFxuICovXG5mdW5jdGlvbiBpc09yZ1BvcnRhbChwb3J0YWwpIHtcbiAgcmV0dXJuICEhKHBvcnRhbC51cmxLZXkgJiYgcG9ydGFsLmN1c3RvbUJhc2VVcmwpIHx8ICEhcG9ydGFsLmlzUG9ydGFsO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBpcyBhbGxvd2VkIHRvIHNoYXJlIHRoZWlyIGl0ZW0gdG8gZ3JvdXBzXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlSXRlbVRvR3JvdXAodXNlcikge1xuICByZXR1cm4gKHVzZXIucHJpdmlsZWdlcyB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6dXNlcjpzaGFyZVRvR3JvdXBcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGNhbiBzaGFyZSBhbiBpdGVtIG9uIGEgZ2l2ZW4gcG9ydGFsXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlKHVzZXIsIHBvcnRhbCkge1xuICByZXR1cm4gKCFpc09yZ1BvcnRhbChwb3J0YWwpIHx8XG4gICAgY2FuU2hhcmVJdGVtVG9Hcm91cCh1c2VyKSB8fFxuICAgIGNhblNoYXJlSXRlbVRvT3JnKHVzZXIpIHx8XG4gICAgKCEhcG9ydGFsLmNhblNoYXJlUHVibGljICYmIGNhblNoYXJlSXRlbVRvUHVibGljKHVzZXIpKSk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gc2hhcmUgdGhlaXIgaXRlbSBvdCB0aGUgb3JnYW5pemF0aW9uLlxuICovXG5mdW5jdGlvbiBjYW5TaGFyZUl0ZW1Ub09yZyh1c2VyKSB7XG4gIHJldHVybiAodXNlci5wcml2aWxlZ2VzIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDp1c2VyOnNoYXJlVG9PcmdcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gc2hhcmUgdGhlaXIgaXRlbSB0byBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY2FuU2hhcmVJdGVtVG9QdWJsaWModXNlcikge1xuICByZXR1cm4gKHVzZXIucHJpdmlsZWdlcyB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6dXNlcjpzaGFyZVRvUHVibGljXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXNUb09yZyh1c2VyKSB7XG4gIHJldHVybiAodXNlci5wcml2aWxlZ2VzIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvT3JnXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyh1c2VyKSB7XG4gIHJldHVybiAodXNlci5wcml2aWxlZ2VzIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvUHVibGljXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGFkbWluQ2FuU2hhcmVPdGhlcnNJdGVtVG9Hcm91cCh1c2VyKSB7XG4gIHJldHVybiAodXNlci5wcml2aWxlZ2VzIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvR3JvdXBcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGluIGFuIGFsbG93ZWQgb3JnYW5pemF0aW9uIGFuZCBoYXMgdGhlIHBvd2VyIHRvIG1hbmFnZSBjb2xsYWJvcmF0aW9uc1xuICovXG5mdW5jdGlvbiBjYW5NYW5hZ2VDb2xsYWJvcmF0aW9ucyhjb25maWcsIHVzZXIsIHBvcnRhbCwgc3Vic2NyaXB0aW9uSW5mbykge1xuICBjb25zdCBleGNsdWRlZE9yZ1R5cGVzID0gW1wiVHJpYWxcIiwgXCJUcmlhbCBQcmVzc1wiLCBcIlRyaWFsIERldmVsb3BlclwiLCBcIkRldmVsb3BlciBTdWJzY3JpcHRpb25cIiwgXCJFdmFsdWF0aW9uXCJdO1xuICBjb25zdCBpc1ZhbGlkT3JnVHlwZSA9IHN1YnNjcmlwdGlvbkluZm8gJiYgIWV4Y2x1ZGVkT3JnVHlwZXMuaW5jbHVkZXMoc3Vic2NyaXB0aW9uSW5mby50eXBlKTtcbiAgY29uc3QgaGFzUHJpdmlsZWdlID0gKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucHJpdmlsZWdlcykgfHwgW10pLmluY2x1ZGVzKFwicG9ydGFsOmFkbWluOm1hbmFnZUNvbGxhYm9yYXRpb25zXCIpO1xuICByZXR1cm4gISEoKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5jb2xsYWJvcmF0aW9uc0VuYWJsZWQpICYmXG4gICAgdXNlciAmJlxuICAgIChpc09yZ0FkbWluKHVzZXIpIHx8IGhhc1ByaXZpbGVnZSkgJiZcbiAgICAoKHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5pc1BvcnRhbCkgfHwgaXNWYWxpZE9yZ1R5cGUpKTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgY2FuIHZpZXcgb3RoZXIgb3JnYW5pemF0aW9uIHVzZXJzJyBpdGVtc1xuICovXG5mdW5jdGlvbiBjYW5WaWV3T3JnSXRlbXModXNlcikge1xuICByZXR1cm4gKHVzZXIucHJpdmlsZWdlcyB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46dmlld0l0ZW1zXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gdmlldyBvdGhlciBvcmdhbml6YXRpb24gdXNlcnMnIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblZpZXdPdGhlcnNPcmdJdGVtcyh1c2VyKSB7XG4gIHJldHVybiAhaXNDdXN0b21Sb2xlKHVzZXIpIHx8IChpc0N1c3RvbVJvbGUodXNlcikgJiYgY2FuVmlld09yZ0l0ZW1zKHVzZXIpKTtcbn1cbi8vIFRPRE86IGFkZCB1bml0IHRlc3RzXG5jb25zdCBoYXNBZG1pblNoYXJlUHJpdmlsZWdlID0gKHsgaXRlbXMsIHVzZXIsIHBvcnRhbCB9KSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBpdGVtc1swXTtcbiAgLy8gZW50ZXJwcmlzZSBpbmNvcnJlY3RseSByZXR1cm5zIGl0ZW1zIG93bmVkIGJ5IFwiZXNyaV9cIiBhcyBpdGVtIGNvbnRyb2wgYWRtaW4gKFdlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcCMzODY5NSlcbiAgY29uc3Qgb3duZXIgPSBpdGVtLm93bmVyO1xuICBjb25zdCB3aGl0ZWxpc3RPd25lciA9IFtcImVzcmlfbGl2aW5nYXRsYXNcIl07XG4gIGlmIChwb3J0YWwuaXNQb3J0YWwgJiYgb3duZXIgIT09IHVzZXIudXNlcm5hbWUgJiYgb3duZXIuaW5jbHVkZXMoXCJlc3JpX1wiKSAmJiAhd2hpdGVsaXN0T3duZXIuaW5jbHVkZXMob3duZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzT3duZXJPckFkbWluID0gdXNlcklzSXRlbUFkbWluKGl0ZW0sIHVzZXIpO1xuICBjb25zdCBpc0N1c3RvbSA9IGlzQ3VzdG9tUm9sZSh1c2VyKTtcbiAgY29uc3QgY2FuU2hhcmVPcmdJdGVtcyA9IGNhblNoYXJlT3RoZXJzSXRlbXModXNlcik7XG4gIGNvbnN0IGNhblVwZGF0ZUFuZFNoYXJlID0gY2FuVXBkYXRlSXRlbShpdGVtLCB1c2VyKSAmJlxuICAgIGNhblVwZGF0ZU9yZ0l0ZW1zKHVzZXIpICYmXG4gICAgIWlzQ3VzdG9tICYmXG4gICAgKGNhblNoYXJlKHVzZXIsIHBvcnRhbCkgfHwgY2FuU2hhcmVPdGhlcnNJdGVtcyh1c2VyKSk7XG4gIC8vIGlmIGl0J3MgdGhlIGl0ZW0gb3duZXIgb3IgYWRtaW4sIG9yIGN1c3RvbSBhZG1pbiB3aG8gY2FuIHNoYXJlXG4gIHJldHVybiBpc093bmVyT3JBZG1pbiB8fCBjYW5VcGRhdGVBbmRTaGFyZSB8fCAoaXRlbXNCZWxvbmdUb1VzZXJPcmcoaXRlbXMsIHVzZXIpICYmIGNhblNoYXJlT3JnSXRlbXMpO1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgY2FuIHNoYXJlIG90aGVyIHVzZXIncyBpdGVtc1xuICovXG5mdW5jdGlvbiBjYW5TaGFyZU90aGVyc0l0ZW1zKHVzZXIpIHtcbiAgcmV0dXJuIGFkbWluQ2FuU2hhcmVPdGhlcnNJdGVtVG9Hcm91cCh1c2VyKSB8fCBjYW5TaGFyZU90aGVyc0l0ZW1zVG9PcmcodXNlcikgfHwgY2FuU2hhcmVPdGhlcnNJdGVtc1RvUHVibGljKHVzZXIpO1xufVxuXG5leHBvcnQgeyBhZG1pbkNhblNoYXJlT3RoZXJzSXRlbVRvR3JvdXAgYXMgQSwgY2FuU2hhcmVPdGhlcnNJdGVtc1RvT3JnIGFzIEIsIGNhblNoYXJlSXRlbVRvUHVibGljIGFzIEMsIGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyBhcyBELCBoYXNBZG1pblNoYXJlUHJpdmlsZWdlIGFzIEUsIGl0ZW1zQmVsb25nVG9Vc2VyT3JnIGFzIEYsIGNhblZpZXdPdGhlcnNPcmdJdGVtcyBhcyBHLCBpc1N1YnNjcmliZXIgYXMgYSwgaXNQcmVtaXVtIGFzIGIsIGlzRGV2ZWxvcGVyIGFzIGMsIGFkZFRyYWlsaW5nU2xhc2hJZk1pc3NpbmcgYXMgZCwgaXNPcmdBZG1pbiBhcyBlLCBjYW5NYW5hZ2VTZWN1cml0eSBhcyBmLCBjYW5NYW5hZ2VTZXJ2ZXJzIGFzIGcsIGNhblVwZGF0ZU9yZ0l0ZW1zIGFzIGgsIGlzT3duZXIgYXMgaSwgY2FuRGVsZXRlT3JnSXRlbXMgYXMgaiwgaXNPcmdQdWJsaXNoZXIgYXMgaywgZ2V0UmVzdFVybEZyb21VcmwgYXMgbCwgZ2V0SXRlbUhvbWVBcHBVcmwgYXMgbSwgaXNQdWJsaWNVc2VyIGFzIG4sIGlzSG9zdGVkUG9ydGFsIGFzIG8sIHBhcnNlQUdTU2VydmVySW5mbyBhcyBwLCBnZW9Kc29uUmVnRXhwIGFzIHEsIGFnc1JlZ0V4cCBhcyByLCBzcGVjaWFsQ2hhcmFjdGVyc1JlZ0V4cCBhcyBzLCBpc0N1c3RvbVJvbGUgYXMgdCwgcmVnZXhTZXJ2ZXJUeXBlIGFzIHUsIHZhbGlkQXJjZ2lzUmVzdFNlcnZpY2VQYXRoIGFzIHYsIGNhbk1hbmFnZUNvbGxhYm9yYXRpb25zIGFzIHcsIGlzT3JnVXNlciBhcyB4LCBjYW5TaGFyZUl0ZW1Ub0dyb3VwIGFzIHksIGNhblNoYXJlSXRlbVRvT3JnIGFzIHogfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==